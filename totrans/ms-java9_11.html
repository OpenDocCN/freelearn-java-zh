<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">New Tools and Tool Enhancements</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we explored Java 9's new stack walker API and learned how it enables Java applications to walk the calling stack. This is a specialized functionality that is not often implemented in Java applications. That being said, the API may be good for some very special cases, such as for functionality that is delivered by a framework. You learned that if you develop framework-supporting application programming and you want code that depends on the caller context, then the stack walker API is for you. We also discovered that the API gives fast and optimized access to the call stack, implementing lazy access to the individual frames.</p>
<p>In this chapter, we will cover 16 <strong>Java Enhancement Proposals</strong> (<strong>JEPs</strong>) that were incorporated into the Java 9 platform. These JEPs cover a wide range of tools and updates to APIs to make developing with Java easier, with greater optimization possibilities for our resulting programs.</p>
<p>Our review of new tools and tool enhancements will include the following:</p>
<ul>
<li>The new HTTP client</li>
<li>Javadoc and the Doclet API</li>
<li>mJRE changes</li>
<li>JavaScript parser</li>
<li>Multi-release JAR files</li>
<li>The Java-level JVM compiler interface</li>
<li>TIFF support</li>
<li>Platform logging</li>
<li>XML Catalogs</li>
<li>Collections</li>
<li>Platform-specific desktop features</li>
<li>Enhanced method handling</li>
<li>Enhanced deprecation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The new HTTP client [JEP-110]</h1>
                </header>
            
            <article>
                
<p>In this section, we will review Java's <strong>Hypertext Transfer Protocol</strong> (<strong>HTTP</strong>) client, starting with a pre-Java 9 look and then diving into the new HTTP client that is part of the Java 9 platform. This approach is needed to support an understanding of the changes made in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The HTTP client before Java 9</h1>
                </header>
            
            <article>
                
<p>JDK version 1.1 introduced the <kbd>HttpURLConnection</kbd> API that supported HTTP-specific features. This was a robust class that included the fields listed here:</p>
<ul>
<li><kbd><span>chunkLength</span></kbd></li>
<li><kbd><span>fixedContentLength</span></kbd></li>
<li><kbd><span>fixedContentLengthLong</span></kbd></li>
<li><kbd><span>HTTP_ACCEPTED</span></kbd></li>
<li><kbd><span>HTTP_BAD_GATEWAY</span></kbd></li>
<li><kbd><span>HTTP_BAD_METHOD</span></kbd></li>
<li><kbd><span>HTTP_BAD_REQUEST</span></kbd></li>
<li><kbd><span>HTTP_CLIENT_TIMEOUT</span></kbd></li>
<li><kbd><span>HTTP_CONFLICT</span></kbd></li>
<li><kbd><span>HTTP_CREATED</span></kbd></li>
<li><kbd><span>HTTP_ENTITY_TOO_LARGE</span></kbd></li>
<li><kbd><span>HTTP_FORBIDDEN</span></kbd></li>
<li><kbd><span>HTTP_GONE</span></kbd></li>
<li><kbd><span>HTTP_INTERNAL_ERROR</span></kbd></li>
<li><kbd><span>HTTP_LENGTH_REQUIRED</span></kbd></li>
<li><kbd><span>HTTP_MOVED_PERM</span></kbd></li>
<li><kbd><span>HTTP_MOVED_TEMP</span></kbd></li>
<li><kbd><span>HTTP_MULT_CHOICE</span></kbd></li>
<li><kbd><span>HTTP_NO_CONTENT</span></kbd></li>
<li><kbd><span>HTTP_NOT_ACCEPTABLE</span></kbd></li>
<li><kbd><span>HTTP_NOT_AUTHORITATIVE</span></kbd></li>
<li><kbd><span>HTTP_NOT_FOUND</span></kbd></li>
<li><kbd><span>HTTP_NOT_IMPLEMENTED</span></kbd></li>
<li><kbd><span>HTTP_NOT_MODIFIED</span></kbd></li>
<li><kbd><span>HTTP_OK</span></kbd></li>
<li><kbd><span>HTTP_PARTIAL</span></kbd></li>
<li><kbd><span>HTTP_PAYMENT_REQUIRED</span></kbd></li>
<li><kbd><span>HTTP_PRECON_FAILED</span></kbd></li>
<li><kbd><span>HTTP_PROXY_AUTH</span></kbd></li>
<li><kbd><span>HTTP_REQ_TOO_LONG</span></kbd></li>
<li><kbd><span>HTTP_RESET</span></kbd></li>
<li><kbd><span>HTTP_SEE_OTHER</span></kbd></li>
<li><kbd><span>HTTP_SERVER_ERROR</span></kbd></li>
<li><kbd><span>HTTP_UNAUTHORIZED</span></kbd></li>
<li><kbd><span>HTTP_UNAVAIABLE</span></kbd></li>
<li><kbd><span>HTTP_UNSUPPORTED_TYPE</span></kbd></li>
<li><kbd><span>HTTP_USE_PROXY</span></kbd></li>
<li><kbd><span>HTTP_VERSION</span></kbd></li>
<li><kbd><span>instanceFollowRedirects</span></kbd></li>
<li><kbd><span>method</span></kbd></li>
<li><kbd><span>responseCode</span></kbd></li>
<li><kbd><span>responseMessage</span></kbd></li>
</ul>
<p>As you can see from the list of fields, there was a great support for HTTP. In addition to a constructor, there are a plethora of available methods, including the following ones:</p>
<ul>
<li><kbd><span>disconnect()</span></kbd></li>
<li><kbd><span>getErrorStream()</span></kbd></li>
<li><kbd><span>getFollowRedirects()</span></kbd></li>
<li><kbd><span>getHeaderField(int n)</span></kbd></li>
<li><kbd><span>getHeaderFieldDate(String name, long Default)</span></kbd></li>
<li><kbd><span>getHeaderFieldKey(int n)</span></kbd></li>
<li><kbd><span>getInstanceFollowRedirects()</span></kbd></li>
<li><kbd><span>getPermission()</span></kbd></li>
<li><kbd><span>getRequestMethod()</span></kbd></li>
<li><kbd><span>getResponseCode()</span></kbd></li>
<li><kbd><span>getResponseMessage()</span></kbd></li>
<li><kbd><span>setChunkedStreamingMode(int chunklen)</span></kbd></li>
<li><kbd><span>setFixedLengthStreamingMode(int contentLength)</span></kbd></li>
<li><kbd><span>setFixedlengthStreamingMode(long contentLength)</span></kbd></li>
<li><kbd><span>setFollowRedirects(boolean set)</span></kbd></li>
<li><kbd><span>setInstanceFollowRedircts(boolean followRedirects)</span></kbd></li>
<li><kbd><span>setRequestMethod(String method)</span></kbd></li>
<li><kbd><span>usingProxy()</span></kbd></li>
</ul>
<p>The class methods <span>listed earlier</span> are in addition to the methods inherited from the <kbd>java.net.URLConnection</kbd> class and the <kbd>java.lang.Object</kbd> class.</p>
<p>There were problems with the original HTTP client that made it ripe for updating with the new Java platform. Those problems were as follows:</p>
<ul>
<li>The base <kbd>URLConnection</kbd> API had, defunct protocols such as Gopher and FTP <span>increasingly over the years</span></li>
<li>The <kbd>HttpURLConnection</kbd> API predated HTTP 1.1 and was overly abstract, making it less usable</li>
<li>The HTTP client was woefully under documented, making the API frustrating and difficult to use</li>
<li>The client only functioned on one thread at a time</li>
<li>The API was extremely difficult to maintain due to the above points about it predating HTTP 1.1 and it lacking sufficient documentation</li>
</ul>
<p>Now that we know what was wrong with the HTTP client, let's look at what's in store for Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java 9's new HTTP client</h1>
                </header>
            
            <article>
                
<p>There were several goals associated with creating the new HTTP client for the Java 9 platform. JEP-110 was the organizing proposal for the new HTTP client. The primary goals of JEP-110 are listed here and featured the creation of the new HTTP client presented. These goals are presented in the broad categories of ease of use, core capabilities, additional capabilities, and performance:</p>
<ul>
<li>Ease of use:
<ul>
<li>The API was designed to provide up to 90 percent of HTTP-related application requirements.</li>
<li>The new API is usable, without unnecessary complexity, for the most common use cases.</li>
<li>A simplistic blocking mode is included.</li>
<li>The API supports modern Java language features. Lambda expressions, a major new introduction released with Java 8, are an example.</li>
</ul>
</li>
<li>Core capabilities:
<ul>
<li>Supports HTTPS/TLS</li>
<li>Supports HTTP/2</li>
<li>Provides visibility on all details related to HTTP protocol requests and responses</li>
<li>Supports standard/common authentication mechanisms</li>
<li>Provides <strong>headers received</strong> event notifications</li>
<li>Provides <strong>response body received</strong> event notifications</li>
<li>Provides error event notifications</li>
</ul>
</li>
<li>Additional capabilities:
<ul>
<li>The new API can be used for WebSocket handshakes</li>
<li>It performs security checks in concert with the current networking API</li>
</ul>
</li>
<li>Performance:
<ul>
<li>For HTTP/1.1:
<ul>
<li>The new API must perform at least as efficiently as the previous API.</li>
<li>Memory consumption must not exceed that of Apache HttpClient, Netty, and Jetty, when being used as a client API.</li>
</ul>
</li>
<li>For HTTP/2:
<ul>
<li>Performance must exceed that of HTTP/1.1.</li>
<li>The new performance must match or exceed that of Netty and Jetty when being used as a client API. No performance degradation should be a result of the new client.</li>
<li>Memory consumption must not exceed that of Apache HttpClient, Netty, and Jetty, when being used as a client API.</li>
</ul>
</li>
<li>Avoids running timer threads</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New API limitations</h1>
                </header>
            
            <article>
                
<p>There are some intentional shortcomings of the new API. While this might sound counter-intuitive, the new API was not intended to completely replace the current <kbd>HttpURLConnection</kbd> API. Instead, the new API is intended to eventually replace the current one.</p>
<p>The following code snippet provides an example of how to implement the <kbd>HttpURLConnect</kbd> class to open and read a URL in a Java application:</p>
<pre class="brush: java">    /*<br/>    import statements<br/>    */

    public class HttpUrlConnectionExample
    {  
      public static void main(String[] args) 
      {
        new HttpUrlConnectionExample();
      }
  
      public HttpUrlConnectionExample()
      {<br/>        URL theUrl = null;<br/>        BufferedReader theReader = null;<br/>        StringBuilder theStringBuilder;<br/> <br/>        // put the URL into a String<br/>        String theUrl = "https://www.packtpub.com/";<br/><br/>        // here we are creating the connection<br/>        theUrl = new URL(theUrl);<br/>        HttpURLConnection theConnection = (HttpURLConnection) <br/>         theUrl.openConnection();<br/><br/>        theConnection.setRequestedMethod("GET");<br/><br/>        // add a delay <br/>        theConnection.setReadTimeout(30000); // 30 seconds
        theConnection.connect();<br/><br/>        // next, we can read the output<br/>        theReader = new BufferedReader(<br/>          new InputStreamReader(theConnection.getInputStream()));<br/>        theStringBuilder =  new StringBuilder();<br/><br/>        // read the output one line at a time<br/>        String theLine = null;<br/>        while ((theLine = theReader.readLine() != null)<br/>        {<br/>          theStringBUilder.append(line + "\n");<br/>        }<br/><br/>        // echo the output to the screen console<br/>        System.out.println(theStringBuilder.toString());<br/>    <br/>        // close the reader<br/>        theReader.close();<br/>      }<br/>    }<br/>    . . . </pre>
<div class="packt_infobox">The preceding code does not include exception handling for brevity.</div>
<p>Here are some specific limitations of the new API:</p>
<ul>
<li>Not all HTTP-related functionality is supported. It is estimated that about 10 percent of the HTTP's protocol is not exposed by the API.</li>
<li>Standard/common authentication mechanisms have been limited to basic authentication.</li>
<li>The overarching goal of the new API was the simplicity of use, which means that performance improvements might not be realized. Certainly, there will be no performance degradation, but there is not likely to be an overwhelming level of improvement, either.</li>
<li>There is no support for filtering on requests.</li>
<li>There is no support for filtering on responses.</li>
<li>The new API does not include a pluggable connection cache.</li>
<li>There is a lack of a general upgrade mechanism.</li>
</ul>
<p>The new API is delivered as part of the Java 9 platform in the incubator mode. This suggests that the API will be standardized in a future Java platform, perhaps with Java 10.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simplified Doclet API [JEP-221]</h1>
                </header>
            
            <article>
                
<p>The Doclet API and Javadoc are closely related. Javadoc is a documentation tool and the Doclet API provides functionality so that we can inspect the javadoc comments embedded at the source-levels of libraries and programs. In this section, we will review the pre-Java 9 status of the Doclet API and then explore the changes introduced to the Doclet API in the Java 9 platform. In the following section, we will review Javadoc.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pre-Java 9 Doclet API</h1>
                </header>
            
            <article>
                
<p>The pre-Java 9 Doclet API, or the <kbd>com.sun.javadoc</kbd> package, gives us access to look at javadoc comments located in the source code. Invoking a Doclet is accomplished by using the <kbd>start</kbd> method. That method's signature is <kbd>public static boolean start(RootDoc root)</kbd>. We will use the <kbd>RootDoc</kbd> instance as a container for the program structure information.</p>
<p>In order to call javadoc, we need to pass the following:</p>
<ul>
<li>Package names</li>
<li>Source file names (for classes and interfaces)</li>
<li>An access control option--one of the following:
<ul>
<li><kbd>package</kbd></li>
<li><kbd>private</kbd></li>
<li><kbd>protected</kbd></li>
<li><kbd>public</kbd></li>
</ul>
</li>
</ul>
<p>When the preceding listed items are used to call javadoc, a <strong>documented set</strong> is provided as a filtered list. If our aim is to obtain a comprehensive, unfiltered list, we can use <kbd>allClasses(false)</kbd>.</p>
<p>Let's review an example Doclet:</p>
<pre>    // Mandatory import statement.<br/>    import com.sun.javadoc.*;<br/><br/>    // We will be looking for all the @throws documentation tags.<br/>    public class AllThrowsTags extends Doclet <br/>    {<br/>      // This is used to invoke the Doclet.<br/>      public static boolean start(Rootdoc myRoot) <br/>      {<br/>        // "ClassDoc[]" here referes to classes and interfaces.<br/>        ClassDoc[] classesAndInterfaces = <br/>         myRoot.classesAndInterfaces();<br/>        for (int i = 0; i &lt; classesAndInterfaces.length; ++i)<br/>        {<br/>          ClassDoc tempCD = classesAndInterfaces[i];<br/>          printThrows(tempCD.contructors());<br/>          printThrows(tempCD.methods());<br/>        }<br/>        return true;<br/>      }<br/><br/>      static void printThrows(ExecutableMemberDoc[] theThrows)<br/>      {<br/>        for (int i = 0; i &lt; theThrows.length; ++i)<br/>        {<br/>          ThrowsTag[] throws = theThrows[i].throwsTags();<br/><br/>          // Print the "qualified name" which will be a the<br/>             class or <br/>          // interface name.<br/>          System.out.println(theThrows[i].qualifiedName());<br/><br/>          // A loop to print all comments with the Throws Tag that <br/>          // belongs to the previously printed class or<br/>             interface name<br/>          for (int j = 0; j &lt; throws.length; ++j)<br/>          {<br/>            // A println statement that calls three methods<br/>               from the <br/>            // ThrowsTag Interface: exceptionType(),<br/>               exceptionName(),<br/>            // and exceptionComment().<br/>            System.out.println("--&gt; TYPE: " +<br/>              throws[j].exceptionType() + <br/>              " | NAME: " + throws[j].exceptionName() + <br/>              " | COMMENT: " + throws[j].exceptionComment());<br/>          }<br/>        }<br/>      }<br/>    }</pre>
<p>As you can see by the thoroughly commented code, gaining access to the javadoc content is relatively easy. In our preceding example, we would invoke the <kbd>AllThrows</kbd> class using the following code in the command line:</p>
<pre><strong>javadoc -doclet AllThrowsTags -sourcepath &lt;source-location&gt; java.util</strong></pre>
<p>The output of our result will consist of the following structure:</p>
<pre><strong>&lt;class or interface name&gt;</strong><br/><strong>    TYPE: &lt;exception type&gt; | NAME: &lt;exception name&gt; | COMMENT: &lt;exception comment&gt;</strong><br/><strong>    TYPE: &lt;exception type&gt; | NAME: &lt;exception name&gt; | COMMENT: &lt;exception comment&gt;</strong><br/><strong>    TYPE: &lt;exception type&gt; | NAME: &lt;exception name&gt; | COMMENT: &lt;exception comment&gt;</strong><br/><strong>&lt;class or interface name&gt;</strong><br/><strong>    TYPE: &lt;exception type&gt; | NAME: &lt;exception name&gt; | COMMENT: &lt;exception comment&gt;</strong><br/><strong>    TYPE: &lt;exception type&gt; | NAME: &lt;exception name&gt; | COMMENT: &lt;exception comment&gt;</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API enums</h1>
                </header>
            
            <article>
                
<p>The API consists of one enum, <kbd>LanguageVersion</kbd>, which provides the Java programming language version. The constants for this enum are <kbd>Java_1_1</kbd> and <kbd>Java_1_5</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API classes</h1>
                </header>
            
            <article>
                
<p>The <kbd>Doclet</kbd> class provides an example of how to create a class to start a Doclet. It contains an empty <kbd>Doclet()</kbd> constructor and the following methods:</p>
<ul>
<li><kbd>languageVersion()</kbd></li>
<li><kbd>optionLength(String option)</kbd></li>
<li><kbd>start(RootDoc root)</kbd></li>
<li><kbd>validOptions(String[][] options, DocErrorReporter reporter)</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API interfaces</h1>
                </header>
            
            <article>
                
<p>The Doclet API contains the following listed interfaces. The interface names are self-describing. You can consult the documentation for additional details:</p>
<ul>
<li><kbd>AnnotatedType</kbd></li>
<li><kbd>AnnotationDesc</kbd></li>
<li><kbd>AnnotationDesc.ElementValuePair</kbd></li>
<li><kbd>AnnotationTypeDoc</kbd></li>
<li><kbd>AnnotationTypeElementDoc</kbd></li>
<li><kbd>AnnotationValue</kbd></li>
<li><kbd>ClassDoc</kbd></li>
<li><kbd>ConstructorDoc</kbd></li>
<li><kbd>Doc</kbd></li>
<li><kbd>DocErrorReporter</kbd></li>
<li><kbd>ExecutableMemberDoc</kbd></li>
<li><kbd>FieldDoc</kbd></li>
<li><kbd>MemberDoc</kbd></li>
<li><kbd>MethodDoc</kbd></li>
<li><kbd>PackageDoc</kbd></li>
<li><kbd>Parameter</kbd></li>
<li><kbd>ParameterizedType</kbd></li>
<li><kbd>ParamTag</kbd></li>
<li><kbd>ProgramElementDoc</kbd></li>
<li><kbd>RootDoc</kbd></li>
<li><kbd>SeeTag</kbd></li>
<li><kbd>SerialFieldTag</kbd></li>
<li><kbd>SourcePosition</kbd></li>
<li><kbd>Tag</kbd></li>
<li><kbd>ThrowsTag</kbd></li>
<li><kbd>Type</kbd></li>
<li><kbd>TypeVariable</kbd></li>
<li><kbd>WildcardType</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Problems with the pre-existing Doclet API</h1>
                </header>
            
            <article>
                
<p>Fueling the need for a new Doclet API were several issues with the pre-existing Doclet API:</p>
<ul>
<li>It was not ideal for testing or concurrent usage. This stemmed from its implementation of static methods.</li>
<li>The language model used in the API had several limitations and became more problematic with each successive Java upgrade.</li>
<li>The API was inefficient, largely due to its heavy use of substring matching.</li>
<li>There was no reference provided regarding the specific location of any given comment. This made diagnostics and troubleshooting difficult.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java 9's Doclet API</h1>
                </header>
            
            <article>
                
<p>Now that you have a good handle on the Doclet API as it existed prior to Java 9, let's look at what changes have been made and delivered with the Java 9 platform. The new Doclet API is in the <kbd>jdk.javadoc.doclet</kbd> package.</p>
<p>At a high level, the changes to the Doclet API are as follows:</p>
<ul>
<li>Updates the <kbd>com.sun.javadoc</kbd> Doclet API to take advantage of several Java SE and JDK APIs</li>
<li>Updates the <kbd>com.sun.tools.doclets.standard.Standard</kbd> Doclet to use the new API</li>
<li>Supports the updated Taglet API that is used to create custom javadoc tags</li>
</ul>
<p>In addition to the changes listed earlier, the new API uses the two APIs listed here:</p>
<ul>
<li>Compiler tree API</li>
<li>Language model API</li>
</ul>
<p>Let's explore each of these in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiler tree API</h1>
                </header>
            
            <article>
                
<p>The compiler tree API is in the <kbd>com.sun.source.doctree</kbd> package. It provides several interfaces to document source-level comments. These APIs are represented as <strong>Abstract Syntax Trees</strong> (<strong>ASTs</strong>).</p>
<p>There are two enums:</p>
<ul>
<li><kbd>AttributeTree.ValueKind</kbd> with the following constants:
<ul>
<li><kbd>DOUBLE</kbd></li>
<li><kbd>EMPTY</kbd></li>
<li><kbd>SINGLE</kbd></li>
<li><kbd>UNQUOTED</kbd></li>
</ul>
</li>
<li><kbd>DocTree.Kind</kbd> with the following constants:
<ul>
<li><kbd>ATTRIBUTE</kbd></li>
<li><kbd>AUTHOR</kbd></li>
<li><kbd>CODE</kbd></li>
<li><kbd>COMMENT</kbd></li>
<li><kbd>DEPRECATED</kbd></li>
<li><kbd>DOC_COMMENT</kbd></li>
<li><kbd>DOC_ROOT</kbd></li>
<li><kbd>END_ELEMENT</kbd></li>
<li><kbd>ENTITY</kbd></li>
<li><kbd>ERRONEOUS</kbd></li>
<li><kbd>EXCEPTION</kbd></li>
<li><kbd>IDENTIFIER</kbd></li>
<li><kbd>INHERIT_DOC</kbd></li>
<li><kbd>LINK</kbd></li>
<li><kbd>LINK_PLAIN</kbd></li>
<li><kbd>LITERAL</kbd></li>
<li><kbd>OTHER</kbd></li>
<li><kbd>PARAM</kbd></li>
<li><kbd>REFERENCE</kbd></li>
<li><kbd>RETURN</kbd></li>
<li><kbd>SEE</kbd></li>
<li><kbd>SERIAL</kbd></li>
<li><kbd>SERIAL_DATA</kbd></li>
<li><kbd>SERIAL_FIELD</kbd></li>
<li><kbd>SINCE</kbd></li>
<li><kbd>START_ELEMENT</kbd></li>
<li><kbd>TEXT</kbd></li>
<li><kbd>THROWS</kbd></li>
<li><kbd>UNKNOWN_BLOCK_TAG</kbd></li>
<li><kbd>UNKNOWN_INLINE_TAG</kbd></li>
<li><kbd>VALUE</kbd></li>
<li><kbd>VERSION</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>com.sun.source.doctree</kbd> package contains several interfaces. They are detailed in the following table:</p>
<table>
<tbody>
<tr>
<td><strong>Interface name</strong></td>
<td><strong>Extends</strong></td>
<td><strong>A tree node for:</strong></td>
<td><strong>Non-inherited methods</strong></td>
</tr>
<tr>
<td><kbd>AttributeTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>HTML element</td>
<td><kbd>getName()</kbd>, <kbd>getValue()</kbd>, <kbd>getValueKind()</kbd></td>
</tr>
<tr>
<td><kbd>AuthorTree</kbd></td>
<td><kbd>BlockTagTree</kbd>, <kbd>DocTree</kbd></td>
<td><kbd>@author</kbd> block tag</td>
<td><kbd>getName()</kbd></td>
</tr>
<tr>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>Base class for different types of block tags</td>
<td><kbd>getTagName()</kbd></td>
</tr>
<tr>
<td><kbd>CommentTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>An embedded HTML comment with the following HTML tags--<kbd>&lt;!--text--&gt;</kbd></td>
<td><kbd>getBody()</kbd></td>
</tr>
<tr>
<td><kbd>DeprecatedTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>@deprecated</kbd> block tag</td>
<td><kbd>getBody()</kbd></td>
</tr>
<tr>
<td><kbd>DocCommentTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>Body block tags</td>
<td><kbd>getBlockTags()</kbd>, <kbd>getBody()</kbd>, <kbd>getFirstSentence()</kbd></td>
</tr>
<tr>
<td><kbd>DocRootTree</kbd></td>
<td><kbd>InlineTagTree</kbd></td>
<td><kbd>@docroot</kbd> inline tag</td>
<td>N/A</td>
</tr>
<tr>
<td><kbd>DocTree</kbd></td>
<td>N/A</td>
<td>Common interface for all</td>
<td><kbd>accept(DocTreeVisitor&lt;R,D&gt;visitor,Ddata)</kbd>, <kbd>getKind()</kbd></td>
</tr>
<tr>
<td><kbd>DocTreeVisitor&lt;R,P&gt;</kbd></td>
<td>N/A</td>
<td><kbd>R</kbd> = return type of visitor's methods; <kbd>P</kbd> = type of the additional parameter</td>
<td><kbd>visitAttribute(AttributeTree node, P p)</kbd>, <kbd>visitAuthor(AuthorTree node, P p)</kbd>, <kbd>visitComment(CommentTree node, P p)</kbd>, <kbd>visitDeprecated(DeprecatedTree node, P p)</kbd>, <kbd>visitDocComment(DocCommentTree node, P p)</kbd>, <kbd>visitDocRoot(DocRootTree node, P p)</kbd>, <kbd>visitEndElement(EndElementTree node, P p)</kbd>, <kbd>visitEntity(EntityTree node, P p)</kbd>, <kbd>visitErroneous(ErroneousTree node, P p)</kbd>, <kbd>visitIdentifier(IdentifierTree node, P p)</kbd>, <kbd>visitInheritDoc(InheritDocTree node, P p)</kbd>, <kbd>visitLink(LinkTree node, P p)</kbd>, <kbd>visitLiteral(LiteralTree node, P p)</kbd>, <kbd>visitOther(DocTree node, P p)</kbd>, <kbd>visitParam(ParamTree node, P p)</kbd>, <kbd>visitReference(ReferenceTree node, P p)</kbd>, <kbd>visitReturn(ReturnTree node, P p)</kbd>, <kbd>visitSee(SeeTree node, P p)</kbd>, <kbd>visitSerial(SerialTree node, P p)</kbd>, <kbd>visitSerialData(SerialDataTree node, P p)</kbd>, <kbd>visitSerialField(SerialFieldTree node, P p)</kbd>, <kbd>visitSince(SinceTree node, P p)</kbd>, <kbd>visitStartElement(StartElementTree node, P p)</kbd>, <kbd>visitText(TextTree node, P p)</kbd>, <kbd>visitThrows(ThrowsTree node, P p)</kbd>, <kbd>visitUnknownBlockTag(UnknownBlockTagTree node, P p)</kbd>, <kbd>visitUnknownInlineTag(UnknownInlineTagTree node, P p)</kbd>, <kbd>visitValue(ValueTree node, P p)</kbd>, <kbd>visitVersion(VersionTree node, P p)</kbd></td>
</tr>
<tr>
<td><kbd>EndElementTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>End of an HTML element <kbd>&lt;/name&gt;</kbd></td>
<td><kbd>getName()</kbd></td>
</tr>
<tr>
<td><kbd>EntityTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>An HTML entity</td>
<td><kbd>getName()</kbd></td>
</tr>
<tr>
<td><kbd>ErroneousTree</kbd></td>
<td><kbd>TextTree</kbd></td>
<td>This is for malformed text</td>
<td><kbd>getDiagnostic()</kbd></td>
</tr>
<tr>
<td><kbd>IdentifierTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>An identifier in a comment</td>
<td><kbd>getName()</kbd></td>
</tr>
<tr>
<td><kbd>InheritDocTree</kbd></td>
<td><kbd>InlineTagTree</kbd></td>
<td>
<p class="mce-root"><kbd>@inheritDoc</kbd></p>
<p class="mce-root">inline tag</p>
</td>
<td>N/A</td>
</tr>
<tr>
<td><kbd>InlineTagTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>Common interface for inline tags</td>
<td><kbd>getTagName()</kbd></td>
</tr>
<tr>
<td><kbd>LinkTree</kbd></td>
<td><kbd>InlineTagTree</kbd></td>
<td><kbd>@link</kbd> or <kbd>@linkplan</kbd> inline tags</td>
<td><kbd>getLabel()</kbd>, <kbd>getReference()</kbd></td>
</tr>
<tr>
<td><kbd>LiteralTree</kbd></td>
<td><kbd>InlineTagTree</kbd></td>
<td><kbd>@literal</kbd> or <kbd>@code</kbd> inline tags</td>
<td><kbd>getBody()</kbd></td>
</tr>
<tr>
<td><kbd>ParamTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>@param</kbd> block tags</td>
<td><kbd>getDescription()</kbd>, <kbd>getName()</kbd>, <kbd>isTypeParameter()</kbd></td>
</tr>
<tr>
<td><kbd>ReferenceTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>Used to reference a Java lang element</td>
<td><kbd>getSignature()</kbd></td>
</tr>
<tr>
<td><kbd>ReturnTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>@return</kbd> block tags</td>
<td><kbd>getDescription()</kbd></td>
</tr>
<tr>
<td><kbd>SeeTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>@see</kbd> block tags</td>
<td><kbd>getReference()</kbd></td>
</tr>
<tr>
<td><kbd>SerialDataTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>@serialData</kbd> block tags</td>
<td><kbd>getDescription()</kbd></td>
</tr>
<tr>
<td><kbd>SerialFieldTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td>
<p class="mce-root"><kbd>@serialData</kbd> block tags and <kbd>@serialField</kbd></p>
<p class="mce-root">field names and descriptions</p>
</td>
<td><kbd>getDescription()</kbd>, <kbd>getName()</kbd>, <kbd>getType()</kbd></td>
</tr>
<tr>
<td><kbd>SerialTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>@serial</kbd> block tags</td>
<td><kbd>getDescription()</kbd></td>
</tr>
<tr>
<td><kbd>SinceTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>@since</kbd> block tags</td>
<td><kbd>getBody()</kbd></td>
</tr>
<tr>
<td><kbd>StartElementTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>Start of an HTML element <kbd>&lt; name [attributes] [/] &gt;</kbd></td>
<td><kbd>getAttributes()</kbd>, <kbd>getName()</kbd>, <kbd>isSelfClosing()</kbd></td>
</tr>
<tr>
<td><kbd>TextTree</kbd></td>
<td><kbd>DocTree</kbd></td>
<td>Plain text</td>
<td><kbd>getBody()</kbd></td>
</tr>
<tr>
<td><kbd>ThrowsTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>@exception</kbd> or <kbd>@throws</kbd> block tags</td>
<td><kbd>getDescription()</kbd>, <kbd>getExceptionname()</kbd></td>
</tr>
<tr>
<td><kbd>UnknownBlockTagTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td>
<p class="mce-root">Unrecognized</p>
<p class="mce-root">inline tags</p>
</td>
<td><kbd>getContent()</kbd></td>
</tr>
<tr>
<td><kbd>UnknownInlineTagTree</kbd></td>
<td><kbd>InlineTagTree</kbd></td>
<td>
<p class="mce-root">Unrecognized</p>
<p>inline tags</p>
</td>
<td><kbd>getContent()</kbd></td>
</tr>
<tr>
<td><kbd>ValueTree</kbd></td>
<td><kbd>InlineTagTree</kbd></td>
<td><kbd>@value</kbd> inline tags</td>
<td><kbd>getReference()</kbd></td>
</tr>
<tr>
<td><kbd>VersionTree</kbd></td>
<td><kbd>BlockTagTree</kbd></td>
<td><kbd>@version</kbd> block tags</td>
<td><kbd>getBody()</kbd></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Language model API</h1>
                </header>
            
            <article>
                
<p>The language model API is in the <kbd>java.lang.model</kbd> package. It includes packages and classes that are used for language processing and language modeling. It consists of the following components:</p>
<ul>
<li><kbd>AnnotatedConstruct</kbd> interface</li>
<li><kbd>SourceVersion</kbd> enum</li>
<li><kbd>UnknownEntityException</kbd> exception</li>
</ul>
<p>Each of these language model API components is further explored in the next three sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The AnnotatedConstruct interface</h1>
                </header>
            
            <article>
                
<p>The <kbd>AnnotatedConstruction</kbd> interface provides an annotatable construct to the language model API that has been part of the Java platform since version 1.8. It is applicable to constructs that are either an element (Interface <kbd>Element</kbd>) or a type (Interface <kbd>TypeMirror</kbd>). The annotations for each of these constructs differ, as shown in this table:</p>
<table>
<tbody>
<tr>
<td><strong>Construct type</strong></td>
<td><strong>Interface</strong></td>
<td><strong>Annotation</strong></td>
</tr>
<tr>
<td><kbd>element</kbd></td>
<td><kbd>Element</kbd></td>
<td>Declaration</td>
</tr>
<tr>
<td><kbd>type</kbd></td>
<td><kbd>TypeMirror</kbd></td>
<td>Based on use of a type name</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>AnnotatedConstruction</kbd> interface has three methods:</p>
<ul>
<li><kbd>getAnnotation(Class&lt;A&gt; annotationType)</kbd>: This method returns the type of the construct's annotation</li>
</ul>
<ul>
<li><kbd>getAnnotationMirrors()</kbd>: This method returns a list of annotations that are on the construct</li>
</ul>
<ul>
<li><kbd>getAnnotationsByType(Class&lt;A&gt; annotationType)</kbd>: This method returns the construct's associated annotations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The SourceVersion enum</h1>
                </header>
            
            <article>
                
<p>The <kbd>SourceVersion</kbd> enum consists of the following constants:</p>
<ul>
<li><kbd>RELEASE_0</kbd></li>
<li><kbd>RELEASE_1</kbd></li>
<li><kbd>RELEASE_2</kbd></li>
<li><kbd>RELEASE_3</kbd></li>
<li><kbd>RELEASE_4</kbd></li>
<li><kbd>RELEASE_5</kbd></li>
<li><kbd>RELEASE_6</kbd></li>
<li><kbd>RELEASE_7</kbd></li>
<li><kbd>RELEASE_8</kbd></li>
</ul>
<div class="packt_infobox">It is anticipated that the <kbd>SourceVersion</kbd> enum will be updated to include <kbd>RELEASE_9</kbd> once the Java 9 platform has been officially released.</div>
<p>This enum also contains several methods, which are as follows:</p>
<p><strong>Method name</strong>: <kbd>isIdentifier</kbd></p>
<p><kbd>public static boolean isIdentifier(CharSequence name)</kbd></p>
<p>This method returns <kbd>true</kbd> if the parameter string is a Java identifier or keyword.</p>
<p><strong>Method name</strong>: <kbd>isKeyword</kbd></p>
<p><kbd>public static boolean isKeyword(CharSequence s)</kbd></p>
<p>This method returns <kbd>true</kbd> if the given <kbd>CharSequence</kbd> is a literal or keyword.</p>
<p><strong>Method name</strong>: <kbd>isName</kbd></p>
<p><kbd>public static boolean isName(CharSequence name)</kbd></p>
<p>This method returns <kbd>true</kbd> if the <kbd>CharSequence</kbd> is a valid name.</p>
<p><strong>Method name</strong>: <kbd>latest</kbd></p>
<p><kbd>public static SourceVersion latest()</kbd></p>
<p>This method returns the latest source version for modeling purposes.</p>
<p><strong>Method name</strong>: <kbd>latestSupported</kbd></p>
<p><kbd>public static SourceVersion latestSupported()</kbd></p>
<p>This method returns the latest source version that can be fully supported for modeling.</p>
<p><strong>Method name</strong>: <kbd>valueOf</kbd></p>
<p><kbd>public static SourceVersion valueOf(String name)</kbd></p>
<p>This method returns the enum constant based on the parameter string provided.</p>
<div class="packt_tip">You should be aware that the <kbd>value(String name)</kbd> method throws two exceptions: <kbd>IllegalArgumentException</kbd> and <kbd>NullPointerException</kbd>.</div>
<p><strong>Method name</strong>: <kbd>values</kbd></p>
<p><kbd>public static SourceVersion[] values()</kbd></p>
<p>This method returns an array of the enum constants.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The UnknownEntityException exception</h1>
                </header>
            
            <article>
                
<p>The <kbd>UnknownEntityException</kbd> class extends <kbd>RuntimeException</kbd> and is a superclass of unknown exceptions. The class constructor is as follows:</p>
<pre>    protected UnknownEntityException(String message)</pre>
<p>The constructor creates a new instance of <kbd>UnknownEntityException</kbd> with the message provided as a string argument. The method does not take additional arguments.</p>
<p>This class does not have its own methods, but inherits methods from both <kbd>java.lang.Throwable</kbd> and <kbd>class.java.lang.Object</kbd> classes as shown here:</p>
<p>The <kbd>java.lang.Throwable</kbd> class methods:</p>
<ul>
<li><kbd><span>addSuppressed()</span></kbd></li>
<li><kbd><span>fillInStackTrace()</span></kbd></li>
<li><kbd><span>getCause()</span></kbd></li>
<li><kbd><span>getLocalizedMessage()</span></kbd></li>
<li><kbd><span>getMessage()</span></kbd></li>
<li><kbd><span>getStackTrace()</span></kbd></li>
<li><kbd><span>getSuppressed()</span></kbd></li>
<li><kbd><span>initCause()</span></kbd></li>
<li><kbd><span>printStackTrace()</span></kbd></li>
<li><kbd><span>setStackTrace()</span></kbd></li>
<li><kbd><span>toString()</span></kbd></li>
</ul>
<p>The <kbd>java.lang.Object</kbd> class methods:</p>
<ul>
<li><kbd><span>clone()</span></kbd></li>
<li><kbd><span>equals()</span></kbd></li>
<li><kbd><span>finalize()</span></kbd></li>
<li><kbd><span>getClass()</span></kbd></li>
<li><kbd><span>hashCode()</span></kbd></li>
<li><kbd><span>notify()</span></kbd></li>
<li><kbd><span>notifyAll()</span></kbd></li>
<li><kbd><span>wait()</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTML5 Javadoc [JEP-224]</h1>
                </header>
            
            <article>
                
<p>The Javadoc tool has been updated for the Java 9 platform. It can now generate HTML 5 markup output in addition to HTML 4. The new Javadoc tool provides support for both HTML 4 and HTML 5.</p>
<p>HTML 4 will continue, even with the advent of the Java 9 platform, to be the default Javadoc output format. HTML 5 will be an option and will not become the default output markup format until Java 10.</p>
<p>The following short Java application simply generates a <kbd>319</kbd>-wide by <kbd>319</kbd>-high frame. It is shown here without any Javadoc tags, which we will discuss later in this section:</p>
<pre>    /import javax.swing.JFrame;<br/>    import javax.swing.WindowConstants;<br/><br/>    public class JavadocExample <br/>    {<br/><br/>      public static void main(String[] args) <br/>      {<br/>        drawJFrame();<br/>      }<br/><br/>      public static void drawJFrame()<br/>      {<br/>        JFrame myFrame = new JFrame("Javadoc Example");<br/>        myFrame.setSize(319,319);<br/>        myFrame.setDefaultCloseOperation(<br/>          WindowConstants.EXIT_ON_CLOSE);<br/>        myFrame.setVisible(true);<br/>      }<br/>    }</pre>
<p>Once your package or class is completed, you can generate a Javadoc using the Javadoc tool. You can run the Javadoc tool, located in your JDK /bin directory, from the command line or from within your <strong>Integrated Development Environment</strong> (<strong>IDE</strong>). Each IDE handles Javadoc generation differently. For example, in Eclipse, you would select <span class="packt_screen">Project</span> from the pull-down menu and then <span class="packt_screen">Generate Javadoc</span>. In the IntelliJ IDEA IDE, you select the <span class="packt_screen">Tools</span> pull-down menu and then <span class="packt_screen">Generate Javadoc</span>.</p>
<p>The following screenshot shows the IntelliJ IDEA interface for the Generate Javadoc functionality. As you can see, the <kbd>-html5</kbd> command-line argument has been included:</p>
<div class="CDPAlignCenter CDPAlign"><img height="435" width="372" src="assets/0a6b1732-b267-427a-b490-8c23c71e3037.png"/></div>
<p>When the <span class="packt_screen">OK</span> button is clicked, you will see a series of status messages, as shown in the following example:</p>
<pre><strong>"C:\Program Files\Java\jdk-9\bin\javadoc.exe" -public -splitindex -use -author -version -nodeprecated -html5 @C:\Users\elavi\AppData\Local\Temp\javadoc1304args.txt -d C:\Chapter11\JD-Output</strong><br/><strong>Loading source file C:\Chapter11\src\JavadocExample.java...</strong><br/><strong>Constructing Javadoc information...</strong><br/><strong>Standard Doclet version 9</strong><br/><strong>Building tree for all the packages and classes...</strong><br/><strong>Generating C:\Chapter11\JD-Output\JavadocExample.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\package-frame.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\package-summary.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\package-tree.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\constant-values.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\class-use\JavadocExample.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\package-use.html...</strong><br/><strong>Building index for all the packages and classes...</strong><br/><strong>Generating C:\Chapter11\JD-Output\overview-tree.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\index-files\index-1.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\index-files\index-2.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\index-files\index-3.html...</strong><br/><strong>Building index for all classes...</strong><br/><strong>Generating C:\Chapter11\JD-Output\allclasses-frame.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\allclasses-frame.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\allclasses-noframe.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\allclasses-noframe.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\index.html...</strong><br/><strong>Generating C:\Chapter11\JD-Output\help-doc.html...</strong><br/><br/><strong>javadoc exited with exit code 0</strong></pre>
<p>Once the Javadoc tool exits, you are ready to view the Javadoc. Here is a screenshot of what was generated based on the previously provided code. As you can see, it is formatted in the same manner in which the formal Java documentation from Oracle is documented:</p>
<div class="CDPAlignCenter CDPAlign"><img height="626" width="471" src="assets/9f97610a-7166-4ee8-98ff-55ec4cd03073.png"/></div>
<p>When we generated the Javadoc, multiple documents were created, as illustrated by the directory tree provided in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3358f198-85b3-4189-9f35-3f7da7619a62.png"/></div>
<p>You can also add optional tags that are recognized by the Javadoc tool. Those tags are provided here:</p>
<ul>
<li><kbd>@author</kbd></li>
<li><kbd>@code</kbd></li>
<li><kbd>@deprecated</kbd></li>
<li><kbd>@docRoot</kbd></li>
<li><kbd>@exception</kbd></li>
<li><kbd>@inheritDoc</kbd></li>
<li><kbd>@link</kbd></li>
<li><kbd>@linkplain</kbd></li>
<li><kbd>@param</kbd></li>
<li><kbd>@return</kbd></li>
<li><kbd>@see</kbd></li>
<li><kbd>@serial</kbd></li>
<li><kbd>@serialData</kbd></li>
<li><kbd>@serialField</kbd></li>
<li><kbd>@since</kbd></li>
<li><kbd>@throws</kbd></li>
<li><kbd>@value</kbd></li>
<li><kbd>@version</kbd></li>
</ul>
<div class="packt_tip">For more information on how to write document comments for the Javadoc tool, you can visit Oracle's official instructions at <a href="http://www.oracle.com/technetwork/articles/java/index-137868.html">http://www.oracle.com/technetwork/articles/java/index-137868.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Javadoc search [JEP-225]</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, the standard Doclet generated API documentation pages that made navigating them difficult. Unless you are very familiar with the layout of these documentation pages, you will likely use browser-based find functionality to search text. This is considered clunky and suboptimal.</p>
<p>The Java 9 platform includes a search box as part of the API documentation. This search box is granted by the standard Doclet and can be used to search for text within the documentation. This represents a great convenience for developers and is likely to change our usage of Doclet-generated documentation.</p>
<p>With the new Javadoc search functionality, we have the ability to search for the following indexed components:</p>
<ul>
<li>Module names</li>
<li>Package names</li>
<li>Types</li>
<li>Members</li>
<li>Terms/phrases indexed using the new <kbd>@index</kbd> inline tag</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing camel case search</h1>
                </header>
            
            <article>
                
<p>The new Javadoc search functionality includes a great shortcut using camel case search. As an example, we can search for <kbd>openED</kbd> to find the <kbd>openExternalDatabase()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Remove launch-time JRE version selection [JEP-231]</h1>
                </header>
            
            <article>
                
<p><span>Prior to Java 9, we could use the <strong>mJRE</strong> (<strong>Multiple JRE</strong>) feature to specify a specific JRE version, or range of</span> versions<span>, for launching our applications. We would accomplish this via the command-line option <kbd>-version</kbd> or with an entry in the JAR file's manifest. The following flowchart illustrates what happens based on our selection:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="364" width="334" src="assets/db52f66a-a51b-451b-ab60-77c0541baff0.png"/></div>
<p>This functionality was introduced with JDK 5 and was not fully documented in that release or any subsequent release prior to JDK 9.</p>
<p>The following specific changes were introduced with the Java 9 platform:</p>
<ul>
<li>The mJRE feature has been removed.</li>
<li>The launcher will now produce an error whenever the <kbd>-version</kbd> command-line option is used. This is a terminal errors in that processing will not continue.</li>
<li>A warning will be produced if there is a <kbd>-version</kbd> entry in a JARs manifest. The warning will not stop execution.</li>
</ul>
<p>Interestingly, the presence of a <kbd>-version</kbd> entry in a manifest file will only generate a warning. This is by design, to take into account the likelihood of the entry being in older JAR file. It is estimated that this warning will be changed into a terminal error when the Java 10 platform is released.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parser API for Nashorn [JEP-236]</h1>
                </header>
            
            <article>
                
<p>The focus of JEP 236 was to create an API for Nashorn's EMCAScript abstract syntax tree. In this section, we will individually look at Nashorn, EMCAScript and then the Parser API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nashorn</h1>
                </header>
            
            <article>
                
<p>Oracle Nashorn is a JavaScript engine for the JVM developed in Java by Oracle. It was released with Java 8. It was created to provide developers with a highly efficiently and lightweight JavaScript runtime engine. Using this engine, developers were able to embed JavaScript code in their Java applications. Prior to Java 8, developers had access to the JavaScript engine created by Netscape. That engine, introduced in 1997, was maintained by Mozilla.</p>
<p>Nashorn can be used both as a command-line tool and as an embedded interpreter in Java applications. Let's look at examples of both.</p>
<div class="packt_infobox">Nashorn is the German word for rhinoceros. The name spawned from the Rhino-named JavaScript engine from the Mozilla Foundation. Rhino is said to have originated from the picture of the animal on a JavaScript book cover. File this one under <strong>interesting facts</strong>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Nashorn as a command-line tool</h1>
                </header>
            
            <article>
                
<p>The Nashorn executable file, <kbd>jjs.exe</kbd>, resides in the <kbd>\bin</kbd> folder. To access it, you can navigate to that folder or, if your system path is set up appropriately, you can launch into the shell by entering the <kbd>jjs</kbd> command in a Terminal / Command Prompt window on your system:</p>
<div class="CDPAlignCenter CDPAlign"><img height="566" width="500" src="assets/3a503feb-a949-46a1-a7de-2e1a7ec42a89.png"/></div>
<p>Here, you can see an open terminal window that first checks the version of Java and then uses the <kbd>jjs -version</kbd> command to launch the Nashorn shell. In this example, both Java and Nashorn are version 1.8.0.121. Alternatively, we can simply launch Nashorn with the <kbd>jjs</kbd> command, and the shell will open without the version identification:</p>
<div class="CDPAlignCenter CDPAlign"><img height="221" width="725" src="assets/09232883-d452-4d5e-be30-dba2c5b9ce30.png"/></div>
<p>Next, let's create a short JavaScript and run it using Nashorn. Consider the following simple JavaScript code that has three simple lines of output.</p>
<pre>    var addtest = function()<br/>    {<br/>      print("Simple Test");<br/>      print("This JavaScript program adds the numbers 300<br/>       and 19.");<br/>      print("Addition results = " + (300 + 19));<br/>    }<br/>    addtest();</pre>
<p>To have Java run this JavaScript application, we will use the <kbd>jjs address.js</kbd> command. Here is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="124" width="504" src="assets/af11affd-fc08-47cf-a425-56dadf4aab0f.png"/></div>
<p>There is a lot you can do with Nashorn. From the Command Prompt/Terminal window, we can execute <kbd>jjs</kbd> with the <kbd>-help</kbd> option to see a full list of command-line commands:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b4ff29b9-e56f-48ad-9a8e-954b4d673ba1.png"/></div>
<p>As you can see, using the <kbd>-scripting</kbd> option gives us the ability to create scripts using Nashorn as a text editor. There are several built-in functions that are useful when using Nashorn:</p>
<ul>
<li><kbd>echo()</kbd>: This is similar to a <kbd>System.out.print()</kbd> Java method</li>
<li><kbd>exit()</kbd>: This exits Nashorn</li>
<li><kbd>load()</kbd>: This loads a script from a given path or URL</li>
<li><kbd>print()</kbd>: This is similar to a <kbd>System.out.print()</kbd> Java method</li>
<li><kbd>readFull()</kbd>: This reads a file's contents</li>
<li><kbd>readLine()</kbd>: This reads a single line from <kbd>stdin</kbd></li>
<li><kbd>quit()</kbd>: This exits Nashorn</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Nashorn as an embedded interpreter</h1>
                </header>
            
            <article>
                
<p>A more common use of Nashorn, compared to using it as a command-line tool, is using it as an embedded interpreter. The <kbd>javax.script</kbd> API is public and can be accessed via the <kbd>nashorn</kbd> identifier. The following code demonstrates how we can gain access to Nashorn, define a JavaScript function, and obtain the results--all from within a Java application:</p>
<pre>    // required imports<br/><span>    import</span> javax.script.ScriptEngine;<br/><span>    import</span> javax.script.ScriptEngineManager;<br/><br/><span>    public</span> <span>class</span> EmbeddedAddTest <br/>    {<br/><span>      public</span> <span>static</span> <span>void</span> main(String[] <span>args</span>) <span>throws</span> Throwable<br/>      {<br/>        // instantiate a new ScriptEngineManager<br/>        ScriptEngineManager <span>myEngineManager</span> =<br/>          <span>new</span> ScriptEngineManager();<br/><br/>        // instantiate a new <span>Nashorn</span> ScriptEngine<br/>        ScriptEngine <span>myEngine</span> = <span>myEngineManager</span>.getEngineByName(<br/><span>         "nashorn"</span>);<br/><br/>        // create the JavaScript function<br/><span>        myEngine</span><span>.eval(</span>"function addTest(x, y) { return x + y; }"<span>);<br/><br/></span>        // generate output including a call to the addTest function<br/>           via the engine<br/><span>        System.</span><span>out</span><span>.println(</span>"The addition results are:<br/>         "<span> + </span><span>myEngine</span><span>.eval(</span>"addTest(300, 19);"<span>));<br/></span>      }<br/>    }</pre>
<p>Here is the output provided in the console window:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/75b7bde5-385d-42a5-9a3a-2fbe94c1e09d.png"/></div>
<p>This is a simplistic example to give you an idea of what is possible with embedded use of Nashorn. There are ample examples in Oracle's official documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">EMCAScript</h1>
                </header>
            
            <article>
                
<p><strong>EMCA</strong> (<strong>European Computer Manufacturers Association</strong>) was formed in 1961 as a standards organization for both information systems and communications systems. Today, the EMCA continues to develop standards and issue technical reports to help standardize how consumer electronics, information systems, and communications technology are used. They are over 400 ECMA standards, most of which have been adopted.</p>
<div class="packt_infobox">You will notice that EMCA is not spelled with all capital letters as it is no longer considered an acronym. In 1994, the European Computer Manufacturers Association formally changed its name to EMCA.</div>
<p>EMCAScript, also referred to as ES, was created in 1997 as a scripted-language specification. JavaScript implements this specification. The specification includes the following:</p>
<ul>
<li>Complementary technologies</li>
<li>Libraries</li>
<li>Scripting language syntax</li>
<li>Semantics</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parser API</h1>
                </header>
            
            <article>
                
<p>One of the changes in the Java platform with version 9 is to provide specific support for Nashorn's EMCAScript abstract syntax tree. The goals of the new API are to provide the following:</p>
<ul>
<li>Interfaces to represent Nashorn syntax tree nodes</li>
<li>The ability to create parser instances that can be configured with command-line options</li>
<li>A visitor pattern API for interfacing with AST nodes</li>
<li>Test programs to use the API</li>
</ul>
<p>The new API, <kbd>jdk.nashorn.api.tree</kbd>, was created to permit future changes to the Nashorn classes. Prior to the new Parser API, IDEs used Nashorn's internal AST representations for code analysis. According to Oracle, use of the <kbd>idk.nashorn.internal.ir</kbd> package prevented the modernization of Nashorn's internal classes.</p>
<p>Here is a look at the the class hierarchy of the new <kbd>jdk.nashorn.api.tree</kbd> package:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f2633438-e406-4357-bfc9-b0a78e686fef.png"/></div>
<p>The following graphic illustrates the complexity of the new API, featuring a full interface hierarchy:</p>
<div class="CDPAlignCenter CDPAlign"><img height="643" width="303" src="assets/43b9ee78-0a9e-4251-bdaf-9fdb9f107bb0.png"/></div>
<p>The last component of the <kbd>jdk.nashorn.api.tree</kbd> package is the enum hierarchy, shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5fd964b6-5153-4c60-a597-be9989942268.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multi-release JAR files [JEP-238]</h1>
                </header>
            
            <article>
                
<p>The JAR file format has been extended in the Java 9 platform and now permits multiple versions of class files to exist in a single JAR file. The class versions can be specific to a Java release version. This enhancement allows developers to use a single JAR file to house multiple releases of their software.</p>
<p>The JAR file enhancement includes the following:</p>
<ul>
<li>Support for the <kbd>JarFile</kbd> API</li>
<li>Support for standard class loaders</li>
</ul>
<p>The changes to the JAR file format resulted in necessary changes to core Java tools so that they are able to interpret the new multiple-release JAR files. These core tools include the following:</p>
<ul>
<li>javac</li>
<li>javap</li>
<li>jdeps</li>
</ul>
<p>Finally, the new JAR file format supports modularity as the key characteristic of the Java 9 platform. The changes to the JAR file format have not resulted in reduced performance of related tools or processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying multi-release JAR files</h1>
                </header>
            
            <article>
                
<p>Multi-release JAR files will have a new attribute, <kbd>Multi-Release: true</kbd>. This attribute will be located in the JAR <kbd>MANIFEST.MF</kbd> main section.</p>
<p>The directory structure will differ between standard JAR files and multi-release JAR files. Here is a look at a typical JAR file structure:</p>
<div class="CDPAlignCenter CDPAlign"><img height="124" width="135" src="assets/582bb88d-54ac-4dae-abb2-f5f3c913027d.png"/></div>
<p>This illustration shows the new multi-release JAR file structure with Java version-specific class files for both Java 8 and Java 9:</p>
<div class="CDPAlignCenter CDPAlign"><img height="296" width="193" src="assets/f2fa5f0f-5f49-407f-b993-9c2a3cbf0ef9.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Related JDK changes</h1>
                </header>
            
            <article>
                
<p>Several changes had to be made to the JDK to support the new multi-release JAR file format. These changes include the following:</p>
<ul>
<li>The <kbd>URLClassLoader</kbd> is JAR-based and was modified so that it can read class files from the specified version.</li>
<li>The new module-based class loader, new to Java 9, was written so that it can read class files from the specified version.</li>
<li>The <kbd>java.util.jar.JarFile</kbd> class was modified so that it selects the appropriate class version from the multi-release JAR files.</li>
<li>The JAR URL scheme's protocol handler was modified so that it selects the appropriate class version from the multi-release JAR files.</li>
<li>The Java Compiler, <kbd>javac</kbd>, was made to read identified versions of the class files. These version identifications are made using the <kbd>-target</kbd> and <kbd>-release</kbd> command-line options with the <kbd>JavacFileManager</kbd> API and the <kbd>ZipFileSystem</kbd> API.</li>
<li>The following tools were modified to take advantage of the changes to the <kbd>JavacFileManager</kbd> API and the <kbd>ZipFileSystem</kbd> API:
<ul>
<li><kbd>javah</kbd>: This generates C header and source files</li>
<li><kbd>schemagen</kbd>: This is the schema generator for namespaces in Java classes</li>
<li><kbd>wsgen</kbd>: This is the parser for web service deployment</li>
</ul>
</li>
<li>The javap tool was updated to support the new versioning schema.</li>
<li>The jdeps tool was modified to support the new versioning schema.</li>
<li>The JAR packing tool set was updated accordingly. This tool set consists of <kbd>pack200</kbd> and <kbd>unpack200</kbd>.</li>
<li>Of course, the JAR tool was enhanced so that it can create the multi-release JAR files.</li>
</ul>
<p>All related documentation has been updated to support all the changes involved in establishing and supporting the new multi-release JAR file format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java-level JVM compiler interface [JEP-243]</h1>
                </header>
            
            <article>
                
<p>The JEP-243 was to create a Java-based <strong>JVM Compiler Interface</strong> (<strong>JVMCI</strong>). The JVMCI enables a Java compiler (which must have been written in Java) to be used as a dynamic compiler by the JVM.</p>
<p>The reasoning behind the desire for the JVMCI is that it would be a highly optimized compiler that does not require low-level language features. Some JVM subsystems require low-level functionality, such as with garbage collection and bytemode interpretation. So, the JVMCI was written in Java instead of C or C++. This provides the collateral benefit of some of Java's greatest features, such as the following ones:</p>
<ul>
<li>Exception handling</li>
<li>IDEs that are both free and robust</li>
<li>Memory management</li>
<li>Runtime extensibility</li>
<li>Synchronization</li>
<li>Unit testing support</li>
</ul>
<p>As JVMCI was written in Java, it will arguably be easier to maintain.</p>
<p>There are three primary components of the JVMCI API:</p>
<ul>
<li>Virtual machine data structure access</li>
<li>Installing compiled code with its metadata</li>
<li>Using the JVM's compilation system</li>
</ul>
<p>The JVMCI actually existed, to some extent, in Java 8. The JVMCI API was only accessible via a class loader that worked for code on the boot class path. In Java 9, this changes. It will still be experimental in Java 9, but more accessible. In order to enable the JVMCI, the following series of command-line options must be used:</p>
<pre><strong>-XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler - Djvmci.Compiler=&lt;name of compiler&gt;</strong></pre>
<p>Oracle is keeping the JVMCI experimental in Java 9 to permit further testing and to afford the greatest level of protection for developers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BeanInfo annotations [JEP-256]</h1>
                </header>
            
            <article>
                
<p>The JEP-256 focused on replacing <kbd>@beanifo</kbd> javadoc tags with more appropriate annotations. Furthermore, these new annotations are now processed at runtime so that <kbd>BeanInfo</kbd> classes can be generated <span>dynamically</span>. The modularity of Java 9 resulted in this change. The creation of custom <kbd>BeanInfo</kbd> classes has been simplified and the client library has been modularized.</p>
<p>In order to fully grasp this change, we will review <kbd>JavaBean</kbd>, <kbd>BeanProperty</kbd>, and <kbd>SwingContainer</kbd> before going any further into this JEP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaBean</h1>
                </header>
            
            <article>
                
<p>A <kbd>JavaBean</kbd> is a Java class. Like other Java classes, <kbd>JavaBeans</kbd> are reusable code. They are unique in their design because they encapsulate several objects into one. There are three conventions a <kbd>JavaBean</kbd> class must follow:</p>
<ul>
<li>The constructor should not take any arguments</li>
<li>It must be serializable</li>
<li>It must contain mutator and accessor methods for its properties</li>
</ul>
<p>Here is an example <kbd>JavaBean</kbd> class:</p>
<pre><span>    public</span> <span>class</span> <span>MyBean</span> <span>implements</span> java.io.Serializable <br/>    {<br/>      // instance variables  <br/>      private<span> </span>int<span> </span><span>studentId</span><span>;<br/></span><span>      private</span><span> String </span>studentName<span>;<br/><br/></span>      // no-argument constructor<br/><span>      public</span> MyBean() <br/>      {<br/>  <br/>      }<br/>  <br/>      // mutator/setter <br/><span>      public</span> <span>void</span> setStudentId(<span>int</span> <span>theID</span>)<br/>      {<br/><span>        this</span><span>.</span>studentId<span> = </span><span>theID</span><span>;<br/></span>      }<br/><br/>      // <span>accessor</span>/getter<br/><span>      public</span> <span>int</span> getStudentId()<br/>      {<br/><span>        return</span><span> </span>studentId<span>;<br/></span>      }<br/><br/>      // mutator/setter <br/><span>      public</span> <span>void</span> setStudentName(String <span>theName</span>)<br/>      {<br/><span>        this</span><span>.</span>studentName<span> = </span><span>theName</span><span>;<br/></span>      }<br/><br/>      // <span>accessor</span>/getter<br/><span>      public</span> String getStudentName()<br/>      {<br/><span>        return</span><span> </span>studentName<span>;<br/></span>      }<br/><br/>    }</pre>
<p>Accessing <kbd>JavaBean</kbd> classes is as simple as using the mutator and accessor methods. This is likely not new to you, but there is a good chance you did not know that those carefully coded classes you created were called <kbd>JavaBean</kbd> classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BeanProperty</h1>
                </header>
            
            <article>
                
<p><kbd>BeanProperty</kbd> is an annotation type. We use this annotation to specify a property so that we can automatically generate <kbd>BeanInfo</kbd> classes. This is a new annotation for Java 9.</p>
<p>The <kbd>BeanProperty</kbd> annotation has the following optional elements:</p>
<ul>
<li><kbd>boolean bound</kbd></li>
<li><kbd>String description</kbd></li>
<li><kbd>String[] enumerationValues</kbd></li>
<li><kbd>boolean expert</kbd></li>
<li><kbd>boolean hidden</kbd></li>
<li><kbd>boolean preferred</kbd></li>
<li><kbd>boolean required</kbd></li>
<li><kbd>boolean visualUpdate</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SwingContainer</h1>
                </header>
            
            <article>
                
<p><kbd>SwingContainer</kbd> is an annotation type. We use this annotation to specify a swing-related property so that we can automatically generate <kbd>BeanInfo</kbd> classes. This is a new annotation for Java 9.</p>
<p>The <kbd>SwingContainer</kbd> annotation has the following optional elements:</p>
<ul>
<li><kbd>String delegate</kbd></li>
<li><kbd>boolean value</kbd></li>
</ul>
<p>Now that we have reviewed <kbd>JavaBean</kbd>, <kbd>BeanProperty</kbd>, and <kbd>SwingContainer</kbd>, let's take a look at the <kbd>BeanInfo</kbd> classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BeanInfo classes</h1>
                </header>
            
            <article>
                
<p>For the most part, <kbd>BeanInfo</kbd> classes are automatically generated at runtime. The exception is with Swing classes. Those classes generate <kbd>BeanInfo</kbd> classes based on the <kbd>@beaninfo</kbd> javadoc tags. This is done at compile time, not runtime. In Java 9, the <kbd>@beaninfo</kbd> tags have been replaced with <kbd>@interface JavaBean</kbd>, <kbd>@interface BeanProperty</kbd>, and <kbd>@interface SwingContainer</kbd> annotations.</p>
<p>These new annotations are used to set the corresponding attributes based on the optional elements noted in the previous sections. As an example, the following code snippet sets the attributes for a <kbd>SwingContainer</kbd>:</p>
<pre>    package javax.swing;<br/><br/>    public @interface SwingContainer<br/>    {<br/>      boolean value() default false;<br/>      String delegate() default "";<br/>    }</pre>
<p>This provides us with three benefits:</p>
<ul>
<li>It will be much easier to specify attributes in Bean classes instead of having to create individual <kbd>BeanInfo</kbd> classes</li>
<li>We will be able to remove auto-generated classes</li>
<li>The client library is much more easily modularized with this approach</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TIFF image input/output [JEP-262]</h1>
                </header>
            
            <article>
                
<p>JEP-262 is pretty straight forward. For Java 9, the image input/output plugins have been extended to include support for the TIFF image format. The <kbd>ImageIO</kbd> class extends the <kbd>Object</kbd> class and is part of Java SE. The class contains several methods for encoding and decoding images. Here is a list of static methods:</p>
<table>
<tbody>
<tr>
<td><strong>Method</strong></td>
<td><strong>Return value</strong></td>
</tr>
<tr>
<td><kbd>createImageInputStream(Object input)</kbd></td>
<td><kbd>ImageInputStream</kbd></td>
</tr>
<tr>
<td><kbd>createImageOutputStream(Object output)</kbd></td>
<td><kbd>ImageOutputStream</kbd></td>
</tr>
<tr>
<td><kbd>getCacheDirectory()</kbd></td>
<td>Current value of the <kbd>CacheDirectory</kbd></td>
</tr>
<tr>
<td><kbd>getImageReader(ImageWriter writer)</kbd></td>
<td><kbd>ImageReader</kbd></td>
</tr>
<tr>
<td><kbd>getImageReaders(Object input)</kbd></td>
<td>Iterator of current <kbd>ImageReaders</kbd></td>
</tr>
<tr>
<td><kbd>getImageReadersByFormatName(String formatName)</kbd></td>
<td>Iterator of current <kbd>ImageReaders</kbd> with the specified format name</td>
</tr>
<tr>
<td><kbd>getImageReadersByMIMEType(String MIMEType)</kbd></td>
<td>Iterator of current <kbd>ImageReaders</kbd> of the specified MIME type</td>
</tr>
<tr>
<td><kbd>getImageReadersBySuffix(String fileSuffix)</kbd></td>
<td>Iterator of current <kbd>ImageReaders</kbd> with the specified suffix.</td>
</tr>
<tr>
<td><kbd>getImageTranscoders(ImageReader reader)</kbd></td>
<td>Iterator of current <kbd>ImageTranscoders</kbd></td>
</tr>
<tr>
<td><kbd>getImageWriter(ImageReader reader)</kbd></td>
<td><kbd>ImageWriter</kbd></td>
</tr>
<tr>
<td><kbd>getImageWriters(ImageTypeSpecifier type, String formatName)</kbd></td>
<td>Iterator of current <kbd>ImageWriters</kbd> that can encode to the specified type</td>
</tr>
<tr>
<td><kbd>getImageWritersByFormatName(String formatName)</kbd></td>
<td>Iterator of current <kbd>ImageWriters</kbd> with the specified format name</td>
</tr>
<tr>
<td><kbd>getImageWritersByMIMEType(String MIMEType)</kbd></td>
<td>Iterator of current <kbd>ImageWriters</kbd> of the specified MIME type</td>
</tr>
<tr>
<td><kbd>getImageWritersBySuffix(String fileSuffix)</kbd></td>
<td>Iterator of current <kbd>ImageWriters</kbd> with the specified suffix.</td>
</tr>
<tr>
<td><kbd>getReaderFileSuffixes()</kbd></td>
<td>String array with file suffixes understood by current readers</td>
</tr>
<tr>
<td><kbd>getReaderFormatNames()</kbd></td>
<td>String array with format names understood by current readers</td>
</tr>
<tr>
<td><kbd>getReaderMIMETypes()</kbd></td>
<td>String array with MIME types understood by current readers</td>
</tr>
<tr>
<td><kbd>getUseCache()</kbd></td>
<td><kbd>UseCache</kbd> value</td>
</tr>
<tr>
<td><kbd>getWriterFileSuffixes()</kbd></td>
<td>String array of file suffixes understood by current writers</td>
</tr>
<tr>
<td><kbd>getWriterFormatNames()</kbd></td>
<td>String array with format names understood by current writers</td>
</tr>
<tr>
<td><kbd>getWriterMIMETypes()</kbd></td>
<td>String array with MIME types understood by current writers</td>
</tr>
<tr>
<td><kbd>read(File input)</kbd></td>
<td><kbd>BufferedImage</kbd> with an <kbd>ImageReader</kbd></td>
</tr>
<tr>
<td><kbd>read(ImageInputStream stream)</kbd></td>
<td><kbd>BufferedImage</kbd> with <kbd>ImageInputStream</kbd> and an <kbd>ImageReader</kbd></td>
</tr>
<tr>
<td><kbd>read(InputStream input)</kbd></td>
<td><kbd>BufferedImage</kbd> with <kbd>InputStream</kbd> and <kbd>ImageReader</kbd></td>
</tr>
<tr>
<td><kbd>read(URL input)</kbd></td>
<td><kbd>BufferedImage</kbd> with an <kbd>ImageReader</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>There are also a few static methods that do not return a value or return a Boolean:</p>
<table>
<tbody>
<tr>
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>scanForPlugins()</kbd></td>
<td>
<p class="mce-root">Performs the following actions:</p>
<ul>
<li>Scans the application classpath for plugins</li>
<li>Loads plugin service provider classes</li>
<li>Registers service provide instances in the IIORegistry</li>
</ul>
</td>
</tr>
<tr>
<td><kbd>setCacheDirectory(File cacheDirectory)</kbd></td>
<td>This is where the cache files will be stored.</td>
</tr>
<tr>
<td><kbd>setUseCache(boolean useCache)</kbd></td>
<td>This method toggles if the cache will be disk-based or not. This applies to <kbd>ImageInputStream</kbd> and <kbd>ImageOutputStream</kbd> instances.</td>
</tr>
<tr>
<td><kbd>write(RenderedImage im, String formatName, File output)</kbd></td>
<td>Writes an image to the specified file.</td>
</tr>
<tr>
<td><kbd>write(RenderedImage im, String formatName, ImageOutputStream output)</kbd></td>
<td>Writes an image to an <kbd>ImageOutputStream</kbd>.</td>
</tr>
<tr>
<td><kbd>write(RenderedImage im, String formatName, OutputStream output)</kbd></td>
<td>Writes an image to an <kbd>OutputStream</kbd>.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As you can glean from the provided methods, the image input/output framework provides us with a convenient way of using image codecs. As of Java 7, the following image format plugins were implemented by <kbd>javax.imageio</kbd>:</p>
<ul>
<li>BMP</li>
<li>GIF</li>
<li>JPEG</li>
<li>PNG</li>
<li>WBMP</li>
</ul>
<p>The TIFF is, as you can see, not on the list of image file formats. TIFFs are a common file format and, in 2001, macOS, with the release of MacOS X, used the format extensively.</p>
<p>The Java 9 platform includes <kbd>ImageReader</kbd> and <kbd>ImageWriter</kbd> plugins for the TIFFs. These plugins have been written in Java and have been bundled in the new <kbd>javax.imageio.plugins.tiff</kbd> package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Platform logging API and service [JEP-264]</h1>
                </header>
            
            <article>
                
<p>The Java 9 platform includes a new logging API enabling platform classes to log messages. It has a commensurate service for manipulating the logs. Before we go too far into what is new regarding the logging API and service, let's review <kbd>java.util.logging.api</kbd> which was introduced in Java 7.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The java.util.logging package</h1>
                </header>
            
            <article>
                
<p>The <kbd>java.util.logging</kbd> package includes classes and interfaces that collectively comprise Java's core logging features. This functionality was created with the following goals:</p>
<ul>
<li>Problem diagnosis by end users and system administrators</li>
<li>Problem diagnosis by field service engineers</li>
<li>Problem diagnosis by the development organization</li>
</ul>
<p>As you can see, the primary purpose was to enable maintenance of remote software.</p>
<p>The <kbd>java.util.logging</kbd> package has two interfaces:</p>
<ul>
<li><kbd>public interface Filter</kbd>
<ul>
<li>Purpose: This provides fine-grain control over logged data</li>
<li>Method:
<ul>
<li><kbd>isLoggable(LogRecord record)</kbd></li>
</ul>
</li>
</ul>
</li>
<li><kbd>public interface LoggingMXBean</kbd>
<ul>
<li>Purpose: This is the logging facility's management interface</li>
<li>Methods:
<ul>
<li><kbd>getLoggerLevel(String loggerName)</kbd></li>
<li><kbd>getLoggerNames()</kbd></li>
<li><kbd>getparentLoggerName(String loggerName)</kbd></li>
<li><kbd>setLoggerLevel(String loggerName, String levelName)</kbd></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The following table provides the <kbd>java.util.logging</kbd> package classes, along with a brief description regarding what each class provides in respect to logging functionality and management:</p>
<table>
<tbody>
<tr>
<td><strong>Class</strong></td>
<td><strong>Definition</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>ConsoleHandler</kbd></td>
<td><kbd>public class ConsoleHandler extends StreamHandler</kbd></td>
<td>Publishes log records to <kbd>System.err</kbd></td>
</tr>
<tr>
<td><kbd>ErrorManager</kbd></td>
<td><kbd>public class ErrorManager extends Object</kbd></td>
<td>Used to process errors during logging</td>
</tr>
<tr>
<td><kbd>FileHandler</kbd></td>
<td><kbd>public class FileHandler extends StreamHandler</kbd></td>
<td>File logging</td>
</tr>
<tr>
<td><kbd>Formatter</kbd></td>
<td><kbd>public abstract class Formatter extends Object</kbd></td>
<td>For formatting <kbd>LogRecords</kbd></td>
</tr>
<tr>
<td><kbd>Handler</kbd></td>
<td><kbd>public abstract class Handler extends Object</kbd></td>
<td>Exports <kbd>Logger</kbd> messages</td>
</tr>
<tr>
<td><kbd>Level</kbd></td>
<td><kbd>public class Level extends Object implements Serializable</kbd></td>
<td>Controls level of logging. The levels, in descending order, are--severe, warning, info, config, fine, finer, and finest</td>
</tr>
<tr>
<td><kbd>Logger</kbd></td>
<td><kbd>public class Logger extends Object</kbd></td>
<td>Logs messages</td>
</tr>
<tr>
<td><kbd>LoggingPermission</kbd></td>
<td><kbd>public final class LoggingPermission extends BasicPermission</kbd></td>
<td><kbd>SecurityManager</kbd> checks this</td>
</tr>
<tr>
<td><kbd>LogManager</kbd></td>
<td><kbd>public class LogManager</kbd></td>
<td>For maintaining shared state between loggers and logging services</td>
</tr>
<tr>
<td><kbd>LogRecord</kbd></td>
<td><kbd>public class LogRecord extends Object implements Serializable</kbd></td>
<td>Passed between handlers</td>
</tr>
<tr>
<td><kbd>MemoryHandler</kbd></td>
<td><kbd>public class MemoryHandler extends Handler</kbd></td>
<td>Buffers requests in memory</td>
</tr>
<tr>
<td><kbd>SimpleFormatter</kbd></td>
<td><kbd>public class SimpleFormatter extends Formatter</kbd></td>
<td>Provides human-readable <kbd>LogRecord</kbd> metadata</td>
</tr>
<tr>
<td><kbd>SocketHandler</kbd></td>
<td><kbd>public class SocketHandler extends StreamHandler</kbd></td>
<td>Network logging handler</td>
</tr>
<tr>
<td><kbd>StreamHandler</kbd></td>
<td><kbd>public class StreamHandler extends Handler</kbd></td>
<td>Stream-based logging handler</td>
</tr>
<tr>
<td><kbd>XMLFormatter</kbd></td>
<td><kbd>public class XMLFormatter extends Formatter</kbd></td>
<td>Formats logs into XML</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Next, let's review what changes were made in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging in Java 9</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, there were multiple logging schemas available, including <kbd>java.util.logging</kbd>, <kbd>SLF4J</kbd>, and <kbd>Log4J</kbd>. The latter two are third-party frameworks that have separate facade and implementation components. This pattern has been replicated in the new Java 9 platform.</p>
<p>Java 9 introduced changes to the <kbd>java.base</kbd> module so that it would handle logging functions and not rely on the <kbd>java.util.logging</kbd> API. It has separate facade and implementation components. This means that when using third-party frameworks, the JDK only needs to provide the implementation component and return platform loggers that work with the requesting logging framework.</p>
<p>As you can see in the following illustration, we use the <kbd>java.util.ServiceLoader</kbd> API to load our <kbd>LoggerFinder</kbd> implementation. The JDK uses a default implementation if a concrete implementation is not found using the system class loader:</p>
<div class="CDPAlignCenter CDPAlign"><img height="325" width="602" src="assets/9bdf222e-0a06-4a54-b8d9-728601e10744.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XML Catalogs [JEP-268]</h1>
                </header>
            
            <article>
                
<p>JEP 268, titled XML Catalogs, focused on creating a standard XML Catalog API to support the OASIS XML Catalogs Standard v1.1. The new API defines catalog and catalog-resolve abstractions so that JAXP processors can use them. In this section, we will look at the following:</p>
<ul>
<li>The OASIS XML Catalog standard</li>
<li>JAXP processors</li>
<li>XML Catalogs prior to Java 9</li>
<li>Java 9 platform changes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The OASIS XML Catalog standard</h1>
                </header>
            
            <article>
                
<p><strong>XML</strong> (<strong>eXtensible Markup Language</strong>) Catalogs are XML documents consisting of catalog entries. Each entry pairs an identifier to another location. OASIS is a not-for-profit consortium with the mission of advancing open standards. They published the XML catalog standard, version 1.1., in 2005. This standard has two basic use cases:</p>
<ul>
<li>Map an external identifier to a URI reference</li>
<li>Map a URI reference to another URI reference</li>
</ul>
<p>Here is a sample XML catalog entry:</p>
<pre>    &lt;public publicId="-//Packt Publishing Limited//Mastering Java 9//EN"<br/>     uri="https://www.packtpub.com/application-development/mastering-java-9"/&gt;</pre>
<p>The complete OASIS XML Catalog standard can be found at the official site: <a href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html">https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JAXP processors</h1>
                </header>
            
            <article>
                
<p>The Java API for XML processing is referred to as JAXP. As its name suggests, this API is used for parsing XML documents. There are four related interfaces:</p>
<ul>
<li>DOM: Document Object Model parsing</li>
<li>SAX: Simple API for XML parsing</li>
<li>StAX: Streaming API for XML parsing</li>
<li>XSLT: Interface to transform XML documents</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XML Catalogs prior to Java 9</h1>
                </header>
            
            <article>
                
<p>The Java platform has had an internal catalog resolver since JDK 6. There was no public API, so external tools and libraries were used to access the functionality. Moving into Java 9, the goal was to make the internal catalog resolver a standard API for common use and ease of support.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java 9 platform changes</h1>
                </header>
            
            <article>
                
<p>The new XML Catalog API, delivered with Java 9, follows the OASIS XML Catalogs standard, v1.1. Here are the feature and capability highlights:</p>
<ul>
<li>Implements <kbd>EntityResolver</kbd></li>
<li>Implements <kbd>URIResolver</kbd></li>
<li>Creation of XML Catalogs is possible via the <kbd>CatalogManager</kbd></li>
<li><kbd>CatalogManager</kbd> will be used to create <kbd>CatalogResolvers</kbd></li>
<li>OASIS open catalog file semantics will be followed
<ul>
<li>Map an external identifier to a URI reference</li>
<li>Map a URI reference to another URI reference</li>
</ul>
</li>
<li><kbd>CatalogResolvers</kbd> will implement the JAXP <kbd>EntityResolver</kbd> interface</li>
<li><kbd>CatalogResolvers</kbd> will implement the JAXP <kbd>URIResolver</kbd> interface</li>
<li>The SAX <kbd>XMLFilter</kbd> will be supported by the resolver.</li>
</ul>
<p>Since the new XML Catalog API will be public, the pre-Java 9 internal catalog resolver will be removed, as it will no longer be necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Convenience factory methods for collections [JEP-269]</h1>
                </header>
            
            <article>
                
<p>The Java programming language does not support collection literals. Adding this feature to the Java platform was proposed in 2013 and revisited in 2016, but it only gained exposure as a research proposal, not for future implementation.</p>
<div class="packt_infobox">Oracle's definition of a collection literal is "<em>a syntactic expression form that evaluates to an aggregate type, such as an array, list, or map</em>" (<a href="http://openjdk.java.net/jeps/186">http://openjdk.java.net/jeps/186</a>).</div>
<p>Of course, that is until Java 9 is released. Implementing collection literals in the Java programming language is reported to have the following benefits:</p>
<ul>
<li>Performance improvement</li>
<li>Increased safety</li>
<li>Reduction of boilerplate code</li>
</ul>
<p>Even without being part of the research group, our knowledge of the Java programming language clues us in to additional benefits:</p>
<ul>
<li>Ability to write shorter code</li>
<li>Ability to write space-efficient code</li>
<li>Ability to make collection literals immutable</li>
</ul>
<p>Let's look at two cases--using collections before Java 9, and then with the new support for collection literals in the new Java platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using collections before Java 9</h1>
                </header>
            
            <article>
                
<p>Here is an example of how we would create our own collections prior to Java 9. This first class defines the structure for <kbd>PlanetCollection</kbd>. It has the following components:</p>
<ul>
<li>A single instance variable</li>
<li>A one argument constructor</li>
<li>Mutator/setter method</li>
<li>Accessor/getter method</li>
<li>Method to print the object</li>
</ul>
<p>Here is the code implementing the preceding listed constructor and methods:</p>
<pre><span>    public</span> <span>class</span> PlanetCollection <br/>    {<br/>      // Instance Variable<br/><span>      private</span> String <span>planetName</span>;<br/><br/>      // constructor<br/><span>      public</span> PlanetCollection(String <span>name</span>)<br/>      {<br/>        setPlanetName(<span>name</span>);<br/>      }<br/><br/>      // mutator<br/><span>      public</span> <span>void</span> setPlanetName(String <span>name</span>)<br/>      {<br/><span>        this</span><span>.</span>planetName<span> = </span><span>name</span><span>;<br/></span>      }<br/><br/>      // <span>accessor<br/></span><span>      public</span> String getPlanetName()<br/>      {<br/>        return<span> </span>this<span>.</span><span>planetName</span><span>;<br/></span>      }<br/><br/><span>      public</span> <span>void</span> print()<br/>      {<br/>        System.<span>out</span>.println(getPlanetName());<br/>      }<br/>    }</pre>
<p>Now, let's look at the driver class that populates the collection:</p>
<pre><span>    import</span> java.util.ArrayList;<br/><br/><span>    public</span><span> </span><span>class</span><span> OldSchool <br/>    {<br/></span><span>      private</span> <span>static</span> ArrayList&lt;PlanetCollection&gt; <span>myPlanets</span> =<br/>        <span>new</span> ArrayList&lt;&gt;();<br/><br/><span>      public</span> <span>static</span> <span>void</span> main(String[] <span>args</span>) <br/>      {<br/>        add(<span>"Earth"</span>);<br/><span>        add(</span>"Jupiter"<span>);<br/></span>        add(<span>"Mars"</span>);<br/>        add(<span>"Venus"</span>);<br/>        add(<span>"Saturn"</span>);<br/><span>        add(</span>"Mercury"<span>);<br/></span><span>        add(</span>"Neptune"<span>);<br/></span>        add(<span>"Uranus"</span>);<br/><span>        add(</span>"Dagobah"<span>);<br/></span>        add(<span>"Kobol"</span>);<br/>    <br/><span>        for</span> (PlanetCollection <span>orb</span> : <span>myPlanets</span>)<br/>        {<br/><span>          orb</span>.print();<br/>        }<br/><br/>      }<br/><br/><span>      public</span> <span>static</span> <span>void</span> add(String <span>name</span>)<br/>      {<br/>        PlanetCollection <span>newPlanet</span> = <span>new</span> PlanetCollection(<span>name</span>);<br/><span>        myPlanets</span>.add(<span>newPlanet</span>);<br/>      }<br/>    }</pre>
<p>Here is the output from this application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb5b62da-e9be-429a-9a1e-aa29485632a3.png"/></div>
<p>This code is, unfortunately, very verbose. We populated our collection in static initializer blocks instead of using a field initializer. There are other methods of populating our list, but they are all more verbose than they should have to be. These other methods have additional problems, such as the need to create extra classes, the use of obscure code, and hidden references.</p>
<p>Let's now take a look at the solution to this problem, provided by the new Java 9 platform. We will look at what is new in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using new collection literals</h1>
                </header>
            
            <article>
                
<p>In order to rectify the currently required code verbosity in creating collections, we need library APIs for creating collection instances. Look at our pre-Java 9 code snippet in the previous section and then consider this possible refactoring:</p>
<pre>    PlanetCollection&lt;String&gt; myPlanets = Set.of(<br/>      "Earth",<br/>      "Jupiter",<br/>      "Mars",<br/>      "Venus",<br/>      "Saturn",<br/>      "Mercury",<br/>      "Neptune",<br/>      "Uranus",<br/>      "Dagobah",<br/>      "Kobol");</pre>
<p>This code is highly human-readable and not verbose.</p>
<p>The new implementation will include static factory methods on the following interfaces:</p>
<ul>
<li><kbd>List</kbd></li>
<li><kbd>Map</kbd></li>
<li><kbd>Set</kbd></li>
</ul>
<p>So, we are now able to create unmodifiable instances of <kbd>List</kbd> collections, <kbd>Map</kbd> collections, and <kbd>Set</kbd> collections. They can be instantiated with the following syntax:</p>
<ul>
<li><kbd>List.of(a, b, c, d, e);</kbd></li>
<li><kbd>Set.of(a, b, c, d, e);</kbd></li>
<li><kbd>Map.of();</kbd></li>
</ul>
<p>The <kbd>Map</kbd> collections will have a set of fixed arguments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Platform-specific desktop features [JEP-272]</h1>
                </header>
            
            <article>
                
<p>The exciting JEP-272 was to create a new public API so that we can write applications with access to platform-specific desktop features. These features include interacting with task bars/docks and listening for application and system events.</p>
<p>The macOS X <kbd>com.apple.eawt</kbd> package was an internal API and, starting with Java 9, is no longer accessible. In support of Java 9's new embedded platform-specific desktop features, <kbd>apple.applescript</kbd> classes are being removed from the Java platform without replacement.</p>
<p>This effort had several objectives:</p>
<ul>
<li>Create a public API to replace the functionality in <span><kbd>com.apple.{east,eio}</kbd></span></li>
<li>Ensure OS X developers do not loose functionality. To this end, the Java 9 platform has replacements for the following packages:
<ul>
<li><kbd>com.apple.eawt</kbd></li>
<li><kbd>com.apple.eio</kbd></li>
</ul>
</li>
<li>Provide developers with a near-common set of features for platforms (that is, Windows and Linux) in addition to OS X. The common features include:
<ul>
<li>Login/logout handler with event listeners</li>
<li>Screen lock handler with event listeners</li>
<li>Task bar / dock actions to include:
<ul>
<li>Requesting user attention</li>
<li>Indicating task progress</li>
<li>Action shortcuts</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The new API will be added to the <kbd>java.awt.Desktop</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhanced method handles [JEP-274]</h1>
                </header>
            
            <article>
                
<p>The <strong>Enhanced Method Handles</strong> JEP-274 was to improve the following listed classes, to make common usage easier with improved optimizations:</p>
<ul>
<li><kbd>MethodHandle</kbd> class</li>
<li><kbd>MethodHandles</kbd> class</li>
<li><kbd>MethodHandles.Lookup</kbd> class</li>
</ul>
<p>The listed classes are all part of the <kbd>java.lang.invoke</kbd> package, which has been updated as part of the Java 9 platform. The improvements were made possible through the use of lookup refinement and <kbd>MethodHandle</kbd> combinations <kbd>for</kbd> loops and <kbd>try...finally</kbd> blocks.</p>
<p>In this section, we will look at the following regarding JEP-274:</p>
<ul>
<li>Reason for the enhancement</li>
<li>Lookup functions</li>
<li>Argument handling</li>
<li>Additional combinations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reason for the enhancement</h1>
                </header>
            
            <article>
                
<p>This enhancement stemmed from developer feedback and the desire to make the <kbd>MethodHandle</kbd>, <kbd>MethodHandles</kbd>, and <kbd>MethodHandles.Lookup</kbd> classes much easier to use. There was also the call to add additional use cases.</p>
<p>The changes resulted in the following benefits:</p>
<ul>
<li>Enabled precision in the usage of the <kbd>MethodHandle</kbd> API</li>
<li>Instantiation reduction</li>
<li>Increased JVM compiler optimizations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lookup functions</h1>
                </header>
            
            <article>
                
<p>Changes regarding lookup functions, for the Java 9 platform, include the following:</p>
<ul>
<li><kbd>MethodHandles</kbd> can now be bound to non-abstract methods in interfaces</li>
<li>The lookup API allows class lookups from different contexts</li>
</ul>
<p>The <kbd>MethodHandles.Lookup.findSpecial(Class&lt;?&gt; refs, String name, MethodType type, Class&lt;?&gt; specialCaller)</kbd> class has been modified to permit locating super-callable methods on interfaces.</p>
<p>In addition, the following methods have been added to the <kbd>MethodHandles.Lookup</kbd> class:</p>
<ul>
<li><kbd>Class&lt;?&gt; findClass(String targetName)</kbd></li>
<li><kbd>Class&lt;?&gt; accessClass(Class&lt;?&gt; targetClass)</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Argument handling</h1>
                </header>
            
            <article>
                
<p>Three updates were made to improve <kbd>MethodHandle</kbd> argument handling for the Java 9 platform. These changes are highlighted as follows:</p>
<ul>
<li>Argument folding using <kbd>foldArguments(MethodHandle target, MethodHandle combinator)</kbd> did not previously have a position argument.
<ul>
<li>Argument collection using the <kbd>MethodHandle.asCollector(Class&lt;?&gt; arrayType, int arrayLength)</kbd> method did not previously support collecting the arguments into an array except for the trailing element. This has been changed, and there is now an additional <kbd>asCollector</kbd> method to support that functionality in Java 9.</li>
</ul>
</li>
<li>Argument spreading using the <kbd>MethodHandle.asSpreader(Class&lt;?&gt; arrayType, int arrayLength)</kbd> method spreads the contents of the trailing array to a number of arguments, in a reverse method of argument collection. Argument spreading has been modified to support the expansion of an array anywhere in the method signature.</li>
</ul>
<div class="packt_infobox">The new method definitions for the updated <kbd>asCollector</kbd> and <kbd>asSpreader</kbd> methods are provided in the next section.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional combinations</h1>
                </header>
            
            <article>
                
<p>The following addition combinations have been added to support the ease of use and optimizations for the <kbd>MethodHandle</kbd><span>,</span> <kbd>MethodHandles</kbd><span>, and</span> <kbd>MethodHandles.Lookup</kbd> <span>classes</span> of the <kbd>java.lang.invoke</kbd> package in the Java 9 platform:</p>
<ul>
<li>Generic loop abstraction:
<ul>
<li><kbd>MethodHandle loop(MethodHandle[] . . . clauses)</kbd></li>
</ul>
</li>
<li><kbd>While</kbd> loops:
<ul>
<li><kbd>MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body)</kbd></li>
</ul>
</li>
<li><kbd>Do...while</kbd> loops:
<ul>
<li><kbd><kbd>MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred)</kbd></kbd></li>
</ul>
</li>
<li>Counting loops:
<ul>
<li><kbd>MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body)</kbd></li>
</ul>
</li>
<li>Data structure iteration:
<ul>
<li><kbd>MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body)</kbd></li>
</ul>
</li>
<li><kbd>Try...finally</kbd> blocks:
<ul>
<li><kbd>MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup)</kbd></li>
</ul>
</li>
<li>Argument handling:
<ul>
<li>Argument spreading:
<ul>
<li><kbd>MethodHandle asSpreader(int pos, Class&lt;?&gt; arrayType, int arrayLength)</kbd></li>
</ul>
</li>
<li>Argument collection:
<ul>
<li><kbd>MethodHandle asCollector(int pos, Class&lt;?&gt; arrayType, int arrayLength)</kbd></li>
</ul>
</li>
<li>Argument folding:
<ul>
<li><kbd>MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner)</kbd></li>
</ul>
</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhanced deprecation [JEP-277]</h1>
                </header>
            
            <article>
                
<p>There are two facilities for expressing deprecation:</p>
<ul>
<li><kbd>@Deprecated</kbd> annotation</li>
<li><kbd>@deprecated</kbd> javadoc tag</li>
</ul>
<p>These facilities were introduced in Java SE 5 and JDK 1.1, respectively. The <kbd>@Deprecated</kbd> annotation was intended to annotate program components that should not be used because they were deemed dangerous and/or there was a better option. That was the intended use. Actual use varied including and because warnings were only provided at compile time; there was little reason to ignore the annotated code.</p>
<p>The <strong>Enhanced Deprecation</strong> JEP-277 was taken on to provide developers with clearer information regarding the intended disposition of the APIs in the specification documentation. Work on this JEP also resulted in a tool for analyzing a program's use of deprecated APIs.</p>
<p>To support this fidelity in information, the following components have been added to the <kbd>java.lang.Deprecated</kbd> annotation type:</p>
<ul>
<li><kbd>forRemoval()</kbd>:
<ul>
<li>Returns Boolean <kbd>true</kbd> if the API element has been slated for future removal</li>
<li>Returns Boolean <kbd>false</kbd> if the API element has not been slated for future removal but is deprecated</li>
<li>Default is <kbd>false</kbd></li>
</ul>
</li>
<li><kbd>since()</kbd>:
<ul>
<li>Returns a string containing the release or version number, at which point the specified API was marked as deprecated</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What the @Deprecated annotation really means</h1>
                </header>
            
            <article>
                
<p>When an API, or methods within an API, has/have been marked with the <kbd>@Deprecated</kbd> annotation, one or more of the following conditions typically exists:</p>
<ul>
<li>There are errors in the API for which there is no plan to fix them</li>
<li>Using the API is likely to result in errors</li>
<li>The API has been replaced by another API</li>
<li>The API is experimental</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered 16 JEPs that were incorporated into the Java 9 platform. These JEPs cover a wide range of tools and updates to APIs to make developing with Java easier, with greater optimization possibilities for our resulting programs. Our review included a look at the new HTTP client, changes to Javadoc and the Doclet API, the new JavaScript parser, JAR and JRE changes, the new Java-level JVM compiler interface, the new support for TIFF images, platform logging, XML Catalog support, collections, and the new platform-specific desktop features. We also looked at enhancements to method handling and the deprecation annotation.</p>
<p><span>In the next chapter, we will cover concurrency enhancements introduced with the Java 9 platform. Our primary focus</span> will <span>be the support for reactive programming that is provided by the flow class API. We will also explore additional concurrency enhancements introduced in Java 9.</span></p>


            </article>

            
        </section>
    </body></html>