- en: Chapter 8. Futures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。未来
- en: The first step towards reactive applications is to break out of synchronous
    processing. In general, applications waste a lot of time waiting for things to
    happen. Maybe we are waiting on an expensive computation—say, calculating the
    1000th Fibonacci number. Perhaps we are waiting for some information to be written
    to the database. We could also be waiting for a network call to return, bringing
    us the latest recommendations from our favorite online store.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 向反应式应用迈出的第一步是跳出同步处理。一般来说，应用程序浪费了很多时间等待事情发生。也许我们在等待一个昂贵的计算——比如计算第1000个斐波那契数。也许我们在等待某些信息被写入数据库。我们也可以在等待一个网络调用返回，带给我们我们最喜欢的在线商店的最新推荐。
- en: Regardless of what we're waiting for, we should never block clients of our application.
    This is crucial to achieve the responsiveness we desire when building reactive
    systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们等待什么，我们都不应该阻塞我们应用程序的客户端。这对于在构建反应式系统时实现我们想要的响应性至关重要。
- en: In an age where processing cores are abundant—my MacBook Pro has eight processor
    cores—blocking APIs severely underutilizes the resources we have at our disposal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理核心丰富的时代——我的MacBook Pro有八个处理器核心——阻塞API严重地未充分利用我们可用的资源。
- en: As we approach the end of this book, it is appropriate to step back a little
    and appreciate that not all classes of problems that deal with concurrent, asynchronous
    computations require the machinery of frameworks such as RxJava or `core.async`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们接近这本书的结尾，适当地退后一步，欣赏到并非所有处理并发、异步计算的类问题都需要像RxJava或`core.async`这样的框架机制。
- en: 'In this chapter, we will look at another abstraction that helps us develop
    concurrent, asynchronous applications: **futures**. We will learn about:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨另一个有助于我们开发并发、异步应用的抽象：**未来**。我们将了解：
- en: The problems and limitations with Clojure's implementation of futures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure实现futures的问题和局限性
- en: An alternative to Clojure's futures that provides asynchronous, composable semantics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure的futures的替代方案，提供异步、可组合的语义
- en: How to optimize concurrency in the face of blocking IO
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在面临阻塞IO的情况下优化并发
- en: Clojure futures
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure futures
- en: The first step toward fixing this issue—that is, to prevent a potentially long-running
    task from blocking our application—is to create new threads, which do the work
    and wait for it to complete. This way, we keep the application's main thread free
    to serve more clients.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一步——即防止一个可能长时间运行的任务阻塞我们的应用程序——是创建新的线程，这些线程执行工作并等待其完成。这样，我们保持应用程序的主线程空闲，以便为更多客户端提供服务。
- en: 'Working directly with threads, however, is tedious and error-prone, so Clojure''s
    core library includes futures, which are extremely simple to use:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 直接与线程工作，然而，却是繁琐且容易出错的，所以Clojure的核心库包括了未来（futures），它们的使用极其简单：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, the most interesting computations, such as the expensive one, return
    results we care about. This is where the first limitation of Clojure futures becomes
    apparent. If we attempt to retrieve the result of a future—by derefing it—before
    it has completed, the calling thread will block until the future returns a value.
    Try running the following slightly modified version of the previous snippet:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最有趣的计算，如昂贵的计算，返回我们关心的结果。这就是Clojure futures的第一个局限性变得明显的地方。如果我们尝试在完成之前检索未来的结果——通过解引用它——调用线程将阻塞，直到未来返回一个值。尝试运行以下略微修改的先前代码片段：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only difference now is that we immediately try to *deref* the future after
    we create it. Since the future isn't done, we sit there waiting for 5 seconds
    until it returns its value. Only then is our program allowed to continue.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一的区别是我们立即尝试在创建未来后立即*解引用*它。由于未来尚未完成，我们就会在那里等待5秒钟，直到它返回其值。只有在这种情况下，我们的程序才被允许继续。
- en: In general, this poses a problem when building modular systems. Often, a long-running
    operation like the one described earlier would be initiated within a specific
    module or function, and handed over to the next logical step for further processing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这在构建模块化系统时会导致问题。通常，像前面描述的那样，长时间运行的操作会在特定的模块或函数中启动，然后将其传递给下一个逻辑步骤以进行进一步处理。
- en: Clojure futures don't allow us to schedule a function to be executed when the
    future finishes in order to perform such further processing. This is an important
    feature in building reactive systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure futures不允许我们在未来完成时安排一个函数执行以进行进一步处理。这是构建反应式系统的一个重要功能。
- en: Fetching data in parallel
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行获取数据
- en: To understand better the issues outlined in the previous section, let's build
    a more complex example that fetches data about one of my favorite movies, *The
    Lord of the Rings*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解上一节中概述的问题，让我们构建一个更复杂的示例，该示例获取关于我喜欢的电影之一《指环王》的数据。
- en: The idea is that given the movie, we wish to retrieve its actors and, for each
    actor, retrieve the movies they have been a part of. We also would like to find
    out more information about each actor, such as their spouses.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，给定一部电影，我们希望检索其演员，并且对于每个演员，检索他们参与过的电影。我们还希望了解每个演员的更多信息，例如他们的配偶。
- en: Additionally, we will match each actor's movie against the list of top five
    movies in order to highlight them as such. Finally, the result will be printed
    to the screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将匹配每个演员的电影与顶级五部电影列表，以突出显示它们。最后，结果将打印到屏幕上。
- en: 'From the problem statement, we identify the following two main characteristics
    we will need to account for:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从问题陈述中，我们确定了以下两个主要特征，我们需要考虑：
- en: Some of these tasks need to be performed in parallel
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一些任务需要并行执行
- en: They establish dependencies on each other
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们相互建立依赖关系
- en: 'To get started, let''s create a new leiningen project:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们创建一个新的 leiningen 项目：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, open the core namespace file in `src/clj_futures_playground/core.clj`
    and add the data we will be working with:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `src/clj_futures_playground/core.clj` 中的核心命名空间文件，并添加我们将要使用的数据：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The namespace declaration is simple and only requires the `pprint` function,
    which will help us print our result in an easy-to-read format. With all the data
    in place, we can create the functions that will simulate remote services responsible
    for fetching the relevant data:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间声明很简单，只需要 `pprint` 函数，这将帮助我们以易于阅读的格式打印我们的结果。有了所有数据，我们可以创建模拟远程服务的函数，这些服务负责获取相关数据：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each `service` function sleeps the current thread by a given amount of time
    to simulate a slow network. The functions `cast-by-movie` and `Top 5` each returns
    a future, indicating we wish to fetch this data on a different thread. The remaining
    functions simply return the actual data. They will also be executed in a different
    thread, however, as we will see shortly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `service` 函数通过给定的时间量暂停当前线程以模拟缓慢的网络。函数 `cast-by-movie` 和 `Top 5` 每个都返回一个 future，表示我们希望在另一个线程上获取这些数据。其余的函数简单地返回实际数据。然而，它们也将在一个不同的线程中执行，正如我们很快将看到的。
- en: 'The next thing we need is a function to aggregate all fetched data, match spouses
    to actors, and highlight movies in the **Top 5** list. We''ll call it the `aggregate-actor-data`
    function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要一个函数来聚合所有获取的数据，将配偶与演员匹配，并突出显示 **Top 5** 列表中的电影。我们将称之为 `aggregate-actor-data`
    函数：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding function is fairly straightforward. It simply zips spouses and
    movies together, building a map of keys `:name`, `:spouse`, and `:movies`. It
    further transforms `movies` to append the **Top 5** suffix to the ones in the
    `top-5` list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数相当直接。它只是将配偶和电影组合在一起，构建一个键为 `:name`、`:spouse` 和 `:movies` 的映射。它进一步将 `movies`
    转换为在 `top-5` 列表中的项后面添加 **Top 5** 后缀。
- en: 'The last piece of the puzzle is the `-main` function, which allows us to run
    the program from the command line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是 `-main` 函数，它允许我们从命令行运行程序：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, we set up a number of `let` bindings. The first, `cast`, is the result
    of calling `cast-by-movie`, which returns a future.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置了一系列 `let` 绑定。第一个，`cast`，是调用 `cast-by-movie` 的结果，它返回一个 future。
- en: 'The next binding, `movies`, uses a function we haven''t seen before: `pmap`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个绑定，`movies`，使用了一个我们之前没有见过的函数：`pmap`。
- en: The `pmap` function works like `map`, except the function is mapped over the
    items in the list in parallel. The `pmap` function uses futures under the covers
    and that is the reason `movies-by-actor` doesn't return a future—it leaves that
    for `pmap` to handle.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`pmap` 函数类似于 `map`，除了函数是并行映射到列表中的项。`pmap` 函数在幕后使用 futures，这就是为什么 `movies-by-actor`
    不返回 future——它将这个任务留给 `pmap` 处理。'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `pmap` function is actually meant for CPU-bound operations, but is used
    here to keep the code simple. In the face of blocking IO, `pmap` wouldn't perform
    optimally. We will talk more about blocking IO later in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`pmap` 函数实际上是为 CPU 密集型操作设计的，但在这里使用是为了使代码简单。面对阻塞 I/O，`pmap` 不会表现最优。我们将在本章后面更多地讨论阻塞
    I/O。'
- en: We get the list of actors by *derefing* the `cast` binding, which, as we saw
    in the previous section, blocks the current thread waiting for the asynchronous
    fetch to finish. Once all results are ready, we simply call the `aggregate-actor-data`
    function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过*deref* `cast`绑定来获取演员列表，正如我们在上一节中看到的，这会阻塞当前线程等待异步获取完成。一旦所有结果都准备好了，我们只需调用`aggregate-actor-data`函数。
- en: Lastly, we call the `shutdown-agents` function, which shuts down the **Thread
    Pool** backing futures in Clojure. This is necessary for our program to terminate
    properly, otherwise it would simply hang in the terminal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`shutdown-agents`函数，这将关闭Clojure中futures背后的**线程池**。这对于我们的程序正确终止是必要的，否则它会在终端中简单地挂起。
- en: 'To run the program, type the following in the terminal, under the project''s
    root directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，请在终端中（在项目根目录下）输入以下内容：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will have noticed that the program takes a while to print the first message.
    Additionally, because futures block when they are derefed , the program doesn't
    start fetching the list of top five movies until it has completely finished fetching
    the cast of *The Lord of The Rings*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到程序需要一段时间才能打印出第一条消息。此外，因为当futures被解引用时它们会阻塞，所以程序只有在完全完成《指环王》的演员阵容的获取后才会开始获取前五部电影的列表。
- en: 'Let''s have a look at why that is so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么是这样的：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This prevents `top-5`—a completely independent parallel data fetch—from running
    before we retrieve the movie's cast.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这防止了`top-5`——一个完全独立的并行数据获取——在我们检索电影的演员阵容之前运行。
- en: Of course, this is a contrived example, and we could solve this particular annoyance
    by calling `top-5` before anything else. The problem is that the solution isn't
    always crystal clear and ideally we should not have to worry about the order of
    execution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个人为的例子，我们可以在调用`top-5`之前解决这个特定的烦恼。问题是解决方案并不总是那么清晰，理想情况下我们不应该担心执行顺序。
- en: As we will see in the next section, there is a better way.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节中看到的，有更好的方法。
- en: Imminent – a composable futures library for Clojure
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Imminent – 一个用于Clojure的可组合futures库
- en: In the past few months, I have been working on an open source library that aims
    to fix the previous issues with Clojure futures. The result of this work is called
    *imminent* (see [https://github.com/leonardoborges/imminent](https://github.com/leonardoborges/imminent)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几个月里，我一直在开发一个开源库，旨在解决Clojure futures之前的问题。这项工作的结果是称为*imminent*（见[https://github.com/leonardoborges/imminent](https://github.com/leonardoborges/imminent)）的库。
- en: The fundamental difference is that imminent futures are asynchronous by default
    and provide a number of combinators that allow us to declaratively write our programs
    without having to worry about its order of execution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的区别在于imminent futures默认是异步的，并提供了一些组合子，允许我们声明性地编写程序，而无需担心其执行顺序。
- en: The best way to demonstrate how the library works is to rewrite the previous
    movies example in it. We will do this in two steps.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 展示库如何工作的最佳方式是将之前的电影示例重写进其中。我们将分两步进行。
- en: 'First, we will examine individually the bits of imminent''s API that will be
    part of our final solution. Then, we''ll put it all together in a working application.
    Let''s start by creating a new project:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将单独检查即将到来的API的各个部分，这些部分将是我们最终解决方案的一部分。然后，我们将把它们全部整合到一个工作应用中。让我们先创建一个新的项目：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, add a dependency on imminent to your `project.clj`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将imminent的依赖项添加到你的`project.clj`中：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, create a new file, `src/imminent_playground/repl.clj`, and add imminent''s
    core namespace:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个新的文件，`src/imminent_playground/repl.clj`，并添加imminent的核心命名空间：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All the following examples should be in this file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的以下示例都应该在这个文件中。
- en: Creating futures
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建futures
- en: 'Creating a future in imminent isn''t much different from creating a future
    in Clojure. It''s as simple as the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在imminent中创建未来与在Clojure中创建未来并没有太大的区别。它就像以下这样简单：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What looks very different, however, is the return value. A key decision in
    imminent''s API is to represent the value of a computation as either a `Success`
    or a `Failure` type. Success, as in the preceding example, wraps the result of
    the computation. Failure, as you might have guessed, will wrap any exceptions
    that happened in the future:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看起来非常不同的是返回值。imminent API中的一个关键决策是将计算的值表示为`Success`或`Failure`类型。正如先前的例子所示，Success封装了计算的成果。Failure，正如你可能猜到的，将封装未来中发生的任何异常：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, you're not limited to exceptions only. We can use the `failed-future`
    function to create a future that completes immediately with the given reason,
    which, in the second example, is simply a keyword.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你不仅限于异常。我们可以使用`failed-future`函数创建一个立即完成给定原因的未来，在第二个例子中，这个原因只是一个关键字。
- en: 'The next question we might ask is "How do we get the result out of a future?".
    As with Clojure futures, we can deref it as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能接下来会问的问题是“我们如何从未来中获取结果？”。与Clojure中的未来类似，我们可以按照以下方式解引用它：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The idiom of using a double-deref is common, so imminent provides the convenience
    shown, `dderef`, which is equivalent to calling `deref` twice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双重解引用的惯用用法很常见，因此imminent提供了这样的便利，即`dderef`，它相当于调用`deref`两次。
- en: 'However, different from Clojure futures, this is a non-blocking operation,
    so if the future hasn''t completed yet, the following is what you''ll get:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与Clojure未来不同，这是一个非阻塞操作，所以如果未来还没有完成，你将得到以下结果：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The initial state of a future is `unresolved`, so unless you are absolutely
    certain a future has completed, derefing might not be the best way to work with
    the result of a computation. This is where combinators become useful.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的初始状态是`unresolved`，除非你绝对确定未来已经完成，否则解引用可能不是处理计算结果的最佳方式。这就是组合子变得有用的地方。
- en: Combinators and event handlers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合子和事件处理器
- en: 'Let''s say we would like to double the value in the age future. As we would
    with lists, we can simply map a function over the future to do just this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将年龄未来的值加倍。就像我们对列表做的那样，我们可以简单地映射一个函数到未来上，以完成这个操作：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While `i/future` schedules its body for execution on a separate thread, it's
    worth noting that future combinators such as `map`, `filter`, and so on, do not
    create a new thread immediately. Instead, they schedule a function to be executed
    asynchronously in the thread pool once the original future completes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`i/future`将主体调度到单独的线程上执行，但值得注意的是，未来的组合子如`map`、`filter`等并不会立即创建一个新的线程。相反，它们在原始未来完成之后，将函数调度到线程池中异步执行。
- en: 'Another way to do something with the value of a future is to use the `on-success`
    event handler that gets called with the wrapped value of the future in case it
    is successful:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用未来值的方法是使用`on-success`事件处理器，它在未来成功时被调用，并带有未来的封装值：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, an `on-failure` handler exists, which does the same for `Failure`
    types. While on the subject of failures, imminent futures understand the context
    in which they are being executed and, if the current future yields a `Failure`,
    it simply short-circuits the computation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，存在一个`on-failure`处理器，它对`Failure`类型做同样的事情。在讨论失败的话题时，imminent未来理解它们被执行的上下文，如果当前未来产生一个`Failure`，它将简单地短路计算：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, we don't get a new error, but rather the original
    exception contained in `failed-computation`. The function passed to `map` never
    runs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们不会得到一个新的错误，而是`failed-computation`中包含的原始异常。传递给`map`的函数永远不会运行。
- en: 'The decision to wrap the result of a future in a type such as `Success` or
    `Failure` might seem arbitrary but is actually quite the opposite. Both types
    implement the protocol `IReturn`—and a couple of other ones—which comes with a
    set of useful functions, one of which is `map`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 决定将未来的结果封装在`Success`或`Failure`这样的类型中可能看起来是随意的，但实际上恰恰相反。这两种类型都实现了`IReturn`协议——以及一些其他协议，它们附带了一系列有用的函数，其中之一就是`map`函数：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We get a similar behavior here as we did previously: mapping a function over
    a failure simply short-circuits the whole computation. If you do, however, wish
    to map over the failure, you can use map''s counterpart map-failure, which behaves
    similarly to map but is its inverse:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里得到的行为与我们之前的行为相似：将函数映射到失败上只是简单地短路整个计算。然而，如果你确实希望映射到失败上，你可以使用map的对应函数`map-failure`，它的工作方式与map类似，但它是其逆操作：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This plays well with the last event handlers imminent provides—`on-complete`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这与最后提供的事件处理器`on-complete`配合得很好：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: On contrary to `on-success` and `on-failure`, `on-complete` calls the provided
    function with the result type wrapper, so it is a convenient way to handle both
    cases in a single function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与`on-success`和`on-failure`不同，`on-complete`使用结果类型封装调用提供的函数，因此它是处理单个函数中两种情况的一种方便方式。
- en: 'Coming back to combinators, sometimes we will need to map a function over a
    future, which itself returns a future:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回到组合子，有时我们需要将函数映射到一个返回未来的未来上：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `range-future` function returns a successful future that yields a range
    of *n*. The `const-future` function is analogous to `failed-future`, except it
    immediately completes the future with a `Success` type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`range-future`函数返回一个成功的期货，它产生一个范围`n`。`const-future`函数与`failed-future`类似，但它立即使用`Success`类型完成期货。'
- en: However, we end up with a nested future, which is almost never what you want.
    That's OK. This is precisely the scenario in which you would use another combinator,
    `flatmap`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们最终得到一个嵌套的期货，这几乎从来不是你想要的。没关系。这正是你将使用另一个组合子`flatmap`的场景。
- en: 'You can think of it as `mapcat` for futures—it flattens the computation for
    us:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把它想象成针对期货的`mapcat`——它为我们简化了计算过程：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another very useful combinator is used to bring together multiple computations
    to be used in a single function—`sequence`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的组合子是用来将多个计算汇集到单个函数中使用的——`sequence`：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Essentially, `sequence` creates a new future, which will complete only when
    all other futures in the vector have completed or any one of them have failed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`sequence`创建了一个新的期货，它将仅在向量中的所有其他期货都完成或其中任何一个失败时才完成。
- en: 'This is a nice segue into the last combinator we will look at—`map-future`—which
    we would use in place of `pmap`, used in the movies example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这很自然地引出了我们将要查看的最后一个组合子——`map-future`——我们将用它来代替电影示例中使用的`pmap`：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, `calculate-double` is a function that returns a future
    with the value `n` doubled. The `map-future` function then maps `calculate-double`
    over the list, effectively performing the calculations in parallel. Finally, `map-future`
    sequences all futures together, returning a single future, which yields the result
    of all computations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`calculate-double`是一个返回值`n`翻倍的期货的函数。`map-future`函数随后将`calculate-double`映射到列表上，实际上是在并行执行计算。最后，`map-future`将所有期货序列化，返回一个单一的期货，它提供了所有计算的结果。
- en: Because we are performing a number of parallel computations and don't really
    know when they will finish, we call `await` on the future, which is a way to block
    the current thread until its result is ready. In general, you would use the combinators
    and event handlers instead, but for this example, using `await` is acceptable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在执行多个并行计算，并且不知道它们何时会完成，所以我们调用`await`在期货上，这是一种阻塞当前线程直到其结果准备好的方法。通常，你会使用组合子和事件处理器，但在这个例子中，使用`await`是可以接受的。
- en: Imminent's API provides many more combinators, which help us write asynchronous
    programs in a declarative way. This section gave us a taste of what is possible
    with the API and is enough to allow us to write the movies example using imminent
    futures.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Imminent的API提供了许多更多的组合子，这有助于我们以声明式的方式编写异步程序。本节让我们领略了API的强大功能，足以让我们使用imminent期货编写电影示例。
- en: The movies example revisited
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次审视电影示例
- en: 'Still within our `imminent-playground` project, open the `src/imminent_playground/core.clj`
    file and add the appropriate definitions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在我们的`imminent-playground`项目中，打开`src/imminent_playground/core.clj`文件并添加适当的定义：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The main difference is that all of them now return an imminent future. The `aggregate-actor-data`
    function is also the same as before.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别是它们现在都返回一个imminent期货。`aggregate-actor-data`函数与之前相同。
- en: 'This brings us to the `-main` function, which was rewritten to use imminent
    combinators:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到了`-main`函数，它被重写为使用imminent组合子：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The function starts much like its previous version, and even the first binding,
    `cast`, looks familiar. Next we have `movies`, which is obtained by fetching an
    actor''s movies in parallel. This in itself returns a future, so we `flatmap`
    it over the `cast` future to obtain our final result:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的起始部分与之前的版本非常相似，甚至第一个绑定`cast`看起来也很熟悉。接下来是`movies`，它是通过并行获取一个演员的电影得到的。这本身返回一个期货，所以我们通过`flatmap`在`cast`期货上，以获得最终结果：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`spouses` works in exactly the same way as `movies`, which brings us to `result`.
    This is where we would like to bring all asynchronous computations together. Therefore,
    we use the `sequence` combinator:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`spouses`与`movies`的工作方式完全相同，这带我们来到了`result`。这是我们希望将所有异步计算汇集在一起的地方。因此，我们使用`sequence`组合子：'
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we decide to block on the `result` future—by using await—so we can
    print the final result:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们决定通过使用`await`阻塞在`result`期货上——这样我们就可以打印出最终结果：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We run the program in the same way as before, so simply type the following
    in the command line, under the project''s root directory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与之前相同的方式运行程序，所以只需在命令行中输入以下内容，在项目的根目录下：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The result output was trimmed as it is exactly the same as before, but two
    things are different and deserve attention:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果被裁剪了，因为它与之前完全相同，但有两点不同，值得注意：
- en: The first output, **Fetching data...**, is printed to the screen a lot faster
    than in the example using Clojure futures
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个输出，**获取数据...**，打印到屏幕上的速度比使用Clojure futures的示例快得多
- en: The overall time it took to fetch all that is shorter, clocking in at just over
    7 seconds
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有这些所需的总时间更短，仅超过7秒
- en: This highlights the asynchronous nature of imminent futures and combinators.
    The only time we had to wait is when we explicitly called `await` at the end of
    the program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这突出了imminent futures和组合器的异步性质。我们唯一需要等待的时间是在程序末尾显式调用`await`时。
- en: 'More specifically, the performance boost comes from the following section in
    the code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，性能提升来自以下代码段：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Because none of the previous bindings block the current thread, we never have
    to wait to kick off `top-5` in parallel, shaving off roughly 3 seconds from the
    overall execution time. We didn't have to explicitly think about the order of
    execution—the combinators simply did the right thing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前的所有绑定都不会阻塞当前线程，所以我们永远不需要等待并行启动`top-5`，从而从总体执行时间中节省了大约3秒。我们不需要显式考虑执行顺序——组合器只是做了正确的事情。
- en: 'Finally, one last difference is that we didn''t have to explicitly call `shutdown-agents`
    as before. The reason for this is that imminent uses a different type of thread
    pool: a `ForkJoinPool` (see [http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.html)).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个不同之处是我们不再需要像以前那样显式调用`shutdown-agents`。这是因为imminent使用了一种不同类型的线程池：一个`ForkJoinPool`（参见[http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.html)）。
- en: This pool has a number of advantages—each with its own trade-off—over the other
    thread pools, and one characteristic is that we don't need to explicitly shut
    it down—all threads it creates daemon threads.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个池子相对于其他线程池有许多优点——每个都有自己的权衡——其中一个特点是，我们不需要显式关闭它——它创建的所有线程都是守护线程。
- en: When the JVM shuts down, it hangs waiting for all non-daemon threads to finish.
    Only then does it exit. That's why using Clojure futures would cause the JVM to
    hang, if we had not called `shutdown-agents`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM关闭时，它会挂起等待所有非守护线程完成。只有在这种情况下，它才会退出。这就是为什么如果我们没有调用`shutdown-agents`，使用Clojure
    futures会导致JVM挂起的原因。
- en: 'All threads created by the ForkJoinPool are set as daemon threads by default:
    when the JVM attempts to shut down, and if the only threads running are daemon
    ones, they are abandoned and the JVM exits gracefully.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ForkJoinPool创建的所有线程默认设置为守护线程：当JVM尝试关闭时，如果运行的唯一线程是守护线程，它们将被放弃，JVM优雅地退出。
- en: Combinators such as `map` and `flatmap`, as well as the functions `sequence`
    and `map-future`, aren't exclusive to futures. They have many more fundamental
    principles by which they abide, making them useful in a range of domains. Understanding
    these principles isn't necessary for following the contents of this book. Should
    you want to know more about these principles, please refer to the [Appendix](part0070_split_000.html#page
    "Appendix A. The Algebra of Library Design") , *The Algebra of Library Design*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如`map`和`flatmap`之类的组合器以及`sequence`和`map-future`函数并不局限于future。它们遵循许多更基本的原则，这使得它们在多个领域都有用。理解这些原则对于理解本书的内容不是必要的。如果您想了解更多关于这些原则的信息，请参阅[附录](part0070_split_000.html#page
    "附录 A. The Algebra of Library Design")，*《库设计的代数》*。
- en: Futures and blocking IO
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Futures和阻塞IO
- en: The choice of using ForkJoinPool for imminent is deliberate. The ForkJoinPool—added
    on Java 7—is extremely smart. When created, you give it a desired level of `parallelism`,
    which defaults to the number of available processors.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ForkJoinPool作为imminent的选择是故意的。ForkJoinPool是在Java 7中添加的，非常智能。创建时，你给它一个期望的`parallelism`级别，默认为可用的处理器数量。
- en: ForkJoinPool then attempts to honor the desired parallelism by dynamically shrinking
    and expanding the pool as required. When a task is submitted to this pool, it
    doesn't necessarily create a new thread if it doesn't have to. This allows the
    pool to serve an extremely large number of tasks with a much smaller number of
    actual threads.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ForkJoinPool会尝试通过动态缩小和扩大池子来满足所需的并行性。当一个任务提交到这个池子时，如果不需要，它不一定创建一个新的线程。这使得池子能够用更少的实际线程服务大量的任务。
- en: However, it cannot guarantee such optimizations in the face of blocking IO,
    as it can't know whether the thread is blocking waiting for an external resource.
    Nevertheless, ForkJoinPool provides a mechanism by which threads can notify the
    pool when they might block.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，面对阻塞 I/O 时，它不能保证这样的优化，因为它无法知道线程是否正在阻塞等待外部资源。尽管如此，ForkJoinPool 提供了一种机制，允许线程在可能阻塞时通知池。
- en: 'Imminent takes advantage of this mechanism by implementing the `ManagedBlocker`
    (see [http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.ManagedBlocker.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.ManagedBlocker.html))
    interface—and provides another way to create futures, as demonstrated here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Imminent 通过实现 `ManagedBlocker` 接口（见 [http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.ManagedBlocker.html](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.ManagedBlocker.html)）利用了这一机制，并提供了另一种创建未来的方法，如下所示：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `blocking-future` and `blocking-future-call` have the same semantics as
    their counterparts, `future` and `future-call`, but should be used when the task
    to be performed is of a blocking nature (that is, not CPU-bound). This allows
    the ForkJoinPool to better utilize its resources, making it a powerful and flexible
    solution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`blocking-future` 和 `blocking-future-call` 与它们的对应物 `future` 和 `future-call`
    具有相同的语义，但应该在要执行的任务具有阻塞性质（即非 CPU 密集型）时使用。这允许 ForkJoinPool 更好地利用其资源，使其成为一个强大且灵活的解决方案。'
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that Clojure futures leave a lot to be desired.
    More specifically, Clojure futures don't provide a way to express dependencies
    between results. It doesn't mean, however, that we should dismiss futures altogether.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到 Clojure 的未来还有很多需要改进的地方。更具体地说，Clojure 的未来没有提供表达结果之间依赖关系的方法。但这并不意味着我们应该完全摒弃未来。
- en: They are still a useful abstraction and with the right semantics for asynchronous
    computations and a rich set of combinators—such as the ones provided by imminent—they
    can be a big ally in building reactive applications that are performant and responsive.
    Sometimes, this is all we need.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它们仍然是一个有用的抽象，并且对于异步计算具有正确的语义和丰富的组合器集——例如 Imminent 提供的——它们可以在构建性能和响应性强的反应式应用程序中成为强大的盟友。有时，这已经足够了。
- en: For the times where we need to model data that varies over time, we turn to
    richer frameworks inspired by **Functional Reactive Programming** (**FRP**) and
    **Compositional Event Systems** (**CES**) —such as RxJava—or **Communicating Sequential
    Processes** (**CSP**) —such as `core.async`. As they have a lot more to offer,
    much of this book has been dedicated to those approaches.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要模拟随时间变化的数据的情况，我们转向受 **函数式响应式编程**（**FRP**）和 **组合事件系统**（**CES**）启发的更丰富的框架——例如
    RxJava——或 **通信顺序进程**（**CSP**）——例如 `core.async`。由于它们提供了更多功能，本书的大部分内容都致力于这些方法。
- en: In the next chapter, we will go back to discussing FRP/CES by way of a case
    study.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过案例研究回顾 FRP/CES。
