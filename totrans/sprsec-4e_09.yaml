- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Opening up to OAuth 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OAuth 2** is a very popular form of trusted identity management that allows
    users to manage their identity through a single trusted provider. This convenient
    feature provides users with the security of storing their password and personal
    information with the trusted OAuth 2 provider, optionally disclosing personal
    information upon request. Additionally, an OAuth 2-enabled website offers the
    confidence that the users providing OAuth 2 credentials are who they say they
    are.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to set up your own OAuth 2 application in less than 5 minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the `JBCP calendar` application with a very rapid implementation
    of OAuth 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the conceptual architecture of OAuth 2 and how it provides your site
    with trustworthy user access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing OAuth 2-based user registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimenting with OAuth 2 attribute exchange for user profile functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring OAuth 2 support in `Spring Security`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the OAuth 2 provider connection workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating OpenID Connect providers with `Spring Security`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/ejucD](https://packt.link/ejucD).'
  prefs: []
  type: TYPE_NORMAL
- en: The Promising World of OAuth 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an application developer, you may have heard the term OAuth 2 thrown around
    a lot. OAuth 2 has been widely adopted by web service and software companies around
    the world and is integral to the way these companies interact and share information.
    But what exactly is it? In a nutshell, OAuth 2 is a protocol that allows distinct
    parties to share information and resources in a secure and reliable manner.
  prefs: []
  type: TYPE_NORMAL
- en: What about OAuth 1.0?
  prefs: []
  type: TYPE_NORMAL
- en: Built with the same motivation, OAuth 1.0 was designed and ratified in 2007\.
    However, it was criticized for being overly complex and also had issues with imprecise
    specifications, which led to insecure implementation. All of these issues contributed
    to the poor adoption of OAuth 1.0, and eventually led to the design and creation
    of OAuth 2.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 is the successor to OAuth 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that OAuth 2 is not backward compatible with OAuth
    1.0, and so OAuth 2 applications cannot integrate with OAuth 1.0 service providers.
  prefs: []
  type: TYPE_NORMAL
- en: This type of login—through a trusted third party—has been in existence for a
    long time, in many different forms (for example, *Google Identity Provider* or
    *Microsoft Entra ID* became two of the more notable central login services on
    the web for some time).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key concepts and components of OAuth 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Roles*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Owner (RO)**: The entity that can grant access to a protected resource.
    Typically, this is the end-user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: The application requesting access to the protected resource on
    behalf of the resource owner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization Server (AS)**: The server that authenticates the resource owner
    and issues access tokens after getting proper authorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Server (RS)**: The server hosting the protected resources that are
    being accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Authorization Grant*:'
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 defines several authorization grant types, such as Authorization Code,
    Implicit, Resource Owner Password Credentials, and Client Credentials. The grant
    type determines the flow and the way the client obtains the access token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Access Token*:'
  prefs: []
  type: TYPE_NORMAL
- en: The access token is a credential representing the authorization granted to the
    client. It is used to access protected resources on behalf of the resource owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scope*:'
  prefs: []
  type: TYPE_NORMAL
- en: Scopes define the extent of the access that a client is requesting. It specifies
    what actions the client intends to perform on the resource server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Authorization Endpoint and* *Token Endpoint*:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Authorization Endpoint` facilitates communication with the resource owner
    to secure an authorization grant, while the Token Endpoint facilitates the exchange
    of this grant for an access token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Redirect URI*:'
  prefs: []
  type: TYPE_NORMAL
- en: After the resource owner grants permission, the `Authorization Server` redirects
    the user back to the client application using a redirect URI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the OAuth 2.0 specification at [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the high-level relationship between a site
    integrating OAuth 2 during the login process and the Facebook OAuth 2 provider,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – OAuth 2 during the login process and the Facebook OAuth 2 provider](img/B21757_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – OAuth 2 during the login process and the Facebook OAuth 2 provider
  prefs: []
  type: TYPE_NORMAL
- en: We can see that submitting a form post will initiate a request to the OAuth
    provider, resulting in the provider displaying an authorization dialog asking
    the user to allow `jbcpcalendar` to gain permission to specific information from
    your OAuth provider account. This request contains a `uri` parameter called `code`.
    Once granted, the user is redirected back to `jbcpcalendar`, and the `code` parameter
    is included in the
  prefs: []
  type: TYPE_NORMAL
- en: '`uri` parameter. Then, the request is redirected to the OAuth provider again,
    to authorize `jbcpcalendar`. The OAuth provider then responds with an `access_token`
    that can be used to access the user’s OAuth information that `jbcpcalendar` was
    granted access to.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t trust OAuth 2 unequivocally!
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see a fundamental assumption that can fool users of the system.
    It is possible for us to sign up for an OAuth 2 provider account, which would
    make it appear as though we were James Gosling, even though we obviously are not.
    Do not make the false assumption that just because a user has a convincing-sounding
    OAuth 2 (or OAuth 2 delegate provider), they are who they say they are without
    requiring additional forms of identification. Thinking about it another way, if
    someone came to your door just claiming he was James Gosling, would you let him
    in without verifying his ID?
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth 2-enabled application then redirects the user to the OAuth 2 provider,
    and the user presents their credentials to the provider, which is then responsible
    for making an access decision. Once the access decision has been made by the provider,
    the provider redirects the user to the originating site, which is now assured
    of the user’s authenticity. OAuth 2 is much easier to understand once you have
    tried it. Let’s add OAuth 2 to the `JBCP calendar` login screen now!
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need OpenID Connect?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RFC 6749` ([https://datatracker.ietf.org/doc/html/rfc6749](https://datatracker.ietf.org/doc/html/rfc6749))
    and `RFC 6750` ([https://datatracker.ietf.org/doc/html/rfc6750](https://datatracker.ietf.org/doc/html/rfc6750)).
    Its primary goal is to streamline the process of verifying user identity through
    authentication performed by an `Authorization Server`, allowing for the retrieval
    of user profile information in a manner that is both interoperable and akin to
    REST principles.'
  prefs: []
  type: TYPE_NORMAL
- en: This protocol empowers developers of applications and websites to initiate sign-in
    processes and receive credible assertions regarding users, ensuring consistency
    across various platforms, including web-based, mobile, and JavaScript clients.
    The specification suite is adaptable, supporting a variety of optional features
    such as the encryption of identity data, discovery of `OpenID Providers`, and
    session logout.
  prefs: []
  type: TYPE_NORMAL
- en: 'For developers, OpenID Connect offers a secure and verifiable means of answering
    the crucial question: “Who is the individual presently using the connected browser
    or mobile app?” Notably, it alleviates the burden of handling passwords—typically
    associated with data breaches—by removing the need to set, store, and manage them.'
  prefs: []
  type: TYPE_NORMAL
- en: How OpenID Connect Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenID Connect facilitates the establishment of an Internet identity ecosystem
    by offering seamless integration, robust support, security, and privacy-preserving
    configuration. It emphasizes interoperability, extends support to a broad array
    of clients and devices, and allows any entity to function as an **OpenID** **Provider**
    (**OP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key concepts and components of `OpenID Connect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RP**, short **for Relying Party**, refers to an application or website that
    delegates its user authentication function to an **Identity** **Provider** (**IDP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OP** or **IDP**: An OP is an entity that has implemented the OpenID Connect
    and OAuth 2.0 protocols. Sometimes, OPs are denoted by the role they fulfill,
    such as a **Security Token Service** (**STS**), **IDP**, or an **Suthorization
    Server(AS)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity Token**: Serving as the outcome of an authentication process, an
    identity token includes, at a minimum, a user identifier (referred to as the *sub*
    or subject claim) and details about when and how the user authenticated. Additional
    identity data may also be included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: A client is software that requests tokens, either for user authentication
    or resource access (**RP**). Clients need to be registered with the OP and can
    take various forms, such as web applications, native mobile and desktop applications,
    etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User**: A user is an individual leveraging a registered client to access
    resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After highlighting the OpenID Connect principles as a protocol built on top
    of the OAuth 2 protocol, we will be learning how to set up OAuth 2 in our `JBCP
    Calendar` application using some popular providers.
  prefs: []
  type: TYPE_NORMAL
- en: Signing up for an OAuth 2 application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get the full value out of the exercise in this section (and be able to test
    logging in), you will need to create an application with a service provider. Currently,
    Spring Social supports Twitter, Facebook, Google, LinkedIn, and GitHub, and the
    list is growing.
  prefs: []
  type: TYPE_NORMAL
- en: To get the full value out of the exercises in this chapter, we recommend you
    have accounts with at least Google. We have set up accounts for the `jbcpcalendar`
    application, which we will be using for the remainder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following additional dependencies in your `build.gradle` file if
    you are leveraging the **OAuth** **2** feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source code in `chapter09.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `Spring Security OAuth 2` dependencies, we will now explore
    the `JBCP` `Calendar` application.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling OAuth 2.0 Login with Spring Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can see a common theme among the external authentication providers examined
    over the next several chapters. `Spring Security` provides comprehensive OAuth
    2 support. This section discusses how to integrate OAuth 2 into your servlet-based
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The `OAuth 2.0 Login` feature lets an application have users log in to the application
    by using their existing account with an OAuth 2.0 Provider (such as GitHub) or
    `OpenID Connect 1.0 Provider` (such as Google).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`OAuth 2.0 Login` is implemented by using the `Authorization Code Grant`, as
    specified in the `OAuth 2.0 Authorization Framework`, which you can find here:
    [https://tools.ietf.org/html/rfc6749#section-4.1](https://tools.ietf.org/html/rfc6749#section-4.1)
    and `OpenID Connect Core 1.0`, found here: [https://openid.net/specs/openid-connect-core-1_0.xhtml#CodeFlowAuth](https://openid.net/specs/openid-connect-core-1_0.xhtml#CodeFlowAuth).'
  prefs: []
  type: TYPE_NORMAL
- en: Initial Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section shows how to configure the `OAuth 2.0 Login` sample by using Google
    as the `Authentication Provider` and covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the instructions on the OpenID Connect page here: [https://developers.google.com/identity/openid-connect/openid-connect](https://developers.google.com/identity/openid-connect/openid-connect),
    starting in the *Setting up OAuth* *2.0* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing the `Obtain OAuth 2.0 credentials` instructions, you should
    have a new `OAuth Client` with credentials consisting of a **Client ID** and a
    **Client Secret**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This setup is important to configure our application as an **OAuth** **2** client.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Redirect URI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The redirect URI is the path in the application that the end-user’s user-agent
    is redirected back to after they have authenticated with Google and have granted
    access to the `OAuth Client` (created in the previous step) on the **Consent**
    page.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, ensure that the Authorized redirect URIs field is set to
    `https://localhost:8443/login/oauth2/code/google`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The default redirect URI template is `{baseUrl}/login/oauth2/code/{registrationId}`.
    The `registrationId` is a unique identifier for the `ClientRegistration`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `OAuth Client` runs behind a proxy server, you should check the proxy
    server configuration (follow this link: [https://docs.spring.io/spring-security/reference/features/exploits/http.xhtml#http-proxy-server](https://docs.spring.io/spring-security/reference/features/exploits/http.xhtml#http-proxy-server))
    to ensure the application is correctly configured. Also, see the supported URI
    template variables here: [https://docs.spring.io/spring-security/reference/servlet/oauth2/client/authorization-grants.xhtml#oauth2Client-auth-code-redirect-uri](https://docs.spring.io/spring-security/reference/servlet/oauth2/client/authorization-grants.xhtml#oauth2Client-auth-code-redirect-uri)
    for `redirect-uri`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the redirect URI is established, we will proceed to set up the `application.yml`
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configure application.yml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have a new `OAuth Client` with Google, you need to configure the
    application to use the `OAuth Client` for the authentication flow. To do so, go
    to `application.yml` and set the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have configured here the following client properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring.security.oauth2.client.registration` is the base property prefix for
    `OAuth` `Client` properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the base property prefix is the ID for the `ClientRegistration`, such
    as Google.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After configuring the OAuth 2 client properties, we need to register a `SecurityFilterChain`
    bean.
  prefs: []
  type: TYPE_NORMAL
- en: Register a SecurityFilterChain Bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example shows how to register a `SecurityFilterChain` bean with
    `@EnableWebSecurity` and enable `OAuth 2.0 login` through `httpSecurity.oauth2Login()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The next step after configuring the `SecurityFilterChain` bean is to update
    the `SpringSecurityUserContext` class.
  prefs: []
  type: TYPE_NORMAL
- en: Update the SpringSecurityUserContext class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getCurrentUser` in the `SpringSecurityUserContext` needs to reference the
    new authenticated user of type `DefaultOidcUser`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to adapt the current implementation to reference
    the `DefaultOidcUser` user type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After completing the previous steps, we will test the application.
  prefs: []
  type: TYPE_NORMAL
- en: Boot up the Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Launch the sample application and go to `https://localhost:8443/oauth2/authorization/google`.
    You will be redirected to the default login page, which displays a link for Google.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Google link, and you are then redirected to Google for authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `OAuth Client` retrieves your email address and basic profile information
    from the `UserInfo Endpoint` (find out more here: https://openid.net/specs/openid-connect-core-1_0.xhtml#UserInfo)
    and establishes an authenticated session.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, you should be able to complete a full login using the Google
    OAuth 2 provider. The redirects that occur are as follows. First, we initiate
    the OAuth 2 provider login as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – OAuth 2 Social login with Google](img/B21757_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – OAuth 2 Social login with Google
  prefs: []
  type: TYPE_NORMAL
- en: 'After filling in the login details, the user is redirected to the `JBCP Calendar`
    application and automatically logged in using the provider display name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Welcome page after successful authentication](img/B21757_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Welcome page after successful authentication
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the user exists in the application and is authenticated but not
    authorized on all the web pages. The page `Create Event` can only be accessed
    by authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like that in `chapter09.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Customize the Login Page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the OAuth 2.0 login page is auto-generated by the `DefaultLoginPageGeneratingFilter`.
    The default login page shows each configured `OAuth Client` with its `ClientRegistration.clientName`
    as a link, which is capable of initiating the `Authorization Request` (or OAuth
    2.0 Login).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For `DefaultLoginPageGeneratingFilter` to show links for configured `OAuth Clients`,
    the registered `ClientRegistrationRepository` needs to also implement `Iterable<ClientRegistration>`.
    See `InMemoryClientRegistrationRepository` for reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The link’s destination for each `OAuth Client` defaults to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows an example of adapting the `login.xhtml` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can use the login social button to authenticate your users with Google
    as an `Identity Provider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need also to make sure the user is redirected to the `jbcpcalendar` application
    and automatically logged in. The following example shows how to adapt a `SecurityConfig.java`
    to have a proper redirection after successful authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be able to complete a full login using Google’s OAuth
    2 provider. The redirects that occur are as follows. First, we initiate the OAuth
    2 provider login.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Login screen after successful authentication](img/B21757_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Login screen after successful authentication
  prefs: []
  type: TYPE_NORMAL
- en: We are then redirected to the `JBCP` `Calendar` application.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like that in `chapter09.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Additional OAuth 2 providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully integrated a single OAuth 2 provider using one of the popular
    OAuth 2 providers. There are several other providers available; we are going to
    add a few more providers so our users have more than one option. `Spring Security`
    currently supports the **Google**, **GitHub**, **Facebook**, and **Okta** providers
    natively. Including additional providers will require configuring custom provider
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: '`CommonOAuth2Provider` pre-defines a set of default client properties for a
    number of well-known providers that `Spring Security` supports natively, as mentioned
    previously.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `authorization-uri`, `token-uri`, and `user-info-uri` do not
    change often for a provider. Therefore, it makes sense to provide default values,
    to reduce the required configuration.
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated previously when we configured a Google client, only the `client-id`
    and `client-secret` properties are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add GitHub providers to the `JBCP` `calendar` application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Register your application in GitHub by following the steps given here: [https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app).
    At the end, save the `client-id` and `client-secret`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `https://localhost:8443/login/oauth2/code/github`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additional application properties need to be set, and each configured provider
    will automatically be registered with the `client-id` and `client-secret` keys
    from the provider application, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now add the new login options to our `login.xhtml` file to include the
    new provider `GitHub`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have the required details to connect to the additional providers for
    the JBCP calendar, and we can restart the `JBCP calendar` application and test
    logging in with the other OAuth 2 providers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like that in `chapter09.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When logging in now, we should be presented with additional provider options,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Social login options with Google and GitHub](img/B21757_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Social login options with Google and GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should be able to complete a full login using the Google
    OAuth 2 provider. The redirects that occur are as follows. First, we initiate
    the OAuth 2 provider login as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – OAuth 2 social login with GitHub](img/B21757_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – OAuth 2 social login with GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'We are then redirected to the provider authorization page, requesting the user
    to grant permission to the `jbcpcalendar` application as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – OAuth 2 GitHub consent screen](img/B21757_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – OAuth 2 GitHub consent screen
  prefs: []
  type: TYPE_NORMAL
- en: After authorizing the `jbcpcalendar` application, the user is redirected to
    the `jbcpcalendar` application and automatically logged in using the provider
    display name.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Custom Provider Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some OAuth 2.0 Providers that support multi-tenancy, which results
    in different protocol endpoints for each tenant (or sub-domain).
  prefs: []
  type: TYPE_NORMAL
- en: For example, an `OAuth Client` registered with `OKTA` is assigned to a specific
    sub-domain and has its own protocol endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you’ll require an **Okta developer account**. You can set one
    up by visiting [https://developer.okta.com/signup](https://developer.okta.com/signup).
  prefs: []
  type: TYPE_NORMAL
- en: 'For these cases, `Spring Boot 2.x` provides the following base property for
    configuring custom provider properties: `spring.security.oauth2.client.provider.[providerId]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The base property (`spring.security.oauth2.client.provider.okta`) allows for
    the custom configuration of protocol endpoint locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add the new login options to our `login.xhtml` file, to include
    with the new `OKTA` provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the required details to connect to the additional providers for
    the JBCP calendar, and we can restart the `JBCP calendar` application and test
    logging in with the custom OAuth 2 `OKTA` providers.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like that in `chapter09.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When logging in now, we should be presented with additional provider options,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Social login options with Google, GitHub, and OKTA](img/B21757_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Social login options with Google, GitHub, and OKTA
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Proof Key for Code Exchange (PKCE) support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PKCE** stands for **Proof Key for Code Exchange**. It is a security feature
    used in OAuth 2.0 authorization flows to mitigate certain types of attacks, particularly
    those targeting the authorization code flow.'
  prefs: []
  type: TYPE_NORMAL
- en: The traditional OAuth 2.0 authorization code flow, a client application redirects
    a user to an `Authorization Server`, the user authenticates and provides consent,
    and the `Authorization Server` issues an authorization code to the client. The
    client then exchanges this code for an access token.
  prefs: []
  type: TYPE_NORMAL
- en: PKCE is designed to prevent authorization code interception attacks. In these
    attacks, a malicious actor intercepts the authorization code as it’s being returned
    to the client, and then uses it to obtain an access token. PKCE adds an additional
    layer of security to this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence diagram describes how PKCE works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Social login options with Google, GitHub, and OKTA](img/B21757_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Social login options with Google, GitHub, and OKTA
  prefs: []
  type: TYPE_NORMAL
- en: 'Public clients receive support through the utilization of PKCE. For further
    information on PKCE, refer to this link: [https://datatracker.ietf.org/doc/html/rfc7636](https://datatracker.ietf.org/doc/html/rfc7636).
    PKCE is automatically employed when the client operates in an untrusted environment
    (e.g., native or web browser-based applications), rendering it unable to uphold
    the secrecy of its credentials when the following conditions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`client-secret` is omitted (or empty)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client-authentication-method` is set to `ClientAuthenticationMethod.NONE`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the OAuth 2.0 Provider supports PKCE for confidential clients (find out
    more about confidential clients: [https://datatracker.ietf.org/doc/html/rfc6749#section-2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-2.1)),
    you may (optionally) configure it using `DefaultServerOAuth2AuthorizationRequestResolver.setAuthorizationRequestCustomizer(OAuth2AuthorizationRequestCustomizers.withPkce()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to adapt a `SecurityConfig.java` to use PKCE
    by registering your own `OAuth2AuthorizationRequestResolver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like that in `chapter09.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID Connect 1.0 Logout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RP-Initiated Logout`, detailed at [https://openid.net/specs/openid-connect-rpinitiated-1_0.xhtml](https://openid.net/specs/openid-connect-rpinitiated-1_0.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where the `OpenID Provider` supports both `end_session_endpoint` URL
    from the *OpenID Provider’s Discovery Metadata*. You can achieve this by configuring
    the `ClientRegistration` with the `issuer-uri`, as outlined in [https://openid.net/specs/openid-connect-session-1_0.xhtml#OPMetadata](https://openid.net/specs/openid-connect-session-1_0.xhtml#OPMetadata):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can configure `OidcClientInitiatedLogoutSuccessHandler`, which implements
    RP-Initiated Logout, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like that in `chapter09.06-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic User Registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many applications need to hold data about their users locally, even if authentication
    is delegated to an external provider. This can be done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose a backend for your database, and set up some repositories (using Spring
    Data, say) for a custom `User` object that suits your needs and can be populated,
    fully or partially, from external authentication. For our `JBCP Calendar` application,
    we will adapt `CalendarUser` to add the provider information as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement and expose `OAuth2UserService` to call the `CalendarUser` object and
    implements `OAuth2User`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement and expose `OidcUserService` to call the `Authorization Server` as
    well as your database. Your implementation should return something that extends
    your custom User object and implements `OidcUser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: Include a new attribute within the User object to establish a connection with
    a distinct identifier from the external provider (distinct from the user’s name,
    yet uniquely associated with the account on the external platform).
  prefs: []
  type: TYPE_NORMAL
- en: One issue that would need to be resolved if supporting multiple providers is
    username conflicts between the various provider details returned.
  prefs: []
  type: TYPE_NORMAL
- en: If you log in to the `JBCP calendar` application with each of the listed providers—which
    then query the data that was stored in `H2 database`—you will find the data could
    be similar, if not exactly the same, based on the user’s account details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CALENDAR_USERS` table, we have two possible issues:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use the email attribute of the `UserDetails` object as the `user ID`
    to find the `JBCP calendar` users. But the `user ID`, can be different than an
    email for some other providers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, it is still possible that the user identifier for two different providers
    will be the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are not going to dive into the various ways to detect and correct this possible
    issue, but it is worth noting for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like that in `chapter09.07-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping User Authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GrantedAuthoritiesMapper` receives a collection of granted authorities,
    including a unique authority of the `OAuth2UserAuthority` type with the corresponding
    string identifier `OAUTH2_USER` (or `OidcUserAuthority` with the string identifier
    `OIDC_USER`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will provide a custom implementation of `GrantedAuthoritiesMapper` and configure
    it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to adapt a `SecurityConfig.java` to use the
    `GrantedAuthoritiesMapper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, you need to make sure the OIDC user roles already
    exist in the database.
  prefs: []
  type: TYPE_NORMAL
- en: For our `JBCP calendar` application, let’s define a user with the admin role.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, the user `calendarjbcp@gmail.com` has the admin role and can
    have access to the **All Events** page after successful authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like that in `chapter09.08-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Is OAuth 2 secure?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As support for OAuth 2 relies on the trustworthiness of the OAuth 2 provider
    and the verifiability of the provider’s response, security and authenticity are
    critical in order for the application to have confidence in the user’s OAuth 2-based
    login.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the designers of the OAuth 2 specification were very aware of
    this concern, and implemented a series of verification steps to prevent response
    forgery, replay attacks, and other types of tampering, which are explained as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response forgery** is prevented due to a combination of a shared secret key
    (created by the OAuth 2-enabled site prior to the initial request) and a one-way
    hashed message signature on the response itself. A malicious user tampering with
    the data in any of the response fields without having access to the shared secret
    key—and signature algorithm—would generate an invalid response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replay attacks** are prevented due to the inclusion of a nonce, or a one-time
    use, random key, which should be recorded by the OAuth 2-enabled site so that
    it cannot ever be reused. In this way, even a user attempting to reissue the response
    URL would be foiled because the receiving site would determine that the nonce
    had been previously used, and would invalidate the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most likely form of attack that could result in a compromised user interaction
    would be a **man-in-the-middle attack**, where a malicious user could intercept
    the user’s interaction between their computer and the OAuth 2 provider. A hypothetical
    attacker in this situation could be in a position to record the conversation between
    the user’s browser and the OAuth 2 provider, and record the secret key used when
    the request was initiated. The attacker, in this case, would need a very high
    level of sophistication and reasonably a complete implementation of the OAuth
    2 signature specification—in short, this is not likely to occur with any regularity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed OAuth 2, a relatively recent technology for user
    authentication and credentials management. OAuth 2 has a very wide reach on the
    web and has made great strides in usability and acceptance within the past year
    or two. Most public-facing sites on the modern web should plan on having some
    form of OAuth 2 support, and the `JBCP calendar` application is no exception!
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned about the following topics: the OAuth 2 authentication mechanism
    and its high-level architecture and key terminology. We also learned about OAuth
    2 login and automatic user registration with the `JBCP calendar` application.
    We also covered automatic login with OAuth 2 and the security of OAuth 2’s login
    responses.'
  prefs: []
  type: TYPE_NORMAL
- en: We covered one of the simplest single sign-on mechanisms to implement with `Spring
    Security`. One of the downsides is that it does not support a standard mechanism
    for a single logout. In the next chapter, we will explore SAML, another standard,
    single sign-on protocol that also supports single logout.
  prefs: []
  type: TYPE_NORMAL
