<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit Testing</h1>
                
            
            <article>
                
<p class="calibre3">In the last chapter, we learned how to create a web application that uses a database. In this chapter, we will learn how to write and execute unit tests in Eclipse for JEE applications. We will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11"><span>Creating and executing unit tests using Eclipse JEE</span></li>
<li class="calibre11">Executing unit tests from Eclipse IDE</li>
<li class="calibre11">Mocking external dependencies for unit tests</li>
<li class="calibre11">Calculating unit test coverage</li>
</ul>
<p class="calibre3">Testing the software that you develop is a very important part of the overall software development cycle. There are many types of testing; each one has a specific purpose, and each one varies in scope. Some examples of testing are functional testing, integration testing, scenario testing, and unit testing.</p>
<p class="calibre3">Of all these types, unit tests are the narrowest in scope and are typically coded and executed by developers. Each unit test is meant to test a specific and small piece of functionality (typically, a method in a class), and is expected to execute without any external dependencies. Here are some of the reasons why you should write efficient unit tests:</p>
<ul class="calibre10">
<li class="calibre11">To catch bugs early. If you find a bug in functional or integration testing, which have a much wider scope of testing, then it might be difficult to isolate the code that caused the bug. It is much easier to catch and fix bugs in unit testing, because unit tests, by definition, work in a narrower scope, and if a test fails, you will find out exactly where to go to fix the issue.</li>
<li class="calibre11">Unit tests can help you catch any regression that you might have introduced when editing the code. There are good tools and libraries available for automating the execution of unit tests. For example, using build tools such as Ant and Maven, you can execute unit tests at the end of a successful build, so that you will immediately find out if the changes you have made have broken any previously working code.</li>
</ul>
<p class="calibre3">As mentioned previously, writing unit tests and executing them is typically the responsibility of the developer. Therefore, most IDEs have good built-in support for writing and executing unit tests. Eclipse JEE is no exception. It has built-in support for JUnit, which is a popular unit testing framework for Java.</p>
<p class="calibre3">In this chapter, we will see how to write and execute JUnit tests for the <em class="calibre21">Course Management</em> web application that we built in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>. However, first, here is a quick introduction to JUnit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing JUnit</h1>
                
            
            <article>
                
<p class="calibre3">JUnit test classes are Java classes separate from the classes you want to test. Each test class can contain many test cases, which are just methods marked to be executed when JUnit tests are executed. A test suite is a collection of test classes.</p>
<p class="calibre3">The convention is to assign the test class the same name as that of the class you want to test, and append <kbd class="calibre13">Test</kbd> to that name. For example, if you wanted to test the <kbd class="calibre13">Course</kbd> class from the previous chapter, then you would create a JUnit test class and name it <kbd class="calibre13">CourseTest</kbd>. Test case (method) names start with <kbd class="calibre13">test</kbd>, followed by the name of the method in the class that you want to test; for example, if you wanted to test the <kbd class="calibre13">validate</kbd> method in the <kbd class="calibre13">Course</kbd> class, then you would create the <kbd class="calibre13">testValidate</kbd> method in the <kbd class="calibre13">CourseTest</kbd> class. Test classes are also created in the same package as the package in which the classes to be tested are present. In Maven projects, test classes are typically created under the <kbd class="calibre13">src/test/java</kbd> folder. The convention is to create the same package structure in the <kbd class="calibre13">test</kbd> folder as in the <kbd class="calibre13">src/main/java</kbd> folder.</p>
<p class="calibre3">JUnit supports annotations to mark unit tests and test suites. Here is a simple test case for the <kbd class="calibre13">Course</kbd> class:</p>
<pre class="calibre25">/** 
* Test for {@link Course} 
*/ 
Class CourseTest { 
  @Test 
  public void testValidate() { 
    Course course = new Course(); 
    Assert.assertFalse(course.validate()); 
    course.setName("course1") 
    Assert.assetFalse(course.validate()); 
    Course.setCredits(-5); 
    Assert.assetFalse(course.validate()); 
    course.setCredits(5); 
    Assert.assertTrue(course.validate()); 
  } 
} </pre>
<p class="calibre3">Let's assume that the <kbd class="calibre13">validate</kbd> method checks that the course <kbd class="calibre13">name</kbd> is not null and that <kbd class="calibre13">credits</kbd> is greater than zero.</p>
<p class="calibre3">The preceding test case is marked with the <kbd class="calibre13">@Test</kbd> annotation. It creates an instance of the <kbd class="calibre13">Course</kbd> class, and then calls the <kbd class="calibre13">Assert.assertFalse</kbd> method to make sure that the <kbd class="calibre13">validate</kbd> method returns <kbd class="calibre13">false</kbd>, because <kbd class="calibre13">name</kbd> and <kbd class="calibre13">credits</kbd> are not set, and they will have their default values, which are <kbd class="calibre13">null</kbd> and <kbd class="calibre13">0</kbd>, respectively. <kbd class="calibre13">Assert</kbd> is a class provided by the JUnit library, and has many assert methods to test many conditions (see <a href="http://junit.sourceforge.net/javadoc/org/junit/Assert.html" class="calibre9"><span>http://junit.sourceforge.net/javadoc/org/junit/Assert</span>.html</a> for more information).</p>
<p class="calibre3">The test case, then, only sets the name, and does the same validation again, expecting the <kbd class="calibre13">validate</kbd> method to return <kbd class="calibre13">false</kbd>, because the credits are still zero. Finally, the test case sets both the name and credits, and calls the <kbd class="calibre13">Assert.assertTrue</kbd> method to ensure that <kbd class="calibre13">course.validate()</kbd> returns <kbd class="calibre13">true</kbd>. If any of the assertions fail, then the test case fails.</p>
<p class="calibre3">Other than <kbd class="calibre13">@Test</kbd>, you can use the following annotations provided by JUnit:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">@Before</kbd> and <kbd class="calibre13">@After</kbd>: Methods annotated with these annotations are executed before and after each test. You may want to initialize resources in <kbd class="calibre13">@Before</kbd> and free them in <kbd class="calibre13">@After</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">@BeforeClass</kbd> and <kbd class="calibre13">@AfterClass</kbd>: Similar to <kbd class="calibre13">@Before</kbd> and <kbd class="calibre13">@After</kbd>, but instead of being called per test, these methods are called once per test class. A method with the <kbd class="calibre13">@BeforeClass</kbd> annotation is called before any of the test cases in that class are executed, and one with <kbd class="calibre13">@AfterClass</kbd> is called after all the test cases are executed.</li>
</ul>
<div class="packt_infobox"><br class="calibre26"/>
You can find more annotations for JUnit at <a href="https://junit.org/junit4/javadoc/latest/org/junit/package-summary.html" class="calibre17">https://junit.org/junit4/javadoc/latest/org/junit/package-summary.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating and executing unit tests using Eclipse JEE</h1>
                
            
            <article>
                
<p class="calibre3">To understand how to write unit tests, let's take the JDBC version of the <em class="calibre21">Course Management</em> application that we developed in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>. Let's start with a simple test case for validating a course. The following is the source code of <kbd class="calibre13">Course.java</kbd>:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch5.bean; 
 
import java.sql.SQLException; 
import java.util.List; 
 
import packt.book.jee.eclipse.ch5.dao.CourseDAO; 
 
public class Course { 
  private int id; 
  private String name; 
  private int credits; 
  private Teacher teacher; 
  private int teacherId; 
  private CourseDAO courseDAO = new CourseDAO(); 
 
  public int getId() { 
    return id; 
  } 
  public void setId(int id) { 
    this.id = id; 
  } 
  public String getName() { 
    return name; 
  } 
  public void setName(String name) { 
    this.name = name; 
  } 
  public int getCredits() { 
    return credits; 
  } 
  public void setCredits(int credits) { 
    this.credits = credits; 
  } 
  public boolean isValidCourse() { 
    return name != null &amp;&amp; credits != 0; 
  } 
  public Teacher getTeacher() { 
    return teacher; 
  } 
  public void setTeacher(Teacher teacher) { 
    this.teacher = teacher; 
  } 
  public void addCourse() throws SQLException { 
    courseDAO.addCourse(this); 
  } 
  public List&lt;Course&gt; getCourses() throws SQLException { 
    return courseDAO.getCourses(); 
  } 
  public int getTeacherId() { 
    return teacherId; 
  } 
  public void setTeacherId(int teacherId) { 
    this.teacherId = teacherId; 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating unit test cases</h1>
                
            
            <article>
                
<p class="calibre3">Maven projects follow certain conventions; the entire application source in a Maven project is in the <kbd class="calibre13">src/main/java</kbd> folder, and unit tests are expected to be in the <kbd class="calibre13">src/test/java</kbd> folder. In fact, when you create a Maven project in Eclipse, it creates the <kbd class="calibre13">src/test/java</kbd> folder for you. We are going to create our test cases in this folder. We are going to create the same package structure for the test classes as that for the application source; that is, to test the <kbd class="calibre13">packt.book.jee.eclipse.ch5.bean.Course</kbd> class, we will create the <kbd class="calibre13">packt.book.jee.eclipse.ch5.bean</kbd> package under the <kbd class="calibre13">src/test/java</kbd> folder and then create a JUnit test class called <kbd class="calibre13">CourseTest</kbd>, as follows:</p>
<ol class="calibre14">
<li value="1" class="calibre11">Right-click on the <kbd class="calibre13">src/test/java</kbd> folder in <span>Package Explorer</span> in Eclipse and select <span>New</span> | <span>JUnit Test Case</span> (if you do not find this option in the menu, select <span>New</span> | <span>Other</span>, and type <kbd class="calibre13">junit</kbd> into the <span>Filter</span> textbox. Then, select the <span>JUnit Test Case</span> option).</li>
<li value="2" class="calibre11">Enter the package name as <kbd class="calibre13">packt.book.jee.eclipse.ch5.bean</kbd> and the class name as <kbd class="calibre13">CourseTest</kbd>.</li>
</ol>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Click on the <span>Browse...</span> <span>button next to the </span><span>Class under test</span> <span>textbox. Type</span> <kbd class="calibre13">course</kbd> <span>into the <span>Filter</span> textbox and select the</span> <kbd class="calibre13">Course</kbd> <span>class:</span>
<ol start="2" class="calibre15"/>
</li>
</ol>
<div class="packt_figure1"><img src="../images/00127.jpeg" class="calibre143"/></div>
<div class="packt_figure1">Figure 5.1: JUnit test case wizard</div>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">Click <span>Next</span>. The page shows methods in the class (<kbd class="calibre13">Course</kbd>) for which we want to create the test cases. Select the methods that you want to create test cases for.</li>
<li class="calibre11" value="5"><span>We don't want to test getters and setters because they are simple methods and don't do much other than just getting or setting member variables. Presently, we will create a test case for only one method:</span> <kbd class="calibre13">isValidTestCase</kbd><span>. Select the checkbox for this method:</span></li>
</ol>
<div class="mce-root1"><img src="../images/00128.jpeg" class="calibre144"/></div>
<div class="packt_figure1">Figure 5.2: Select methods for test cases</div>
<ol start="6" class="calibre14">
<li value="6" class="calibre11">Click <span>Finish</span><span>. Eclipse checks whether JUnit libraries are included in your project, and if not, prompts you to include them:</span>
<ol start="4" class="calibre15"/>
</li>
</ol>
<div class="packt_figure1"><img src="../images/00129.jpeg" class="calibre145"/></div>
<div class="packt_figure1">Figure 5.3: Include JUnit libraries in project</div>
<ol start="7" class="calibre14">
<li value="7" class="calibre11">Click <span>OK</span>. Eclipse creates the package and the test class with one method/test case called <kbd class="calibre13">testIsValidCourse</kbd>. Note that the method is annotated with <kbd class="calibre13">@Test</kbd>, indicating that it is a JUnit test case.</li>
</ol>
<p class="calibre3">How do we test whether <kbd class="calibre13">isValidCourse</kbd> works as expected? We create an instance of the <kbd class="calibre13">Course</kbd> class, set some values that we know are valid/invalid, call the <kbd class="calibre13">isValidateCourse</kbd> method, and compare the results with the expected results. JUnit provides many methods in the <kbd class="calibre13">Assert</kbd> class to compare the actual results obtained by calling test methods with the expected results. So, let's add the test code to the <kbd class="calibre13">testIsValidCourse</kbd> method:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch5.bean; 
import org.junit.Assert; 
import org.junit.Test; 
public class CourseTest { 
 
  @Test 
  public void testIsValidCourse() { 
    Course course = new Course(); 
    //First validate without any values set 
    Assert.assertFalse(course.isValidCourse()); 
    //set  name 
    course.setName("course1"); 
    Assert.assertFalse(course.isValidCourse()); 
    //set zero credits 
    course.setCredits(0); 
    Assert.assertFalse(course.isValidCourse()); 
    //now set valid credits 
    course.setCredits(4); 
    Assert.assertTrue(course.isValidCourse()); 
  } 
 
} </pre>
<p class="calibre3">We first create an instance of the <kbd class="calibre13">Course</kbd> class, and without setting any of its values, call the <kbd class="calibre13">isValidCourse</kbd> method. We know that it is not a valid course because the name and credits are the required fields in a valid course. So, we check whether the returned value of <kbd class="calibre13">isValidCourse</kbd> is false by calling the <kbd class="calibre13">Assert.assertFalse</kbd> method. We then set the name and check again, expecting the instance to be an invalid course. Then, we set a <kbd class="calibre13">0</kbd> credits value for <kbd class="calibre13">Course</kbd>, and, finally, we set <kbd class="calibre13">4</kbd> credits for <kbd class="calibre13">Course</kbd>. Now, <kbd class="calibre13">isValidCourse</kbd> is expected to return <kbd class="calibre13">true</kbd> because both the name and credits are valid. We verify this by calling <kbd class="calibre13">Assert.assertTrue</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running unit test cases</h1>
                
            
            <article>
                
<p class="mce-root">Let's run this test case in Eclipse. Right-click on the file, or anywhere in the project in <span class="calibre12">Package Explorer</span>, and select the <span class="calibre12">Run As</span> | <span class="calibre12">JUnit Test</span> menu. Eclipse finds all unit tests in the project, executes them, and shows the results in the <span class="calibre12">JUnit</span> view:</p>
<div class="mce-root1"><img src="../images/00130.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 5.4: JUnit results view</div>
<p class="calibre3">This view shows a summary of the test cases run. In this case, it has run one test case, which was successful. The green bar shows that all test cases were executed successfully.</p>
<p class="calibre3">Now, let's add one more check into the method:</p>
<pre class="calibre25">  @Test 
  public void testIsValidCourse() { 
    ... 
    //set empty course name 
    course.setName(""); 
    Assert.assertFalse(course.isValidCourse()); 
  } </pre>
<p class="calibre3">Then, run the test case again:</p>
<div class="mce-root1"><img src="../images/00131.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 5.5: JUnit results view showing the failed test</div>
<p class="calibre3">The test case failed because <kbd class="calibre13">course.isValidCourse()</kbd> returned <kbd class="calibre13">true</kbd> when the course name was set to an empty string, while the test case expected the instance to be an invalid course. So, we need to modify the <kbd class="calibre13">isValidCourse</kbd> method of the <kbd class="calibre13">Course</kbd> class to fix this failure:</p>
<pre class="calibre25">public boolean isValidCourse() { 
  return name != null &amp;&amp; credits != 0 &amp;&amp; name.trim().length() &gt; 0; 
} </pre>
<p class="calibre3">We have added the condition to check the length of the <kbd class="calibre13">name</kbd> field. This should fix the test case failure. You can run the test case again to verify.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running unit test cases using Maven</h1>
                
            
            <article>
                
<p class="calibre3">You can run unit test cases using Maven, too. In fact, the install target of Maven <span class="calibre12">also</span><span class="calibre12"> runs unit tests. However, it is possible to run only unit tests. To do this, right-click on the project in</span> <span class="calibre12">Package Explorer</span> <span class="calibre12">and select</span> <span class="calibre12">Run As</span> <span class="calibre12">|</span> <span class="calibre12">Maven test</span><span class="calibre12">.</span></p>
<p class="calibre3">You might see the following error in the console:</p>
<pre class="calibre25">java.lang.NoClassDefFoundError: org/junit/Assert 
  at packt.book.jee.eclipse.ch5.bean.CourseTest.testIsValidCourse 
(CourseTest.java:10) 
Caused by: java.lang.ClassNotFoundException: org.junit.Assert 
  at java.net.URLClassLoader$1.run(URLClassLoader.java:366) 
  at java.net.URLClassLoader$1.run(URLClassLoader.java:355) 
  at java.security.AccessController.doPrivileged(Native Method) </pre>
<p class="calibre3">The reason for this error is that we haven't added a dependency on JUnit for our Maven project. Add the following dependency in <kbd class="calibre13">pom.xml</kbd>:</p>
<pre class="calibre25">    &lt;dependency&gt; 
      &lt;groupId&gt;junit&lt;/groupId&gt; 
      &lt;artifactId&gt;junit&lt;/artifactId&gt; 
      &lt;version&gt;4.12&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="calibre3">Refer to the <em class="calibre21">Using Maven for project management</em> section in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>, to learn how to add dependencies to a Maven project.</p>
<p class="calibre3">Run the Maven test again; this time, the test should pass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocking external dependencies for unit tests</h1>
                
            
            <article>
                
<p class="calibre3">Unit tests are meant to execute without any external dependencies. We can certainly write methods at a granular level, such that the core business logic methods are totally separate from methods that have external dependencies. However, sometimes this is not practical, and we may have to write unit tests for code that are closely dependent on methods that access external systems.</p>
<p class="calibre3">For example, let's assume that we have to add a method in our <kbd class="calibre13">Course</kbd> bean to add students to the course. We will also mandate that the course has an upper limit on the number of students that it can enroll, and once this limit is reached, no more students can be enrolled. Let's add the following method to our <kbd class="calibre13">Course</kbd> bean:</p>
<pre class="calibre25">public void addStudent (Student student) 
    throws EnrolmentFullException, SQLException { 
  //get current enrolement first 
  int currentEnrolment = courseDAO.getNumStudentsInCourse(id); 
  if (currentEnrolment &gt;= getMaxStudents()) 
    throw new EnrolmentFullException("Course if full. Enrolment closed"); 
  courseDAO.enrolStudentInCourse(id, student.getId()); 
} </pre>
<p class="calibre3">The <kbd class="calibre13">addStudent</kbd> method first finds the current enrollment in the course. For this, it queries the database using the <kbd class="calibre13">CourseDAO</kbd> class. It then checks whether the current enrollment is less than the maximum enrollment. Then, it calls the <kbd class="calibre13">enrollStudentInCourse</kbd> method of <kbd class="calibre13">CourseDAO</kbd>.</p>
<p class="calibre3">The <kbd class="calibre13">addStudent</kbd> method has an external dependency. It depends on successful access to an external database. We can write a unit test for this function as follows:</p>
<pre class="calibre25">@Test 
public void testAddStudent() { 
  //create course 
  Course course = new Course(); 
  course.setId(1); 
  course.setName("course1"); 
  course.setMaxStudents(2); 
  //create student 
  Student student = new Student(); 
  student.setFirstName("Student1"); 
  student.setId(1); 
  //now add student 
  try { 
    course.addStudent(student); 
  } catch (Exception e) { 
    Assert.fail(e.getMessage()); 
  } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">testAddStudent</kbd> method is meant to check whether  <kbd class="calibre13">addStudent</kbd> method works fine when all external dependencies are satisfied; in this case, it means that a database connection is established, the database server is up and running, and the tables are configured properly. If we want to verify that the functionality to enroll a student on a course works by taking into account all dependencies, then we should write a functional test. Unit tests only need to check whether code that does not depend on external dependencies works fine; in this case, it is a trivial check to verify that the total enrollment is less than the maximum allowed enrollment. This is a simple example, but in real applications you might have a lot more complex code to test.</p>
<p class="calibre3">The problem with the previous unit test is that we may have false failures, from the perspective of unit testing, because the database could be down or might not be configured correctly. One solution is to mock external dependencies; we can mock calls to the database (in this case, calls to <kbd class="calibre13">CourseDAO</kbd>). Instead of making real calls to the database, we can create stubs that will return some mock data or perform a mock operation. For example, we can write a mock function that returns some hardcoded value for the <kbd class="calibre13">getNumStudentsInCourse</kbd> method of <kbd class="calibre13">CourseDAO</kbd>. However, we don't want to modify the application source code to add mock methods. Fortunately, there are open source frameworks that let us mock dependencies in unit tests. Next, we will see how to mock dependencies using a popular framework called Mockito (<a href="http://mockito.org/" class="calibre9"><span>http://mockito.org/</span></a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Mockito</h1>
                
            
            <article>
                
<p class="calibre3">At a very high level, we can use Mockito to do two things:</p>
<ul class="calibre10">
<li class="calibre11">Provide wrapper implementations over dependent methods in the application class</li>
<li class="calibre11">Verify that these wrapper implementations are called</li>
</ul>
<p class="calibre3">We specify the wrapper implementation using a static method of Mockito:</p>
<pre class="calibre25">Mockito.when(object_name.method_name(params)).thenReturn(return_value); </pre>
<p class="calibre3">Further, we verify whether the wrapper method was called by calling another static method of Mockito:</p>
<pre class="calibre25">Mockito.verify(object_name, Mockito.atLeastOnce()).method_name(params);</pre>
<p class="calibre3">To use Mockito in our project, we need to add a dependency on it in our <kbd class="calibre13">pom.xml</kbd>:</p>
<pre class="calibre25">    &lt;dependency&gt; 
      &lt;groupId&gt;org.mockito&lt;/groupId&gt; 
      &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; 
      &lt;version&gt;2.17.0&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="calibre3">Before we start writing a unit test case using Mockito, we will make a small change in the <kbd class="calibre13">Course</kbd> class. Currently, <kbd class="calibre13">CourseDAO</kbd> in the <kbd class="calibre13">Course</kbd> class is private and there are no setters for it. Add the setter method (<kbd class="calibre13">setCourseDAO</kbd>) in the <kbd class="calibre13">Course</kbd> class:</p>
<pre class="calibre25">public void setCourseDAO(CourseDAO courseDAO) { 
  this.courseDAO = courseDAO; 
} </pre>
<p class="calibre3">Now, let's rewrite our test case using Mockito.</p>
<p class="calibre3">First, we need to tell Mockito which method calls we want to mock and what action should be taken in the mocked function (for example, return a specific value). In our example, we would like to mock the methods in <kbd class="calibre13">CourseDAO</kbd> that are called from the <kbd class="calibre13">Course.addStudent</kbd> method, because methods in <kbd class="calibre13">CourseDAO</kbd> access the database, and we want our unit tests to be independent of the data access code. Therefore, we create a mocked (wrapper) instance of <kbd class="calibre13">CourseDAO</kbd> using Mockito:</p>
<pre class="calibre25">CourseDAO courseDAO = Mockito.mock(CourseDAO.class); </pre>
<p class="calibre3">Then, we tell Mockito which specific methods in this object to mock. We want to mock <kbd class="calibre13">getNumStudentsInCourse</kbd> and <kbd class="calibre13">getNumStudentsInCourse</kbd>as follows:</p>
<pre class="calibre25">try { 
Mockito.when(courseDAO.getNumStudentsInCourse(1)).thenReturn(60); 
Mockito.doNothing().when(courseDAO).enrollStudentInCourse(1, 1); 
} catch (SQLException e) { 
  Assert.fail(e.getMessage()); 
} </pre>
<p class="calibre3">The code is in a <kbd class="calibre13">try...catch</kbd> block because the <kbd class="calibre13">getNumStudentsInCourse</kbd> and <kbd class="calibre13">getNumStudentsInCourse</kbd> methods throw <kbd class="calibre13">SQLException</kbd>. This will not happen when we mock the method because the mocked method will not call any SQL code. However, since the signature of these methods indicates that <kbd class="calibre13">SQLException</kbd> can be thrown from these methods, we have to call them in <kbd class="calibre13">try...catch</kbd> to avoid compiler errors.</p>
<p class="calibre3">The first statement in the <kbd class="calibre13">try</kbd> block tells Mockito that when the <kbd class="calibre13">getNumStudentsInCourse</kbd> method is called on the <kbd class="calibre13">courseDAO</kbd> object with the parameter <kbd class="calibre13">1</kbd> (course ID), it should return <kbd class="calibre13">60</kbd> from the mocked method.</p>
<p class="calibre3">The second statement tells Mockito that when <kbd class="calibre13">enrollStudentInCourse</kbd> is called on the <kbd class="calibre13">courseDAO</kbd> object with the arguments <kbd class="calibre13">1</kbd> (course ID) and <kbd class="calibre13">1</kbd> (student ID), it should do nothing. We don't really want to insert any record into the database from the unit test code.</p>
<p class="calibre3">We will now create the <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Student</kbd> objects and call the <kbd class="calibre13">addStudent</kbd> method of <kbd class="calibre13">Course</kbd>. This code is similar to the one we wrote in the preceding test case:</p>
<pre class="calibre25">Course course = new Course(); 
course.setCourseDAO(courseDAO); 
 
course.setId(1); 
course.setName("course1"); 
course.setMaxStudents(60); 
//create student 
Student student = new Student(); 
student.setFirstName("Student1"); 
student.setId(1); 
//now add student 
course.addStudent(student); </pre>
<p class="calibre3">Note that the course ID and student ID that we used when creating the <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Student</kbd> objects, respectively, should match the arguments we passed to <kbd class="calibre13">getNumStudentsInCourse</kbd> and <kbd class="calibre13">enrollStudentInCourse</kbd> when mocking the methods.</p>
<p class="calibre3">We have set that the maximum number of students to be allowed in this course to <kbd class="calibre13">60</kbd>. When mocking <kbd class="calibre13">getNumStudentsInCourse</kbd>, we asked Mockito to also return <kbd class="calibre13">60</kbd>. Therefore, the <kbd class="calibre13">addStudent</kbd> method should throw an exception because the course is full. We will verify this by adding the <kbd class="calibre13">@Test</kbd> annotation later.</p>
<p class="calibre3">At the end of the test, we want to verify that the mocked method was actually called:</p>
<pre class="calibre25">try { 
  Mockito.verify(courseDAO, Mockito.atLeastOnce()).getNumStudentsInCourse(1); 
} catch (SQLException e) { 
  Assert.fail(e.getMessage()); 
} </pre>
<p class="calibre3">The preceding code verifies that <kbd class="calibre13">getNumStudentsInCourse</kbd> of <kbd class="calibre13">courseDAO</kbd> was called at least once by Mockito, when running this test.</p>
<p class="calibre3">Here is the complete test case, including the <kbd class="calibre13">@Test</kbd> annotation attribute, to make sure that the function throws an exception:</p>
<pre class="calibre25">  @Test (expected = EnrollmentFullException.class) 
  public void testAddStudentWithEnrollmentFull() throws Exception <br class="title-page-name"/>   { 
    CourseDAO courseDAO = Mockito.mock(CourseDAO.class); 
    try { 
Mockito.when(courseDAO.getNumStudentsInCourse(1)).thenReturn(60); 
Mockito.doNothing().when(courseDAO).enrollStudentInCourse(1, 1); 
    } catch (SQLException e) { 
      Assert.fail(e.getMessage()); 
    } 
    Course course = new Course(); 
    course.setCourseDAO(courseDAO); 
 
    course.setId(1); 
    course.setName("course1"); 
    course.setMaxStudents(60); 
    //create student 
    Student student = new Student(); 
    student.setFirstName("Student1"); 
    student.setId(1); 
    //now add student 
    course.addStudent(student); 
 
    try { 
      Mockito.verify(courseDAO, <br class="title-page-name"/>       Mockito.atLeastOnce()).getNumStudentsInCourse(1); 
    } catch (SQLException e) { 
      Assert.fail(e.getMessage()); 
    } 
 
    //If no exception was thrown then the test case was successful 
    //No need of Assert here 
  } </pre>
<p class="calibre3">Now, run the unit tests. All tests should pass.</p>
<p class="calibre3">Here is a similar test case that makes Mockito return the current enrollment number of <kbd class="calibre13">59</kbd>, and makes sure that the student is enrolled successfully:</p>
<pre class="calibre25">  @Test 
  public void testAddStudentWithEnrollmentOpen() throws Exception <br class="title-page-name"/>   { 
    CourseDAO courseDAO = Mockito.mock(CourseDAO.class); 
    try { 
Mockito.when(courseDAO.getNumStudentsInCourse(1)).thenReturn(59); 
Mockito.doNothing().when(courseDAO).enrollStudentInCourse(1, 1); 
    } catch (SQLException e) { 
      Assert.fail(e.getMessage()); 
    } 
    Course course = new Course(); 
    course.setCourseDAO(courseDAO); 
 
    course.setId(1); 
    course.setName("course1"); 
    course.setMaxStudents(60); 
    //create student 
    Student student = new Student(); 
    student.setFirstName("Student1"); 
    student.setId(1); 
    //now add student 
    course.addStudent(student); 
 
    try { 
      Mockito.verify(courseDAO, <br class="title-page-name"/>       Mockito.atLeastOnce()).getNumStudentsInCourse(1);      Mockito.verify(courseDAO, <br class="title-page-name"/>       Mockito.atLeastOnce()).enrollStudentInCourse(1,1); 
    } catch (SQLException e) { 
      Assert.fail(e.getMessage()); 
    } 
 
    //If no exception was thrown then the test case was successful 
    //No need of Assert here 
  } </pre>
<p class="calibre3">Note that this test case does not expect any exceptions to be thrown (if an exception is thrown, then the test case fails). We can also verify that the mocked <kbd class="calibre13">enrollStudentInCourse</kbd> <span class="calibre12">method </span><span class="calibre12">is called. We did not verify this in the previous test case because an exception was thrown before calling this method in the </span><kbd class="calibre13">Course.addStudent</kbd> <span class="calibre12">method.</span></p>
<p class="calibre3">There are many topics of JUnit that we have not covered in this section. You are encouraged to read the JUnit documentation at <a href="https://github.com/junit-team/junit4/wiki" class="calibre9">https://github.com/junit-team/junit4/wiki</a>. In particular, the following topics might be of interest to you:</p>
<ul class="calibre10">
<li class="calibre11">JUnit test suites. You can aggregate test cases from different test classes in a suite. Find more information about test suites at <a href="https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites" class="calibre9">https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites</a>.</li>
<li class="calibre11">Parameterized test cases; find information at <a href="https://github.com/junit-team/junit4/wiki/Parameterized-tests" class="calibre9">https://github.com/junit-team/junit4/wiki/Parameterized-tests</a>.</li>
<li class="calibre11">If you are using Apache Ant for building your project, then take a look at the JUnit Ant task at <a href="https://ant.apache.org/manual/Tasks/junit.html" class="calibre9"><span>https://ant.apache.org/manual/Tasks/junit.html</span></a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Calculating unit test coverage</h1>
                
            
            <article>
                
<p class="calibre3">Unit tests tell you whether your application code behaves as expected. Unit tests are important to maintain code quality and catch errors early in the development cycle. However, this goal is at risk if you do not write enough unit tests to test your application code, or if you have not tested all possible input conditions in the test cases and the exception paths. To measure the quality and adequacy of your test cases, you need to calculate the coverage of your test cases. In simple terms, coverage tells you what percentage of your application code was touched by running your unit tests. There are different measures to calculate coverage:</p>
<ul class="calibre10">
<li class="calibre11">Number of lines covered</li>
<li class="calibre11">Number of branches covered (created using the <kbd class="calibre13">if</kbd>, <kbd class="calibre13">else</kbd>, <kbd class="calibre13">elseif</kbd>, <kbd class="calibre13">switch</kbd>, and <kbd class="calibre13">try</kbd>/<kbd class="calibre13">catch</kbd> statements)</li>
<li class="calibre11">Number of functions covered</li>
</ul>
<p class="calibre3">Together, these three measures give a fair measurement of the quality of your unit tests. There are many code coverage tools for Java. In this chapter, we will take a look at an open source code coverage tool called JaCoCo (<a href="http://www.eclemma.org/jacoco/" class="calibre9"><span>http://www.eclemma.o</span>rg/jacoco/</a>). JaCoCo also has an Eclipse plugin (<a href="http://www.eclemma.org/" class="calibre9"><span>http://www.eclemma.org/</span></a>), and we can measure code coverage from right within Eclipse.</p>
<p class="calibre3">You can install the JaCoCo plugin using the update URL (<a href="http://update.eclemma.org/" class="calibre9"><span>http://update.ec</span>lemma.org/</a>) or from <span class="calibre12">Eclipse Marketplace</span>. To install it using the update site, select the <span class="calibre12">Help</span> | <span class="calibre12">Install New Software...</span> menu. Click on the <span class="calibre12">Add</span> button and enter the name of the update site (you can give any name) and the update URL:</p>
<div class="mce-root1"><img src="../images/00132.jpeg" class="calibre146"/></div>
<div class="packt_figure1">Figure 5.6: Add an update site for JaCoCo</div>
<p class="calibre3">Then, follow the instructions to install the plugin.</p>
<p class="calibre3">Alternatively, you can install it from the marketplace. Select the <span class="calibre12">Help</span> | <span class="calibre12">Eclipse Marketplace...</span> menu. Type <kbd class="calibre13">EclEmma</kbd> into the <span class="calibre12">Find</span> textbox, and click the <span class="calibre12">Go</span> button:</p>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00133.jpeg" class="calibre147"/></div>
<div class="packt_figure1">Figure 5.7: Install EclEmma code coverage plugin from Eclipse Marketplace</div>
<p class="calibre3">Click the <span class="calibre12">Install</span> button and follow the instructions.</p>
<p class="calibre3">To verify that the plugin is installed properly, open <span class="calibre12">Window</span> | <span class="calibre12">Show View</span> | <span class="calibre12">Other</span>. Type <kbd class="calibre13">coverage</kbd> into the <span class="calibre12">Filter</span> textbox and make sure that the <span class="calibre12">Coverage</span> (under the <span class="calibre12">Java</span> category) view is available. Open the view.</p>
<p class="calibre3">To run a unit test with coverage, right-click on the project in <span class="calibre12">Package Explorer</span> and select <span class="calibre12">Coverage As</span> | <span class="calibre12">JUnit Test</span>. After the tests have run, the coverage information is displayed in the <span class="calibre12">Coverage</span> view:</p>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00134.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 5.8: Coverage results</div>
<p class="calibre3">How can you interpret these results? Overall, at the project level the coverage is <span class="calibre12">24.2%</span>. This means that out of all the code that we have written in this application, our unit test case has touched only <span class="calibre12">24.2%</span>. Then, there is the coverage percentage at the package level and at the class level.</p>
<p class="calibre3">Double-click on <kbd class="calibre13">Course.java</kbd> in the <span class="calibre12">Coverage</span> view to see which lines are covered in this file. The following screenshot shows a part of the file where the red lines indicate the code that is not covered, and the green lines indicate the code that is covered:</p>
<div class="mce-root1"><img src="../images/00135.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 5.9: Line coverage details</div>
<p class="calibre3">We have written unit tests for <kbd class="calibre13">addStudent</kbd>, and the coverage of this class is <span class="calibre12">100%</span>, which is good. We haven't used all <span class="calibre12">getters</span><span class="calibre12"> </span><span class="calibre12">and</span><span class="calibre12"> </span><span class="calibre12">setters in our unit tests, so some of them are not covered.</span></p>
<p class="calibre3">As you can see, the coverage results help you understand places in your code for which unit tests are not written, or which are partially covered by the unit tests. Based on this data, you can add unit tests for the code that is not covered. Of course, you may not want all lines to be covered if the code is very simple, such as the getters and setters in the preceding class, if the code is very simple.</p>
<p class="calibre3">In <em class="calibre21">Figure 5.8</em>, observe that the coverage tool has analyzed the test classes too. Typically, we don't want to measure coverage on test classes; we want to measure the coverage of the application code by running the test classes. To exclude the test classes from this analysis, right-click on the project and select <span class="calibre12">Coverage As</span> | <span class="calibre12">Coverage Configurations...</span>. Click on the <span class="calibre12">Coverage</span> tab and select only <span class="calibre12">CourseManagementJDBC - src/main/java</span>:</p>
<div class="mce-root1"><img src="../images/00136.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 5.10: Coverage configurations</div>
<p class="calibre3">Click <span class="calibre12">Coverage</span> to run coverage with the new settings. You will see in the <span class="calibre12">Coverage</span> view that the test classes do not appear in the report, and that the overall test coverage on the project has also dropped.</p>
<p class="calibre3">If you want to run coverage using Maven, then refer to <a href="http://www.eclemma.org/jacoco/trunk/doc/maven.html" class="calibre9"><span>http://www.eclemma.org/jacoco/trun</span>k/doc/maven.html</a>. Specifically, take a look at <kbd class="calibre13">pom.xml</kbd> (<a href="http://jacoco.org/jacoco/trunk/doc/examples/build/pom-it.xml" class="calibre9"><span>http://jacoco.org/jacoco/trunk/doc/examples/build/pom-it.xml</span></a>), which creates reports for JUnit and JaCoCo coverage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">Writing unit tests is an important part of the application development process. Unit tests help you catch bugs in your application at very early stages; they also help you catch any regression because of subsequent code changes. JUnit and Eclipse provide an easy way to integrate unit tests into your development workflow. Eclipse also creates a nice report in the JUnit view, which makes it easy to identify the failed tests and jump to the line in the code where the test failed.</p>
<p class="calibre3">Unit tests are meant to be executed without any external dependencies. Libraries such as Mockito help you to mock any external dependencies.</p>
<p class="calibre3">Use coverage tools such as JaCoCo to find out the quality of the unit tests that you have written. Coverage tools tell you the percentage of the application code that is covered by your unit tests. You can also see in each class which lines are covered by your unit tests and which are not. Such a report can help you to decide whether you need to write more unit test cases or modify the existing unit test cases to cover important code that your unit tests have not tested.</p>
<p class="calibre3">In the next chapter, we will see how to debug Java applications from Eclipse. The chapter will also explain how to connect to a remote JEE server for debugging.</p>


            </article>

            
        </section>
    </body></html>