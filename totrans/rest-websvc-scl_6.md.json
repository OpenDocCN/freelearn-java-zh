["```java\naddSbtPlugin(\"com.typesafe.play\" % \"sbt-plugin\" % \"2.4.0\")\n```", "```java\nlazy val playVersion = \"2.4.0\"\n\nval backendDeps = Seq (\n  \"com.typesafe.play\" %% \"play\" % playVersion,\n  \"com.typesafe.play\" %% \"play-docs\" % playVersion\n)\n```", "```java\naddCommandAlias(\"runCH06-HelloPlay\", \"; chapter06/run -Dhttp.port=8080  -Dplay.http.router=hello.Routes\")\n\naddCommandAlias(\"runCH06-runCH06Step1\", \"; chapter06/run -Dhttp.port=8080  -Dplay.http.router=step01.Routes\")\n\naddCommandAlias(\"runCH06-runCH06Step2\", \"; chapter06/run -Dhttp.port=8080  -Dplay.http.router=step02.Routes\")\n\naddCommandAlias(\"runCH06-runCH06Step3\", \"; chapter06/run -Dhttp.port=8080  -Dplay.http.router=step03.Routes\")\n\nimport PlayKeys._\nlazy val chapter06 = (project in file (\"chapter-06\"))\n  .enablePlugins(PlayScala)\n  .dependsOn(common)\n  .settings(commonSettings: _*)\n  .settings(\n    name := \"chapter-06\",\n    libraryDependencies := DependenciesChapter6.backendDeps\n  )\n```", "```java\nGET     /hello                       controllers.Hello.helloWorld\n```", "```java\npackage controllers\n\nimport play.api.mvc._\n\nobject Hello extends Controller {\n\n  def helloWorld = Action {\n\n    Ok(\"Hello Play\")\n  }\n\n}\n```", "```java\nJoss-MacBook-Pro:rest-with-scala jos$ sbt runCH06-HelloPlay\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n\n--- (Running the application, auto-reloading is enabled) ---\n\n[info] p.a.l.c.ActorSystemProvider - Starting application default Akka system: application\n[info] p.c.s.NettyServer$ - Listening for HTTP on /0:0:0:0:0:0:0:0:8080\n\n(Server started, use Ctrl+D to stop and go back to the console...)\n\n```", "```java\ndef helloWorld = Action {\n\n  Ok(\"Hello Play, now with reload!\")\n}\n```", "```java\nPOST     /tasks       controllers.Step1.createTask\nGET      /tasks       controllers.Step1.getTasks\nGET      /tasks/:id   controllers.Step1.getTask(id: Long)\nDELETE   /tasks/:id   controllers.Step1.deleteTask(id: Long)\nPUT      /tasks/:id   controllers.Step1.updateTask(id: Long)\n\nGET         /*path    controllers.Step1.notImplemented(path: String)\nPOST        /*path    controllers.Step1.notImplemented(path: String)\nPUT         /*path    controllers.Step1.notImplemented(path: String)\nDELETE      /*path    controllers.Step1.notImplemented(path: String)\n```", "```java\npackage controllers\n\nimport play.api.mvc._\n\nobject Step1 extends Controller {\n\n  def createTask = Action { request =>\n    val body: Option[String] = request.body.asText\n    Ok(s\"Create a task with body: \n         ${body.getOrElse(\"No body provided\")}\")\n  }\n\n  def getTasks = Action {\n    Ok(\"Getting all tasks\")\n  }\n\n  def getTask(id: Long) = Action {\n    Ok(s\"Getting task with id: $id\")\n  }\n\n  def deleteTask(id: Long) = Action {\n    Ok(s\"Delete task with id: $id\")\n  }\n\n  def updateTask(id: Long) = Action { request =>\n    val body: Option[String] = request.body.asText\n    Ok(s\"Update a task with body: \n         ${body.getOrElse(\"No body provided\")}\")\n  }\n\n  def notImplemented(path: String) = Action {\n    NotFound(s\"Specified route not found: $path\")\n  }\n}\n```", "```java\n$ sbt runCH06-runCH06Step1\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n\n--- (Running the application, auto-reloading is enabled) ---\n\n[info] p.a.l.c.ActorSystemProvider - Starting application default Akka system: application\n[info] p.c.s.NettyServer$ - Listening for HTTP on /0:0:0:0:0:0:0:0:8080\n\n(Server started, use Ctrl+D to stop and go back to the console...)\n\n```", "```java\nPOST   /tasks            controllers.Step2.createTask(\n                              title: String, person: Option[String],\n                              status: String ?=\"New\")\nGET    /tasks            controllers.Step2.getTasks\nGET    /tasks/:id        controllers.Step2.getTask(id: Long)\nDELETE /tasks/:id        controllers.Step2.deleteTask(id: Long)\nPUT    /tasks/:id        controllers.Step2.updateTask(\n                              id: Long, title: String, \n                              person: Option[String],\n                              status: String ?=\"New\")\n```", "```java\nobject Step2 extends Controller {\n\n  // simple implicit to convert our tasks to a simple string for now\n  implicit def wTask: Writeable[Task] = \n       Writeable(_.toString.getBytes, Some(\"application/text\"))\n  implicit def wListTask: Writeable[List[Task]] =\n       Writeable(_.mkString(\"\\n\").getBytes, Some(\"application/text\"))\n```", "```java\n  def createTask(title: String, person: Option[String], \n                 status: String) = Action.async { request =>\n\n    val body: Option[String] = request.body.asText\n\n    val createdTask = TaskService.insert(Task(\n      -1,\n      title,\n      body.getOrElse(\"No body provided\"),\n      person.map(Person(_)),\n      List[Note](),\n      MStatus(status)))\n\n    createdTask.map(Ok(_))\n  }\n```", "```java\nMap(ROUTE_COMMENTS -> this is a comment,\n    ROUTE_PATTERN -> /tasks,\n    ROUTE_CONTROLLER -> controllers.Step2,\n    ROUTE_ACTION_METHOD -> createTask,\n    ROUTE_VERB -> POST)\n```", "```java\n  def getTasks = Action.async {\n    TaskService.all.map(\n      Ok(_)\n        .as(\"application/text\")\n        .withCookies(new Cookie(\"play\",\"cookie\"))\n        .withHeaders((\"header1\" -> \"header1value\")))\n  }\n```", "```java\n  def getTask(id: Long) = Action.async {\n    val task = TaskService.select(id);\n    task.map({\n      case Some(task) => Ok(task)\n      case None => NotFound(\"\")\n    })\n  }\n\n  def updateTask(id: Long, title: String, \n                 person: Option[String], \n                 status: String) = Action.async { request =>\n    val body: Option[String] = request.body.asText\n\n    val updatedTask = TaskService.update(id, Task(\n      id,\n      title,\n      body.getOrElse(\"No body provided\"),\n      person.map(Person(_)),\n      List[Note](),\n      MStatus(status)))\n\n    updatedTask.map({\n      case Some(task) => Ok(task)\n      case None => NotFound(\"\")\n    })\n  }\n```", "```java\n$ sbt runCH06-runCH06Step2\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n\n--- (Running the application, auto-reloading is enabled) ---\n\n[info] p.a.l.c.ActorSystemProvider - Starting application default Akka system: application\n[info] p.c.s.NettyServer$ - Listening for HTTP on /0:0:0:0:0:0:0:0:8080\n\n(Server started, use Ctrl+D to stop and go back to the console...)\n\n```", "```java\nimplicit val fmtNote = Json.format[Note]\nimplicit val fmtPerson = Json.format[Person]\nimplicit val fmtMStatus = Json.format[MStatus]\nimplicit val fmtTask = Json.format[Task]\n```", "```java\nimplicit def notesFormat: Format[Note] = (\n   (JsPath \\ \"id\").format[Long] and\n   (JsPath \\ \"content\").format[String])\n     (Note.apply, unlift(Note.unapply))\n```", "```java\nimplicit def statusReads: Reads[MStatus] =\n   ((JsPath \\ \"status\").read(\n     minLength[String](3) andKeep\n       filter(ValidationError(\"Status must be either New,\n                               In Progress or Closed\"))\n         ((b: String) => List(\"New\", \"In Progress\",\n                              \"Closed\").contains(b))\n   ))\n   .map(MStatus(_))\n\n implicit def statusWrites: Writes[MStatus] = ((JsPath \\ \n           \"status\").write[String])\n           .contramap((_.status))\n```", "```java\nimplicit def taskReads: Reads[Task] = (\n     (JsPath \\ \"id\").read[Long] and\n       (JsPath \\ \"title\").read(minLength[String](3)\n                          andKeep maxLength[String](10)) and\n       (JsPath \\ \"content\").read[String] and(JsPath \\ \"assignedTo\").readNullable[Person] and\n       (JsPath \\ \"notes\").read[List[Note]] and\n       (JsPath \\ \"status\").read[MStatus])(Task.apply _)\n```", "```java\n  def createTask = Action.async { request =>\n\n    val body: Option[JsResult[Task]] = \n             request.body.asJson.map(_.validate[Task])\n\n    // option defines whether we have a Json body or not.\n    body match {\n      case Some(task) =>\n        // jsResult defines whether we have failures.\n        task match {\n          case JsSuccess(task, _) => TaskService.insert(task).\n                          map(b => Ok(Json.toJson(b)))\n          case JsError(errors) =>\n                         Future{BadRequest(errors.mkString(\"\\n\"))}\n        }\n      case None => Future{BadRequest(\"Body can't be parsed to JSON\")}\n    }\n  }\n```", "```java\n  def deleteTask(id: Long) = Action.async {\n    val task = TaskService.delete(id);\n\n    // assume this task does something unexpected and throws \n    // an exception.\n    throw new IllegalArgumentException(\"Unexpected argument\");\n\n    task.map({\n      case Some(task) => Ok(task)\n      case None => NotFound(\"\")\n    })\n  }\n```", "```java\nclass ErrorHandler @Inject() (env: Environment,\n                              config: Configuration,\n                              sourceMapper: OptionalSourceMapper,\n                              router: Provider[Router]\n                              ) extends DefaultHttpErrorHandler(env, config, sourceMapper, router) {\n\n  override def onDevServerError(request: RequestHeader, \n                             exception: UsefulException) = {\n    Future.successful(\n      InternalServerError(\"A server error occurred: \" + \n                           exception.getMessage)\n    )\n  }\n\n  override def onProdServerError(request: RequestHeader, \n                               exception: UsefulException) = {\n    Future.successful(\n      InternalServerError(\"A server error occurred: \" + \n                           exception.getMessage)\n    )\n  }\n}\n```"]