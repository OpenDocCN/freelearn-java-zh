<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Algorithm Design Paradigms</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous chapter, we learned about hash tables and binary search trees. In this chapter, we will explore algorithm design paradigms. These design patterns can be seen as the generic methods or approaches that motivate the design of a class of algorithms.</p>
<p class="mce-root">Just as an algorithm is a higher abstraction than a computer program, an algorithm design paradigm is an abstraction higher than an algorithm. The choice of an algorithm paradigm is an important one when designing an algorithm. </p>
<p class="mce-root">This chapter will focus on the following three algorithm paradigms:</p>
<ul class="calibre12">
<li class="calibre13">Greedy</li>
<li class="calibre13">Divide and conquer</li>
<li class="calibre13">Dynamic programming</li>
</ul>
<p class="mce-root">By becoming familiar with these higher abstractions, you can make more informed decisions when designing algorithms.</p>
<div class="packt_infobox">In a previous chapter, we have come across the merge sort and quick sort algorithms, which are examples of the divide and conquer paradigm. As the name suggests, both of these algorithms <em class="calibre21">divide</em> the input into smaller parts, which are then solved recursively (<em class="calibre21">conquer</em>).<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root">There are obviously more algorithm design paradigms, but these three already cover a broad range of problems. Some other paradigms we're not talking about in this book are backtracking and prune and search. There are even paradigms focused on specific branches of computer science. The sweep line algorithms, in computational geometry, is an example of this.</p>
<p class="mce-root">By the end of this chapter, you will be able to:</p>
<ul class="calibre12">
<li class="calibre13">Describe greedy, divide and conquer, and dynamic programming algorithm paradigms</li>
<li class="calibre13">Analyze common problems solved by using the described paradigms</li>
</ul>
<ul class="calibre12">
<li class="calibre13">List the properties of a problem to be solved by each paradigm</li>
<li class="calibre13">Solve some well-known problems that explain the applicability of each paradigm</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introducing Greedy Algorithms</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Algorithms typically go through a sequence of steps, wherein each step you have a set of choices. Greedy algorithms, as the name suggests, follow the heuristic of making the locally choice at each step, with the hope of arriving at a global optimum. To better understand what we mean by this, let's introduce a problem.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Activity Selection Problem</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Peter is an energetic guy, and usually has many things to do in a given day. However, with the amount of things he wants to do, he is usually unable to do them all in a single day. What he usually does after waking up is write up a list of activities that he has to do, along with their time span. Then, looking at that list, he devises a plan for the day, trying to accommodate as many activities as possible.</p>
<p class="mce-root">Being an energetic guy, he usually rushes through this process and finds himself doing fewer activities than possible throughout the day. Can you help him maximize the amount of activities he can do in a day, given his schedule? An example of a schedule for Peter is given in the following table:</p>
<div class="title-page-name">
<table border="1" class="calibre65">
<tbody class="calibre23">
<tr class="calibre66">
<td class="cdpalignleft1"><strong class="calibre3">ID</strong></td>
<td class="cdpalignleft2"><strong class="calibre3">Activity</strong></td>
<td class="cdpalignleft3"><strong class="calibre3">Time Span</strong></td>
</tr>
<tr class="calibre67">
<td class="cdpalignleft1">1</td>
<td class="cdpalignleft2">Tidy up his room</td>
<td class="cdpalignleft3">10:00 - 12:00</td>
</tr>
<tr class="calibre68">
<td class="cdpalignleft1">2</td>
<td class="cdpalignleft2">Going to the rock concert</td>
<td class="cdpalignleft3">20:00 - 23:00</td>
</tr>
<tr class="calibre69">
<td class="cdpalignleft1">3</td>
<td class="cdpalignleft2">Play chess at the local club</td>
<td class="cdpalignleft3">17:00 - 19:00</td>
</tr>
<tr class="calibre66">
<td class="cdpalignleft1">4</td>
<td class="cdpalignleft2">Take a shower</td>
<td class="cdpalignleft3">10:00 - 10:30</td>
</tr>
<tr class="calibre67">
<td class="cdpalignleft1">5</td>
<td class="cdpalignleft2">Dinner with friends</td>
<td class="cdpalignleft3">19:00 - 20:30</td>
</tr>
<tr class="calibre66">
<td class="cdpalignleft1">6</td>
<td class="cdpalignleft2">Play Civilization VI</td>
<td class="cdpalignleft3">21:30 - 23:00</td>
</tr>
<tr class="calibre69">
<td class="cdpalignleft1">7</td>
<td class="cdpalignleft2">Have lunch with friends</td>
<td class="cdpalignleft3">12:30 - 13:30</td>
</tr>
<tr class="calibre66">
<td class="cdpalignleft1">8</td>
<td class="cdpalignleft2">Go to the cinema</td>
<td class="cdpalignleft3">20:00 - 22:00</td>
</tr>
<tr class="calibre67">
<td class="cdpalignleft1">9</td>
<td class="cdpalignleft2">Go biking in the park</td>
<td class="cdpalignleft3">17:00 - 19:30</td>
</tr>
<tr class="calibre66">
<td class="cdpalignleft1">10</td>
<td class="cdpalignleft2">Go to the beach</td>
<td class="cdpalignleft3">16:00 - 19:00</td>
</tr>
<tr class="calibre70">
<td class="cdpalignleft1">11</td>
<td class="cdpalignleft2">Go to the library</td>
<td class="cdpalignleft3">15:00 - 17:00</td>
</tr>
</tbody>
</table>
</div>
<div class="packt_figref">Table 4.1: Peter's schedule</div>
<p class="mce-root">This is known as the <strong class="calibre6">activity selection problem</strong>. The problem is to schedule several competing activities that require exclusive use of a common resource (which is Peter, in this case), with the goal of selecting a maximum size set of activities that are mutually compatible.</p>
<p class="mce-root">In other words, we are trying to find the biggest set of activities that Peter can perform in a day. Each activity (<em class="calibre19">a<sub class="calibre40">i</sub></em>) has a start time (<em class="calibre19">s<sub class="calibre40">i</sub></em>) and a finish time (<em class="calibre19">f<sub class="calibre40">i</sub></em>). Two activities, <em class="calibre19">a<sub class="calibre40">i</sub></em> and <em class="calibre19">a<sub class="calibre40">j</sub></em>, are considered compatible if the intervals (<em class="calibre19">s<sub class="calibre40">i</sub></em>, <em class="calibre19">f<sub class="calibre40">i</sub></em>) and (<em class="calibre19">s<sub class="calibre40">j</sub></em>, <em class="calibre19">f<sub class="calibre40">j</sub></em>) do not overlap, for example, <em class="calibre19">s<sub class="calibre40">i</sub> ≥ f<sub class="calibre40">j</sub></em> or <em class="calibre19">s<sub class="calibre40">j</sub> ≥ f<sub class="calibre40">i</sub></em>.</p>
<p class="mce-root">Looking at Peter's schedule, and converting the start and finish times to minutes since the start of a day, we can arrive at the following table. To convert the times to minutes since the start of the day, we multiply the hours by 60 and add the minutes. For example, <kbd class="calibre15">activity 1</kbd> runs from 10:00 to 12:00. 10:00 is <em class="calibre19">600 (10*60 + 0)</em> minutes since the start of the day, and 12:00 is <em class="calibre19">720 (12*60 + 0)</em> minutes since the start of the day:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="cdpaligncenter2"><strong class="calibre3">ai</strong></td>
<td class="cdpaligncenter2">1</td>
<td class="cdpaligncenter2">2</td>
<td class="cdpaligncenter2">3</td>
<td class="cdpaligncenter2">4</td>
<td class="cdpaligncenter2">5</td>
<td class="cdpaligncenter2">6</td>
<td class="cdpaligncenter2">7</td>
<td class="cdpaligncenter2">8</td>
<td class="cdpaligncenter2">9</td>
<td class="cdpaligncenter2">10</td>
<td class="cdpaligncenter2">11</td>
</tr>
<tr class="calibre26">
<td class="cdpaligncenter2"><strong class="calibre3">si</strong></td>
<td class="cdpaligncenter2">600</td>
<td class="cdpaligncenter2">1200</td>
<td class="cdpaligncenter2">1020</td>
<td class="cdpaligncenter2">600</td>
<td class="cdpaligncenter2">1140</td>
<td class="cdpaligncenter2">1290</td>
<td class="cdpaligncenter2">750</td>
<td class="cdpaligncenter2">1200</td>
<td class="cdpaligncenter2">1020</td>
<td class="cdpaligncenter2">960</td>
<td class="cdpaligncenter2">900</td>
</tr>
<tr class="calibre27">
<td class="cdpaligncenter2"><strong class="calibre3">fi</strong></td>
<td class="cdpaligncenter2">720</td>
<td class="cdpaligncenter2">1380</td>
<td class="cdpaligncenter2">1140</td>
<td class="cdpaligncenter2">630</td>
<td class="cdpaligncenter2">1230</td>
<td class="cdpaligncenter2">1380</td>
<td class="cdpaligncenter2">810</td>
<td class="cdpaligncenter2">1320</td>
<td class="cdpaligncenter2">1170</td>
<td class="cdpaligncenter2">1140</td>
<td class="cdpaligncenter2">1020</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_figref">Table 4.2: Start and finish times of peter's activities</div>
<p class="mce-root">For this example, the subset <em class="calibre19">{a<sub class="calibre40">1</sub>, a<sub class="calibre40">3</sub>, a<sub class="calibre40">5</sub>, a<sub class="calibre40">6</sub>}</em> consists of mutually compatible activities, as their times don't overlap. It is not a maximum subset (that is, we can find a set with a larger number of activities), since the subset <em class="calibre19">{a<sub class="calibre40">3</sub>, a<sub class="calibre40">4</sub>, a<sub class="calibre40">5</sub>, a<sub class="calibre40">6</sub>, a<sub class="calibre40">7</sub>, a<sub class="calibre40">11</sub>}</em> is larger (note that the order of the activities is <em class="calibre19">a<sub class="calibre40">4</sub></em>, <em class="calibre19">a<sub class="calibre40">7</sub></em>, <em class="calibre19">a<sub class="calibre40">11</sub></em>, <em class="calibre19">a<sub class="calibre40">3</sub></em>, <em class="calibre19">a<sub class="calibre40">5</sub></em> and <em class="calibre19">a<sub class="calibre40">6</sub></em>). In fact, it is a larger subset of mutually compatible activities. It is not the only one: another possible larger subset is <em class="calibre19">{a<sub class="calibre40">1</sub>, a<sub class="calibre40">7</sub>, a<sub class="calibre40">11</sub>, a<sub class="calibre40">3</sub>, a<sub class="calibre40">5</sub>, a<sub class="calibre40">6</sub>}</em>.</p>
<p class="mce-root">How should we approach this problem to find the maximum size set of activities that are mutually compatible? It turns out we should do the greedy choice. What this means is that, at each step of the algorithm, from the set of activities that we can still perform, we should choose one greedily.</p>
<p class="mce-root">The greedy choice may not be immediate, but you can intuitively think that we should select activities that leave Peter available for as many other activities as possible.</p>
<p class="mce-root">We can have two approaches to resolve this problem, and they are as follows:</p>
<ul class="calibre12">
<li class="calibre13">Always choose the activity with the earliest starting time; however, we can have the activity with the earliest starting time finishing after all the other activities.</li>
<li class="calibre13">Choose the activity that consumes the least amount of time; however, we can have a small activity overlapping two or more non-overlapping activities (for example, activities <em class="calibre21">[1, 4)</em>, <em class="calibre21">[3, 5)</em> and <em class="calibre21">[4, 8)</em>).</li>
</ul>
<p class="mce-root">Hence, both of these approaches don't work.<span class="calibre14"><br class="calibre7"/></span></p>
<p class="mce-root">From the set of activities that we are able to choose, we must choose the first one to finish, as that is the activity that would leave Peter available for as many of the activities that follow it as possible. If we sort activities by finish time, we can then always select the first activity we find that is compatible with the last activity selected for Peter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Solving the Activity Selection Problem</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To implement the greedy algorithm in Java to solve the activity selection problem, as <strong class="calibre6">described previously</strong>.</p>
<p class="mce-root">A possible implementation of the algorithm described to solve the activity selection problem is as follows:</p>
<pre class="calibre20">Collections.sort(sortedActivities, (o1, o2) -&gt; Integer.signum(o1.finish - o2.finish));<br class="calibre2"/>if (sortedActivities.size() &gt; 0)<br class="calibre2"/>  selected.add(sortedActivities.get(0));<br class="calibre2"/>for (int i = 1; i &lt; sortedActivities.size(); i++)<br class="calibre2"/>  if (sortedActivities.get(i).start &gt;= selected.get(selected.size() - 1).finish)<br class="calibre2"/>    selected.add(sortedActivities.get(i));</pre>
<div class="packt_infobox"><br class="calibre2"/>
Navigate to <a href="https://goo.gl/xYT2Ho" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/xYT2Ho</a> to access complete code.</div>
<p class="mce-root">After having sorted the activities by finish time, the selection part of the algorithm runs in <em class="calibre19">O(n)</em> time. Since we can't sort in <em class="calibre19">O(n)</em>, the overall complexity of this algorithm is bounded by the complexity of the sorting algorithm. As seen in previous chapters, we can sort in <em class="calibre19">O(nlog(n))</em> so that's the runtime complexity of the algorithm we've devised for the activity selection problem. The algorithm looks good, but how can we be sure that it always arrives at the optimal solution?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Ingredients of a Greedy Algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are two basic ingredients every greedy algorithm has in common. They are as follows:</p>
<ul class="calibre12">
<li class="calibre13">Optimal substructure property</li>
<li class="calibre13">Greedy choice property</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Optimal Substructure Property</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The first step in solving an optimization problem by using a greedy approach is to characterize the structure of an optimal solution. A problem exhibits the optimal substructure property if an optimal solution to the problem within it contains optimal solutions to subproblems.</p>
<p class="mce-root">Intuitively, we can think that the activity selection problem exhibits the optimal substructure property in the sense that, if we suppose that a given activity belongs to a maximum size set of mutually compatible activities, then we are left to choose the maximum size set of mutually compatible activities from the ones that finish before this activity starts and that start after this activity finishes. Those two sets must also be maximum sets for the compatible activities, so that they can showcase the optimal substructure of this problem.</p>
<p class="mce-root">Formally, it is possible to prove that the activity selection problem exhibits optimal substructure. Let's assume we have the set of activities sorted in monotonically increasing order of finish time so that the following can be true for activities <em class="calibre19">i</em> and <em class="calibre19">j</em>:</p>
<div class="cdpaligncenter1"><em class="calibre21">f<sub class="calibre40">i</sub> ≤ f<sub class="calibre40">j</sub> if i ≤ j</em></div>
<p class="mce-root">Whereas <em class="calibre19">f<sub class="calibre40">i</sub></em> is denoting the finish time of activity <em class="calibre19">i</em>.</p>
<p class="mce-root">Suppose we denote by <em class="calibre19">S<sub class="calibre40">ij</sub></em>; the set of activities that start after activity <em class="calibre19">a<sub class="calibre40">i</sub></em> finish, and they finish before activity <em class="calibre19">a<sub class="calibre40">j</sub></em> starts. Thus, we wish to find a maximum set of mutually compatible activities in <em class="calibre19">S<sub class="calibre40">ij</sub></em>.</p>
<p class="mce-root">Let's say that the set is <em class="calibre19">A<sub class="calibre40">ij</sub></em>, and includes activity <em class="calibre19">a<sub class="calibre40">k</sub></em>. By including <em class="calibre19">a<sub class="calibre40">k</sub></em> in an optimal solution, we are left with two subproblems that are finding the maximum subset of mutually compatible activities in the set <em class="calibre19">S<sub class="calibre40">ik</sub></em> and set <em class="calibre19">S<sub class="calibre40">kj</sub></em>, which can be represented as follows:</p>
<div class="cdpaligncenter1"><em class="calibre21">A<sub class="calibre40">ij</sub> = A<sub class="calibre40">ik</sub> ∪ {a<sub class="calibre40">k</sub>} ∪ A<sub class="calibre40">kj</sub></em></div>
<p class="mce-root">Thus, the size of the maximum size set of mutually compatible activities in <em class="calibre19">S<sub class="calibre40">ij</sub></em> is given by the following:</p>
<div class="cdpaligncenter1"><em class="calibre21">|A<sub class="calibre40">ij</sub>| = |A<sub class="calibre40">ik</sub>| + |A<sub class="calibre40">kj</sub>| + 1</em></div>
<p class="mce-root">If we could find a set <em class="calibre19">A'<sub class="calibre40">kj</sub></em> of mutually compatible activities in <em class="calibre19">S<sub class="calibre40">kj</sub></em> where <em class="calibre19">|A'<sub class="calibre40">kj</sub>| &gt; |A<sub class="calibre40">kj</sub>|</em>, then we could use <em class="calibre19">A'<sub class="calibre40">kj</sub></em> instead of <em class="calibre19">A<sub class="calibre40">kj</sub></em> in the optimal solution to the subproblem for <em class="calibre19">S<sub class="calibre40">ij</sub></em>. But that way, we would have something that contradicts the assumption that <em class="calibre19">A<sub class="calibre40">ij</sub></em> is an optimal solution:</p>
<div class="cdpaligncenter1"><em class="calibre21">|A<sub class="calibre40">ik</sub>| + |A'<sub class="calibre40">kj</sub>| + 1 &gt; |A<sub class="calibre40">ik</sub>| + |A<sub class="calibre40">kj</sub>| + 1 = |A<sub class="calibre40">ij</sub>|</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Greedy Choice Property</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">When searching for a possible solution to a problem, we usually consider various solutions, which we call the solution space.</p>
<p class="mce-root">When trying to find the best solution to a problem, we're usually interested in a global optimum, that is, the optimal solution from the whole set of possible solutions.</p>
<p class="mce-root">However, the solution space can exhibit other optimums. Namely, we can have local optimums, which are optimal solutions in a small neighborhood of possible solutions.</p>
<p class="mce-root">The greedy choice property states that from a local optimum we can reach a global optimum, without having to reconsider decisions that have already been made.</p>
<p class="mce-root">In the activity selection problem for Peter, we applied the greedy choice by always choosing the activity with the earliest finish time from the set of available activities.</p>
<p class="mce-root">Intuitively, we can think that this problem exhibits the greedy choice property in the sense that if we have a maximum size subset and we replace the activity from that set with the earliest finish time with one that finishes even earlier, we are always left with a maximum size set, making it safe to always choose the one with the earliest finish time.</p>
<p class="mce-root">It is possible to prove that the greedy choice is always part of some optimal solution.</p>
<p class="mce-root">Let's try to prove that, for any nonempty subproblem <em class="calibre19">S<sub class="calibre40">k</sub></em>, if <em class="calibre19">a<sub class="calibre40">m</sub></em> is an activity in <em class="calibre19">S<sub class="calibre40">k</sub></em> with the earliest finish time, then <em class="calibre19">a<sub class="calibre40">m</sub></em> is included in some maximum size subset of mutually compatible activities of <em class="calibre19">S<sub class="calibre40">k</sub></em>.</p>
<p class="mce-root">To prove it, let's assume the following:</p>
<ul class="calibre12">
<li class="calibre13"><em class="calibre21">A<sub class="calibre40">k</sub></em> is a maximum size subset of mutually compatible activities in <em class="calibre21">S<sub class="calibre40">k</sub></em></li>
<li class="calibre13"><em class="calibre21">a<sub class="calibre40">j</sub></em> is the activity in <em class="calibre21">A<sub class="calibre40">k</sub></em> with the earliest finish time</li>
</ul>
<p class="mce-root">If <em class="calibre19">a<sub class="calibre40">j</sub> = a<sub class="calibre40">m</sub></em>, we are done. If <em class="calibre19">a<sub class="calibre40">j</sub> != a<sub class="calibre40">m</sub></em>, we can try to replace a<span class="calibre14"><sub class="calibre40">j</sub></span> by am in <em class="calibre19">A<sub class="calibre40">k</sub></em>, producing the set <em class="calibre19">A'<sub class="calibre40">k</sub> = A<sub class="calibre40">k</sub> - {a<sub class="calibre40">k</sub>} ∪ {a<sub class="calibre40">m</sub>}</em>.</p>
<p class="mce-root">We can safely do that since the activities in <em class="calibre19">A<sub class="calibre40">k</sub></em> are disjoined. <em class="calibre19">a<sub class="calibre40">j</sub></em> is the first activity to finish in <em class="calibre19">A<sub class="calibre40">k</sub></em>, and <em class="calibre19">f<sub class="calibre40">m</sub> &lt;= f<sub class="calibre40">j</sub></em>.</p>
<p class="mce-root">Since <em class="calibre19">|A'<sub class="calibre40">k</sub>| = |A<sub class="calibre40">k</sub>|</em>, we conclude that <em class="calibre19">A'<sub class="calibre40">k</sub></em> is a maximum size subset of mutually compatible activities of <em class="calibre19">S<sub class="calibre40">k</sub></em>, and that it includes <em class="calibre19">a<sub class="calibre40">m</sub></em>.</p>
<p class="mce-root">Intuition usually helps us decide whether a greedy algorithm produces the optimal solution, without having to formally prove the optimal substructure and the greedy choice properties. We're also going to cover a different paradigm of algorithm design in this chapter, which is dynamic programming that also requires problems to exhibit the optimal substructure property. If you are not sure if a greedy algorithm works for a given problem due to the greedy choice, you can always build a dynamic programming solution for it to gain some insight.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Huffman Coding</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To gain more insight about greedy algorithms, let's look at another problem that is solvable by a greedy algorithm.</p>
<p class="mce-root">Huffman codes represent a way of compressing data effectively. Data is considered to be a sequence of characters. Huffman's greedy algorithm uses a table with the frequency of each character to build up an optimal way of representing each character as a binary string. </p>
<p class="mce-root">To illustrate this, imagine we have a 1,00,000 character data file that we wish to store in a compressed fashion. The frequency of each character in the data file is given by the following table:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="cdpaligncenter3"><strong class="calibre3">Character</strong></td>
<td class="cdpaligncenter4">a</td>
<td class="cdpaligncenter5">b</td>
<td class="cdpaligncenter5">c</td>
<td class="cdpaligncenter6">d</td>
<td class="cdpaligncenter7">e</td>
<td class="cdpaligncenter8">f</td>
</tr>
<tr class="calibre38">
<td class="cdpaligncenter3"><strong class="calibre3">Frequency</strong></td>
<td class="cdpaligncenter4">45,000</td>
<td class="cdpaligncenter5">13,000</td>
<td class="cdpaligncenter5">12,000</td>
<td class="cdpaligncenter6">16,000</td>
<td class="cdpaligncenter7">9,000</td>
<td class="cdpaligncenter8">5,000</td>
</tr>
</tbody>
</table>
<div class="packt_figref">Table 4.3: Frequency of each character in a data file</div>
<p class="mce-root">There are various ways to represent this information. For the purpose of this problem, let's say that we want to design a binary character code in which each character is represented by a unique binary string (which we shall call a <strong class="calibre6">code word</strong>). One option is to use a fixed-length code (for example, each character is represented by a code word of the same size). If we opt for that, we need three bits to represent each the six characters, as shown in the following table:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="cdpaligncenter9"><strong class="calibre3"><span class="calibre10">Character</span></strong></td>
<td class="cdpaligncenter10">a</td>
<td class="cdpaligncenter5">b</td>
<td class="cdpaligncenter5">c</td>
<td class="cdpaligncenter6">d</td>
<td class="cdpaligncenter7">e</td>
<td class="cdpaligncenter8">f</td>
</tr>
<tr class="calibre26">
<td class="cdpaligncenter9"><strong class="calibre3"><span class="calibre10">Frequency</span></strong></td>
<td class="cdpaligncenter10">45,000</td>
<td class="cdpaligncenter5">13,000</td>
<td class="cdpaligncenter5">12,000</td>
<td class="cdpaligncenter6">16,000</td>
<td class="cdpaligncenter7">9,000</td>
<td class="cdpaligncenter8">5,000</td>
</tr>
<tr class="calibre27">
<td class="cdpaligncenter9"><strong class="calibre3">Code Word</strong></td>
<td class="cdpaligncenter10">000</td>
<td class="cdpaligncenter5">001</td>
<td class="cdpaligncenter5">010</td>
<td class="cdpaligncenter6">011</td>
<td class="cdpaligncenter7">100</td>
<td class="cdpaligncenter8">101</td>
</tr>
</tbody>
</table>
<div class="packt_figref">Table 4.4: Code word for each character</div>
<p class="mce-root">Using this method, we need 3,00,000 bits to code the entire sequence of characters. Can we do better?</p>
<p class="mce-root">A variable-length code can do a lot better than a fixed-length code. Since we want to minimize the size of the compressed sequence of bits, we want to give short code words to frequent characters and long code words to infrequent characters. A possible code for this character sequence is shown in the following table:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="cdpaligncenter11"><strong class="calibre3"><span class="calibre10">Character</span></strong></td>
<td class="cdpaligncenter12">a</td>
<td class="cdpaligncenter5">b</td>
<td class="cdpaligncenter5">c</td>
<td class="cdpaligncenter6">d</td>
<td class="cdpaligncenter7">e</td>
<td class="cdpaligncenter8">f</td>
</tr>
<tr class="calibre26">
<td class="cdpaligncenter11"><strong class="calibre3"><span class="calibre10">Frequency</span></strong></td>
<td class="cdpaligncenter12">45,000</td>
<td class="cdpaligncenter5">13,000</td>
<td class="cdpaligncenter5">12,000</td>
<td class="cdpaligncenter6">16,000</td>
<td class="cdpaligncenter7">9,000</td>
<td class="cdpaligncenter8">5,000</td>
</tr>
<tr class="calibre27">
<td class="cdpaligncenter11"><strong class="calibre3">Code Word</strong></td>
<td class="cdpaligncenter12">0</td>
<td class="cdpaligncenter5">101</td>
<td class="cdpaligncenter5">100</td>
<td class="cdpaligncenter6">111</td>
<td class="cdpaligncenter7">1101</td>
<td class="cdpaligncenter8">1100</td>
</tr>
</tbody>
</table>
<div class="packt_figref">Table 4.5: Possible code for character sequence</div>
<p class="mce-root">Instead of 3,00,000 bits, this code requires only 2,24,000 bits to represent the character sequence. Using this code, we save around 28% of space. The code we have presented is also an optimal character code for this sequence, as we shall see.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building a Huffman Code</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we start studying an algorithm to solve this problem, we should introduce something called <strong class="calibre6">prefix codes</strong>. Prefix codes are codes in which no code word is also a prefix of some other code word. As you have seen from the proposed variable-length code, we must make sure that no code word is also a prefix of some other code word, since we want to concatenate on code words and unambiguously be able to decode it afterwards.</p>
<p class="mce-root">For example, using the code shown previously, we encode the string <kbd class="calibre15">abc</kbd> as <kbd class="calibre15">0101100</kbd>. Since no code word is a prefix of any other, decoding is vastly simplified, as we can identify the initial code word, translate it, and repeat the process on the remainder of the encoded sequence.</p>
<p class="mce-root">A convenient (for decoding purposes) representation of prefix codes is a binary tree whose leaves are the characters of the original data sequence. For the proposed variable-length code, we have the following binary tree:</p>
<p class="cdpaligncenter"><img src="Images/59c876aa-4888-44ae-8c40-4db8b7c60f33.png" width="658" height="677" class="calibre71"/></p>
<div class="packt_figref">Figure 4.1: A Representation of prefix codes</div>
<p class="mce-root">The binary code word for a character is the path from the root to that character, following in the binary digits in each edge. Note that each node also holds the frequency of characters under its subtree. Such a tree also has some interesting properties. A tree for an optimal prefix code has exactly <em class="calibre19">|C|</em> leaves, <em class="calibre19">C</em> being the alphabet from which the characters are drawn. The number of internal nodes is exactly <em class="calibre19">|C| - 1</em>. We also know that the number of bits necessary to encode a particular character in a sequence is equal to the frequency of that character multiplied by the depth of the leaf that holds the character. As such, the number of bits required to encode the full character sequence is simply the sum of these values for all the characters in the alphabet.</p>
<p class="mce-root">If we can build such a tree, we can compute an optimal prefix code. David A. Huffman invented a greedy algorithm to construct an optimal prefix code, called a <strong class="calibre6">Huffman Code</strong>. Its basic idea is to build the tree in a bottom-up fashion. We start with just the leaf, one for each character. We then repeatedly join the two least-frequent nodes, until we are left with a single node, which is the root of the tree.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Developing an Algorithm to Generate Code Words Using Huffman Coding</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To implement an algorithm capable of building the tree that generates the binary code words for the character in a data file using Java:</p>
<ol class="calibre17">
<li class="chapter">Use a priority queue to store nodes with the character frequency.</li>
<li class="chapter">Repeatedly join the two nodes with the least frequencies until you are left with a single node. The source code for this algorithm is as follows:</li>
</ol>
<pre class="calibre30">for (int i = 0; i &lt; N - 1; i++) {<br class="calibre2"/>  Node n = new Node();<br class="calibre2"/>  n.left = pq.remove();<br class="calibre2"/>  n.right = pq.remove();<br class="calibre2"/>  n.frequency = n.left.frequency + n.right.frequency;<br class="calibre2"/>  pq.add(n);<br class="calibre2"/>}</pre>
<div class="packt_figref"><span class="calibre10">Snippet 4.2: Huffman code. Source class name:</span> <span class="calibre10">Huffman</span></div>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/indhgT" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/indhgT</a> to access the full code.</div>
<p class="mce-root">We make use of a priority queue to store our nodes, making it very efficient <em class="calibre19">(O(logn))</em> to extract the node with the least frequency. A priority queue is like a queue, or a stack, but each element has an additional <strong class="calibre6">priority</strong> associated with it. An element with a higher priority is served before an element with lower priority. Priority queues are usually implemented using heaps, which usually provide <em class="calibre19">O(1)</em> time to find the element with a higher priority, <em class="calibre19">O(logn)</em> to insert an element, and <em class="calibre19">O(logn)</em> time to remove the element with a higher priority.</p>
<p class="mce-root">To analyze the running time of Huffman's algorithm, let's break it down into steps. We first go through each character in the frequencies map and build a node that we later insert in the priority queue. It takes <em class="calibre19">O(logn)</em> time to insert a node in the priority queue. Since we go through each character, it takes <em class="calibre19">O(nlogn)</em> to create and initially populate the priority queue. The second for loop executes exactly <em class="calibre19">n-1</em> times. Each time, we perform two removes from the priority queue, each one taking <em class="calibre19">O(logn)</em> time. In its whole, the <kbd class="calibre15">for</kbd> loop takes <em class="calibre19">O(nlogn)</em> time. We thus have two steps, each taking <em class="calibre19">O(nlogn)</em> time, which leaves us at a total running time on a set of <em class="calibre19">n</em> characters of <em class="calibre19">O(nlogn)</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Implementing a Greedy Algorithm to Compute Egyptian Fractions</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6">Scenario</strong></p>
<p class="mce-root">For this activity, we will be building a greedy algorithm to compute Egyptian fractions. Every positive fraction can be represented as a sum of unique unit fractions. A fraction is a unit fraction if its numerator is one and its denominator is a positive integer. For example, <em class="calibre19">1/3</em> is a unit fraction. Such a representation, for example, a sum of unique unit fractions, is called an Egyptian fraction, since it was used by the ancient Egyptians.</p>
<p class="mce-root">For example, the Egyptian fraction representation of <em class="calibre19">2/3</em> is <em class="calibre19">1/2 + 1/6</em>. The Egyptian fraction representation of <em class="calibre19">6/14</em> is <em class="calibre19">1/3 + 1/11 + 1/231</em>.</p>
<p class="mce-root"><strong class="calibre6">Aim</strong></p>
<p class="mce-root">To implement a greedy algorithm to compute Egyptian fractions, as described previously.</p>
<p class="mce-root"><strong class="calibre6">Prerequisites</strong></p>
<ul class="calibre12">
<li class="calibre13">Implement the <kbd class="calibre15">build</kbd> method of the <kbd class="calibre15">EgyptianFractions</kbd> class, which returns a list of denominators for the Egyptian fraction representation, in increasing order, which is available on GitHub at: <br class="calibre2"/>
<a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/egyptian/EgyptianFractions.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/egyptian/EgyptianFractions.java</a></li>
<li class="calibre13">Assume that the denominator is always larger than the numerator, and that the returned denominators always fit in a Long</li>
</ul>
<div class="packt_infobox"><br class="calibre2"/>
To verify that your solution is correct, run <kbd class="calibre31">./gradlew test</kbd> in the command line.</div>
<p class="mce-root"><strong class="calibre6">Steps for Completion</strong></p>
<ol class="calibre17">
<li class="chapter">Check whether the numerator divides the denominator without leaving a remainder, and that we're left with a single fraction</li>
<li class="chapter">If not, find the greatest possible unit fraction, subtract it from the original fraction, and recur on the remaining fraction</li>
</ol>
<p class="mce-root">In this first section, we introduced the greedy paradigm of algorithm design using the activity selection problem as a running example. We introduced the two properties a problem must observe to be optimally solved by a greedy algorithm: optimal substructure and greedy choice. To gain intuition about the applicability of greedy algorithms, we later explored two other problems that are solvable by a greedy approach: Huffman coding and Egyptian fractions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting Started with Divide and Conquer Algorithms</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In <a href="ab7975d0-4b38-437d-9ff5-8f6c20199874.xhtml" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">Chapter 2</a>, <em class="calibre19"><span class="calibre14"><span class="calibre14">Sorting Algorithms and Fundamental Data Structures</span></span></em>, we introduced, among other sorting algorithms, merge and quick sort. A peculiarity of both algorithms is that they divide the problem into subproblems that are smaller instances of the same, solve each one of the subproblems recursively, and then combine the solutions to the subproblems into the solution for the original problem. This strategy forms the basis of the divide and conquer paradigm.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Divide and Conquer Approach</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In a divide and conquer approach, we solve a problem recursively, applying the following three steps at each level of recursion:</p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre3">Divide</strong> the problem into more than one subproblems that are smaller instances of the same problem.</li>
<li class="calibre13"><strong class="calibre3">Conquer</strong> the subproblems by solving them recursively. Eventually, the subproblem sizes are small enough for them to be solved in a straightforward manner.</li>
<li class="calibre13"><strong class="calibre3">Combine</strong> the solutions to the subproblems in the solution for the original problem.</li>
</ul>
<p class="mce-root">When a subproblem is large enough to be solved recursively, we call that the <strong class="calibre6">recursive case</strong>. When a subproblem becomes small enough that recursion is no longer necessary, we say that we have reached to the <strong class="calibre6">base case</strong>. It is common to solve subproblems that are different from the original problem, in addition to the subproblems that are smaller instances of the main problem. Solving these problems is considered to be part of the combine step.</p>
<p class="mce-root">In <a href="ab7975d0-4b38-437d-9ff5-8f6c20199874.xhtml" target="_blank" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">Chapter 2</a>, <em class="calibre19">Sorting Algorithms and Fundamental Data Structures</em>, we saw that the runtime complexity of merge sort was <em class="calibre19">O(nlogn)</em>. We can also see that the worst-case running time <em class="calibre19">T(n)</em> of merge sort can be described by the following recurrence:</p>
<div class="cdpaligncenter1"><img class="fm-editor-equation2" src="Images/6ecc74ee-27be-45ee-950b-fb75990d6893.png" width="1900" height="298"/></div>
<p class="mce-root">These kinds of recurrences arise frequently and characterize divide and conquer algorithms. If we generalize the recursion to the following:</p>
<div class="cdpaligncenter1"><img class="fm-editor-equation3" src="Images/e675b4ff-2902-4f87-893f-9aa79d8a6bfb.png" width="1900" height="303"/></div>
<p class="mce-root"/>
<p class="mce-root">Where <em class="calibre19">a &gt;= 1, b &gt; 1</em> and <em class="calibre19">f(n)</em> is a given function, we have the recurrence for the worst-case running time of a divide and conquer algorithm that creates subproblems, each being of size <em class="calibre19">1/b</em> of the original problem, and in which the combine steps together take <em class="calibre19">f(n)</em> time.</p>
<p class="mce-root">When it comes to divide and conquer algorithms, it is often easier to come up with this recursion, but harder to derive the runtime complexity. Fortunately, there are at least three methods to provide <strong class="calibre6">O</strong> bounds for these recurrences: the substitution method, the recursion tree method, and the master method. For the purpose of this book, we will only be focused on the master method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Master Method</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The master method provides a way to solve recurrences of the following form:</p>
<div class="cdpaligncenter1"><em class="calibre21">T(n) = aT(n/b) + f(n)</em></div>
<p class="mce-root">Where:<br class="calibre7"/>
<em class="calibre19">a &gt;= 1</em> and <em class="calibre19">b &gt; 1</em> are constants, <em class="calibre19">f(n)</em> is an asymptotically positive function</p>
<p class="mce-root">The master method consists of three cases, which will allow you to solve these kind of recurrences quite easily. Before we delve into these three cases, it is important to note that the recurrence is not actually well defined, since <em class="calibre19">n/b</em> may not be an integer. Whether we replace it with the floor or ceiling of the <em class="calibre19">n/b</em> division will not affect the asymptotic behavior of the recurrence.</p>
<p class="mce-root">The big O notation describes the asymptotic upper bound of the growth rate of a function. There are also other notations to describe bounds on the growth rate of functions.</p>
<p class="mce-root">For the purpose of the master method, we're interested in the big-theta notation (<em class="calibre19">Ө</em>) and the big-omega notation (<em class="calibre19">Ω</em>).</p>
<p class="mce-root">The big-theta notation describes the asymptotic tight bound of the growth rate. It's called tight bound because the running time is nailed within a constant factor above and below. It is a tighter bound than <em class="calibre19">O(n)</em>.</p>
<p class="mce-root">When we say that an algorithm is <em class="calibre19">O(f(n))</em>, we're saying that the running time of the algorithm as <em class="calibre19">n</em> gets larger is at most proportional to <em class="calibre19">f(n)</em>.</p>
<p class="mce-root">When we say that an algorithm is <em class="calibre19">Ө(f(n))</em>, we're saying that the running time of the algorithm as <em class="calibre19">n</em> gets larger is proportional to <em class="calibre19">f(n)</em>.</p>
<p class="mce-root">The big-omega notation describes an asymptotic lower bound of the growth rate. When we say that an algorithm is <em class="calibre19">Ω(f(n))</em>, we're saying that the running time of the algorithm as n gets larger is at least proportional to <em class="calibre19">f(n)</em>.</p>
<p class="mce-root">Having clarified all the necessary notations, we can present the three cases to derive the asymptotic bounds from a recurrence of type <em class="calibre19">T(n) = aT(n/b) + f(n)</em> as follows:</p>
<ol class="calibre17">
<li class="chapter"><em class="calibre21">If f(n) = O(n<sup class="calibre32">log<sub class="calibre72">b</sub></sup><sup class="calibre32">a-∈</sup>)</em> for some constant <em class="calibre21">∈ &gt; 0</em>, then <em class="calibre21">T(n) = θ(n<sup class="calibre32">log<sub class="calibre72">b</sub></sup><sup class="calibre32">a</sup>) = O(n<sup class="calibre32">log<sub class="calibre72">b</sub></sup><sup class="calibre32">a</sup>)</em></li>
<li class="chapter">If <em class="calibre21">f(n) = θ(n<sup class="calibre32">log<sub class="calibre72">b</sub></sup><sup class="calibre32">a</sup>)</em>, then <em class="calibre21">T(n) = θ(n<sup class="calibre32">log<sub class="calibre72">b</sub></sup><sup class="calibre32">a</sup> log(n)) = O(n<sup class="calibre32">log<sub class="calibre72">b</sub></sup><sup class="calibre32">a</sup> log(n))</em></li>
<li class="chapter">If <em class="calibre21">f(n) = Ω(n<sup class="calibre32">log<sub class="calibre72">b</sub></sup><sup class="calibre32">a+∈</sup>)</em> for some constant <em class="calibre21">∈ &gt; 0</em>, and if <em class="calibre21">a f(n/b) ≤ c f(n)</em> for some constant <em class="calibre21">c &lt; 1</em> and all sufficiently large <em class="calibre21">n</em>, then <em class="calibre21">T(n) = T(n) = θ(f(n)) = O(f(n))</em></li>
</ol>
<p class="mce-root">Note that in all three cases we're comparing the function <em class="calibre19">f(n)</em> with the function n<sup class="calibre32">log<span class="calibre14"><sub class="calibre72">b</sub></span></sup><sup class="calibre32">a</sup>. This function is usually called the <strong class="calibre6">critical exponent</strong>.</p>
<p class="mce-root">We can see intuitively that the larger of the two functions determines the solution to the recurrence.</p>
<p class="mce-root">In <em class="calibre19">case 2</em>, the functions are of the same size, so we multiply by a logarithmic factor.</p>
<p class="mce-root">One other way to see this is that in <em class="calibre19">case 1</em>, the work to split and recombine a problem is dwarfed by subproblems; in <em class="calibre19">case 2</em>, the work to split and recombine a problem is comparable to subproblems; and in <em class="calibre19">case 3</em>, the work to split and recombine a problem dominates the subproblems.</p>
<p class="mce-root">To get some practice on using the master method, let's look at some examples.</p>
<p class="mce-root">For the first case, let's consider the following:</p>
<div class="cdpaligncenter1"><img class="fm-editor-equation4" src="Images/12f13cde-6a96-4453-b439-e303f7414a7d.png" width="1640" height="220"/></div>
<p class="mce-root"/>
<p class="mce-root">For this recurrence, we have <em class="calibre19">a = 9</em>, <em class="calibre19">b = 3</em>, <em class="calibre19">f(n) = n</em>, and thus we have <em class="calibre19">n<sup class="calibre32">log<span class="calibre14"><sub class="calibre72">b</sub></span></sup><sup class="calibre32">a</sup> = n<sup class="calibre32">log<sub class="calibre72">3</sub></sup></em><em class="calibre19"><sup class="calibre32">9</sup> = θ(n<sup class="calibre32">2</sup>)</em>. Since <em class="calibre19">f(n) = Ω(n<sup class="calibre32">log<sub class="calibre72">4</sub></sup></em><em class="calibre19"><sup class="calibre32">3+∈</sup>)</em>, <em class="calibre19">∈</em> being one, we can apply <em class="calibre19">case 1</em> of the master theorem and conclude that <em class="calibre19">T(n) = O(n2)</em>.</p>
<p class="mce-root">For the second case, let's consider the following:</p>
<div class="cdpaligncenter1"><img class="fm-editor-equation5" src="Images/0bcc4829-6d16-4475-a815-dc5f2a9c328d.png" width="1900" height="212"/></div>
<p class="mce-root">For this recurrence, we have <em class="calibre19">a = 2</em>, <em class="calibre19">b = 2</em>, <em class="calibre19">f(n) = 10n</em>, and thus we have <em class="calibre19">n<sup class="calibre32">log<sub class="calibre72">b</sub></sup></em><em class="calibre19"><sup class="calibre32">9</sup> = n<sup class="calibre32">log<sub class="calibre72">2</sub></sup></em><em class="calibre19"><sup class="calibre32">2</sup> = O(n)</em>. Since <em class="calibre19">f(n) = O(n)</em>, we can apply <em class="calibre19">case 2</em> of the master theorem and conclude that <em class="calibre19">T(n) = O(nlogn)</em>.</p>
<p class="mce-root">For the third and final case, let's consider the following:</p>
<div class="cdpaligncenter1"><img class="fm-editor-equation6" src="Images/fa684dd6-9968-4e85-8634-3516a4a3d102.png" width="1900" height="196"/></div>
<p class="mce-root">For this recurrence, we have <em class="calibre19">a = 3</em>, <em class="calibre19">b = 4</em>, <em class="calibre19">f(n) = nlog(n)</em>, and thus we have <em class="calibre19">n<sup class="calibre32">log<sub class="calibre72">b</sub></sup></em><em class="calibre19"><sup class="calibre32">a</sup> = n<sup class="calibre32">log<sub class="calibre72">4</sub></sup></em><em class="calibre19"><sup class="calibre32">3</sup> = O(n<sup class="calibre32">0.793</sup>)</em>. Since <em class="calibre19">f(n) = Ω(n<sup class="calibre32">log<sub class="calibre72">4</sub></sup></em><em class="calibre19"><sup class="calibre32">3+∈</sup>)</em>, <em class="calibre19">∈</em> being around <em class="calibre19">0.2</em>, we can apply <em class="calibre19">case 3</em> as long as the condition holds for <em class="calibre19">f(n)</em>.</p>
<p class="mce-root">For sufficiently large <em class="calibre19">n</em>, we have <em class="calibre19">af(n/b) = 3(n/4)log(n/4) &lt;= (3/4)nlogn (for c = 3/4)</em>. Consequently, <em class="calibre19">T(n) = O(nlogn)</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Closest Pair of Points Problem</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now that we know what characterizes a divide and conquer algorithm and are familiar with the master method to derive bounds from recurrences, let's look at a problem solvable by a divide and conquer approach.</p>
<p class="mce-root">The problem we will be looking at is the problem of finding the closest pair of points on a plane. We are given an array of <em class="calibre19">n</em> points in the plane, and we want to find out the closest pair of points in this array. Recall that the distance between two points, <em class="calibre19">p</em> and <em class="calibre19">q</em>, is given by the following:</p>
<p class="cdpaligncenter"><img class="fm-editor-equation7" src="Images/7fdfc998-b219-47ee-905f-d62184129d1f.png" width="1900" height="265"/></p>
<p class="mce-root">Our first approach may be to compute the distance between each pair and return the smallest, for a runtime complexity of <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>. The following snippet implements this algorithm:</p>
<pre class="calibre20">PointPair bruteForce(List&lt;Point&gt; points) {<br class="calibre2"/>  PointPair best = new PointPair(points.get(0), points.get(1));<br class="calibre2"/>  for (int i = 2; i &lt; points.size(); i++) {<br class="calibre2"/>    for (int j = i - 1; j &gt;= 0; j--) {<br class="calibre2"/>      PointPair candidate = new PointPair(points.get(i), points.get(j));<br class="calibre2"/>      if (candidate.distance() &lt; best.distance())<br class="calibre2"/>        best = candidate;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  return best;<br class="calibre2"/>}</pre>
<div class="packt_figref"><span class="calibre10">Snippet 4.3: Brute force for closest pair of points. Source class name:</span> <span class="calibre10">ClosestPairOfPoints</span></div>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/FrRW3i" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/FrRW3i</a> to access this code.</div>
<p class="mce-root">The proposed algorithm solves this problem, but we can do better by using a divide and conquer approach. The algorithm makes use of a preprocessing step in which it sorts the input array by its <em class="calibre19">x</em> coordinate. Then, it proceeds as follows:</p>
<ol class="calibre17">
<li class="chapter"><strong class="calibre3">Divides</strong> the array into two halves</li>
<li class="chapter"><strong class="calibre3">Recursively</strong> finds the smallest distances in both subarrays (<strong class="calibre3">conquer</strong>)</li>
<li class="chapter"><strong class="calibre3">Combines</strong> the results by taking the minimum distance from both halves and additionally considers pairs so that one point in the pair is from the left subarray and another is from the right subarray</li>
</ol>
<p class="mce-root">The approach seems straightforward, except for the combine part. After finding the minimum distance <em class="calibre19">d</em> from both the left and right subarrays, we have an upper bound of the minimum distance for this subproblem. Therefore, we only need to consider points whose <em class="calibre19">x</em> coordinate is closer than <em class="calibre19">d</em> to the middle vertical line. We can then sort those points by <em class="calibre19">y</em> coordinates and find the smallest distance in the strip, as shown in the following diagram:</p>
<p class="cdpaligncenter"><img src="Images/74bdf3ed-7e65-4c80-95e5-608f9fdc79c0.png" width="449" height="497" class="calibre73"/></p>
<div class="packt_figref">Figure 4.2: Method to calculate closest pair of points</div>
<p class="mce-root">The following code snippet computes the minimum distance in the strip, considering the minimum distance computed so far:</p>
<pre class="calibre20">Collections.sort(sortedPoints, (o1, o2) -&gt; Integer.signum(o1.y - o2.y));<br class="calibre2"/>for (int i = 0; i &lt; points.size(); i++) {<br class="calibre2"/>  for (int j = i + 1; j &lt; points.size() &amp;&amp;<br class="calibre2"/>    (points.get(j).y - points.get(i).y) &lt; best.distance(); j++) {<br class="calibre2"/>     PointPair candidate = new PointPair(points.get(i), points.get(j));<br class="calibre2"/>     if (candidate.distance() &lt; best.distance())<br class="calibre2"/>       best = candidate;<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<div class="packt_figref"><span class="calibre10">Snippet 4.4: Computing the minimum distance between pairs of points in the middle strip. Source class name:</span> <span class="calibre10">ClosestPairOfPoints</span></div>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/PwUrTc" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/PwUrTc</a> to access the full code.</div>
<p class="mce-root">Looking at this code, it seems to have a runtime of <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>, which doesn't really improve our brute force approach. However, it can be proved geometrically that for every point in the strip, a maximum of seven points after it need to be checked. This reduces the runtime of this step to <em class="calibre19">O(nlogn)</em> due to the sorting step.</p>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
You can refer to <a href="http://people.csail.mit.edu/indyk/6.838-old/handouts/lec17.pdf" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">http://people.csail.mit.edu/indyk/6.838-old/handouts/lec17.pdf</a> for the geometric proof of the preceding problem.<br class="calibre2"/></span></div>
<p class="mce-root">We can even do better on this step if we sort the initial input by the <em class="calibre19">y </em>coordinate and keep a relationship between the points on the <em class="calibre19">x</em>-sorted array and the <em class="calibre19">y</em>-sorted array, effectively reducing the runtime of this step to <em class="calibre19">O(n)</em>.</p>
<p class="mce-root">After having computed the minimum distance from both subarrays and the middle strip, we have found the closest pair of points in the subarray. The following code snippet exposes the merging part of both subarrays and calling the <kbd class="calibre15">bestWithStrip()</kbd> method:</p>
<pre class="calibre20">PointPair bestSoFar = bl;<br class="calibre2"/>if (br.distance() &lt; bl.distance())<br class="calibre2"/>  bestSoFar = br;<br class="calibre2"/>List&lt;Point&gt; strip = new ArrayList&lt;&gt;();<br class="calibre2"/>for (int i = 0; i &lt; N; i++) {<br class="calibre2"/>  if (Math.abs(points.get(i).x - midPoint.x) &lt; bestSoFar.distance())<br class="calibre2"/>      strip.add(points.get(i));<br class="calibre2"/>}<br class="calibre2"/>return bestWithStrip(strip, bestSoFar);</pre>
<div class="packt_figref"><span class="calibre10">Snippet 4.5: Combine Step of the divide and conquer algorithm to find the closest pair of points<br class="calibre2"/>
on a plane. Source class name:</span> <span class="calibre10">ClosestPairOfPoints</span></div>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/wyQkBc" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/wyQkBc</a> to access this code.</div>
<p class="mce-root">The proposed algorithm divides all points into two sets and recursively solves both subproblems. After dividing, it finds the strip in <em class="calibre19">O(n)</em> time and finds the closest points in <em class="calibre19">O(n)</em> time (we're assuming the improvement of not requiring the sort in this step). Therefore, <em class="calibre19">T(n)</em> can be expressed as <em class="calibre19">T(n) = 2T(n/2) + O(n) + O(n) = 2T(n/2) + O(n)</em>, which is a bound of <em class="calibre19">O(nlogn)</em>, being better than the brute force approach.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Solving the Maximum Subarray Problem</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6">Scenario</strong></p>
<p class="mce-root">Create an algorithm to solve the maximum subarray problem. Find the non-empty, contiguous subarray of the input array whose values have the largest sum. You can see an example array with the maximum subarray indicated in the following diagram:</p>
<p class="cdpaligncenter"><img src="Images/599a327f-5d66-4291-ac25-597488b7e4d2.png" class="calibre74"/></p>
<p class="mce-root">The <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em> brute force algorithm that tests all combinations for the start and end indices of the subarray is trivial to implement. Try to solve this using the divide and conquer algorithm.</p>
<p class="mce-root"><strong class="calibre6">Aim</strong></p>
<p class="mce-root">To design and implement an algorithm to solve the maximum subarray problem with a better runtime than the <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em> brute force algorithm, using a divide and conquer approach.</p>
<p class="mce-root"><strong class="calibre6">Prerequisites</strong></p>
<ul class="calibre12">
<li class="calibre13">You need to implement the <kbd class="calibre15">maxSubarray()</kbd> method of the <kbd class="calibre15">MaximumSubarray</kbd> class in the source code, which returns the sum of values for the maximum subarray of the input array. The code is available on the following path: <br class="calibre2"/>
<a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/maxsubarray/MaximumSubarray.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/maxsubarray/MaximumSubarray.java</a></li>
<li class="calibre13">Assume that the sum always fits in an int, and that the size of the input array is at most 100,000.</li>
</ul>
<div class="packt_infobox">The source code comes with a test suite for this class, so to verify that your solution is correct, run <kbd class="calibre31">./gradlew test</kbd> in the command line.</div>
<p class="mce-root"><strong class="calibre6">Steps for Completion</strong></p>
<p class="mce-root">The divide and conquer approach suggests that we divide the subarray into two subarrays of as equal size as possible. After doing so, we know that a maximum subarray must lie in exactly one of following three places:</p>
<ul class="calibre12">
<li class="calibre13">Entirely in the left subarray</li>
<li class="calibre13">Entirely in the right subarray</li>
<li class="calibre13">Crossing the midpoint</li>
</ul>
<p class="mce-root">The maximum subarray of the arrays on the left and right is given recursively, since those subproblems are smaller instances of the original problem. </p>
<p class="mce-root">Find a maximum subarray that crosses the midpoint.</p>
<p class="mce-root">There exists an even faster dynamic programming algorithm with a runtime of <em class="calibre19">O(n)</em> to solve the maximum subarray problem. The algorithm is called Kadane's algorithm. Dynamic programming will be explored in the next section.</p>
<p class="mce-root">In the second section, we introduced the divide and conquer paradigm of algorithm design. We formalized the steps that a divide and conquer algorithm goes through, and showed the students how to go from a recurrence relationship to a runtime complexity bound using the master theorem. To gain intuition about the applicability of divide and conquer algorithms, we explored the problem of finding the closest pair of points on a plane.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding Dynamic Programming</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">After greedy and divide and conquer, we will turn our attention to dynamic programming. Dynamic programming is an algorithm design paradigm that also attempts to solve optimization problems by combining solutions with subproblems. Unlike divide and conquer, subproblems need to exhibit optimal substructure for dynamic programming to be applicable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Elements of a Dynamic Programming Problem</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are two key ingredients that an optimization problem must have for dynamic programming to be applicable: optimal substructure and overlapping subproblems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Optimal Substructure</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Optimal substructure is something we already covered when we introduced greedy algorithms. Recall that a problem exhibits optimal substructure, if an optimal solution to the problem contains within it, the optimal solutions to the sub-problems. There's a common pattern when trying to discover optimal substructure for a problem that can be explained as follows:</p>
<ul class="calibre12">
<li class="calibre13">Show that a solution to the problem consists of making a choice, which leaves one or more subproblems to be solved. This choice may not be obvious and it is likely that many choices have to be tried (contrary to a greedy approach, in which a single optimal choice is made).</li>
<li class="calibre13">Supposing that you are given the choice that leads to an optimal solution, determine the subproblems that follow.</li>
</ul>
<ul class="calibre12">
<li class="calibre13">Show that the solutions to the subproblems used within an optimal solution to the problem must themselves be optimal</li>
<li class="calibre13">Usually, a <em class="calibre21">cut-and-paste</em> technique is used here. By supposing that each subproblem solution is not optimal, if a non-optimal solution is <em class="calibre21">cut out</em> and an optimal one is <em class="calibre21">pasted in</em>, a better solution to the original problem is produced, contradicting the supposition that the original solution to the problem was optimal</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Overlapping Subproblems</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Another ingredient that optimization problems must have for dynamic programming to apply is that the space of subproblems should be <strong class="calibre6">small</strong>. Hence, a recursive algorithm for the problem should solve the same subproblems repeatedly. Typically, the total number of distinct subproblems is a polynomial in the input size. A recursive algorithm is said to have overlapping subproblems if it visits the same problem repeatedly. It's therefore typical for dynamic programming algorithms to cache solutions to subproblems to avoid re-computation of the same solutions over and over.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">0-1 Knapsack</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To showcase a dynamic programming solution, exploring the properties of the problem that make it solvable by this technique, we shall look at the <strong class="calibre6">0-1 knapsack</strong> problem.</p>
<p class="mce-root">You are given weights and values of <em class="calibre19">n</em> items. You must put these items in a knapsack of capacity <em class="calibre19">W</em> to get the maximum value of the knapsack. You cannot break an item. You can either pick it or not pick it (hence the <em class="calibre19">0-1</em> property).</p>
<p class="mce-root">In other words, you are given two arrays, <em class="calibre19">values[0...n-1]</em> and <em class="calibre19">weights[0...n-1]</em>, which represent values and weights associated with n items, respectively. You want to find the maximum value subset of <em class="calibre19">values[]</em> such that the sum of weights of the subset is smaller than or equal to <em class="calibre19">W</em>.</p>
<p class="mce-root">The first immediate solution to this problem is to consider all subsets of items and calculate the total weight and value of all subsets, considering only those whose total weight is smaller than <em class="calibre19">W</em>. To consider all subsets of items, we can observe that there are two choices for each item: either it is included in the optimal subset, or it is not. Hence, the maximum value we can obtain from <em class="calibre19">n</em> items is the maximum of two values:</p>
<ol class="calibre17">
<li class="chapter">The maximum value obtained by <em class="calibre21">n-1</em> items and <em class="calibre21">W</em> weight (that is, they don't include the <em class="calibre21">n<sup class="calibre32">th</sup></em> item in the optimal solution)</li>
<li class="chapter">The value of the <em class="calibre21">n<sup class="calibre32">th</sup></em> item plus the maximum value obtained by <em class="calibre21">n-1</em> items and <em class="calibre21">W</em> minus the weight of the <em class="calibre21">n<sup class="calibre32">th</sup></em> item (for example, including the <em class="calibre21">n<sup class="calibre32">th</sup></em> item)</li>
</ol>
<p class="mce-root">With the previous observation, we've shown the optimal substructure property for the <em class="calibre19">0-1</em> knapsack problem.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Solving the 0-1 Knapsack Problem Using Recursion</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To write a code for solving the <em class="calibre19">0-1</em> knapsack problem by implementing the recursive approach.</p>
<p class="mce-root">Remember that this is a recursive top-down approach, thus it repeatedly computes the same subproblems for an exponential runtime complexity (2<sup class="calibre32">n</sup>). The following code snippet solves this problem using a recursive approach:</p>
<pre class="calibre20">public int recursiveAux(int W, int weights[], int values[], int n) {<br class="calibre2"/>  if (n == 0 || W == 0)<br class="calibre2"/>    return 0;<br class="calibre2"/>  if (weights[n - 1] &gt; W)<br class="calibre2"/>    return recursiveAux(W, weights, values, n - 1);<br class="calibre2"/>  return Math.max(values[n - 1] +<br class="calibre2"/>   recursiveAux(W - weights[n - 1], weights, values, n - 1),<br class="calibre2"/>   recursiveAux(W, weights, values, n - 1));<br class="calibre2"/> }</pre>
<div class="packt_figref"><span class="calibre10">Snippet 4.6: Recursive solution for the 0-1 Knapsack problem. Source class name: </span><span class="calibre10">Knapsack</span></div>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/RoNb5L" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/RoNb5L</a> to access this code.</div>
<p class="mce-root">The following diagram of tree shows the recursion for <em class="calibre19">n</em> and <em class="calibre19">W</em>, with inputs <em class="calibre19">values[] = {10, 20, 30}</em> and <em class="calibre19">weights[] = {1, 1, 1}</em>:</p>
<p class="cdpaligncenter"><img src="Images/8b975d86-dbdc-473f-8dd6-aefd117c7609.png" width="868" height="399" class="calibre75"/></p>
<div class="packt_figref"><span class="calibre10">Figure 4.3: Tree Showing the recursion for N and W</span></div>
<p class="mce-root">Since problems are evaluated again, this has the overlapping subproblems property. When we have a recursive top-down approach to a problem with the overlapping subproblems property, we can improve things by modifying the procedure to save the result of each subproblem (in an array or hash table). The procedure now first checks to see whether it has previously solved the subproblem. If so, it returns the saved value; if not, it computes, stores, and returns it. It is said that the recursive procedure has been memoized, remembering what results it has computed previously. Such an approach is therefore usually called top-down with memoization. The following code snippet adapts the previous one to use memoization:</p>
<pre class="calibre20">public int topDownWithMemoizationAux(int W, int weights[], int values[], int n, int[][] memo) {<br class="calibre2"/>  if (n == 0 || W == 0)<br class="calibre2"/>    return 0;<br class="calibre2"/>  if (memo[n][W] == -1) {<br class="calibre2"/>    if (weights[n - 1] &gt; W)<br class="calibre2"/>      memo[n][W] = topDownWithMemoizationAux(W, weights, values, <br class="calibre2"/>                   n - 1, memo);<br class="calibre2"/>    else<br class="calibre2"/>      memo[n][W] = Math.max(<br class="calibre2"/>        values[n - 1] + topDownWithMemoizationAux(W - weights[n - 1], <br class="calibre2"/>        weights, values, n - 1, memo),<br class="calibre2"/>        topDownWithMemoizationAux(W, weights, values, n - 1, memo));<br class="calibre2"/>  }<br class="calibre2"/>  return memo[n][W];<br class="calibre2"/>}</pre>
<div class="packt_figref"><span class="calibre10">Snippet 4.7: Top down with memoization approach for the 0-1 knapsack problem. Source class name:</span> <span class="calibre10">Knapsack</span></div>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/VDEZ1B" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/VDEZ1B</a> to access this code.</div>
<p class="mce-root">By applying memoization, we reduce the runtime complexity of the algorithm from exponential (<em class="calibre19">2<sup class="calibre32">n</sup></em>) to quadratic (<em class="calibre19">n*W</em>). It is also possible to solve this problem using a bottom-up approach.</p>
<p class="mce-root">Use of a bottom-up approach typically depends on some natural notion of the <em class="calibre19">size</em> of the subproblems. We must sort the subproblems by size and solve them in order, smallest first, so that we're sure that we already have computed the solutions for smaller subproblems when we need them for a larger one.</p>
<p class="mce-root">A bottom-up approach usually yields the same asymptotic running time as a top-down approach, but it is typical for it to have much better constant factors, since it has less overhead for procedure calls. A bottom-up approach for solving the <em class="calibre19">0-1</em> Knapsack problem is shown in the following code snippet:</p>
<pre class="calibre20"><span class="calibre10">public int topDownWithMemoizationAux(int W, int weights[], <br class="calibre2"/>  int values[], int n, int[][] memo) {<br class="calibre2"/>    if (n == 0 || W == 0)<br class="calibre2"/>      return 0;<br class="calibre2"/>      if (memo[n][W] == -1) {<br class="calibre2"/>        if (weights[n - 1] &gt; W)<br class="calibre2"/>          memo[n][W] = topDownWithMemoizationAux(W, weights,<br class="calibre2"/>            values, n - 1, memo);<br class="calibre2"/>        else<br class="calibre2"/>          memo[n][W] = Math.max(<br class="calibre2"/>            values[n - 1] +<br class="calibre2"/>            topDownWithMemoizationAux(W - weights[n - 1], <br class="calibre2"/>            weights, values, n - 1, memo),</span> <br class="calibre2"/>            <span class="calibre10">topDownWithMemoizationAux(W, weights,<br class="calibre2"/>            values, n - 1, memo));<br class="calibre2"/>      }<br class="calibre2"/>      return memo[n][W];<br class="calibre2"/>}</span>  </pre>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/bYyTs8" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/bYyTs8</a> to access this code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Longest Common Subsequence</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now, let's look at a different problem which is solvable by a dynamic programming algorithm. The problem we're now interested in is the longest common subsequence problem.</p>
<div class="packt_infobox"><br class="calibre2"/>
The difference between a subsequence and a substring is that a substring is a consecutive subsequence. For example, <em class="calibre21">[a, d, f]</em> is a subsequence of <em class="calibre21">[a, b, c, d, e, f]</em>, but not a substring. <em class="calibre21">[b, c, d]</em> is a substring and a subsequence of <em class="calibre21">[a, b, c, d, e, f]</em>.<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root">We're interested in finding similarities between two given sequences by computing the <strong class="calibre6">Longest Common Subsequence</strong> (<strong class="calibre6">LCS</strong>) between them. A common subsequence, <em class="calibre19">S<sub class="calibre40">3</sub></em>, of two given sequences, <em class="calibre19">S<sub class="calibre40">1</sub></em> and <em class="calibre19">S<sub class="calibre40">2</sub></em>, is a sequence whose elements appear in both <em class="calibre19">S</em> and <em class="calibre19">S<sub class="calibre40">2</sub></em> in the same order, but not necessarily consecutively. This problem is usually applicable when finding DNA similarities of different organisms.</p>
<p class="mce-root">For example, if we have two strands, <em class="calibre19">S<sub class="calibre40">1</sub></em> and <em class="calibre19">S<sub class="calibre40">2</sub></em>, as follows:</p>
<p class="mce-root"><em class="calibre19">S<sub class="calibre40">1</sub> = ACCGGTCGAGTGCGCGGAGCCGGCCGAA</em><br class="calibre7"/>
<em class="calibre19">S<sub class="calibre40">2</sub> = GTCGTTCGGAATGCCGTTGCTCTGTAAAA</em></p>
<p class="mce-root">Then the longest common strand between those two, let's call it S<sub class="calibre40">3</sub>, would be as follows:</p>
<p class="mce-root"><em class="calibre19">S<sub class="calibre40">3</sub> = GTCGTCGGAAGCCGGCCGAA</em></p>
<p class="cdpaligncenter"><img src="Images/ad9bd457-e4b4-4cde-b38b-dfe89c9518e6.png" width="268" height="149" class="calibre76"/></p>
<div class="packt_figref">Figure 4.4: Calculating the longest common subsequence</div>
<p class="mce-root">This problem is solvable using dynamic programming. If we go for a brute force approach, we can enumerate all subsequences of <em class="calibre19">S<sub class="calibre40">1</sub></em> and check each subsequence to see if it is also a subsequence of <em class="calibre19">S<sub class="calibre40">2</sub></em>, keeping track of the longest one we find.</p>
<p class="mce-root">However, if <em class="calibre19">|S<sub class="calibre40">1</sub>| = m</em>, then <em class="calibre19">S<sub class="calibre40">1</sub></em> has <em class="calibre19">2m</em> subsequences, making it impractical for long sequences. The <strong class="calibre6">LCS</strong> exhibits the optimal-substructure property.</p>
<p class="mce-root">One way for this to become evident is to think in terms of prefixes. Let's assume that we have the following two sequences:</p>
<p class="mce-root"><em class="calibre19">X = {x<sub class="calibre40">1</sub>, x<sub class="calibre40">2</sub>… x<sub class="calibre40">m</sub>}</em><br class="calibre7"/>
<em class="calibre19">Y = {y<sub class="calibre40">1</sub>, y<sub class="calibre40">2</sub>… y<sub class="calibre40">n</sub>}</em></p>
<p class="mce-root">Let <em class="calibre19">Z</em> be any LCS of <em class="calibre19">X</em> and <em class="calibre19">Y</em> that can be represented as follows:</p>
<p class="mce-root"><em class="calibre19">Z = {z<sub class="calibre40">1</sub>, z<sub class="calibre40">2</sub>… z<sub class="calibre40">k</sub>}</em></p>
<p class="mce-root">Then, the following cases are possible:</p>
<ol class="calibre17">
<li class="chapter">If <em class="calibre21">x<sub class="calibre40">m</sub> = y<sub class="calibre40">n</sub></em>, then <em class="calibre21">z<sub class="calibre40">k</sub> = x<sub class="calibre40">m</sub> = y<sub class="calibre40">n</sub></em>, and therefore <em class="calibre21">Z<sub class="calibre40">k</sub>-1</em> is a LCS of <em class="calibre21">X<sub class="calibre40">m</sub>-1</em> and <em class="calibre21">Y<sub class="calibre40">n</sub>-1</em></li>
<li class="chapter">If <em class="calibre21">x<sub class="calibre40">m</sub> != y<sub class="calibre40">n</sub></em>, then <em class="calibre21">z<sub class="calibre40">k</sub> != x<sub class="calibre40">m</sub></em> implies that <em class="calibre21">Z</em> is a LCS of <em class="calibre21">X<sub class="calibre40">m</sub>-1</em> and <em class="calibre21">Y</em></li>
<li class="chapter">If <em class="calibre21">x<sub class="calibre40">m</sub> != y<sub class="calibre40">n</sub></em>, then <em class="calibre21">z<sub class="calibre40">k</sub> != y<sub class="calibre40">n</sub></em> implies that <em class="calibre21">Z</em> is a LCS of <em class="calibre21">X</em> and <em class="calibre21">Yn-1</em></li>
</ol>
<p class="mce-root">This tells us that an LCS of two sequences contains the LCS of prefixes of the two sequences, exhibiting the optimal-substructure property. If we define <em class="calibre19">c[i][j]</em> to be the length of a LCS of sequences <em class="calibre19">X<sub class="calibre40">i</sub></em> and <em class="calibre19">Y<sub class="calibre40">j</sub></em>, then we can arrive at the following recursive formula, which guides us toward the dynamic programming solution for the problem that can be represented as follows:</p>
<div class="cdpaligncenter1"><img class="fm-editor-equation8" src="Images/200e5215-3062-41cd-b1ed-5e67d99fe77e.png" width="1900" height="274"/></div>
<p class="mce-root">Looking at the recurrence, the property of overlapping subproblems immediately pops out.</p>
<p class="mce-root">To find a LCS of <em class="calibre19">X</em> and <em class="calibre19">Y</em>, we may need to find the LCS's of <em class="calibre19">X</em> and <em class="calibre19">Y<sub class="calibre40">n-1</sub></em> and <em class="calibre19">X<sub class="calibre40">m-1</sub></em> and <em class="calibre19">Y</em>, but each of these have the problem of finding the LCS of <em class="calibre19">X<sub class="calibre40">m-1</sub></em> and <em class="calibre19">Y<sub class="calibre40">n-1</sub></em>. Many other subproblems share sub-subproblems.</p>
<p class="mce-root">Using this recurrence, in a bottom-up fashion (where we have solutions for subproblems readily computed), we can produce the following dynamic programming algorithm to compute the length of the longest common subsequence of two strings:</p>
<pre class="calibre20">public int length(String x, String y) {<br class="calibre2"/>  int m = x.length();<br class="calibre2"/>  int n = y.length();<br class="calibre2"/>  int[][] c = new int[m + 1][n + 1];<br class="calibre2"/>  for (int i = 1; i &lt;= m; i++) {<br class="calibre2"/>    for (int j = 1; j &lt;= n; j++) {<br class="calibre2"/>      if (x.charAt(i - 1) == y.charAt(j - 1))<br class="calibre2"/>        c[i][j] = c[i - 1][j - 1] + 1;<br class="calibre2"/>      else<br class="calibre2"/>        c[i][j] = Math.max(c[i - 1][j], c[i][j - 1]);<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  return c[m][n];<br class="calibre2"/>}</pre>
<p class="mce-root"/>
<div class="packt_figref"><span class="calibre10">Snippet 4.9: Computing the length of the longest common subsequence of two Strings using dynamic programming algorithm. Source class name:</span> <span class="calibre10">LongestCommonSubsequence</span></div>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/4TdNVQ" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/4TdNVQ</a> to access this code.</div>
<p class="mce-root">It is possible to also compute the longest common subsequence, and not only the length of it if we keep track of the <strong class="calibre6">direction</strong> we go in the <em class="calibre19">c</em> matrix on each step (either up or left), taking into account that we only add a new character to the optimal subsequence when <em class="calibre19">x<sub class="calibre40">i</sub> = y<sub class="calibre40">j</sub></em>.</p>
<p class="mce-root">We don't cover the solution to this problem in this book. If you are interested in it, the Wikipedia page for the LCS problem has a detailed walkthrough on the implementation of it: <a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://en.wikipedia.org/wiki/Longest_common_subsequence_problem</a>.<span class="calibre14"><br class="calibre7"/></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: The Coin Change Problem</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6">Scenario</strong></p>
<p class="mce-root">In this activity, we will be building a dynamic programming algorithm to solve the coin change problem. Given a value, <em class="calibre19">N</em>, if we want to split it into coins, and we have an infinite supply of each of <em class="calibre19">S={S<sub class="calibre40">1</sub>, S<sub class="calibre40">2</sub>, …, S<sub class="calibre40">m</sub>}</em> valued coins, in how many ways can we do it? The order of the coins doesn't matter. For <em class="calibre19">N = 4</em> and <em class="calibre19">S = {1, 2, 3}</em>, there are four solutions: <em class="calibre19">{1, 1, 1, 1}</em>, <em class="calibre19">{1, 1, 2}</em>, <em class="calibre19">{2, 2}</em>, and <em class="calibre19">{1, 3}</em>, so the result should be four.</p>
<p class="mce-root"><strong class="calibre6">Aim</strong></p>
<p class="mce-root">To solve the coin change problem as described previously using a dynamic programming algorithm.</p>
<p class="mce-root"><strong class="calibre6">Prerequisites</strong></p>
<p class="mce-root">You need to implement the <kbd class="calibre15">ways()</kbd> method of the <kbd class="calibre15">CoinChange</kbd> class, which returns the number of ways to produce a given change for amount <em class="calibre19">N</em>, given a set of coins. It is available on the following path:</p>
<p class="mce-root"><a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/coinchange/CoinChange.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/coinchange/CoinChange.java</a>.</p>
<div class="packt_infobox"><br class="calibre2"/>
The source code comes with a test suite for this class, so to verify that your solution is correct, run <kbd class="calibre31">./gradlew test</kbd> in the command line.</div>
<p class="mce-root"><strong class="calibre6">Steps for Completion</strong></p>
<ol class="calibre17">
<li class="chapter">When going through a coin <em class="calibre21">S<sub class="calibre40">m</sub></em>, in order to count the number of solutions, we can divide the solution into two sets:
<ul class="calibre12">
<li class="calibre37">Those that do not contain any coin <em class="calibre21">S<sub class="calibre40">m</sub></em></li>
<li class="calibre37">Those that contain at least one <em class="calibre21">S<sub class="calibre40">m</sub></em></li>
</ul>
</li>
<li class="chapter">If <em class="calibre21">w[i][j]</em> counts the number of ways to make change for <em class="calibre21">i</em> using coins up to <em class="calibre21">S<sub class="calibre40">j</sub></em>, then we have the following recursion:</li>
</ol>
<div class="cdpaligncenter1"><img class="fm-editor-equation9" src="Images/257e69cc-0b87-4387-878c-347011e03777.png" width="1900" height="337"/></div>
<p class="mce-root">In this third and final section, we introduced the dynamic programming paradigm of algorithm design, using the <em class="calibre19">0-1</em> knapsack and the longest common subsequence problems as examples. We introduced the two properties a problem must observe to be optimally solved by a dynamic programming algorithm: optimal substructure and overlapping subproblems, and showed the students how to identify these properties. We've also seen the differences between a top-down (with memoization) and a bottom-up approach in dynamic programming algorithms.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we have discussed three different algorithm design paradigms. We've seen example problems for all of them and discussed how we can identify whether problems may be solvable by one of the given paradigms. In the next chapter, we will be focusing on some string matching algorithms that use the paradigms introduced here.</p>


            </article>

            
        </section>
    </div>



  </body></html>