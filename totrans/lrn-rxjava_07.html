<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Switching, Throttling, Windowing, and Buffering</h1>
                </header>
            
            <article>
                
<p>It is not uncommon to run into situations where an <kbd>Observable</kbd> is producing emissions faster than an <kbd>Observer</kbd> can consume them. This happens particularly when you introduce concurrency, and the <kbd>Observable</kbd> chain has different operators running on different Schedulers. Whether it is one operator struggling to keep up with a preceding one, or the final <kbd>Observer</kbd> struggling to keep up with emissions from the upstream, bottlenecks can occur where emissions start to queue up behind slow operations.</p>
<p>Of course, the ideal way to handle bottlenecks is to leverage backpressure using Flowable instead of <kbd>Observable</kbd>.The <kbd>Flowable</kbd> is not much different than the <kbd>Observable</kbd> other than that it tells the source to slow down by having the <kbd>Observer</kbd> request emissions at its own pace, as we will learn about it in <em><a href="14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml">Chapter 8</a>, Flowables and Backpressure</em>. But not every source of emissions can be backpressured. You cannot instruct <kbd>Observable.interval()</kbd> (or even <kbd>Flowable.interval()</kbd>) to slow down because the emissions are logically time-sensitive. Asking it to slow down would make those time-based emissions inaccurate. User input events, such as button clicks, logically cannot be backpressured either because you cannot programmatically control the user.</p>
<p>Thankfully, there are some operators that help cope with rapidly firing sources without using backpressure and are especially appropriate for situations where backpressure cannot be utilized. Some of these operators batch up emissions into chunks that are more easily consumed downstream. Others simply sample emissions while ignoring the rest. There is even a powerful <kbd>switchMap()</kbd> operator that functions similarly to <kbd>flatMap()</kbd> but will only subscribe to the <kbd>Observable</kbd> derived from the latest emission and dispose of any previous ones.</p>
<p>We will cover all of these topics in this chapter:</p>
<ul>
<li>Buffering</li>
<li>Windowing</li>
<li>Throttling</li>
<li>Switching</li>
</ul>
<p>We will also end the chapter with an exercise that groups up keystrokes to emit strings of user inputs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Buffering</h1>
                </header>
            
            <article>
                
<p>The <kbd>buffer()</kbd> operator will gather emissions within a certain scope and emit each batch as a list or another collection type. The scope can be defined by a fixed buffer sizing or a timing window that cuts off at intervals or even slices by the emissions of another <kbd>Observable</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fixed-size buffering</h1>
                </header>
            
            <article>
                
<p>The simplest overload for <kbd>buffer()</kbd> accepts a <kbd>count</kbd> argument that batches emissions in that fixed size. If we wanted to batch up emissions into lists of eight elements, we can do that as follows:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/><br/>public class Launcher {    <br/>public static void main(String[] args) {<br/>     Observable.range(1,50)<br/>               .buffer(8)<br/>               .subscribe(System.out::println);<br/>   }<br/>}</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">[1, 2, 3, 4, 5, 6, 7, 8]<br/>[9, 10, 11, 12, 13, 14, 15, 16]<br/>[17, 18, 19, 20, 21, 22, 23, 24]<br/>[25, 26, 27, 28, 29, 30, 31, 32]<br/>[33, 34, 35, 36, 37, 38, 39, 40]<br/>[41, 42, 43, 44, 45, 46, 47, 48]<br/>[49, 50]</pre>
<p>Of course, if the number of emissions does not cleanly divide, the remaining elements will be emitted in a final list even if it is less than the specified count. This is why the last emission in the preceding code has a list of two elements (not eight), containing only <kbd>49</kbd> and <kbd>50</kbd>.</p>
<p>You can also supply a second <kbd>bufferSupplier</kbd> lambda argument to put items in another collection besides a list, such as <kbd>HashSet</kbd>, as demonstrated here (this should yield the same output):</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.HashSet;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable.range(1,50)<br/>                  .buffer(8, HashSet::new)<br/>                  .subscribe(System.out::println);<br/>    }<br/>}</pre>
<p>To make things more interesting, you can also provide a <kbd>skip</kbd> argument that specifies how many items should be skipped before starting a new buffer. If <kbd>skip</kbd> is equal to <kbd>count</kbd>, the <kbd>skip</kbd> has no effect. But if they are different, you can get some interesting behaviors. For instance, you can buffer <kbd>2</kbd> emissions but skip <kbd>3</kbd> before the next buffer starts, as shown here. This will essentially cause every third element to not be buffered:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable.range(1,10)<br/>                  .buffer(2, 3)<br/>                  .subscribe(System.out::println);<br/>    }<br/>}</pre>
<p>The output is as follows:</p>
<p> </p>
<pre style="padding-left: 60px">[1, 2]<br/>[4, 5]<br/>[7, 8]<br/>[10]</pre>
<p> </p>
<p>If you make <kbd>skip</kbd> less than <kbd>count</kbd>, you can get some interesting rolling buffers. If you buffer items into a size of <kbd>3</kbd> but have <kbd>skip</kbd> of <kbd>1</kbd>, you will get rolling buffers. In the following code, for instance, we emit the numbers <kbd>1</kbd> through <kbd>10</kbd> but create buffers <kbd>[1, 2, 3]</kbd>, then <kbd>[2, 3, 4]</kbd>, then <kbd>[3, 4, 5]</kbd>, and so on:</p>
<p> </p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable.range(1,10)<br/>                  .buffer(3, 1)<br/>                  .subscribe(System.out::println);<br/>    }<br/>}</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">[1, 2, 3]<br/>[2, 3, 4]<br/>[3, 4, 5]<br/>[4, 5, 6]<br/>[5, 6, 7]<br/>[6, 7, 8]<br/>[7, 8, 9]<br/>[8, 9, 10]<br/>[9, 10]<br/>[10]</pre>
<p>Definitely play with the <kbd>skip</kbd> argument for <kbd>buffer()</kbd> , and you may find surprising use cases for it. For example, I sometimes use <kbd>buffer(2,1)</kbd> to emit the "previous" emission and the next emission together, as shown here. I also use <kbd>filter()</kbd> to omit the last list , which only contains <kbd>10</kbd>:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable.range(1,10)<br/>                .buffer(2, 1)<br/>                .filter(c -&gt; c.size() == 2)<br/>                .subscribe(System.out::println);<br/>    }<br/>}</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">[1, 2]<br/>[2, 3]<br/>[3, 4]<br/>[4, 5]<br/>[5, 6]<br/>[6, 7]<br/>[7, 8]<br/>[8, 9]<br/>[9, 10]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time-based buffering</h1>
                </header>
            
            <article>
                
<p>You can use <kbd>buffer()</kbd> at fixed time intervals by providing a long and <kbd>TimeUnit</kbd>. To buffer emissions into a list at 1-second intervals, you can run the following code. Note that we are making the source emit every <kbd>300</kbd> milliseconds, and each resulting buffered list will likely contain three or four emissions due to the one-second interval cut-offs:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.concurrent.TimeUnit;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable.interval(300, TimeUnit.MILLISECONDS)<br/>                  .map(i -&gt; (i + 1) * 300) // map to elapsed time<br/>                  .buffer(1, TimeUnit.SECONDS)<br/>                  .subscribe(System.out::println);<br/>        sleep(4000);<br/>    }<br/>    public static void sleep(int millis) {<br/>        try {<br/>            Thread.sleep(millis);<br/>        } <br/>        catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">[300, 600, 900]<br/>[1200, 1500, 1800]<br/>[2100, 2400, 2700]<br/>[3000, 3300, 3600, 3900]</pre>
<p>There is an option to also specify a <kbd>timeskip</kbd> argument, which is the timer-based counterpart to <kbd>skip</kbd>. It controls the timing of when each buffer starts.</p>
<p>You can also leverage a third <kbd>count</kbd> argument to provide a maximum buffer size. This will result in a buffer emission at each time interval or when <kbd>count</kbd> is reached, whichever happens first. If the <kbd>count</kbd> is reached right before the time window closes, it will result in an empty buffer being emitted.</p>
<p>Here, we buffer emissions every 1 second, but we limit the buffer size to 2:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.concurrent.TimeUnit;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable.interval(300, TimeUnit.MILLISECONDS)<br/>                .map(i -&gt; (i + 1) * 300) // map to elapsed time<br/>                .buffer(1, TimeUnit.SECONDS, 2)<br/>                .subscribe(System.out::println);<br/>        sleep(5000);<br/>    }<br/>    public static void sleep(int millis) {<br/>        try {<br/>            Thread.sleep(millis);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">[300, 600]<br/>[900]<br/>[1200, 1500]<br/>[1800]<br/>[2100, 2400]<br/>[2700]<br/>[3000, 3300]<br/>[3600, 3900]<br/>[]<br/>[4200, 4500]<br/>[4800]</pre>
<p>Note that time-based <kbd>buffer()</kbd> operators will operate on the computation <kbd>Scheduler</kbd> . This makes sense since a separate thread needs to run on a timer to execute the cutoffs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Boundary-based buffering</h1>
                </header>
            
            <article>
                
<p>The most powerful variance of <kbd>buffer()</kbd> is accepting another <kbd>Observable</kbd> as a <kbd>boundary</kbd> argument. It does not matter what type this other <kbd>Observable</kbd> emits. All that matters is every time it emits something, it will use the timing of that emission as the buffer cut-off. In other words, the arbitrary occurrence of emissions of another <kbd>Observable</kbd> will determine when to "slice" each buffer.</p>
<p>For example, we can perform our previous example with 300-millisecond emissions buffered every 1-second using this technique. We can have <kbd>Observable.interval()</kbd> of 1 second serve as the boundary for our <kbd>Observable.interval()</kbd>emitting every 300 milliseconds:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.concurrent.TimeUnit;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable&lt;Long&gt; cutOffs =<br/>                Observable.interval(1, TimeUnit.SECONDS);<br/>        Observable.interval(300, TimeUnit.MILLISECONDS)<br/>            .map(i -&gt; (i + 1) * 300) // map to elapsed time<br/>            .buffer(cutOffs)<br/>            .subscribe(System.out::println);<br/>        sleep(5000);<br/>    }<br/>    public static void sleep(int millis) {<br/>        try {<br/>            Thread.sleep(millis);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">[300, 600, 900]<br/>[1200, 1500, 1800]<br/>[2100, 2400, 2700]<br/>[3000, 3300, 3600, 3900]<br/>[4200, 4500, 4800]</pre>
<p>This is probably the most flexible way to buffer items based on highly variable events. While the timing of each slicing is consistent in the preceding example (which is every 1 second), the <kbd>boundary</kbd> can be any <kbd>Observable</kbd> representing any kind of event happening at any time. This idea of an <kbd>Observable</kbd> serving as a cut-off for another <kbd>Observable</kbd> is a powerful pattern we will see throughout this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windowing</h1>
                </header>
            
            <article>
                
<p>The <kbd>window()</kbd> operators are almost identical to <kbd>buffer()</kbd>, except that they buffer into other Observables rather than collections. This results in an <kbd>Observable&lt;Observable&lt;T&gt;&gt;</kbd><span> </span>that emits Observables. Each <kbd>Observable</kbd> emission will cache emissions for each scope and then flush them once subscribed (much like the <kbd>GroupedObservable</kbd> from <kbd>groupBy()</kbd>, which we worked with in <em><a href="d19b22f4-bb94-4f52-99ab-d03b962d4d16.xhtml">Chapter 4</a>, Combining Observables</em>). This allows emissions to be worked with immediately as they become available rather than waiting for each list or collection to be finalized and emitted. The <kbd>window()</kbd> operator is also convenient to work with if you want to use operators to transform each batch.</p>
<p>Just like <kbd>buffer()</kbd>, you can cut-off each batch using fixed sizing, a time interval, or a boundary from another <kbd>Observable</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fixed-size windowing</h1>
                </header>
            
            <article>
                
<p>Let's modify our earlier example, where we buffered 50 integers into lists of size 8, but we will use <kbd>window()</kbd> to buffer them as Observables instead. We can reactively transform each batch into something else besides a collection, such as concatenating emissions into strings with pipe "<kbd>|</kbd>" separators:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable.range(1,50)<br/>                  .window(8)<br/>                  .flatMapSingle(obs -&gt; obs.reduce("", (total, next) -&gt; total<br/>                        + (total.equals("") ? "" : "|") + next))<br/>                  .subscribe(System.out::println);<br/>    }<br/>}</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">1|2|3|4|5|6|7|8<br/>9|10|11|12|13|14|15|16<br/>17|18|19|20|21|22|23|24<br/>25|26|27|28|29|30|31|32<br/>33|34|35|36|37|38|39|40<br/>41|42|43|44|45|46|47|48<br/>49|50</pre>
<p>Just like <kbd>buffer()</kbd>, you can also provide a <kbd>skip</kbd> argument. This is how many emissions need to be skipped before starting a new window. Here, our window size is 2, but we skip three items. We then take each windowed <kbd>Observable</kbd> and reduce it to a <kbd>String</kbd> concatenation:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable.range(1,50)<br/>                  .window(2, 3)<br/>                  .flatMapSingle(obs -&gt; obs.reduce("", (total, next) -&gt; total<br/>                        + (total.equals("") ? "" : "|") + next))<br/>                  .subscribe(System.out::println);<br/>    }<br/>}</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">1|2<br/>4|5<br/>7|8<br/>10|11<br/>13|14<br/>16|17<br/>19|20<br/>22|23<br/>25|26<br/>28|29<br/>31|32<br/>34|35<br/>37|38<br/>40|41<br/>43|44<br/>46|47<br/>49|50</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time-based windowing</h1>
                </header>
            
            <article>
                
<p>As you might be able to guess, you can cut-off windowed Observables at time intervals just like <kbd>buffer()</kbd>. Here, we have an <kbd>Observable</kbd> emitting every 300 milliseconds like earlier, and we are slicing it into separate Observables every 1 second. We will then use <kbd>flatMapSingle()</kbd> on each <kbd>Observable</kbd> to a <kbd>String</kbd> concatenation of the emissions:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.concurrent.TimeUnit;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable.interval(300, TimeUnit.MILLISECONDS)<br/>                  .map(i -&gt; (i + 1) * 300) // map to elapsed time<br/>                  .window(1, TimeUnit.SECONDS)   <br/>                  .flatMapSingle(obs -&gt; obs.reduce("", (total, next) -&gt; total<br/>                        + (total.equals("") ? "" : "|") + next))<br/>                  .subscribe(System.out::println);<br/>        sleep(5000);<br/>    }<br/>    public static void sleep(int millis) {<br/>        try {<br/>            Thread.sleep(millis);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>       }<br/>    }<br/>}</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">300|600|900<br/>1200|1500|1800<br/>2100|2400|2700<br/>3000|3300|3600|3900<br/>4200|4500|4800</pre>
<p>Of course, you can use these yielded Observables for other transformations besides <kbd>String</kbd> concatenations. You can use all the operators we learned up to this point to perform different operations on each windowed <kbd>Observable</kbd>, and you will likely do that work in <kbd>flatMap()</kbd>, <kbd>concatMap()</kbd>, or <kbd>switchMap()</kbd>.</p>
<p>With time-based <kbd>window()</kbd> operators, you can also specify <kbd>count</kbd> or <kbd>timeshift</kbd> arguments, just like its <kbd>buffer()</kbd> counterpart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Boundary-based windowing</h1>
                </header>
            
            <article>
                
<p>It probably is no surprise that since <kbd>window()</kbd> is similar to <kbd>buffer()</kbd> (other than that it emits Observables instead of connections), you can also use another <kbd>Observable</kbd> as <kbd>boundary</kbd>.</p>
<p>Here, we use an <kbd>Observable.interval()</kbd> emitting every 1 second to serve as the <kbd>boundary</kbd> on an <kbd>Observable</kbd> emitting every 300 milliseconds. We leverage each emitted <kbd>Observable</kbd> to concatenate emissions into concatenated strings:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.concurrent.TimeUnit;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable&lt;Long&gt; cutOffs =<br/>                Observable.interval(1, TimeUnit.SECONDS);<br/>        Observable.interval(300, TimeUnit.MILLISECONDS)<br/>            .map(i -&gt; (i + 1) * 300) // map to elapsed time<br/>            .window(cutOffs)<br/>            .flatMapSingle(obs -&gt; obs.reduce("", (total, next) -&gt; total<br/>                + (total.equals("") ? "" : "|") + next))<br/>            .subscribe(System.out::println);<br/>        sleep(5000);<br/>    }<br/>    public static void sleep(int millis) {<br/>        try {<br/>            Thread.sleep(millis);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">300|600|900<br/>1200|1500|1800<br/>2100|2400|2700<br/>3000|3300|3600|3900<br/>4200|4500|4800</pre>
<p>Again, the benefit of using another <kbd>Observable</kbd> as a <kbd>boundary</kbd> is that it allows you to use the arbitrary timing of emissions from any <kbd>Observable</kbd> to cut-off each window, whether it is a button click, a web request, or any other event. This makes it the most flexible way to slice <kbd>window()</kbd> or <kbd>buffer()</kbd> operations when variability is involved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Throttling</h1>
                </header>
            
            <article>
                
<p>The <kbd>buffer()</kbd> and <kbd>window()</kbd> operators batch up emissions into collections or Observables based on a defined scope, which regularly consolidates rather than omits emissions.The <kbd>throttle()</kbd> operator, however, omits emissions when they occur rapidly. This is helpful when rapid emissions are assumed to be redundant or unwanted, such as a user clicking on a button repeatedly. For these situations, you can use the <kbd>throttleLast()</kbd>, <kbd>throttleFirst()</kbd>, and <kbd>throttleWithTimeout()</kbd> operators to only let the first or last element in a rapid sequence of emissions through. How you choose one of the many rapid emissions is determined by your choice of operator, parameters, and arguments.</p>
<p>For the examples in this section, we are going to work with this case: we have three <kbd>Observable.interval()</kbd> sources, the first emitting every 100 milliseconds, the second every 300 milliseconds, and the third every 2000 milliseconds. We only take 10 emissions from the first source, three from the second, and two from the third. As you can see here, we will use <kbd>Observable.concat()</kbd> on them together in order to create a rapid sequence that changes pace at three different intervals:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.concurrent.TimeUnit;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable&lt;String&gt; source1 = Observable.interval(100, TimeUnit.MILLISECONDS)<br/>                .map(i -&gt; (i + 1) * 100) // map to elapsed time<br/>                .map(i -&gt; "SOURCE 1: " + i)<br/>                .take(10);<br/>        Observable&lt;String&gt; source2 = Observable.interval(300, TimeUnit.MILLISECONDS)<br/>                .map(i -&gt; (i + 1) * 300) // map to elapsed time<br/>                .map(i -&gt; "SOURCE 2: " + i)<br/>                .take(3);<br/>        Observable&lt;String&gt; source3 = Observable.interval(2000, TimeUnit.MILLISECONDS)<br/>                .map(i -&gt; (i + 1) * 2000) // map to elapsed time<br/>                .map(i -&gt; "SOURCE 3: " + i)<br/>                .take(2);<br/>        Observable.concat(source1, source2, source3)<br/>                .subscribe(System.out::println);<br/>        sleep(6000);<br/>    }<br/>    public static void sleep(int millis) {<br/>        try {<br/>            Thread.sleep(millis);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">SOURCE 1: 100<br/>SOURCE 1: 200<br/>SOURCE 1: 300<br/>SOURCE 1: 400<br/>SOURCE 1: 500<br/>SOURCE 1: 600<br/>SOURCE 1: 700<br/>SOURCE 1: 800<br/>SOURCE 1: 900<br/>SOURCE 1: 1000<br/>SOURCE 2: 300<br/>SOURCE 2: 600<br/>SOURCE 2: 900<br/>SOURCE 3: 2000<br/>SOURCE 3: 4000</pre>
<p>The first source rapidly pushes 10 emissions within a second, the second pushes three within a second, and the third pushes two within four seconds. Let's use some <kbd>throttle()</kbd> operators to only choose a few of these emissions and ignore the rest.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">throttleLast() / sample()</h1>
                </header>
            
            <article>
                
<p>The <kbd>throttleLast()</kbd> operator (which is aliased as <kbd>sample()</kbd>) will only emit the last item at a fixed time interval. Modify your earlier example to use <kbd>throttleLast()</kbd> at 1-second intervals, as shown here:</p>
<pre style="padding-left: 60px">Observable.concat(source1, source2, source3)<br/>         .throttleLast(1, TimeUnit.SECONDS)<br/>         .subscribe(System.out::println);</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">SOURCE 1: 900<br/>SOURCE 2: 900<br/>SOURCE 3: 2000</pre>
<p>If you study the output, you can see that the last emission at every 1-second interval was all that got through. This effectively samples emissions by dipping into the stream on a timer and pulling out the latest one.</p>
<p>If you want to throttle more liberally at larger time intervals, you will get fewer emissions as this effectively reduces the sample frequency. Here, we use <kbd>throttleLast()</kbd> every two seconds:</p>
<pre style="padding-left: 60px">Observable.concat(source1, source2, source3)<br/>         .throttleLast(2, TimeUnit.SECONDS)<br/>         .subscribe(System.out::println);</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">SOURCE 2: 900<br/>SOURCE 3: 2000</pre>
<p>If you want to throttle more aggressively at shorter time intervals, you will get more emissions, as this increases the sample frequency. Here, we use <kbd>throttleLast()</kbd> every 500 milliseconds:</p>
<pre style="padding-left: 60px">Observable.concat(source1, source2, source3)<br/>          .throttleLast(500, TimeUnit.MILLISECONDS)<br/>          .subscribe(System.out::println);</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">SOURCE 1: 400<br/>SOURCE 1: 900<br/>SOURCE 2: 300<br/>SOURCE 2: 900<br/>SOURCE 3: 2000</pre>
<p>Again, <kbd>throttleLast()</kbd> will push the last emission at every fixed time interval. Next, we will cover <kbd>throttleFirst()</kbd>, which emits the first item instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">throttleFirst()</h1>
                </header>
            
            <article>
                
<p>The <kbd>throttleFirst()</kbd> operates almost identically to <kbd>throttleLast()</kbd>, but it will emit the <em>first</em> item that occurs at every fixed time interval. If we modify our example to <kbd>throttleFirst()</kbd> every 1 second, we should get an output like this:</p>
<pre style="padding-left: 60px">Observable.concat(source1, source2, source3)<br/>         .throttleFirst(1, TimeUnit.SECONDS)<br/>         .subscribe(System.out::println);</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">SOURCE 1: 100<br/>SOURCE 2: 300<br/>SOURCE 3: 2000<br/>SOURCE 3: 4000</pre>
<p>Effectively, the first emission found after each interval starts is the emission that gets pushed through. The 100 from <kbd>source1</kbd> was the first emission found on the first interval. On the next interval, 300 from <kbd>source2</kbd> was emitted, then 2000, followed by 4000. The 4000 was emitted right on the cusp of the application quitting, hence we got four emissions from <kbd>throttleFirst()</kbd> as opposed to three from <kbd>throttleLast()</kbd>.</p>
<p>Besides the first item being emitted rather than the last at each interval, all the behaviors from <kbd>throttleLast()</kbd> also apply to <kbd>throttleFirst()</kbd>. Specifying shorter intervals will yield more emissions, whereas longer intervals will yield less.</p>
<p>Both <kbd>throttleFirst()</kbd> and <kbd>throttleLast()</kbd> emit on the computation <kbd>Scheduler</kbd>, but you can specify your own <kbd>Scheduler</kbd> as a third argument.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">throttleWithTimeout() / debounce()</h1>
                </header>
            
            <article>
                
<p>If you play with <kbd>throttleFirst()</kbd> and <kbd>throttleLast()</kbd>, you might be dissatisfied with one aspect of their behavior. They are agnostic to the variability of emission frequency, and they simply "dip in" at fixed intervals and pull the first or last emission they find. There is no notion of waiting for a "period of silence" where emissions stop for a moment, and that might be an opportune time to push the last emission that occurred forward.</p>
<p>Think of Hollywood action movies where a protagonist is under heavy gunfire. While bullets are flying, he/she has to take cover and is unable to act. But the moment their attackers stop to reload, there is a period of silence where they have time to react. This is essentially what <kbd>throttleWithTimout()</kbd> does. While emissions are firing rapidly, it will not emit anything until there is a "period of silence", and then it will push the last emission forward.</p>
<p><kbd>throttleWithTimout()</kbd> (also called <kbd>debounce()</kbd>) accepts time interval arguments that specify how long a period of inactivity (which means no emissions are coming from the source) must be before the last emission can be pushed forward. In our earlier example, our three concatenated <kbd>Observable.interval()</kbd> sources are rapidly firing at 100 milliseconds and then 300-millisecond spurts for approximately 2 seconds. But after that, intervals slow down to every 2 seconds. If we wanted to only emit after 1 second of silence, we are not going to emit anything until we hit that third <kbd>Observable.interval()</kbd>, emitting every 2 seconds, as shown here:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.concurrent.TimeUnit;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable&lt;String&gt; source1 = Observable.interval(100, TimeUnit.MILLISECONDS)<br/>                .map(i -&gt; (i + 1) * 100) // map to elapsed time<br/>                .map(i -&gt; "SOURCE 1: " + i)<br/>                .take(10);<br/>        Observable&lt;String&gt; source2 = Observable.interval(300, TimeUnit.MILLISECONDS)<br/>                .map(i -&gt; (i + 1) * 300) // map to elapsed time<br/>                .map(i -&gt; "SOURCE 2: " + i)<br/>                .take(3);<br/>        Observable&lt;String&gt; source3 = Observable.interval(2000, TimeUnit.MILLISECONDS)<br/>                .map(i -&gt; (i + 1) * 2000) // map to elapsed time<br/>                .map(i -&gt; "SOURCE 3: " + i)<br/>                .take(2);<br/>        Observable.concat(source1, source2, source3)<br/>                .throttleWithTimeout(1, TimeUnit.SECONDS)<br/>                .subscribe(System.out::println);<br/>        sleep(6000);<br/>    }<br/>    public static void sleep(int millis) {<br/>        try {<br/>            Thread.sleep(millis);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">SOURCE 2: 900<br/>SOURCE 3: 2000<br/>SOURCE 3: 4000</pre>
<p>The 900 emission from <kbd>source2</kbd> was the last emission as soon as <kbd>source3</kbd> started, since <kbd>source3</kbd> will not push its first emission for 2 seconds, which gave more than the needed 1-second period of silence for the 900 emission to be fired. The 2000 emission then emitted next and 1 second later no further emissions occurred, so it was pushed forward by <kbd>throttleWithTimeout()</kbd>. Another second later, the 4000 emission was pushed and the 2-second silence (before the program exited) allowed it to fire as well.</p>
<p>The <kbd>throttleWithTimeout()</kbd> is an effective way to handle excessive inputs (such as a user clicking on a button rapidly) and other noisy, redundant events that sporadically speed up, slow down, or cease. The only disadvantage of <kbd>throttleWithTimeout()</kbd> is that it will delay each winning emission. If an emission does make it through <kbd>throttleWithTimeout()</kbd>, it will be delayed by the specified time interval in order to ensure no more emissions are coming. Especially for user experiences, this artificial delay may be unwelcome. For these situations, which are sensitive to delays, a better option might be to leverage <kbd>switchMap()</kbd>, which we will cover next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Switching</h1>
                </header>
            
            <article>
                
<p>In RxJava, there is a powerful operator called <kbd>switchMap()</kbd>. Its usage feels like <kbd>flatMap()</kbd>, but it has one important behavioral difference: it will emit from the latest <kbd>Observable</kbd> derived from the latest emission and dispose of any previous Observables that were processing. In other words, it allows you to cancel an emitting <kbd>Observable</kbd> and switch to a new one, preventing stale or redundant processing.</p>
<p>Say we have a process that emits nine strings, and it delays each string emission randomly from 0 to 2000 milliseconds. This is to emulate an intense calculation done to each one, as demonstrated here:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.concurrent.ThreadLocalRandom;<br/>import java.util.concurrent.TimeUnit;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>       Observable&lt;String&gt; items = Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon",<br/>                        "Zeta", "Eta", "Theta", "Iota");<br/>       //delay each String to emulate an intense calculation<br/>        Observable&lt;String&gt; processStrings = items.concatMap(s -&gt;<br/>                Observable.just(s)<br/>                        .delay(randomSleepTime(), TimeUnit.MILLISECONDS)<br/>        );<br/>        processStrings.subscribe(System.out::println);<br/>        //keep application alive for 20 seconds<br/>        sleep(20000);<br/>    }<br/>    public static int randomSleepTime() {<br/>        //returns random sleep time between 0 to 2000 milliseconds<br/>        return ThreadLocalRandom.current().nextInt(2000);<br/>    }<br/>    public static void sleep(int millis) {<br/>        try {<br/>            Thread.sleep(millis);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Alpha<br/>Beta<br/>Gamma<br/>Delta<br/>Epsilon<br/>Zeta<br/>Eta<br/>Theta<br/>Iota</pre>
<p>As you can tell, each emission takes between 0-2 seconds to be emitted, and processing all the strings can take up to 20 seconds.</p>
<p>Say we want to run this process every 5 seconds, but we want to cancel (or more technically, <kbd>dispose()</kbd>) previous instances of the process and only run the latest one. This is easy to do with <kbd>switchMap()</kbd>. Here, we create another <kbd>Observable.interval()</kbd>, emitting every 5 seconds and then we use <kbd>switchMap()</kbd> on it to the <kbd>Observable</kbd> we want to process (which in this case is <kbd>processStrings</kbd>). Every 5 seconds, the emission going into <kbd>switchMap()</kbd> will promptly dispose of the currently processing <kbd>Observable</kbd> (if there are any) and then emit from the new <kbd>Observable</kbd> it maps to. To prove that <kbd>dispose()</kbd> is being called, we will put <kbd>doOnDispose()</kbd> on the <kbd>Observable</kbd> inside <kbd>switchMap()</kbd> to display a message:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import java.util.concurrent.ThreadLocalRandom;<br/>import java.util.concurrent.TimeUnit;<br/>public class Launcher {<br/>    public static void main(String[] args) {<br/>        Observable&lt;String&gt; items = Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon",<br/>                "Zeta", "Eta", "Theta", "Iota");<br/>        //delay each String to emulate an intense calculation<br/>        Observable&lt;String&gt; processStrings = items.concatMap(s -&gt;<br/>                Observable.just(s)<br/>                        .delay(randomSleepTime(), TimeUnit.MILLISECONDS)<br/>        );<br/>        //run processStrings every 5 seconds, and kill each previous instance to start next<br/>        Observable.interval(5, TimeUnit.SECONDS)<br/>                .switchMap(i -&gt;<br/>                        processStrings<br/>                                .doOnDispose(() -&gt; System.out.println("Disposing! Starting next"))<br/>                ).subscribe(System.out::println);<br/>        //keep application alive for 20 seconds<br/>        sleep(20000);<br/>    }<br/>    public static int randomSleepTime() {<br/>        //returns random sleep time between 0 to 2000 milliseconds<br/>        return ThreadLocalRandom.current().nextInt(2000);<br/>    }<br/>    public static void sleep(int millis) {<br/>        try {<br/>            Thread.sleep(millis);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</pre>
<p><span>The output is as follows </span>(yours will be different):</p>
<pre style="padding-left: 60px">Alpha<br/>Beta<br/>Gamma<br/>Delta<br/>Epsilon<br/>Zeta<br/>Eta<br/>Disposing! Starting next<br/>Alpha<br/>Beta<br/>Gamma<br/>Delta<br/>Disposing! Starting next<br/>Alpha<br/>Beta<br/>Gamma<br/>Delta<br/>Disposing! Starting next</pre>
<p>Again, <kbd>switchMap()</kbd> is just like <kbd>flatMap()</kbd> except that it will cancel any previous Observables that were processing and only chase after the latest one. This can be helpful in many situations to prevent redundant or stale work and is especially effective in user interfaces where rapid user inputs create stale requests. You can use it to cancel database queries, web requests, and other expensive tasks and replace it with a new task.</p>
<p> For <kbd>switchMap()</kbd> to work effectively, the thread pushing emissions into <kbd>switchMap()</kbd> cannot be occupied doing the work inside <kbd>switchMap()</kbd>. This means that you may have to use <kbd>observeOn()</kbd> or <kbd>subscribeOn()</kbd> inside <kbd>switchMap()</kbd> to do work on a different thread. If the operations inside <kbd>switchMap()</kbd> are expensive to stop (for instance, a database query using RxJava-JDBC), you might want to use <kbd>unsubscribeOn()</kbd> as well to keep the triggering thread from becoming occupied with disposal.</p>
<p>A neat trick you can do to cancel work within <kbd>switchMap()</kbd> (without providing new work immediately) is to conditionally yield <kbd>Observable.empty()</kbd>. This can be helpful to cancel a long-running or infinite process. For example, if you bring in  RxJavaFX (<a href="https://github.com/ReactiveX/RxJavaFX">https://github.com/ReactiveX/RxJavaFX</a>) as a dependency, we can quickly create a stop watch application using <kbd>switchMap()</kbd>, as shown in the following code snippet:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import io.reactivex.rxjavafx.observables.JavaFxObservable;<br/>import io.reactivex.rxjavafx.schedulers.JavaFxScheduler;<br/>import javafx.application.Application;<br/>import javafx.scene.Scene;<br/>import javafx.scene.control.Label;<br/>import javafx.scene.control.ToggleButton;<br/>import javafx.scene.layout.VBox;<br/>import javafx.stage.Stage;<br/>import java.util.concurrent.TimeUnit;<br/>public final class JavaFxApp extends Application {<br/>    @Override<br/>    public void start(Stage stage) throws Exception {<br/>        VBox root = new VBox();<br/>        Label counterLabel = new Label("");<br/>        ToggleButton startStopButton = new ToggleButton();<br/>     // Multicast the ToggleButton's true/false selected state<br/>        Observable&lt;Boolean&gt; selectedStates =<br/>JavaFxObservable.valuesOf(startStopButton.selectedProperty())<br/>                        .publish()<br/>                        .autoConnect(2);<br/>     // Using switchMap() with ToggleButton's selected state will drive<br/>     // whether to kick off an Observable.interval(),<br/>     // or dispose() it by switching to empty Observable<br/>        selectedStates.switchMap(selected -&gt; {<br/>                    if (selected)<br/>                        return Observable.interval(1, TimeUnit.MILLISECONDS);<br/>                    else<br/>                        return Observable.empty();<br/>                }).observeOn(JavaFxScheduler.platform()) // Observe on JavaFX UI thread<br/>                .map(Object::toString)<br/>                .subscribe(counterLabel::setText);<br/>        // Change ToggleButton's text depending on its state<br/>        selectedStates.subscribe(selected -&gt;<br/>                startStopButton.setText(selected ? "STOP" : "START")<br/>        );<br/>        root.getChildren().addAll(counterLabel, startStopButton);<br/>        stage.setScene(new Scene(root));<br/>        stage.show();<br/>    }<br/>}</pre>
<p> The code preceding yields  a stopwatch application that uses <kbd>switchMap()</kbd> , as shown below in Figure 7.1:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e7a2a8e1-573d-4e78-9fc6-a798cfea939b.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 7.1 - A stopwatch application that uses switchMap()</div>
<p>Pressing the <kbd>ToggleButton</kbd> will start and stop the stopwatch, which displays in milliseconds. Note that the <kbd>ToggleButton</kbd> will emit a Boolean <kbd>True</kbd>/<kbd>False</kbd> value through an <kbd>Observable</kbd> called <kbd>selectedStates</kbd>. We multicast it to prevent duplicate listeners on JavaFX, and we have two Observers. The first will use <kbd>switchMap()</kbd> on each Boolean value, where <kbd>true</kbd> will emit from an <kbd>Observable.interval()</kbd> every millisecond, and <kbd>false</kbd> will cancel it by replacing it with an <kbd>Observable.empty()</kbd>. Since <kbd>Observable.interval()</kbd> will emit on a <kbd>Scheduler</kbd> computation, we will use <kbd>observeOn()</kbd> to put it back on the JavaFX <kbd>Scheduler</kbd> provided by RxJavaFX. The other <kbd>Observer</kbd> will change the text of the <kbd>ToggleButton</kbd> to STOP or START depending on its state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grouping keystrokes</h1>
                </header>
            
            <article>
                
<p>We will wrap up this chapter by integrating most of what we learned and achieve a complex task: grouping keystrokes that happen in rapid succession to form strings without any delay! It can be helpful in user interfaces to immediately "jump" to items in a list based on what is being typed or perform auto-completion in some way. This can be a challenging task, but as we will see, it is not that difficult with RxJava.</p>
<p>This exercise will use JavaFX again with RxJavaFX. Our user interface will simply have a <kbd>Label</kbd> that receives rolling concatenations of keys we are typing. But after 300 milliseconds, it will reset and receive an empty  <kbd>""</kbd> to clear it. Here is the code that achieves this as well as some screenshots with the console output when I type "<kbd>Hello</kbd>" and then type "<kbd>World</kbd>" a moment later:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/>import io.reactivex.rxjavafx.observables.JavaFxObservable;<br/>import io.reactivex.rxjavafx.schedulers.JavaFxScheduler;<br/>import javafx.application.Application;<br/>import javafx.scene.Scene;<br/>import javafx.scene.control.Label;<br/>import javafx.scene.input.KeyEvent;<br/>import javafx.scene.layout.VBox;<br/>import javafx.stage.Stage;<br/>import java.util.concurrent.TimeUnit;<br/>public final class JavaFxApp extends Application {<br/>    @Override<br/>    public void start(Stage stage) throws Exception {<br/>        VBox root = new VBox();<br/>        root.setMinSize(200, 100);<br/>        Label typedTextLabel = new Label("");<br/>        root.getChildren().addAll(typedTextLabel);<br/>        Scene scene = new Scene(root);<br/>        // Multicast typed keys<br/>        Observable&lt;String&gt; typedLetters =<br/>                JavaFxObservable.eventsOf(scene, KeyEvent.KEY_TYPED)<br/>                    .map(KeyEvent::getCharacter)<br/>                    .share();<br/>        // Signal 300 milliseconds of inactivity<br/>        Observable&lt;String&gt; restSignal =<br/>                typedLetters<br/>                        .throttleWithTimeout(500, TimeUnit.MILLISECONDS)<br/>                        .startWith(""); //trigger initial<br/>        // switchMap() each period of inactivity to<br/>        // an infinite scan() concatenating typed letters<br/>        restSignal.switchMap(s -&gt;<br/>                typedLetters.scan("", (rolling, next) -&gt; rolling + next)<br/>        ).observeOn(JavaFxScheduler.platform())<br/>         .subscribe(s -&gt; {<br/>            typedTextLabel.setText(s);<br/>            System.out.println(s);<br/>         });<br/>        stage.setScene(scene);<br/>        stage.show();<br/>    }<br/>}</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">H<br/>He<br/>Hel<br/>Hell<br/>Hello<br/>W<br/>Wo<br/>Wor<br/>Worl<br/>World</pre>
<p>This is the rendered UI:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/61d41975-4212-48e6-b50f-176d36589673.png"/></div>
<p>When you type keys, the <kbd>Label</kbd> will display a rolling <kbd>String</kbd> concatenation of their characters in live time on both the UI as well as the console. Note that after 500 milliseconds of no activity, it resets and emits a new <kbd>scan()</kbd> operation and disposes of the old one, starting with an empty <kbd>""</kbd> string. This can be enormously helpful to instantly send search requests or autocomplete suggestions while the user is typing.</p>
<p>The way it works is that we have an <kbd>Observable</kbd> emitting the characters that were pressed on the keyboard, but it is multicast with <kbd>share()</kbd> and used for two purposes. It is first used to create another <kbd>Observable</kbd> that signals the last character typed after 500 milliseconds of inactivity. But we do not care about the character as much as the emission's timing, which signals 500 milliseconds of inactivity has occurred. We then use <kbd>switchMap()</kbd> on it to the <kbd>Observable</kbd> emitting the characters again, and we infinitely concatenate each typed character in succession and emit each resulting string. However, this <kbd>scan()</kbd> operation in <kbd>switchMap()</kbd> will be disposed of when 500 milliseconds of inactivity occurs and start over with a new <kbd>scan()</kbd> instance.</p>
<p>If you find this example dizzying, take your time and keep studying it. It will click ultimately and once it does, you will have truly mastered the ideas in this chapter!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to leverage buffering, windowing, throttling, and switching to cope with rapidly emitting Observables. Ideally, we should leverage Flowables and backpressure when we see that Observables are emitting faster than the Observers can keep up with, which we will learn about in the next chapter. But for situations where backpressure cannot work, such as user inputs or timer events, you can leverage these three categories of operations to limit how many emissions are passed downstream.</p>
<p>In the next chapter, we will learn about backpressuring with Flowables, which provides more proactive ways to cope with common cases of rapid emissions overwhelming Observers.</p>


            </article>

            
        </section>
    </body></html>