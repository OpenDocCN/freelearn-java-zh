<html><head></head><body>
<div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.2.1">Good Coding Habits</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In a book about refactoring, I believe it’s necessary to talk about well-written code. </span><span class="koboSpan" id="kobo.3.2">These are two obviously closely related aspects that almost overlap. </span><span class="koboSpan" id="kobo.3.3">The lack of good code or solid architecture is among the main reasons for refactoring; refactoring is the means through which we aim to improve the writing of a method, a class, a project, or </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">an architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">To understand clearly what we’re talking about, it’s important to try to explain what good code is and, by exclusion, what is considered poorly written code. </span><span class="koboSpan" id="kobo.5.2">It may seem excessive to try to define what good code is because, in reality, it should be – or should be treated as – something quite intuitive. </span><span class="koboSpan" id="kobo.5.3">We should almost have </span><em class="italic"><span class="koboSpan" id="kobo.6.1">spider senses</span></em><span class="koboSpan" id="kobo.7.1"> that tingle when we see code that is hard to understand or overly complicated. </span><span class="koboSpan" id="kobo.7.2">If you don’t have spider senses developed yet, don’t worry! </span><span class="koboSpan" id="kobo.7.3">They will grow with experience (and this book could help you </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">get there).</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Nowadays, good code is often synonymous with </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Clean Code</span></em><span class="koboSpan" id="kobo.11.1">, that is, a collection of informal rules gathered in the book of the same name by Robert C. </span><span class="koboSpan" id="kobo.11.2">Martin (we’re going to speak about Clean Code a lot). </span><span class="koboSpan" id="kobo.11.3">In this chapter, we’ll try to summarize in broad terms what Clean Code means, what its fundamental principles are, and why we should all strive for Clean Code every day of our </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">professional lives.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">Clean Code is often accompanied by and closely related to the so-called SOLID principles, for which the computer science community has shown great inventiveness regarding acronyms. </span><span class="koboSpan" id="kobo.13.2">But they also provide </span><em class="italic"><span class="koboSpan" id="kobo.14.1">solid</span></em><span class="koboSpan" id="kobo.15.1"> (do software developers love dad jokes?) foundations for writing </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">excellent code.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">good code?</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Clean Code</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Write </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">SOLID code</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Side effects </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">and mutability</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Causes of </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">bad code</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.28.1">A small disclaimer</span></p>
<p class="callout"><span class="koboSpan" id="kobo.29.1">I don’t claim to present the ultimate truth about anything. </span><span class="koboSpan" id="kobo.29.2">I know that some of what I’ll write is the subject of debate, and there are plenty of programmers out there ready to question everything (and I say that as a good thing). </span><span class="koboSpan" id="kobo.29.3">The intention is to share what I believe are healthy habits to practice every day, to avoid getting stuck and, most importantly, to find joy in our beautiful craft </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">as artisans.</span></span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.31.1">Characteristics of good code</span></h1>
<p><span class="koboSpan" id="kobo.32.1">Once again, I must disappoint you. </span><span class="koboSpan" id="kobo.32.2">I struggle to find a clear, precise, and universally agreed-upon </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.33.1">definition of what good code is. </span><span class="koboSpan" id="kobo.33.2">It is a highly subjective concept that heavily depends on the context. </span><span class="koboSpan" id="kobo.33.3">Online and in textbooks, you can find numerous definitions that differ slightly from each other. </span><span class="koboSpan" id="kobo.33.4">However, I strongly believe that there are some foundations on which we can all agree. </span><span class="koboSpan" id="kobo.33.5">I will try to summarize the various interpretations of good code and provide some feedback based on my experience, for what </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">it’s worth.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.35.1">Good code is readable</span></h2>
<p><span class="koboSpan" id="kobo.36.1">Obviously, this is the first thing. </span><span class="koboSpan" id="kobo.36.2">Pretty intuitive, right? </span><span class="koboSpan" id="kobo.36.3">Well, yes, but it’s one of the aspects that I’ve </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.37.1">often found to be underestimated. </span><span class="koboSpan" id="kobo.37.2">Sometimes we are so focused on achieving the end result, on delivering a product at all costs, that we forget about what comes after; we forget that – as already mentioned – code must not only speak to machines but also and above all to other programmers. </span><span class="koboSpan" id="kobo.37.3">And those other programmers are also our future selves! </span><span class="koboSpan" id="kobo.37.4">Doing things quickly is not the only reason for which code lacks readability: for instance, sometimes we could have performance issues to handle. </span><span class="koboSpan" id="kobo.37.5">Anyways, if you have other aspects to handle, my small piece of advice is to make sure to at least strike a balance between readability and </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">those aspects.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">To give a definition of readable code, we don’t need to rely on the code itself. </span><span class="koboSpan" id="kobo.39.2">Plain language is enough. </span><span class="koboSpan" id="kobo.39.3">Just imagine for a moment that you’re at your own home and you need to assemble one of those beautiful, satisfying, low-budget Swedish furniture pieces that we have to assemble ourselves, like a wardrobe. </span><span class="koboSpan" id="kobo.39.4">Instead of the crystal-clear visual instructions that we are familiar with, we find a text that says </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the following:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.41.1">Take the white wooden piece with dimensions A x B, which we will now refer to as L. </span><span class="koboSpan" id="kobo.41.2">Take another wooden board with dimensions B x C, which we’ll call M. </span><span class="koboSpan" id="kobo.41.3">Take the tool consisting of a metal rod with a cross-shaped end. </span><span class="koboSpan" id="kobo.41.4">Take a screw that fits into the holes of both L and M; it must be not too short and not too long. </span><span class="koboSpan" id="kobo.41.5">Using the cross-shaped end of the aforementioned tool, rotate the screw clockwise so that they inextricably join, forming a single partial structure that we’ll </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.42.1">call P.</span></em></span></p>
<p><span class="koboSpan" id="kobo.43.1">This text is obviously incomprehensible. </span><span class="koboSpan" id="kobo.43.2">I suffered a lot in writing it. </span><span class="koboSpan" id="kobo.43.3">Don’t fall into the trap of thinking that code is different from prose language. </span><span class="koboSpan" id="kobo.43.4">I mean, of course, it’s different, but in an abstract way, you should consider them as the same thing. </span><span class="koboSpan" id="kobo.43.5">Imagine, when you write code, writing in prose. </span><span class="koboSpan" id="kobo.43.6">You should aim for prose writing, in a way, so that your code </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.44.1">is as readable as possible. </span><span class="koboSpan" id="kobo.44.2">When a piece of code is readable even by someone who knows nothing about the project or has basic programming skills, then you have succeeded. </span><span class="koboSpan" id="kobo.44.3">The excerpt from the previous instruction manual could be rewritten </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">as follows:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.46.1">Take the wooden board labeled “left side” and screw it together with the one labeled “back” using a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.47.1">Phillips screwdriver.</span></em></span></p>
<p><span class="koboSpan" id="kobo.48.1">This excerpt can certainly be further improved. </span><span class="koboSpan" id="kobo.48.2">But the starting point is definitely understandable; it’s understandable to me and it’s understandable to others, and that’s how your code should be. </span><span class="koboSpan" id="kobo.48.3">Readable code is code that can be improved and </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">expanded upon.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.50.1">Good code is reliable</span></h2>
<p><span class="koboSpan" id="kobo.51.1">If I have to think of a definition for “reliable,” it brings to mind a friend of mine who, when they </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.52.1">say they will do something, they do it and only that. </span><span class="koboSpan" id="kobo.52.2">Nothing more, nothing less. </span><span class="koboSpan" id="kobo.52.3">So, think of reliable code as your friend who always agrees to help you in the best possible way—no surprises, as Radiohead used to sing. </span><span class="koboSpan" id="kobo.52.4">I could give you an example of unreliable code not so far from certain things I have encountered in the past. </span><span class="koboSpan" id="kobo.52.5">For instance, imagine you have an entity in your domain represented </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.54.1"><img alt="Table 2.1 – Example entity" src="image/B20912_02_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.55.1">Table 2.1 – Example entity</span></p>
<p><span class="koboSpan" id="kobo.56.1">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">id</span></strong><span class="koboSpan" id="kobo.58.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">taxCode</span></strong><span class="koboSpan" id="kobo.60.1"> are of type String and are unique within the domain. </span><span class="koboSpan" id="kobo.60.2">That means there cannot be two students with the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">id</span></strong><span class="koboSpan" id="kobo.62.1"> or the </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">same </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">taxCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">I also have an </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.67.1">exposed method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">Student</span></strong><span class="koboSpan" id="kobo.69.1"> interface that is written </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.71.1">
public String getUniqueIdentifier();</span></pre> <p><span class="koboSpan" id="kobo.72.1">Apparently, this signature of this method is correct, because it does not expose the internal structure of the object. </span><span class="koboSpan" id="kobo.72.2">But, it could also have been named </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">getId()</span></strong><span class="koboSpan" id="kobo.74.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">getTaxCode()</span></strong><span class="koboSpan" id="kobo.76.1"> and that is </span><em class="italic"><span class="koboSpan" id="kobo.77.1">exactly</span></em><span class="koboSpan" id="kobo.78.1"> the point. </span><span class="koboSpan" id="kobo.78.2">Without looking at the implementation, we don’t know if we will get </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">taxCode</span></strong><span class="koboSpan" id="kobo.80.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">id</span></strong><span class="koboSpan" id="kobo.82.1"> when using it. </span><span class="koboSpan" id="kobo.82.2">When we actually use </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">getUniqueIdentifier()</span></strong><span class="koboSpan" id="kobo.84.1">, we realize that the behavior is variable and depends on the specific implementation. </span><span class="koboSpan" id="kobo.84.2">If we were to use this method within a payment and invoicing system where we specifically need </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">taxCode</span></strong><span class="koboSpan" id="kobo.86.1">, this method would be unreliable. </span><span class="koboSpan" id="kobo.86.2">One possible solution could be to expose two separate getter methods so that we know exactly which information we are reading at that moment. </span><span class="koboSpan" id="kobo.86.3">Alternatively, another solution could be to expose an additional method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">getTaxIdentifier()</span></strong><span class="koboSpan" id="kobo.88.1"> that specifically returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">taxCode</span></strong><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">This way, you would have separate methods providing clear and unambiguous access to each piece of information without exposing the </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">internal structure.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.92.1">Good code is hard to misuse</span></h2>
<p><span class="koboSpan" id="kobo.93.1">To easily </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.94.1">explain the concept of code that cannot be misused, all I have to do is take a look inside my children’s room. </span><span class="koboSpan" id="kobo.94.2">There are toys, sometimes referred to as “Montessori toys,” that involve small wooden objects being inserted into a box with corresponding holes of the right shape for each object. </span><span class="koboSpan" id="kobo.94.3">As can be seen from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.95.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.96.1">.1</span></em><span class="koboSpan" id="kobo.97.1">, it is impossible to fit a cylinder into a square, a cube into a circle, and </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">so on.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.99.1"><img alt="Figure 2.1 – An example of a Montessori toy" src="image/B20912_02_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.100.1">Figure 2.1 – An example of a Montessori toy</span></p>
<p><span class="koboSpan" id="kobo.101.1">The usage is intuitive and provides </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">immediate feedback.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">We need to envision writing the code and designing the components in this way: we expect our </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.104.1">code to perform certain actions, which may have impacts on external systems or a database. </span><span class="koboSpan" id="kobo.104.2">Misusable code could potentially cause significant problems—for instance, it could write incorrect information to a database—or it could simply fail to function properly. </span><span class="koboSpan" id="kobo.104.3">When providing our services, which include our code, libraries, and design, we must put ourselves in the shoes of those who will integrate or </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">utilize them.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">There are several techniques to make your code non-misusable, and it would take – and indeed there are – entire books on the subject. </span><span class="koboSpan" id="kobo.106.2">However, I want to give you a couple of ideas here that can be easily applied even without delving </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">too deep.</span></span></p>
<h3><span class="koboSpan" id="kobo.108.1">Don’t be overly generic</span></h3>
<p><span class="koboSpan" id="kobo.109.1">One “trick” to make your code non-misusable is to avoid overly generic data types whenever possible. </span><span class="koboSpan" id="kobo.109.2">Types like Integer, String, List, and so on, serve as the building blocks for constructing </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.110.1">our programs and are very versatile. </span><span class="koboSpan" id="kobo.110.2">However, the flip side is that they can sometimes be too generic. </span><span class="koboSpan" id="kobo.110.3">Let me give you a couple of examples from my own experience: in a company operating in the travel industry, we deal with a service that returns all available flights based on a user’s search. </span><span class="koboSpan" id="kobo.110.4">As we need to represent the number of adults, children, and infants for whom a solution is being sought, we chose the following solution (for simplicity, let’s omit the handling of null values, possible initializations with default </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">values, etc.):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
private List&lt;Integer&gt; passengers;</span></pre> <p><span class="koboSpan" id="kobo.113.1">So, for example, if we are searching for a flight for 2 adults, 1 child, and 1 infant, the convention would be to populate </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">passengers</span></strong><span class="koboSpan" id="kobo.115.1"> as an array: </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">[2, 1, 1]</span></strong><span class="koboSpan" id="kobo.117.1">. </span><span class="koboSpan" id="kobo.117.2">In my opinion, this choice is very risky. </span><span class="koboSpan" id="kobo.117.3">We could insert fewer values than necessary, for example, just one or two. </span><span class="koboSpan" id="kobo.117.4">We could insert more values. </span><span class="koboSpan" id="kobo.117.5">We could even omit them entirely. </span><span class="koboSpan" id="kobo.117.6">Yes, we could introduce some input validation, but why allow input and then return an error later? </span><span class="koboSpan" id="kobo.117.7">If this were a library, by the way, I would be forced to read the documentation </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.118.1">to understand how to populate that field (there’s nothing wrong with reading documentation, of course, but it should be something that could be more intuitive). </span><span class="koboSpan" id="kobo.118.2">It would be more intuitive instead to divide the information into a more </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">meaningful structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
private Integer adultCount;
private Integer childrenCount;
private Integer infantCount;</span></pre> <p><span class="koboSpan" id="kobo.121.1">Much clearer, </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">isn’t it?</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">We could, in fact, go further and create an ad-hoc structure for our needs, something that cannot lead to confusion. </span><span class="koboSpan" id="kobo.123.2">Something </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
public class Passengers {
   private final Integer adultCount;
   private final Integer childrenCount;
   private final Integer infantCount;
   //constructor(s) and getters...
</span><span class="koboSpan" id="kobo.125.2">}</span></pre> <p><span class="koboSpan" id="kobo.126.1">And that would lead to having a single, </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">understandable field:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
private Passenger passengers;</span></pre> <h3><span class="koboSpan" id="kobo.129.1">Use standards for writing good code</span></h3>
<p><span class="koboSpan" id="kobo.130.1">Another way to make your code non-misusable is to use standards whenever possible. </span><span class="koboSpan" id="kobo.130.2">A couple of examples come to mind, related to handling time. </span><span class="koboSpan" id="kobo.130.3">If you need to represent a date, choose a format, document that you are using it, and consistently use it throughout </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.131.1">your project. </span><span class="koboSpan" id="kobo.131.2">One thing I’ve seen done very often is trying to represent a time period or duration with an Integer or even </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">a String:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.133.1">
private Integer movieDuration = 150; //movie duration in
                                       minutes</span></pre> <p><span class="koboSpan" id="kobo.134.1">Starting from </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">version 8</span></strong><span class="koboSpan" id="kobo.136.1">, Java has introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">Duration</span></strong><span class="koboSpan" id="kobo.138.1"> class, and I highly recommend using it. </span><span class="koboSpan" id="kobo.138.2">It is incredibly versatile and allows you to represent a duration of </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">time unambiguously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
private Duration movieDuration = Duration.of(150,
    ChronoUnit.MINUTES);</span></pre> <p><span class="koboSpan" id="kobo.141.1">Additional cool thing: the preceding duration serializes according to a convenient ISO standard (ISO-8601), such </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">PT2H30M</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">The thing here is simple: don’t reinvent the wheel! </span><span class="koboSpan" id="kobo.145.2">After all, Java is so widespread also because there are a multitude of libraries available, so I suggest, while we are solving common problems, to avoid recreating basic components and instead rely on language features or open source libraries. </span><span class="koboSpan" id="kobo.145.3">One of the first things that I always ask myself is: am I the first one having this issue? </span><span class="koboSpan" id="kobo.145.4">The answer is </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">rarely yes.</span></span></p>
<h3><span class="koboSpan" id="kobo.147.1">Use single sources of truth for data and logic</span></h3>
<p><span class="koboSpan" id="kobo.148.1">Last piece of advice: use a single source of truth for data and a single source of truth for logic. </span><span class="koboSpan" id="kobo.148.2">I must </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.149.1">admit that the concepts </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.150.1">of a single source of truth are often straightforward to explain but less easy </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">to implement.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">Let me try to illustrate what I have in mind with an example. </span><span class="koboSpan" id="kobo.152.2">Once again, let’s imagine managing a flight search system. </span><span class="koboSpan" id="kobo.152.3">Typically, the data can be divided into primary data and derived data. </span><span class="koboSpan" id="kobo.152.4">Primary data is essentially the information without which our system couldn’t function, while derived data refers to all the other information. </span><span class="koboSpan" id="kobo.152.5">In our flight search example, let’s say we need to provide, among other details, the duration of a trip from Milan to San Francisco. </span><span class="koboSpan" id="kobo.152.6">The trip consists of two flights: one from Milan to Copenhagen and another from Copenhagen to San Francisco. </span><span class="koboSpan" id="kobo.152.7">In this example, we can consider the departure and arrival times of each individual flight as primary data. </span><span class="koboSpan" id="kobo.152.8">From these, we can derive information about the duration of the trip and potentially the duration of the layover. </span><span class="koboSpan" id="kobo.152.9">Managing derived data as primary data, for example by storing it in the database, could lead to inconsistencies. </span><span class="koboSpan" id="kobo.152.10">Especially when deriving information from a large volume of data – or when the derivation is complex or involves some external system – the computational cost of such calculations could be high. </span><span class="koboSpan" id="kobo.152.11">I would advise you to </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.153.1">exercise caution and consider implementing a mechanism called </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">lazy calculation</span></strong><span class="koboSpan" id="kobo.155.1">. </span><span class="koboSpan" id="kobo.155.2">Essentially, this approach involves calculating the derived data only when it is needed, rather than in advance, and saving it in a cache so that it is readily available for future use. </span><span class="koboSpan" id="kobo.155.3">In our flight duration example, we would calculate </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.156.1">the journey duration using the flight’s departure and arrival times (we have also to consider the airport locations and their time zones) without storing it in a database, but at most in a short-term </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.157.1">cache or something like that. </span><span class="koboSpan" id="kobo.157.2">If we stored it in a database, in fact, we would have to recalculate it every time the flight departure/arrival times change (in industry jargon, every time there is a “schedule change”) or we might </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">get inconsistencies.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">Just as having a single source of truth is a good practice, having a single source of logic is also beneficial. </span><span class="koboSpan" id="kobo.159.2">In the aforementioned case, for instance, we need to calculate the duration of a flight from Milan to San Francisco. </span><span class="koboSpan" id="kobo.159.3">While it may not be rocket science, it is not a trivial calculation either, as it involves different time zones and the so-called daylight saving time. </span><span class="koboSpan" id="kobo.159.4">It is one of those things that is easy to underestimate and can, more easily than you might think, lead to bugs in production (and there are many flight search websites that have this bug in production at the moment I’m writing). </span><span class="koboSpan" id="kobo.159.5">In this case, it is very helpful to write the function once, thoroughly test it, and then consistently use it throughout our code base. </span><span class="koboSpan" id="kobo.159.6">This way, we do not stray far from the good old </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.160.1">principle of </span><strong class="bold"><span class="koboSpan" id="kobo.161.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.162.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.163.1">DRY</span></strong><span class="koboSpan" id="kobo.164.1">). </span><span class="koboSpan" id="kobo.164.2">In this case, you could write a library, a service, or just a class in your project that deals with the journey duration and use it every time you </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">need it.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.166.1">Good code is modular</span></h2>
<p><span class="koboSpan" id="kobo.167.1">In general, modularity </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.168.1">refers to the concept of dividing a system or complex entity into smaller, independent components or modules. </span><span class="koboSpan" id="kobo.168.2">It is a principle that can be applied beyond software and is used in various fields and disciplines. </span><span class="koboSpan" id="kobo.168.3">Let’s consider a shelving unit consisting of individual modules that can be easily assembled </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">and disassembled.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.170.1"><img alt="Figure 2.2 – This kind of furniture is composed of a set of identical and reusable modules" src="image/B20912_02_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.171.1">Figure 2.2 – This kind of furniture is composed of a set of identical and reusable modules</span></p>
<p><span class="koboSpan" id="kobo.172.1">Each module serves as a building block, and you can arrange them in various configurations to create different shelving arrangements based on your needs. </span><span class="koboSpan" id="kobo.172.2">This modular </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.173.1">approach allows for flexibility in adapting the furniture to different spaces and changing requirements. </span><span class="koboSpan" id="kobo.173.2">For example, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.174.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.175.1">.2</span></em><span class="koboSpan" id="kobo.176.1">, it is possible to use the same type of brackets vertically, adapting them to shelves of </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">different lengths.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">The components that make up this shelf are easy to use, meaning they have clear interfaces and few points of interaction. </span><span class="koboSpan" id="kobo.178.2">If you put yourselves in the shoes of both the designer of this shelf and the person who has to assemble and maintain it, you understand that modularity is essential. </span><span class="koboSpan" id="kobo.178.3">If there were a different way to assemble each shelf or bracket, or if there were different brackets for different shelves, the management would be much more complex and prone to errors. </span><span class="koboSpan" id="kobo.178.4">We’ll say something more about modularity in the </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">text sections.</span></span></p>
<h3><span class="koboSpan" id="kobo.180.1">Dependency injection</span></h3>
<p><span class="koboSpan" id="kobo.181.1">Classes often need to use other classes. </span><span class="koboSpan" id="kobo.181.2">In well-organized code, we often solve each of these smaller </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.182.1">problems with a separate class. </span><span class="koboSpan" id="kobo.182.2">However, there isn’t always just one way to solve a problem, so it can be helpful to structure our code in a way that allows us to change how we solve these smaller problems. </span><span class="koboSpan" id="kobo.182.3">That’s where dependency injection comes </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">in handy.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">I could give you a quick example relating to our example flight search system. </span><span class="koboSpan" id="kobo.184.2">Let’s suppose we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">FlightSearcher</span></strong><span class="koboSpan" id="kobo.186.1"> which returns, given an itinerary and a description of the people involved, some possible travel plans around Europe and their relative prices. </span><span class="koboSpan" id="kobo.186.2">Of course, we are a profitable company so we want to surcharge the original price to get some earnings out of it. </span><span class="koboSpan" id="kobo.186.3">A crucial part of the response will be the price given to the customer, calculated through a component </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">FlightPricer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
class FlightSearcher {
    private final EuroFlightPricer euroFlightPricer;
    FlightSearcher() {
        this.euroFlightPricer = new EuroFlightPricer();
    }
    Collection&lt;Flight&gt; searchFlights(FlightSearchRequest flightSearchRequest) {
        ...
</span><span class="koboSpan" id="kobo.190.2">    }
}</span></pre> <p><span class="koboSpan" id="kobo.191.1">It is clear to see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">FlightSearcher</span></strong><span class="koboSpan" id="kobo.193.1"> components depend on </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">EuroFlightPricer</span></strong><span class="koboSpan" id="kobo.195.1">. </span><span class="koboSpan" id="kobo.195.2">As easily inferred from the name of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">EuroFlightPricer</span></strong><span class="koboSpan" id="kobo.197.1"> component, it handles and returns prices in euros. </span><span class="koboSpan" id="kobo.197.2">Without blaming the hard-working development </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.198.1">team that was under pressure to deliver this feature as quickly as possible to ensure the company’s commercial success, it is clear that hardcoding this dependency is not a wise long-term choice. </span><span class="koboSpan" id="kobo.198.2">Certainly, ensuring simplicity and readability of the code is guaranteed (for example, there is no need to provide any parameters for the constructor). </span><span class="koboSpan" id="kobo.198.3">However, if we were to use another currency or any other logic for calculations in the future, we would need to modify the existing code. </span><span class="koboSpan" id="kobo.198.4">The solution is to inject the dependency from </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">the outside:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
class FlightSearcher{
    private final FlightPricer flightPricer;
    
    FlightSearcher(FlightPricer flightPricer){
        this.flightPricer = flightPricer;
    }
    Collection&lt;Flight&gt; searchFlights(FlightSearchRequest flightSearchRequest){ 
        …
    }
}</span></pre> <p><span class="koboSpan" id="kobo.201.1">It is crucial </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.202.1">to note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">FlightSearcher</span></strong><span class="koboSpan" id="kobo.204.1"> now depends on an interface. </span><span class="koboSpan" id="kobo.204.2">We will use, in fact, a specific implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">FlightPricer</span></strong><span class="koboSpan" id="kobo.206.1"> interface intended just to handle the </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">euro currency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
class EuroFlightPricer implements FlightPricer{
    ...
</span><span class="koboSpan" id="kobo.208.2">  @Override
  Collection&lt;Price&gt; getPrices() { ... </span><span class="koboSpan" id="kobo.208.3">}
  @Override
  Collection&lt;Discount&gt; getDiscounts() { ... </span><span class="koboSpan" id="kobo.208.4">}
}</span></pre> <p><span class="koboSpan" id="kobo.209.1">With dependency injection, we can easily reconfigure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">FlightSearcher</span></strong><span class="koboSpan" id="kobo.211.1"> class. </span><span class="koboSpan" id="kobo.211.2">This is possible because all the different pricer classes implement the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">FlightPricer</span></strong><span class="koboSpan" id="kobo.213.1"> interface, allowing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">FlightSearcher</span></strong><span class="koboSpan" id="kobo.215.1"> class to depend on it. </span><span class="koboSpan" id="kobo.215.2">This means we can use any implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">FlightPricer</span></strong><span class="koboSpan" id="kobo.217.1">, making the code more flexible </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">and adaptable.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">This leads to a general technique for making code more modular and adaptable: if we depend on a class that implements an interface with the needed functionality, it’s usually better to depend on the interface itself instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">specific class.</span></span></p>
<h3><span class="koboSpan" id="kobo.221.1">Law of Demeter</span></h3>
<p><span class="koboSpan" id="kobo.222.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.223.1">Law of Demeter</span></strong><span class="koboSpan" id="kobo.224.1">, also </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.225.1">known as </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.226.1">the principle of least knowledge and sometimes abbreviated as </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">LoD</span></strong><span class="koboSpan" id="kobo.228.1">, is a software design guideline that promotes loose coupling and encapsulation. </span><span class="koboSpan" id="kobo.228.2">According to this principle, an object should have limited knowledge about other objects and should only interact with its immediate neighbors. </span><span class="koboSpan" id="kobo.228.3">Let’s see some applications of </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">this principle:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.230.1">Avoid chaining method calls excessively</span></strong><span class="koboSpan" id="kobo.231.1">: Instead of accessing methods of multiple objects in a single chain, limit the number of method invocations to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">loose coupling:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.233.1">
// Non-compliant
String result = object1.getObject2()
    .getObject3().getObject4().getValue();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.234.1">While this code works, it could be problematic for several reasons. </span><span class="koboSpan" id="kobo.234.2">Firstly, it assumes that each method call will successfully return a non-null object, otherwise, it may encounter a </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">NullPointerException</span></strong><span class="koboSpan" id="kobo.236.1">. </span><span class="koboSpan" id="kobo.236.2">Additionally, it tightly </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.237.1">couples the code to the specific structure of the object hierarchy. </span><span class="koboSpan" id="kobo.237.2">If the structure changes in the future, this code will need to be </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">modified accordingly.</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.239.1">// Compliant
Object2 object2 = object1.getObject2();
Object3 object3 = object2.getObject3();
Object4 object4 = object3.getObject4();
String result = object4.getValue();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.240.1">In this version, the nested object hierarchy is traversed step by step, and each intermediate object is stored in a separate variable. </span><span class="koboSpan" id="kobo.240.2">This approach allows for better readability, improved error handling (it would be possible to check for null values), and flexibility in case the structure of the object </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">hierarchy changes.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.242.1">Don’t expose the internals of an object by returning references to internal objects</span></strong><span class="koboSpan" id="kobo.243.1">: Instead, provide high-level methods that encapsulate the required functionality. </span><span class="koboSpan" id="kobo.243.2">For example, let’s suppose we must retrieve all the books from a warehouse that stores several types </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">of goods:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.245.1">
// Non-compliant
public List&lt;Item&gt; getItems() {
    return warehouse.getItems();
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.246.1">This code is technically OK, but the caller is forced to retrieve all the items and then filter to keep only the books. </span><span class="koboSpan" id="kobo.246.2">This is unpleasant for several reasons: we query the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">Warehouse</span></strong><span class="koboSpan" id="kobo.248.1"> for all of the items, but we only need books; the caller must increase its complexity to filter the items; we must expose the internal structure of </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Item</span></strong><span class="koboSpan" id="kobo.250.1"> to let the client get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Type</span></strong><span class="koboSpan" id="kobo.252.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Item</span></strong><span class="koboSpan" id="kobo.254.1"> itself, so that it can apply filtering. </span><span class="koboSpan" id="kobo.254.2">We’re producing, above all else, </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">strong couplings.</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.256.1">// Compliant
public List&lt;Item&gt; getItems(String itemCategory) {
    return warehouse.getItemsByCategory(itemCategory);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.257.1">In this way, we don’t let the client do all the filtering and we only enquire in the warehouse for books. </span><span class="koboSpan" id="kobo.257.2">We are not forced to expose the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Item</span></strong><span class="koboSpan" id="kobo.259.1">, because </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.260.1">the client just asked for a given category. </span><span class="koboSpan" id="kobo.260.2">We should optimize even more this code, for example returning a </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Book</span></strong><span class="koboSpan" id="kobo.262.1"> class instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Item</span></strong><span class="koboSpan" id="kobo.264.1">, but the purpose was just to provide an example for the internal structure exposure, so we’ll stop here </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">for now.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.266.1">Avoid passing objects further than necessary as method arguments</span></strong><span class="koboSpan" id="kobo.267.1">: If an object requires access to another object, provide only the necessary information </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">or dependencies:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.269.1">
// Non-compliant
public void processOrder(Order order) {
    shippingService.shipOrder(order);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.270.1">In this code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">shipOrder</span></strong><span class="koboSpan" id="kobo.272.1"> method receives all of the order, while it needs only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">items</span></strong><span class="koboSpan" id="kobo.274.1"> of the order itself. </span><span class="koboSpan" id="kobo.274.2">It would be better to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">shipOrder</span></strong><span class="koboSpan" id="kobo.276.1"> signature so that it takes </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">only them.</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.278.1">// Compliant
public void processOrder(Order order) {
    shippingService.shipOrder(order.getItems());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.279.1">Now, we provide to </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">shipOrder</span></strong><span class="koboSpan" id="kobo.281.1"> only the </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">necessary information.</span></span></p></li> </ul>
<p><span class="koboSpan" id="kobo.283.1">It can’t </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.284.1">be said that the entire developer community fully agrees with the Law of Demeter (refer to the Further reading section), so much so that some think it should be called the </span><em class="italic"><span class="koboSpan" id="kobo.285.1">suggestion</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.286.1">of Demeter.</span></span></p>
<h3><span class="koboSpan" id="kobo.287.1">Data cohesion (make related data work together)</span></h3>
<p><span class="koboSpan" id="kobo.288.1">Classes help us organize things, but it can become problematic if we group too many things </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.289.1">together in a single class. </span><span class="koboSpan" id="kobo.289.2">We should be careful about this, but at the same time, we shouldn’t forget the benefits of grouping things together when it </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">makes sense.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">Sometimes, certain pieces of data are naturally related to each other, and our code needs to handle them together. </span><span class="koboSpan" id="kobo.291.2">In such cases, it makes sense to group them into a class or a similar structure. </span><span class="koboSpan" id="kobo.291.3">By doing this, our code can focus on the overall concept that the group of items represents, rather than dealing with specific details all the time. </span><span class="koboSpan" id="kobo.291.4">This approach promotes modularity in our code and allows changes in requirements to be isolated </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">more easily.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">An example of related data grouping is the combination of price and currency. </span><span class="koboSpan" id="kobo.293.2">In many applications, when dealing with financial transactions or monetary values, it is essential to consider both the price amount and the currency in which it </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">is expressed.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">By grouping the price and currency together into a class or a data structure, we can conveniently handle these related pieces of information as a single unit. </span><span class="koboSpan" id="kobo.295.2">This allows us to perform calculations, conversions, and other operations on the price while ensuring that the corresponding currency is correctly </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">accounted for.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">For instance, we can create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">Price</span></strong><span class="koboSpan" id="kobo.299.1"> class that encapsulates the price value and the currency code. </span><span class="koboSpan" id="kobo.299.2">This class would provide methods to perform arithmetic operations and currency conversions and enforce consistency between the price and currency (and thus, the logic would all be in one place, behaving as a single source </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">of truth).</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Another example of related data grouping could involve latitude and longitude coordinates. </span><span class="koboSpan" id="kobo.301.2">When working with location-based applications or mapping systems, latitude and </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.302.1">longitude values are often used together to specify a specific point on the Earth’s surface. </span><span class="koboSpan" id="kobo.302.2">By grouping latitude and longitude into a class or a data structure (simply put: </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Point</span></strong><span class="koboSpan" id="kobo.304.1">) and encapsulating the latitude and longitude values, we can conveniently handle and manipulate geographic coordinates as a cohesive unit. </span><span class="koboSpan" id="kobo.304.2">And again, we could perform various operations such as distance calculations, mapping functionalities, or finding nearby locations (actually, many libraries that deal with geographical calculation do </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">exactly this).</span></span></p>
<h3><span class="koboSpan" id="kobo.306.1">Don’t leak implementation details in the return type</span></h3>
<p><span class="koboSpan" id="kobo.307.1">In order to keep things organized and easy to work with, it’s important to make sure that each </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.308.1">layer of abstraction is clean and doesn’t reveal how things are implemented under the hood. </span><span class="koboSpan" id="kobo.308.2">When implementation details are leaked, it can expose information about lower layer</span><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.309.1">s in the code and make it really tough to make changes or customize things later on. </span><span class="koboSpan" id="kobo.309.2">One common way this happens is when the code returns a type that’s tightly connected to those </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">specific details.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">In our hypothetical flight search system, let’s consider the scenario where we depend on external suppliers through traditional web service calls. </span><span class="koboSpan" id="kobo.311.2">Due to legal requirements, we are obligated to retain all the requests and responses for a specific duration. </span><span class="koboSpan" id="kobo.311.3">To address this, we have implemented a service within our code base that handles the storage of these records. </span><span class="koboSpan" id="kobo.311.4">We use a cloud storage system, referred to as SkyVault, for </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">this purpose:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
class PayloadStorageService{
    public SkyVaultClientResponse upload(Payload payload){
    … }
}</span></pre> <p><span class="koboSpan" id="kobo.314.1">As we can see, the class spills the beans about using </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">SkyVault</span></strong><span class="koboSpan" id="kobo.316.1"> as our storage service, and it binds the client to this choice. </span><span class="koboSpan" id="kobo.316.2">This makes it super hard to change things if we ever want to switch to a different storage service, use a database, or go for any other type of data storage. </span><span class="koboSpan" id="kobo.316.3">Changing the code would be </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">very difficult.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">One solution to this problem could be to abstract the response in a very </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">trivial way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
class PayloadStorageService{
    public UploadResponse upload(Payload payload){ … }
}</span></pre> <p><span class="koboSpan" id="kobo.321.1">Besides the return type, there are cases where the implementation is overly visible, creating </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.322.1">a tight connection between library or service users and the service itself. </span><span class="koboSpan" id="kobo.322.2">For example, the implementation complexities of external systems are exposed instead of being simplified and pushed up to the </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">caller level:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.324.1">
class PayloadStorageService{
    public boolean exists(Payload payload) { … }
    public UploadResponse overWrite(Payload payload) { … }
    public UploadResponse upload(Payload payload) { … }
    …
}</span></pre> <p><span class="koboSpan" id="kobo.325.1">In this case, the client needs to first check if the payload </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">exists</span></strong><span class="koboSpan" id="kobo.327.1"> before calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">upload</span></strong><span class="koboSpan" id="kobo.329.1"> method. </span><span class="koboSpan" id="kobo.329.2">If it does exist, they have to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">overWrite</span></strong><span class="koboSpan" id="kobo.331.1"> method instead. </span><span class="koboSpan" id="kobo.331.2">This extra step adds unnecessary complexity for the client. </span><span class="koboSpan" id="kobo.331.3">It would have been better if this complexity was handled internally within the method itself (unless, of course, overwriting an existing file is somehow important to our </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">specific situation).</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.333.1">Good code is reusable</span></h2>
<p><span class="koboSpan" id="kobo.334.1">As engineers, we often </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.335.1">solve big problems by breaking them down into smaller ones (the good old </span><em class="italic"><span class="koboSpan" id="kobo.336.1">divide et impera</span></em><span class="koboSpan" id="kobo.337.1">). </span><span class="koboSpan" id="kobo.337.2">And guess what? </span><span class="koboSpan" id="kobo.337.3">We keep running into the same small problems over and over again across different projects. </span><span class="koboSpan" id="kobo.337.4">So, if we or other engineers have already figured out a solution to one of these recurring problems, it just makes sense to reuse it. </span><span class="koboSpan" id="kobo.337.5">It saves us time and reduces the chances of introducing bugs because we know the solution has already been tried </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">and tested.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">The concept of reusability is closely tied to two key practices: establishing clear layers of abstraction </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.340.1">and developing modular code. </span><span class="koboSpan" id="kobo.340.2">By implementing clean layers of abstraction and modularizing our code, we naturally break down solutions to subproblems into separate code components that are loosely interconnected. </span><span class="koboSpan" id="kobo.340.3">This approach significantly enhances the ease and safety of code reuse </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">and generalization.</span></span></p>
<h3><span class="koboSpan" id="kobo.342.1">Don’t make assumptions while writing your code</span></h3>
<p><span class="koboSpan" id="kobo.343.1">Don't make assumptions is a good piece of advice for life in general – but I don’t want to be your life coach here, so </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">don’t worry.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">There is </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.346.1">no specific definition for an assumption, but I can provide you with a recent example I encountered. </span><span class="koboSpan" id="kobo.346.2">Imagine you are responsible for managing an e-commerce system and need to maintain records of purchases. </span><span class="koboSpan" id="kobo.346.3">Each purchase is characterized by a set of properties, and each purchase has a unique identifier called the </span><strong class="bold"><span class="koboSpan" id="kobo.347.1">ID</span></strong><span class="koboSpan" id="kobo.348.1">. </span><span class="koboSpan" id="kobo.348.2">It is important to note that this ID is a numeric value that increases sequentially. </span><span class="koboSpan" id="kobo.348.3">For instance, if a purchase has ID </span><em class="italic"><span class="koboSpan" id="kobo.349.1">x</span></em><span class="koboSpan" id="kobo.350.1">, the subsequent purchase will be identified as </span><em class="italic"><span class="koboSpan" id="kobo.351.1">x+1</span></em><span class="koboSpan" id="kobo.352.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">Alongside the purchase management system, there is a typical component found in most companies called a reporting system (in my mind, I can hear a horse neighing, as in the movie </span><em class="italic"><span class="koboSpan" id="kobo.355.1">Frankenstein Junior</span></em><span class="koboSpan" id="kobo.356.1">). </span><span class="koboSpan" id="kobo.356.2">This reporting system relies on determining the relative recency of purchases. </span><span class="koboSpan" id="kobo.356.3">The logical basis for this comparison is typically a date field such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">created_on</span></strong><span class="koboSpan" id="kobo.358.1"> or a similar attribute. </span><span class="koboSpan" id="kobo.358.2">However, the reporting system in this case makes the assumption that the ordering of purchases is solely dependent on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">id</span></strong><span class="koboSpan" id="kobo.360.1"> field. </span><span class="koboSpan" id="kobo.360.2">It assumes that the lower the ID, the more recent </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">the purchase.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Now, let’s consider a scenario where the maintainers of the purchase management system needed to migrate data. </span><span class="koboSpan" id="kobo.362.2">It became convenient for them to change the ID generation process to use random alphanumeric strings instead of numeric increments. </span><span class="koboSpan" id="kobo.362.3">Consequently, the reporting system, which had assumed that the IDs were numerical and sequentially incremental, ceased to </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">function correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">Assumptions can lead to bugs when code is reused because the reused code may rely on certain conditions or behaviors that are not met or consistent in the new context. </span><span class="koboSpan" id="kobo.364.2">These bugs may kick in many different ways, including </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.366.1">Contextual differences</span></strong><span class="koboSpan" id="kobo.367.1">: When code is reused in a different context or environment, the assumptions made during the original implementation may not hold true anymore. </span><span class="koboSpan" id="kobo.367.2">The underlying dependencies, data structures, or system configurations might be different, causing the code to behave unexpectedly or produce </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">incorrect results.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.369.1">Implicit dependencies</span></strong><span class="koboSpan" id="kobo.370.1">: Reused code may have implicit dependencies on external factors, such as specific data formats, database schemas, or API responses. </span><span class="koboSpan" id="kobo.370.2">If these dependencies are not properly understood or communicated, using the code in a different context can result in compatibility issues and </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">unexpected failures.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.372.1">Assumed constraints</span></strong><span class="koboSpan" id="kobo.373.1">: The reused code might make assumptions about the limitations or constraints of the original system. </span><span class="koboSpan" id="kobo.373.2">These assumptions could include </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.374.1">factors like data size, frequency of operations, or expected usage patterns. </span><span class="koboSpan" id="kobo.374.2">If these constraints are exceeded or not satisfied in the new context, the reused code may not handle the situations correctly, leading to bugs or </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">system failures.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.376.1">Compatibility issues</span></strong><span class="koboSpan" id="kobo.377.1">: Code reuse often involves integrating different components or libraries. </span><span class="koboSpan" id="kobo.377.2">If the reused code relies on specific versions or configurations of these components, it may not work as intended when used with different versions or alternative implementations. </span><span class="koboSpan" id="kobo.377.3">Incompatible interactions between reused code and other components can introduce bugs or cause </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">system instability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.379.1">Limited validation</span></strong><span class="koboSpan" id="kobo.380.1">: Assumptions may not have been thoroughly validated during the original implementation. </span><span class="koboSpan" id="kobo.380.2">When code is reused, there is a risk that the assumptions were only valid in the original use case but not in other scenarios. </span><span class="koboSpan" id="kobo.380.3">Insufficient validation of assumptions can result in bugs that arise when the code is reused in a </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">different context.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.382.1">If you make assumptions, identify them clearly</span></h3>
<p><span class="koboSpan" id="kobo.383.1">I am a man who lives by his own contradictions, and so now I tell you: making assumptions is crucial! </span><span class="koboSpan" id="kobo.383.2">The important thing is to do it at the right time, in the right amount, and for the right things. </span><span class="koboSpan" id="kobo.383.3">For example, when we find ourselves working on a completely </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.384.1">unfamiliar code base, it is vital to make assumptions; otherwise, we would be navigating through every single class, every single line, searching for answers to our countless questions. </span><span class="koboSpan" id="kobo.384.2">Another example is debugging: when it comes to fixing bugs, start by making lots of assumptions, especially if you’re familiar with the code. </span><span class="koboSpan" id="kobo.384.3">Trust your gut feeling. </span><span class="koboSpan" id="kobo.384.4">Most of the time, when someone starts explaining the problem to you, you will already know where the bug is hiding. </span><span class="koboSpan" id="kobo.384.5">Also, when creating new code, assumptions can be crucial in order to build quickly and effectively. </span><span class="koboSpan" id="kobo.384.6">Otherwise, we may end up stuck trying to create code to handle every possible use case, even the ones that are not going </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">to happen.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">At times, making assumptions becomes necessary or simplifies the code significantly, outweighing any drawbacks. </span><span class="koboSpan" id="kobo.386.2">However, when we make assumptions in our code, it’s crucial to remember that other engineers might not be aware of them. </span><span class="koboSpan" id="kobo.386.3">To prevent them from inadvertently being affected by our assumptions, we need to enforce them. </span><span class="koboSpan" id="kobo.386.4">There are generally two approaches we can adopt to </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">achieve this:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.388.1">Making the assumption “impossible to break”</span></strong><span class="koboSpan" id="kobo.389.1">: If we can structure the code in such a way that it won’t compile if an assumption is violated, we ensure that the assumption always remains valid. </span><span class="koboSpan" id="kobo.389.2">For example, if a class must be instantiated or initialized in a certain way, keep its constructor private and expose a </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">create()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.391.1">method instead.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.392.1">Utilizing an error-signaling technique</span></strong><span class="koboSpan" id="kobo.393.1">: If it’s not feasible to make the assumption foolproof, we can implement code that detects when the assumption is violated and employs an error-signaling technique to quickly halt </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">the execution.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.395.1">If you would like to look more deeply into these aspects, I recommend the book by Tom Long listed in the </span><em class="italic"><span class="koboSpan" id="kobo.396.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.397.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.398.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">So far, we’ve learned what makes code good, the most important things for which are readability and reliability. </span><span class="koboSpan" id="kobo.399.2">Good code should be easy to understand and hard to mess up. </span><span class="koboSpan" id="kobo.399.3">It’s modular, like a well-built piece of furniture that you can use over and over again. </span><span class="koboSpan" id="kobo.399.4">Of course, there’s some room for debate and personal preference, but I think we can mostly agree on these points. </span><span class="koboSpan" id="kobo.399.5">Now, let’s move on to another important way to create good code: </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.400.1">Clean Code</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.402.1">Clean Code</span></h1>
<p><span class="koboSpan" id="kobo.403.1">The most well-known book on Clean Code is called </span><em class="italic"><span class="koboSpan" id="kobo.404.1">Clean Code</span></em><span class="koboSpan" id="kobo.405.1"> by Robert C. </span><span class="koboSpan" id="kobo.405.2">Martin. </span><span class="koboSpan" id="kobo.405.3">Surprisingly, even Martin himself struggles to come up with a single definition for Clean Code. </span><span class="koboSpan" id="kobo.405.4">It seems </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.406.1">like there are multiple definitions floating around among us developers. </span><span class="koboSpan" id="kobo.406.2">In fact, in his book, Martin asks several developers to provide their own “custom” definitions, and he includes all of them so that we can create our own understanding of what Clean </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">Code means.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">Clean Code is all about writing code that’s easy to understand and follows a logical and disciplined approach. </span><span class="koboSpan" id="kobo.408.2">The main goal is to create software efficiently and effectively while ensuring that the code is readable, adaptable, expandable, and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">to maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">You could argue that this definition is not objective, and you would be right! </span><span class="koboSpan" id="kobo.410.2">For example, “</span><em class="italic"><span class="koboSpan" id="kobo.411.1">readable</span></em><span class="koboSpan" id="kobo.412.1">” is something very personal (and depends also on the seniority and the skillset of those who are approaching the code). </span><span class="koboSpan" id="kobo.412.2">More often than you might think, we judge code by our guts. </span><span class="koboSpan" id="kobo.412.3">Can I understand it? </span><span class="koboSpan" id="kobo.412.4">Then it’s readable! </span><span class="koboSpan" id="kobo.412.5">Rephrasing from the “</span><em class="italic"><span class="koboSpan" id="kobo.413.1">Fundamental Theorem of Readability</span></em><span class="koboSpan" id="kobo.414.1">” book by Bowsell and Foucher: </span><em class="italic"><span class="koboSpan" id="kobo.415.1">code should be crafted in a way that reduces the amount of time someone else would need to </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.416.1">comprehend it.</span></em></span></p>
<p><span class="koboSpan" id="kobo.417.1">And when we use the word “</span><em class="italic"><span class="koboSpan" id="kobo.418.1">understand</span></em><span class="koboSpan" id="kobo.419.1">,” we set a very high standard. </span><span class="koboSpan" id="kobo.419.2">To truly comprehend your code, someone should possess the ability to make modifications, identify bugs, and grasp how it interacts with the rest of your code base. </span><span class="koboSpan" id="kobo.419.3">Clean Code is not a set of laws or a set of rules; it is an attitude, a mindset that we all </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">should follow.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">As already mentioned, refactoring and clean code are strictly related, since they both aim to improve the quality and maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">of software.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.423.1">Why Clean Code?</span></h2>
<p><span class="koboSpan" id="kobo.424.1">Exactly as happens with refactoring, when I talk about Clean Code at work to people who don’t </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.425.1">have a technical background, the reactions vary, but not so much: they range from yawning to rolling their eyes, from looking down to impatient gestures. </span><span class="koboSpan" id="kobo.425.2">They perceive someone talking about incomprehensible topics to them, or proposing “changing something that works” or “writing code well,” as if there was something other than code that either works or doesn’t work (and – let’s face it – considering practices such as refactoring as a waste of time </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">and money).</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">Things such as documentation and comments are definitely important (and we’ll get there), but the most crucial thing that should always speak for itself is your code. </span><span class="koboSpan" id="kobo.427.2">Write your code as if you’re talking in everyday language. </span><span class="koboSpan" id="kobo.427.3">Make it understandable not just for now, but also for yourself and others in the future. </span><span class="koboSpan" id="kobo.427.4">Remember that a big part of our job is maintenance (which might not be fun, but it’s a reality). </span><span class="koboSpan" id="kobo.427.5">When your code can speak for itself, it not only improves your technical skills but also enhances the quality of your code. </span><span class="koboSpan" id="kobo.427.6">Being able to communicate clearly about your code allows you to seek help and receive valuable suggestions for improvement. </span><span class="koboSpan" id="kobo.427.7">Clean code doesn’t magically appear; it requires dedicated effort to express your intentions effectively. </span><span class="koboSpan" id="kobo.427.8">Aim to write self-explanatory code, organized and structured, so that you don’t have to litter it with excessive comments to explain </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">its purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">I’ve already </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.430.1">mentioned that your code will be read by someone else, whether it’s another person or even yourself. </span><span class="koboSpan" id="kobo.430.2">This highlights the need to write Clean Code, as it benefits teamwork. </span><span class="koboSpan" id="kobo.430.3">It takes less time to understand what the code does, fix it when issues arise, and add new features. </span><span class="koboSpan" id="kobo.430.4">Clean Code promotes code reusability and makes you a more efficient programmer; it facilitates easier and faster maintenance, as it is easier to understand, debug, and modify when needed. </span><span class="koboSpan" id="kobo.430.5">Simply put, it makes the team faster. </span><span class="koboSpan" id="kobo.430.6">You can use this argument (this </span><em class="italic"><span class="koboSpan" id="kobo.431.1">fact</span></em><span class="koboSpan" id="kobo.432.1">) when a colleague or manager accuses you of wasting time by being picky about </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">the code!</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">One often underestimated aspect of writing clean code is feeling comfortable with what you’re doing. </span><span class="koboSpan" id="kobo.434.2">Imagine having to ask someone for help and showing them something messy and shaky, something that is hard to understand and complicated to explain. </span><span class="koboSpan" id="kobo.434.3">It would be embarrassing. </span><span class="koboSpan" id="kobo.434.4">Moreover, in my opinion, working on a clean project boosts morale. </span><span class="koboSpan" id="kobo.434.5">You have the satisfaction of doing things properly, almost something beautiful, you could say. </span><span class="koboSpan" id="kobo.434.6">It’s what a craftsman should do (forgive the clichéd metaphor). </span><span class="koboSpan" id="kobo.434.7">We’re not just button pushers; we’re artisans. </span><span class="koboSpan" id="kobo.434.8">Let’s always write code as if we were going to show it to someone else (and actually showing it to someone else, through peer reviews or pair programming, really helps—we’ll come on to that later). </span><span class="koboSpan" id="kobo.434.9">Clean Code just works better, hence the satisfaction is not only when people look at your code, but also when they use the services it provides and they </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">work properly.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">If you think your main job as a programmer is writing code, think again. </span><span class="koboSpan" id="kobo.436.2">You actually spend more time reading code, hunting down bugs, identifying issues, and figuring out solutions. </span><span class="koboSpan" id="kobo.436.3">Clean Code simplifies all of these tasks. </span><span class="koboSpan" id="kobo.436.4">One thing every programmer can unanimously agree on is that Clean Code is </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">undeniably better.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.438.1">Some principles of Clean Code</span></h2>
<p><span class="koboSpan" id="kobo.439.1">Trying to explain Clean Code in its entirety would take a whole book, and guess what? </span><span class="koboSpan" id="kobo.439.2">It already </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.440.1">exists courtesy of Uncle Bob, Robert C. </span><span class="koboSpan" id="kobo.440.2">Martin. </span><span class="koboSpan" id="kobo.440.3">However, I do think it would be helpful to provide you with some highlights, especially if you’re new to this topic. </span><span class="koboSpan" id="kobo.440.4">We’ll delve deeper into some of these aspects </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">later on.</span></span></p>
<h3><span class="koboSpan" id="kobo.442.1">KISS – Keep things as simple as possible</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.443.1">KISS</span></strong><span class="koboSpan" id="kobo.444.1"> (short for </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">Keep It Simple, Stupid</span></strong><span class="koboSpan" id="kobo.446.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.447.1">Keep It Stupid-Simple</span></strong><span class="koboSpan" id="kobo.448.1">, depending on how bold you want to be) is one of the oldest rules in clean code. </span><span class="koboSpan" id="kobo.448.2">It urges programmers to keep </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.449.1">their code as simple as possible. </span><span class="koboSpan" id="kobo.449.2">Avoid making things needlessly complicated. </span><span class="koboSpan" id="kobo.449.3">In the world of programming, there’s </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.450.1">never just one way to solve a problem. </span><span class="koboSpan" id="kobo.450.2">You can accomplish a task using different languages and various commands. </span><span class="koboSpan" id="kobo.450.3">Programmers who embrace the KISS principle always ask themselves if there’s a simpler way to tackle a </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">specific problem.</span></span></p>
<h3><span class="koboSpan" id="kobo.452.1">DRY – Avoid repetition</span></h3>
<p><span class="koboSpan" id="kobo.453.1">One of </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.454.1">the main functions of computer </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.455.1">science is to come up with cool acronyms. </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">DRY</span></strong><span class="koboSpan" id="kobo.457.1"> (short for </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.459.1">) is one of them. </span><span class="koboSpan" id="kobo.459.2">It’s like a more specific version of KISS, emphasizing that functions in Clean Code should do one thing only (and do it well). </span><span class="koboSpan" id="kobo.459.3">It’s worth noting that the opposite </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.460.1">of DRY code is called </span><strong class="bold"><span class="koboSpan" id="kobo.461.1">WET</span></strong><span class="koboSpan" id="kobo.462.1">, which stands for </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">We Enjoy Typing</span></strong><span class="koboSpan" id="kobo.464.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">Write </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.466.1">Everything Twice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">A very trivial WET code example is </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
public class WETExample {
    public static void main(String[] args) {
        String name = "John";
        System.out.println("Hello, " + name + "!");
        // Some other code...
</span><span class="koboSpan" id="kobo.470.2">        System.out.println("Hello, " + name + "!");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.471.1">As you </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.472.1">can see, in this code, there are many lines that are basically the same. </span><span class="koboSpan" id="kobo.472.2">We must try to avoid these repetitions; to continue </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.473.1">with the wordplay, we must </span><em class="italic"><span class="koboSpan" id="kobo.474.1">dry</span></em><span class="koboSpan" id="kobo.475.1"> this </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.476.1">wet</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.477.1"> code.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">In its DRY version, the preceding code becomes the following, with </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">no surprises:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
public class DRYExample {
    public static void main(String[] args) {
        String name = "John";
        greetUser(name);
        // Some other code...
</span><span class="koboSpan" id="kobo.480.2">        greetUser(name);
    }
    public static void greetUser(String name) {
        System.out.println("Hello, " + name + "!");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.481.1">In the DRY version, we simply isolated the repeated code in a single method. </span><span class="koboSpan" id="kobo.481.2">This example was very simple because the repeated line was just a one-line </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">sysout</span></strong><span class="koboSpan" id="kobo.483.1">, but this was just to explain the concept: imagine how it would be if there were many lines. </span><span class="koboSpan" id="kobo.483.2">And that will not only create clean, more readable code but will also reduce the possibility of bugs sneaking in (and security issues, </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">as well).</span></span></p>
<h3><span class="koboSpan" id="kobo.485.1">YAGNI – delete what’s useless</span></h3>
<p><span class="koboSpan" id="kobo.486.1">The </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.487.1">Clean Code principle </span><strong class="bold"><span class="koboSpan" id="kobo.488.1">YAGNI</span></strong><span class="koboSpan" id="kobo.489.1"> (short for </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">You Aren’t Gonna Need It</span></strong><span class="koboSpan" id="kobo.491.1">) follows </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.492.1">this simple idea: a developer should only add extra functionality to code when it’s actually needed. </span><span class="koboSpan" id="kobo.492.2">YAGNI is closely associated with Agile software development approaches. </span><span class="koboSpan" id="kobo.492.3">According to the YAGNI principle, instead of starting with a grand plan, you should build the software architecture in small increments to address </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.493.1">problems as they arise. </span><span class="koboSpan" id="kobo.493.2">This allows for dynamic and individualized problem-solving. </span><span class="koboSpan" id="kobo.493.3">Clean Code is achieved </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.494.1">when the underlying problem is solved efficiently without unnecessary bells </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">and whistles.</span></span></p>
<h3><span class="koboSpan" id="kobo.496.1">Code should be readable, not concise</span></h3>
<p><span class="koboSpan" id="kobo.497.1">Code needs to do its job and be interpreted correctly by the machine. </span><span class="koboSpan" id="kobo.497.2">But it’s not just the machine </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.498.1">that needs to understand it—other developers should be able to comprehend the code too, especially in collaborative projects. </span><span class="koboSpan" id="kobo.498.2">That’s why readability is always prioritized over brevity in software development. </span><span class="koboSpan" id="kobo.498.3">Writing concise code is pointless if it becomes incomprehensible to others. </span><span class="koboSpan" id="kobo.498.4">A prime example of producing clean and readable code lies in </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">variable naming.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">A variable should have a name that clearly conveys its purpose. </span><span class="koboSpan" id="kobo.500.2">Take the following variable, for instance, which is cryptic without the requisite background knowledge </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">and explanation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
int x;</span></pre> <p><span class="koboSpan" id="kobo.503.1">But also, this somewhat more precisely named variable still leaves </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">some doubt:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.505.1">
int elapsed;</span></pre> <p><span class="koboSpan" id="kobo.506.1">It should be elapsed... </span><span class="koboSpan" id="kobo.506.2">time, OK, but what’s the measurement unit? </span><span class="koboSpan" id="kobo.506.3">By using the following name for the same variable, its purpose </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">becomes evident:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.508.1">
int elapsedTimeInMillis;</span></pre> <p><span class="koboSpan" id="kobo.509.1">Our personal opinion on the length of variable names is that I prefer them to be longer rather than too short. </span><span class="koboSpan" id="kobo.509.2">It would be ideal to find a middle ground, but it’s not always possible. </span><span class="koboSpan" id="kobo.509.3">Between the two extremes, I lean towards longer names as they enhance readability. </span><span class="koboSpan" id="kobo.509.4">However, it’s important to note that lengthy names can sometimes indicate </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">underlying issues.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">To summarize, we quickly reviewed what Clean Code is. </span><span class="koboSpan" id="kobo.511.2">There are entire books, online courses, and company workshops dedicated to this topic... </span><span class="koboSpan" id="kobo.511.3">in short, there is a whole world around it, and I don’t expect these few lines to cover everything. </span><span class="koboSpan" id="kobo.511.4">My invitation, as usual, is to delve into it as much as possible. </span><span class="koboSpan" id="kobo.511.5">There are still people out there who consider Clean Code as an accessory, something that wastes time because the code works even when it’s not clean. </span><span class="koboSpan" id="kobo.511.6">I hope I conveyed the concept that things don’t work that way </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.512.1">and that good and clean code brings numerous advantages with relatively low effort if approached methodically. </span><span class="koboSpan" id="kobo.512.2">In the next section, we will add another adjective to our code: after good and clean, we will see what is meant by </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.513.1">SOLID</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.514.1"> code!</span></span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.515.1">Write SOLID code</span></h1>
<p><span class="koboSpan" id="kobo.516.1">If there’s one thing the software engineering community excels at, it’s coming up with cool acronyms! </span><span class="koboSpan" id="kobo.516.2">That’s exactly what Michael Feathers did when he took inspiration from a paper by </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.517.1">the ever-present Robert C. </span><span class="koboSpan" id="kobo.517.2">Martin (aka Uncle Bob) and came up with the term </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">SOLID principles</span></strong><span class="koboSpan" id="kobo.519.1">. </span><span class="koboSpan" id="kobo.519.2">In his essay, Martin recognized that software evolves and gets more complicated over time. </span><span class="koboSpan" id="kobo.519.3">But without good design principles, he warned that software becomes rigid, fragile, and hard to work with. </span><span class="koboSpan" id="kobo.519.4">That’s where the SOLID principles come in—they were created to tackle these issues head-on and make software development easier and </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">more flexible.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">The acronym SOLID represents five fundamental </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">design principles:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.523.1">Single Responsibility </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.524.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.525.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.526.1">SRP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.528.1">Open-closed principle</span></span></li>
<li><span class="koboSpan" id="kobo.529.1">Liskov </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">substitution principle</span></span></li>
<li><span class="koboSpan" id="kobo.531.1">Interface </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">segregation principle</span></span></li>
<li><span class="koboSpan" id="kobo.533.1">Dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">inversion principle</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.535.1">These principles are widely adopted by software engineers and offer significant advantages for developers. </span><span class="koboSpan" id="kobo.535.2">Please note that, unlike what is explained in the other sections, the SOLID principles apply only to </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">object-oriented languages.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.537.1">Single responsibility principle</span></h2>
<p><span class="koboSpan" id="kobo.538.1">The </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.539.1">essence of the SRP, as eloquently </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.540.1">stated by Robert Martin, is that “</span><em class="italic"><span class="koboSpan" id="kobo.541.1">a class should have one, and only one, reason to change</span></em><span class="koboSpan" id="kobo.542.1">.” </span><span class="koboSpan" id="kobo.542.2">By adhering to this principle, each class focuses on a specific task, ensuring that every class, module, or component in the software system has a clear responsibility. </span><span class="koboSpan" id="kobo.542.3">In simpler terms, each class should address a </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">single problem.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">The single responsibility principle is a fundamental concept already employed by most developers when writing code. </span><span class="koboSpan" id="kobo.544.2">It can be applied to various levels, such as classes, software components, </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">or microservices.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">By following </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.547.1">this principle, several benefits arise: code </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.548.1">becomes easier to test and maintain, software implementation becomes more straightforward, and it helps prevent unexpected side effects when making </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">future changes.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">Maybe it’s worth providing </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.552.1">
public class User {
    private String username;
    private String password;
    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }
}
public class UserManager {
    public void saveUserToDatabase() {
        // Code to save the user to the database
        // This method is responsible for persistence
    }
    public void sendEmailToUser(String message) {
        // Code to send an email to the user
        // This method is responsible for email sending
    }
}</span></pre> <p><span class="koboSpan" id="kobo.553.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">UserManager</span></strong><span class="koboSpan" id="kobo.555.1"> class violates the SRP by having two distinct responsibilities: saving the user to the database and sending emails to the user. </span><span class="koboSpan" id="kobo.555.2">Ideally, each class should have only </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">one responsibility.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">To address </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.558.1">the SRP violation, we can refactor </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.559.1">the code by separating the concerns into different classes. </span><span class="koboSpan" id="kobo.559.2">Here’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">possible refactoring:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.561.1">
public class User {
    private String username;
    private String password;
    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }
}
public class UserRepository {
    public void saveUserToDatabase(User user) {
        // Code to save the user to the database
    }
}
public class EmailService {
    public void sendEmailToUser(User user, String message){
        // Code to send an email to the user
    }
}</span></pre> <p><span class="koboSpan" id="kobo.562.1">In this refactored code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">UserRepository</span></strong><span class="koboSpan" id="kobo.564.1"> class is responsible for handling persistence logic, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">EmailService</span></strong><span class="koboSpan" id="kobo.566.1"> class handles email communication. </span><span class="koboSpan" id="kobo.566.2">By separating these concerns into different classes, we adhere to the SRP and make the code more maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">and flexible.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.568.1">Open-closed principle</span></h2>
<p><span class="koboSpan" id="kobo.569.1">The concept </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.570.1">behind the open-closed principle is that when new functionality needs to be added, it’s preferable to extend existing, well-tested classes </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.571.1">rather than modify them. </span><span class="koboSpan" id="kobo.571.2">Making changes to classes can introduce issues or bugs. </span><span class="koboSpan" id="kobo.571.3">The goal is to be able to enhance a class’s behavior without altering its </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">original implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">Adhering to this principle is crucial for developing code that is easily maintainable and adaptable. </span><span class="koboSpan" id="kobo.573.2">A class follows the open-closed principle if it satisfies the </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">following conditions:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.575.1">Open for extension</span></strong><span class="koboSpan" id="kobo.576.1">: The </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.577.1">class’s behavior can be extended </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">or augmented</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.579.1">Closed for modification</span></strong><span class="koboSpan" id="kobo.580.1">: The </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.581.1">source code of the class remains unchanged and is not </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">directly modified</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.583.1">At first glance, these two criteria might appear contradictory, but as you become more familiar with the principle, you’ll realize that it’s not as complex as it </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">initially seems.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">To follow these principles and make sure your class can be easily extended without changing the code, you need to use abstractions. </span><span class="koboSpan" id="kobo.585.2">Inheritance or interfaces that allow for different implementations are commonly used to meet this requirement. </span><span class="koboSpan" id="kobo.585.3">No matter which method you choose, it’s important to stick to this principle so that your code remains easy to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">and update.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">Let’s say you work for a travel e-commerce company that sells various modes of transportation. </span><span class="koboSpan" id="kobo.587.2">With a focus on environmental sustainability, you decide to display the CO2 emissions for each mode of transport. </span><span class="koboSpan" id="kobo.587.3">Currently, you handle airplanes </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">and trains.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">We decided to have the following interface </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">and classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
public interface Co2Calculator{
    Integer calculateCo2Tons();
}
public class AirplaneCo2Calculator implements
    Co2Calculator{
    @Override
    public Integer calculateCo2Tons(){
       //...calculates...
</span><span class="koboSpan" id="kobo.591.2">    }
}
public class TrainCo2Calculator implements Co2Calculator{
    @Override
    public Integer calculateCo2Tons(){
        //...calculates...
</span><span class="koboSpan" id="kobo.591.3">    }
}</span></pre> <p><span class="koboSpan" id="kobo.592.1">We have </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.593.1">two implementations of </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">Co2Calculator</span></strong><span class="koboSpan" id="kobo.595.1">, one used for </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.596.1">planes and one for trains. </span><span class="koboSpan" id="kobo.596.2">Each of them implements, of course, the same method. </span><span class="koboSpan" id="kobo.596.3">This interface would be used in another class – let’s call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">EmissionCalculator</span></strong><span class="koboSpan" id="kobo.598.1">, in </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">this way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.600.1">
public class EmissionCalculator {
    public Integer calculateEmissions(Co2Calculator
        calculator) {
               return calculator.calculateCo2Tons();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.601.1">Should we decide to introduce a new transportation mode, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">Bus</span></strong><span class="koboSpan" id="kobo.603.1">, it would be easy </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">to do:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.605.1">
public class BusCo2Calculator implements Co2Calculator{
    @Override
    public Integer calculateCo2Tons(){
        //...calculates...
</span><span class="koboSpan" id="kobo.605.2">    }
}</span></pre> <p><span class="koboSpan" id="kobo.606.1">None of </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.607.1">the existing code has been touched. </span><span class="koboSpan" id="kobo.607.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">EmissionCalculator</span></strong><span class="koboSpan" id="kobo.609.1"> class doesn’t need to implement new logic when we </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.610.1">introduce a new </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">transportation mode.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.612.1">Liskov substitution principle</span></h2>
<p><span class="koboSpan" id="kobo.613.1">Among the five SOLID principles, the Liskov substitution principle can be challenging to grasp. </span><span class="koboSpan" id="kobo.613.2">In essence, this principle states that any derived class should be capable of replacing </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.614.1">its parent class without causing any issues. </span><span class="koboSpan" id="kobo.614.2">Simply put, if class </span><em class="italic"><span class="koboSpan" id="kobo.615.1">A</span></em><span class="koboSpan" id="kobo.616.1"> is a subtype of class </span><em class="italic"><span class="koboSpan" id="kobo.617.1">B</span></em><span class="koboSpan" id="kobo.618.1">, we should be able to replace </span><em class="italic"><span class="koboSpan" id="kobo.619.1">B</span></em><span class="koboSpan" id="kobo.620.1"> with </span><em class="italic"><span class="koboSpan" id="kobo.621.1">A</span></em><span class="koboSpan" id="kobo.622.1"> without </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.623.1">disrupting the behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">our program.</span></span></p>
<p><span class="koboSpan" id="kobo.625.1">For a very trivial example, let’s suppose we must model vehicles (for simplicity, I’m omitting constructors, getters, </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">and setters):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
public class Vehicle {
    public void startEngine();
}
public class Airplane extends Vehicle {
    private AirplaneEngine engine;
    @Override
    public void startEngine(){
        engine.start();
    }
}
public class Train extends Vehicle {
    private TrainEngine engine;
    @Override
    public void startEngine(){
        engine.start();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.628.1">Introducing </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.629.1">a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">Bicycle</span></strong><span class="koboSpan" id="kobo.631.1"> entity and </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.632.1">making it extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">Vehicle</span></strong><span class="koboSpan" id="kobo.634.1"> class would violate </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">the principle:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.636.1">
public class Bicycle extends Vehicle {
    @Override
    public void startEngine(){
        throw new UnsupportedOperationException(
            "Bicycles do not have engines!");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.637.1">In this code, we are forced to implement the method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">Vehicle</span></strong><span class="koboSpan" id="kobo.639.1"> interface, but we are also unable to do it because, you know, bicycles have no engine! </span><span class="koboSpan" id="kobo.639.2">So we’re forced to cause disruption, for example, throwing an exception. </span><span class="koboSpan" id="kobo.639.3">We would not be able to replace a vehicle with a bike without disrupting the behavior of our program, violating the </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">Liskov principle.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.641.1">Interface segregation principle</span></h2>
<p><span class="koboSpan" id="kobo.642.1">The main </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.643.1">idea behind the </span><strong class="bold"><span class="koboSpan" id="kobo.644.1">Interface Segregation Principle</span></strong><span class="koboSpan" id="kobo.645.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.646.1">ISP</span></strong><span class="koboSpan" id="kobo.647.1">) is to have many small interfaces rather than a few big ones. </span><span class="koboSpan" id="kobo.647.2">According to Martin, “</span><em class="italic"><span class="koboSpan" id="kobo.648.1">Make fine grained interfaces that are client-specific. </span><span class="koboSpan" id="kobo.648.2">Clients should not be forced to implement interfaces they do </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.649.1">not use.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.651.1">For software engineers, this means you shouldn’t just add new methods to an existing interface. </span><span class="koboSpan" id="kobo.651.2">Instead, start fresh and build new interfaces tailored to each client’s needs. </span><span class="koboSpan" id="kobo.651.3">Using </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.652.1">smaller interfaces encourages composition over inheritance and promotes loose coupling. </span><span class="koboSpan" id="kobo.652.2">If an interface is too big, it’s better to break it down into smaller ones. </span><span class="koboSpan" id="kobo.652.3">That way, classes implementing those interfaces just have to worry about the methods they actually </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">care about.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">Let’s suppose we have the usual transportation selling system, and we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">following interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.656.1">
public interface FlightManager {
    Long calculateDistance();
    Long calculateEmissions();
    Double calculatePrice();
}</span></pre> <p><span class="koboSpan" id="kobo.657.1">This interface seems pretty big, and the fact that its name ends with “</span><em class="italic"><span class="koboSpan" id="kobo.658.1">manager</span></em><span class="koboSpan" id="kobo.659.1">” is too generic and could be a problem (because it lacks specificity and doesn’t provide clear information about the responsibilities or purpose of the class or component). </span><span class="koboSpan" id="kobo.659.2">It covers a lot of different things. </span><span class="koboSpan" id="kobo.659.3">If you were to implement it in a class, you’d have to handle a bunch of different stuff, each with its own level </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">of importance.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">What about splitting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">FlightManager</span></strong><span class="koboSpan" id="kobo.663.1"> interface into three specific “calculators”, one for </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">each concern?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
public interface FlightDistanceCalculator {
    Long calculateDistance();
}
public interface FlightEmissionCalculator {
    Long calculateEmissions();
}
public interface FlightPriceCalculator {
    Double calculatePrice();
}</span></pre> <p><span class="koboSpan" id="kobo.666.1">By doing this, we </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.667.1">can have greater </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.668.1">flexibility in deciding which classes will implement </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">specific interfaces:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.670.1">
public class FlightStatisticsManager implements
    FlightDistanceCalculator, FlightEmissionsCalculator {
    public Long calculateDistance() {
        //implementation here
    }
    public Long calculateEmissions () {
        //implementation here
    }
}
public class FlightPricer implements FlightPriceCalculator{
    public Double calculatePrice() {
        //implementation here
    }
}</span></pre> <p><span class="koboSpan" id="kobo.671.1">Now, each specific class only implements the required method(s) and isn’t aware of anything that is not its </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">particular concern.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.673.1">Dependency inversion principle</span></h2>
<p><span class="koboSpan" id="kobo.674.1">This principle helps separate software components. </span><span class="koboSpan" id="kobo.674.2">Basically, the dependency inversion principle </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.675.1">suggests that developers should “</span><em class="italic"><span class="koboSpan" id="kobo.676.1">depend on general concepts, not specific implementations.</span></em><span class="koboSpan" id="kobo.677.1">” Martin also explains that “</span><em class="italic"><span class="koboSpan" id="kobo.678.1">higher-level modules should not rely on lower-level modules. </span><span class="koboSpan" id="kobo.678.2">Both should rely on abstract concepts.</span></em><span class="koboSpan" id="kobo.679.1">” Additionally, </span><em class="italic"><span class="koboSpan" id="kobo.680.1">“abstract concepts should not rely on specific details. </span><span class="koboSpan" id="kobo.680.2">Details should rely on </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.681.1">abstract concepts.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">A common </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.684.1">approach to following this principle is to use a dependency inversion pattern, but that’s not the only way to </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">achieve it.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">To test this principle, let’s suppose we have a (simplified) </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">LocationCatalog</span></strong><span class="koboSpan" id="kobo.688.1"> class, which handles all of the queries about locations in a system. </span><span class="koboSpan" id="kobo.688.2">This class takes the “location dictionary” from a </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">database repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
public class LocationCatalog {
    private final LocationDatabaseRepository
        locationRepository;
    public LocationCatalog() {
        this.locationRepository = new
            LocationDatabaseRepository();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.691.1">This code will function correctly, allowing us to utilize </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">LocationDatabaseRepository</span></strong><span class="koboSpan" id="kobo.693.1"> without limitations in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">LocationCatalog</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.695.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.696.1">So everything’s OK now? </span><span class="koboSpan" id="kobo.696.2">Not quite. </span><span class="koboSpan" id="kobo.696.3">There’s an issue, and it lies in tightly coupling these three classes together when declaring </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">locationRepository</span></strong><span class="koboSpan" id="kobo.698.1"> with the new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">LocationDatabaseRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">This not only makes it difficult to test our </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">LocationCatalog</span></strong><span class="koboSpan" id="kobo.703.1"> class, but it also eliminates </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.704.1">the possibility of easily </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.705.1">swapping out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">LocationDatabaseRepository</span></strong><span class="koboSpan" id="kobo.707.1"> class for a different one </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">To address this, let’s decouple our location manager from </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">LocationDatabaseRepository</span></strong><span class="koboSpan" id="kobo.711.1"> by introducing a more generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">LocationRepository</span></strong><span class="koboSpan" id="kobo.713.1"> interface and incorporating it into </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">our class.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.715.1">
public interface LocationRepository{ }
public class LocationCatalog{
    private final LocationRepository locationRepository;
    public LocationCatalog (LocationRepository
        locationRepository) {
        this. </span><span class="koboSpan" id="kobo.715.2">locationRepository = locationRepository;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.716.1">We have successfully eliminated the dependency and now have the freedom to choose any source for our location, be it a file, an external service, or a mocked implementation (particularly useful for </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">testing purposes).</span></span></p>
<p><span class="koboSpan" id="kobo.718.1">Now we have a good foundation in writing good code: we know what it is, we know about Clean Code, and we know that good code is also SOLID code. </span><span class="koboSpan" id="kobo.718.2">Next, let’s consider the reliability of code and the fact that reliable code does not produce unwanted effects, also known as </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">side effects.</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.720.1">Side effects and mutability</span></h1>
<p><span class="koboSpan" id="kobo.721.1">When </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.722.1">something is immutable, it means its </span><em class="italic"><span class="koboSpan" id="kobo.723.1">state</span></em><span class="koboSpan" id="kobo.724.1"> can’t be changed once it’s created. </span><span class="koboSpan" id="kobo.724.2">Understanding why immutability is a good thing involves recognizing the problems that can arise from </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">its opposite—mutability.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">There are several downsides to having mutable objects or, in general, in being forced to handle mutability (and thus, handling </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">objects’ state).</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">A mutable class that has setup functions can easily be misconfigured, leading to an invalid state; this is a sort of addendum (a </span><em class="italic"><span class="koboSpan" id="kobo.729.1">spin-off</span></em><span class="koboSpan" id="kobo.730.1">) to what we said before (“</span><em class="italic"><span class="koboSpan" id="kobo.731.1">good code is hard to misuse</span></em><span class="koboSpan" id="kobo.732.1">”). </span><span class="koboSpan" id="kobo.732.2">If you allow a class to have some kind of really detailed and complicated setup functions, it will be more likely to misuse it, ending up with a wrong or invalid configuration that will end in some malfunctioning in </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">Another big issue </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.735.1">with mutable objects arises when you think about thread safety, a critical concern in multi-threaded or parallel programming because multiple threads can access and modify shared data simultaneously. </span><span class="koboSpan" id="kobo.735.2">For more information about what thread safety is, there’s an entry in the </span><em class="italic"><span class="koboSpan" id="kobo.736.1">Further reading</span></em><span class="koboSpan" id="kobo.737.1"> section. </span><span class="koboSpan" id="kobo.737.2">Mutable objects are not thread-safe because they can be modified by multiple threads concurrently without proper synchronization, leading to unpredictable and potentially </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">incorrect behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.739.1">However the real problem with mutability occurs when a function messes with the input parameters. </span><span class="koboSpan" id="kobo.739.2">It’s like lending something to a friend. </span><span class="koboSpan" id="kobo.739.3">When you lend something, you don’t want it to get messed up because you might need it later or want to lend it to someone else (think of a book, a bike, or your favorite Batman action figure). </span><span class="koboSpan" id="kobo.739.4">That function holds important information that the function needs, but you might still need it for other things after the function </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">is done.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">If a function starts changing the input parameter, it’s like scratching your bike or ruining your Batman action figure. </span><span class="koboSpan" id="kobo.741.2">Usually, when you pass an object to a function, you expect it to be borrowed and returned as it is. </span><span class="koboSpan" id="kobo.741.3">But if the function goes ahead and messes with it, that’s not cool. </span><span class="koboSpan" id="kobo.741.4">Changing an input parameter is a side effect because it affects something outside the function itself. </span><span class="koboSpan" id="kobo.741.5">Typically, functions take inputs through parameters and give back results through </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">return values.</span></span></p>
<p><span class="koboSpan" id="kobo.743.1">For most engineers, modifying an input parameter is an unexpected side effect that can lead to surprises and confusion. </span><span class="koboSpan" id="kobo.743.2">So, it’s best to avoid messing with borrowed objects and stick to the convention of using parameters for inputs and return values </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">for results.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">A good way to make code non-misusable is to use immutable objects. </span><span class="koboSpan" id="kobo.745.2">In Java specifically, a typical immutable object would contain just the fields (with the final modifier), a constructor, and – optionally – </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">the getters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.747.1">
public class Student {
    private final String name;
    private final String surname;
    public Student(String name, String surname) {
        this.name = name;
        this.surname = surname;
    }
    public String getName() {
        return name;
    }
    public String getSurname() {
        return surname;
    }
    //... </span><span class="koboSpan" id="kobo.747.2">toString(), hashCode(), equals(), etc...
</span><span class="koboSpan" id="kobo.747.3">}</span></pre> <p><span class="koboSpan" id="kobo.748.1">This object </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.749.1">is indeed immutable, and it follows a common pattern for implementing immutability. </span><span class="koboSpan" id="kobo.749.2">All of its properties are declared as </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">final</span></strong><span class="koboSpan" id="kobo.751.1">, meaning they cannot be modified after they are initialized. </span><span class="koboSpan" id="kobo.751.2">The properties are typically declared in a constructor, which may or may not require all of these parameters, depending on the specific requirements. </span><span class="koboSpan" id="kobo.751.3">This object does not provide setter methods, as attempting to do so would result in a compilation error due to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">final</span></strong><span class="koboSpan" id="kobo.753.1"> fields. </span><span class="koboSpan" id="kobo.753.2">However, it does provide getters for accessing the property values, but this can vary depending on your specific needs. </span><span class="koboSpan" id="kobo.753.3">It should be evident that once this object is created, it cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">be modified.</span></span></p>
<p><span class="koboSpan" id="kobo.755.1">Of course, the same aim can be achieved in a much simpler way using a Java record (introduced in </span><strong class="bold"><span class="koboSpan" id="kobo.756.1">Java 14</span></strong><span class="koboSpan" id="kobo.757.1">), but that would be a bit out of scope here. </span><span class="koboSpan" id="kobo.757.2">The goal is to promote immutability; this implementation is just an example. </span><span class="koboSpan" id="kobo.757.3">There's also the builder pattern that we'll introduce in the </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.759.1">Another really common example in Java is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">String</span></strong><span class="koboSpan" id="kobo.761.1"> class. </span><span class="koboSpan" id="kobo.761.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">String</span></strong><span class="koboSpan" id="kobo.763.1"> object always represents the same string. </span><span class="koboSpan" id="kobo.763.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">String</span></strong><span class="koboSpan" id="kobo.765.1"> is immutable, once created, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">String</span></strong><span class="koboSpan" id="kobo.767.1"> object always has the same value. </span><span class="koboSpan" id="kobo.767.2">To add something to the end of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">String</span></strong><span class="koboSpan" id="kobo.769.1">, you have to create a new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">String</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.771.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.772.1">
String s = "a"; // Creates a String object with the value
    "a"
s = s.concat("b"); // Creates a new String object with the
    value "ab"
// The below two operations also result in the creation of
    new String objects:
// s += "b";
// s = s + "b";</span></pre> <p><span class="koboSpan" id="kobo.773.1">In general, to make </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.774.1">a class immutable, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">these rules:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.776.1">Don’t provide any methods that modify the state of your object (</span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">aka mutators).</span></span></li>
<li><span class="koboSpan" id="kobo.778.1">Ensure that the class can’t be extended (this is mostly done by making </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">final</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.782.1">Make all fields </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">final</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.784.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">private</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.787.1">Ensure exclusive access to any mutable components: it can happen that a field of your class is defined as a mutable object. </span><span class="koboSpan" id="kobo.787.2">In this case, be sure that a client cannot obtain references to this object. </span><span class="koboSpan" id="kobo.787.3">Initialize it </span><em class="italic"><span class="koboSpan" id="kobo.788.1">inside</span></em><span class="koboSpan" id="kobo.789.1"> your class and make defensive copies in constructors </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">and accessors.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.791.1">You could argue: OK, but I just have that one use case in which I </span><em class="italic"><span class="koboSpan" id="kobo.792.1">must</span></em><span class="koboSpan" id="kobo.793.1"> create an object and then change it. </span><span class="koboSpan" id="kobo.793.2">A typical example is when you have to create an object and fill its fields in different steps. </span><span class="koboSpan" id="kobo.793.3">My suggestion here is to use the builder </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">pattern instead.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.795.1">The builder pattern</span></h2>
<p><span class="koboSpan" id="kobo.796.1">A builder is a </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.797.1">design pattern commonly used in object-oriented programming to construct complex objects step by step. </span><span class="koboSpan" id="kobo.797.2">It provides a flexible and readable way to create objects with multiple optional parameters or configurations. </span><span class="koboSpan" id="kobo.797.3">The builder pattern separates the construction of an object from its representation, allowing the same construction process to create different representations of the object. </span><span class="koboSpan" id="kobo.797.4">It provides a clear and intuitive API for constructing objects by providing methods to set values for various properties or parameters. </span><span class="koboSpan" id="kobo.797.5">Typically, a builder class is created for each complex object, and it contains methods to set individual properties or configurations of the object. </span><span class="koboSpan" id="kobo.797.6">The builder accumulates these settings and finally constructs the object when requested. </span><span class="koboSpan" id="kobo.797.7">This approach allows for more readable and maintainable code, especially when </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.798.1">dealing with objects that have many optional parameters or configurations. </span><span class="koboSpan" id="kobo.798.2">It promotes the idea of </span><em class="italic"><span class="koboSpan" id="kobo.799.1">fluent</span></em><span class="koboSpan" id="kobo.800.1"> or chainable method calls, where each method returns the builder instance itself, allowing for a more concise and readable </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">construction syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.802.1">Let’s use a builder to create </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">a “student”:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.804.1">
public class StudentBuilder {
    private String name;
    private String surname;
    public StudentBuilder() {
        // Default constructor
    }
    public StudentBuilder withName(String name) {
        this.name = name;
        return this;
    }
    public StudentBuilder withSurname(String surname) {
        this.surname = surname;
        return this;
    }
    public Student build() {
        return new Student(name, surname);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.805.1">The class provides a default constructor, which doesn’t take any parameters. </span><span class="koboSpan" id="kobo.805.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">StudentBuilder</span></strong><span class="koboSpan" id="kobo.807.1"> class also provides two setter-like methods: </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">withName(String name)</span></strong><span class="koboSpan" id="kobo.809.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">withSurname(String surname)</span></strong><span class="koboSpan" id="kobo.811.1">. </span><span class="koboSpan" id="kobo.811.2">These methods allow setting the name and surname properties of the student, respectively. </span><span class="koboSpan" id="kobo.811.3">Each setter-like method updates the corresponding property of the builder instance and returns the builder object itself (</span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">this</span></strong><span class="koboSpan" id="kobo.813.1">) to support method chaining. </span><span class="koboSpan" id="kobo.813.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">build()</span></strong><span class="koboSpan" id="kobo.815.1"> method is used to construct and return a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">Student</span></strong><span class="koboSpan" id="kobo.817.1"> object using the values set in the builder. </span><span class="koboSpan" id="kobo.817.2">It creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">Student</span></strong><span class="koboSpan" id="kobo.819.1"> instance with the name and surname obtained from the builder and </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.820.1">returns the constructed object. </span><span class="koboSpan" id="kobo.820.2">With this builder class, you can construct a </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">Student</span></strong><span class="koboSpan" id="kobo.822.1"> object step by step, setting the name and surname values as needed. </span><span class="koboSpan" id="kobo.822.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.824.1">
Student student = new StudentBuilder()
    .withName("John")
    .withSurname("Doe")
    .build();</span></pre> <p><span class="koboSpan" id="kobo.825.1">This code creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">Student</span></strong><span class="koboSpan" id="kobo.827.1"> object with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">"John"</span></strong><span class="koboSpan" id="kobo.829.1"> and surname </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">"Doe"</span></strong><span class="koboSpan" id="kobo.831.1"> using the builder pattern. </span><span class="koboSpan" id="kobo.831.2">By chaining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">withName()</span></strong><span class="koboSpan" id="kobo.833.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">withSurname()</span></strong><span class="koboSpan" id="kobo.835.1"> methods, you can set the desired values for the name and surname properties, respectively. </span><span class="koboSpan" id="kobo.835.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">build()</span></strong><span class="koboSpan" id="kobo.837.1"> method constructs and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">Student</span></strong><span class="koboSpan" id="kobo.839.1"> object with the </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">provided values.</span></span></p>
<p><span class="koboSpan" id="kobo.841.1">This might seem a bit inconsistent with the message we provided earlier, the one regarding long chains of calls. </span><span class="koboSpan" id="kobo.841.2">However, in my opinion, this is a special case where we are simply constructing an object: there is no logic, the return type is always the same, and the alternatives would be equally complex, or worse – a long sequence of “set” methods and/or a constructor with </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">many parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.843.1">The builder can be implemented in slightly different ways, and what’s more, it can be automated. </span><span class="koboSpan" id="kobo.843.2">You have the option to use IDE plugins or metaprogramming libraries such as Lombok. </span><span class="koboSpan" id="kobo.843.3">We will discuss these alternatives later on in </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.845.1">I hope that, up to this point, I have provided you with some small tools to help combat bad code; not an exhaustive list, but I hope to have at least sparked curiosity. </span><span class="koboSpan" id="kobo.845.2">Another thing I have always wondered is: why does bad code exist? </span><span class="koboSpan" id="kobo.845.3">Assuming it is not due to laziness or incompetence of individuals, let’s quickly explore some contingent causes that contribute to the situation we are trying </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">to address.</span></span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.847.1">Causes of bad code</span></h1>
<p><span class="koboSpan" id="kobo.848.1">As I mentioned in the previous chapter, I don’t have the intention of blaming those who write bad code. </span><span class="koboSpan" id="kobo.848.2">I myself have written bad code; it has happened in the past, it still happens, and it will happen again (I can already imagine my colleagues nodding as they read these lines!). </span><span class="koboSpan" id="kobo.848.3">In the vast majority of cases, those who write bad code do so without realizing it because </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.849.1">we are human and can only handle a certain number of tasks at once. </span><span class="koboSpan" id="kobo.849.2">In our hearts, we have the desire to do a good job, something to be proud of, but in our minds, we have deadlines, and pressure, and we generally work within an ecosystem that we don’t fully control. </span><span class="koboSpan" id="kobo.849.3">Very often, companies are complex systems that may have clear rules (for example, regarding the methodologies to follow), but they have to deal with an increasingly hectic world, with time-to-market pressures, and the need to compete fiercely. </span><span class="koboSpan" id="kobo.849.4">There’s a way things should be and the way they actually are. </span><span class="koboSpan" id="kobo.849.5">As software engineers, we guide or support the work of the company and often find ourselves interacting with mentalities and needs that are very different from our own. </span><span class="koboSpan" id="kobo.849.6">Sometimes, the result is sacrificing quality and experiencing a bit of frustration. </span><span class="koboSpan" id="kobo.849.7">Almost always, this leads to having a bad code base. </span><span class="koboSpan" id="kobo.849.8">But why does this happen? </span><span class="koboSpan" id="kobo.849.9">If we could identify some common causes of bad code, maybe we’d be able to recognize them and </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">avoid them.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.851.1">Deadlines</span></h2>
<p><span class="koboSpan" id="kobo.852.1">This is definitely going to be a controversial point. </span><span class="koboSpan" id="kobo.852.2">For many, blaming deadlines as the cause of bad </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.853.1">code is just an excuse to hide laziness or incompetence. </span><span class="koboSpan" id="kobo.853.2">It’s not true that there’s no time; it’s just that you don’t want to put in the effort to think and do things properly. </span><span class="koboSpan" id="kobo.853.3">In some cases, that may very well be true. </span><span class="koboSpan" id="kobo.853.4">Over the years, though, I’ve often observed – although I must say, not always and to a lesser extent as time goes on – a disconnect between management and engineers. </span><span class="koboSpan" id="kobo.853.5">There’s often a tendency to “sell” the solution without paying much attention to how long it will actually take to implement it. </span><span class="koboSpan" id="kobo.853.6">As a result, developers end up not negotiating a deadline but simply being subjected to it. </span><span class="koboSpan" id="kobo.853.7">So they take shortcuts, maybe cut back on testing, documentation, and overall quality (violating some of the principles seen so far, such as keeping code readable or </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">without repetitions).</span></span></p>
<p><span class="koboSpan" id="kobo.855.1">On this matter, I’d advise you to take a look at what’s called the </span><em class="italic"><span class="koboSpan" id="kobo.856.1">project </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.857.1">management triangle</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.859.1"><img alt="Figure 2.3 – The project management triangle" src="image/B20912_02_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.860.1">Figure 2.3 – The project management triangle</span></p>
<p><span class="koboSpan" id="kobo.861.1">It’s like an equilateral triangle with sides representing the </span><strong class="bold"><span class="koboSpan" id="kobo.862.1">Scope</span></strong><span class="koboSpan" id="kobo.863.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.864.1">Cost</span></strong><span class="koboSpan" id="kobo.865.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">Time</span></strong><span class="koboSpan" id="kobo.867.1"> of a project. </span><span class="koboSpan" id="kobo.867.2">These three dimensions are interconnected, and changing one of them will affect the </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.868.1">overall shape of the triangle, which represents the quality. </span><span class="koboSpan" id="kobo.868.2">Furthermore, since the triangle needs to remain equilateral, it’s clear that modifying the available time will decrease the cost, and vice versa. </span><span class="koboSpan" id="kobo.868.3">By extending the time available, you can increase the project scope, but the costs will also go up accordingly. </span><span class="koboSpan" id="kobo.868.4">It’s a neat metaphor for how projects, including software </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">projects, work.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.870.1">The Broken Window theory</span></h2>
<p><span class="koboSpan" id="kobo.871.1">Here’s another thing to consider: the Broken Window theory. </span><span class="koboSpan" id="kobo.871.2">Philip Zimbardo, a psychologist from Stanford, did a very interesting study: he parked a car in a fancy neighborhood </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.872.1">for a couple of days and just watched it. </span><span class="koboSpan" id="kobo.872.2">Surprisingly, nothing happened. </span><span class="koboSpan" id="kobo.872.3">He waited and waited, but nobody touched the car. </span><span class="koboSpan" id="kobo.872.4">Then, he decided to break a small window to see if things would change. </span><span class="koboSpan" id="kobo.872.5">Within just a few hours, the car was completely stripped; everything was gone – tires, wheels, electronics, steering wheel, seats, mats, even the engine. </span><span class="koboSpan" id="kobo.872.6">All that was left was a bare-bones car sitting on </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">cinder blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.874.1">Now, the same kind of thing can happen with code. </span><span class="koboSpan" id="kobo.874.2">You start off with a clean situation; everything’s looking good. </span><span class="koboSpan" id="kobo.874.3">But as soon as you introduce one bit of bad code, things can quickly go out of control. </span><span class="koboSpan" id="kobo.874.4">For instance, you ignore code duplication in a few places, leave inconsistent formatting, and tolerate inconsistent variable naming. </span><span class="koboSpan" id="kobo.874.5">Again, you can start adding code without the proper test coverage, or you avoid upgrading your project’s dependencies due to fear of issues </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">sneaking in.</span></span></p>
<p><span class="koboSpan" id="kobo.876.1">Initially, these may seem like minor problems, and developers prioritize adding new features or fixing critical bugs instead. </span><span class="koboSpan" id="kobo.876.2">Other team members notice these neglected issues but also follow suit, assuming they are not a high priority. </span><span class="koboSpan" id="kobo.876.3">As developers, we’re already making some mistakes, so why bother doing it right in this case? </span><span class="koboSpan" id="kobo.876.4">Taking shortcuts and doing things the easier, faster way seems tempting. </span><span class="koboSpan" id="kobo.876.5">As time goes on, more developers join the project, and the code base grows larger and more complex. </span><span class="koboSpan" id="kobo.876.6">The neglected </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.877.1">issues start to accumulate, making the code harder to understand and maintain. </span><span class="koboSpan" id="kobo.877.2">The lack of consistent conventions leads to confusion, reduces code readability, and introduces errors. </span><span class="koboSpan" id="kobo.877.3">Additionally, because the existing issues were not addressed, developers may feel less motivated to maintain code quality. </span><span class="koboSpan" id="kobo.877.4">They might think, “If there are already duplicated code snippets, what harm can a few more do?”. Eventually, the code base becomes a tangled mess of poorly organized, duplicated, and hard-to-read code. </span><span class="koboSpan" id="kobo.877.5">New developers joining the project struggle to make sense of it and find it increasingly difficult to introduce changes without inadvertently introducing bugs or breaking </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">existing functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.879.1">It’s like a snowball effect, and things can get pretty messy in no time. </span><span class="koboSpan" id="kobo.879.2">And this kind of mess can produce technical debt; you re-pay technical debt with slowness in developing </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">new features.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.881.1">No code review process</span></h2>
<p><span class="koboSpan" id="kobo.882.1">When we started programming, maybe back in school, it often happened that we did it alone. </span><span class="koboSpan" id="kobo.882.2">You wrote </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.883.1">the code, tested it in some way, and that was it. </span><span class="koboSpan" id="kobo.883.2">The code and the design only needed to make sense to us and no </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">one else.</span></span></p>
<p><span class="koboSpan" id="kobo.885.1">When working in a team, it’s a good idea to implement code review mechanisms. </span><span class="koboSpan" id="kobo.885.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.886.1">code review</span></strong><span class="koboSpan" id="kobo.887.1"> is the process of reviewing and examining code to improve its quality, identify issues, and ensure adherence to standards – we’ll delve into that in </span><a href="B20912_08.xhtml#_idTextAnchor183"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.888.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.889.1">. </span><span class="koboSpan" id="kobo.889.2">Code reviews are also useful to make the code we write somewhat “consistent” and clear for all team members. </span><span class="koboSpan" id="kobo.889.3">When code reviews are absent, the code can become subject to personal preferences, may contain errors, or have room for improvement in terms of performance. </span><span class="koboSpan" id="kobo.889.4">Some people see the review process as a distraction from business activities; some developers see it as a hindrance to their own tasks. </span><span class="koboSpan" id="kobo.889.5">Sometimes, of course, even reviews cannot address particularly deep-rooted problems. </span><span class="koboSpan" id="kobo.889.6">However, they at least help identify major “issues” that may have slipped past the individual developer, who was focused on solving complex problems. </span><span class="koboSpan" id="kobo.889.7">It happens more often than you </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">might think.</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">In </span><a href="B20912_08.xhtml#_idTextAnchor183"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.892.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.893.1">, we will </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.894.1">introduce the </span><strong class="bold"><span class="koboSpan" id="kobo.895.1">Pair Programming</span></strong><span class="koboSpan" id="kobo.896.1"> practice, which can be used as a substitute for </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">code reviews.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.898.1">Insufficient domain or technical knowledge</span></h2>
<p><span class="koboSpan" id="kobo.899.1">Sometimes, the reason behind bad code is simply that the people who worked on it were not </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.900.1">aware of the application domain or the technologies being used. </span><span class="koboSpan" id="kobo.900.2">These are different aspects but </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">somehow related.</span></span></p>
<p><span class="koboSpan" id="kobo.902.1">When lacking </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.903.1">domain knowledge, it’s easy to misinterpret requirements or write the logic in the wrong place (maybe not knowing that it already exists elsewhere). </span><span class="koboSpan" id="kobo.903.2">The situation gets worse when the code is already messy, and we have to work on it without really knowing what we’re doing. </span><span class="koboSpan" id="kobo.903.3">In this situation, even with the purest of intentions, removing an apparently unused </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">if</span></strong><span class="koboSpan" id="kobo.905.1"> statement or changing how an object is created requires careful consideration (and adequate test coverage, something else we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">tackle later).</span></span></p>
<p><span class="koboSpan" id="kobo.907.1">Knowledge gaps can also be purely technological. </span><span class="koboSpan" id="kobo.907.2">It may be that some of us are new and don’t yet have a clear understanding of the technology stack. </span><span class="koboSpan" id="kobo.907.3">This often leads to overly complex solutions or, on the contrary, workarounds and hacks. </span><span class="koboSpan" id="kobo.907.4">It can happen that the developer lacks certain discipline and the habitual use of good practices that we’ve tried to explain in this chapter. </span><span class="koboSpan" id="kobo.907.5">These practices – contrary to what it may seem – don’t exist to slow us down, but actually enable us to produce high-quality code quickly </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">and consistently.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">We have tried to investigate some of the most common causes of bad code. </span><span class="koboSpan" id="kobo.909.2">I realize that I have relied on my own experience to some extent, but I believe that some of the concepts expressed here are universal and worth considering, such as the Broken Window theory or the project management triangle. </span><span class="koboSpan" id="kobo.909.3">The next time a manager asks you to do something well and in less time, you will hopefully have an additional argument on </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">your side!</span></span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.911.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.912.1">Speaking of refactoring, it is crucial to understand what needs to be refactored; in other words, it is necessary to distinguish good code from bad code. </span><span class="koboSpan" id="kobo.912.2">In this chapter, we have seen what is typically meant by good code, providing an overview of its characteristics. </span><span class="koboSpan" id="kobo.912.3">When these characteristics are lacking, it is likely that refactoring is needed. </span><span class="koboSpan" id="kobo.912.4">When discussing good code, we must also talk about Clean Code; we addressed this topic and learned how to recognize it and, hopefully, write it. </span><span class="koboSpan" id="kobo.912.5">Good code is usually also SOLID code, and we briefly touched upon the meaning of that as well. </span><span class="koboSpan" id="kobo.912.6">Lastly, after understanding what good code is, we investigated some causes of bad code; the hope is that you will be alert if you find yourself in one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">described situations.</span></span></p>
<p><span class="koboSpan" id="kobo.914.1">In the upcoming chapter, we'll address a set of warning signs—elements in your code that should alert you and prompt contemplation on refactoring </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">your code.</span></span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.916.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.917.1">mscharhag, </span><em class="italic"><span class="koboSpan" id="kobo.918.1">ISO 8601 durations in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.919.1">Java</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">: </span></span><a href="https://www.mscharhag.com/java/iso8601-durations"><span class="No-Break"><span class="koboSpan" id="kobo.921.1">https://www.mscharhag.com/java/iso8601-durations</span></span></a></li>
<li><span class="koboSpan" id="kobo.922.1">Tom Long, </span><em class="italic"><span class="koboSpan" id="kobo.923.1">Good Code, Bad </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.924.1">Code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">, Manning</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.926.1">Stop calling it bad code</span></em><span class="koboSpan" id="kobo.927.1">, by Joel </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">Spolsky: </span></span><a href="https://blog.pragmaticengineer.com/bad-code/"><span class="No-Break"><span class="koboSpan" id="kobo.929.1">https://blog.pragmaticengineer.com/bad-code/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.930.1">The law of leaky abstraction</span></em><span class="koboSpan" id="kobo.931.1">, by Joel </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">Spolsky: </span></span><a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/"><span class="No-Break"><span class="koboSpan" id="kobo.933.1">https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.934.1">What does Clean Code </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.935.1">mean?</span></strong></span><span class="No-Break"> </span><a href="https://cogut.medium.com/what-does-clean-code-mean-2190e4aed818"><span class="No-Break"><span class="koboSpan" id="kobo.936.1">https://cogut.medium.com/what-does-clean-code-mean-2190e4aed818</span></span></a></li>
<li><span class="koboSpan" id="kobo.937.1">Robert C Martin, </span><em class="italic"><span class="koboSpan" id="kobo.938.1">Clean Code</span></em><span class="koboSpan" id="kobo.939.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">Prentice-Hall 2009</span></span></li>
<li><span class="koboSpan" id="kobo.941.1">Robert C Martin, </span><em class="italic"><span class="koboSpan" id="kobo.942.1">Design Principles and Design </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.943.1">Patterns</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">: </span></span><a href="http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf"><span class="No-Break"><span class="koboSpan" id="kobo.945.1">http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.946.1">What is thread </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.947.1">safety?</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">: </span></span><a href="https://en.wikipedia.org/wiki/Thread_safety"><span class="No-Break"><span class="koboSpan" id="kobo.949.1">https://en.wikipedia.org/wiki/Thread_safety</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.950.1">The SOLID principles in </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.951.1">pictures</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">: </span></span><a href="https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898"><span class="No-Break"><span class="koboSpan" id="kobo.953.1">https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.954.1">You should break the Law of Demeter</span></em><span class="koboSpan" id="kobo.955.1">, by Ted </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">Kaminski </span></span><a href="https://www.tedinski.com/2018/12/18/the-law-of-demeter.html"><span class="No-Break"><span class="koboSpan" id="kobo.957.1">https://www.tedinski.com/2018/12/18/the-law-of-demeter.html</span></span></a></li>
</ul>
</div>


<div class="Content" id="_idContainer020">
<h1 id="_idParaDest-69" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.1.1">Part 2: Essence of Refactoring and Good Code</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Going through code, especially old code, is a big part of a software developer’s job. </span><span class="koboSpan" id="kobo.2.2">There are certain warning signs, like “red flags,” that professionals should notice right away. </span><span class="koboSpan" id="kobo.2.3">Recognizing and avoiding these issues is an important skill, and in this section, we’ll understand how to </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">spot them.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">Now that we’ve learned what refactoring is and why it’s important, let’s explore a crucial requirement. </span><span class="koboSpan" id="kobo.4.2">Refactoring isn’t safe unless you have really good test coverage. </span><span class="koboSpan" id="kobo.4.3">We’ll find out why having thorough tests </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">is essential.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">Next, how do you actually refactor your code? </span><span class="koboSpan" id="kobo.6.2">There are some common techniques that can be very helpful. </span><span class="koboSpan" id="kobo.6.3">We’ll learn how to </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">master them.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">After that, we’ll delve into metaprogramming. </span><span class="koboSpan" id="kobo.8.2">Instead of manually changing code, metaprogramming techniques can automatically analyze and refactor it. </span><span class="koboSpan" id="kobo.8.3">For example, metaprogramming can generate code, replace method calls, or dynamically modify class structures. </span><span class="koboSpan" id="kobo.8.4">This makes refactoring faster and less prone to errors by reducing the amount of manual </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">work needed.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Lastly, we’ll discuss static and dynamic analysis. </span><span class="koboSpan" id="kobo.10.2">Static analysis involves examining code without running it and identifying issues like code smells and security vulnerabilities. </span><span class="koboSpan" id="kobo.10.3">Dynamic analysis, on the other hand, involves analyzing code by running it, helping find performance bottlenecks and runtime issues like </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">memory leaks.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">following chapters:</span></span></p>
<ul>
<li><a href="B20912_03.xhtml#_idTextAnchor070"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.15.1">, </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Code Smells</span></em></li>
<li><a href="B20912_04.xhtml#_idTextAnchor095"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.18.1">, </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Testing</span></em></li>
<li><a href="B20912_05.xhtml#_idTextAnchor117"><em class="italic"><span class="koboSpan" id="kobo.20.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.21.1">, </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Refactoring Techniques</span></em></li>
<li><a href="B20912_06.xhtml#_idTextAnchor150"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.24.1">, </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Metaprogramming</span></em></li>
<li><a href="B20912_07.xhtml#_idTextAnchor161"><em class="italic"><span class="koboSpan" id="kobo.26.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.27.1">, </span><em class="italic"><span class="koboSpan" id="kobo.28.1">Static and Dynamic Analysis</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer021">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer022">
</div>
</div>
</body></html>