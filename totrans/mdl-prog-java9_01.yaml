- en: Introducing Java 9 Modularity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Java 9模块化
- en: This book covers modularity features in Java 9--an important new change to the
    Java programming language. We'll look at its impact on Java development and how
    you can use it to build powerful modular applications. The Java 9 release also
    comes with a few other changes, such as support for HTTP 2.0 and a shell called
    `jshell` that lets you run Java code snippets in a **Read-Eval-Print-Loop** (**REPL**).
    While these are exciting new changes, they are not the focus of this book. We
    will be primarily focusing on the modularity features, which are arguably the
    most important and powerful among all the new changes with the Java 9 release.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了Java 9中的模块化特性——这是Java编程语言的一个重要新变化。我们将探讨它对Java开发的影响以及如何使用它来构建强大的模块化应用程序。Java
    9的发布还带来了一些其他变化，例如支持HTTP 2.0和一个名为`jshell`的shell，它允许你在**读取-评估-打印-循环**（**REPL**）中运行Java代码片段。虽然这些都是令人兴奋的新变化，但它们并不是本书的重点。我们将主要关注模块化特性，这些特性在Java
    9发布的新变化中可能是最重要和最强大的。
- en: 'This chapter provides an introduction to the new module features in Java 9
    by covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过以下主题介绍了Java 9中的新模块特性：
- en: Examining two important structural and organizational problems when building
    Java applications today, and their implications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查在构建Java应用程序时遇到的两个重要的结构和组织问题，以及它们的影响
- en: Why does Java even need modularity features? What are we missing right now?
    And what do we gain from modularity?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Java甚至需要模块化特性？我们现在缺少什么？模块化能给我们带来什么？
- en: Introducing the **Java Platform Module System** (**JPMS**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍**Java平台模块系统**（**JPMS**）
- en: Understanding the benefits that the Java modular system aims to provide
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Java模块系统旨在提供的优势
- en: Modularity in Java
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的模块化
- en: If you've been a developer for any length of time, you'll have very likely realized
    that the word **module** is perhaps one of the most overused terms in software
    development. A module can mean anything ranging from a group of code entities,
    components, or UI types, to framework elements to complete reusable libraries.
    Sometimes, we use the word to imply multiple meanings in the same context!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是一名开发者一段时间了，你很可能已经意识到“模块”这个词可能是软件开发中最被过度使用的术语之一。模块可以指从一组代码实体、组件或UI类型到框架元素，甚至是完整的可重用库。有时，我们使用这个词在同一语境中暗示多个含义！
- en: 'There is a good reason for that. When writing code, we typically try to break
    the code base down into smaller units in order to manage complexity. For anything
    more than very simple programs, having a monolithic code base is not a good idea.
    That''s why *modular programming* is a generally favored software design approach.
    There are two important goals that modularity in software development usually
    achieves, which are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有充分理由的。在编写代码时，我们通常试图将代码库分解成更小的单元以管理复杂性。对于非常简单的程序之外，拥有一个单体代码库并不是一个好主意。这就是为什么*模块化编程*通常是一个受欢迎的软件开发方法。软件开发的模块化通常实现以下两个重要目标，具体如下：
- en: Divide and conquer approach
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分而治之的方法
- en: What do you do when you need to solve a large and seemingly insurmountable problem?
    *You break it down!* You'll very likely split it into smaller problems and solve
    them individually.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要解决一个庞大且看似无法克服的问题时，你会怎么做？*你将其分解！*你很可能将其拆分成更小的问题并逐一解决。
- en: The principles of modularity encourages separating large code bases into smaller
    encapsulated units of functionality that are then composed to work together as
    a bigger unit. This aligns well with the approach we humans usually take to solve
    large problems. Also, once you've got a bunch of smaller modules with specialized
    concerns, you can use those to solve various other problems. Thus, we also achieve
    *reusability!*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的原则鼓励将大型代码库分解成更小的封装功能单元，然后组合起来作为一个更大的单元协同工作。这很好地符合我们人类通常用来解决大型问题的方法。此外，一旦你拥有了一组具有专门关注点的较小模块，你可以使用这些模块来解决各种其他问题。因此，我们也实现了*可重用性！*
- en: Achieving encapsulation and well-defined interfaces
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现封装和定义良好的接口
- en: When you build modules, you have the ability to hide the internal implementation
    from the consumers of your module. The hidden implementation details are usually
    referred to as being *encapsulated*, and what you expose to the consumers of your
    module is usually called the *interface* of your module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建模块时，你有能力将模块的内部实现隐藏给模块的使用者。这些隐藏的实现细节通常被称为*封装*，而你向模块使用者暴露的部分通常被称为模块的*接口*。
- en: Although Java developers have leveraged many different patterns and best practices
    over the years in order to write and structure modular and maintainable code,
    the language has never had native support to create modular units and build modular
    applications, until Java 9\. With Java 9, Java developers now have the ability
    to create smaller units of code with a new construct called **Java modules** that
    they can group together like building blocks in order to compose larger applications.
    In addition to introducing this feature to the language, Java 9 also comes with
    what is probably the biggest overhaul to the core Java code base itself. The **Java
    Runtime Environment** (**JRE**) and the **Java Development Kit** (**JDK**) have
    been rewritten to use the concepts of modularity so that the core Java Platform
    itself is modularized.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多年来Java开发者已经利用了许多不同的模式和最佳实践来编写和构建模块化和可维护的代码，但Java语言本身从未有过创建模块单元和构建模块化应用程序的原生支持，直到Java
    9。随着Java 9的推出，Java开发者现在可以使用一种称为**Java模块**的新结构来创建更小的代码单元，并将它们像积木一样组合起来，以构建更大的应用程序。除了向语言引入这一特性外，Java
    9还带来了对核心Java代码库的可能是最大的改进。**Java运行时环境**（**JRE**）和**Java开发工具包**（**JDK**）已经被重写，以使用模块化的概念，从而使核心Java平台本身实现了模块化。
- en: When learning about Java 9 module features, it's important to understand what
    those new features add to the language when compared to the other features the
    language already has. Can't we write well organized code in Java 8? In fact, one
    of the benefits of object-oriented programming is indeed the idea of breaking
    down functionality into sub-units called *objects* or *classes*. We've been writing
    code like this in Java since version 1\. Every Java class contains a portion of
    the overall application functionality that happens to belongs together. We have
    the ability to *encapsulate* some functionalities as internal to a class (as `private`)
    and some others as external (or `public`).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习Java 9模块功能时，了解这些新功能与语言已有的其他功能相比增加了什么功能是很重要的。我们难道不能在Java 8中编写有组织的代码吗？事实上，面向对象编程的一个好处确实是将功能分解成称为*对象*或*类*的子单元的想法。我们自从Java
    1版本以来就是这样编写代码的。每个Java类都包含整体应用程序功能的一部分，这些功能碰巧属于一起。我们有能力将某些功能*封装*为类内部的（作为`private`），而将其他一些功能作为外部（或`public`）。
- en: And then there's something in between with `protected`, thanks to the concept
    of packages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有介于`protected`之间的一些内容，这得益于包的概念。
- en: Rethinking Java development with packages
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新思考使用包的Java开发
- en: Think about why we use packages in Java. We could very well write entire Java
    applications without creating any packages and, thereby, using just the default
    *unnamed* package. It would work! However, unless it's a simple or throwaway application,
    that's not a good idea. The idea of packages is to group your Java types into
    namespaces that signify the relationship, or perhaps a common *theme* among those
    types. It makes code easier to read, understand, and navigate.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下为什么我们在Java中使用包。我们完全可以编写整个Java应用程序而不创建任何包，从而仅使用默认的*未命名*包。这也可以工作！然而，除非它是一个简单或一次性应用程序，否则这不是一个好主意。包的概念是将你的Java类型分组到命名空间中，这些命名空间表示这些类型之间的关系，或者可能是这些类型之间的一个共同*主题*。这使得代码更容易阅读、理解和导航。
- en: 'The following diagram shows an example of classes organized in packages. Adding
    all classes to a single package (left) is not good practice. We typically group
    related classes into well-named packages that describe the nature of the classes
    in them (right):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了类在包中组织的一个示例。将所有类添加到单个包中（左侧）并不是一个好的实践。我们通常将相关的类分组到具有良好命名的包中，这些包描述了其中类的本质（右侧）：
- en: '![](img/00005.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00005.jpeg)'
- en: There's really no *rule* about what types belong together in a package. However,
    it's generally understood that when you create a package and put a bunch of Java
    types in it, the types are usually related in some way. You could very well write
    any random set of types in the same package and the compiler wouldn't care. However,
    anyone else who ends up working on your code could potentially hate you forever,
    so this is not a wise thing to do! Having related types in common packages also
    has the benefit of those types being able to access the protected members of each
    other. This is another level of *encapsulation*--any protected members or methods
    are encapsulated within types of a package. (Although, there's an exception to
    this, as inherited classes are able to access private members across packages.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上并没有关于在包中哪些类型属于一起的规则。然而，通常人们认为，当你创建一个包并将一些Java类型放入其中时，这些类型通常以某种方式相关。你完全可以随意在同一个包中编写任何随机的类型集，编译器也不会在意。然而，最终会有人在你代码上工作，他们可能会永远讨厌你，所以这不是一个明智的做法！在公共包中有相关类型也有好处，即这些类型能够访问彼此的保护成员。这是封装的另一个层次--任何保护成员或方法都被封装在包的类型中。（尽管，有一个例外，即继承类能够跨包访问私有成员。） '
- en: So, if the idea of modular programming is to break code and functionality into
    encapsulated units, there's a sense in which you can do *some *kind of modular
    programming in Java well before Java 9.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你认为模块化编程是将代码和功能分解成封装单元的想法，那么在Java 9之前，你可以在某种程度上很好地进行某种模块化编程。
- en: 'The following table shows the various ways in which you can encapsulate code
    in Java before Java 9:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了在Java 9之前，你可以用各种方式在Java中封装代码：
- en: '| **What to encapsulate** | **How to encapsulate** | **Encapsulation boundary**
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **要封装的内容** | **如何封装** | **封装边界** |'
- en: '| Member variables and methods | `private` modifier | Class |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 成员变量和方法 | `private`修饰符 | 类 |'
- en: '| Member variables and methods | `protected` modifier | Package |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 成员变量和方法 | `protected`修饰符 | 包 |'
- en: '| Member variables, methods, and types | No modifier(default package - protected)
    | Package |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 成员变量、方法和类型 | 无修饰符（默认包 - protected） | 包 |'
- en: Isn't that good enough? Well, not really. The preceding table is where a limitation
    in the modular ability of the language becomes apparent. Notice the *What to encapsulate*
    column. Most of the encapsulation features provided by these modifiers focus on
    controlling access to member variables and methods. The only way you can really
    protect access to a type is by making it package-protected. That, unfortunately,
    ends up making access difficult for even your own library code to access the type,
    and you are forced to move all the code that accesses that type into the same
    package. What if you want more?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是足够好吗？实际上并不够。前面的表格显示了语言模块化能力的一个限制。注意“要封装的内容”这一列。这些修饰符提供的多数封装功能都集中在控制成员变量和方法访问上。真正保护类型访问的唯一方法是将它设置为包保护的。不幸的是，这最终使得即使是你的库代码访问该类型也变得困难，你被迫将所有访问该类型的代码移动到同一个包中。如果你想要更多呢？
- en: Why, you ask? There are a couple of problems with approaching modularity with
    just the preceding paradigm available in Java 8 and earlier. Let me explain both
    those problems with two stories.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？使用Java 8和更早版本中可用的先前的范式来处理模块化存在一些问题。让我用两个故事来解释这两个问题。
- en: The unfortunate tale of a library developer
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个库开发者的不幸故事
- en: 'Meet Jack. He''s a Java developer at a medium-sized enterprise organization.
    He''s a part of a team that writes code to do data processing. One day, Jack wrote
    some Java code to sort a list of usernames in alphabetical order. His code worked
    well without any errors and Jack was proud of his work. Since this was something
    that could be used by other developers in the organization, he decided to build
    it as a reusable library and share it with his colleagues as a packaged JAR file.
    Here''s the structure of Jack''s library:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 见杰克。他是一家中型企业组织的Java开发者。他是编写数据处理代码的团队的一员。有一天，杰克编写了一些Java代码来按字母顺序排序用户名列表。他的代码运行良好，没有任何错误，杰克为自己的工作感到自豪。由于这是其他开发者可以在组织中使用的，他决定将其构建为一个可重用的库，并以打包的JAR文件的形式与同事分享。以下是杰克库的结构：
- en: '![](img/00006.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00006.jpeg)'
- en: His code belonged to two packages--`acme.util.stringsorter` and `acme.util.stringsorter.internal`.
    The main utility class was `StringSorterUtil` with one method--`sortStrings`.
    The method in turn internally called and delegated the sorting responsibility
    to the `BubbleSortUtil.sortStrings()` class  from a class in the `acme.util.stringsorter.internal`
    package. The `BubbleSortUtil` class used the popular Bubble Sort algorithm to
    sort a given list of Strings.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 他的代码属于两个包--`acme.util.stringsorter` 和 `acme.util.stringsorter.internal`。主要的实用类是
    `StringSorterUtil`，它有一个方法--`sortStrings`。该方法反过来内部调用并委托排序责任给 `acme.util.stringsorter.internal`
    包中的一个类中的 `BubbleSortUtil.sortStrings()` 类。`BubbleSortUtil` 类使用流行的冒泡排序算法对给定的字符串列表进行排序。
- en: All that any developer had to do was to drop the jar in the classpath and call
    the `StringSorterUtil.sortStrings()` method by passing in an list of strings they
    needed sorting. And they did! Jack's little library became a hit! His colleagues
    loved the convenience that his library provided and they started using it to sort
    many things, such as names, tokens, addresses, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 任何开发者所要做的只是将 jar 文件放入类路径中，并通过传递需要排序的字符串列表来调用 `StringSorterUtil.sortStrings()`
    方法。他们确实这么做了！杰克的小型库变得非常受欢迎！他的同事们非常喜欢他的库提供的便利性，并开始用它来排序许多东西，比如名字、令牌、地址等等。
- en: A few months later, Jack happened to talk to Daryl at the water cooler, and
    as usual, their conversation veered towards a discussion about their current favorite
    sorting algorithms. Daryl couldn't stop talking about his new-found love for hash
    sort. He said he found it performs much better than bubble sort, and it was unabashedly
    his new favorite algorithm! Jack was intrigued. He went to his desk and ran a
    few tests. Daryl was right! Hash sort outperformed bubble sort in most of his
    tests. Jack knew right then that he had to update his sorting utility to use hash
    sort. He added a new class, `HashSortUtil` in the `acme.util.stringsorter.internal`
    package and removed `BubbleSortUtil`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月后，杰克偶然在饮水机旁遇到了达里尔，像往常一样，他们的对话转向了关于他们当前最喜欢的排序算法的讨论。达里尔无法停止谈论他对哈希排序的新发现之爱。他说他发现它的性能比冒泡排序要好得多，而且他毫不掩饰地宣称这是他新的最爱算法！杰克感到很感兴趣。他回到自己的办公桌前进行了一些测试。达里尔是对的！在大多数测试中，哈希排序都优于冒泡排序。杰克当时就知道他必须更新他的排序实用工具以使用哈希排序。他在
    `acme.util.stringsorter.internal` 包中添加了一个新的类 `HashSortUtil` 并移除了 `BubbleSortUtil`。
- en: 'The following is the structure of Jack''s library after the change:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是杰克库变更后的结构：
- en: '![](img/00007.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: Thankfully, he had a separate internal class that did the sorting, so the process
    to invoke the `StringSorterUtil.sortStrings()` utility wouldn't change. Everyone
    could just drop in the newer version of the JAR and everything would work just
    fine.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，他有一个单独的内部类用于排序，所以调用 `StringSorterUtil.sortStrings()` 实用工具的过程不会改变。每个人都可以简单地放入新的
    JAR 版本，一切都会正常工作。
- en: But it didn't! A few of the code builds in his company started failing. It turned
    out the culprit was the newer version of Jack's library. Jack couldn't believe
    it. He didn't miss anything, did he? Well, no. All the projects that used just
    the `StringSorterUtil` class worked just fine. However, it turned out that some
    of the developers ended up using the `BubbleSortUtil` class in the internal package
    directly. It was available in the classpath, so they had just imported and used
    it. Now, since that class didn't exist in the new jar anymore, their code couldn't
    compile!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实并非如此！他公司中的一些代码构建开始失败。结果发现罪魁祸首是杰克库的新版本。杰克不敢相信这一点。他没有遗漏任何东西，是吗？嗯，没有。所有只使用 `StringSorterUtil`
    类的项目都运行得很好。然而，结果发现一些开发者最终直接使用了内部包中的 `BubbleSortUtil` 类。它在类路径中可用，所以他们只是导入并使用了它。现在，由于那个类在新
    jar 中不再存在，他们的代码无法编译！
- en: Jack sent out an email instructing everyone using `BubbleSortUtil` to update
    their code to use `StringSorterUtil` instead. However, it turned out the `BubbleSortUtil` class
    was being used in multiple places by that time, and it wasn't an easy task to
    change them all. "Couldn't Jack just put the `BubbleSortUtil` class back?" they
    asked. Jack yielded to their requests and the next version of the library had
    both the `SortUtil` classes (and would possibly do so well into the foreseeable
    future), even though it internally used only one of those two classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 杰克发送了一封电子邮件，指示所有使用`BubbleSortUtil`的人更新他们的代码，改用`StringSorterUtil`。然而，那时`BubbleSortUtil`类已经被多处使用，要全部更改并非易事。“杰克就不能把`BubbleSortUtil`类恢复回来吗？”他们问道。杰克屈服于他们的请求，下一个版本的库同时包含了`SortUtil`类（并且可能会持续到可预见的未来），尽管它内部只使用了这两个类中的一个。
- en: After the dust settled, Jack sat at his desk and wondered what had gone wrong.
    What could he have done to prevent this problem? Clearly, naming the package as
    internal did not prevent developers from using it. One solution would have been
    to write that internal bubble sort type as package-protected and move the external
    type to the same package. This way, he could leverage the third mechanism in the
    preceding encapsulation table. However, he liked the idea of separating the bubble
    sort class into its own type and package. Also, imagine if this were a bigger
    library and there was a common shared class that was supposed to be internal.
    In that case, pretty much all types in that library that need the internal type
    have to exist in the same package as that internal type! Wasn't there a better
    way to encapsulate the internal types?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 烟尘散去后，杰克坐在他的办公桌前，思考出了什么问题。他本可以做些什么来防止这个问题？显然，将包命名为内部并没有阻止开发者使用它。一个解决方案可能是将内部冒泡排序类型写成包保护，并将外部类型移动到同一个包中。这样，他就可以利用前面封装表中的第三个机制。然而，他喜欢将冒泡排序类分离成自己的类型和包的想法。此外，想象一下，如果这是一个更大的库，并且有一个应该内部共享的公共类。在这种情况下，几乎那个库中所有需要内部类型的类型都必须存在于与内部类型相同的包中！难道没有更好的封装内部类型的方法吗？
- en: The impossible task of a deployment engineer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署工程师的艰巨任务
- en: Meet Amit, a deployment engineer at yet another enterprise technology firm.
    His job is to make sure that during every product release, the organization's
    code base is compiled and deployed properly in the production environment. During
    every release, he pulls in the application code and all the necessary jar files
    and places them in the classpath. He then starts the application that results
    in the **Java Virtual Machine** (**JVM**) loading all the classes and initializing
    execution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 来认识阿米特，他是另一家企业技术公司的一名部署工程师。他的工作是确保在每次产品发布时，组织的代码库在生产环境中正确编译和部署。在每次发布中，他都会拉取应用程序代码和所有必要的jar文件，并将它们放置在类路径中。然后他启动应用程序，这将导致**Java虚拟机**（**JVM**）加载所有类并初始化执行。
- en: One night, there was a major product feature release. There were a lot of changes
    to the code that were all supposed to be deployed and launched together. Amit
    made sure that all the new code was compiled properly and he had all the necessary
    jars in the classpath. He then had to start the application. Before he clicked
    on the button to launch the build, Amit wondered if there was some way he could
    make sure everything was good and that the application would work without any
    runtime class errors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一天晚上，有一个主要产品功能的发布。代码有很多更改，都计划一起部署和发布。阿米特确保所有新代码都正确编译，并且他在类路径中有了所有必要的jar文件。然后他必须启动应用程序。在点击按钮启动构建之前，阿米特想知道是否有办法确保一切正常，并且应用程序在没有运行时类错误的情况下能够工作。
- en: One thing that could potentially go wrong was if he had missed adding a certain
    class or jar in the classpath. Was there a way he could statically verify whether
    all the classes were available without actually running the application?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出错的另一件事是他可能遗漏了在类路径中添加某个类或jar文件。他是否有办法在实际上运行应用程序之前静态地验证所有类是否可用？
- en: Each JAR bundled a set of types in a set of packages. Each type therein could
    potentially import other types, either from the same JAR or from other jars. To
    make sure he has all the classes in the classpath, he has to go to each class
    and verify that all its imports are in the classpath. Considering that the number
    of classes in his application run to thousands, it's a Herculean task.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个JAR文件都包含了一组包中的类型。其中每个类型都可能从同一JAR文件或其他JAR文件中导入其他类型。为了确保他在类路径中有所有的类，他必须对每个类进行检查，以确认所有导入都在类路径中。考虑到他的应用程序中的类数量达到数千个，这是一项艰巨的任务。
- en: 'The following diagram is a simplified version of what a sample deployed Java
    application looks like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图是示例部署的Java应用程序的简化版本：
- en: '![](img/00008.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00008.jpeg)'
- en: There are four jar files in the picture above, each of which contains packages
    and classes within them. **Jar 1** is deployed in **Classpath A**, **Jar 2** and
    **Jar 3** in **Classpath B**, and **Jar 4** in **Classpath C**. Let's assume each
    jar has two classes as indicated by the smaller white boxes. The three paths are
    configured as classpaths for the Java runtime, so the runtime knows to look at
    all three paths to scan and pick up classes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上图中有四个JAR文件，每个文件都包含其中的包和类。**Jar 1** 部署在**Classpath A**中，**Jar 2**和**Jar 3**在**Classpath
    B**中，**Jar 4**在**Classpath C**中。假设每个JAR文件中有两个类，如较小的白色方框所示。这三个路径被配置为Java运行时的类路径，因此运行时知道要查看所有三个路径以扫描和拾取类。
- en: 'After scanning all the classpaths, this is what the structure looks like to
    the Java runtime:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描完所有类路径后，这就是Java运行时看到的结构：
- en: '![](img/00009.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00009.jpeg)'
- en: Notice that the runtime doesn't care which directory or classpath the package/type
    is in. It also doesn't care which jar the package/type is bundled in. As far as
    the Java runtime is concerned, it's just a flattened list of types in packages!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到运行时并不关心包/类型所在的目录或类路径。它也不关心包/类型捆绑在哪个JAR文件中。对Java运行时来说，它只是一个包中类型的扁平列表！
- en: In Java, a classpath is a just set of paths. Any of those locations could have
    the jars and classes that the application needs to work. You can immediately see
    how easy it is for things to break! There's always a possibility that some of
    the classes that the application uses are *not* available in the classpath. Perhaps
    a missing jar or library. If the runtime doesn't have a specific class it needs,
    the application could start running fine, but throw a `NoClassDefFoundError` much
    later. That too, only when the execution hits a point where a missing class is
    actually needed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，类路径只是一组路径。这些位置中的任何一个都可能包含应用程序运行所需的所有JAR文件和类。你可以立即看到事情为什么会变得如此容易出错！总有可能应用程序使用的某些类不在类路径中。可能是一个缺失的JAR文件或库。如果运行时不具有它需要的特定类，应用程序可能会正常运行，但稍后抛出`NoClassDefFoundError`异常。同样，只有在执行到达实际需要缺失类的点时，才会抛出这个异常。
- en: This is a huge and very real problem in large Java applications today. There
    is a whole ecosystem of solutions that have sprung up to address this. For example,
    tools and build utilities, such as Maven or Gradle, standardize the process of
    specifying and acquiring external dependencies. Process-based solutions such as
    continuous integration aim to solve the unpredictable nature of builds across
    various development environments. However, all that such tools can do is make
    the process *predictable*. They cannot verify the *validity* or *accuracy* of
    the result that they help assemble. Once the dependencies are fetched, there's
    nothing that those tools can do to detect missing or duplicate types in the classpath.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是目前大型Java应用程序中一个巨大且非常现实的问题。为了解决这个问题，已经出现了一个完整的解决方案生态系统。例如，工具和构建实用程序，如Maven或Gradle，标准化了指定和获取外部依赖项的过程。基于流程的解决方案，如持续集成，旨在解决跨各种开发环境构建不可预测性的问题。然而，这些工具所能做的只是使过程*可预测*。它们无法验证它们帮助组装的结果的*有效性*或*准确性*。一旦获取了依赖项，这些工具就无能为力，无法检测类路径中缺失或重复的类型。
- en: Back to Amit's story. Having no way to verify whether all the classes are available
    up front, Amit hopes for the best and deploys the application. The application
    starts up fine and runs for a couple of hours without any errors. However, there's
    still no saying if he's got it right. Maybe there's a class in there that hasn't
    been executed yet, but when it has, the JVM might realize that it cannot find
    one of its imports. Or, maybe, there are duplicate versions of the same class
    in the classpath and the JVM picks up the first copy it finds. Wasn't there a
    better way to ensure that any given Java application will work *reliably* in advance?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Amit的故事。由于无法在部署前验证所有类是否可用，Amit寄希望于最好的情况并部署了应用程序。应用程序启动正常，运行了几个小时没有出现任何错误。然而，仍然无法确定他是否做对了。也许有一个类还没有被执行，但一旦执行，JVM可能会意识到它找不到其中一个导入。或者，也许在类路径中有相同类的重复版本，JVM选择了它找到的第一个副本。难道没有更好的方法来确保任何给定的Java应用程序在部署/运行之前都能可靠地工作吗？
- en: The classpath problem
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类路径问题
- en: We've seen two problems in Jack's and Amit's stories. Jack needed an effective
    way to *encapsulate* portions of his library, but couldn't. Amit needed a way
    to *ensure* *reliable* *execution* of his application without actually executing
    it. Both Jack and Amit didn't really have a solution to their problems because
    of the way classpath resolution works in Java. We may sometimes mistakenly think
    of a JAR file as a way to build a reusable module in Java, but that's unfortunately
    not the case. A JAR file is just a convenient bundle of classes. Nothing more!
    Once in the classpath, the JVM treats classes in a JAR no differently from separate
    class files all in the same root directory. At runtime, as far as the JVM is concerned,
    an application is just a set of classes in a flat list of packages.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Jack和Amit的故事中看到了两个问题。Jack需要一个有效的方法来*封装*他库的一部分，但他做不到。Amit需要一个方法来*确保*他的应用程序在没有实际执行的情况下可靠地执行。由于Java中类路径解析的方式，Jack和Amit都没有真正解决他们的问题。我们有时可能会错误地将JAR文件视为在Java中构建可重用模块的方法，但不幸的是，情况并非如此。JAR文件只是类的一个方便的捆绑包。仅此而已！一旦在类路径中，JVM对待JAR中的类与同一根目录中的所有单独类文件没有区别。在运行时，对JVM来说，应用程序只是一个包的扁平列表中的类集。
- en: What's worse is, once a class is in the classpath, it's free for all. It's incredibly
    easy for any developer to use a type they are not supposed to, or a type that
    might be available for them during compile time, but not at deployment/runtime.
    Or there could be multiple copies or even multiple versions of the same class
    in two different classpath locations, making it unpredictable which version the
    runtime will actually pick up during execution. There's a problem commonly called
    **JAR hell**, which refers to several issues resulting from mismatched and incorrect
    classes and versions in JAR files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，一旦一个类在类路径中，它就是公共的。任何开发者都可以非常容易地使用他们不应该使用的类型，或者在他们编译/部署/运行时可能可用的类型。或者，在两个不同的类路径位置可能有相同类的多个副本甚至多个版本，这使得在执行期间无法预测运行时将选择哪个版本。有一个常见的问题被称为**JAR地狱**，它指的是由于JAR文件中不匹配和不正确的类和版本而产生的一系列问题。
- en: This problem is exacerbated in huge code bases with hundreds of thousands of
    classes. Imagine all those classes in your application as a flat list with no
    structure! It's a nightmare to maintain and organize. The bigger the code base,
    the bigger the problem. To illustrate this, let's take the classic example of
    a code base that's written in Java, that's incredibly large and complex, and has
    lasted for many years now. It is perhaps one of the oldest Java code bases ever,
    and still it continues to grow and change at a fairly rapid pace. Any guesses?
    Well, it's the Java platform itself!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有数十万个类的巨大代码库中，这个问题更为严重。想象一下，你的应用程序中的所有这些类都像是一个没有结构的扁平列表！维护和组织起来就像是一场噩梦。代码库越大，问题越大。为了说明这一点，让我们以一个经典的例子来说明，这是一个用Java编写的代码库，它非常庞大且复杂，并且已经存在多年。它可能是有史以来最古老的Java代码库之一，而且它仍然以相当快的速度持续增长和变化。有什么猜测吗？好吧，它是Java平台本身！
- en: Java - the 20-year-old code base
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java - 20年的代码库
- en: Talk about a monolith! Java has come a long way since its first release in 1996\.
    The first major release of the JDK had a little over 500 public classes. A far
    cry indeed from JDK 8 released in 2014, which counts upwards of 4,200 public classes
    and over 20,000 total files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 来谈谈单体架构吧！自1996年首次发布以来，Java已经走了很长的路。JDK的第一个主要版本有超过500个公共类。与2014年发布的JDK 8相比，这相去甚远，JDK
    8有超过4,200个公共类和超过20,000个总文件。
- en: 'The following commands extract the `rt.jar` file, a library JAR file bundled
    in JDK 8, and count the number of classes in it. With the Java 8 version I have
    installed on my machine, the count is `20651`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令提取了 `rt.jar` 文件，这是 JDK 8 中捆绑的库 JAR 文件，并计算了其中的类数量。在我的机器上安装的 Java 8 版本中，计数为
    `20651`：
- en: '![](img/00010.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00010.jpeg)'
- en: The JDK and the runtime, the JRE, have continued to grow over the years. There
    are a lot of features that have been added to the language, so this growth is
    understandable. However, the Java language is also notorious for going to great
    lengths to maintain backward compatibility and for its reluctance to deprecate
    features unless it is absolutely necessary. So, in a way, the current size of
    the runtime is a little over what it could have ideally been.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 和运行时，即 JRE，多年来一直在增长。语言中添加了许多功能，因此这种增长是可以理解的。然而，Java 语言也以其不遗余力地保持向后兼容性而闻名，并且除非绝对必要，否则它不愿意弃用功能。因此，从某种意义上说，当前运行时的大小略大于理想情况下的理想大小。
- en: Normally, most application developers wouldn't need to worry about the JDK code
    base. They just focus on their application code. However, the contents of the
    runtime *does* matter for application execution because of the way it is bundled.
    Traditionally, every JRE has had all the classes necessary for runtime bundled
    into a single JAR that resides in the lib directory called `rt.jar`. The name
    `rt`, as you might have guessed, stands for **runtime**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，大多数应用程序开发者不需要担心 JDK 代码库。他们只需关注自己的应用程序代码。然而，由于打包方式的原因，运行时的内容对于应用程序的执行确实很重要。传统上，每个
    JRE 都会将所有必要的运行时类打包成一个名为 `rt.jar` 的单个 JAR 文件，该文件位于 lib 目录中。正如你可能猜到的，名称 `rt` 代表
    **运行时**。
- en: Not only is this huge monolith of classes unnecessarily bulky in size, it also
    adds performance overheads for the Java Virtual Machine to manage. And that's
    a price the execution environment of all your applications have to pay, irrespective
    of whether all of those classes are being used or not.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这个庞大的类库在大小上不必要地庞大，它还增加了 Java 虚拟机管理的性能开销。而且，这是所有应用程序执行环境必须支付的价格，无论是否使用了所有这些类。
- en: Legacy classes
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧类
- en: A good example of classes that you don't need is the set of classes in the JRE
    related to CORBA. Ever heard of CORBA? If you haven't, don't despair. It's for
    a reason! It's an old technology that was introduced to the Java runtime back
    in version 1.4\. It has mostly fallen out of popular use since then. Considering
    most applications don't use the CORBA technology anymore, wouldn't it be great
    if apps could be bundled with JREs that do not contain the unnecessary CORBA classes?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不需要的类的例子是 JRE 中与 CORBA 相关的类集。你听说过 CORBA 吗？如果你没有，不要绝望。这有一个原因！它是一种老技术，早在 Java
    1.4 版本中就被引入到 Java 运行时中。从那时起，它已经基本上不再被广泛使用。考虑到大多数应用程序不再使用 CORBA 技术，如果应用程序可以与不包含不必要
    CORBA 类的 JRE 打包在一起，那岂不是很好？
- en: That's unfortunately not possible, again, because of `rt.jar`. Since everything
    gets bundled into a single runtime JAR, you cannot pick and choose what features
    you need. Everybody gets everything. And since the runtime has been increasing
    in size, so has the standalone deployable application. This is a more significant
    challenge when the runtime needs to be used on smaller devices with limited resources.
    If you are bundling the runtime with a simple *Hello World* application that uses
    just a handful of classes from the runtime, you have no option but to bundle a
    whole lot of unused classes in `rt.jar` with it. And, yes, even those old CORBA
    classes join in for the ride!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这不可能，同样是因为 `rt.jar`。由于所有内容都被打包到一个单独的运行时 JAR 中，你无法选择你需要的功能。每个人都会得到一切。由于运行时的大小在增加，因此独立的可部署应用程序的大小也在增加。当运行时需要在资源有限的较小设备上使用时，这是一个更大的挑战。如果你将运行时与一个简单的
    *Hello World* 应用程序捆绑在一起，该应用程序只使用了运行时中的一小部分类，你除了将 `rt.jar` 中的大量未使用类与之捆绑外别无选择。而且，是的，甚至那些旧的
    CORBA 类也加入了这次旅行！
- en: Java 8 introduced the concept of profiles, and with that, you can technically
    deploy smaller runtimes. But they do have some drawbacks. Also, this feature was
    just an initial step in the introduction of modularity features in Java 9 anyway.
    We'll examine compact profiles in detail in [Chapter 4](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing the Modular JDK*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 引入了配置文件的概念，因此从技术上讲，你可以部署更小的运行时。但它们确实有一些缺点。此外，这个特性只是 Java 9 中引入模块化特性的第一步。我们将在第
    4 章 [介绍模块化 JDK](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb) 中详细探讨紧凑配置文件。
- en: Internal APIs
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部API
- en: Remember the problem that Jack had with his `BubbleSortUtil` class? It was a
    Java class he wrote with the intention of it being private to his library. However,
    even though it started out as a private *internal* class, it ended up being a
    *public* class because other developers just decided to use it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记得Jack与他自己的`BubbleSortUtil`类遇到的问题吗？这是一个他写的Java类，目的是使其仅限于他的库。然而，尽管它最初是一个私有的*内部*类，但它最终变成了一个*公共*类，因为其他开发者只是决定使用它。
- en: That was just a small library. Now, think about a library as big and as widely
    used as the Java runtime. The Java runtime obviously bundles in internal classes
    that are required for its functioning and aren't meant to be used by application
    developers. However, considering the magnitude of its usage, it isn't surprising
    that some of the internal classes are inadvertently used by developers anyway.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那只是一个小的库。现在，想象一下一个像Java运行时那样大且广泛使用的库。Java运行时显然捆绑了其功能所需的内部类，这些类并不打算被应用程序开发者使用。然而，考虑到其使用的规模，一些内部类无意中被开发者使用并不令人惊讶。
- en: A classic example of this is a class called `Unsafe` in the `sun.misc` package.
    This ominous sounding class has been a part of every major JDK release for a while
    now. Can you guess what it does? It contains a collection of methods that perform,
    according to the author of the class, *low-level unsafe operations*. Yes, it actually
    says that in the comments in the class! For instance, it has a method that gets
    a value from a memory address. Not a typical day's work for a Java application
    developer! You wouldn't, and ideally shouldn't, do something like that as an application
    developer. This is why the class has been marked as an internal API. Want to look
    up its Javadoc to use it? You won't find it in there. Want to create a new instance
    of the class? Its constructors are marked as private. If you do somehow use it
    and compile your code, every Java compiler since Java 6 will give you a nasty
    warning, discouraging the usage of the class. And, if you still need more reasons
    to avoid using it, you'd be best served to just look at the name of the class!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个经典例子是`sun.misc`包中的一个名为`Unsafe`的类。这个听起来不祥的类已经成为了每个主要JDK版本的一部分。你能猜到它做什么吗？它包含了一组方法，根据类的作者，执行*低级不安全操作*。是的，它实际上在类的注释中这样说的！例如，它有一个从内存地址获取值的方法。这不是Java应用程序开发者典型的一天的工作！你不会，理想情况下也不应该作为应用程序开发者做这样的事情。这就是为什么这个类被标记为内部API。你想查找它的Javadoc来使用它吗？你不会在那里找到它。你想创建这个类的新实例吗？它的构造函数被标记为私有。如果你
    somehow 使用了它并编译了你的代码，从Java 6以来的每个Java编译器都会给你一个讨厌的警告，劝阻你使用这个类。而且，如果你还需要更多避免使用它的理由，最好的办法就是看看类的名字！
- en: You must have guessed what's coming by now. The `sun.misc.Unsafe` class has
    now been used in multiple projects by many developers to perform those very low-level
    operations, in spite of all those preventive measures that the Java runtime authors
    have put in place. One could argue that it implements functionality that isn't
    commonly available elsewhere, and for a developer who needs to do something like
    that, nothing beats just picking it up while it's available in the classpath and
    ready to use. `Unsafe` isn't the only internal API that is being used this way,
    of course. There are a few more internal classes, many in the `sun.*` packages,
    that developers have used over the years even though they shouldn't. Moreover,
    as long as developers continue to use these APIs, it becomes harder to remove
    them from the runtime. This has ended up continuing the existence of these classes
    in subsequent versions of the runtime, thereby allowing more developers to use
    them!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在肯定已经猜到了接下来会发生什么。尽管Java运行时作者已经采取了所有预防措施，但`sun.misc.Unsafe`类已经被许多开发者用于多个项目中，以执行那些非常低级的操作。有人可能会争辩说，它实现了在其他地方不常见的功能，对于一个需要做类似事情的开发者来说，没有什么能比在类路径中找到并准备好使用它更好了。当然，`Unsafe`并不是唯一以这种方式使用的内部API。还有一些其他内部类，许多在`sun.*`包中，多年来开发者们一直在使用，尽管他们不应该这样做。此外，只要开发者继续使用这些API，就越来越难以从运行时中移除它们。这最终导致这些类在运行时的后续版本中继续存在，从而允许更多的开发者使用它们！
- en: These limitations of the Java runtime and library system have been felt for
    a while now. All the problems I've outlined so far exist because of the lack of
    ability to create modular units of code in Java. Such a construct simply hasn't
    existed in the language so far. The need for it has been strongly felt in the
    community.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关于Java运行时和库系统的限制已经存在了一段时间。我之前概述的所有问题都存在，因为Java缺乏创建模块化代码单元的能力。这种结构在语言中至今尚未存在。社区对此需求强烈。
- en: Multiple proposals for a module system for Java have been made over the years,
    including JSR-277 way back in 2005 ([https://jcp.org/en/jsr/detail?id=277](https://jcp.org/en/jsr/detail?id=277))
    and JSR-294 ([https://jcp.org/en/jsr/detail?id=294](https://jcp.org/en/jsr/detail?id=294))
    in 2006\. After facing several hurdles, modularity is finally coming to Java with
    the 2017 release of Java 9 with JSR-376 ([https://jcp.org/en/jsr/detail?id=376](https://jcp.org/en/jsr/detail?id=376)),
    the spec titled Java Platform Module System, as well as Project Jigsaw.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，人们提出了多个为Java创建模块系统的建议，包括2005年的JSR-277([https://jcp.org/en/jsr/detail?id=277](https://jcp.org/en/jsr/detail?id=277))和2006年的JSR-294([https://jcp.org/en/jsr/detail?id=294](https://jcp.org/en/jsr/detail?id=294))。在面临了多次挑战后，模块化终于在2017年Java
    9的发布中到来，伴随着JSR-376([https://jcp.org/en/jsr/detail?id=376](https://jcp.org/en/jsr/detail?id=376))的发布，该规范名为Java平台模块系统，以及Project
    Jigsaw。
- en: 'Acronym alert: JCP and JSR'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写提醒：JCP和JSR
- en: '**JCP**: The Java language specification has, for a long time, been a community-owned
    asset. There is no one central authority that has complete control and the decision-making
    power in how the language evolves. Each of us, as Java developers, can have a
    say in how we want the language to change and grow. The **Java Community Process**
    (**JCP**) is a mechanism, introduced in 1998, that allows anyone interested in
    the future of the language specification to register, provide input, and take
    part in the technical specifications process. Go to [https://jcp.org](https://jcp.org)
    to learn more.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**JCP**：Java语言规范长期以来一直是社区拥有的资产。没有一个人中央权威机构对语言如何发展拥有完全的控制权和决策权。作为Java开发者，我们每个人都可以对语言如何改变和成长发表意见。**Java社区过程**（**JCP**）是一种机制，于1998年引入，允许任何对语言规范未来感兴趣的人注册、提供反馈并参与技术规范过程。访问[https://jcp.org](https://jcp.org)了解更多信息。'
- en: '**JSR**: Let''s say you are a part of the Java Community Process, and you have
    a great idea for a change in the language specification. What you do is create
    a **Java Specification Request** (**JSR**)--a formal document that describes the
    proposed changes. JSRs are reviewed and voted upon as a part of the community
    process before they become final. Once a JSR does become final, it is worked on
    and eventually becomes a part of the language specification.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSR**：假设你是Java社区过程的一部分，并且你有一个关于语言规范变化的绝佳想法。你所做的是创建一个**Java规范请求**（**JSR**）——一份正式文件，描述了拟议的更改。JSR在成为最终版本之前，作为社区过程的一部分进行审查和投票。一旦JSR成为最终版本，它就会被开发，并最终成为语言规范的一部分。'
- en: 'Fun fact: The Java Community Process itself is an important part of the language,
    and so changes to it are also handled just like any other changes to the language--by
    submitting a Java Specification Request for it. Yes, there''s the JSR that describes
    the JCP!'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实：Java社区过程本身是语言的重要组成部分，因此对其的更改也像对语言的任何其他更改一样处理——通过提交一个针对它的Java规范请求。是的，有一个描述JCP的JSR！
- en: Java Platform Module System
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java平台模块系统
- en: 'The modularity features in Java 9 are together referred to by the name **Java
    Platform Module System** (**JPMS**). It introduces a new language construct to
    create reusable components called *modules*. The Java Platform Module System makes
    it easy for developers to create contained units or components that have clearly
    established dependencies on other modules. With Java 9 modules, you can group
    certain types and packages into a module and provide it with the following information:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中的模块化特性统称为**Java平台模块系统**（**JPMS**）。它引入了一种新的语言结构来创建可重用的组件，称为*模块*。Java平台模块系统使得开发者能够创建具有明确依赖其他模块的封装单元或组件变得容易。使用Java
    9模块，你可以将某些类型和包组合成一个模块，并为其提供以下信息：
- en: '**Its name**: This is a unique name for the module'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其名称**：这是模块的唯一名称'
- en: '**Its inputs**: What does the module need and use? What''s required for the
    given module to be compiled and run?'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其输入**：模块需要什么并使用什么？给定模块要编译和运行需要什么？'
- en: '**Its outputs**: What does this module output or export out to other modules?'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其输出**：这个模块输出或导出到其他模块的是什么？'
- en: I'll explain the input and output configuration shortly, but at a very high
    level, these three pieces of information are what you typically supply when you
    create a new module. Whenever developers need to create any components that are
    meant to be reusable, they can create new Java modules and provide this information
    to create a unit of code with a clear interface. Since a module can contain both
    its inputs and outputs specified formally, it adds a whole set of advantages compared
    to the classpath approach that we've critiqued so far.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我很快会解释输入和输出配置，但非常简单地说，在创建新模块时，您通常需要提供这三条信息。每当开发者需要创建任何旨在可重用的组件时，他们可以创建新的Java模块，并提供这些信息来创建一个具有清晰接口的代码单元。由于模块可以正式指定其输入和输出，与迄今为止我们批评的类路径方法相比，它增加了一系列优势。
- en: 'Let''s now look at the process of creating a module step by step. We''ll look
    at it at a conceptual level now, and we''ll cover the syntax in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb),
    *Creating Your First Java Module*. Let''s say you want to create a reusable library
    and you''ve decided to put your code in a Java 9 module. Here are the steps you
    need to follow:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们一步一步地看看创建模块的过程。我们现在从概念层面来探讨它，而关于语法的内容将在[第2章](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb)“创建您的第一个Java模块”中进行介绍。假设您想创建一个可重用的库，并且已经决定将您的代码放在一个Java
    9模块中。以下是您需要遵循的步骤：
- en: '**Create a module and give it a name**: Every module has a name associated
    with it, for the obvious purpose of referring to it. You can give a module any
    name that you''d traditionally give to types. All the rules you are already familiar
    with regarding Java package names apply here (so certain characters like ''`/`''
    or ''`-`'' aren''t allowed, but ''`_`'' or ''`.`'' are okay). The recommended
    way to name a module is to use the *reverse domain name* convention, similar to
    the way you name your packages. So, for example, if someone in Acme Corp wrote
    an analytics module, they''d probably name the module `com.acme.analytics`.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建模块并为其命名**：每个模块都与一个名称相关联，这是为了显而易见的目的——引用它。您可以给模块起任何您传统上会给类型起的名字。您已经熟悉的有关Java包名的所有规则都适用于这里（所以某些字符，如`''/''`或`''-''`是不允许的，但`''_''`或`''.''`是可以的）。命名模块的推荐方法是使用*反向域名*约定，类似于您命名包的方式。例如，如果Acme公司的人编写了一个分析模块，他们可能会将模块命名为`com.acme.analytics`。'
- en: '**Define the module inputs**: Not many modules can realistically be self-sufficient.
    You''ll often need to import types that aren''t in your module. This is where
    the module input configuration comes into play. When you create a module, you
    explicitly need to declare which *other modules* you need for your code to work.
    You do that specifying which modules your module *requires*.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义模块输入**：实际上，很少有模块可以真正自给自足。您通常会需要导入不在您模块中的类型。这就是模块输入配置发挥作用的地方。当您创建一个模块时，您需要明确声明哪些*其他模块*对您的代码运行是必需的。您通过指定您的模块*需要*哪些模块来完成这项工作。'
- en: '**Define the module outputs**: We''ve seen that in a traditional JAR file system,
    placing Java types in a JAR file doesn''t really mean anything and every public
    type is accessible to every other type in the classpath, irrespective of which
    JAR it is in. A module behaves differently. By default, every Java type you place
    in a module is accessible only to other types in the same module. Even if the
    type is marked public! In order to expose types outside the module, you need to
    explicitly specify which *packages* you want to *export*. From any module, you
    can only export packages that are in that module. Once you''ve exported a package,
    all types in that package are potentially accessible outside the module. This
    enables every Java module to clearly separate and hide *internal* packages that
    are to be used only inside the module and expose only types that are intended
    to be used externally. If a Java type is in a package that isn''t exported, then
    no other type outside the module can import it, even if the type is public!'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义模块输出**：我们已经看到，在传统的JAR文件系统中，将Java类型放入JAR文件实际上并没有什么意义，并且每个公共类型都可以被类路径中的任何其他类型访问，无论它位于哪个JAR中。模块的行为不同。默认情况下，您放入模块中的每个Java类型只能被同一模块中的其他类型访问。即使该类型被标记为public！为了将类型暴露在模块之外，您需要明确指定您想要*导出*的*包*。从任何模块中，您只能导出该模块中存在的包。一旦导出了一个包，该包中的所有类型都可能对模块外部可访问。这使得每个Java模块可以清楚地分离和隐藏仅用于模块内部的*内部*包，并仅暴露旨在外部使用的类型。如果一个Java类型位于未导出的包中，那么模块外部的任何其他类型都无法导入它，即使该类型是public！'
- en: Note the difference between the things you export from a module (which are packages)
    and the things you import or require (which are other modules). Since we are exporting
    types from a module at a package level, why not require packages too? The reason
    is simple. When a module requires another module, it automatically gets access
    to all the packages that that module exports. This way, you don't have to specify
    every package that your module needs. Just the name of the module you depend on
    will suffice. We'll look at the access mechanisms in much more detail in [Chapter
    3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb), *Handling Inter-Module
    Dependencies*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意从模块导出的内容（即包）与导入或要求的内容（即其他模块）之间的区别。由于我们正在以包级别从模块导出类型，为什么不要求包呢？原因很简单。当模块要求另一个模块时，它自动获得访问该模块导出所有包的权限。这样，你不必指定你的模块需要的每个包。只需指定你依赖的模块的名称就足够了。我们将在
    [第 3 章](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb)，*处理模块间依赖关系*中更详细地探讨访问机制。
- en: 'The following diagram illustrates the input and output definitions of a typical
    module:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了典型模块的输入和输出定义：
- en: '![](img/00011.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: 'JPMS was designed with two primary goals in mind:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JPMS 是基于两个主要目标设计的：
- en: '**Strong encapsulation**: We''ve seen the dangers of having every public class
    accessible to every other class in the classpath. Since every module declares
    which packages are public and isolates those which are internal, the Java compiler
    and runtime can now enforce these rules to make sure that none of the internal
    classes are being used outside the module.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强封装**：我们已经看到了每个公共类对类路径中每个其他类都可见的危险。由于每个模块都声明了哪些包是公共的，并隔离了内部包，Java 编译器和运行时现在可以强制执行这些规则，以确保没有内部类在模块外部被使用。'
- en: '**Reliable configuration**: Since every module declares what it needs, the
    runtime can check whether every module has what it needs well before the application
    is up and running. No more wishing and hoping that all the required classes are
    available in the classpath.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠的配置**：由于每个模块都声明了它需要什么，运行时可以在应用程序启动和运行之前很好地检查每个模块是否拥有它所需的一切。不再需要希望和期望所有必需的类都存在于类路径中。'
- en: You can guess how happy Jack and Amit would be to hear this! Thanks to **strong
    encapsulation**, Jack would just need to put all of his `StringSorter` code in
    a module and export just his public package. Thus, his *internal* package would
    be hidden and not accessible by default. And, thanks to **reliable configuration**,
    Amit can always confidently say whether a given set of modules have all their
    dependencies met before running the application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象 Jack 和 Amit 听到这个消息会有多高兴！多亏了 **强封装**，Jack 只需将他的所有 `StringSorter` 代码放入一个模块中，并导出他的公共包。这样，他的
    *内部* 包就会被隐藏，默认情况下不可访问。而且，多亏了 **可靠的配置**，Amit 总是可以在运行应用程序之前自信地说，给定的模块集是否满足所有依赖项。
- en: In addition to these two core goals, there has been another important goal that
    the module system was designed for--to be scalable and easy to use even on huge
    monolithic libraries. As a validation of that, the Java 9 team went ahead and
    modularized what's pretty much the oldest and biggest Java code base they could
    get their hands on--the Java Platform itself. This task, something that ended
    up involving significant effort, was performed under the name *Project Jigsaw*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个核心目标之外，模块化系统还被设计为具有另一个重要的目标——即使在巨大的单体库中也能实现可扩展性和易于使用。为了验证这一点，Java 9 团队继续对几乎所有他们能接触到的最古老和最大的
    Java 代码库进行了模块化——即 Java 平台本身。这项任务，最终涉及了大量努力，被命名为 *Project Jigsaw*。
- en: Project Jigsaw
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Jigsaw
- en: 'Alan Bateman, a member of the Java Platform Group at Oracle said this is in
    his talk in Java One in September 2016:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 的 Java 平台组成员 Alan Bateman 在 2016 年 9 月的 Java One 会议上说：
- en: Modular development starts with a modular platform.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化开发从模块化平台开始。
- en: No matter what the application is about, there's one set of libraries that every
    Java program is guaranteed to use without a doubt--the Java Platform. For Java
    developers to be writing modular Java code, it's essential for the core Java platform
    and the JDK library to be modular as well. Before Java 9, all the classes and
    types in the JDK had such complicated inter-dependencies that they resembled a
    big bowl of spaghetti.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无论应用程序的内容是什么，都有一组库是每个 Java 程序无疑都会使用的——Java 平台。为了使 Java 开发者能够编写模块化 Java 代码，核心
    Java 平台和 JDK 库本身也必须是模块化的。在 Java 9 之前，JDK 中的所有类和类型都有如此复杂的相互依赖关系，它们就像一大碗意大利面。
- en: Not only is the final `rt.jar` bundle unnecessarily large, it makes the JDK
    code base itself harder to change and evolve. Considering how any type in such
    a huge code base could be used by any of the other thousands of types in the platform,
    I wouldn't want to go in there and make any major changes to that code. Another
    problem with the platform is that it has always lacked ways to hide and encapsulate
    internal platform APIs such as `sun.misc.Unsafe`. The platform itself could very
    well use the same strong encapsulation and reliable configuration benefits that
    JPMS gives us.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅最终的`rt.jar`捆绑包不必要地大，它还使得JDK代码库本身更难更改和演进。考虑到这样一个庞大的代码库中的任何类型都可能被平台中的其他数千个类型使用，我不愿意去那里对那段代码进行任何重大更改。平台本身的问题之一是它始终缺乏隐藏和封装内部平台API（如`sun.misc.Unsafe`）的方法。平台本身完全可以利用JPMS给我们带来的强大封装和可靠配置的好处。
- en: With Java 9, we've finally got a modular JDK to build on top of. Various different
    sets of related JDK classes are bundled into separate modules, each with its own
    imports and exports. For example, SQL related types are in a module called `java.sql`.
    XML functionality has gone into the `java.xml` module, and so on. We'll be looking
    at these out-of-the-box modules in more detail in [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),
    *Handling Inter-Module Dependencies*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 9，我们终于得到了一个模块化JDK，可以在其之上构建。各种不同的相关JDK类被捆绑到单独的模块中，每个模块都有自己的导入和导出。例如，SQL相关类型在名为`java.sql`的模块中。XML功能已进入`java.xml`模块，等等。我们将在[第3章](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb)“处理模块间依赖”中更详细地查看这些即用型模块。
- en: 'The following is an illustration of a subset of the new Java 9 platform modules.
    Don''t worry about the individual names. We''ll cover platform modules in detail
    in [Chapter 4](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing
    the Modular JDK*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是新Java 9平台模块的一个子集的示例。不必担心个别名称。我们将在[第4章](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb)“介绍模块化JDK”中详细介绍平台模块：
- en: '![](img/00012.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.jpeg)'
- en: 'Project Jigsaw claims the following as its primary goals. It''s important to
    keep this in mind as you learn about the impact of the modularization of the platform:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Project Jigsaw声称以下为其主要目标。在学习平台模块化的影响时，请记住这一点：
- en: '**Scalable platform**: Moving away from a monolithic runtime and enabling the
    ability to scale the platform down to smaller computing devices.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展的平台**：从单一运行时转向，并使平台能够扩展到更小的计算设备。'
- en: '**Security and maintainability**: Better organization of the platform code
    to make it more maintainable. Hiding internal APIs and better modular interfaces
    to improve platform security.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和可维护性**：更好地组织平台代码，使其更易于维护。隐藏内部API和更好的模块化接口，以提高平台安全性。'
- en: '**Improved application performance**: Smaller platform with only the necessary
    runtimes, resulting in faster performance.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的应用性能**：平台更小，只包含必要的运行时，从而实现更快的性能。'
- en: '**Easier developer experience**: The combination of the module system and the
    modular platform to make it easier for developers to create applications and libraries.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更便捷的开发体验**：模块系统和模块化平台的结合，使开发者更容易创建应用程序和库。'
- en: What does this mean for application developers? The most immediate difference
    is that not all types in the JDK are now accessible in your code. The same mechanisms
    we saw apply to our modules work with the Java modules too. Any time you depend
    on a platform class, you'll have to import into your module the right platform
    module that contains that class. And, even then, you'll be able to use the class
    only if it has been exported from the module and is public.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应用程序开发者意味着什么？最直接的区别是，现在不是所有JDK中的类型都可以在您的代码中访问。我们看到的相同机制也适用于Java模块。每次您依赖于平台类时，您都必须将包含该类的正确平台模块导入到您的模块中。即使如此，您也只有在类已被模块导出且是公共的时才能使用该类。
- en: This way, the JDK code base also gets all the advantages of the strong encapsulation
    and reliable configuration that the JPMS promises. There are potential backward
    compatibility issues though. What if you used a JDK class in JDK 8 or earlier
    that's now an encapsulated class in a module? That code wouldn't work in Java
    9! The platform uses the encapsulation features to protect certain internal JDK
    classes from external use. So, any code that depends on such classes in Java 8
    or earlier cannot be migrated to Java 9 without removing that dependency first.
    There are a few challenges associated with moving code from Java 8 or earlier
    to Java 9\. We'll look at Java 9 migration-related challenges and best practices
    in [Chapter 9](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb), *Module
    Design Patterns and Strategies*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，JDK代码库也获得了JPMS承诺的强大封装和可靠配置的所有优势。尽管如此，也存在潜在的向后兼容性问题。如果您在JDK 8或更早版本中使用了现在属于模块封装类的JDK类，会发生什么？这些代码在Java
    9中将无法工作！平台使用封装功能来保护某些内部JDK类免受外部使用。因此，任何依赖于这些类在Java 8或更早版本的代码，在迁移到Java 9之前必须先移除该依赖。从Java
    8或更早版本迁移到Java 9存在一些挑战。我们将在[第9章](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb)“模块设计模式和策略”中探讨与Java
    9迁移相关的挑战和最佳实践。
- en: Another important aspect of modularity that most modular platforms have to deal
    with, and we haven't covered so far, is *versioning*. Are modules versionable?
    Can you declare dependencies between modules that specify which versions of the
    modules need to work together? You cannot! Java Platform Module System does not
    support versioning today. We'll briefly examine the reasons why in [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),
    *Handling Inter-Module Dependencies*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的重要方面之一，大多数模块化平台都必须处理，而我们之前还没有涉及的是*版本控制*。模块是否可以版本化？您能否声明模块之间的依赖关系，指定需要一起工作的模块版本？您不能！Java平台模块系统今天不支持版本控制。我们将在[第3章](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb)“处理模块间依赖关系”中简要探讨其原因。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked, at a high level, at some limitations of the traditional
    way of building reusable components in Java using JAR files. We saw how packaging
    libraries in JAR files doesn't allow developers to encapsulate inner APIs and
    types. There's also no way to reliably figure out whether a given application
    has all the necessary classes in the classpath. We learned how these problems
    that developers face in their code are not only present in the JDK code base itself,
    but are actually an issue on a much bigger scale. We understood the Java Platform
    Module System and the two primary goals that it set to achieve--strong encapsulation
    and reliable configuration. We learned about *Project Jigsaw* and the effort to
    modularize the core JDK using the same modular paradigm that's available to developers
    to use in their code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从高层次的角度探讨了使用JAR文件在Java中构建可重用组件的传统方式的局限性。我们看到了将库打包到JAR文件中不允许开发者封装内部API和类型。也没有可靠的方法来确定给定应用程序是否在类路径中包含所有必要的类。我们了解到，开发者在其代码中遇到的问题不仅存在于JDK代码库本身，实际上是一个更大规模的问题。我们了解了Java平台模块系统及其设定的两个主要目标——强大的封装和可靠的配置。我们了解了*Project
    Jigsaw*以及使用与开发者在其代码中可用的相同模块化范式对核心JDK进行模块化的努力。
- en: At this time, you are probably wondering how the concept of modularity manifests
    in the Java language. What does a Java module look like?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道模块化的概念如何在Java语言中体现。Java模块是什么样的？
- en: In the next chapter, we'll answer these questions by creating our first Java
    9 module, and get started on our sample application project which we'll be working
    on throughout this book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过创建我们的第一个Java 9模块来回答这些问题，并开始我们的示例应用程序项目，我们将在这本书的整个过程中对其进行工作。
