- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous API Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have developed RESTful web services based on the imperative model,
    where calls are synchronous. What if you want to make code async and non-blocking?
    This is what we are going to do in this chapter. You’ll learn about asynchronous
    API design in this chapter, where calls are asynchronous and non-blocking. We’ll
    develop these APIs using Spring **WebFlux**, which is based on Project Reactor
    ([https://projectreactor.io](https://projectreactor.io)). Reactor is a library
    for building non-blocking apps on a **Java virtual** **machine** (**JVM**).
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll walk through the reactive programming fundamentals, and then we’ll
    migrate the existing e-commerce REST API (which we learned about in [*Chapter
    4*](B19349_04.xhtml#_idTextAnchor097), *Writing Business Logic for APIs*) to an
    asynchronous (reactive) API to make things easier by comparing the existing (imperative)
    way and reactive way of programming. The code will make use of R2DBC for database
    persistence, which supports reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll discuss the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Reactive Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Spring WebFlux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `DispatcherHandler`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing reactive APIs for our e-commerce app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to develop and implement
    reactive APIs and explored async APIs. You will also be able to implement reactive
    controllers and functional endpoints and make use of R2DBC for database persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Reactive Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normal Java code achieves asynchronicity by using thread pools. Your web server
    uses a thread pool to serve requests – it assigns a thread to each incoming request.
    The application uses the thread pool for database connections too. Each database
    call uses a separate thread and waits for the result. Therefore, each web request
    and database call uses its own thread. However, there is a wait associated with
    this and, therefore, these are blocking calls. The thread waits and utilizes the
    resources until a response is received back from the database or a response object
    is written. This is kind of a limitation when you scale as you can only use the
    resources available to the JVM. You overcome this limitation by using a load balancer
    with other instances of the service, which is a type of horizontal scaling.
  prefs: []
  type: TYPE_NORMAL
- en: In the last decade, there has been a rise in client-server architecture. Lots
    of IoT-enabled devices, smartphones that have native apps, first-class web apps,
    and traditional web applications have emerged. Applications not only have third-party
    services but also have various sources of data, which leads to higher-scale applications.
    On top of that, microservice-based architecture has increased communication among
    services themselves. You need lots of resources to serve this higher network communication
    demand. This makes scaling a necessity. Threads are expensive and not infinite.
    You don’t want to block them for effective utilization. For example, let’s say
    your code is calling the database for data. In this case, the call waits until
    you get the response in the blocking call. However, a non-blocking call doesn’t
    block anything. It responds only when a response is received from the dependent
    code (the database in this case). The system can serve other calls during this
    time. This is where asynchronicity helps. In asynchronous calls, threads become
    free as soon as a call is done and use a callback utility (common in JavaScript).
    When data is available at the source, it pushes the data. Project Reactor is based
    on **Reactive Streams**. Reactive Streams uses the **publisher-subscriber model**,
    where the source of data, the publisher, pushes the data to the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: You might be aware that, on the other hand, Node.js uses a single thread to
    make use of most resources. It is based on an asynchronous non-blocking design,
    known as an **event loop**.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive APIs are also based on an event loop design and use push-style notifications.
    If you look closely, Reactive Streams also supports Java stream (a sequence of
    objects pipelined to produce the desired results by performing various operations)
    operations, such as `map`, `flatMap`, and `filter`. Internally, Reactive Streams
    uses a push style, whereas Java streams work according to a pull model; that is,
    items are pulled from the source, such as a Java collection. In reactive programming,
    the source (publisher) pushes the data.
  prefs: []
  type: TYPE_NORMAL
- en: In Reactive Streams, streams of data are asynchronous and non-blocking and support
    backpressure. (Refer to the *Subscriber* subsection of this chapter for an explanation
    of backpressure.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four basic types of interfaces as per the Reactive Streams specification:'
  prefs: []
  type: TYPE_NORMAL
- en: Publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscriber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s have a look at each of these types.
  prefs: []
  type: TYPE_NORMAL
- en: Publisher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A publisher provides a stream of data to one or more subscribers. A subscriber
    uses the `subscribe()` method to subscribe to a publisher. Each subscriber should
    only subscribe once to a publisher.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, the publisher pushes data according to the demand received
    from subscribers. Reactive Streams are lazy; therefore, the publisher will only
    push an element if there is a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Publisher` interface is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Publisher` interface contains the `subscribe` method. Let’s find
    out about the `Subscriber` type in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Subscriber
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The subscriber consumes the data pushed by the publisher. Publisher-subscriber
    communication works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When a `Subscriber` instance is passed to the `Publisher.subscribe()` method,
    it triggers the `onSubscribe()` method. It contains a `Subscription` parameter,
    which controls the backpressure, that is, how much data a subscriber demands from
    the publisher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the first step, `Publisher` waits for the `Subscription.request(long)`
    call. It only pushes data to `Subscriber` after the `Subscription.request()` call
    is made. This method indicates to the `Publisher` how many items the subscriber
    is ready to receive at a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normally, the publisher pushes the data to the subscriber, irrespective of whether
    the subscriber can handle it safely or not. However, the subscriber knows best
    how much data it can handle safely; therefore, in Reactive Streams, `Subscriber`
    uses the `Subscription` instance to communicate the demand for the number of elements
    to `Publisher`. This is known as **back-pressure** or **flow control**.
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering, what if `Publisher` asks `Subscriber` to slow down but
    it can’t? In that case, `Publisher` must decide whether to fail, drop, or buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Once the demand is made in *step 2*, `Publisher` sends the data notifications
    and the `onNext()` method is used to consume the data. This method will be triggered
    until the data notifications are pushed by `Publisher` according to the demand
    communicated by `Subscription.request()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end, either `onError()` or `onCompletion()` will be triggered as the
    terminal state. No notification will be sent after one of these invocations has
    been triggered even if you call `Subscription.request()`. The following are the
    terminal methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onError()` will be invoked the moment any error occurs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCompletion()` will be invoked when all elements are pushed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Subscriber` interface is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Subscription
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A subscription is a mediator between the publisher and subscriber. It is the
    subscriber’s responsibility to invoke the `Subscription.subscriber()` method and
    let the publisher know of the demand. It can be invoked as and when required by
    the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: The `cancel()` method asks the publisher to stop sending data notifications
    and to clean up the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'A subscription is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Processor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The processor is a bridge between the publisher and subscriber and represents
    the processing stage. It works as both a publisher and subscriber and obeys the
    contract defined by both. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a look at the following example. Here, we are creating `Flux` by
    using the `Flux.just()` static factory method. `Flux` is a type of publisher in
    Project Reactor. This publisher contains four integer elements. Then, we use the
    `reduce` operator (like we do in Java streams) to perform a `sum` operation on
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the previous code, it prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the output, when `Publisher` is subscribed, `Subscriber` sends an
    unbounded `Subscription.request()`. When the first element is notified, `onNext()`
    is called, and so on. At the end, when the publisher is done with the push elements,
    the `onComplete()` event is called. This is how Reactive Streams works.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of how Reactive Streams works, let’s see how and why
    Spring makes use of Reactive Streams in the Spring WebFlux module.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Existing Servlet APIs are blocking APIs. They use input and output streams,
    which block APIs. Servlet 3.0 containers evolve and use the underlying event loop.
    Async requests are processed asynchronously but read and write operations still
    use blocking input/output streams. The *Servlet 3.1* container has evolved further,
    supporting asynchronicity and having the non-blocking I/O stream APIs. However,
    there are certain Servlet APIs, such as `request.getParameters()`, which parse
    the blocking request body and provide synchronous contracts such as `Filter`.
    The **Spring MVC** framework is based on the Servlet API and Servlet containers.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, Spring provides **Spring WebFlux**, which is fully non-blocking and
    provides backpressure functionality. It provides concurrency with a small number
    of threads and scales with fewer hardware resources. WebFlux provides fluent,
    functional, and continuation-style APIs to support the declarative composition
    of asynchronous logic. Writing asynchronous functional code is more complex than
    writing imperative-style code. However, once you get hands-on with it, you will
    love it because it allows you to write precise and readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Both Spring WebFlux and Spring MVC can co-exist; however, to ensure the effective
    use of reactive programming, you should never mix a reactive flow with blocking
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring WebFlux supports the following features and archetypes:'
  prefs: []
  type: TYPE_NORMAL
- en: The event loop concurrency model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both annotated controllers and functional endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netty and Servlet 3.1 container-based web servers, such as Tomcat, Undertow,
    and Jetty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have some idea about WebFlux, you can deep dive into learning how
    WebFlux works by understanding reactive APIs and Reactor Core. Let’s first explore
    reactive APIs. You’ll explore Reactor Core in a subsequent subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reactive APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring WebFlux APIs are reactive APIs and accept `Publisher` as the plain input.
    WebFlux then adapts it to a type supported by a reactive library such as Reactor
    Core or RxJava. It then processes the input and returns the output in a format
    supported by the reactive library. This allows WebFlux APIs to be interoperable
    with other reactive libraries.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring WebFlux uses Reactor ([https://projectreactor.io](https://projectreactor.io))
    as a core dependency. Project Reactor provides the Reactive Streams library. As
    stated in the previous paragraph, WebFlux accepts the input as `Publisher`, then
    adapts it to a Reactor type, and then returns it as a `Mono` or `Flux` output.
  prefs: []
  type: TYPE_NORMAL
- en: You know that `Publisher` in Reactive Streams pushes the data to its subscribers
    based on demand. It can push one or more (possibly infinite) elements. Project
    Reactor takes it further and provides two `Publisher` implementations, namely
    `Mono` and `Flux`. `Mono` can return either `0` or `1` to `Subscriber`, whereas
    `Flux` returns `0` to `N` elements. Both are abstract classes that implement the
    `CorePublisher` interface. The `CorePublisher` interface extends the publisher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, we have the following methods in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These can be replaced with `Mono` and `Flux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Streams can be either hot or cold based on whether the source can be restarted
    or not. The source is restarted if there are multiple subscribers for cold streams,
    while the same source is used for multiple subscribers in hot streams. Project
    Reactor streams are, by default, cold. Therefore, once you consume a stream, you
    can’t reuse it until it’s restarted. However, Project Reactor allows you to turn
    a cold stream into a hot one by using `cache()` methods. Both `Mono` and `Flux`
    abstract classes support cold and hot streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand the cold and hot stream concepts with some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created a `Flux` object, `fluxInt`, that contains three numbers.
    Then, we are performing two operations separately – `sum` and `max`. You can see
    that there are two subscribers. By default, Project Reactor streams are cold;
    therefore, when a second subscriber registers, it restarts, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The source is created in the same program, but what if the source is somewhere
    else, such as in an HTTP request, or you don’t want to restart the source? In
    these cases, you can turn the cold stream into a hot stream by using `cache()`,
    as shown in the next code block. The only difference between the following code
    and the previous code is that we have added a `cache()` call to `Flux.just()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, look at the output. The source has not restarted; instead, the same source
    is used again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have got to the crux of reactive APIs, let’s see what Spring WebFlux’s
    Reactive Core consists of.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reactive Core provides a foundation for developing a reactive web application
    with Spring. A web application needs three levels of support for serving HTTP
    web requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling web requests by the server using the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpHandler`: An interface of the `reactor.core.publisher.Mono` package that
    is an abstraction of a request/response handler over different HTTP server APIs,
    such as Netty or Tomcat:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`WebHandler`: An interface of the `org.springframework.web.server` package
    that provides support for user sessions, request and session attributes, a locale
    and principal for the request, form data, and so on. You can find more information
    about `WebHandler` at [https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of a web request call by the client using `WebClient`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Codecs (`Encoder`, `Decoder`, `HttpMessageWriter`, `HttpMessageReader`, and
    `DataBuffer`) for the serialization and deserialization of content at both the
    server and client levels for the request and response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These components are at the core of Spring WebFlux. WebFlux application configuration
    also contains the following beans – `webHandler` (`DispatcherHandler`), `WebFilter`,
    `WebExceptionHandler`, `HandlerMapping`, `HandlerAdapter`, and `HandlerResultHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: For REST service implementation, there are specific `HandlerAdapter` instances
    for the following web servers – Tomcat, Jetty, Netty, and Undertow. A web server
    such as Netty, which supports Reactive Streams, handles the subscriber’s demands.
    However, if the server handler does not support Reactive Streams, then the `org.
    springframework.http.server.reactive.ServletHttpHandlerAdapter` HTTP `HandlerAdapter`
    is used. `HandlerAdapter` handles the adaptation between Reactive Streams and
    the Servlet 3.1 container async I/O and implements a `Subscriber` class. `HandlerAdapter`
    uses the OS TCP buffers. OS TCP uses its own backpressure (control flow); that
    is, when the buffer is full, the OS uses the TCP backpressure to stop incoming
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: The browser, or any HTTP client, consumes REST APIs using the HTTP protocol.
    When a request is received by the web server, it forwards it to the Spring WebFlux
    application. Then, WebFlux builds the reactive pipeline that goes to the controller.
    `HttpHandler` is an interface between WebFlux and the web server that communicates
    using the HTTP protocol. If the underlying server supports Reactive Streams, such
    as Netty, then the subscription is done by the server natively. Else, WebFlux
    uses `ServletHttpHandlerAdapter` for Servlet 3.1 container-based servers. `ServletHttpHandlerAdapter`
    then adapts the streams to async I/O Servlet APIs and vice versa. Then, the subscription
    of Reactive Streams happens with `ServletHttpHandlerAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in summary, `Mono`/`Flux` streams are subscribed by WebFlux internal
    classes, and when the controller sends a `Mono`/`Flux` stream, these classes convert
    it into HTTP packets. The HTTP protocol does support event streams. However, for
    other media types, such as JSON, Spring WebFlux subscribes the `Mono`/`Flux` streams
    and waits until `onComplete()` or `onError()` is triggered. Then, it serializes
    the whole list of elements, or a single element in the case of `Mono`, in one
    HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux needs a component like `DispatcherServlet` in Spring MVC – a
    front controller. Let’s discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DispatcherHandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DispatcherHandler`, a front controller in Spring WebFlux, is the equivalent
    of `DispatcherServlet` in the Spring MVC framework. `DispatcherHandler` contains
    an algorithm that makes use of special components – `HandlerMapping` (maps requests
    to the handler), `HandlerAdapter` (a `DispatcherHandler` helper to invoke a handler
    mapped to a request), and `HandlerResultHandler` (a palindrome of words, for processing
    the result and forming results) – for processing requests. The `DispatcherHandler`
    component is identified by a bean named `webHandler`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It processes requests in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: A web request is received by `DispatcherHandler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DispatcherHandler` uses `HandlerMapping` to find a matching handler for the
    request and uses the first match.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then uses the respective `HandlerAdapter` to process the request, which exposes
    `HandlerResult` (the value returned by `HandlerAdapter` after processing). The
    return value could be one of the following – `ResponseEntity`, `ServerResponse`,
    values returned from `@RestController`, or values (`CharSequence`, `view`, `map`,
    and so on) returned by a view resolver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it makes use of the respective `HandlerResultHandler` to write the response
    or render a view based on the `HandlerResult` type received from *step 2*. `ResponseEntityResultHandler`
    is used for `ResponseEntity`, `ServerResponseResultHandler` is used for `ServerResponse`,
    `ResponseBodyResultHandler` is used for values returned by the `@RestController`
    or `@ResponseBody` annotated method, and `ViewResolutionResultHandler` is used
    for values returned by the view resolver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The request is completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can create REST endpoints in Spring WebFlux using either an annotated controller
    such as Spring MVC or functional endpoints. Let’s explore these in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Spring team has kept the same annotations for both Spring MVC and Spring
    WebFlux as these annotations are non-blocking. Therefore, you can use the same
    annotations we used in previous chapters to create REST controllers. In Spring
    WebFlux, the annotation runs on Reactive Core and provides a non-blocking flow.
    However, you, as the developer, have the responsibility of maintaining a fully
    non-blocking flow and the reactive chain (pipeline). Any blocking calls in a reactive
    chain will convert the reactive chain into a blocking call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a simple REST controller that supports non-blocking and reactive
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that it uses all the annotations that we have used in Spring MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RestController` is used to mark a class as a REST controller. Without this,
    the endpoint won’t register, and the request will be returned as `NOT` `FOUND
    404`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping` is used to define the path and HTTP method. Here, you can
    also use `@PostMapping` with just the path. Similarly, for each of the HTTP methods,
    there is a respective mapping, such as `@GetMapping`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@RequestBody` annotation marks a parameter as a request body, and an appropriate
    codec will be used for conversion. Similarly, there are `@PathVariable` and `@RequestParam`
    for the path parameter and query parameter, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to use an annotation-based model to write the REST endpoints. You’ll
    get a closer look when we implement the e-commerce app controllers using WebFlux.
    Spring WebFlux also provides a way to write a REST endpoint using a functional
    programming style, which you’ll explore in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Functional endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The REST controllers we coded using Spring MVC were written in imperative-style
    programming. Reactive programming, on the other hand, is functional-style programming.
    Therefore, Spring WebFlux also allows an alternative way to define REST endpoints,
    using functional endpoints. These also use the same Reactive Core foundation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can write the same `Order` REST endpoint of the sample e-commerce
    app, using a functional endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, you can see that the `RouterFunctions.route()` builder
    allows you to write all the REST routes in a single statement using the functional
    programming style. Then, it uses the method reference of the handler class to
    process the request, which is the same as the `@RequestMapping` body of an annotation-based
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the following code to the `OrderHandler` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the `@RequestMapping()` mapping methods in the REST controller, handler
    methods don’t have multiple parameters, such as body, path, or query parameters.
    They just have a `ServerRequest` parameter, which can be used to extract the body,
    path, and query parameters. In the `addOrder` method, the `Order` object is extracted
    using `request.bodyToMono()`, which parses the request body and then converts
    it into an `Order` object. Similarly, the `getOrderById()` method retrieves the
    `order` object identified by the given ID from a server request object by calling
    `request. pathVariable("id")`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the response. The handler method uses the `ServerResponse`
    object in comparison to `ResponseEntity` in Spring MVC. Therefore, the `ok()`
    static method looks like it’s from `ResponseEntity`, but it is from `org.springframework.
    web.reactive.function.server.ServerResponse.ok`. The Spring team has tried to
    keep the API as similar as possible to Spring MVC; however, the underlying implementation
    differs and provides a non-blocking reactive interface.
  prefs: []
  type: TYPE_NORMAL
- en: The last point about these handler methods is the way a response is written.
    It uses a functional style instead of an imperative style and makes sure that
    the reactive chain does not break. The repository returns the `Mono` object (a
    publisher) in both cases as a response wrapped inside `ServerResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find interesting code in the `getOrderById()` handler method. It performs
    a `flatMap` operation on the received `Mono` object from the repository. It converts
    it from an entity into a model, then wraps it in a `ServerResponse` object, and
    returns the response. You must be wondering what happens if the repository returns
    null. The repository returns `Mono` as per the contract, which is similar in nature
    to the Java `Optional` class. Therefore, the `Mono` object can be empty but not
    null, as per the contract. If the repository returns an empty `Mono`, then the
    `switchIfEmpty()` operator will be used and a `NOT FOUND 404` response will be
    sent.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an error, there are different error operators that can be used,
    such as `doOnError()` or `onErrorReturn()`.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the logic flow using the `Mono` type; the same explanation
    will apply if you use the `Flux` type in place of the `Mono` type.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed a lot of theory relating to reactive, asynchronous, and non-blocking
    programming in a Spring context. Let’s jump into coding and migrate the e-commerce
    API developed in [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097), *Writing Business
    Logic for APIs*, to a reactive API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing reactive APIs for our e-commerce app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have an idea of how Reactive Streams works, we can go ahead and
    implement REST APIs that are asynchronous and non-blocking.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll recall that we are following the design-first approach, so we need the
    API design specification first. However, we can reuse the e-commerce API specification
    we created previously in [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080), *API
    Specifications* *and Implementation*.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI Codegen is used to generate the API interface/contract that creates
    the Spring MVC-compliant API Java interfaces. Let’s see what changes we need to
    do to generate the reactive API interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Changing OpenAPI Codegen for reactive APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to tweak a few OpenAPI Codegen configurations to generate Spring WebFlux-compliant
    Java interfaces, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/api/config.json](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/api/config.json)'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive API support is only there if you opt for `spring-boot` as the library.
    Also, you need to set the `reactive` flag to `true`. By default, the `reactive`
    flag is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate Reactive Streams-compliant Java interfaces, which are annotation-based
    REST controller interfaces. When you open any API interface, you’ll find `Mono`/`Flux`
    reactor types in it, as shown in the following code block for the `OrderAPI` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will have observed another change: an additional parameter, `ServerWebExchange`,
    is also required for reactive controllers.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you compile your code, you may find compilation errors because we
    haven’t yet added the dependencies required for reactive support. Let’s learn
    how to add them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Reactive dependencies to build.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we’ll remove `spring-boot-starter-web` as we don’t need Spring MVC now.
    Second, we’ll add `spring-boot-starter-webflux` and `reactor-test` for Spring
    WebFlux and Reactor support tests, respectively. Once these dependencies are added
    successfully, you should not see any compilation errors in the OpenAPI-generated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the required reactive dependencies to `build.gradle`, as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/build.gradle)'
  prefs: []
  type: TYPE_NORMAL
- en: We need to have a complete reactive pipeline from the REST controller to the
    database. However, existing JDBC and Hibernate dependencies only support blocking
    calls. JDBC is a fully blocking API. Hibernate is also blocking. Therefore, we
    need to have reactive dependencies for the database.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate Reactive ([https://github.com/hibernate/hibernate-reactive](https://github.com/hibernate/hibernate-reactive))
    was released after the first edition of this book. Hibernate Reactive supports
    PostgreSQL, MySQL/MariaDB, Db2 11.5+, CockroachDB 22.1+, MS SQL Server 2019+,
    and Oracle Database 21+. Hibernate Reactive does not support H2 at the time of
    writing. Therefore, we will simply use Spring Data, a Spring framework that provides
    the `spring-data-r2dbc` library for working with Reactive Streams.
  prefs: []
  type: TYPE_NORMAL
- en: Many NoSQL databases, such as MongoDB, already provide a reactive database driver.
    An R2DBC-based driver should be used for relational databases in place of JDBC
    for fully non-blocking/reactive API calls. **R2DBC** stands for **Reactive Relational
    Database Connectivity**. R2DBC is a reactive API open specification that establishes
    a **Service Provider Interface** (**SPI**) for database drivers. Almost all the
    popular relational databases support R2DBC drivers – H2, Oracle Database, MySQL,
    MariaDB, SQL Server, PostgreSQL, and R2DBC Proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the R2DBC dependencies for Spring Data and H2 to the `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can write end-to-end (from the controller to the repository) code without
    any compilation errors. Let’s add global exception handling before we jump into
    writing an implementation for API Java interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll add the global exception handler the way it was added in Spring MVC in
    [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080), *API Specifications and Implementation*.
    Before that, you must be wondering how to handle exceptions in a reactive pipeline.
    Reactive pipelines are a flow of streams and you can’t add exception handling
    the way you do in imperative code. You need to raise the error in a pipeline flow
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, a `flatMap` operation is performed. An error should be thrown if `card`
    is not valid, that is, if `card` does not have the requested `ID`. Here, `Mono.error()`
    is used because the pipeline expects `Mono` as a returned object. Similarly, you
    can use `Flux.error()` if `Flux` is expected as the returned type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume you are expecting an object from a service or repository call,
    but instead, you receive an empty object. Then, you can use the `switchIfEmpty()`
    operator, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the code expects a `Mono` object of the `List` type from the `item` repository.
    However, if the returned object is empty, then it simply throws the `ResourceNotFoundException.switchIfEmpty()`
    exception and accepts the alternate `Mono` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you might have a question about the type of exception. It throws a
    runtime exception. See the `ResourceNotFoundException` class declaration here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can also use `onErrorReturn()`, `onErrorResume()`, or similar
    error operators from Reactive Streams. Look at the use of `onErrorReturn()` in
    the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All exceptions should be handled, and an error response should be sent to the
    user. We’ll have a look at the global exception handler first, in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling global exceptions for controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a global exception handler using `@ControllerAdvice` in Spring MVC.
    We’ll take a slightly different route for handling errors in Spring WebFlux. First,
    we’ll create the `ApiErrorAttributes` class, which can also be used in Spring
    MVC. This class extends `DefaultErrorAttributes`, which is a default implementation
    of the `ErrorAttributes` interface. The `ErrorAttributes` interface provides a
    way to handle maps, a map of error fields, and their values. These error attributes
    can then be used to display an error to the user or for logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following attributes are provided by the `DefaultErrorAttributes` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timestamp`: The time that the error was captured'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: The status code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: An error description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exception`: The class name of the root exception (if configured)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: The exception message (if configured)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errors`: Any `ObjectError` from a `BindingResult` exception (if configured)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace`: The exception stack trace (if configured)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The URL path when the exception was raised'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestId`: The unique ID associated with the current request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have added two default values to the status and message – an internal server
    error and a generic error message (`The system is unable to complete the request.
    Contact system support.`), respectively – to `ApiErrorAttributes`, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorAttributes.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorAttributes.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use this `ApiErrorAttributes` class in a custom global exception
    handler class. We’ll create the `ApiErrorWebExceptionHandler` class, which extends
    the `AbstractErrorWebExceptionHandler` abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AbstractErrorWebExceptionHandler` class implements the `ErrorWebExcepti``     onHandler` and `InitializingBean` interfaces. `ErrorWebExceptionHandler` is a
    functional interface that extends the `WebExceptionHandler` interface, which indicates
    that `WebExceptionHandler` is used for rendering exceptions. `WebExceptionHandler`
    is a contract for handling exceptions when server exchange processing takes place.'
  prefs: []
  type: TYPE_NORMAL
- en: The `InitializingBean` interface is a part of the Spring core framework. It
    is used by components that react when all properties are populated. It can also
    be used to check whether all the mandatory properties are set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have studied the basics, let’s jump into writing the `ApiErrorAttributes`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java)'
  prefs: []
  type: TYPE_NORMAL
- en: The first important observation about this code is that we have added the `@Order`
    annotation, which tells us the preference of execution. `ResponseStatusExceptionHandler`
    is placed at the `0` index by the Spring Framework and `DefaultErrorWebExceptionHandler`
    is ordered at the `-1` index. Both are exception handlers like the one we have
    created. If you don’t give an order of precedence to `ApiErrorWebExceptionHandler`
    superseding both, then it won’t ever execute. Therefore, the order of precedence
    is set at `-2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, this class overrides the `getRoutingFunction()` method, which calls the
    privately defined `renderErrorResponse()` method, where we have our own custom
    implementation for error handling, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java
  prefs: []
  type: TYPE_NORMAL
- en: Here, first, we extract the error attributes in `errorPropertiesMap`. This will
    be used when we form the error response. Next, we capture the occurred exception
    using `throwable`. Then, we check the type of the exception and assign an appropriate
    code to it. We keep the default as `GenericError`, which is nothing more than
    `InternalServerError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use a `switch` statement to form an error response based on the raised
    exception, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Probably in the next version of Java, we will be able to combine the `if-else`
    and `switch` blocks to make the code more concise. You can also create a separate
    method that takes `errorPropertiesMap` as an argument and returns the formed server
    response based on it. Then, you can use `switch`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom application exception classes, such as `CustomerNotFoundException`, and
    other exception-handling-supported classes, such as `ErrorCode` and `Error`, are
    being used from the existing code (from [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097),
    *Writing Business Logic* *for APIs*).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have studied exception handling, we can concentrate on HATEOAS.
  prefs: []
  type: TYPE_NORMAL
- en: Adding hypermedia links to an API response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HATEOAS support for reactive APIs exists and is a bit like what we did in the
    previous chapter using Spring MVC. We create these assemblers again for HATEOAS
    support. We also use the HATEOAS assembler classes to convert a model into an
    entity and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux provides the `ReactiveRepresentationModelAssembler` interface
    for forming hypermedia links. We would override its `toModel()` method to add
    the links to response models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will do some groundwork for populating the links. We will create an
    `HateoasSupport` interface with a single default method, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/HateoasSupport.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/HateoasSupport.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, this class contains a single default method, `getUriCompononentBuilder()`,
    which accepts `ServerWebExchange` as an argument and returns the `UriComponentsBuilder`
    instance. This instance can then be used to extract the server URI that would
    be used to add the links with a protocol, host, and port. If you remember, the
    `ServerWebExchange` argument was added to controller methods. This interface is
    used to get the HTTP request, response, and other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use these two interfaces – `HateoasSupport` and `ReactiveRepresentation``     ModelAssembler` – to define the representation model assemblers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the address’s representational model assembler, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have defined another private method, `getServerUri()`, which extracts
    the server URI from `UriComponentBuilder`, which itself is returned from the default
    `getUriComponentBuilder()` method of the `HateoasSupport` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can override the `toModel()` method, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: AddressRepresentationModelAssembler.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `toModel()` method returns the `Mono<Address>` object with hypermedia links
    formed from the `AddressEntity` instance using the `entityToModel()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`entityToModel()` copies the properties from the entity instance to the model
    instance. Most importantly, it adds hypermedia links to the model using the `resource.add()`
    method. The `add()` method takes the `org.springframework.hateoas.Link` instance
    as an argument. Then, we use the `Link` class’s `of()` static factory method to
    form the link. You can see that a server URI is used here to add it to the link.
    You can form as many links as you want and add these to the resource using the
    `add()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReactiveRepresentationModelAssembler` interface provides the `toCollectionModel()`
    method with a default implementation that returns the `Mono<CollectionModel<D>>`
    collection model. However, we can also add the `toListModel()` method, as shown
    here, which returns the list of addresses using `Flux`:'
  prefs: []
  type: TYPE_NORMAL
- en: AddressRepresentationModelAssembler.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This method internally uses the `entityToModel()` method. Similarly, you can
    create a representation model assembler for other API models. You can find all
    these models at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/hateoas](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/hateoas).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the basic code infrastructure, we can develop the
    API implementation based on the interfaces generated by OpenAPI Codegen. Here,
    we’ll first develop the repositories that will be consumed by the services. At
    the end, we’ll write the controller implementation. Let’s start with the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Entities are defined in more or less the same way as we defined and used them
    in [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097), *Writing Business Logic for
    APIs*. However, instead of using Hibernate mappings and JPA, we’ll use Spring
    Data annotations, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/entity/OrderEntity.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/entity/OrderEntity.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, because we are using Spring Data in place of Hibernate, we use Spring
    Data annotations, namely `@Table`, to associate an entity class to a table name,
    and `@Column` for mapping a field to a column of the table. As is obvious, `@Id`
    is used as the identifier column. Similarly, you can define the other entities.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the entities, let’s add repositories in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A repository is an interface between our application code and database. It is
    the same as the respository you used in Spring MVC. However, we are writing the
    code using the reactive paradigm. Therefore, it is necessary to have repositories
    that use an R2DBC-/reactive-based driver and return instances of reactive types
    on top of Reactive Streams. This is the reason why we can’t use JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data R2DBC provides different repositories for Reactor and RxJava, for
    example, `ReactiveCrudRepository` and `ReactiveSortingRepository` and `RxJava2CrudRepository`
    and `RxJava3CrudRepository`. Also, you can write your own custom implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use `ReactiveCrudRepository` and also write a custom implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll write repositories for the `Order` entity. For other entities, you can
    find the repositories at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/repository](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/repository).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s write the CRUD repository for the `Order` entity, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepository.java)'
  prefs: []
  type: TYPE_NORMAL
- en: This is as simple as shown. The `OrderRepository` interface extends `ReactiveCrudRepository`
    and our own custom repository interface, `OrderRepositoryExt`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss `OrderRepositoryExt` a bit later; let’s discuss `OrderRepository`
    first. We have added one extra method, `findByCustomerId()`, to the `OrderRepository`
    interface, which finds the order by the given customer ID. The `ReactiveCrudRepository`
    interface and the `Query()` annotation are part of the Spring Data R2DBC library.
    `Query()` consumes native SQL queries, unlike the repository we created in the
    previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write our own custom repository. Let’s write a simple contract
    for it, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have written two method signatures – the first one inserts a new order
    record in the database and the second one updates the order item and cart item
    mapping. The idea is that once an order is placed, items should be removed from
    the cart and added to the order. If you want, you can also combine both operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first define the `OrderRepositoryExtImpl` class, which extends the `OrderRepositoryExt`
    interface, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java)'
  prefs: []
  type: TYPE_NORMAL
- en: We have just defined a few class properties and added these properties in the
    constructor as an argument for constructor-based dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the contract, it receives `Mono<NewOrder>`. Therefore, we need to add
    a method that converts a model into an entity to the `OrderRepositoryExtImpl`
    class. We also need an extra argument as `CartEntity` contains the cart items.
    Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: OrderRepositoryExtImpl.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is straightforward except for the code where the total is set.
    The total is calculated using the stream. Let’s break it down to understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it takes the items from `CartEntity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it creates streams from items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates a map with the key as the product ID and the value as the product
    of the quantity and price.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It takes the value from the map and converts it into a stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It performs the reduce operation by adding a method to `BigDecimal`. It then
    gives the total amount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If values are not present, then it simply returns `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the `toEntity()` method, we also need another mapper that reads rows
    from the database and converts them into `OrderEntity`. For this purpose, we’ll
    write `BiFunction`, which is a part of the `java.util.function` package:'
  prefs: []
  type: TYPE_NORMAL
- en: OrderRepositoryExtImpl.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have overridden the `apply()` method, which returns `OrderEntity`,
    by mapping properties from the row to `OrderEntity`. The second parameter of the
    `apply()` method is not used because it contains metadata that we don’t need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first implement the `updateMapping()` method from the `OrderRepositoryExt`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: OrderRepositoryExtImpl.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a pipeline of Reactive Streams and performed two back-to-back
    database operations. First, it creates the order item mapping using `OrderItemRepository`,
    and then it removes the cart item mapping using `ItemRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Java streams are used to create an input list of `OrderItemEntity` instances
    in the first operation, and a list of item IDs in the second operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have made use of `ReactiveCrudRepository` methods. Let’s implement
    a custom method using an entity template, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: OrderRepositoryExtImpl.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we override the `insert()` method from the `OrderRepositoryExt` interface.
    The `insert()` method is filled with fluent, functional, and reactive APIs. The
    `insert()` method receives a `NewOrder` model `Mono` instance as an argument that
    contains the payload for creating a new order. Spring Data R2DBC does not allow
    fetching nested entities. However, you can write a custom repository for `Cart`
    in the same way you have written for `Order` that can fetch `Cart` and its items
    together.
  prefs: []
  type: TYPE_NORMAL
- en: We are using `ReactiveCrudRepository` for `Cart` and `Item` entities. Therefore,
    we are fetching them one by one. First, we use the item repository to fetch the
    cart items based on the given customer ID. `Customer` has a one-to-one mapping
    with `Cart`. Then, we fetch the `Cart` entity using `CartRepository` by using
    the customer ID.
  prefs: []
  type: TYPE_NORMAL
- en: We get the two separate Mono objects – `Mono<List<ItemEntity>>` and `Mono<CartEntity>`.
    Now, we need to combine them. `Mono` has a `zip()` operator, which allows you
    to take two `Mono` objects and then use the Java `BiFunction` to merge them. `zip()`
    returns a new `Mono` object only when both the given `Mono` objects produce the
    item. `zip()` is polymorphic and therefore other forms are also available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the cart and its items, plus the `NewOrder` payload. Let’s insert these
    items into a database, as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: OrderRepositoryExtImpl.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we again use `Mono.zip()` to create an `OrderEntity` instance. Now, we
    can use values from this instance to insert into the `orders` table.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to interact with the database to run SQL queries – by using
    either `DatabaseClient` or `R2dbcEntityTemplate`. Now, `DatabaseClient` is a lightweight
    implementation that uses the `sql()` method to deal with SQL directly, whereas
    `R2dbcEntityTemplate` provides a fluent API for CRUD operations. We have used
    both classes to demonstrate their usage.
  prefs: []
  type: TYPE_NORMAL
- en: First, we use `DatabaseClient.sql()` to insert the new order into the `orders`
    table. We use `OrderMapper` to map the row returned from the database to the entity.
    Then, we use the `then()` reactive operator to select the newly inserted record
    and then map it back to `orderEntity` using the `R2dbcEntityTemplate.selectOne()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can create repositories for other entities. Now, we can use these
    repositories in services. Let’s define services in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add a service for `Order`. There is no change in the `OrderService` interface,
    as shown next. You just need to make sure that interface method signatures have
    reactive types as returned types to keep the non-blocking flow in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderService.java)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you are going to implement each of these four methods described in `OrderService`.
    Let’s first implement the first two methods of `OrderService` in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two are straightforward; we just use the `OrderRepository` instance
    to call the respective methods. In an idle scenario, the overridden `updateMapping`
    method will trigger the rest of the process after updating the mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: Initiate the payment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the payment is authorized, change the status to `paid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initiate the shipment and changed the status to `Shipment Initiated` or `Shipped`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As our application is not a real-world app and we are writing for learning purposes,
    we are not writing the code for executing all three steps. For simplicity, we
    are just updating the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the third one (`getOrdersByCustomerId`). This is a bit tricky,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: OrderServiceImpl.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The previous method looks complicated, but it’s not. What you are doing here
    is basically fetching data from multiple repositories and then populating the
    nested entities inside `OrderEntity`. This is done with the `zipWith()` operator
    by using either the `map()` operator alongside it or `BiFunction` as a separate
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding method first fetches the orders by using the customer ID, then
    flat maps the orders to populate its nested entities such as `Customer`, `Order`,
    and `Items`. Therefore, we are using `zipWith()` inside the `flatMap()` operator.
    If you observe the first `zipWith()`, it fetches the user entity and then sets
    the nested user entity’s property using the `map()` operator. Similarly, other
    nested entities are populated.
  prefs: []
  type: TYPE_NORMAL
- en: In the last `zipWith()` operator, we are using `BiFunction` `biOrderItems` to
    set the `item` entities in the `OrderEntity` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same algorithm is used to implement the last method (`getOrderById`) of
    the `OrderService` interface, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: OrderServiceImpl.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, you have used the `zipWith()` operator to merge different objects.
    You may find another way to merge two `Mono` instances using the `Mono.zip()`
    operator, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/CardServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/CardServiceImpl.java)'
  prefs: []
  type: TYPE_NORMAL
- en: This example is taken from the `CartServiceImpl` class. Here, we make two separate
    calls – one using the `cart` repository and another one from the `item` repository.
    As a result, these two calls produce two `Mono` instances and merge them using
    the `Mono.zip()` operator. This we call directly using `Mono`; the previous example
    was used on `Mono`/`Flux` instances with the `zipWith()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Using similar techniques, the remaining services have been created. You can
    find them at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/service](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/service).
  prefs: []
  type: TYPE_NORMAL
- en: You have implemented async services that allow you to perform async operations,
    including database calls. Now, you can consume these service classes in controllers.
    Let’s move our focus on to the last development subsection (controllers) of our
    reactive API implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding controller implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST controller interfaces are already generated by the OpenAPI Codegen tool.
    We can now create an implementation of those interfaces. The only different thing
    while implementing the reactive controller is having the reactive pipelines to
    call the services and assemblers. You should also only return `ResponseEntity`
    objects wrapped in either `Mono` or `Flux` based on the generated contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement `OrderApi`, which is the controller interface for the `Orders`
    REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `@RestController` is a trick that combines `@Controller` and `@ResponseBody`.
    These are the same annotations we used in [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097),
    *Writing Business Logic for APIs*, to create the REST controller. However, the
    methods have different signatures now to apply the reactive pipelines. Make sure
    you don’t break the reactive chain of calls or add any blocking calls. If you
    do, either the REST call will not be fully non-blocking or you may see undesired
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use constructor-based dependency injection to inject the order service and
    assembler. Let’s add the method implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: OrderController.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Both the method argument and return type are reactive types (`Mono`), used as
    a wrapper. Reactive controllers also have an extra parameter, `ServerWebExchange`,
    which we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, we simply pass the `newOrder` instance to the service. We have
    used `cache()` because we need to subscribe to it more than once. We get the newly
    created `EntityOrder` through the `addOrder()` call. Then, we use the `zipWhen()`
    operator, which performs the `updateMapping` operation using the newly created
    order entity. At the end, we send the `Order` object by wrapping it inside `ResponseEntity`.
    Also, it returns `NOT FOUND 404` when an empty instance is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at other method implementations of the `order` API interface:'
  prefs: []
  type: TYPE_NORMAL
- en: OrderController.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, both methods are kind of similar in nature; the service
    returns `OrderEntity` based on the given customer ID and order ID, respectively.
    It then gets converted into a model and is wrapped inside `ResponseEntity` and
    `Mono`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, other REST controllers are implemented using the same approach. You
    can find the rest of them at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/controller](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/controller).
  prefs: []
  type: TYPE_NORMAL
- en: We are almost done with the reactive API implementation. Let’s look into some
    of the other minor changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding H2 Console to an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The H2 Console app is not available by default in Spring WebFlux the way it
    is available in Spring MVC. However, you can add it by defining the bean on your
    own, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/H2ConsoleComponent.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/H2ConsoleComponent.java)'
  prefs: []
  type: TYPE_NORMAL
- en: The previous code (`H2ConsoleComponent`) is straightforward; we have added the
    `start()` and `stop()` methods, which are executed on `ContextRefreshEvent` and
    `ContextStopEvent`, respectively. `ContextRefreshEvent` is an application event
    that gets fired when `ApplicationContext` is refreshed or initialized. `ContextStopEvent`
    is also an application event that gets fired when `ApplicationContext` is closed.
  prefs: []
  type: TYPE_NORMAL
- en: The `start()` method creates the web server using the H2 library and starts
    it on a given port. The `stop()` method stops the H2 web server, that is, the
    H2 Console app.
  prefs: []
  type: TYPE_NORMAL
- en: You need a different port to execute H2 Console, which can be configured by
    adding the `modern.api.h2.console.port=8081` property to the `application.properties`
    file. The `h2ConsolePort` property is annotated with `@Value("${modern.api.h2.console.port:8081}")`;
    therefore, the value configured in `application.properties` will be picked and
    assigned to `h2ConsolePort` when the `H2ConsoleComponent` bean is initialized
    by the Spring Framework. The value `8081` will be assigned if the property is
    not defined in the `application.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are discussing `application.properties`, let’s have a look at some
    of the other changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding application configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use Flyway for database migration. Let’s add the configuration
    required for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/application.properties)'
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering why we are using JDBC here, instead of R2DBC. This is
    because Flyway hasn’t yet started supporting R2DBC (at the time of writing). You
    can change it to R2DBC once support is added.
  prefs: []
  type: TYPE_NORMAL
- en: We have specified the `ecomm` schema and set a blank username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can add the Spring Data configuration in the `application.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Spring Data supports R2DBC; therefore, we are using an R2DBC-based URL. We have
    set `io.r2dbc:r2dbc-h2` for the driver to H2 and set a blank username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we have added the following logging properties to `logback-spring.xml`
    to add debug statements to the console for Spring R2DBC and H2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our implementation of reactive RESTful APIs. Now, you can test
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Testing reactive APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you must be looking forward to testing. You can find the API client collection
    at the following location. You can import it and then test the APIs using any
    API client that supports the HAR-type file import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/Chapter05-API-Collection.har](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/Chapter05-API-Collection.har)'
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the Chapter 05 code
  prefs: []
  type: TYPE_NORMAL
- en: You can build the code by running `gradlew clean build` from the root of the
    project and run the service using `java -jar build/libs/Chapter05-0.0.1-SNAPSHOT.jar`.
    Make sure to use Java 17 in the path.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you enjoyed learning about reactive API development with an asynchronous,
    non-blocking, and functional paradigm. At first glance, you may find it complicated
    if you are not very familiar with the fluent and functional paradigm, but with
    practice, you’ll start writing only functional-style code. Definitely, familiarity
    with Java streams and functions will help you to grasp the concepts easily.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have reached the end of this chapter, you have the skills to write
    functional and reactive code. You can write reactive, asynchronous, and non-blocking
    code and REST APIs. You also learned about R2DBC, which will become more solid
    and enhanced in the future as long as reactive programming continues to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore the security aspect of RESTful service development.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you really need the reactive paradigm for application development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there any disadvantages to using the reactive paradigm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who plays the role of the subscriber in the case of an HTTP request in Spring
    WebFlux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, it is required only if you need vertical scaling. In the cloud, you pay
    to use the resources, and reactive applications help you to use resources optimally.
    This is a new way of achieving scale. You need a small number of threads compared
    to non-reactive applications. The cost of connection to a database, I/O, or any
    external source is a callback; therefore, reactive-based applications do not require
    much memory. However, while reactive programming is superior in terms of vertical
    scaling, you should continue using your existing or non-reactive applications.
    Even Spring recommends that. There is no new or old style; both can co-exist.
    However, when you need scaling for any special component or application, you can
    go the reactive way. A few years back, Netflix replaced the Zuul API gateway with
    the reactive Zuul2 API gateway. This helped them to achieve scale. However, they
    still have/use non-reactive applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are pros and cons to everything. Reactive is no exception. Reactive code
    is not easy to write compared to the imperative style. It is very difficult to
    debug because it does not use a single thread. However, if you have developers
    who are proficient in the reactive paradigm, this isn’t an issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WebFlux internal classes subscribe to `Mono`/`Flux` streams sent by the controller
    and convert them into HTTP packets. The HTTP protocol does support event streams.
    However, for other media types, such as JSON, Spring WebFlux subscribes `Mono`/`Flux`
    streams and waits till `onComplete()` or `onError()` is triggered. Then, it serializes
    the whole list of elements, or a single element in the case of `Mono`, in one
    HTTP response. You can learn more about it in the *Reactive* *Core* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project Reactor: [https://projectreactor.io](https://projectreactor.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Reactive documentation: [https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Data R2DBC – reference documentation: [https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/](https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Reactive Programming in Spring* *5*: [https://www.packtpub.com/product/hands-on-reactive-programming-in-spring-5/9781787284951](https://www.packtpub.com/product/hands-on-reactive-programming-in-spring-5/9781787284951)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learn Java 17 Programming – Second* *Edition*: [https://www.packtpub.com/product/learn-java-17-programming-second-edition/9781803241432](https://www.packtpub.com/product/learn-java-17-programming-second-edition/9781803241432)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 2 – Security, UI, Testing, and Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn how to secure REST APIs with JWTs and Spring Security.
    After completing this part, you will also be able to authorize REST endpoints
    based on user roles. You will learn how APIs are consumed by the UI app, and you
    will learn how to automate the unit testing and integration testing of APIs. By
    the end of this part, you will be able to containerize the built app and then
    deploy it in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19349_06.xhtml#_idTextAnchor148), *Securing REST Endpoints Using
    Authorization and Authentication*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19349_07.xhtml#_idTextAnchor169), *Designing a User Interface*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19349_08.xhtml#_idTextAnchor201), *Testing APIs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19349_09.xhtml#_idTextAnchor215), *Deployment of Web Services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
