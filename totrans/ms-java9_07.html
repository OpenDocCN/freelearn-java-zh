<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Leveraging the New Default G1 Garbage Collector</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we examined <strong>Java Shell</strong> (<strong>JShell</strong>), Java 9's new <strong>read-eval-print loop</strong> (<strong>REPL</strong>) command-line tool. We started with introductory information regarding the tool and looked closely at the read-eval-print loop concept. We spent considerable time reviewing JShell commands and command-line options. Our coverage included practical guides to feedback modes, asset listing, and editing in the shell. We also gained experience working with scripts.</p>
<p>In this chapter, we will take an in-depth look at <strong>garbage collection</strong> and how it is handled in Java 9. We will start with an overview of garbage collection, and then look at specifics in the pre-Java 9 realm. Armed with that foundational information, we will look at specific garbage collection changes in the Java 9 platform. Lastly, we will look at some garbage collection issues that persist, even after Java 9.</p>
<p>The following topics are covered in this chapter:</p>
<ul>
<li>Overview of garbage collection</li>
<li>The pre-Java 9 garbage collection schema</li>
<li>Collecting garbage with the new Java platform</li>
<li>Persistent issues</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of garbage collection</h1>
                </header>
            
            <article>
                
<p>Garbage collection is the mechanism used in Java to deallocate unused memory. Essentially, when an object is created, memory space is allocated and dedicated to that object until it no longer has any references pointing to it. At that time, the system deallocates the memory. Java performs this garbage collection automatically for us, which can lead to a lack of attention to memory usage and poor programming practices in the area of memory management and system performance.</p>
<p>Java's garbage collection is considered an automatic memory management schema because programmers do not have to designate objects as ready to be deallocated. The garbage collection runs on a low-priority thread and, as you will read later in this chapter, has variable execution cycles.</p>
<p>In our overview of garbage collection, we will look at the following concepts:</p>
<ul>
<li>Object life cycle</li>
<li>Garbage collection algorithms</li>
<li>Garbage collection options</li>
<li>Java methods relevant to garbage collection</li>
</ul>
<p>We will look at each of these concepts in the sections that follow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object life cycle</h1>
                </header>
            
            <article>
                
<p>In order to fully understand Java's garbage collection, we need to look at the entire life cycle of an object. Because the core of garbage collection is automatic in Java, it is not uncommon to see the terms <em>garbage collection</em> and <em>memory management</em> as assumed components of the object life cycle.</p>
<p>We will start our review of the object life cycle with object creation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object creation</h1>
                </header>
            
            <article>
                
<p>Objects are declared and created. When we write an object declaration, or declare an object, we are declaring a name or identifier so that we can refer to an object. For example, the following line of code declares <kbd>myObjectName</kbd> as the name of an object of type <kbd>CapuchinMonkey</kbd>. At this point, no object was created and no memory allocated for it:</p>
<pre>    CapuchinMonkey myObjectName;</pre>
<p>We use the <kbd>new</kbd> keyword to create an object. The following example illustrates how to invoke the <kbd>new</kbd> operation to create an object. This operation results in:</p>
<pre>    myObjectName = new CapuchinMonkey();</pre>
<p>Of course, we can combine the declaration and creation statements together by using <kbd>CapuchinMonkey myObjectName = new CapuchinMonkey();</kbd> instead of <kbd>CapuchinMonkey myObjectName;</kbd> and <kbd>myObjectName = new CapuchinMonkey();</kbd>. They were separated in the preceding example for illustrative purposes.</p>
<p>When an object is created, a specific amount of memory is allocated for storing that object. The amount of memory allocated can differ based on architecture and JVM.</p>
<p>Next look at the mid-life of an object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object mid-life</h1>
                </header>
            
            <article>
                
<p>Objects are created and Java allocates system memory for storing that object. If the object is not used, the memory allocated to it is considered wasted. This is something we want to avoid. Even with small applications, this type of wasted memory can lead to poor performance and even out-of-memory issues.</p>
<p>Our goal is to deallocate or release the memory, any previously allocated memory that we no longer need. Fortunately, with Java, there is a mechanism for handling this issue. It is called garbage collection.</p>
<p>When an object, such as our <kbd>myObjectName</kbd> example, no longer has any references pointing to it, the system will reallocate the associated memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object destruction</h1>
                </header>
            
            <article>
                
<p>The idea of Java having a garbage collector running in the dark shadows of your code (usually a low-priority thread) and deallocating memory currently allocated to unreferenced objects, is appealing. So, how does this work? The garbage collection system monitors objects and, as feasible, counts the number of references to each object.</p>
<p>When there are no references to an object, there is no way to get to it with the currently running code, so it makes perfect sense to deallocate the associated memory.</p>
<div class="packt_infobox">The term <strong>memory leak</strong> refers to small memory chunks to be lost or improperly deallocated. These leaks are avoidable with Java's garbage collection.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Garbage collection algorithms</h1>
                </header>
            
            <article>
                
<p>There are several garbage collection algorithms, or types, for use by the Java virtual machine. In this section, we will cover the following garbage collection algorithms:</p>
<ul>
<li>Mark and sweep</li>
<li>CMS garbage collection</li>
<li>Serial garbage collection</li>
<li>Parallel garbage collection</li>
<li>G1 garbage collection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mark and sweep</h1>
                </header>
            
            <article>
                
<p>Java's initial garbage collection algorithm, <em>mark and sweep</em>, used a simple two-step process:</p>
<ol>
<li>Java first step, mark, is to step through all objects that have accessible references, marking those objects as alive.</li>
<li>The second step, sweep, involves scanning the sea for any object that is not marked.</li>
</ol>
<p>As you can readily determine, the mark and sweep algorithm seems effective, but probably not very efficient due to the two-step nature of this approach. This eventually lead to a Java garbage collection system with vastly improved efficiencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concurrent mark sweep (CMS) garbage collection</h1>
                </header>
            
            <article>
                
<p>The <strong>concurrent mark sweep</strong> (<span><strong>CMS</strong>)</span> algorithm for garbage collection scans heap memory using multiple threads. Similar to the mark and sweep method, it marks objects for removal and then makes a sweep to actually remove those objects. This method of garbage collection is essentially an upgraded mark and sweep method. It was modified to take advantage of faster systems and had performance enhancements.</p>
<p>To manually invoke the concurrent mark sweep garbage collection algorithm for your application, use the following command-line option:</p>
<pre><strong>-XX:+UseConcMarkSweepGC </strong></pre>
<p>If you want to use the concurrent mark sweep garbage collection algorithm and dictate the number of threads to use, you can use the following command-line option. In the following example, we are telling the Java platform to use the concurrent mark sweep garbage collection algorithm with eight threads:</p>
<pre><strong>-XX:ParallelCMSThreads=8</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serial garbage collection</h1>
                </header>
            
            <article>
                
<p>Java's serial garbage collection works on a single thread. When executing, it freezes all other threads until garbage collection operations have concluded. Due to the thread-freezing nature of serial garbage collection, it is only feasible for very small programs.</p>
<p>To manually invoke the serial garbage collection algorithm for your application, use the following command-line option:</p>
<pre><strong>-XX:+UseSerialGC</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parallel garbage collection</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, the parallel garbage collection algorithm was the default garbage collector. It uses multiple threads but freezes all non-garbage collection threads in the application until garbage collection functions have completed, just like the serial garbage collection algorithm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">G1 garbage collection</h1>
                </header>
            
            <article>
                
<p>The G1 garbage collection algorithm was created for use with large memory heaps. This approach involves segmenting the memory heap into regions. Garbage collection, using the G1 algorithm, takes place in parallel with each heap region.</p>
<p>Another part of the G1 algorithm is that when memory is deallocated, the heap space is compacted. Unfortunately, the compacting operation takes place using the <em>Stop the World</em> approach.</p>
<p>The G1 garbage collection algorithm also prioritizes the regions based on those that have the most garbage to be collected.</p>
<div class="packt_infobox">The G1 name refers to Garbage First.</div>
<p>To manually invoke the G1 garbage collection algorithm for your application, use the following command-line option:</p>
<pre><strong>-XX:+UseG1GC</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Garbage collection options</h1>
                </header>
            
            <article>
                
<p>Here is a list of JVM sizing options:</p>
<table>
<tbody>
<tr>
<td><strong>Sizing description</strong></td>
<td><strong>JVM option flag</strong></td>
</tr>
<tr>
<td>Sets the initial heap size (young space plus tenured space).</td>
<td>
<p><kbd>-XX:InitialHeapSize=3g</kbd></p>
</td>
</tr>
<tr>
<td>Sets the maximum heap size (young space plus tenured space).</td>
<td><kbd>-XX:MaxHeapSize=3g</kbd></td>
</tr>
<tr>
<td>Sets the initial and maximum heap size (young space plus tenured space).</td>
<td><kbd>-Xms2048m -Xmx3g</kbd></td>
</tr>
<tr>
<td>Sets the initial size of young space.</td>
<td><kbd>-XX:NewSize=128m</kbd></td>
</tr>
<tr>
<td>Sets the maximum size of young space.</td>
<td><kbd>-XX:MaxNewSize=128m</kbd></td>
</tr>
<tr>
<td>Sets young space size. Uses ration of young verses tenured space. In the sample flag to the right, <kbd>3</kbd> means that young space will be three times smaller than tenured space.</td>
<td><kbd>-XX:NewRation=3</kbd></td>
</tr>
<tr>
<td>Sets the size of single survivor space as a portion of Eden space size.</td>
<td><kbd>-XX:SurvivorRatio=15</kbd></td>
</tr>
<tr>
<td>Sets the initial size of the permanent space.</td>
<td><kbd>-XX:PermSize=512m</kbd></td>
</tr>
<tr>
<td>Sets the maximum size of the permanent space.</td>
<td><kbd>-XX:MaxPermSize=512m</kbd></td>
</tr>
<tr>
<td>Sets the size of the stack area dedicated to each thread in bytes.</td>
<td>
<p class="mce-root"><kbd>-Xss512k</kbd></p>
</td>
</tr>
<tr>
<td>Sets the size of the stack area dedicated to each thread in Kbytes.</td>
<td><kbd>-XX:ThreadStackSize=512</kbd></td>
</tr>
<tr>
<td>Sets the maximum size of off-heap memory available to the JVM.</td>
<td><kbd>-XX:MaxDirectMemorySize=3g</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Here is a list of young garbage collection options:</p>
<table>
<tbody>
<tr>
<td><strong>Young garbage collection tuning option</strong></td>
<td><strong>Flag</strong></td>
</tr>
<tr>
<td>Sets the initial value for the number of collections before an object will be promoted from young to tenured space. This is referred to as the <strong>tenuring threshold</strong>.</td>
<td>
<div><kbd>-XX:Initial\TenuringThreshold=16</kbd></div>
</td>
</tr>
<tr>
<td>Sets the maximum value for tenuring threshold.</td>
<td>
<div><kbd>-XX:Max\TenuringThreshold=30</kbd></div>
</td>
</tr>
<tr>
<td>Sets the maximum object size allowed to be allocated in young space. If an object is larger than the maximum size it will be allocated to tenured space and bypass young space.</td>
<td>
<div><kbd>-XX:Pretenure\SizeThreshold=3m</kbd></div>
</td>
</tr>
<tr>
<td>This can be used to promote all young objects surviving the young collection to tenured space.</td>
<td><kbd><span>-XX:+AlwaysTenure</span></kbd></td>
</tr>
<tr>
<td>With this tag, objects from young space never get promoted to tenured space as long as the survivor space has sufficient room for them.</td>
<td><kbd><span>-XX:+NeverTenure</span></kbd></td>
</tr>
<tr>
<td>We can indicate that we want to use thread local allocation blocks in the young space. This is enabled by default.</td>
<td><kbd><span>-XX:+UseTLAB</span></kbd></td>
</tr>
<tr>
<td>Toggle this to allow the JVM to adaptively resize the <strong>TLAB</strong> (<strong>Thread Local Allocation Blocks</strong>) for threads.</td>
<td><kbd><span>-XX:+ResizeTLAB</span></kbd></td>
</tr>
<tr>
<td>Sets the initial size of TLAB for a thread.</td>
<td><kbd><span>-XX:TLABSize=2m</span></kbd></td>
</tr>
<tr>
<td>Sets the minimum allowable size of TLAB.</td>
<td><kbd><span>-XX:MinTLABSize=128k</span></kbd></td>
</tr>
</tbody>
</table>
<p>Here is a list of <strong>concurrent mark sweep</strong> (<strong>CMS</strong>) tuning options:</p>
<table>
<tbody>
<tr>
<td><strong>CMS tuning option</strong></td>
<td><strong>Flag</strong></td>
</tr>
<tr>
<td>Indicates that you want to solely use occupancy as a criterion for starting a CMS collection operation.</td>
<td>
<div><kbd>-XX:+UseCMSInitiating\OccupancyOnly</kbd></div>
</td>
</tr>
<tr>
<td>Sets the percentage CMS generation occupancy to start a CMS collection cycle. If you indicate a negative number, you are telling the JVM you want to use <kbd>CMSTriggerRatio</kbd>.</td>
<td>
<div><kbd>-XX:CMSInitiating\OccupancyFraction=70</kbd></div>
</td>
</tr>
<tr>
<td>Sets the percentage CMS generation occupancy that you want to initiate a CMS collection for bootstrapping collection statistics.</td>
<td>
<div><kbd>-XX:CMSBootstrap\Occupancy=10</kbd></div>
</td>
</tr>
<tr>
<td>This is the percentage of <kbd>MinHeapFreeRatio</kbd> in CMS generation that is allocated prior to a CMS cycle starts.</td>
<td><kbd><span>-XX:CMSTriggerRatio=70</span></kbd></td>
</tr>
<tr>
<td>Sets the percentage of <kbd>MinHeapFreeRatio</kbd> in the CMS permanent generation that is allocated before starting a CMS collection cycle.</td>
<td><kbd><span>-XX:CMSTriggerPermRatio=90</span></kbd></td>
</tr>
<tr>
<td>This is the wait duration after a CMS collection is triggered. Use the parameter to specify how long the CMS is allowed to wait for young collection.</td>
<td><kbd><span>-XX:CMSWaitDuration=2000</span></kbd></td>
</tr>
<tr>
<td>Enables parallel remark.</td>
<td>
<div><kbd>-XX:+CMSParallel\RemarkEnabled</kbd></div>
</td>
</tr>
<tr>
<td>Enables parallel remark of survivor space.</td>
<td>
<div><kbd>-XX:+CMSParallel\SurvivorRemarkEnabled</kbd></div>
</td>
</tr>
<tr>
<td>You can use this to force young collection before the remark phase.</td>
<td><kbd><span>-XX:+CMSScavengeBeforeRemark</span></kbd></td>
</tr>
<tr>
<td>Use this to prevent scheduling remark if Eden used is below the threshold value.</td>
<td>
<div><kbd>-XX:+CMSScheduleRemark\EdenSizeThreshold</kbd></div>
</td>
</tr>
<tr>
<td>Sets the Eden occupancy percentage that you want CMS to try and schedule a remark pause.</td>
<td>
<div><kbd>-XX:CMSScheduleRemark\EdenPenetration=20</kbd></div>
</td>
</tr>
<tr>
<td>This is where you want to start sampling Eden top at least before young generation occupancy reaches <em>1/4</em><sup>th</sup> (in our sample to the right) of the size at which you want to schedule remark.</td>
<td>
<div><kbd>-XX:CMSScheduleRemark\SamplingRatio=4</kbd></div>
</td>
</tr>
<tr>
<td>You can select <kbd>variant=1</kbd> or <kbd>variant=2</kbd> of verification following remark.</td>
<td><kbd><span>-XX:CMSRemarkVerifyVariant=1</span></kbd></td>
</tr>
<tr>
<td>Elects to use the parallel algorithm for young space collection.</td>
<td><kbd><span>-XX:+UseParNewGC</span></kbd></td>
</tr>
<tr>
<td>Enables the use of multiple threads for concurrent phases.</td>
<td><kbd><span>-XX:+CMSConcurrentMTEnabled</span></kbd></td>
</tr>
<tr>
<td>Sets the number of parallel threads used for the concurrent phases.</td>
<td><kbd><span>-XX:ConcGCThreads=2</span></kbd></td>
</tr>
<tr>
<td>Sets the number of parallel threads you want used for <em>stop-the-world</em> phases.</td>
<td><kbd><span>-XX:ParallelGCThreads=2</span></kbd></td>
</tr>
<tr>
<td>You can enable <strong>incremental CMS</strong> (<strong>iCMS</strong>) mode.</td>
<td><kbd><span>-XX:+CMSIncrementalMode</span></kbd></td>
</tr>
<tr>
<td>If this is not enabled, CMS will not clean permanent space.</td>
<td><kbd><span>-XX:+CMSClassUnloadingEnabled</span></kbd></td>
</tr>
<tr>
<td>This allows <kbd>System.gc()</kbd> to trigger concurrent collection instead of a full garbage collection cycle.</td>
<td>
<div><kbd>-XX:+ExplicitGCInvokes\Concurrent</kbd></div>
</td>
</tr>
<tr>
<td>This allows <kbd>System.gc()</kbd> to trigger concurrent collection of permanent space.</td>
<td>
<div><kbd>‑XX:+ExplicitGCInvokes\ConcurrentAndUnloadsClasses</kbd></div>
</td>
</tr>
</tbody>
</table>
<div class="packt_tip"><strong>iCMS</strong> (<strong>incremental concurrent mark sweep</strong>) mode is intended for servers with a small number of CPUs. It should not be employed on modern hardware.</div>
<p>Here are some miscellaneous garbage collection options:</p>
<table>
<tbody>
<tr>
<td><strong>Miscellaneous garbage collection options</strong></td>
<td><strong>Flag</strong></td>
</tr>
<tr>
<td>This will cause the JVM to ignore any <kbd>System.gc()</kbd> method invocations by an application.</td>
<td><kbd>-XX:+DisableExplicitGC</kbd></td>
</tr>
<tr>
<td>This is the (soft reference) time to live in milliseconds per MB of free space in the heap.</td>
<td><kbd>-XX:SoftRefLRU\PolicyMSPerMB=2000</kbd></td>
</tr>
<tr>
<td>This is the <strong>use policy</strong> used to limit the time spent in garbage collection before an <kbd>OutOfMemory</kbd> error is thrown.</td>
<td><kbd>-XX:+UseGCOverheadLimit</kbd></td>
</tr>
<tr>
<td>This limits the proportion of time spent in garbage collection before an <kbd>OutOfMemory</kbd> error is thrown. This is used with <kbd>GCHeapFreeLimit</kbd>.</td>
<td><kbd>-XX:GCTimeLimit=95</kbd></td>
</tr>
<tr>
<td>This sets the minimum percentage of free space after a full garbage collection before an <kbd>OutOfMemory</kbd> error is thrown. This is used with <kbd>GCTimeLimit</kbd>.</td>
<td><kbd>-XX:GCHeapFreeLimit=5</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Finally, here are some G1 specific options. Note that, these are all supported starting with JVM 6u26:</p>
<table>
<tbody>
<tr>
<td><strong>G1 garbage collection options</strong></td>
<td><strong>Flag</strong></td>
</tr>
<tr>
<td>Size of the heap region. The default is 2,048 and the acceptable range is 1 MiB to 32 MiB.</td>
<td><kbd>-XX:G1HeapRegionSize=16m</kbd></td>
</tr>
<tr>
<td>This is the confidence coefficient pause prediction heuristics.</td>
<td><kbd>-XX:G1ConfidencePercent=75</kbd></td>
</tr>
<tr>
<td>This determines the minimum reserve in the heap.</td>
<td><kbd>-XX:G1ReservePercent=5</kbd></td>
</tr>
<tr>
<td>This is the garbage collection time per MMU--time slice in milliseconds.</td>
<td><kbd>-XX:MaxGCPauseMillis=100</kbd></td>
</tr>
<tr>
<td>This is the pause interval time slice per MMU in milliseconds.</td>
<td><kbd>-XX:GCPauseIntervalMillis=200</kbd></td>
</tr>
</tbody>
</table>
<div class="packt_infobox"><strong>MiB</strong> stands for <strong>Mebibyte</strong> which is a multiple of bytes for digital information.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java methods relevant to garbage collection</h1>
                </header>
            
            <article>
                
<p>Let's look at two specific methods associated with garbage collection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The System.gc() method</h1>
                </header>
            
            <article>
                
<p>Although garbage collection is automatic in Java, you can make explicit calls to the <kbd>java.lang.System.gc()</kbd> method to aid in the debugging process. This method does not take any parameters and does not return any value. It is an explicit call that runs Java's garbage collector. Here is a sample implementation:</p>
<pre>    System.gc();<br/>    System.out.println("Garbage collected and unused <br/>     memory has been deallocated.");</pre>
<p>Let's look at a more in-depth example. In the following code, we start by creating an instance of the <kbd>Runtime</kbd>, using <kbd>Runtime myRuntime = Runtime.getRuntime();</kbd> which returns a singleton. This gives us access to the JVM. After printing some header information and initial memory stats, we create an <kbd>ArrayList</kbd> with a size of <kbd>300000</kbd>. Then, we create a loop that generates <kbd>100000</kbd> array list objects. Lastly, we provide output in three passes, asking the JVM to invoke the garbage collector with <kbd>1</kbd> second pauses in between. Here is the source code:</p>
<pre><span>    package</span> MyGarbageCollectionSuite;<br/><br/><span>    import</span> java.util.ArrayList;<br/><span>    import</span> java.util.concurrent.TimeUnit;<br/><br/><span>    public</span> <span>class</span> GCVerificationTest <br/>    {<br/><span>      public</span> <span>static</span> <span>void</span> main(String[] <span>args</span>) <span>throws</span> <br/>       InterruptedException <br/>       {<br/>         // Obtain a Runtime instance (to communicate<br/>          with the JVM)<br/>         Runtime <span>myRuntime</span> = Runtime.getRuntime();<br/><br/>         // Set header information and output initial <br/>          memory <span>stats<br/></span><span>         System.</span><span>out</span><span>.println(</span>"Garbage Collection<br/>          Verification Test"<span>);<br/></span><span>         System.</span><span>out</span><span>.println(</span>"-----------------------------<br/>          -----------------------------"<span>);<br/></span>         System.<span>out</span>.println(<span>"Initial JVM Memory: "</span> + <br/><span>          myRuntime</span>.totalMemory() + <br/><span>            "\tFree Memory: "</span> + <span>myRuntime</span>.freeMemory());<br/>    <br/>         // Use a bunch of memory<br/>         ArrayList&lt;Integer&gt; <span>AccountNumbers</span> = <span>new</span> <br/>          ArrayList&lt;&gt;(300000);<br/><span>         for</span> (<span>int</span> <span>i</span> = 0; <span>i</span> &lt; 100000; <span>i</span>++)<br/>         {<br/><span>           AccountNumbers</span> = <span>new</span> ArrayList&lt;&gt;(3000);<br/>           AccountNumbers<span> = </span><span>null</span><span>;<br/></span>         }<br/><br/>         // Provide update with with three passes<br/><span>         for</span> (<span>int</span> <span>i</span> = 0; <span>i</span> &lt; 3; <span>i</span>++)<br/>         {<br/><span>           System.</span><span>out</span><span>.println(</span>"---------------------------<br/>            -----------"<span>);<br/></span>           System.<span>out</span>.println(<span>"Free Memory before<br/>            collection number "</span> + <br/>              (<span>i</span>+1) + <span>": "</span> + <span>myRuntime</span>.freeMemory());<br/>           System.gc();<br/>           System.<span>out</span>.println(<span>"Free Memory after<br/>            collection number "</span> + <br/>              (<span>i</span>+1) + <span>": "</span> + <span>myRuntime</span>.freeMemory());<br/><span>           TimeUnit.</span><span>SECONDS</span><span>.sleep(1); </span>// delay thread <br/>            1 second<br/>         }<br/><br/>       }<br/><br/>    }</pre>
<p>As you can see from the following output, the garbage collector did not reallocate all of the 'garbage' during the first or even the second pass:</p>
<div class="CDPAlignCenter CDPAlign"><img height="172" width="383" src="assets/e4940c1f-fd9d-462d-b72b-7adfd6cf8ee0.png"/></div>
<p>There is an alternative to using the <kbd>System.gc()</kbd> method to invoke the garbage collector. In our example, we could have used <kbd>myRuntime.gc()</kbd>, our earlier singleton example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The finalize() method</h1>
                </header>
            
            <article>
                
<p>You can think of Java's garbage collector as a death dealer. When it removes something from memory, it is gone. This so-called death dealer is not without compassion as it provides each method with their final last words. The objects give their <em>last words</em> through a <kbd>finalize()</kbd> method. If an object has a <kbd>finalize()</kbd> method, the garbage collector invokes it before the object is removed and the associated memory deallocated. The method takes no parameters and has a return type of <kbd>void</kbd>.</p>
<p>The <kbd>finalize()</kbd> method is only called once and there can be variability when it is run. Certainly, the method is invoked before it is removed, but when the garbage collector runs is dependent on the system. If, as an example, you have a relatively small app that is running a memory-rich system, the garbage collector might not run at all. So, why include a <kbd>finalize()</kbd> method at all? It is considered poor programming practice to override the <kbd>finalize()</kbd> method. That being said, you can use the method if needed. In fact, you can add code there to add a reference to your object to ensure it is not removed by the garbage collector. Again, this is not advisable.</p>
<p>Because all objects in Java, even the ones you create yourself are child classes of <kbd>java.lang.Object</kbd>, every object in Java has a <kbd>finalize()</kbd> method.</p>
<p>The garbage collector, as sophisticated as it is, might not close databases, files, or network connections the way you want it done. If your application requires specific considerations when its objects are collected, you can override the object's <kbd>finalize()</kbd> method.</p>
<p>Here is an example implementation that demonstrates a use case for when you might want to override an object's <kbd>finalize()</kbd> method:</p>
<pre>    public<span> </span>class<span> Animal <br/>    {<br/></span>      private<span> </span>static<span> String </span><span>animalName</span><span>;<br/></span>      private<span> </span>static<span> String </span>animalBreed<span>;<br/></span>      private<span> </span>static<span> </span>int<span> </span><span>objectTally</span><span> = 0;<br/><br/></span>      // constructor<br/><span>      public</span> Animal(String <span>name</span>, String <span>type</span>) <br/>      {<br/>        animalName<span> = </span><span>name</span><span>;<br/></span>        animalBreed<span> = </span><span>type</span><span>;<br/><br/></span>       // increment count of object<br/><span>        ++</span>objectTally<span>;<br/></span>      }<br/><br/><span>      protected</span> <span>void</span> finalize()<br/>      {<br/>        // decrement object count each time this method<br/>        // is called by the garbage collector<br/><span>        --</span>objectTally<span>;<br/><br/></span>        //Provide output to user<br/><span>        System.</span><span>out</span><span>.println(</span><span>animalName</span><span> + </span>" has been <br/>         removed from memory."<span>);<br/><br/></span><span>  <br/>        // condition for 1 animal (use singular form)<br/>        if</span><span> (</span><span>objectTally</span><span> == 1) </span><br/>        {<br/><span>          System.</span><span>out</span><span>.println(</span>"You have "<span> + </span><span>objectTally</span><span> + </span>"<br/>           animal remaining."<span>);<br/></span>        }<br/><br/>        // condition for 0 or greater than 1 <br/>         animals (use plural form)<br/><span>        else</span><span> </span><br/>        {<br/><span>          System.</span><span>out</span><span>.println(</span>"You have "<span> + </span><span>objectTally</span><span> + </span>"<br/>           animals remaining."<span>);<br/></span>        }<br/><br/>      }<br/><br/>    }</pre>
<p>As you can see in the preceding code, the <kbd>objectTally</kbd> count is incremented each time an object of type <kbd>Animal</kbd> is created and decremented when one is removed by the garbage collector.</p>
<div class="packt_tip">Overriding an object's <kbd>finalize()</kbd> method is usually discouraged. The <kbd>finalize()</kbd> method should normally be declared as <kbd>protected</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-Java 9 garbage collection</h1>
                </header>
            
            <article>
                
<p>Java's garbage collection is not new to Java 9, it has existed since the initial release of Java. Java has long had a sophisticated garbage collection system that is automatic and runs in the background. By running in the background, we are referring to garbage collection processes running during idle times.</p>
<div class="packt_infobox">Idle times refer to the time in between input/output such as between keyboard input, mouse clicks, and output generation.</div>
<p>This automatic garbage collection has been one of the key factors in developers selecting Java for their programming solutions. Other programming languages such as C# and Objective-C have implemented garbage collection following the success of the Java platform.</p>
<p>Let's next take a look at the following listed concepts before we look at the changes to garbage collection in the Java 9 platform:</p>
<ul>
<li>Visualizing garbage collection</li>
<li>Garbage collection upgrades in Java 8</li>
<li>Case study - Games written with Java</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing garbage collection</h1>
                </header>
            
            <article>
                
<p>It can be helpful to visualize how garbage collection works and, perhaps more importantly, the need for it. Consider the following code snippet that progressively creates the string <kbd>Garbage</kbd>:</p>
<pre>    001 String var = new String("G");<br/>    002 var += "a";<br/>    003 var += "r";<br/>    004 var += "b";<br/>    005 var += "a";<br/>    006 var += "g";<br/>    007 var += "e";<br/>    008 System.out.println("Your completed String<br/>     is: " + var + ".");</pre>
<p>Clearly, the preceding code generates the output provided as follows:</p>
<pre>    Your completed String is Garbage.</pre>
<p>What might not be clear is that the sample code results in five unreferenced string objects. This is due, in part, because strings are immutable. As you can see in the following illustration, with each successive line of code, the referenced object is updated and an additional object becomes unreferenced:</p>
<div class="CDPAlignCenter CDPAlign"><img height="203" width="546" src="assets/b31863c4-6d01-4bc9-b7f2-7a28ca5c54a1.png"/></div>
<p>The preceding unreferenced objects listed certainly will not break the memory bank, but it is indicative of how quickly a large number of unreferenced objects can accumulate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Garbage collection upgrades in Java 8</h1>
                </header>
            
            <article>
                
<p>As of Java 8, the default garbage collection algorithm was the parallel garbage collector. Java 8 was released with some improvements to the G1 garbage collection system. One of these improvements was the ability to use the following command-line option to optimize the heap memory by removing duplicative string values:</p>
<pre><strong>-XX:+UseStringDeduplication</strong></pre>
<p>The G1 garbage collector can view the character arrays when it sees a string. It then takes the value and stores it with a new, weak reference to the character array. If the G1 garbage collector finds a string with the same hash code, it will compare the two strings with a character-by-character review. If a match is found, both strings end up pointing to the same character array. Specifically, the first string will point to the character array of the second string.</p>
<p>This method can require substantial processing overhead and should only be used if deemed beneficial or absolutely necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study - Games written with Java</h1>
                </header>
            
            <article>
                
<p>Multiplayer games require extensive management techniques, both for server and client systems. The JVM runs the garbage collection thread in a low-priority thread and periodically runs. Server administrators previously used an incremental garbage collection schema using the now depreciated <kbd>-Xincgc</kbd> command-line option to avoid <strong>server stalls</strong> that occur when the server is overloaded. The goal is to have garbage collection run more frequently and with much shorter execution cycles each time.</p>
<div class="packt_tip">When considering memory usage and garbage collection, it is important to use as little memory on the target system as possible and to limit pauses for garbage collection to the extent feasible. These tips are especially important for games, simulations, and other applications that require real-time performance.</div>
<p>The JVM manages the heap where Java memory is stored. The JVM starts with a small heap by default and grows as additional objects are created. The heap has two partitions--young and tenured. When objects are initially created, they are created in the young partition. Persistent objects are moved to the tenure partition. The creation of objects is usually very quick with not much more than pointer incrementation. Processing in the young partition is much faster than that of the tenured partition. This is important because it applies to the overall app, or in our case, a game's efficiency.</p>
<p>It becomes important for us to monitor our game's memory usage and when garbage collection occurs. To monitor garbage collection, we can add the verbose flag (<kbd>-verbose:gc</kbd>) when we launch our game such as with the following example:</p>
<pre><strong>java -verbose:gc MyJavaGameClass</strong></pre>
<p>The JVM will then provide a line of formatted output for each garbage collection. Here is the format of the verbose GC output:</p>
<pre>    [&lt;TYPE&gt; &lt;MEMORY USED BEFORE&gt; -&gt; MEMORY USED AFTER<br/>     (TOTAL HEAP SIZE), &lt;TIME&gt;]</pre>
<p>Let's look at two examples. In this first example, we see <kbd>GC</kbd> for type which refers to the young partition we previously discussed:</p>
<pre>    [GC 31924K -&gt; 29732K(42234K), 0.0019319 secs]</pre>
<p>In this second example, <kbd>Full GC</kbd> indicates that the garbage collection action was taken on the tenured partition of the memory heap:</p>
<pre>    [Full GC 29732K -&gt; 10911K(42234K), 0.0319319 secs]</pre>
<p>You can obtain more detailed information from the garbage collector using the <kbd>-XX:+PrintGCDetails</kbd> option as shown here:</p>
<pre><strong>java -verbose:gc -XX:+PrintGCDetails MyJavaGameClass</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collecting garbage with the new Java platform</h1>
                </header>
            
            <article>
                
<p>Java came out of the gate with automatic garbage collection, making it a development platform of choice for many programmers. It was commonplace to want to avoid manual memory management in other programming languages. We have looked in-depth at the garbage collection system to include the various approaches, or algorithms, used by the JVM. Java 9 includes some relevant changes to the garbage collection system and was the focus of three <strong>Java Enhancement Program</strong> (<strong>JEP</strong>) issues. Those issues are listed here:</p>
<ul>
<li>Default garbage collection (JEP 248)</li>
<li>Depreciated garbage collection combinations (JEP 214)</li>
<li>Unified garbage collection logging (JEP 271)</li>
</ul>
<p>We will review each one of these garbage collection concepts and their corresponding <strong>Java Enhancement Plan</strong> (<strong>JEP</strong>) issue in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default garbage collection</h1>
                </header>
            
            <article>
                
<p>We previously detailed the following garbage collection approaches used by the JVM prior to Java 9. These are still plausible garbage collection algorithms:</p>
<ul>
<li>CMS garbage collection</li>
<li>Serial garbage collection</li>
<li>Parallel garbage collection</li>
<li>G1 garbage collection</li>
</ul>
<p>Let's briefly recap each of these approaches:</p>
<ul>
<li><strong>CMS garbage collection</strong>: The CMS garbage collection algorithm scans heap memory using multiple threads. Using this approach, the JVM marks objects for removal and then makes a sweep to actually remove them.</li>
<li><strong>Serial garbage collection</strong>: This approach uses a thread-freezing schema on a single thread. When the garbage collection is in progress, it freezes all other threads until garbage collection operations have concluded. Due to the thread-freezing nature of serial garbage collection, it is only feasible for very small programs.</li>
<li><strong>Parallel garbage collection</strong>: This approach uses multiple threads but freezes all non-garbage collection threads in the application until garbage collection functions have completed, just like the serial garbage collection algorithm.</li>
<li><strong>G1 garbage collection</strong>: This is the garbage collection algorithm with the following characteristics:
<ul>
<li>Is used with large memory heaps</li>
<li>Involves segmenting the memory heap into regions</li>
<li>Takes place in parallel with each heap region</li>
<li>Compacts the heap space when memory is deallocated</li>
<li>Compacting operations take place using the <em>Stop the World</em> approach</li>
<li><span>Prioritizes the regions based on those that have the most garbage to be collected</span></li>
</ul>
</li>
</ul>
<p>Prior to Java 9, the parallel garbage collection algorithm was the default garbage collector. In Java 9, the G1 garbage collector is the new default implementation of Java's memory management system. This is true for both 32 and 64-bit server configurations.</p>
<p>Oracle assessed that the G1 garbage collector, mostly due to its low-pause nature, was a better performing garbage collection method than the parallel approach. This change was predicated on the following concepts:</p>
<ul>
<li>It is important to limit latency</li>
<li>Maximizing throughput is less important than limiting latency</li>
<li>The G1 garbage collection algorithm is stable</li>
</ul>
<p>There are two assumptions involved with making the G1 garbage collection method the default method over the parallel approach:</p>
<ul>
<li>Making G1 the default garbage collection method will significantly increase its use. This increased usage might unveil performance or stability issues not realized before Java 9.</li>
<li>The G1 approach is more processor-intensive than the parallel approach. In some use cases, this could be somewhat problematic.</li>
</ul>
<p>On the surface this change might seem like a great step for Java 9 and that very well might be the case. Caution, however, should be used when blindly accepting this new default collection method. It is recommended that systems be tested if switching to G1 to ensure your applications do not suffer from performance degradation or have unexpected issues that are caused by the use of G1. As previously suggested, G1 has not benefited from the widespread testing that the parallel method has.</p>
<p>This last point about the lack of widespread testing is significant. Making G1 the default automatic memory management (garbage collection) system with Java 9 is tantamount to turning developers into unsuspecting testers. While no major problems are expected, knowing that there is potential for performance and stability issues when using G1 with Java 9 will place greater emphasis on testing your Java 9 applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Depreciated garbage collection combinations</h1>
                </header>
            
            <article>
                
<p>Oracle has been great about depreciating features, APIs, and libraries before removing them from a new release to the Java platform. With this schema in place, language components that were depreciated in Java 8 are subject for removal in Java 9. There are a few garbage collection combinations that were deemed to be rarely used and depreciated in Java 8. Those combinations, listed here, have been removed in Java 9:</p>
<ul>
<li>DefNew + CMS</li>
<li>ParNew + SerialOld</li>
<li>Incremental CMS</li>
</ul>
<p>These combinations, in addition to having been rarely used, introduced an unneeded level of complexity to the garbage collection system. This resulted in an extra drain on system resources without providing a commensurate benefit to the user or developer.</p>
<p>The following listed garbage collection configurations were affected by the aforementioned depreciation in the Java 8 platform:</p>
<table>
<tbody>
<tr>
<td><strong>Garbage collection configuration</strong></td>
<td><strong>Flag(s)</strong></td>
</tr>
<tr>
<td>DefNew + CMS</td>
<td>
<p class="mce-root"><kbd>-XX:+UseParNewGC</kbd></p>
<p><kbd>-XX:UseConcMarkSweepGC</kbd></p>
</td>
</tr>
<tr>
<td>ParNew + SerialOld</td>
<td><kbd>-XX:+UseParNewGC</kbd></td>
</tr>
<tr>
<td>ParNew + iCMS</td>
<td><kbd>-Xincgc</kbd></td>
</tr>
<tr>
<td>ParNew + iCMS</td>
<td>
<p class="mce-root"><kbd>-XX:+CMSIncrementalMode</kbd></p>
<p><kbd>-XX:+UseConcMarkSweepGC</kbd></p>
</td>
</tr>
<tr>
<td>Defnew + ICMS</td>
<td>
<p class="mce-root"><kbd>-XX:+CMSIncrementalMode</kbd></p>
<p><kbd>-XX:+UseConcMarkSweepGC</kbd></p>
<p><kbd>-XX:-UseParNewGC</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <strong>Java Enhancement Program 214</strong> (<strong>JEP 214</strong>) removed garbage collection combinations depreciated in JDK 8. Those combinations are listed above along with the flags that control those combinations. In addition, the flags to enable CMS foreground collections were removed and are not present in JDK 9. Those flags are listed as follows:</p>
<table>
<tbody>
<tr>
<td><strong>Garbage collection combinations</strong></td>
<td><strong>Flag</strong></td>
</tr>
<tr>
<td>CMS foreground</td>
<td><kbd>-XX:+UseCMSCompactAtFullCollection</kbd></td>
</tr>
<tr>
<td>CMS foreground</td>
<td><kbd>-XX+CMSFullGCsBeforeCompaction</kbd></td>
</tr>
<tr>
<td>CMS foreground</td>
<td><kbd>-XX+UseCMSCollectionPassing</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>The only assessed downside to the removal of the depreciated garbage collection combinations is that applications that use JVM start up files with any of the flags listed in this section, will need to have their JVM start up files modified to remove or replace the old flags.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unified garbage collection logging</h1>
                </header>
            
            <article>
                
<p>The <strong>Java Enhancement Program #271</strong> (<strong>JEP-271</strong>) titled, <em>Unified GC Logging</em>, is intended to re-implement garbage collection logging using the unified JVM logging framework that was previously introduced with JEP-158. So, let's first review the Unified JVM Logging (JEP-158).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unified JVM logging (JEP-158)</h1>
                </header>
            
            <article>
                
<p>Creating a unified logging schema for the JVM was the central goal of JEP-158. Here is a high-level list of the goals of the JEP:</p>
<ul>
<li>Create a JVM-wide set of command-line options for all logging operations</li>
<li>Use categorized tags for logging</li>
<li>Provide six levels of logging:
<ul>
<li>Error</li>
<li>Warning</li>
<li>Information</li>
<li>Debug</li>
<li>Trace</li>
<li>Develop</li>
</ul>
</li>
</ul>
<div class="packt_infobox">This is not an exhaustive list of goals. We will discuss JEP-158 in greater detail in <a href="e1747284-a850-4e00-b044-fd06c6eb266d.xhtml" target="_blank">Chapter 14</a>, <em>Command Line Flags</em>.</div>
<p>The changes to the JVM, in the context of logging, can be categorized into:</p>
<ul>
<li>Tags</li>
<li>Levels</li>
<li>Decorations</li>
<li>Output</li>
<li>Command-line options</li>
</ul>
<p>Let's briefly look at these categories.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tags</h1>
                </header>
            
            <article>
                
<p>Logging tags are identified in the JVM and can be changed in source code if needed. The tags should be self-identifying, such as <kbd>gc</kbd> for garbage collection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Levels</h1>
                </header>
            
            <article>
                
<p>Each log message has an associated level. As previously listed, the levels are error, warning, information, debug, trace, and develop. The following chart shows how the levels have an increasing level of verbosity in respect to how much information is logged:</p>
<div class="CDPAlignCenter CDPAlign"><img height="247" width="370" src="assets/4873820c-96fb-4fb4-92f8-9e9369193dd9.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorations</h1>
                </header>
            
            <article>
                
<p>In the context of Java 9's logging framework, decorations is metadata about the log message. Here is the alphabetic list of decorations that are available:</p>
<ul>
<li>level</li>
<li>pid</li>
<li>tags</li>
<li>tid</li>
<li>time</li>
<li>timemillis</li>
<li>timenanos</li>
<li>uptime</li>
<li>uptimemillis</li>
<li>uptimenanos</li>
</ul>
<p>For an explanation of these decorations, please refer to <a href="e1747284-a850-4e00-b044-fd06c6eb266d.xhtml" target="_blank">Chapter 14</a>, <em>Command Line Flags</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Output</h1>
                </header>
            
            <article>
                
<p>The Java 9 logging framework supports three types of output:</p>
<ul>
<li>stderr: Provides output to stderr</li>
<li>stdout: Provides output to stdout</li>
<li>text file: Writes the output to text files</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command-line options</h1>
                </header>
            
            <article>
                
<p>A new command-line option was added to the logging framework to provide overall control of the JVM's logging operations. The <kbd>-Xlog</kbd> command-line option has an extensive array of parameters and possibilities. Here is one example:</p>
<pre><strong>-Xlog:gc+rt*=debug</strong></pre>
<p>In this example, we are telling the JVM to take the following actions:</p>
<ul>
<li>Log all messages tagged with, at a minimum, the <kbd>gc</kbd> and <kbd>rt</kbd> tags</li>
<li>Use the <kbd>debug</kbd> level</li>
<li>Provide output to <kbd>stdout</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unified GC logging (JEP-271)</h1>
                </header>
            
            <article>
                
<p>Now that we have a general understanding of the changes to Java 9's logging framework, let's look at what changes JEP-271 introduced. In this section we will look at the following areas:</p>
<ul>
<li>Garbage collection logging options</li>
<li>The <kbd>gc</kbd> tag</li>
<li>Macros</li>
<li>Additional considerations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Garbage collection logging options</h1>
                </header>
            
            <article>
                
<p>Here is a list of garbage collection logging options and flags we had available to us before the introduction of Java 9's logging framework:</p>
<table>
<tbody>
<tr>
<td><strong>Garbage collection logging option</strong></td>
<td><strong>JVM option flag(s)</strong></td>
</tr>
<tr>
<td>This prints the basic garbage collection information.</td>
<td><kbd><span>-verbose:gc</span></kbd> <span>or</span> <kbd><span>-XX:+PrintGC</span></kbd></td>
</tr>
<tr>
<td>This will print more detailed garbage collection information.</td>
<td><kbd><span>-XX:+PrintGCDetails</span></kbd></td>
</tr>
<tr>
<td>You can print timestamps for each garbage collection event. The seconds are sequential and begin from the JVM start time.</td>
<td><kbd><span>-XX:+PrintGCTimeStamps</span></kbd></td>
</tr>
<tr>
<td>
<p class="mce-root">You can print date stamps for each garbage collection event. Sample format:</p>
<p><kbd>2017-07-26T03:19:00.319+400:[GC . . . ]</kbd></p>
</td>
<td><kbd><span>-XX:+PrintGCDateStamps</span></kbd></td>
</tr>
<tr>
<td>You can use this flag to print timestamps for individual garbage collection work thread tasks.</td>
<td>
<div><kbd>-XX:+PrintGC\TaskTimeStamps</kbd></div>
</td>
</tr>
<tr>
<td>Using this you can redirect garbage collection output to a file instead of the console.</td>
<td><kbd><span>-Xloggc:</span></kbd></td>
</tr>
<tr>
<td>You can print detailed information regarding young space following each collection cycle.</td>
<td>
<div><kbd>-XX:+Print\TenuringDistribution</kbd></div>
</td>
</tr>
<tr>
<td>You can use this flag to print TLAB allocation statistics.</td>
<td><kbd><span>-XX:+PrintTLAB</span></kbd></td>
</tr>
<tr>
<td>Using this flag, you can print the times for reference processing (that is, weak, soft, and so on) during <em>stop-the-world</em> pauses.</td>
<td><kbd><span>-XX:+PrintReferenceGC</span></kbd></td>
</tr>
<tr>
<td>This reports if the garbage collection is waiting for native code to unpin objects in memory.</td>
<td><kbd><span>-XX:+PrintJNIGCStalls</span></kbd></td>
</tr>
<tr>
<td>This will print a pause summary after each <em>stop-the-world</em> pause.</td>
<td>
<div><kbd>-XX:+PrintGC\ApplicationStoppedTime</kbd></div>
</td>
</tr>
<tr>
<td>This flag will print time for each concurrent phase of garbage collection.</td>
<td>
<div><kbd>-XX:+PrintGC\ApplicationConcurrentTime</kbd></div>
</td>
</tr>
<tr>
<td>Using this flag will print a class histogram after a full garbage collection.</td>
<td>
<div><kbd>-XX:+Print\ClassHistogramAfterFullGC</kbd></div>
</td>
</tr>
<tr>
<td>Using this flag will print a class histogram before a full garbage collection.</td>
<td>
<div><kbd>-XX:+Print\ClassHistogramBeforeFullGC</kbd></div>
</td>
</tr>
<tr>
<td>This creates a heap dump file after full garbage collection.</td>
<td>
<div><kbd>-XX:+HeapDump\AfterFullGC</kbd></div>
</td>
</tr>
<tr>
<td>This creates a heap dump file before full garbage collection.</td>
<td>
<div><kbd>-XX:+HeapDump\BeforeFullGC</kbd></div>
</td>
</tr>
<tr>
<td>This creates a heap dump file in an out-of-memory condition.</td>
<td>
<div><kbd>-XX:+HeapDump\OnOutOfMemoryError</kbd></div>
</td>
</tr>
<tr>
<td>You use this flag to specify the path where you want your heap dumps saved on your system.</td>
<td><kbd><span>-XX:HeapDumpPath=&lt;path&gt;</span></kbd></td>
</tr>
<tr>
<td>You can use this to print CMS statistics, <kbd>if n &gt;= 1</kbd>. Applies specifically to CMS only.</td>
<td><kbd><span>-XX:PrintCMSStatistics=2</span></kbd></td>
</tr>
<tr>
<td>This will print CMS initialization details. Applies specifically to CMS only.</td>
<td>
<div><kbd>-XX:+Print\CMSInitiationStatistics</kbd></div>
</td>
</tr>
<tr>
<td>You can use this flag to print additional information concerning free lists. Applies specifically to CMS only.</td>
<td><kbd><span>-XX:PrintFLSStatistics=2</span></kbd></td>
</tr>
<tr>
<td>You can use this flag to print additional information concerning free lists. Applies specifically to CMS only.</td>
<td><kbd><span>-XX:PrintFLSCensus=2</span></kbd></td>
</tr>
<tr>
<td>You can use this flag to print detailed diagnostic information following a promotion (young to tenure) failure. Applies specifically to CMS only.</td>
<td><kbd><span>-XX:+PrintPromotionFailure</span></kbd></td>
</tr>
<tr>
<td>This flag allows you to dump useful information regarding the state of the CMS old generation when a promotion (young to tenure) failure occurs. Applies specifically to CMS only.</td>
<td>
<div><kbd>-XX:+CMSDumpAt\PromotionFailure</kbd></div>
</td>
</tr>
<tr>
<td>When the <kbd>-XX:+CMSDumpAt\PromotionFailure</kbd> flag is used, you can use <kbd>-XX:+CMSPrint\ChunksInDump</kbd> to include additional details regarding free chunks. Applies specifically to CMS only.</td>
<td>
<div><kbd>-XX:+CMSPrint\ChunksInDump</kbd></div>
</td>
</tr>
<tr>
<td>When using the <kbd>-XX:+CMSPrint\ChunksInDump</kbd> flag, you can include additional information about the allocated objects using the <kbd>-XX:+CMSPrint\ObjectsInDump</kbd> flag. Applies specifically to CMS only.</td>
<td>
<div><kbd>-XX:+CMSPrint\ObjectsInDump</kbd></div>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The gc tag</h1>
                </header>
            
            <article>
                
<p>We can use the <kbd>gc</kbd> tag with the <kbd>-Xlog</kbd> option to inform the JVM to only log <kbd>gc</kbd> tagged items at the info level. As you will recall, this is similar to using <kbd>-XX:+PrintGC</kbd>. With both options, the JVM will log one line for each garbage collection operation.</p>
<p>It is important to note that the <kbd>gc</kbd> tag was not intended to be used on its own; rather, it is recommended that it be used in conjunction with other tags.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Macros</h1>
                </header>
            
            <article>
                
<p>We can create macros to add logic to our garbage collection logging. Here is the general syntax for the log macro:</p>
<pre>    log_&lt;level&gt;(Tag1[,...])(fmtstr, ...)</pre>
<p>Here is an example of a log macro:</p>
<pre>    log_debug(gc, classloading)("Number of objects<br/>     loaded: %d.", object_count)</pre>
<p>The following example skeleton log macro shows how you can use the new Java 9 logging framework to create scripts for greater fidelity in logging:</p>
<pre>    LogHandle(gc, rt, classunloading) log;<br/>    if (log.is_error())<br/>    {<br/>      // do something specific regarding the 'error' level<br/>    }<br/><br/>    if (log.is_warning())<br/>    {<br/>      // do something specific regarding the 'warning'<br/>      level<br/>    }<br/><br/>    if (log.is_info())<br/>    {<br/>      // do something specific regarding the 'info' level<br/>    }<br/><br/>    if (log.is_debug())<br/>    {<br/>      // do something specific regarding the 'debug' level<br/>    }<br/><br/>    if (log.is_trace())<br/>    {<br/>      // do something specific regarding the 'trace' level<br/>    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional considerations</h1>
                </header>
            
            <article>
                
<p>Here are some additional items to be considered in regards to garbage collection logging:</p>
<ul>
<li>Using the new <kbd>-Xlog:gc</kbd> should produce similar results to the <kbd>-XX:+PrintGCDetails</kbd> command-line option and flag pairing</li>
<li>The new <kbd>trace</kbd> level provides the level of detail previously provided with the <kbd>verbose</kbd> flag</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Persistent issues</h1>
                </header>
            
            <article>
                
<p>Even with the advent of Java 9, there were downsides to Java's garbage collection system. Because it is an automatic process, we do not have complete control of when the collector runs. We, as developers, are not in control of garbage collection, the JVM is. The JVM makes the decision when to run garbage collection. As you have seen earlier in this chapter, we can ask the JVM to run garbage collection using the <kbd>System.gc()</kbd> method. Despite our use of this method, we are guaranteed that our request will be honored or that it will be complied with in a timely manner.</p>
<p>Earlier in this chapter, we reviewed several approaches and algorithms for garbage collection. We discussed how we, as developers, can take control of the process. That assumes that we have the ability to take control of garbage collection. Even when we specify a specific garbage collection technique, for example using <kbd>-XX:+UseConcMarkSweepGC</kbd> for CMS garbage collection, we are not guaranteed that the JVM will use that implementation. So, we can do our best to control how the garbage collector works, but should remember that the JVM has the ultimate authority regarding how, when, and if garbage collection occurs.</p>
<p>Our lack of complete control over garbage collection underscores the importance of writing efficient code with memory management in mind. In the next sections, we will examine how to write code to explicitly make objects eligible for garbage collection by the JVM.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making objects eligible for garbage collection</h1>
                </header>
            
            <article>
                
<p>An easy method for making objects available for garbage collection is to assign <kbd>null</kbd> to the reference variable that refers to the object. Let's review this example:</p>
<pre><span>    package</span> MyGarbageCollectionSuite;<br/><br/><span>    public</span> <span>class</span> GarbageCollectionExperimentOne <br/>    {<br/><span>      public</span> <span>static</span> <span>void</span> main(String[] <span>args</span>) <br/>      {<br/><br/>        // Declare and create new object.<br/>        String <span>junk</span> = <span>new</span> String(<span>"Pile of Junk"</span>);<br/><br/>        // Output to demonstrate that the object<br/>        has an active reference<br/>        // and is not eligible for garbage collection.<br/>        System.<span>out</span>.println(<span>junk</span>);<br/><br/>        // Set the reference variable to null.<br/><span>        junk</span> = <span>null</span>;<br/><br/>        // The String object junk is now eligible<br/>        for garbage collection.<br/><br/>      }<br/><br/>    }</pre>
<p>As indicated in the in-code comments, once the string object reference variable is set to null, in this case using the <kbd>junk = null;</kbd> statement, the object becomes available for garbage collection.</p>
<p>In our next example, we will abandon an object by setting its reference variable to point to a different object. As you can see in the following code, that results in the first object being available for garbage collection:</p>
<pre><span>    package</span> MyGarbageCollectionSuite;<br/><br/><span>    public</span> <span>class</span> GarbageCollectionExperimentTwo<br/>    {<br/><span>      public</span> <span>static</span> <span>void</span> main(String[] <span>args</span>)<br/>      {<br/>        // Declare and create the first object.<br/><span>        String </span><span>junk1</span><span> = </span><span>new</span><span> String(</span>"The first pile of<br/>         Junk"<span>);<br/><br/></span>        // Declare and create the second object.<br/><span>        String </span><span>junk2</span><span> = </span><span>new</span><span> String(</span>"The second pile of <br/>         Junk"<span>);<br/><br/></span>        // Output to demonstrate that both objects have<br/>        active references<br/>        // and are not eligible for garbage collection.<br/>        System.<span>out</span>.println(<span>junk1</span>);<br/>        System.<span>out</span>.println(<span>junk2</span>);<br/><br/>        // Set the first object's reference to the<br/>         second object.<br/>        junk1<span> = </span>junk2;<br/><br/>        // The String "The first pile of Junk" is now<br/>         eligible for garbage collection.<br/><br/>      }<br/><br/>    }</pre>
<p>Let's review one final method of making objects available for garbage collection. In this example, we have a single instance variable (<kbd>objectNbr</kbd>) that is a reference variable to an instance of the <kbd>GarbageCollectionExperimentThree</kbd> class. The class does not do anything interesting other than create additional reference variables to instances of the <kbd>GarbageCollectionExperimentThree</kbd> class. In our example, we set the <kbd>objectNbr2</kbd>, <kbd>objectNbr3</kbd>, <kbd>objectNbr4</kbd>, and <kbd>objectNbr5</kbd> references to <kbd>null</kbd>. Although these objects have instance variables and can refer to each other, their accessibility outside of the class has been terminated by setting their references to <kbd>null</kbd>. This makes them ( <kbd>objectNbr2</kbd>, <kbd>objectNbr3</kbd>, <kbd>objectNbr4</kbd>, and <kbd>objectNbr5</kbd> ) eligible for garbage collection:</p>
<pre><span>    package</span> MyGarbageCollectionSuite;<br/>    {<br/><br/>      // instance variable<br/>      GarbageCollectionExperimentThree <span>objectNbr</span>;<br/><br/><span>      public</span> <span>static</span> <span>void</span> main(String[] <span>args</span>) <br/>      {<br/>        GarbageCollectionExperimentThree <span>objectNbr2</span> = <span>new<br/></span>         GarbageCollectionExperimentThree();<br/>        GarbageCollectionExperimentThree <span>objectNbr3</span> = <span>new<br/></span>         GarbageCollectionExperimentThree();<br/>        GarbageCollectionExperimentThree <span>objectNbr4</span> = <span>new<br/></span>         GarbageCollectionExperimentThree();<br/>        GarbageCollectionExperimentThree <span>objectNbr5</span> = <span>new<br/></span>         GarbageCollectionExperimentThree();<br/>        GarbageCollectionExperimentThree <span>objectNbr6</span> = <span>new<br/></span>         GarbageCollectionExperimentThree();<br/>        GarbageCollectionExperimentThree <span>objectNbr7</span> = <span>new<br/></span>         GarbageCollectionExperimentThree();<br/><br/>        // set objectNbr2 to refer to objectNbr3<br/>        objectNbr2<span>.</span><span>objectNbr</span><span> = </span>objectNbr3<span>;<br/><br/></span>        // set objectNbr3 to refer to objectNbr4<br/>        objectNbr3<span>.</span><span>objectNbr</span><span> = </span>objectNbr4<span>;<br/><br/></span>        // set objectNbr4 to refer to objectNbr5<br/>        objectNbr4<span>.</span><span>objectNbr</span><span> = </span>objectNbr5<span>;<br/><br/></span>        // set objectNbr5 to refer to objectNbr2<br/>        objectNbr5<span>.</span><span>objectNbr</span><span> = </span>objectNbr2<span>;<br/><br/></span>        // set selected references to null<br/>        objectNbr2<span> = </span><span>null</span><span>;<br/></span>        objectNbr3<span> = </span><span>null</span><span>;<br/></span>        objectNbr4<span> = </span><span>null</span><span>;<br/></span>        objectNbr5<span> = </span><span>null</span><span>;<br/><br/></span>      }<br/><br/>    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter we took an in-depth review of garbage collection as a critical pre-Java 9 platform component. Our review included object life cycle, garbage collection algorithms, garbage collection options, and methods related to garbage collection. We looked at upgrades to garbage collection in Java 8 and looked at a case study to help our understanding of modern garbage collection. We then turned our focus to the changes to garbage collection with the new Java 9 platform. Our exploration of garbage collection in Java 9 included looks at default garbage collection, depreciated garbage collection combinations, and unified garbage collection logging. We concluded our exploration of garbage collection by looking at a few garbage collection issues that persist, even after Java 9.</p>
<p>In the next chapter we will look at how to write performance tests using the <strong>Java Microbenchmark Harness</strong> (<strong>JMH</strong>), a Java harness library for writing benchmarks for the JVM.</p>
<p> </p>


            </article>

            
        </section>
    </body></html>