<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Shaping our Scala Program</h1>
                
            
            <article>
                
<div class="packt_quote">"I conclude that there are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult."</div>
<div class="packt_quote1">- C. A. R. Hoare</div>
<p class="calibre2">A program is a solution specific to a problem. The solution we write is broken down to different tasks. Tasks can be specific to a step or a part of the solution. While coding for such tasks, we use constructs as tools to make them easier, readable, and performant. These tools make it possible to shape up your program at hand.</p>
<p class="calibre2">To code for a task that is repetitive requires either a construct that can repeat a given logic for you, or write the same snippet of code by hand again and again. I bet the first one is far better and that's why we have a few constructs, we call them looping constructs. Scala supports <em class="calibre18">for</em>, <kbd class="calibre11">while</kbd>, and <kbd class="calibre11">do while</kbd> loops. We'll see how these loops work in Scala. From there, we'll have a quick look at <kbd class="calibre11">for</kbd> expressions. We'll also go through the FP (functional programming) way of doing loops through recursion. Then, we'll start taking a look at Scala's conditional statements <kbd class="calibre11">if</kbd> and <kbd class="calibre11">end</kbd>, with learning how we can shape up program flow using pattern matching. Here's a quick card for what's in there for us in this chapter:</p>
<ul class="calibre7">
<li class="calibre8">Looping
<ul class="calibre28">
<li class="calibre8"><kbd class="calibre11">for</kbd>, <kbd class="calibre11">while</kbd>, and <kbd class="calibre11">do while</kbd> loops</li>
</ul>
</li>
<li class="calibre8">The <kbd class="calibre11">for</kbd> expressions: a quick go-through</li>
<li class="calibre8">Recursion</li>
<li class="calibre8">Conditional statements
<ul class="calibre28">
<li class="calibre8"><kbd class="calibre11">if</kbd>, and <kbd class="calibre11">if else</kbd></li>
</ul>
</li>
<li class="calibre8">Pattern matching</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Looping</h1>
                
            
            <article>
                
<p class="calibre2">Standing in front of a printer, you give it an instruction to print pages with indexes 2 to 16 from your book. The printer, which is programmed to do so, uses an algorithm to print pages for you; it checks for the document and the number of pages you asked to print. It sets the starting point as 2 and the last point as 16, and it starts printing till the last point is reached. Printing pages we can call repetitive, thus printing each page from your document can be well programmed using a looping construct. As in any other language, Scala supports <kbd class="calibre11">for</kbd><em class="calibre18">,</em> <kbd class="calibre11">while</kbd>, and <kbd class="calibre11">do while</kbd> loops.</p>
<p class="calibre2">Take a look at the following program:</p>
<pre class="calibre19">object PagePrinter extends App {<br class="title-page-name"/><br class="title-page-name"/>   /*<br class="title-page-name"/>    * Prints pages page 1 to lastIndex for doc<br class="title-page-name"/>    */<br class="title-page-name"/>   def printPages(doc: Document, lastIndex: Int) = ??? //Yet to be defined<br class="title-page-name"/><br class="title-page-name"/>   /*<br class="title-page-name"/>    * Prints pages page startIndex to lastIndex for doc<br class="title-page-name"/>    */<br class="title-page-name"/>   def printPages(doc: Document, startIndex: Int, lastIndex: Int) = ???<br class="title-page-name"/><br class="title-page-name"/>   /*<br class="title-page-name"/>    * Prints pages with given Indexes for doc<br class="title-page-name"/>    */<br class="title-page-name"/>   def printPages(doc: Document, indexes: Int*) = ??? <br class="title-page-name"/> <br class="title-page-name"/>   /*<br class="title-page-name"/>    * Prints pages <br class="title-page-name"/>    */ <br class="title-page-name"/>  private def print(index: Int) = println(s"Printing Page $index.")<br class="title-page-name"/><br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/>  <br class="title-page-name"/>  /*<br class="title-page-name"/>   * Declares a Document type with two arguments numOfPages, typeOfDoc<br class="title-page-name"/>   */<br class="title-page-name"/> case class Document(numOfPages: Int, typeOfDoc: String) </pre>
<p class="calibre2">We have created an object named <kbd class="calibre11">PagePrinter</kbd>. We use the syntax <kbd class="calibre11">/* ... */</kbd> to declare multi-line comments and <kbd class="calibre11">//</kbd> for single line comments in Scala. We declared three methods, which are supposed to do what the comment says. These methods are yet to be defined and we have communicated that to the Scala compiler, how? Using the syntax "???", that is, three question mark symbols, we tell the Scala compiler we're yet to define the method.</p>
<p class="calibre2">Let's come back to our methods. The first one takes a document, the number of pages to print as arguments, and prints pages up to the passed index. The second one takes the start and end indexes of pages to print and does so. The third method can take random indexes to print and prints pages from those indexes. In the third method, we've used an asterisk <kbd class="calibre11">*</kbd> to make our Int argument a vararg, that is, a variable argument. Now, the task is to define these methods. We can also see that to define what a document is, we have used a case class—we'll learn about case classes when we go deeper into Scala's object-oriented part in the next few chapters. For now, it'll be helpful to know that a case class let's you create a class with all the boilerplate code already available for you; it means you can access the members, in our case, <kbd class="calibre11">numOfPages</kbd> and <kbd class="calibre11">typeOfDoc</kbd>. Well, there's a lot to know about case classes, but we'll go through it later. We'll use our looping constructs to define our <kbd class="calibre11">PagePrinter</kbd>.</p>
<p class="calibre2">Let's take a look at our looping constructs. We'll first go through the <kbd class="calibre11">for</kbd> loop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The for loop</h1>
                
            
            <article>
                
<p class="calibre2">In Scala, a <kbd class="calibre11">for</kbd> loop, also called <kbd class="calibre11">for</kbd> comprehension takes a sequence of elements, and performs an operation on each of them. One of the ways we can use them is:</p>
<pre class="calibre19">scala&gt; val stocks = List("APL", "GOOG", "JLR", "TESLA") <br class="title-page-name"/>stocks: List[String] = List(APL, GOOG, JLR, TESLA) <br class="title-page-name"/> <br class="title-page-name"/>scala&gt; stocks.foreach(x =&gt; println(x))<br class="title-page-name"/>APL <br class="title-page-name"/>GOOG <br class="title-page-name"/>JLR <br class="title-page-name"/>TESLA </pre>
<p class="calibre2">We defined a list named stocks with a few stock names. Then we used a simple <kbd class="calibre11">for</kbd> loop to print out each stock from that list. Take a look at the syntax: we have <kbd class="calibre11">stock &lt;- stocks</kbd> that represents a single value from the list at the left-hand side of the generator sign <kbd class="calibre11">&lt;-</kbd> and the list or sequence at the right-hand side. Then finally, we can provide any operation to be performed, in our case we printed the names. Now that we've seen how to write a simple <kbd class="calibre11">for</kbd> loop, let's define our set of <kbd class="calibre11">printPages</kbd> methods:</p>
<pre class="calibre19">object PagePrinter extends App{<br class="title-page-name"/><br class="title-page-name"/>   /*<br class="title-page-name"/>    * Prints pages page 1 to lastIndex for doc<br class="title-page-name"/>    */<br class="title-page-name"/>   def printPages(doc: Document, lastIndex: Int) = if(lastIndex &lt;= doc.numOfPages) for(i &lt;- 1 to lastIndex) print(i)<br class="title-page-name"/><br class="title-page-name"/>   /*<br class="title-page-name"/>    * Prints pages page startIndex to lastIndex for doc<br class="title-page-name"/>    */<br class="title-page-name"/>   def printPages(doc: Document, startIndex: Int, lastIndex: Int) = if(lastIndex &lt;= doc.numOfPages &amp;&amp; startIndex &gt; 0 &amp;&amp; startIndex &lt; lastIndex) for(i &lt;- startIndex to lastIndex) print(i)<br class="title-page-name"/><br class="title-page-name"/>   /*<br class="title-page-name"/>    * Prints pages with given Indexes for doc<br class="title-page-name"/>    */<br class="title-page-name"/> def printPages(doc: Document, indexes: Int*) = for(index &lt;- indexes if index &lt;= doc.numOfPages &amp;&amp; index &gt; -1) print(index)<br class="title-page-name"/><br class="title-page-name"/>    <br class="title-page-name"/>  /*<br class="title-page-name"/>   *  Prints pages<br class="title-page-name"/>   */<br class="title-page-name"/>   private def print(index: Int) = println(s"Printing Page $index.")<br class="title-page-name"/><br class="title-page-name"/>   println("---------Method V1-----------")<br class="title-page-name"/>   printPages(Document(15, "DOCX"), 5)<br class="title-page-name"/><br class="title-page-name"/>   println("---------Method V2-----------")<br class="title-page-name"/>   printPages(Document(15, "DOCX"), 2, 5)<br class="title-page-name"/><br class="title-page-name"/>   println("---------Method V3-----------")<br class="title-page-name"/>   printPages(Document(15, "DOCX"), 2, 5, 7, 15)<br class="title-page-name"/><br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/>  <br class="title-page-name"/>/*<br class="title-page-name"/>  * Declares a Document type with two arguments numOfPages, typeOfDoc<br class="title-page-name"/>  */<br class="title-page-name"/> case class Document(numOfPages: Int, typeOfDoc: String) </pre>
<p class="calibre2">The following is the output:</p>
<pre class="calibre19">---------Method V1----------- <br class="title-page-name"/>Printing Page 1. <br class="title-page-name"/>Printing Page 2. <br class="title-page-name"/>Printing Page 3. <br class="title-page-name"/>Printing Page 4. <br class="title-page-name"/>Printing Page 5. <br class="title-page-name"/>---------Method V2----------- <br class="title-page-name"/>Printing Page 2. <br class="title-page-name"/>Printing Page 3. <br class="title-page-name"/>Printing Page 4. <br class="title-page-name"/>Printing Page 5. <br class="title-page-name"/>---------Method V3----------- <br class="title-page-name"/>Printing Page 2. <br class="title-page-name"/>Printing Page 5. <br class="title-page-name"/>Printing Page 7. <br class="title-page-name"/>Printing Page 15. </pre>
<p class="calibre2">We have a utility <kbd class="calibre11">print</kbd> method, which does nothing but print a simple string with index numbers, you're free to imagine a real printer printing the pages though.</p>
<p class="calibre2">Our definition for <kbd class="calibre11">printPages</kbd> method version 1 merely consists of a condition check that the document consists of the pages to be printed. That's done via an <kbd class="calibre11">if</kbd> conditional statement. More on <kbd class="calibre11">if</kbd> statements later in this chapter. After the conditional statement, there's a loop on indexes which ranges from 1 to the <kbd class="calibre11">lastIndex</kbd> passed. The same way the other method version 2 is also defined that takes <kbd class="calibre11">startIndex</kbd> and <kbd class="calibre11">lastIndex</kbd> and prints pages for you. For the last method version 3 of <kbd class="calibre11">printPages</kbd><em class="calibre18">,</em> we're looping on the indexes passed and we have a condition guard that starts with an <kbd class="calibre11">if</kbd> statement<em class="calibre18">.</em> This checks whether the page index is less than the number of pages in the document passed as an argument, and prints it. Finally, we got the result expected from our methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The while Loop</h1>
                
            
            <article>
                
<p class="calibre2">Like in most other languages, the <kbd class="calibre11">while</kbd> loop is another looping construct used. The <kbd class="calibre11">while</kbd> loop can do any repetitive task until a condition is satisfied. It means that the condition provided has to be true for the code execution to stop. Generic syntax for the <kbd class="calibre11">while</kbd> loop is:</p>
<pre class="calibre19">while (condition check (if it's true))  <br class="title-page-name"/>        ... // Block of Code to be executed </pre>
<p class="calibre2">The condition to be checked is going to be a Boolean expression. It gets terminated when the condition is <kbd class="calibre11">false</kbd>. One of the ways we can use them is:</p>
<pre class="calibre19">scala&gt; val stocks = List("APL", "GOOG", "JLR", "TESLA") <br class="title-page-name"/>stocks: List[String] = List(APL, GOOG, JLR, TESLA) <br class="title-page-name"/> <br class="title-page-name"/>scala&gt; val iteraatorForStocks = stocks.iterator <br class="title-page-name"/>iteraatorForStocks: Iterator[String] = non-empty iterator <br class="title-page-name"/> <br class="title-page-name"/>scala&gt; while(iteraatorForStocks.hasNext) println(iteraatorForStocks.next()) <br class="title-page-name"/>APL <br class="title-page-name"/>GOOG <br class="title-page-name"/>JLR <br class="title-page-name"/>TESLA </pre>
<p class="calibre2">We've used our list of stocks with a few stock names. Then we called the <kbd class="calibre11">iterator</kbd> method on the list to get an iterator for our sequence. Here <kbd class="calibre11">iteraatorForStocks</kbd> of <kbd class="calibre11">Type Iterator[String]</kbd> is a non-empty iterator that we can use to iterate over the list. Iterators have <kbd class="calibre11">hasNext</kbd> methods to check if there's a component remaining in sequence. Calling <kbd class="calibre11">next</kbd> on the iterator gives the resulting element. We've printed by iterating over the elements of our stock list. Let's take a look at <kbd class="calibre11">do while</kbd> loops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The do while loop</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">do while</kbd> loop does not differ a lot from the <kbd class="calibre11">while</kbd> loop. Generic syntax for <kbd class="calibre11">do while</kbd> loop is:</p>
<pre class="calibre19">do<br class="title-page-name"/>        ... // Block of Code to be executed <br class="title-page-name"/>        while(condition check (if it's true)) </pre>
<p class="calibre2">The <kbd class="calibre11">do while</kbd> loop ensures that the code in block gets executed at least once and then checks for the condition defined in a <kbd class="calibre11">while</kbd> expression:</p>
<pre class="calibre19">scala&gt; do println("I'll stop by myself after 1 time!") while(false) </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">I'll stop by myself after 1 time! </pre>
<p class="calibre2">It's a simple example where our statement is getting printed just once before the condition passed to the <kbd class="calibre11">while</kbd> loop is <kbd class="calibre11">false</kbd><em class="calibre18">.</em> This is how we can use <kbd class="calibre11">do while</kbd> loops in Scala.</p>
<p class="calibre2">You may want to try out the <kbd class="calibre11">PagePrinter</kbd> example using the <kbd class="calibre11">while</kbd> and <kbd class="calibre11">do while</kbd> loops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The for expressions</h1>
                
            
            <article>
                
<p class="calibre2">We've seen the <kbd class="calibre11">for</kbd> loops, and how simple it is to use them in Scala. There's much more we can do with the <kbd class="calibre11">for</kbd> syntax. Here's an example:</p>
<pre class="calibre19">object ForExpressions extends App {<br class="title-page-name"/><br class="title-page-name"/>   val person1 = Person("Albert", 21, 'm')<br class="title-page-name"/>   val person2 = Person("Bob", 25, 'm')<br class="title-page-name"/>   val person3 = Person("Cyril", 19, 'f')<br class="title-page-name"/><br class="title-page-name"/>   val persons = List(person1, person2, person3)<br class="title-page-name"/><br class="title-page-name"/>   for {<br class="title-page-name"/>     person &lt;- persons<br class="title-page-name"/>     age = person.age<br class="title-page-name"/>     name = person.name<br class="title-page-name"/>     if age &gt; 20 &amp;&amp; name.startsWith("A")<br class="title-page-name"/>   } {<br class="title-page-name"/>     println(s"Hey ${name} You've won a free Gift Hamper.")<br class="title-page-name"/>   }<br class="title-page-name"/><br class="title-page-name"/> case class Person(name: String, age: Int, gender: Char)<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Hey Albert You've won a free Gift Hamper. </pre>
<p class="calibre2">In the preceding example, we used a generator, definitions, and filters in the <kbd class="calibre11">for</kbd> expression. We used a <kbd class="calibre11">for</kbd> expression on a list of persons. We proposed a gift hamper for a person whose name starts with <kbd class="calibre11">A</kbd> and who is older than 20 years of age.</p>
<p class="calibre2">The first expression in <kbd class="calibre11">for</kbd> is a generator expression which generates a new person from the persons list and assigns to person. Second is age and name definitions. Then finally we apply filters using the <kbd class="calibre11">if</kbd> statement to put conditions for our winner:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00016.jpeg"/></div>
<div class="cdpaligncenter1">The for expressions</div>
<p class="calibre2">What if we want a couple more prizes for our people. In that case we may want to get a sub list of winners. That's possible by introducing <kbd class="calibre11">yield</kbd><em class="calibre18">.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The for yield expressions</h1>
                
            
            <article>
                
<p class="calibre2">Here's an example of a <kbd class="calibre11">for yield</kbd> expression where we're listing the names of winners. The criteria for winning a prize is the age, which should be more than 20:</p>
<pre class="calibre19">object ForYieldExpressions extends App {<br class="title-page-name"/><br class="title-page-name"/>   val person1 = Person("Albert", 21, 'm')<br class="title-page-name"/>   val person2 = Person("Bob", 25, 'm')<br class="title-page-name"/>   val person3 = Person("Cyril", 19, 'f')<br class="title-page-name"/><br class="title-page-name"/>   val persons = List(person1, person2, person3)<br class="title-page-name"/><br class="title-page-name"/>   val winners = for {<br class="title-page-name"/>     person &lt;- persons<br class="title-page-name"/>     age = person.age<br class="title-page-name"/>     name = person.name<br class="title-page-name"/>     if age &gt; 20<br class="title-page-name"/>   } yield name<br class="title-page-name"/><br class="title-page-name"/>   winners.foreach(println)<br class="title-page-name"/>   <br class="title-page-name"/>  case class Person(name: String, age: Int, gender: Char)<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">The following is the result<strong class="calibre1">:</strong></p>
<pre class="calibre19">Albert<br class="title-page-name"/>Bob</pre>
<p class="calibre2">Here, <kbd class="calibre11">yield</kbd> does the trick and results in a list of people with satisfying criteria. That's how <kbd class="calibre11">for yield</kbd> expressions work in Scala.</p>
<p class="calibre2">But these iterations are not what Scala or any other functional programming language recommends. Let's check out why this is and the alternative to iterative loops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Recursion</h1>
                
            
            <article>
                
<p class="calibre2">Recursion is a function's call to itself. In simple words, a recursive function is a function which calls itself. Functional programming recommends use of recursion over the use of iterative looping constructs. For the same obvious reasons, Scala also recommends use of <strong class="calibre1">recursion</strong>. Let's first take a look at a recursive function:</p>
<pre class="calibre19">object RecursionEx extends App {<br class="title-page-name"/><br class="title-page-name"/>   /*<br class="title-page-name"/>   * 2 to the power n<br class="title-page-name"/>   * only works for positive integers!<br class="title-page-name"/>   */<br class="title-page-name"/> def power2toN(n: Int): Int = if(n == 0) 1 else 2 * power2toN(n - 1)<br class="title-page-name"/><br class="title-page-name"/>   println(power2toN(2))<br class="title-page-name"/>   println(power2toN(4))<br class="title-page-name"/>   println(power2toN(6))<br class="title-page-name"/> } </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">4 <br class="title-page-name"/>16 <br class="title-page-name"/>64 </pre>
<p class="calibre2">We've defined a function <kbd class="calibre11">power2toN</kbd> which expects an integer <kbd class="calibre11">n</kbd>, checks for <kbd class="calibre11">n</kbd> value and if it's not 0, the function calls itself, decrementing <kbd class="calibre11">n</kbd> integer's value till the number <kbd class="calibre11">n</kbd> becomes <kbd class="calibre11">0</kbd>. Then comes multiplying the value with 2 with each recursive call to get the desired result.</p>
<p class="calibre2">Consider the following:</p>
<pre class="calibre19">def power2toN(n: Int) = if(n == 0) 1 else (2 * power2toN(n - 1)) </pre>
<p class="calibre2">The Scala compiler gives an error stating <kbd class="calibre11">Recursive method power2N needs result type</kbd><em class="calibre18">.</em> This is a required condition by the Scala compiler. We have to explicitly define the response type of a recursive function—that's the reason we have to give the return type with the method definition.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why recursion over iteration?</h1>
                
            
            <article>
                
<p class="calibre2">Given the statement <em class="calibre18">functional programming recommends recursion over iteration</em>, let's discuss why this is the case. If you take a closer look at our definition:</p>
<pre class="calibre19">def power2toN(n: Int): Int = if(n == 0) 1 else 2 * power2toN(n - 1) </pre>
<p class="calibre2">The function definition consists of some conditional statement and finally a call to itself. There's no mutation of states for any variables. Functional programming recommends pure functions, which means functions with no side effects. Side effects can be mutating a state of a variable, performing I/O operations. This is not possible in iteration. Iteration, consists of mutation of its counter/index variable mutating over repetitions. Recursion, on the other hand, can be done without performing any such state changes. This makes it powerful and usable in functional languages. Operations via recursive functions can be performed with all the power of multiple cores executing them without the worry of the same variable state change by different threads. Hence recursion is recommended. But there's a glitch in recursion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Limitations of recursion</h1>
                
            
            <article>
                
<p class="calibre2">With smaller repetitions or fewer levels of calling functions, recursion is considered to be ok, but with more levels it ends up  filling the stack. What's that?</p>
<p class="calibre2">A function call in a program adds a new element to call a stack. A call stack keeps track of information about the function call. For each recursive call, a new call gets added to a stack, hence it works fine for a smaller number of recursive calls. But as the level goes deeper for recursive calls, the call stack reaches its limits and the program gets terminated. That's something unintended and breaks our program. So, shall we avoid <em class="calibre18">recursion</em> or use it?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The ideal way to write recursive functions</h1>
                
            
            <article>
                
<p class="calibre2">The complication with <em class="calibre18">recursion</em> is filling up the space of the call stack. If we find a way which can free up the current stack for each recursive call and use it for all subsequent recursive calls, we can somewhat optimize the use of a call stack and that can result in better performance of recursive functions. Let's try to understand it this way: we have the definition of our recursive function <kbd class="calibre11">power2N</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">if(n == 0) 1 else 2 * power2toN(n - 1) </pre>
<p class="calibre2">As shown in the definition, after a call to itself, <kbd class="calibre11">power2toN</kbd> needs to keep track of its call stack, because the result of it needs to get multiplied by 2 to finalize the step and get the desired result. To avoid this and make an efficient use of the call stack, we can define a helper function as the very last step to be executed in the recursive function. In other words, if we make our function call a tail call, we will be able to optimize the use of call stack, hence resulting in better recursion. This phenomenon is called tail call optimization:</p>
<pre class="calibre19">package chapter3<br class="title-page-name"/><br class="title-page-name"/>import scala.annotation.tailrec<br class="title-page-name"/><br class="title-page-name"/> object TailRecursionEx extends App {<br class="title-page-name"/><br class="title-page-name"/>   /*<br class="title-page-name"/>    * 2 to the power n<br class="title-page-name"/>    * @tailrec optimization<br class="title-page-name"/>    */<br class="title-page-name"/>   def power2toNTail(n: Int): Int = {<br class="title-page-name"/>     @tailrec<br class="title-page-name"/>     def helper(n: Int, currentVal: Int): Int = {<br class="title-page-name"/>       if(n == 0) currentVal else helper(n - 1, currentVal * 2)<br class="title-page-name"/>     }<br class="title-page-name"/>     helper(n, 1)<br class="title-page-name"/>   }<br class="title-page-name"/><br class="title-page-name"/>   println(power2toNTail(2))<br class="title-page-name"/>   println(power2toNTail(4))<br class="title-page-name"/>   println(power2toNTail(6))<br class="title-page-name"/> } <br class="title-page-name"/> </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">4 <br class="title-page-name"/>16 <br class="title-page-name"/>64 </pre>
<p class="calibre2">Above is the <em class="calibre18">tail optimized</em> version of our method <kbd class="calibre11">power2toN</kbd><em class="calibre18">.</em> The annotation used here <kbd class="calibre11">@tailrec</kbd> is to explicitly tell the Scala compiler to recognize a tail recursive function and optimize accordingly. What's different here is the use of a nested, <kbd class="calibre11">helper</kbd> method, that's recursive and contains a tail call. After a call to <kbd class="calibre11">helper(n-1, currentVal * 2)</kbd>, there's no further need for that call stack. Hence, the Scala compiler is free to optimize accordingly. More on tail recursion and tail call optimization in <a href="part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 9</a>, <em class="calibre18">Using Powerful Functional Constructs.</em></p>
<p class="calibre2">This is the preferred way of writing recursive functions in Scala. It takes more effort in understanding the requirement and writing one than simply writing an iterative version of your method. But it's worth it in the functional world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Conditional statements</h1>
                
            
            <article>
                
<p class="calibre2">We've already used conditionals many times. It's hard to have your program make sense without a conditional or logical statement. These statements help keep the flow of the program intact. Moreover, logic implementation is also easier with the use of these. Scala supports <kbd class="calibre11">if</kbd> and <kbd class="calibre11">else</kbd> conditional statements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The if else conditional expression</h1>
                
            
            <article>
                
<p class="calibre2">In Scala, you can use <kbd class="calibre11">if else</kbd> to control program flow. The generic syntax for an <kbd class="calibre11">if else</kbd> statement goes as follows:</p>
<pre class="calibre19">if (condition (is true)) <br class="title-page-name"/>          ... //Block of code to be executed <br class="title-page-name"/>else <br class="title-page-name"/>          ... //Block of code to be executed <br class="title-page-name"/> <br class="title-page-name"/>scala&gt; val age = 17 <br class="title-page-name"/>age: Int = 17 <br class="title-page-name"/> <br class="title-page-name"/>scala&gt; if(age &gt; 18) println("You're now responsible adult.") else println("You should grow up.") <br class="title-page-name"/>You should grow up. </pre>
<p class="calibre2">Above, we defined a variable <kbd class="calibre11">age</kbd> with value 17. In the next line, we checked a condition <kbd class="calibre11">age &gt; 18</kbd>. If age is greater than 18 then we printed some string. You're now a responsible adult, or some other string. Instead of just printing out strings, we can perform any operation as part of the control flow. In Scala, we can also declare and assign a value to our variables using <kbd class="calibre11">if else</kbd> expressions:</p>
<pre class="calibre19">scala&gt; val marks = 89 <br class="title-page-name"/>marks: Int = 89 <br class="title-page-name"/> <br class="title-page-name"/>scala&gt; val performance = if(marks &gt;= 90) "Excellent" else if(marks &gt; 60 &amp;&amp; marks &lt; 90) "Average" else "Poor" <br class="title-page-name"/>performance: String = Average </pre>
<p class="calibre2">Here we assigned a value to a variable <kbd class="calibre11">performance</kbd> on the fly using conditional expressions. We checked if marks are greater than 90, or in between 60 to 90, or less than 90 and based on that assigned the value for performance. This happens because in Scala, conditionals are expressions—the result of an <kbd class="calibre11">if</kbd> statement, is an expression.</p>
<p class="calibre2">There's another way to control the flow of our program in Scala that uses matching of an expression or construct to a value and evaluation of a corresponding block of code on a successful match. We call it pattern matching in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern matching</h1>
                
            
            <article>
                
<p class="calibre2">Pattern matching is more like Java's <kbd class="calibre11">switch</kbd> statements with a few differences. With one expression/value to match against several case statements, whenever a match happens, the corresponding block of code is executed. This gives more than one option for our program flow to follow. Java's switch is a fall-through statement, which means it executes all the statements after the very first match until it confronts a <kbd class="calibre11">break</kbd> statement. In Scala, there's no <kbd class="calibre11">break</kbd> statement. Also, there's no default case in Scala's pattern matching. Instead, a wildcard "_" is used that matches against any other case that has not been covered in previous <kbd class="calibre11">case</kbd> statements.</p>
<p class="calibre2">Let's have a look at the syntactical difference between Java's switch and Scala's pattern matching statements:</p>
<div class="cdpaligncenter"><img src="../images/00017.jpeg" class="calibre29"/></div>
<p class="calibre2">The difference is obvious, as we already discussed. In Scala, we have to provide a case matching to our expression, otherwise the compiler will throw an error, <kbd class="calibre11">MatchError</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">object PatternMatching extends App {<br class="title-page-name"/><br class="title-page-name"/>   def matchAgainst(i: Int) = i match {<br class="title-page-name"/>     case 1 =&gt; println("One")<br class="title-page-name"/>     case 2 =&gt; println("Two")<br class="title-page-name"/>     case 3 =&gt; println("Three")<br class="title-page-name"/>     case 4 =&gt; println("Four")<br class="title-page-name"/>   }<br class="title-page-name"/><br class="title-page-name"/>   matchAgainst(5)<br class="title-page-name"/> } </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Exception in thread "main" scala.MatchError: 5 (of class java.lang.Integer) <br class="title-page-name"/>            at PatternMatching$.matchAgainst(PatternMatching.scala:6) <br class="title-page-name"/>            at PatternMatching$.delayedEndpoint$PatternMatching$1(PatternMatching.scala:13) <br class="title-page-name"/>            at PatternMatching$delayedInit$body.apply(PatternMatching.scala:4) <br class="title-page-name"/>            at scala.Function0.apply$mcV$sp(Function0.scala:34) <br class="title-page-name"/>            at scala.Function0.apply$mcV$sp$(Function0.scala:34) <br class="title-page-name"/>            at scala.runtime.AbstractFunction0.apply$mcV$sp(AbstractFunction0.scala:12) </pre>
<p class="calibre2">In the preceding example, we didn't cover all cases possible so the compiler gave this error back. To cover all the cases, we can add the wildcard "_" as the last <kbd class="calibre11">case</kbd> clause. This will work fine. Let's try that:</p>
<pre class="calibre19">object PatternMatching extends App {<br class="title-page-name"/><br class="title-page-name"/>   def matchAgainst(i: Int) = i match {<br class="title-page-name"/>     case 1 =&gt; println("One")<br class="title-page-name"/>     case 2 =&gt; println("Two")<br class="title-page-name"/>     case 3 =&gt; println("Three")<br class="title-page-name"/>     case 4 =&gt; println("Four")<br class="title-page-name"/>     case _ =&gt; println("Not in Range 1 to 4")<br class="title-page-name"/>   }<br class="title-page-name"/><br class="title-page-name"/>   matchAgainst(1)<br class="title-page-name"/>   matchAgainst(5)<br class="title-page-name"/> } </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">One <br class="title-page-name"/>Not in Range 1 to 4 </pre>
<p class="calibre2">After covering every <kbd class="calibre11">case</kbd> clause, pattern matching works a charm. We got a response; for value 1 we got a corresponding <kbd class="calibre11">One</kbd>, and for 5 we got <kbd class="calibre11">Not in Range 1 to 4</kbd>. There's more to pattern matching in Scala. We'll go through pattern matching in detail and learn several constructs to match against in <a href="part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 9</a>, <em class="calibre18">Using Powerful Functional Constructs</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">We can conclude our chapter; let's go through what we have learned. We started learning about looping constructs in Scala. We discussed native looping constructs such as <kbd class="calibre11">for</kbd><em class="calibre18">,</em> <kbd class="calibre11">while</kbd><em class="calibre18">,</em> and <kbd class="calibre11">do while</kbd> loops. After that, we saw <kbd class="calibre11">for</kbd> expressions<em class="calibre18">,</em> along with <kbd class="calibre11">for yield</kbd> expressions. Then we understood alternatives to iteration, that is, <em class="calibre18">recursion.</em> We wrote a few recursive functions as well. Finally, we looked at <kbd class="calibre11">if else</kbd> conditional statements and pattern matching. We know there's much more to come, but with these concepts we're on our way to understanding Scala language constructs better. We'll continue doing that in our next chapter. There we'll take a look at the core of functional programming: functions. We will see how functions are defined and used. It'll show the variety of functional constructs we have available in Scala. We'll try to give meaning to our programs using functions<em class="calibre18">.</em></p>


            </article>

            
        </section>
    </body></html>