- en: Chapter 7. Progressive JavaScript Frameworks and Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"If you''re a runner and you run in a race, you might lose. If you don''t
    run, you''re guaranteed to lose."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Reverend Jesse Jackson* |'
  prefs: []
  type: TYPE_TB
- en: In the contemporary way of building a website, there is no escape from the language
    of JavaScript because it is a de facto standard of modern web browsers. JavaScript
    is either a pleasure or major inconvenience for developers. If you write or intend
    to build digital web applications for a customer, there is almost no escape from
    the knowledge of HTML5, CSS, and JavaScript. Fortunately, you do not need to be
    an expert in JavaScript in order to be productive because there are many frameworks
    that help you and you can leverage these ideas. Essentially, where JavaScript
    is concerned, you need to know and catch up with the modern digital best practices.
  prefs: []
  type: TYPE_NORMAL
- en: While JavaScript is a very relevant topic for the digital websites, this chapter
    cannot teach you everything that you need to know. Instead, I will endeavor to
    point you in the correct direction and provide you with an oversight, and you
    should definitely extend your knowledge with further resources.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the fundamental JavaScript programming and an idea of the
    language. We will then dive straight into programming with the JavaScript objects.
    Afterwards, we will look at a few of the major frameworks in the world of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a respected programming language by itself. It has a standard
    called ECMAScript ([http://www.ecmascript.org/](http://www.ecmascript.org/)) and
    is accepted as a ratified standard by the W3C. The language is a part of the trinity
    of the fundamental standard web technologies: HTML5, CSS, and JavaScript. That
    said, what is JavaScript? It is a prototype dynamically typed scripting language
    with object types and enclosed scoped function blocks. In JavaScript, every type
    is strictly an object. The JavaScript support functions as a first-class citizen
    and rules on a and supports the declaration of functions that are assigned to
    an associated lexically scoped variable, property, or entity. JavaScript has a
    support for strings, integers, floating point numbers, and prototypes. JavaScript
    is essentially a property and prototypical language. It has a lexical support
    of object-based programming through scopes and closures. The widespread use of
    the language does not explicitly have reserved keywords and it structures out
    of the support object-oriented inheritance. Through clever programming and prototypes,
    developers can replicate the object class inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is the base level standard JavaScript that I should learn?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter looks at JavaScript 1.5, which is ECMA Script Edition 3\. This
    version of the language works in all the major web browsers: Firefox, Chrome,
    Safari, and Internet Explorer. The upcoming JavaScript ECMA 6 will have support
    for object-oriented programming ([http://es6-features.org/](http://es6-features.org/)).'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a popular language on the client side of a normal Java web application.
    You should be aware that JavaScript can also operate on the server side through
    an implementation such as Node.js or Nashorn. These topics are, however, out of
    the scope for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s wade into JavaScript on the client side. What is JavaScript programming
    with an object that you, as a digital developer, can write? Here is one answer—an
    HTML5 web page with an embedded script that creates a contact detail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple program creates a contact detail with properties. The JavaScript
    properties may be integer, numerical numbers: number, or Boolean or String types.
    A JavaScript object may also define the methods as in the case of `getFullName()`.
    For a stock blue-collar Classic Java developer, this syntax of defining a property
    from a function looks peculiar; however, the functions are first-class citizens
    of many languages. The JavaScript functions that define an object are called methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the modern JavaScript writing practices, you will learn to recognize the
    functions written similarly in this vein, which is the reverse of the Java notation.
    Here is a third order polynomial function from mathematics in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This variable defines a JavaScript function called `polynomial()`, which accepts
    three number type arguments. It also returns a Number type. JavaScript is a dynamically
    typed language and thus, there is no static typing.
  prefs: []
  type: TYPE_NORMAL
- en: The console log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console log is a standard object that is a part of the modern web browsers:
    Firefox, Chrome, Opera, Safari, and Internet Explorer. It is usually available
    from the menu that is reserved for the debugging. Formerly, the console object
    was not completely supported for browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, we will not be writing the following conditional code in 2016:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move to the object constructors. Allow me to provide a final note of
    advice about writing a console log: use it only in the development code. Developers
    have been forgotten to remove the console log output from production code, which
    eventually led to crash in a certain web browser, ruining the digital customer''s
    journey. Take advantage of a JavaScript framework such as jQuery, RequireJS, or
    Dojo, which abstracts away the console log in a library function.'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't eventually done so, I strongly recommend that you download the
    Chrome Developer and Web Developer tools for either the Google Chrome or Firefox
    web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Writing JavaScript object constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JavaScript language consists of a limited variety of primitive types in
    comparison. Loosely, these primitives are String, Number, Boolean, Array, and
    Object. These can be created using native JavaScript object constructors: `String()`,
    `Number()`, `Boolean()`, `Array()`, and `Object()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an illustration of how to use these native constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, it is rare to assign the String, Boolean, and Number types from the
    native constructors. However, note the use of the Array native constructor. In
    JavaScript, arrays are treated as objects. They are enumerated from the index
    zero like most computer languages. To find the size of the array, invoke the implicit
    length property (`name.length`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish the JavaScript essentials, we can finesse the earlier example
    and take advantage of the ability of the functions to introduce their own scope,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things going on with this second example. First, we will assign
    a function type to the `ContactDetail` variable. This function is actually a constructor
    for a new object type named by the variable name. In this constructor, there is
    a special `this` reference variable that is associated with the function scope
    at this level. When the reference is returned, it becomes the object instance.
    In the function, we are allowed to define the other functions that are associated
    with the object, such as `getFullName()`. This is how object-based programming
    works in modern JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this new object type constructor to declare a contact detail in
    the variable called `anne`. For Java regular programmers, this syntax might look
    very weird at first, but this JavaScript is completely different to Java and is
    seriously accepted as a programming language in its own right. A scope has practical
    uses in defining the object modules, which I showed in the first chapter of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript property notations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two fundamental ways to access the JavaScript properties in a type.
    The first way is pretty familiar to all Java programmers. It is the dot notation.
    The second way is called the bracket notation, which looks like a map or dictionary
    association in the languages other than Java. The bracket notation is equivalent
    to the dot notation and has its uses.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the following code, which demonstrates another way to create a JavaScript
    object. Remember that JavaScript is a dynamically typed language.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Did you spot the introduction of a new property to the object called subject
    and also a method function? Of course, I am promoting the title of my first technical
    book here, but that is beside the point. JavaScript allows programmers to be quite
    flexible with object internals and properties. The declaration of the object product
    should ring some bells because it is remarkable how similar this declaration is
    to the de facto **JavaScript Object Notation** (**JSON**) standard. The open curly
    bracket notation is a way to define an object with the property key and values.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with a null and undefined reference pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Professor Charles Antony Richard Hoare (Tony Hoare) developed the classic computer
    science algorithm called **QuickSort**, but he also regretted when he said that
    it was also the invention of a billion dollar mistake: the dreaded null reference
    pointer. Personally, I would have thought that someone else would have stumbled
    on such an obvious workaround and quick fit for a general problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript deals with a null reference as a sentinel and also features undefined.
    The following JavaScript extract attempts to print the null reference in a `test`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The null value tells you that the object type thing is defined but is not yet
    available. The undefined value informs the developer that something is missing.
    Remember that JavaScript is a dynamic language and therefore, it is entirely possible
    to navigate across the object graph and not find the object type that your team
    thought was placed there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, if you need to test for a null value, you must use the triple
    equal operator (`===`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Writing about equivalence, how do we know when two objects are equivalent in
    JavaScript?
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript truth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, the conditional expression is false, if it matches one of the
    Set of Empty Values: `false`, `0`, `-0`, `null`, empty string (`''''`), `NaN`,
    or `undefined`. A value evaluates to the JavaScript truth in a conditional expression,
    if and only if the value does not match any of the elements in the Empty Values
    set. Every other value that does match any of the elements is an empty value set
    that evaluates to JavaScript true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following JavaScript all evaluates to false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `Boolean` constructor with the new keyword to instantiate
    a type directly. These statements evaluate to true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Runtime type information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to find out the runtime information of the JavaScript values, you
    can apply the `typeof` operator. This permits the programmer to write a specialist
    code in order to check the arguments to a function. Here is an example of the
    `typeof` interrogation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript has some other quirks, if you use the native constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is surprising! Here is the evidence where you can see why digital web developers
    are driven mad because of the inconsistency in the language, standards, and implementations
    of these standards.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern JavaScript, you will see a lot of quasi-functional programming in
    comparison to Classic Java (Java before version 8 and Lambda expressions). The
    functions are the first-class citizens. You can supply functions as parameters
    to the functions. You can also return a function type from a function. How does
    passing a function as a parameter to a method help? In JavaScript, you can write
    anonymous functions without a name. You can take advantage of passing around the
    blocks of code to the library functions. This style is the basis of functional
    programming. Instead of coding imperatively, we can write concise code and inline,
    which is almost declarative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an anonymous function example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `outside()` function accepts an anonymous `yourIn()` function, as a single
    argument. Now inside the `outside()` function, it immediately invokes the argument
    `yourIn`, which is the supplied anonymously defined function. This is a powerful
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript has one other trick that lends itself to the declaration of modules,
    especially when it is combined with the functional object scopes. It is possible
    to define a function and invoke it inline and directly. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined a variable called `initializeGui` and assigned
    it an anonymous function. The key to the definition is the final round brackets
    at the end of the method statement. JavaScript immediately invokes the function
    at the precise location where the definition is parsed. Here, we are pretending
    to initialize a client side GUI by writing to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass the parameters to an inlined function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This preceding code demonstrates that the parameters are passed from the outside
    global scope to the invoked function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we can get rid of the variable `initializeGui2` and create a self-invocation
    anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This kind of code is fairly typical and seen in the popular JavaScript frameworks
    and applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the function definition, we will take advantage of the JavaScript scope.
    See [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Digital Java EE 7"), *Digital
    Java EE 7* for an earlier explanation on the module namespace technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'I think I will stop here. There is a tremendous variety and a deeper knowledge
    track to the modern JavaScript programming than I can write about here. I recommend
    that you invest in other introductory programming books such as Douglas Crockford''s
    excellent *JavaScript: The Good Parts* and also Packt Publishing''s *Object-Oriented
    JavaScript* by authors *Stoyan Stefanov* and *Kumar Chetan Sharma*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Steve Kwan has written an excellent example of the Module Pattern in JavaScript;
    you might want to investigate his best practices at [https://github.com/stevekwan/best-practices/blob/master/javascript/best-practices.md](https://github.com/stevekwan/best-practices/blob/master/javascript/best-practices.md).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a very important programming framework for JavaScript, jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the jQuery framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jQuery ([http://learn.jquery.com/](http://learn.jquery.com/)) is a cross-platform
    JavaScript framework for client-side web application development. It is a survivor
    from the original AJAX craze from 2004 and 2005, where it was and still is competing
    with Prototype ([http://prototypejs.org/](http://prototypejs.org/)) and Scriptaculous
    ([http://script.aculo.us/](http://script.aculo.us/)). jQuery has been called the
    equivalent of what the Java Collections framework did for the Java programming
    language. According to Wikipedia, jQuery is 70 percent of the 10,000 most visited
    websites in the world. In other words, it is the first JavaScript framework that
    really caught the attention of the developers and caused them to rethink the furthest
    capabilities of the underlying language. jQuery is free and provided under the
    MIT open source license.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery was built to make the manipulation of the **Document Object Model** (**DOM**)
    easier and apply CSS to the HTML elements. In jQuery, there is a secret sauce
    called Sizzle, which is a selector engine that traverses over the DOM. The engine
    combines the flexibility of selection, a respect for functional programming, and
    callback to allow an engineer to comfortably write JavaScript that leverages the
    underlying HTML and CSS elements in a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Including jQuery in a JSF application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can include the jQuery JavaScript library in your page view. In JSF, the
    folder would be under the `src/main/webapp/resources/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will use the expression language, `#{request.contextPath}`, in order to provide
    location independence. Good digital developers will use the minified JavaScript
    for performance and to improve their business SEO chances!
  prefs: []
  type: TYPE_NORMAL
- en: jQuery ready function callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The jQuery framework repurposes the `$` symbol in the global head scope exclusively
    for our use. (The dollar symbol is an alias for the jQuery object instance and
    it is obviously short.) Through clever programming, which is out of the scope
    of this book, jQuery accepts a parameter that represents an HTML DOM object. A
    jQuery entry point is the `ready()` method, which accepts a function object type
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'This argument can be an anonymous or a named function as we will demonstrate
    here to initialize a fictional website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When jQuery invokes the anonymous function, the framework can make certain
    guarantees that the browser has been initialized, the images have all been downloaded,
    the event stack is set to go, and the other proprietary features of certain web
    clients have been finished. In the preceding example, we will initialize the other
    JavaScript libraries in the module pattern and log to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$( document )` expression can be generalized to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression-selector stanza can be a CSS selector expression or an HTML
    DOM element. Here are some example selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The element selectors that start with a hash character (`#`) are equivalent
    to the DOM HTML API call, `getElementById()`, which means that they might return
    the element or not. The `#offerSubmitBtn` selector retrieves an element that is
    specified with the ID attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: jQuery offers very powerful class selectors, which retrieve a collection of
    the HTML elements. The `$('div')` selector retrieves all of the HTML `div` elements
    in the document and page views. Likewise, the `$('div')` class selector retrieves
    all the HTML anchor elements. As some might say, knowledge is power! We can combine
    the CSS class selectors to turn down and fine tune the elements that we want to
    manipulate. The `$( ".footerArea div" )` selector restricts the HTML `div` elements
    in the footer area.
  prefs: []
  type: TYPE_NORMAL
- en: Acting on the jQuery selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jQuery allows a digital developer to access the HTML DOM elements on the web
    page. So how do you act on these powerful selectors? The API features many callback
    methods that accept a function type parameter. Let's take a look at such a method
    called `click()`, which fires an event when the particular HTML element is pressed
    and depressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the red button that we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks on the red button, jQuery handles the DOM event and invokes
    the anonymous function that is associated to the jQuery matched selector. The
    user sees the alert dialog. It does not stop there. Here is some code to make
    the red button fade out of the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of the jQuery animation capability. The `animate()` method
    accepts two arguments: the key and value for the animation properties and a duration
    time. Here we will specify the opacity of the button but we can set other properties
    such as the width or height of the element, and even three-dimensional transformations
    of your target web clients will be served against the CSS3 confirmed web browsers
    only. The duration time is measured in milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If this was a code that is designed to be reused and I wanted a clean modular
    code for a team of interface developers, here is how I would tidy up the code
    and avoid embarrassment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using the popular module pattern, I pushed the initialized code for jQuery into
    a `RedModule` module with the `DigitalJavaEE7` namespace. In the `init()` function
    of this module, I optimized the CSS selector in one call to a `redButton` variable.
    It turns out that jQuery works hard at interpreting the CSS selector to a group
    of potential HTML DOM elements. So, we will avoid asking the framework to do this
    search of the DOM twice. Code is essentially the same, but more concise and still
    comprehensible.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the DOM elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, you learned how to select the DOM elements with jQuery.
    Group elements can be retrieved with the jQuery selectors. Using the manipulation
    part of the API, we will add and remove the class styles to the elements, insert
    the elements before and after a component, and replace the content of the elements.
    There are lots of calls to learn; we will review a small set here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demonstrate how we can manipulate the DOM elements, let''s define
    two HTML button elements. We will apply a style of the red color and the other
    will be blue. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We will set up the anonymous functions to add a Bootstrap class, text-danger,
    to `messageArea`, which you can rightly assume is a reserved `div` element for
    a textual output. The `addClass()` method appends a style class to the matching
    elements. We will add the style to the text area with the callback for the `redButton`
    element. The second anonymous function for `blueButton` deletes the class from
    the element. Both the functions will change the message in the display area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `html()` method is dual purpose. It is overloaded in the jQuery framework.
    When `html()` is called with a single argument, it replaces the contents of the
    element. We will use the `html()` method to change the text in the message area.
    If the method is called with no arguments, it returns the element''s content.
    There are several API methods in jQuery that have this duality such as `attr()`
    and `val()`. They are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `attr()` method either retrieves or manipulates the attributes for the DOM
    elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `val()` method retrieves the current value of the first element in the set
    of matched elements or it sets the value of every matched element. The `val()`
    method is particularly useful to access the name and values in a set of HTML select
    option elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most sophisticated digital applications on a website incorporate smart animations
    and hints (obviously approved by the Head of UX) to guide the user on their digital
    journey. Usually, it is just enough to provide subtle hints on how the user can
    achieve the best experience with a website and this can make a huge difference
    in the overall satisfaction. jQuery has a base level animation feature such as
    sliding up and down the `div` layers and popups, shrinking and expanding the layers,
    and opacity tricks that can lend a hand.
  prefs: []
  type: TYPE_NORMAL
- en: To see the animation, let's examine how to use jQuery to animate a scroll-to-the-top
    arrow when the user scrolls down a page for a certain distance. This is a common
    user interface design pattern. We will not put in a module pattern for obvious
    space reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have a simple HTML content on our JSF page view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we will need to write a function handler that listens to scroll events
    when the user is scrolling up or down the page view. In the DOM, there is a standard
    method, `scroll()`, on the global Window object that accepts a function object
    as a callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an entry point, we will write a handler function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Don't be afraid of the length of this JavaScript function because all will be
    revealed now. It turns out that attaching a callback as a scroll listener means
    that the web browser potentially invokes the callback for perhaps 10 or perhaps
    scores of times per second depending on the user's device. Therefore, we have
    introduced a dampening factor, `scrollingCount`, as a countdown variable, which
    prevents the animation being hyper triggered. The `epsilon` variable also controls
    the sensitivity of the animation when it is activated. We can use set minimum
    and maximum opacity values to bound the animation activations.
  prefs: []
  type: TYPE_NORMAL
- en: As the jQuery selector API, `$('#scrollBackTopArrow')`, may retrieve zero or
    more DOM elements, we will invoke the `each()` method to effectively iterate through
    the elements. We do so with the anonymous function, which takes a single argument
    of the element. In this case, we know the selector will only ever return one DOM
    element, if it exists at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will capture the current window height, `$(window).height()`, in a variable
    in the function. Using the `windowHeight` variable, we will derive some vertical
    limits where the arrow should fade in and out: lower and upper. The origin coordinate
    `(0,0)` sits on the top left-hand corner of the device window. The function call
    `${window).scrollTop()` retrieves an integer position that represents the current
    scroll position of the page.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we will explain the tricky parts. The two conditional statements check if
    the page view scroll position is above the lowest or highest bounds. If the scroll
    position exceeds the upper bound, then we will fade in the arrow from view. If
    the scroll position is less than the lower bound, then we will fade out the arrow
    from view. We will set up a countdown timer in order to prevent the retriggering
    of the animation. Note that JavaScript supports access to a lexical scope for
    the variables that are declared outside the function definition, also known as
    closures. The `minOpacity`, `maxOpacity`, `epsilon`, and `scrollingCount` variables
    are the closure variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of jQuery that uses the CSS3 three-dimensional transformations
    to achieve the expanding buttons or icons. This effect is borrowed from the older
    Mac OS X style user interface where the application icons expand and contract
    in the dock application bar, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `mouseenter()` and `mouseexit()` methods in order to build the
    effect. These methods respectively capture the desktop mouse entering and leaving
    the button, if it is displayed and can be seen. The anonymous functions set up
    the CSS in motion. CSS 3 already has the animation class styles. The transition
    class declares the length of the total animation, which is 0.5 milliseconds, and
    we also declare a 2D transform that scales the element up or down. To expand the
    button element, we will set the scale-factor to `1.667` of the default button
    size. To contract the button element, we will reset the scale-factor to the default
    rendering size of `1.0`. Note that we still have to declare the proprietary browser
    classes such as—webkit-transform for the WebKit browsers such as Apple's Safari
    and the previous editions of Google Chrome. Ultimately, this example is unhelpful
    for the touch screen devices because there are no devices available (yet) that
    can detect fingers hovering very close over a screen! (See the exercise at the
    end of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Working with HTML, JavaScript, and CSS can be quite involved, and it is a job
    of an interface developer to figure out the requirements and build frontends.
    However, a Java developer should also appreciate the work. I hope you see some
    results.
  prefs: []
  type: TYPE_NORMAL
- en: The RequireJS framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are serious about the organization of lots of JavaScript files and components,
    then you will be happy that ideas from dependency injection frameworks such as
    CDI and Spring have also made it in the world. Some professional organizations
    already rely on a small framework called RequireJS ([http://requirejs.org/](http://requirejs.org/)).
    The RequireJS framework is a JavaScript file and module loader. The framework
    has a built-in module script loader, which will improve the speed and quality
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: RequireJS implements the **Asychronous Module Definition** (**AMD**) specification
    for JavaScript ([https://github.com/amdjs/amdjs-api/wiki/AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)).
    This specification defines a mechanism that in turn defines the modules and dependencies
    between modules and how they can be asynchronously loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The AMD specification solves the critical issues where you have many JavaScript
    modules and define the multiple HTML script elements so as to load them, but then
    you find that each module had a dependency order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose that we have a JavaScript module A that has a dependency on
    a module B, then module B has a dependency on modules C and D. You might forget
    to include the dependency for the module D. Worse, you might get the order of
    the dependencies wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: RequireJS helps with these transient dependencies. First, we must understand
    how RequireJS loads the JavaScript files. The framework has a best practice folder
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of a Java web application, let''s define some files in a project,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/index.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/app/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/app/easel.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/app/nested/sub.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/lib/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/lib/jquery-2.1.1.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/lib/bootstrap-3.2.0.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/require.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/resources/js/require-setup.js`'
  prefs: []
  type: TYPE_NORMAL
- en: In a JSF application, we will place the JavaScript modules in the `resources`
    folder. This reads differently to the standard JavaScript descriptions because
    of the indirection required for JSF. The application files are usually saved in
    the `/js/app` folder. The JavaScript libraries are stored in the `/js/lib` folder.
    The `/js/require.js` file is the JavaScript file for a RequireJS framework module.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an HTML5 application, you will first include a reference to the RequireJS
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a practical use of RequireJS because we are using Bootstrap
    and jQuery in an application. The most important HTML script element is the second
    one because it loads RequireJS (require.js). The first script tag is important
    as it configures the RequireJS framework. We will see this in a moment. The third
    script tag loads an application JavaScript module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many commercial websites place tags at the bottom of the page content for a
    best practice convention use and to ease the performance. However, because RequireJS
    is designed for AMD, then this practice may defeat the purpose to load and execute
    the scripts asynchronously while the page continues to load. In other words, your
    mileage may vary and you need to test this out in development work.
  prefs: []
  type: TYPE_NORMAL
- en: A RequireJS configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look in reverse order at the loaded JavaScript files, so this is `/js/app/app.js`.
    This is the target of the reference data-main attribute in the `<script>` tag
    element that includes the RequireJS library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This file configures how RequireJS searches and loads the JavaScript files as
    modules. The `requirejs` is JavaScript Object type variable that the library defines
    in a global head scope. The reference object has a method called `config()` that
    accepts a JavaScript property object. The `baseUrl` property defines the default
    location to load the files. The paths property is a nested property, which lists
    a collection of the paths that are exceptions to the default loading rule.
  prefs: []
  type: TYPE_NORMAL
- en: By default the previous RequireJS configuration loads any module by ID from
    the folder `js/lib`. However if the module ID start with the prefix `app`, then
    it is loaded from the `js/app` directory as specified by the path key.
  prefs: []
  type: TYPE_NORMAL
- en: The paths property configuration is relative to `baseUrl` and never includes
    a `.js` suffix extension as the paths property could stand for a directory folder.
  prefs: []
  type: TYPE_NORMAL
- en: As we will load jQuery and Bootstrap for this example, we will need to shove
    a square peg in a round hole. In the JavaScript programming world, in order to
    avoid conflicts with many popular libraries, the authors have adopted the idea
    of shims.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is a shim?**'
  prefs: []
  type: TYPE_NORMAL
- en: A shim is the idea of a colloquial expression in the JavaScript parlance to
    force the different frameworks to work together. It is also a term for monkey-patching
    a JavaScript context to contain all of the EmcaScript 5 methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In RequireJS, we must set this up in the first loaded file (`require-setup.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It is helpful to re-examine the folder layout for our JavaScript files. The
    require-setup file simply sets up a special named variable called `require` in
    the global head scope with an object definition. The nest object referenced by
    the property name shim defines two changes. First, that a module called `bootstrap`
    has a dependency on a module called `jquery`. Second, the `jquery` module exports
    the symbol (`$`).
  prefs: []
  type: TYPE_NORMAL
- en: The second property key called paths in the configuration defines an association
    object for the module names. Each module name is mapped to its true name. So,
    the `jquery` module is actually associated with a file called `jquery-2.1.3`.
    There is a bonus feature with the indirection because now we have an easy way
    of upgrading the library versions. It's a one line change!
  prefs: []
  type: TYPE_NORMAL
- en: An application module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the configuration of RequireJS completed, we can now write the default
    application module for our application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `/js/app/main.js` script is the common file for our simple client-side
    application. The global `requirejs()` function is the pathway to the library''s
    feature of a dependency injection. The following is the format of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, `< MODULE-ARRAY-LIST>` is the list collection of the module name dependencies
    and `<CALLBACK>` is the single function argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the code example asks RequireJS to initialize the modules: `jquery`,
    `bootstrap`, `easel`, and `nested/sub`. Pay particular attention to the last module
    because `sub.js` is in a subdirectory of the `app` folder; therefore, the name
    uses the path separator. Remember, with RequireJS, you do not need to add the
    suffix (`.js`).'
  prefs: []
  type: TYPE_NORMAL
- en: By the time RequireJS invokes the callback function, the modules are loaded.
    Hence, we will write to the console log, and if we are using jQuery, we will make
    another anonymous function declaration in order to do some fancy selector manipulation
    on the toggle buttons. It should start to make sense as to why we will explicitly
    export the dollar symbol in the preceding shim configuration. Also note that we
    are able to access the reference dependencies through the function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: So, how will we define the module patterns with RequireJS? Read the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to define our own custom modules with RequireJS, we will make use
    of another global scope method from the framework. Following the AMD specification,
    the framework provides a method called `define()`. The format for this method
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is almost the same as the `requirejs()` call. The `define()` method accepts
    a list of the module names as a dependency. The `<FUNCTION-OBJECT>` second argument
    means that the function must explicitly return a JavaScript object. In other words,
    it can't return a void or nothing result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the definition for the canvas module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The module list can be an empty array, which means that the module has no required
    dependencies. The file path is `/js/app/easel.js`. In the anonymous function,
    we will instantiate our JavaScript constructor object with methods and properties
    and then return it to RequireJS. The module just defines a method called `getName()`,
    which returns the value of a private accessible variable. Following the module
    pattern in JavaScript, it is possible to declare the private scope variables and
    functions such as `_name` in the example, which are not accessible outside of
    the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the listing of the other module with a file path of `/js/app/nested/sub.js`,
    which has a dependency on the easel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nested/sub module` defines a function object that contains two methods:
    `getName()` and `getCanvasName()`. We will create an object variable called `easel`.
    RequireJS supplies the module reference as an argument during the invocation of
    the function. The `getCanvasName()` method uses this private reference to invoke
    the `getName()` method on the dependent module, `easel`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of RequireJS in action, loading the modules. The Chrome
    Developer Tools has a network view that allows us to inspect the JavaScript files
    being loaded over the wire:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining modules](img/image00417.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the RequireJS example application
  prefs: []
  type: TYPE_NORMAL
- en: If you find this terse at first, please bear in mind that it takes a little
    while to get your head around the functions and object scopes. The advantages
    are clear to the professional interface developers to get around the severe drawbacks
    of JavaScript's original design. We covered enough of RequireJS for the digital
    development to continue far and wide. We will move on to another framework.
  prefs: []
  type: TYPE_NORMAL
- en: UnderscoreJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I will introduce you to one more JavaScript framework that can be helpful in
    development. UnderscoreJS ([http://underscorejs.org/](http://underscorejs.org/))
    is a framework that brings functional programming constructs and techniques to
    the language. The library contains over 100 methods that add functional support
    to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'UnderscoreJS is a single JavaScript file downloaded just like jQuery and RequireJS.
    If you add the requisite versioned `underscore.js` file to the `/js/lib` folder,
    then you already have the means to inject it into your application. Here is the
    additional configuration in the file, `require-setup.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: UnderscoreJS exports the symbol underscore (`_`) for its library to a developer
    and its function methods are accessible through the symbol. We will review a small
    subset of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional programmers tend to be interested in the following five primary
    concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: How to internally iterate through a collection of elements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to filter the elements in a collection?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to map the elements in a collection from one type to another?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to flatten a collection of elements into just a collection?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, how to collect or reduce the elements in a collection to a single element
    or value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may recognize these concerns as standard ideas in the alternative programming
    languages in JVM such as Scala, Clojure, or even Java 8 with Lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: The for-each operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In UnderscoreJS, we can take an array object and simply iterate over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `each()` function allows you to iterate over the list collections, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used RequireJS as an AMD loader in a module called `underscore-demo.js`.
    The `each()` function iterates over the elements of the array object and invokes
    the supplied function, which is called the **iteratee** with the element as a
    single argument. The `each()` function replaces the typically `foreach` or `for-do`
    compound statements in imperative programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: The filter operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filtering can be achieved in several ways. Let''s take a basic example of filtering
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code searches through each value in the list, returning an array of all
    the values that pass a truth test (predicate). The second argument to `filter()`
    is known as the predicate, which is a function callback that returns a Boolean
    value if the element that is supplied meets the condition test or not. Here, we
    are filtering the names in the list if they begin with the letter `P`.
  prefs: []
  type: TYPE_NORMAL
- en: 'UnderscoreJS also provides a more sophisticated filtering method. The `where()`
    method searches a list and returns an array of all the values that contain all
    of the key-value pairs listed in the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `ContactDetail` JavaScript object that we defined
    earlier in this chapter. We will invoke the `where()` method with the list of
    contacts and supplied key-value objects with the properties that we want to filter.
    The result is `ContactDetail` that matches Anne Jackson because she has a matching
    occupation (software developer) and age (28).
  prefs: []
  type: TYPE_NORMAL
- en: The map operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `map()` function produces a new array object by mapping each element in
    the list, with the user supplied function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The user-supplied function accepts the current element parameter and is responsible
    for returning the new element type. In these examples, we will create a new array
    list of triples of the number element, and next, we will create a new array list
    of the squares of the number element. Finally, we will create an array list of
    the string elements.
  prefs: []
  type: TYPE_NORMAL
- en: The flatten operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to iterate, filter, and map a collection with UnderscoreJS,
    we should also learn how to flatten the collections of elements. There is a method
    called `flatten()` that accepts a collection of elements and flattens it if one
    or more of these elements is itself a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the following two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined an object called `Sector` that represents, say, the sales and
    marketing data. We created a nested collection, `salesSectorData`, which is actually
    an array of two elements but each element is a further collection. In short, `salesSectorData`
    is a level two ordered data structure.
  prefs: []
  type: TYPE_NORMAL
- en: The first `flatten()` call completely flattens the data structure in an array
    list. So we will end up with an array of five items. We will pass a second argument
    to the second `flatten()` call, which is a boolean argument that specifies whether
    the flatten operation should operate also on the elements of the collection or
    not. The result of `f4` is an array of four items. The first element is an array
    list of two items, the second element is an array list of one item, and then the
    remaining elements will follow.
  prefs: []
  type: TYPE_NORMAL
- en: It should be clear why a JavaScript interface developer raves about UnderscoreJS.
    We will move on to the final operation in this firebrand review.
  prefs: []
  type: TYPE_NORMAL
- en: The reduction operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What good are all of these functional operations if we cannot reduce them to
    a single scalar value or object? Thankfully, RequireJS provides us with several
    varieties of methods such as `reduce()`, `reduceRight()`, `min()`, and `max()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will just look at the `reduce()` operation for now. If we wanted to discover
    the total sale value for all of the previous sector objects, how will we do it?
    Here is the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reduce()` operation accepts three arguments: the collection, an iteratee
    function, and initial value. In order to reduce the collection to a single scalar
    value, the `reduce()` operation calls the iteratee on each element. The iteratee
    function accepts the scalar value argument and element. The anonymous function
    adds the sale sector value to the accumulator.'
  prefs: []
  type: TYPE_NORMAL
- en: The `reduce()` operator is left-associative in respect to the collection, whereas
    `reduceRight()` is right-associative. This completes our journey in UnderscoreJS.
    A more interested reader can delve further into this framework online and through
    other resources of information.
  prefs: []
  type: TYPE_NORMAL
- en: GruntJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we conclude this chapter on progressive JavaScript programming, we will
    quickly take a look at a tool to launch actions. This tool is GruntJS ([http://gruntjs.com/](http://gruntjs.com/)),
    and the people behind it describe it as the JavaScript task runner. GruntJS is
    a Node.js tool and works in this ecosystem. Therefore, developers must install
    Node.js before they can work with GruntJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool is currently a favorite with many in the digital community. The following
    are some of the reasons why GruntJS is seen as a bonus:'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration is in one place and can be shared among other developers,
    testers, and operators across your digital team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GruntJS is built with a plugin system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool compresses your CSS and minimizes your JavaScript files for performance
    and delivery to the product site.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GruntJS allows teams of dedicated interface developers to work separately or
    together on the client-side bits of a website. The tools then concatenate their
    JavaScript and CSS components together for a production delivery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can optimize your images to reduce the overall file size and yet still retain
    the quality, which is perfect to deliver the massive *hero* style retina display
    graphics and also create mobile-friendly images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers can take advantage of Sass and Less for CSS authoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are GruntJS plugins for Less, Sass, RequireJS, CoffeeScript, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is a JavaScript runtime platform and therefore, it is absolutely different
    from the Java platform. If you happen to use Gradle, there are two open source
    plugins available that help to bridge the gap between them. They are called Gradle-GruntJS
    Plugin ([https://github.com/srs/gradle-grunt-plugin](https://github.com/srs/gradle-grunt-plugin))
    and Gradle-Node Plugin ([https://github.com/srs/gradle-node-plugin](https://github.com/srs/gradle-node-plugin)).
    Node.js also has its own package manager called npm, which handles the installation,
    updating, and removing of the libraries. Npm permits the Node.js and JavaScript
    open source libraries to be shared with the community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every GruntJS project requires the following two files in the root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`: This file specifies the metadata for an npm project and contains
    JavaScript tool and library dependencies that your project requires, including
    GruntJS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gruntfile.js`: This file configures and defines the build tasks for your project.
    It is the file where you can also add dependencies for the GruntJS plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a JSF project, you will place `package.json` in the project root folder.
    Here is a code for the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the file looks almost like a JSON file. The critical `devDependencies`
    property declares a set of npm tools and frameworks. We want to definitely load
    GruntJS from version 0.4.5 or better.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will dive straight into a real-world case of GruntJS. In a digital project,
    we want to optimize the performance and ensure our SEO ranking with the search
    engines. We are required to merge together the third-party JavaScript libraries
    and minimize the JavaScript files. The interface developers prefer to keep using
    the Sass tool for the flexibility management of the CSS files. We have an agreement
    with our management to keep the developed JavaScript files untouched for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `gruntfile.js` file that achieves this ambition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `gruntfile.js` file defines a single module in the Node.js system.
    It sounds confusing to have a module system in another module; however, all we
    have to know is that modules are a form of encapsulation that permits sharing
    through reuse. The `module.exports` definition allows grunt to participate in
    the Node.js system. Therefore, it is possible to share this grunt module with
    the other node modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `grunt.initConfig()` stanza is required to initialize the GruntJS tool.
    The most important part specifies the name of the metadata file, `package.json`.
    Afterwards, we have an area reserved for the plugin configuration. Each GruntJS
    plugin has a separate configuration of properties. There are three plugins: `grunt-contrib-concat`,
    `grunt-contrib-uglify`, and `grunt-contrib-sass`. Each plugin declares a configuration
    property name: `concat`, `uglify`, and `sass`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the concatenation plugin, we have the following stanza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `grunt-contrib-concat` plugin requires a source of files and a destination
    file. It takes whatever JavaScript library files that are there and then generates
    a single file called `thirdparty.js`. In our Gradle (or Maven project), let's
    assume that we have a WAR task that will eventually bundle the final destination
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We must be aware of the de facto Gradle and Maven directory layout configuration
    for the web projects. Therefore, we will add `src/main/webapp` to the file paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the minimization plugin, we will execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This configuration is very easy to understand; we will just point the `grunt-uglify-contrib`
    plugin to a source and target the file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will configure the Sass CSS build plugin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We will need slightly more instructions for the `grunt-contrib-sass` plugin.
    This plugin requires the key-value properties of files. The target file is the
    key property and the SASS source file is the value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing SASS additionally requires the installation of a valid Ruby installation
    and the corresponding RubyGem.
  prefs: []
  type: TYPE_NORMAL
- en: GruntJS is an exciting and powerful tool for the client-side digital developers.
    There is no doubt about this. The plugin system is still quite immature and I
    recommend that you check the documentation for the configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a whirlwind tour of the modern digital JavaScript programming.
    If you have not worked with the JavaScript language at all or left it far behind
    for several years, then I do hope that you have been invigorated to learn this
    essential skill. We looked at the programming of the JavaScript objects. We saw
    how to construct the objects. We learned about the property notations and dealt
    with the JavaScript truth.
  prefs: []
  type: TYPE_NORMAL
- en: We paid a particular respectable visit to jQuery—the grandmother or granddaddy
    of the JavaScript programming. If you learned nothing else, then you can now understand
    jQuery. We saw how the selectors can search HTML DOM for the elements, which can
    then be manipulated for effect. We made a brief foray into animation, which opened
    the door to the creation of more sophisticated experiences for the customers and
    business owners.
  prefs: []
  type: TYPE_NORMAL
- en: We ventured into dependency management of the modules with RequireJS. We learned
    how this framework can help a digital developer to organize the modules and leave
    the order of retrieving them to the framework.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we crossed the bridge to a non-Java platform called
    Node.js and, in particular, learned the basic details about GruntJS. We studied
    an example of a GruntJS definition that bundled the JavaScript library files together,
    generated CSS from Sass, and optimized the size of the JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will look at AngularJS and the up-and-coming Java EE
    MVC framework.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the exercises and questions for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What does the following JavaScript code define? What else is similar to it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the preceding code, explain what is the main difference between the `hospital.patients`
    and `hospital['patients']` property accessors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a JavaScript object that constructs a participant to a Java User Group
    member. Let's say you call your object `JUGParticipant`. You will need to capture
    their first and last names, their telephone contact numbers, their e-mail addresses
    (optional), and also their specific interests (optional).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify `JUGParticipant` to accept the interests as another object. Write a JavaScript
    Tag object so that you build an array of skills such as Java EE, Android, or HTML.
    Demonstrate that you can build this object graph of the `JUGParticipants` and
    Tag objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt your JavaScript object graph by creating a `JUGEvent` meeting object.
    Your object will need to hold properties such as the event title, its description,
    location, presentation speaker (optional), and willing `JUGParticipants`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find out the nine native object constructors in JavaScript 1.5 (or ECMAScript
    edition 3). To start you off, here are four: `Number()`, `String()`, `Boolean()`,
    and `Object()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the following HTML, use jQuery to change the background color of the `div`
    element, `messageArea`. There are three buttons in the code to denote the convention
    of a traffic light. (You are allowed to make the content pretty!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Explain the difference between the following two jQuery statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the following HTML5 code, which displays a Bootstrap alert box, we want
    the user to make the warning disappear when they click on the close icon. Write
    JavaScript and jQuery to animate the critical notice, fade it out, and then remove
    the content from HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Look at the book's source code and get started with RequireJS. Study the code.
    Your task is to modify the code and add your module, which you may call `/js/app/oxygen.js`.
    You will need to use the AMD specification `define()` method call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have written the new RequireJS module, `oxygen.js`, how do you
    know that it works as expected? Did you write a test web page? You will probably
    need to write a `/js/app/oxygendemo.js` JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define two modules called `/js/app/hydrogen.js` and `/js/app/water.js`. Set
    up the water module such that it depends on the other two modules: hydrogen and
    oxygen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Working with UnderscoreJS and assuming that you have set up the dependencies,
    exercise the following JavaScript example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look at the following JavaScript code, which defines a percentage and an array
    of product prices. Using UnderscoreJS, calculate the grand total price and also
    the grand total price when each price is increased by the percentage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we have different types of products. Using UnderscoreJS, work out
    the grand total of the original prices and then work out the grand total with
    an increase of 5.35 percent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
