<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Spring Cloud</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will learn about the following topics:</p>
<ul>
<li>Getting started with Spring Cloud</li>
<li>Service discovery using Spring Cloud Consul</li>
<li>Using Spring Cloud Netflix—Feign</li>
<li>Service discovery using Spring Cloud Netflix—Eureka</li>
<li>Using Spring Cloud Netflix—Hystrix</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Throughout this book, we have learned how to create an application, configure RESTful services, do testing, integrate metrics and other management components, and handle packaging and deployment, among other things. Now, the time has come to look at the world outside the application—the ubiquitous cloud environment.</p>
<p>In this chapter, we will look at how to make applications cloud-friendly, how to deal with the dynamic nature of the distributed applications running in the cloud, how to make our applications visible to the world, how to discover other service endpoints, how to call them, and how to handle various error conditions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with Spring Cloud</h1>
                </header>
            
            <article>
                
<p>The Spring Cloud family of projects provides integration extensions for Spring Boot of various frameworks, which offer functionality for distributed service discovery, configuration, routing, service invocation, and more. Through the use of uniform API, we can add these concepts to our applications and later have the flexibility to change the specific implementation if such a need arises without making deep-cutting changes to our codebase.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will start by enhancing our <kbd><span class="KeyWordPACKT">BookPub</span></kbd> project with base Spring Cloud modules by adding them to the main build configuration:</p>
<ol>
<li>Add the following content to the <kbd><span class="CodeInTextPACKT">build.gradle</span></kbd> file located at the root of the project:</li>
</ol>
<pre style="padding-left: 60px">... 
apply plugin: 'docker' 
 
dependencyManagement { 
    imports { 
        mavenBom 'org.springframework.cloud:spring-cloud-dependencies:Finchley.BUILD-SNAPSHOT' 
    } 
} 
 
jar { 
    baseName = 'bookpub' 
    version = '0.0.1-SNAPSHOT' 
} 
 
... 
 
dependencies { 
    ... 
    compile("org.springframework.boot:spring-boot-devtools") 
    compile("org.springframework.cloud:spring-cloud-context") 
    compile("org.springframework.cloud:spring-cloud-commons") 
    runtime("com.h2database:h2") 
    ... 
}</pre>
<ol start="2">
<li>Start the application by running <kbd><span class="CodeInTextPACKT">./gradlew clean bootRun</span></kbd></li>
<li>After the application has been started, even though it seems like nothing new has happened, if we open our browser at <kbd><span class="URLPACKT"><span>http://localhost:8081/actuator/env</span></span></kbd> (the management endpoint for environment), we will see new property sources appear:</li>
</ol>
<pre style="padding-left: 60px">{ 
  "name": "springCloudClientHostInfo", 
  "properties": { 
    "spring.cloud.client.hostname": { 
      "value": "127.0.0.1" 
    }, 
    "spring.cloud.client.ip-address": { 
      "value": "127.0.0.1" 
    } 
  } 
} </pre>
<ol start="4">
<li>Create a <kbd><span class="CodeInTextPACKT">bootstrap.properties</span></kbd> file under the <kbd><span class="CodeInTextPACKT">src/main/resources</span></kbd> directory from the root of our project with the following content (the same properties should be commented out inside <kbd><span class="CodeInTextPACKT">application.properties</span></kbd> at this point):</li>
</ol>
<pre style="padding-left: 60px">spring.application.name=BookPub-ch9 </pre>
<ol start="5">
<li>Start the application by running <kbd><span class="CodeInTextPACKT">./gradlew clean bootRun</span></kbd></li>
<li>After the application has been started, open our browser at <kbd><span class="URLPACKT"><span>http://localhost:8081/env</span></span></kbd> and we will see new property sources appear:</li>
</ol>
<pre style="padding-left: 60px">{ 
  "name": "applicationConfig: [classpath:/bootstrap.properties]", 
  "properties": { 
    "spring.application.name": { 
      "value": "BookPub-ch9", 
      "origin": "class path resource [bootstrap.properties]:1:25" 
    } 
  } 
}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Before we dive under the hood of how things work, let's review the changes that we have made to our project. The first step was to enhance the <kbd><span class="CodeInTextPACKT">build.gradle</span></kbd> build configuration by importing a <strong>Bill of Material</strong> (<strong>BOM</strong>) declaration for a Spring Cloud release train—<kbd><span class="CodeInTextPACKT">mavenBom 'org.springframework.cloud:spring-cloud-dependencies:</span> <span class="CodeInTextPACKT">Finchley.BUILD-SNAPSHOT'</span></kbd>. While we could have selectively imported explicitly-defined versions of the <kbd><span class="CodeInTextPACKT">spring-cloud-context</span></kbd> and <kbd><span class="CodeInTextPACKT">spring-cloud-commons</span></kbd> libraries, by relying on a packaged BOM, we are sure that we will be using the correct versions of different artifacts that have been tested for compatibility with each other.</p>
<div class="packt_infobox">Specific versions of each Spring Cloud modules that are included in a particular Release Train can be seen at <span class="URLPACKT"><span><a href="http://cloud.spring.io/">http://cloud.spring.io/</a>.<a href="http://cloud.spring.io/"/></span></span></div>
<p>We start by adding dependencies on the <kbd><span class="CodeInTextPACKT">spring-cloud-context</span></kbd> and <kbd><span class="CodeInTextPACKT">spring-cloud-commons</span></kbd> libraries, to illustrate the basic common facilities Spring Cloud provides, before diving into a specific starter integration such as <kbd><span class="CodeInTextPACKT">spring-cloud-netflix</span></kbd> or <kbd><span class="CodeInTextPACKT">spring-cloud-consul</span></kbd>. Those basic libraries provide a foundation of interfaces and common functionality that is being used to build upon in all the different cloud-specific integrations. Here is what their purpose is:</p>
<ul>
<li><span class="CodeInTextPACKT"><kbd>spring-cloud-commons</kbd>:</span> This provides a collection of shared common interfaces and base classes that define the notions of service discovery, service routing, load balancing, circuit breaking, feature capabilities, and some basic configuration. For example, this is the library that autoconfigures the environment with the <kbd><span class="CodeInTextPACKT">springCloudClientHostInfo</span></kbd> property source.</li>
<li><span class="CodeInTextPACKT"><kbd>spring-cloud-context</kbd>:</span> This is the base foundation that is responsible for bootstrapping and configuring the various integrations, such as a specific implementation of service discovery like Consul, or a specific implementation of circuit breaker like <strong>Hystrix</strong>. This is achieved by creating an isolated Bootstrap application context, which is responsible for loading and configuring all the components before the main application is started.</li>
</ul>
<p>Bootstrap application context gets created early on in the application start cycle and it is configured by a separate file—<kbd><span class="CodeInTextPACKT">bootstrap.properties</span></kbd> (a YAML variant is also supported). Since it is very typical for an application running in the cloud to rely on many external sources of configuration, service lookup, and so on, the purpose of the Bootstrap context is to configure those functions and obtain all of the necessary configuration from outside.</p>
<p>To clearly separate application configuration from Bootstrap, we put things that describe the application, or configure external configs, or other environmental variants like where to call for service discovery, into <kbd><span class="CodeInTextPACKT">bootstrap.properties</span></kbd> instead of <kbd><span class="CodeInTextPACKT">application.properties</span></kbd>. In our example, we have placed <kbd><span class="CodeInTextPACKT">spring.application.name</span></kbd> config into <span class="CodeInTextPACKT"><kbd>bootstrap.properties</kbd>,</span> because that information will be needed during the Bootstrap phase; it could be used to look up configuration from a remote config store.</p>
<p>Since Bootstrap application context is indeed a real Spring application context, there exists a parent-child relationship between the two, where Bootstrap application context becomes the parent of the Spring Boot application context. This means that all the beans and the property sources defined in the Bootstrap context become available for consumption from within the application context as well.</p>
<p>When Spring Cloud is added to the application, it automatically provides the integration framework for specific Spring Cloud modules, like Spring Cloud Consul, to be plugged in via the use of the by now well-known <kbd><span class="CodeInTextPACKT">spring.factories</span></kbd> configuration declarations. The annotations provided inside <kbd><span class="CodeInTextPACKT">spring-cloud-commons</span></kbd>, namely <kbd><span class="CodeInTextPACKT">@SpringCloudApplication</span></kbd>, <kbd><span class="CodeInTextPACKT">@EnableDiscoveryClient</span></kbd>, <kbd><span class="CodeInTextPACKT">@EnableCircuitBreaker</span></kbd>, and the <kbd><span class="CodeInTextPACKT">@BootstrapConfiguraion</span></kbd> and <kbd><span class="CodeInTextPACKT">PropertySourceLocator</span></kbd> interfaces provided by the <kbd><span class="CodeInTextPACKT">spring-cloud-context</span></kbd> library, are designed to define the integration points to be used to self-configure specific components such as discovery clients like Consul, circuit breakers like Hystrix, or remote configuration sources like <strong>ZooKeeper</strong>.</p>
<p>Let's examine those in detail:</p>
<ul>
<li><span class="CodeInTextPACKT"><kbd>@SpringCloudApplication</kbd>: This annotation is</span> like <span class="CodeInTextPACKT"><kbd>@SpringBootApplication</kbd>,</span> meta-annotation in nature, except it also wraps the <kbd><span class="CodeInTextPACKT">@EnableDiscoveryClient</span></kbd> and <kbd><span class="CodeInTextPACKT">@EnableCircuitBreaker</span></kbd> annotations in addition to also being meta-annotated with <kbd><span class="CodeInTextPACKT">@SpringBootApplication</span></kbd>. It is a good idea to use this annotation when you want to enable both the discovery client and the circuit breaker functionality in your application.</li>
<li><span class="CodeInTextPACKT"><kbd>@EnableDiscoveryClient</kbd>: This annotation</span> is used to indicate that Spring Cloud should initialize the provided discovery client for service registry, depending on the included integration library, such as Consul, Eureka, ZooKeeper, and so on.</li>
<li><span class="CodeInTextPACKT"><kbd>@EnableCircuitBreaker</kbd>: This annotation</span> is used to indicate that Spring Cloud should initialize the circuit breaker capabilities, based on the specific dependency of the integration library, such as Hystrix.</li>
<li><span class="CodeInTextPACKT"><kbd>PropertySourceLocator</kbd>: This</span> is used by the integration libraries to implement specific functionality of how to extract remote configuration from the provided datastore. Each integration module, providing ability to load remote configuration, would register an implementing bean of this type that exposes an implementation of <kbd><span class="CodeInTextPACKT">PropertySource</span></kbd> that is backed by the integration.</li>
<li><span class="CodeInTextPACKT"><kbd>@BootstrapConfiguration</kbd>: This annotation is</span> like the <kbd><span class="CodeInTextPACKT">@ManagementContextConfiguration</span></kbd> annotation, and is (mostly) a marker annotation geared to identify the key inside the <kbd><span class="CodeInTextPACKT">spring.factories</span></kbd> descriptor to indicate which configuration classes should be loaded during the Spring Cloud Bootstrap process and be part of the Bootstrap application context. Those configurations are read by <kbd><span class="CodeInTextPACKT">BootstrapApplicationListener</span></kbd> during startup and initialize the specified configurations. Typically, this is where the configuration classes, which define and expose <span class="CodeInTextPACKT"><kbd>PropertySourceLocator</kbd></span>—implementing beans, are configured.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service discovery using Spring Cloud Consul</h1>
                </header>
            
            <article>
                
<p>In a world of distributed computing, it is very common for services to become a disposable commodity. The typical life cycle of a service could be measured in days, if not in hours, and it is not unheard of for an instance to just crash for whatever reason, only to have a new one come up automatically seconds later. When the state of applications is so ephemeral, it becomes really hard to maintain a statically-connected architecture, with services knowing where exactly their dependent services are located, as the topology is always changing.</p>
<p>To help with this problem, the service discovery layer comes into play, maintaining a centralized and distributed state of service registrations, ready to reply on demand with the most current information. Applications register themselves upon startup, providing information about their location and possibly about their capabilities, level of service, health check status, and even more.</p>
<p>Earlier in the book, in <a href="c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em><span class="ItalicsPACKT">Application Packaging and Deployment</span></em>, we were introduced to Consul, and used it for external application configuration consumption. In this recipe, we will continue to look further into the capabilities of Consul and will learn about how to use the <kbd><span class="CodeInTextPACKT">spring-cloud-consul</span></kbd> modules to automatically register our application with Consul.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Take a look at the following steps to set up service discovery:</p>
<ol>
<li>Replace the <kbd><span class="CodeInTextPACKT">spring-cloud-commons</span></kbd> and <kbd><span class="CodeInTextPACKT">spring-cloud-context</span></kbd> modules with <kbd><span class="CodeInTextPACKT">spring-cloud-starter-consul-all</span></kbd> by modifying the <kbd><span class="CodeInTextPACKT">build.gradle</span></kbd> file located in the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">... 
 
dependencies { 
    ... 
    compile("io.dropwizard.metrics:metrics-graphite:3.1.0") 
    compile("org.springframework.boot:spring-boot-devtools") 
    //compile("org.springframework.cloud:spring-cloud-context") 
    //compile("org.springframework.cloud:spring-cloud-commons") 
    compile("org.springframework.cloud:spring-cloud-starter-consul-all") 
    runtime("com.h2database:h2") 
    ... 
} 
... </pre>
<ol start="2">
<li>With Consul dependencies added, we will proceed with enabling our application to automatically register with the local agent upon startup by modifying the <kbd><span class="CodeInTextPACKT">BookPubApplication.java</span></kbd> file located under the <kbd><span class="CodeInTextPACKT">src/main/java/com/example/bookpub</span></kbd> directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">... 
@EnableScheduling 
@EnableDbCounting 
@EnableDiscoveryClient 
public class BookPubApplication { 
    ... 
}</pre>
<ol start="3">
<li>Given that Consul was successfully installed using the steps described in the <em><span class="ItalicsPACKT">Setting up Consul</span></em> recipe in <a href="c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em><span class="ItalicsPACKT">Application Packaging and Deployment</span></em>, we should be able to start it by running <kbd><span class="CodeInTextPACKT">consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul</span></kbd> and our Terminal window should display the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>==&gt; Starting Consul agent... 
==&gt; Starting Consul agent RPC... 
==&gt; Consul agent running! 
           Version: 'v1.0.2' 
...</strong> </pre>
<ol start="4">
<li>After the Consul agent is up and running successfully, we will proceed by starting our application by running <kbd><span class="CodeInTextPACKT">./gradlew clean bootRun</span></kbd></li>
<li>As we watch the startup logs scroll by, there are a couple of interesting entries that indicate the application is interacting with the agent, so watch for the following content in the logs:</li>
</ol>
<pre style="padding-left: 60px"><strong>... 
2017-12-26 --- b.c.PropertySourceBootstrapConfiguration : Located property source: CompositePropertySource [name='consul', propertySources=[ConsulPropertySource [name='config/BookPub-ch9/'], ConsulPropertySource [name='config/application/']]] 
... 
2017-12-26 --- o.s.c.consul.discovery.ConsulLifecycle   : Registering service with consul: NewService{id='BookPub-ch9-8080', name='BookPub-ch9', tags=[], address='&lt;your_machine_name&gt;', port=8080, check=Check{script='null', interval=10s, ttl=null, http=http://&lt;your_machine_name&gt;:8081/health, tcp=null, timeout=null}} 
2017-12-26 --- o.s.c.consul.discovery.ConsulLifecycle   : Registering service with consul: NewService{id='BookPub-ch9-8080-management', name='BookPub-ch9-management', tags=[management], address='://&lt;your_machine_name&gt;', port=8081, check=Check{script='null', interval=10s, ttl=null, http=http://chic02qv045g8wn:8081/health, tcp=null, timeout=null}} 
...</strong></pre>
<ol start="6">
<li>Just to verify that our application has registered and is in communication with the local Consul agent, let's open <kbd><span class="CodeInTextPACKT">http://localhost:8081/actuator/consul</span></kbd> in the browser to see the Consul agent information, as shown in the following screenshot:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="253" src="assets/8cb7c381-b98e-44d9-b5c1-744a19fd90d9.png" width="513"/></div>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When we added <kbd><span class="CodeInTextPACKT">spring-cloud-starter-consul-all</span></kbd> as a build dependency, it automatically pulled all the necessary components to enable Consul functionality for our application. We automatically got the <kbd><span class="CodeInTextPACKT">spring-cloud-consul-binder</span></kbd>, <kbd><span class="CodeInTextPACKT">spring-cloud-consul-core</span></kbd>, <span class="CodeInTextPACKT"><kbd>spring-cloud-consul-config</kbd>,</span> and <kbd><span class="CodeInTextPACKT">spring-cloud-consul-discovery</span></kbd> artifacts added to our classpath. Let's take a look at the them:</p>
<ul>
<li><span class="CodeInTextPACKT"><kbd>spring-cloud-consul-core</kbd>:</span> This artifact provides base autoconfiguration to expose generic <kbd><span class="CodeInTextPACKT">ConsulProperties</span></kbd>, as well as the <kbd><span class="CodeInTextPACKT">ConsulClient</span></kbd> initialization and setting of the <kbd><span class="CodeInTextPACKT">/consul</span></kbd> management endpoint, if the Spring Boot Actuator functionality is enabled.</li>
<li><span class="CodeInTextPACKT"><kbd>spring-cloud-consul-config</kbd>:</span> This provides the <kbd><span class="CodeInTextPACKT">ConsulPropertySourceLocator</span></kbd> implementation, used during Bootstrap, to configure the <kbd><span class="CodeInTextPACKT">ConsulPropertySource</span></kbd> bean, which allows remote configuration consumption from the Consul key/value store. It also sets up a <kbd><span class="CodeInTextPACKT">ConfigWatch</span></kbd> change observer, which fires <kbd><span class="CodeInTextPACKT">RefreshEvent</span></kbd> to the application context, if a configuration key value changes in Consul key/value store while the application is running. This allows for a possible configuration properties reload without having to redeploy and restart the application.</li>
<li><span class="CodeInTextPACKT"><kbd>spring-cloud-consul-discovery</kbd>:</span> This provides all the functionality and implementations needed for service discovery, service registration, and service invocation.</li>
<li><span class="CodeInTextPACKT"><kbd>spring-cloud-consul-binder</kbd>:</span> This provides integration of Consul event functionality with Spring Cloud Stream Framework, enabling it to send and receive events from Consul and respond to them within the application. While outside of the scope of this chapter, more information can be obtained from <span class="URLPACKT"><span><a href="http://cloud.spring.io/spring-cloud-stream/">http://cloud.spring.io/spring-cloud-stream/</a>.<a href="http://cloud.spring.io/spring-cloud-stream/"/></span></span></li>
</ul>
<p>While addition of <kbd><span class="CodeInTextPACKT">spring-cloud-consul-config</span></kbd> to the classpath will automatically register <kbd><span class="CodeInTextPACKT">ConsulPropertySource</span></kbd>, it is not so for the <kbd><span class="CodeInTextPACKT">spring-cloud-consul-discovery</span></kbd> module. The service discovery functionality is more intrusive and thus requires an additional step of acknowledgement from the developers to indicate that it is indeed wanted. This is accomplished by adding the <kbd><span class="CodeInTextPACKT">@EnableDiscoveryClient</span></kbd> annotation to the main application class; in our case it is <kbd><span class="CodeInTextPACKT">BookPubApplication</span></kbd>.</p>
<p>Once the <kbd><span class="CodeInTextPACKT">@EnableDiscoveryClient</span></kbd> annotation is added, Spring Cloud (<kbd><span class="CodeInTextPACKT">EnableDiscoveryClientImportSelector</span></kbd> class from the <kbd><span class="CodeInTextPACKT">spring-cloud-commons</span></kbd> module, to be more precise) scans all <kbd><span class="CodeInTextPACKT">spring.factories</span></kbd> files for the presence of the <kbd><span class="CodeInTextPACKT">org.springframework.cloud.client.discovery.EnableDiscoveryClient</span></kbd> key, and loads all the associated configurations into the main application context. If we look inside the <kbd><span class="CodeInTextPACKT">spring.factories</span></kbd> file located in the <kbd><span class="CodeInTextPACKT">spring-cloud-consul-discovery</span></kbd> JAR under the <kbd><span class="CodeInTextPACKT">META-INF/</span></kbd> directory, we will see the following entry:</p>
<pre># Discovery Client Configuration 
org.springframework.cloud.client.discovery.EnableDiscoveryClient=\ 
org.springframework.cloud.consul.discovery.ConsulDiscoveryClientConfiguration</pre>
<p>This tells us that when the discovery client is enabled, <kbd><span class="CodeInTextPACKT">ConsulDiscoveryClientConfiguration</span></kbd> will be consumed and all of its defining beans will be added to the application context.</p>
<p>A similar approach can be used if a custom service discovery mechanism is being used. One will need to create a custom configuration class, exposing a custom implementation of the <kbd><span class="CodeInTextPACKT">DiscoveryClient</span></kbd> interface, and configure it in the <kbd><span class="CodeInTextPACKT">spring.factories</span></kbd> file bundled within the archive. Once that JAR gets loaded, the configuration will be automatically consumed if discovery client functionality is enabled.</p>
<div class="packt_infobox">Spring Cloud Consul libraries provide very fine-grained ability to configure and pick and choose the selected functions, if not all apply for a particular use-case. For detailed information about various configuration and usage options see <span class="URLPACKT"><a href="http://cloud.spring.io/spring-cloud-consul/">http://cloud.spring.io/spring-cloud-consul/</a></span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Spring Cloud Netflix – Feign</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we looked at how to enable service discovery capability for our application in order to be able to register our service with the world as well as to know what other services exist and where they are located. This recipe will help us better interact with that information and consume those services without having to explicitly code any logic to handle service discovery and all of the related concerns that come with it.</p>
<p>To achieve this goal, we will look at another Spring Cloud integration, provided by the Spring Cloud Netflix module family—Netflix Feign. Feign, which makes writing Java HTTP clients easier. Its purpose is to simplify the process of binding service API calls to their corresponding HTTP API counterparts. It provides automatic service mapping and discovery, ability to translate Java types to HTTP request URL paths, parameters and response payloads, as well as error handling.</p>
<p>For the sake of simplicity, in this recipe, we will be creating a <kbd>Client</kbd> controller, which will act as an external client of our <kbd>BookPub</kbd> application service, calling our APIs via Feign-annotated Java service interfaces, relying on Consul to provide service discovery functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>We will start by adding Netflix Feign module dependencies to our project. Let's modify our <kbd><span class="CodeInTextPACKT">build.gradle</span></kbd> file located in the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
    ... 
    compile("org.springframework.cloud:spring-<br/>    cloud-starter-consul-all") 
    compile("org.springframework.cloud:spring-<br/>    cloud-starter-openfeign") 
    runtime("com.h2database:h2") 
    ... 
} </pre>
<ol start="2">
<li>With the dependency added, our next step is to create a Java API interface describing how we want to define our interaction with the <kbd>BookPub</kbd> service. Let's create an <kbd>api</kbd> package under the <kbd><span class="CodeInTextPACKT">src/main/java/com/example/bookpub</span></kbd> directory from the root of our project.</li>
<li>Inside the newly-created <kbd><span class="CodeInTextPACKT">api</span></kbd> package, let's create our API class file named <kbd><span class="CodeInTextPACKT">BookPubClient.java</span></kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px">package com.example.bookpub.api; 
 
import com.example.bookpub.entity.Book; 
import org.springframework.cloud.netflix.feign.FeignClient; 
import org.springframework.web.bind.annotation.PathVariable; 
import org.springframework.web.bind.annotation.RequestMapping; 
import org.springframework.web.bind.annotation.RequestMethod; 
 
@FeignClient("http://BookPub-ch9") 
public interface BookPubClient { 
    @RequestMapping(value = "/books/{isbn}",  
                    method = RequestMethod.GET) 
    public Book findBookByIsbn(@PathVariable("isbn") String isbn); 
}</pre>
<ol start="4">
<li>After we have defined the API, it is time to tell our application that we want to enable Feign support. We will do that by making a change to the <kbd><span class="CodeInTextPACKT">BookPubApplication.java</span></kbd> file located under the <kbd><span class="CodeInTextPACKT">src/main/java/com/example/bookpub</span> directory</kbd> from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">... 
@EnableDiscoveryClient 
@EnableFeignClients 
public class BookPubApplication {...} </pre>
<ol start="5">
<li>Finally, let's create a client controller to invoke <kbd><span class="CodeInTextPACKT">BookPubClient</span></kbd> by making a new file named <kbd><span class="CodeInTextPACKT">ClientController.java</span></kbd> under the <kbd><span class="CodeInTextPACKT">src/main/java/com/example/bookpub/controllers</span></kbd> directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">... 
@RestController 
@RequestMapping("/client") 
public class ClientController { 
 
    @Autowired 
    private BookPubClient client; 
 
    @RequestMapping(value = "/book/{isbn}",  
                    method = RequestMethod.GET) 
    public Book getBook(@PathVariable String isbn) { 
        return client.findBookByIsbn(isbn); 
    } 
} </pre>
<ol start="6">
<li>With everything set and done, let's start the application by executing the <kbd><span class="CodeInTextPACKT">./gradlew clean bootRun</span></kbd> command.</li>
</ol>
<div class="packt_infobox">Make sure that the Consul agent is also running in the background, otherwise service registration will fail.</div>
<ol start="7">
<li>Once the application is up and running, let's open <kbd><span class="CodeInTextPACKT">http://localhost:8080/client/book/978-1-78528-415-1</span></kbd> in the browser to see the Consul agent information, as shown in the following screenshot:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="213" src="assets/42791c29-c531-46b3-bcda-be2db8c760a9.png" width="438"/></div>
</li>
<li>If we look at the application console logs, we will also see entries indicating that our Feign client is initialized and functioning. You should see something similar to this:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>2017-12-26 --- c.n.u.concurrent.ShutdownEnabledTimer : Shutdown hook installed for: NFLoadBalancer-PingTimer-BookPub-ch9</strong><br/><strong>2017-12-26 --- c.netflix.loadbalancer.BaseLoadBalancer : Client:BookPub-ch9 instantiated a LoadBalancer:DynamicServerListLoadBalancer:{NFLoadBalancer:name=BookPub-ch9,current list of Servers=[],Load balancer stats=Zone stats: {},Server stats: []}ServerList:null</strong><br/><strong>2017-12-26 --- c.n.l.DynamicServerListLoadBalancer : Using serverListUpdater PollingServerListUpdater</strong><br/><strong> 2017-12-26 --- c.netflix.config.ChainedDynamicProperty : Flipping property: BookPub-ch9.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</strong><br/><strong> 2017-12-26 --- c.n.l.DynamicServerListLoadBalancer : DynamicServerListLoadBalancer for client BookPub-ch9 initialized: DynamicServerListLoadBalancer:{NFLoadBalancer:name=BookPub-ch9,current list of Servers=[192.168.1.194:8080],Load balancer stats=Zone stats: {unknown=[Zone:unknown; Instance count:1; Active connections count: 0; Circuit breaker tripped count: 0; Active connections per server: 0.0;]</strong><br/><strong> },Server stats: [[Server:192.168.1.194:8080; Zone:UNKNOWN; Total Requests:0; Successive connection failure:0; Total blackout seconds:0; Last connection made:Wed Dec 31 18:00:00 CST 1969; First connection made: Wed Dec 31 18:00:00 CST 1969; Active Connections:0; total failure count in last (1000) msecs:0; average resp time:0.0; 90 percentile resp time:0.0; 95 percentile resp time:0.0; min resp time:0.0; max resp time:0.0; stddev resp time:0.0]</strong><br/><strong> ]}ServerList:ConsulServerList{serviceId='BookPub-ch9', tag=null}</strong></pre>
<ol start="9">
<li>One last thing that we should do is to get our tests to work with all the newly added frameworks. Because Spring Cloud does not add itself to the test life cycle, we should explicitly disable any reliance on beans created by Spring Cloud libraries during tests. To do so let's add to our <kbd><span class="CodeInTextPACKT">application.properties</span></kbd> file located under the <kbd><span class="CodeInTextPACKT">src/test/resources</span></kbd> directory from the root of the project of the following properties:</li>
</ol>
<pre style="padding-left: 60px">spring.cloud.bus.enabled=false 
spring.cloud.consul.enabled=false 
spring.cloud.consul.discovery.enabled=false 
eureka.client.enabled=false 
autoconfigure.exclude=com.example.bookpub.<br/>MonitoringConfiguration.class </pre>
<ol start="10">
<li>We also need to add a Mock dependency on <kbd><span class="CodeInTextPACKT">BookPubClient</span></kbd> into the <kbd><span class="CodeInTextPACKT">JpaAuthorRepositoryTests.java</span></kbd> and <kbd><span class="CodeInTextPACKT">WebMvcBookControllerTests.java</span></kbd> files located under the <kbd><span class="CodeInTextPACKT">src/test/java/com/example/bookpub</span></kbd> directory from the root of the project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@MockBean 
private BookPubClient client; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Similar to what we saw in the previous recipe, the use of the <kbd><span class="CodeInTextPACKT">@EnableFeignClients</span></kbd> annotation on the main application class, <kbd><span class="CodeInTextPACKT">BookPubApplication</span></kbd>, explicitly tells Spring Cloud that it should scan for all the interfaces annotated with <kbd><span class="CodeInTextPACKT">@FeignClient</span></kbd> and create service client implementations based on their definitions. The <kbd><span class="CodeInTextPACKT">@EnableFeignClients</span></kbd> annotation is similar in nature to the <kbd><span class="CodeInTextPACKT">@ComponentScan</span></kbd> one, providing attributes to control which packages to scan for the <kbd><span class="CodeInTextPACKT">@FeignClient</span></kbd> annotated classes or explicitly list the API classes that should be used.</p>
<p>Out of the box, all Feign client implementations are configured using components defined in the <kbd><span class="CodeInTextPACKT">FeignClientsConfiguration</span></kbd> class, but one can provide alternative configuration classes using the <kbd><span class="CodeInTextPACKT">defaultConfiguration</span></kbd> attribute of the <kbd><span class="CodeInTextPACKT">@EnableFeignClients</span></kbd> annotation.</p>
<p>In a nutshell, every interface definition, annotated with <kbd><span class="CodeInTextPACKT">@FeignClient</span></kbd>, gets a service implementation consisting of a Java dynamic proxy object, which handles all the interface method calls (usually using <kbd><span class="CodeInTextPACKT">FeignInvocationHandler</span></kbd> to handle all the requests). The invocation handler is responsible for doing a few things.</p>
<p>Once any method is invoked, first the service instances are located using the provided discovery client (in our case it is <kbd><span class="CodeInTextPACKT">ConsulDiscoveryClient</span></kbd>) based on the <kbd><span class="CodeInTextPACKT">name</span></kbd> attribute of the <kbd><span class="CodeInTextPACKT">@FeignClient</span></kbd> annotation. In our example, we have declared the value of <kbd><span class="CodeInTextPACKT">name</span></kbd> attribute to be <kbd><span class="CodeInTextPACKT"><span>http://BookPub-ch9</span></span></kbd>, so all the service instances from the registry which have their name set to <kbd><span class="CodeInTextPACKT">BookPub-ch9</span></kbd> will be returned as possible candidates. This name can be just a service name itself, or, as we did in our example, an optional protocol can be specified. This is a useful feature, as not all service discovery providers support ability to specify exactly how the service should be called, so if we want to make a secure call using HTTPS, we can explicitly specify the protocol to help Feign make the right call.</p>
<p>There are a number of other configuration attributes available on the annotation, for example, to tell Feign to make a direct call to a specified URL instead of doing a service lookup, there is a <kbd><span class="CodeInTextPACKT">url</span></kbd> attribute that can be configured.</p>
<div class="packt_infobox">To see a complete list of possible attributes and their use-cases, go to <span class="URLPACKT"><span><a href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-feign">https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-feign</a>.<a href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-feign"/></span></span></div>
<p>The list of instances for a given service gets wrapped with an internal load balancer, provided by another Netflix library—Ribbon. It uses a specified algorithm to rotate between the instances of a service as well as to take the bad instances out of circulation if the discovery client says they are unhealthy.</p>
<div class="packt_infobox">To see a complete list of possible configuration options for things like load balancing rules, and other settings, go to <span class="URLPACKT"><span><a href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon">https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon</a>.<a href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon"/></span></span></div>
<p>When a specific instance has been determined, an HTTP request gets created, using the standard Spring <kbd><span class="CodeInTextPACKT">HttpMessageConverter</span></kbd> beans to transform the method arguments into HTTP request path variables and query parameters. After all that is done, the request gets sent using a configured HTTP client and the response gets converted into a return type declared on the API interface using the same converters.</p>
<p>Now that we know what <kbd><span class="CodeInTextPACKT">@FeignClient</span></kbd> annotation is all about and what happens under the hood once an API-defined method gets invoked, let's take a look at how to annotate the interface methods that should be translated into remote service calls. Conveniently, and done so on purpose, we can use exactly the same annotations as we are already used to, when declaring controller mappings inside the <kbd><span class="CodeInTextPACKT">@Controller</span></kbd> annotated classes. Each method in our API interface, which we want to map to a remote service, should be annotated with the <kbd><span class="CodeInTextPACKT">@RequestMapping</span></kbd> annotation. The <kbd><span class="CodeInTextPACKT">path</span></kbd> attribute corresponds to a URL path of the remote service we want to invoke.</p>
<p>In our example, we want to call our <kbd><span class="CodeInTextPACKT">BookController.getBook(...)</span></kbd> method, which translates to the <kbd><span class="CodeInTextPACKT">/books/{isbn}</span></kbd> URL path. This is exactly what we put as a value for the <kbd><span class="CodeInTextPACKT">path</span></kbd> attribute, and make sure we also annotate the <kbd><span class="CodeInTextPACKT">isbn</span></kbd> argument in our <kbd><span class="CodeInTextPACKT">findBookByIsbn(...)</span></kbd> method with <kbd><span class="CodeInTextPACKT">@PathVariable("isbn")</span></kbd> to link it to a <kbd><span class="CodeInTextPACKT">{isbn}</span></kbd> placeholder in the mapping template.</p>
<p>As a general rule of thumb, the <kbd><span class="CodeInTextPACKT">@RequestMapping</span></kbd> annotation functions exactly the same as if it were used in a controller, except the configuration relates to an outgoing request instead of an inbound one. It might be especially confusing when configuring the <kbd><span class="CodeInTextPACKT">consumes</span></kbd> attribute of the annotation, that is, <kbd><span class="CodeInTextPACKT">consumes = "application/json"</span></kbd>, because it indicates that it is a remote side that expects JSON as a c<span class="CodeInTextPACKT">ontent-type</span> of the payload.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service discovery using Spring Cloud Netflix – Eureka</h1>
                </header>
            
            <article>
                
<p>We've already seen how to do service discovery using HashiCorp Consul and integrate it with our application. This recipe will go over an alternative, and a very popular service discovery framework from Netflix-Eureka. Eureka was developed by Netflix to help solve the problem of service discovery, health checking, and load balancing for their RESTful services in AWS.</p>
<p>Unlike Consul, Eureka is solely focused on the task of service discovery, and does not provide many additional functionalities, such as key/value store service or event delivery. It is, however, very good at what it does and should be considered a viable candidate for a service discovery solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Before we get to the steps to add Eureka to our application, we need to get the Eureka service itself up and running. Thankfully, the Spring Cloud folks have been awesome enough to provide a sample project that makes creating an instance of Eureka server and running it a breeze. Let's take a look at the following steps:</p>
<ol>
<li>To get things up and running just go to <span class="URLPACKT"><a href="https://github.com/spring-cloud-samples/eureka">https://github.com/spring-cloud-samples/eureka</a></span> and git clone the <kbd>git@github.com:spring-cloud-samples/eureka.git</kbd> repository to your machine.</li>
<li>After that's done, run <kbd><span class="CodeInTextPACKT">./gradlew clean bootRun</span></kbd> to start the server:</li>
<li>Once the server is up and running, we need to add the following dependencies to the <kbd>build.gradle</kbd> file located at the root of our project:</li>
</ol>
<pre style="padding-left: 60px">//compile("org.springframework.cloud:spring-cloud-starter-consul-all") 
compile("org.springframework.cloud:spring-cloud-starter-feign") 
compile("org.springframework.cloud:spring-cloud-starter-eureka-client") </pre>
<ol start="4">
<li><span>Ironically, that’s all we had to do, at this point, we just restart our application by executing the</span> <kbd>./gradlew clean bootRun</kbd> <span>command.</span></li>
</ol>
<div class="packt_infobox">Make sure the Eureka server is running in the background, otherwise, though the application will start, the <kbd><span class="CodeInTextPACKT">BookPubClient</span></kbd> calls will fail.</div>
<ol start="5">
<li>Once the application is up and running, let's open <kbd><span class="CodeInTextPACKT">http://localhost:8080/client/book/978-1-78528-415-1</span></kbd> in the browser and we should see exactly the same response as in our previous recipe. </li>
</ol>
<ol start="6">
<li>Just to see that our application did indeed register with Eureka, we can open the browser at the <kbd><span class="CodeInTextPACKT">http://localhost:8761</span></kbd> URL and we should see our service listed under instances list:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img height="199" src="assets/7a596791-b096-4a3a-9a67-1ed2ea7f1a73.png" width="370"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>With a seemingly effortless change, we have switched one service discovery provider, Consul, for another, Eureka. What looked like not much of a change on the outside actually did quite a bit of work under the hood. The reason we were able to do it so easily is the common set of APIs provided by the <kbd><span class="CodeInTextPACKT">spring-cloud-commons</span></kbd> and <kbd><span class="CodeInTextPACKT">spring-cloud-context</span></kbd> foundational libraries. Automated module loading support via the <kbd><span class="CodeInTextPACKT">spring.factores</span></kbd> descriptor allowed for transparent substitution in the initialization of a different service discovery provider. As long as we retained the <kbd><span class="CodeInTextPACKT">@EnableDiscoveryClient</span></kbd> annotation on our <kbd><span class="CodeInTextPACKT">BookPubApplication</span></kbd> class, Spring Cloud did the heavy lifting, taking care of loading the appropriate autoconfiguration files and setting up all the right beans to get our application working with Eureka.</p>
<p>We had to remove the Consul dependency from our classpath at the very first step of the recipe, and that had to be done in order to disambiguate the <kbd><span class="CodeInTextPACKT">DiscoveryClient</span></kbd> implementation. Without doing so, our application context would have ended up with two different implementations of the <kbd><span class="CodeInTextPACKT">DiscoveryClient</span></kbd> interface, which in itself would not be bad, except that Spring Cloud would have to disambiguate and choose one, and might not choose the one we want.</p>
<p>If we leave the <kbd><span class="CodeInTextPACKT">spring-cloud-starter-consul-all</span></kbd> dependency in our <kbd><span class="CodeInTextPACKT">build.gradle</span></kbd> file, and attempt to run the application, it will fail during startup and in the logs we will see the following entry:</p>
<pre><strong>WARN 5592 --- [  restartedMain] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jmxMBeanExporter' defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/jmx/JmxEndpointAutoConfiguration.class]: Invocation of init method failed; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.cloud.client.serviceregistry.ServiceRegistryAutoConfiguration$ServiceRegistryEndpointConfiguration': Unsatisfied dependency expressed through field 'registration'; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'org.springframework.cloud.client.serviceregistry.Registration' available: expected single matching bean but found 2: eurekaRegistration,consulRegistration </strong> </pre>
<p>As you can see from the exception, Spring autowiring can't decide which one of the service registries should be used. This is because both Eureka and Consul automatically have created an instance of <kbd>Registration</kbd>, and the autowiring wants only one.</p>
<p>Since there is a hard requirement for only having one registry, it is best not to configure multiple discovery client dependency libraries to avoid errors. If, for some reason, multiple libraries have to reside in the classpath, one should use configuration properties to explicitly enable/disable a specific client implementation. For example, both Consul and Eureka provide configuration to toggle the state. We can set <kbd>spring.cloud.consul.discovery.enabled=true</kbd> and <kbd>eureka.client.enabled=false</kbd> in <kbd><span class="CodeInTextPACKT">application.properties</span></kbd> if we prefer to use Consul to provide service discovery functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Spring Cloud Netflix – Hystrix</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter we have looked at all the aspects that apply to having a successful microservice application running in the cloud environment. We have learned about how to integrate better into a dynamically changing ecosystem, consuming remote configuration properties, registering service, and discovering and calling other services. In this recipe, we will take a look at another very important aspect of operating in a distributed, highly-volatile cloud environment circuit breakers.</p>
<p>The particular implementation of circuit breaker functionality which we are going to look at is Netflix Hystrix. It provides a very powerful and convenient way to annotate our service calls and handle things like remote service failures, queue backups, overloads, timeouts, and so on. By having circuit breakers in an application, developers can ensure overall application stability if a particular service endpoint becomes overloaded by requests, or experiences an outage of any kind.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>To get started with Hystrix we need to add the <kbd><span class="CodeInTextPACKT">spring-cloud-starter-hystrix</span></kbd> library to our project. Let's modify our <kbd><span class="CodeInTextPACKT">build.gradle</span></kbd> file located in the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
    ... 
    compile("org.springframework.cloud:<br/>     spring-cloud-starter-consul-all") 
    compile("org.springframework.cloud:<br/>     spring-cloud-starter-openfeign") 
    compile("org.springframework.cloud:<br/>     spring-cloud-starter-eureka-client") 
    compile("org.springframework.cloud:<br/>     spring-cloud-starter-netflix-hystrix") 
    runtime("com.h2database:h2") 
    runtime("mysql:mysql-connector-java") 
    ... 
} </pre>
<ol start="2">
<li>After adding the Hystrix dependency, we need to enable Hystrix for our application. Similar to how we enabled service discovery, we will do that by making a change to the <kbd><span class="CodeInTextPACKT">BookPubApplication.java</span></kbd> file located under the <kbd><span class="CodeInTextPACKT">src/main/java/com/example/bookpub</span></kbd> directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">... 
@EnableDiscoveryClient 
@EnableFeignClients 
@EnableCircuitBreaker 
public class BookPubApplication {...}</pre>
<ol start="3">
<li>Now, let's make a few changes to <kbd><span class="CodeInTextPACKT">BookController.java</span></kbd>, located under the <kbd><span class="CodeInTextPACKT">src/main/java/com/example/bookpub/controllers</span></kbd> directory from the root of our project, with the following content:</li>
</ol>
<pre style="padding-left: 60px">@RequestMapping(value = "", method = RequestMethod.GET) 
@HystrixCommand(fallbackMethod = "getEmptyBooksList") 
public Iterable&lt;Book&gt; getAllBooks() { 
    //return bookRepository.findAll(); 
    throw new RuntimeException("Books Service Not Available"); 
} 
 
public Iterable&lt;Book&gt; getEmptyBooksList() { 
    return Collections.emptyList(); 
} 
... </pre>
<ol start="4">
<li>Due to Hystrix internal functionality, we also need to modify our entity models to have them eager-load the relational associations. In the <kbd><span class="CodeInTextPACKT">Author.java</span></kbd>, <kbd><span class="CodeInTextPACKT">Book.java</span></kbd>, and <kbd><span class="CodeInTextPACKT">Publisher.java</span></kbd> files located under the <kbd><span class="CodeInTextPACKT">src/main/java/com/example/bookpub/entity</span></kbd> directory from the root of our project, let's make the following changes:</li>
</ol>
<ul>
<li style="padding-left: 60px">In <span class="CodeInTextPACKT"><kbd>Author.java</kbd>, make the following change:</span></li>
</ul>
<pre style="padding-left: 60px">@OneToMany(mappedBy = "author", fetch = FetchType.EAGER) 
private List&lt;Book&gt; books; </pre>
<ul>
<li style="padding-left: 60px">In <span class="CodeInTextPACKT"><kbd>Book.java</kbd><span>, make the following change:</span></span></li>
</ul>
<pre style="padding-left: 60px">@ManyToOne(fetch = FetchType.EAGER) 
private Author author; 
 
@ManyToOne(fetch = FetchType.EAGER) 
private Publisher publisher; 
 
@ManyToMany(fetch = FetchType.EAGER) 
private List&lt;Reviewer&gt; reviewers; </pre>
<ul>
<li style="padding-left: 60px">In <span class="CodeInTextPACKT"><kbd>Publisher.java</kbd><span>, make the following change:</span></span></li>
</ul>
<pre style="padding-left: 60px">@OneToMany(mappedBy = "publisher", fetch = FetchType.EAGER) 
private List&lt;Book&gt; books; </pre>
<ol start="5">
<li>Finally, we are ready to restart our application by executing the <kbd><span class="CodeInTextPACKT">./gradlew clean bootRun</span></kbd> command.</li>
</ol>
<ol start="6">
<li>When the application has started, let's open <kbd><span class="CodeInTextPACKT">http://localhost:8080/books</span></kbd> in the browser and we should see an empty JSON list as a result:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="211" src="assets/5fbec377-9b90-4f43-a942-f7665ff8c7bd.png" width="430"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe we have done three things after adding the Hystrix dependency library to our project. So, let's take a look at each step in detail to learn what exactly happens:</p>
<ul>
<li><span class="CodeInTextPACKT">The <kbd>@EnableCircuitBreaker</kbd></span> annotation, similar to <kbd><span class="CodeInTextPACKT">@EnableDiscoveryClient</span></kbd>, or <kbd><span class="CodeInTextPACKT">@EnableFeignClients</span></kbd>, which explicitly indicates that we want Spring Cloud to load appropriate configurations from <kbd><span class="CodeInTextPACKT">spring.factories</span></kbd> from all the libraries which have the <kbd><span class="CodeInTextPACKT">org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker</span></kbd> key defined.</li>
<li>In the case of Hystrix, it will load <kbd><span class="CodeInTextPACKT">HystrixCircuitBreakerConfiguration</span></kbd>, which provides the necessary configuration to enable the Hystrix functionality within the application. One of the beans it creates, is the <kbd><span class="CodeInTextPACKT">HystrixCommandAspect</span></kbd> class. It's purpose is to detect all the methods which are annotated with the <kbd><span class="CodeInTextPACKT">@HystrixCommand</span></kbd> annotation and wrap them with a handler to detect errors, timeouts, and other ill-behaviors, and deal with them appropriately, based on configuration.</li>
<li><span class="CodeInTextPACKT">This <kbd>@HystrixCommand</kbd></span> annotation, provided by the Hystrix library, is designed to mark methods which represent <kbd>Hystrix-guarded commands</kbd>, that is, methods which we want to protect using Hystrix against cascading failures and overloads. This annotation has a number of attributes and can be configured in a variety of different ways, depending on the desired behavior.</li>
<li>In our example we have used the most typical attribute—<kbd><span class="CodeInTextPACKT">fallbackMethod</span></kbd>, which allows us to configure an alternative method, with matching signature, which can be automatically called if the real method fails the invocation for whatever reason. This is the prime use-case, and it provides the ability to specify graceful degradation of service, using sensible defaults, if possible, instead of blowing up exceptions up the stack.</li>
<li>We used it to direct failed calls to the <kbd><span class="CodeInTextPACKT">getEmptyBooksList()</span></kbd> method, which returns a static empty list. This way, when the real <kbd><span class="CodeInTextPACKT">getAllBooks()</span></kbd> method fails, we gracefully degrade and return an empty collection, which renders nicely as a response JSON. In the situations when we do indeed desire a particular type of exception to be propagated up the stack, we can configure those explicitly using the <kbd><span class="CodeInTextPACKT">ignoreExceptions</span></kbd> attribute and set it to the desired exception classes.</li>
<li>To configure the circuit breaker behavior of a particular command, we can set a number of different options using the <kbd><span class="CodeInTextPACKT">commandProperties</span></kbd> or <kbd><span class="CodeInTextPACKT">threadPoolProperties</span></kbd> attributes. There we can set things like execution timeouts, size of backup queues, and many others.</li>
</ul>
<div class="packt_infobox">For a complete list of available properties, see <span class="URLPACKT"><span><a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration">https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration</a>.<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration"/></span></span></div>
<p>One last thing to discuss is the modifications we made to our entity models to set the relational association annotations to use <kbd><span class="CodeInTextPACKT">fetch = FetchType.EAGER</span></kbd>. The reason we had to do so is due to the way Hibernate handles association loading. By default, those are loaded using the <kbd><span class="CodeInTextPACKT">FetchType.LAZY</span></kbd> setup, meaning that Hibernate is only going to establish the relationship, but the loading of the data will not happen until the getter methods are invoked. With Hystrix, by default, this could cause an error that looks something like this:</p>
<pre style="padding-left: 30px"><strong>failed to lazily initialize a collection of role: com.example.bookpub.entity.Book.reviewers, could not initialize proxy - no Session (through reference chain: com.example.bookpub.entity.Publisher["books"]-&gt;org.hibernate.collection.internal.PersistentBag[0]-&gt;com.example.bookpub.entity.Book["reviewers"])</strong></pre>
<p>This is due to the fact that Hystrix uses <kbd>ThreadPool</kbd> to execute method calls by default, and because the lazy-loaded data needs to access the datastore at the time of invocation, Hibernate requires an active session to be present in order to handle the request. Since Hibernate stores the session in <kbd><span class="CodeInTextPACKT">ThreadLocal</span></kbd>, it is obviously not present in the pooled executor thread that Hystrix is using during the invocation.</p>
<p>Once we changed the fetching to be eager, all the data is loaded during the repository interaction in the original Hibernate thread. We could, alternatively, configure our <kbd><span class="CodeInTextPACKT">@HystrixCommand</span></kbd> annotation to use the same executing thread by using the following configuration:</p>
<pre style="padding-left: 30px">commandProperties = { 
  @HystrixProperty(name="execution.isolation.strategy", 
                   value="SEMAPHORE") 
} </pre>
<p>While Hystrix strongly recommends to use the default <kbd><span class="CodeInTextPACKT">THREAD</span></kbd> strategy, in situations when we absolutely need to be residing in the same caller thread, <kbd><span class="CodeInTextPACKT">SEMAPHORE</span></kbd> is there to help us.</p>
<p>Alternatively, we can set the same configuration in our <kbd><span class="CodeInTextPACKT">application.properties</span></kbd> file using <kbd><span class="CodeInTextPACKT">hystrix.command.default.execution.isolation.strategy=SEMAPHORE</span></kbd>, or, if we want to be specific to only configure particular <kbd><span class="CodeInTextPACKT">@HystrixCommand</span></kbd>, we can use the value of the <kbd><span class="CodeInTextPACKT">commandKey</span></kbd> attribute, which is the name of the annotated method by default, instead of the <span class="CodeInTextPACKT">default</span> section of the property name. For our specific example from the <kbd><span class="CodeInTextPACKT">BookController</span></kbd> instrumented method, the configuration key would look like <span class="CodeInTextPACKT"><span><kbd>hystrix.command.getAllBooks.execution.isolation.strategy=SEMAPHORE</kbd>.</span></span> This is possible thanks to the Spring Cloud-Netflix Archaius bridge, which makes all Spring environment properties visible to the Archaius configuration manager, thus accessible by all of the Netflix components.</p>
<p>Spring Cloud Hystrix integration also provides a <kbd><span class="CodeInTextPACKT">/hystrix.stream</span></kbd> actuator endpoint, which can be consumed by the Hystrix dashboard for visualizing the state of all the circuit breakers in an application.</p>
<p>To get the dashboard running quickly, Spring Cloud provides a sample application which can be seen at <span class="URLPACKT"><span><a href="https://github.com/spring-cloud-samples/hystrix-dashboard">https://github.com/spring-cloud-samples/hystrix-dashboard</a>:<a href="https://github.com/spring-cloud-samples/hystrix-dashboard"/></span></span></p>
<div class="CDPAlignCenter CDPAlign"><img height="274" src="assets/b47abbbb-d147-4ab5-b21d-bb38b8293a01.png" width="596"/></div>
<p>The same stream can also be fed into <strong>Netflix Turbine Stream Aggregator</strong>, downloadable at <a href="https://github.com/Netflix/Turbine"><span class="URLPACKT">https://github.com/Netflix/Turbine</span></a>, for data aggregation across multiple instances, which can later be visualized using the same dashboard.</p>
<div class="packt_tip">One can also use the <kbd><span class="CodeInTextPACKT">spring-cloud-starter-turbine</span></kbd> dependency library and the <kbd><span class="CodeInTextPACKT">@EnableTurbine</span></kbd> annotation on a basic Spring Boot application, similar to the Hystrix dashboard sample.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>