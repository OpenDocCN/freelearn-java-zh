- en: The First Real Java Program - Sorting Names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we got acquainted with Java, and especially with using
    the REPL tool and interactively executing some simple code. That is a good start,
    but we need more. In this chapter, we will develop a simple sort program. Using
    this code as an example, we will look at different build tools, which are frequently
    used for Java projects, and learn the basic features of the Java language. This
    chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The sorting problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project structure and build tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Make, Ant, Maven, and Gradle build tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java language features related to the code example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sorting problem is one of the oldest programming tasks that an engineer
    deals with. We have a set of records and we know that we want to find a specific
    one sometime later, and we want to find that one fast. To find it, we sort the
    records in a specific order that helps us find the record we want quickly.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we have the names of students with their marks on some cards.
    When students come to the office asking for their results, we look through all
    of the cards one after the other to find the name of the enquiring student. However,
    it is better if we sort the cards by the names of the students alphabetically.
    When a student makes an enquiry, we can search the mark attached to the name much
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: We can look at the middle card; if it shows the name of the student, then we
    are happy to have found the name and the mark. If the card precedes the name of
    the student alphabetically, then we will continue searching in the second half;
    otherwise, we will check the first half.
  prefs: []
  type: TYPE_NORMAL
- en: Following that approach, we can find the name of the student in a few steps.
    The number of steps can not be more than the number as many times the pack of
    cards can be halved. If we have two cards, then it is two steps at most. If it
    is four, then we will need three steps at most. If there are eight cards, then
    we may need four steps, but not more. If there are 1,000 cards, then we may need
    at most 11 steps, while the original, non-sorted set will need 1,000 steps, worst
    case. That is, approximately, it speeds up the search 100 times, so this is worth
    sorting the cards, unless the sorting itself takes too much time. The algorithm
    finding an element in the already sorted set we just described is called **binary
    search** ([https://en.wikipedia.org/wiki/Binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm)).
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, it is worth sorting the dataset, and there are many sorting algorithms
    to do that. There are simpler and more complex algorithms, and, as in many cases,
    more complex algorithms are the ones that run faster.
  prefs: []
  type: TYPE_NORMAL
- en: As we are focusing on the Java programming part and not the algorithm forging,
    in this chapter, we will develop a Java code that implements a simple and not-that-fast
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The algorithm that we will implement in this chapter is well-known as **bubble
    sort**. The approach is very simple. Begin at the start of the cards and compare
    the first and the second card. If the first card is later in lexicographic order
    than the second one, then swap the two cards. Then repeat this for the card that
    is at the second place now, then the third, and so on. There is a card that is
    lexicographically the latest, say Wilson. When we get this card and start to compare
    it with the next one, we will always swap them; this way, Wilson's card will travel
    to the last place where it has to be after the sort. All we have to do is repeat
    this travelling from the start and do the occasional swapping of cards again,
    but this time only to the last but one element. This time, the second latest element
    will get to its place—say, Wilkinson will be right before Wilson. If we have *n*
    cards, and we repeat this *n-1* times, all cards will get to their place.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will create a Java project that implements this
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with project structure and build tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a project is more complex than a single class, and it usually is, then
    it is wise to define a project structure. We will have to decide where we store
    the source files, where the resource files (those that contain some resource for
    the program, but are not Java source) are, where the `.class` files should be
    written by the compiler, and so on. Generally, the structure is mainly the directory
    setup and the configuration of the tools that perform the build.
  prefs: []
  type: TYPE_NORMAL
- en: The compilation of complex programs cannot be feasibly done using the command
    line issuing `javac` commands. If we have 100 Java source files, the compilation
    will require that many `javac` commands to be issued. It can be shortened using
    wild cards, such as `javac *.java` ,or we can write a simple bash script or a
    BAT command file that does that. First, it will be just 100 lines, each compiling
    one source Java file to class file. Then, we will realize that it is only time,
    CPU, and power consuming to compile the files that are not changed since the last
    compilations so we can add some bash programming that checks the time stamp on
    the source and generated files. Then, we will probably realize that... whatever.
    At the end, we will end up with a tool that is essentially a build tool. Build
    tools are available ready made; it is not worth reinventing the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating one, we will use a build tool that is ready. There are a
    few of them that can be found at [https://en.wikipedia.org/wiki/List_of_build_automation_software](https://en.wikipedia.org/wiki/List_of_build_automation_software).
    In this chapter, we will use one called Maven; however, before jumping into the
    details of this tool, we will look at some other tools that you are likely to
    meet as a Java professional in enterprise projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will discuss a bit of the four build tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will mention Make only briefly because it is not used in Java environments
    these days. However, Make was the first build tool, and many ideas that modern Java
    build tools are based on come from the *good old  *`make`. You, as a professional
    Java developer, should also be familiar with Make so that you will not freak out
    if you happen to see the use of it in a project for some purpose, and can know
    what it is and where its detailed documentation can be found.
  prefs: []
  type: TYPE_NORMAL
- en: Ant was the first build tool widely used for Java many years ago, and it is
    still used in many projects.
  prefs: []
  type: TYPE_NORMAL
- en: Maven is newer than Ant, and it uses a different approach. We will look at it
    in detail. Maven is also the official build tool of the Apache software foundation
    for the Java project. We will also use Maven as a build tool in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle is even newer, and it has started to catch up to Maven these days. We
    will use this tool in later chapters in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Make
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `make` program was originally created in April 1976, so this is not a new
    tool. It is included in the Unix system, so this tool is available without any
    extra installation on Linux, Mac OS X, or any other Unix-based system. Additionally,
    there are numerous ports of the tool on Windows, and some version is/was included
    in the Visual Studio compiler toolset.
  prefs: []
  type: TYPE_NORMAL
- en: The Make is not tied to Java. It was created when the major programming language
    was C, but it is not tied to C or any other language. The `make` is a dependency
    description language that has a very simple syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The `make`, just like any other build tool, is controlled by a project description
    file. In the case of make, this file contains a rule set. The description file
    is usually named `Makefile`, but in case the name of the description file is different,
    it can be specified as a command-line option to the `make` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rules in `Makefile` follow each other and consist of one or more lines. The
    first line starts at the first position (there is no tab or space at the start
    of the line) and the following lines start with a tab character. Thus, `Makefile`
    may look something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This file defines three so-called targets: `run`, `hello.jar`, and `HelloWorld.class`.
    To create `HelloWorld.class`, type the following line at the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Make will look at the rule and see that it depends on `HelloWorld.java`. If
    the `HelloWorld.class` file does not exist, or `HelloWorld.java` is newer than
    the Java class file, `make` will execute the command that is written on the next
    line and it will compile the Java source file. If the class file was created following
    the last modification of `HelloWorld.java`, then `make` knows that there is no
    need to run the command.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of creating `HelloWorld.class`, the `make` program has an easy task.
    The source file was already there. If you issue the `make hello.jar` command,
    the procedure is more complex. The `make` command sees that in order to create
    `hello.jar`, it needs `HelloWorld.class`, which itself is also a target on another
    rule. Thus, it may need to be created.
  prefs: []
  type: TYPE_NORMAL
- en: First, it starts the problem the same way as before. If `HelloWorld.class` is
    there, and is older than `hello.jar`, there is nothing to do. If it is not there,
    or is newer than `hello.jar`, then the `jar -cf hello.jar HelloWorld.class` command
    needs to be executed, although not necessarily at the moment when it realizes
    that it has to be performed. The `make` program remembers that this command has
    to be executed sometime in the future when all the commands that are needed to
    create `HelloWorld.class` are already executed successfully. Thus, it continues
    to create the class file exactly the same way as I described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, a rule can have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `make` command can create any target using the `make target` command by
    first calculating which commands to execute and then executing them one by one.
    The commands are shell commands executing in a different process and may pose
    problems under Windows, which may render the `Makefile` files' operating system
    dependent.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `run` target is not an actual file that `make` creates. A target
    can be a file name or just a name for the target. In the latter case, `make` will
    never consider the target to be readily available.
  prefs: []
  type: TYPE_NORMAL
- en: As we do not use `make` for a Java project, there is no reason to get into more
    details. Additionally, I cheated a bit by making the description of a rule simpler
    than it should be. The `make` tool has many powerful features out of the scope
    of this book. There are also several implementations that differ a little from
    each other. You will most probably meet the one made by the Free Software Foundation—the
    GNU make. And, of course, just in case of any Unix command-line tool, `man` is
    your friend. The `man make` command will display the documentation of the tool
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main points that you should remember about `make` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines the dependencies of the individual artifacts (targets) in a declarative
    way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines the actions to create the missing artifacts in an imperative way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This structure was invented decades ago and has survived up until now for most
    of the build tools, as you will see in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Ant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ant` build tool was built especially for Java projects around the year
    2000\. The aim of Java to be a *write-once-run-anywhere* language needed a tool
    that can also be used in different environments. Although `make` is available
    on Unix machines, and Windows as well, `Makefiles` were not always compatible.
    There was a small problem with the use of the tab character that some editors
    replaced with space, rendering `Makefile` unusable, but this was not the major
    reason. The main problem with `make` that ignited the development of Ant is that
    the commands are shell commands. Even if the implementation of the `make` program
    was made to be compatible on different operating systems, the used commands were
    many times incompatible, and that was something make itself could not change.
    Because `make` issues external commands to build the targets, developers are free
    to use any external tool that is available for them on the development machine.
    Another machine using the same operating system just may not have the same set
    of tools invoked by `make`. This undermines the portability of the `make` built
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, Ant is following the major principles of `make`. There are
    targets that may depend on each other and there are commands that need to be executed
    in an appropriate sequence to create the targets one after the other, following
    the dependency order. The description of the dependencies and the commands is
    XML (tab issue solved) and the commands are implemented in Java (system dependency
    is solved, well... more or less).
  prefs: []
  type: TYPE_NORMAL
- en: As Ant is neither part of the operating system nor the JDK, you will have to
    download and install it separately if you want to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ant can be downloaded from its official website ([http://ant.apache.org](http://ant.apache.org)).
    You can download the source or the precompiled version. The easiest way is to
    download the binary in a `tar.gz` format.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you download software from the Internet, it is highly recommended that
    you check the integrity of the downloaded file. The HTTP protocol does not contain
    error checking, and it may happen that a network error remains hidden or a malevolent
    internal proxy modifies the downloaded file. Download sites usually provide checksums
    for the downloadable files. These are usually MD5, SHA1, SHA512, or some other
    checksums.
  prefs: []
  type: TYPE_NORMAL
- en: When I downloaded the Apache Ant 1.9.7 version in `tar.gz` format, I also opened
    the page that led to the MD5 checksum. The checksum value is `bc1d9e5fe73eee5c50b26ed411fb0119`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The downloaded file can be checked using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ md5 apache-ant-1.9.7-bin.tar.gz`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MD5 (apache-ant-1.9.7-bin.tar.gz) = bc1d9e5fe73eee5c50b26ed411fb0119`'
  prefs: []
  type: TYPE_NORMAL
- en: The calculated MD5 checksum is the same as the one on the website, which says
    that the file integrity is not harmed.
  prefs: []
  type: TYPE_NORMAL
- en: On the Windows operating system, no tool to calculate MD5 digest is included.
    There is a tool that Microsoft provides, called **File Integrity Checksum Verifier
    Utility**, which is available via the page [https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility](https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility).
    If you use Linux, it may happen that the `md5` or `md5sum` utility is not installed.
    In that case, you can install it using the command `apt-get` or whatever installation
    tool your Linux distribution supports.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the file is downloaded, you can explode it to a subdirectory using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The created subdirectory is the usable binary distribution of Ant. Usually,
    I move it under `~/bin`, making it available only for my user on OS X. After that,
    you should set the environment variable as `ANT_HOME` to point to this directory
    and also add the `bin` directory of the installation to the `PATH`. To do that,
    you should edit the `~/.bashrc` file and add the following lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, restart the terminal application, or just type `. ~/.bashrc` and test
    the installation of Ant by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the installation was correct, you should see the preceding error message.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you see a project to be built by Ant, you will see a `build.xml` file.
    This is the project build file, the one that Ant was missing when you checked
    that the installation was correct. It can have any other name, and you can specify
    the name of the file as a command-line option for Ant, but this is the default
    file name, as `Makefile` was for `make`. A `build.xml` sample looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-level XML tag is `project`. Each build file describes one project,
    hence the name. There are three possible attributes to the tag, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This defines the name of the project and is used by some IDEs to display
    it in the left panel identifying the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: This names the target to use when no target is defined on the command
    line starting Ant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`basedir`: This defines the initial directory used for any other directory
    name calculation in the build file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build file can contain a description for the project, as well as properties
    in property tags. These properties can be used as variables in the attributes
    of the tasks between the `${` and `}` characters, and play an important role in
    the build process.
  prefs: []
  type: TYPE_NORMAL
- en: The targets are defined in target XML tags. Each tag should have a name that
    uniquely identifies the target in the build file and may have a `depends` tag
    that specifies one or more other targets that this target depends on. In case
    there is more than one target, the targets are comma separated in the attribute.
    The tasks belonging to the targets are executed in the same order as the targets
    dependency chain requires, in a very similar way as we saw in the case of `make`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also add a `description` attribute to a target that is printed by Ant
    when the command-line option, `-projecthelp`, is used. This helps the users of
    the build file to know what targets are there and which does what. Build files
    tend to grow large with many targets, and when you have ten or more targets, it
    is hard to remember each and every target.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample project with `HelloWorld.java` is now arranged in the following
    directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build.xml` in the `root` folder of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld.java` in the `src` folder of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `build/` folder does not exist; it will be created during the build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `build/classes` and `build/jar` also do not exist yet, and will be created
    during the build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you start the build for the `HelloWorld` project the first time, you will
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Some unimportant lines are deleted from the actual output.
  prefs: []
  type: TYPE_NORMAL
- en: Ant realizes that first it has to create the directories, then it has to compile
    the source code, and finally it can pack the `.class` files into a `.jar` file.
    Now it is up to you to remember the command to execute the `HelloWorld` application.
    It was listed already in the first chapter. Note that this time, the JAR file
    is named `HelloWorld.jar`, and it is not in the current directory. You can also
    try to read the online documentation of Ant and create a target `run` that executes
    the compiled and packed program.
  prefs: []
  type: TYPE_NORMAL
- en: Ant has a built-in task named `java` that executes a Java class in almost the
    same way as you typed the `java` command in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Ant was created to overcome the shortages of `make`, Maven was created with
    a similar intention—to overcome the shortages of Ant. You may recall that make
    could not guarantee build portability because the commands `make` executes are
    arbitrary shell commands that may be system specific. An Ant build, if all the
    tasks are available on the classpath, is portable as long as Java runs the same
    way on the different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with Ant is a bit different. When you download the source code of
    a project and you want to build, what will the command be? You should ask Ant
    to list all the targets and select the one that seems to be the most suitable.
    The name of the task depends on the engineer who crafted the `build.xml` file.
    There are some conventions, but they are not strict rules.
  prefs: []
  type: TYPE_NORMAL
- en: Where will you find the Java source files? Are they in the `src` directory or
    not? Will there also be some Groovy or other programming language files in case
    the project is polyglot? That depends. Again, there may be some conventions that
    some groups or company cultures suggest, but there is no general best industry
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: When you start a new project with Ant, you will have to create the targets for
    compilation, test execution, and packaging. It is something that you will have
    already done for other projects. After the second or third project, you will just
    copy and paste your previous `build.xml` to your new project. Is that a problem?
    Yes, it is. It is copy/paste programming, even if it is *only* some build files.
  prefs: []
  type: TYPE_NORMAL
- en: Developers realized that a significant effort of the projects utilizing Ant
    is devoted to project build tool configuration, including repetitive tasks. When
    a new joiner comes to the team, they will first have to learn how the build is
    configured. If a new project is started, the build configuration has to be created.
    If it is a repetitive task, then better let the computers do it. That is generally
    what programming is all about, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Maven approaches the build issue a bit differently. We want to build Java projects.
    Sometimes, some *Groovy* or *Jython* things, but they are also *JVM* languages;
    thus, saying that we want to build Java projects is not really a huge restriction.
    Java projects contain Java files, sometimes some other programming language's
    source files, resource files, and generally, that is it. *Ant* can do anything,
    but we do not want to do just anything with a build tool. We want to build projects.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, after we restricted ourselves and accepted that we do not need a build
    tool that can be used for anything, we can go on. We can require that the source
    files be under the `src` directory. There are files that are needed for the operational
    code and there are files that contain some test code and data. Therefore, we will
    have two directories, `src/test` and `src/main`. Java files are in `src/main/java`
    as well as `src/test/java`. Resource files are under `src/main/resources` and
    `src/test/resources`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to put your source files somewhere else, then don't. I mean it.
    It is possible, but I will not even tell you how. Nobody does it. I do not even
    have any idea why Maven makes it possible. Whenever you see a project that is
    using Maven as a build tool, the sources are organized like that. There is no
    need to understand the directory structure envisioned by the project's build engineer.
    It is always the same.
  prefs: []
  type: TYPE_NORMAL
- en: How about the targets and the tasks? They are also the same for all Maven-based
    projects. What else would you like to do with a Java project other than compile,
    test, package, or deploy it? Maven defines these project life cycles for us. When
    you want to compile a project using Maven as a build tool, you will have to type
    `$ mvn compile` to compile the project. You can do that even before understanding
    what the project actually is.
  prefs: []
  type: TYPE_NORMAL
- en: As we have the same directory structure and the same goals, the actual tasks
    leading to the goals are also all the same. When we create a Maven project, we
    do not have to describe what the build process has to do and how it has to do
    it. We will have to describe the project, and only the parts that are project
    specific.
  prefs: []
  type: TYPE_NORMAL
- en: The build configuration of a Maven project is given in an XML file. The name
    of this file is usually `pom.xml`, and it should be in the `root` directory of
    the project, which should be the current working directory when firing up Maven.
    The word **POM** stands for **Project Object Model**, and it describes the projects
    in a hierarchical way. The source directories, the packaging, and other things
    are defined in a so-called super POM. This POM is part of the Maven program. Anything
    that the POM defines, overrides the defaults defined in the super POM. When there
    is a project with multiple modules, the POMs are arranged into a hierarchy, and
    they inherit the configuration values from the parent down to the modules. As
    we will use Maven to develop our sorting code, we will see some more details later.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maven is neither a part of the operating system nor the JDK. It has to be downloaded
    and installed in a very similar way to Ant. You can download Maven from its official
    website ([https://maven.apache.org/](https://maven.apache.org/)) under the download
    section. Currently, the latest stable version is 3.3.9\. When you download it,
    the actual release may be different; instead, use the latest stable version. You
    can download the source or the precompiled version. The easiest way is to download
    the binary in `tar.gz` format.
  prefs: []
  type: TYPE_NORMAL
- en: I cannot skip drawing your attention to the importance of checking the download
    integrity using checksums. I have detailed the way to do it in the section about
    Ant installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the file is downloaded, you can explode it to a subdirectory using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The created subdirectory is the usable binary distribution of Maven. Usually,
    I move it under `~/bin`, making it available only for my user on OS X. After that,
    you should add the `bin` directory of the installation to the `PATH`. To do that,
    you should edit the `~/.bashrc` file and add the following lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, restart the terminal application, or just type `. ~/.bashrc` and test
    the installation of Maven typing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You should see a similar message on the screen that displays the installed Maven
    version and other information.
  prefs: []
  type: TYPE_NORMAL
- en: Using Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike Ant, Maven helps you create the skeleton of a new project. To do that,
    you will have to type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Maven will first download the actually available project types from the network
    and prompt you to select the one you want to use. This approach seemed to be a
    good idea while Maven was new. When I first started Maven, the number of listed
    projects was somewhere between 10 and 20\. Today, as I write this book, it lists
    1,635 different archetypes. This number seems more like a historical date (the
    constitution of the French Academy of Science) than a usable size list of different
    archetypes. However, do not freak out. Maven offers a default value when it asks
    for your choice, and it is good for the `HelloWorld` we go for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual number may be different on your installation. Whatever it is, accept
    the suggestion and press *Enter*. After that, Maven will ask you for the version
    of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Select the `1.0` version that is listed as number `5`. The next thing Maven
    asks for is the group ID and the artifact ID of the project. The dependency management
    that we will discuss later uses these. I selected a group ID based on the book
    and the publisher. The artifact of the project is `SortTutorial` as we will start
    our chapter example in this project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The next question is the current version of the project. We have already selected
    `1.0` and Maven offers `1.0-SNAPSHOT`. Here, I selected `1.0.0-SNAPSHOT` because
    I prefer semantic versioning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Semantic versioning, defined on [http://semver.org/](http://semver.org/), is
    a versioning scheme that suggests three digit version numbers as *M.m.p.* for
    *Major*, *minor*, and *patch* version numbers. This is very useful for libraries.
    You will increment the last version number if there is only a bug fix since the
    previous release. You will increment the minor number when the new release also
    contains new features, but the library is compatible with the previous version;
    in other words, any program that is using the older version can still use the
    newer version. The major release number is increased when the new version is significantly
    different from the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of application programs, there is no code that uses the application
    API; thus, the minor version number is not that important. It does not hurt, though,
    and it often proves to be useful to signal smaller changes in the application.
    We will discuss how to version software in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Maven handles the versions that have the `-SNAPSHOT` postfix as non-release
    versions. While we develop the code, we will have many *versions* of our code,
    all having the same snapshot version number. On the other hand, non-snapshot version
    numbers can only be used only for a single version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The last question from the program skeleton generation is the name of the Java
    package. The default is the value we gave for `groupId`, and we will use this.
    It is a rare exception to use something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have specified all the parameters that are needed, the final request
    is to confirm the setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After entering `Y`, Maven will generate the files that are needed for the project
    and display the report about this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can take look at the following generated directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also see that it generated the following three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SortTutorial/pom.xml` that contains the **Project Object Model**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortTutorial/``src/main/java/packt/java9/by/example/App.java` that contains
    a `HelloWorld` sample application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortTutorial/src/test/java/packt/java9/by/example/AppTest.java` that contains
    a unit test skeleton utilizing the `junit4` library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will discuss unit tests in the next chapter. For now, we will focus on the
    sorting application. As Maven was so kind and generated a sample class for the
    app, we can compile and run it without actual coding, just to see how we can build
    the project using Maven. Change the default directory to `SortTutorial` issuing
    `cd SortTutorial` and issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Maven fires up, compiles, and packages the project automatically. If not, please
    read the next info box.
  prefs: []
  type: TYPE_NORMAL
- en: When you first start Maven, it downloads a lot of dependencies from the central
    repository. These downloads take time, and are reported on the screen, so the
    actual output may be different from what you saw in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maven compiles code with the default settings for Java version 1.5\. It means
    that the generated class file is compatible with Java version 1.5, and also that
    the compiler only accepts language constructs that were available already in Java
    1.5\. If we want to use newer language features, and in this book we use a lot,
    the `pom.xml` file should be edited to contain the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<build>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    <plugins>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`      <plugin>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`        <groupId>org.apache.maven.plugins</groupId>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`        <artifactId>maven-compiler-plugin</artifactId>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`        <configuration>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`          <source>1.9</source>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`          <target>1.9</target>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`        </configuration>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`      </plugin>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    </plugins>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  </build>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Java 9''s default settings for Maven, it becomes even more complex,
    because Java 9 does not generate class format nor restrict source compatibility
    earlier than Java 1.6\. At this very moment, as I write these lines, the latest
    Maven release is 3.3.9\. When I try to compile the preceding code without the
    modifications, the Java compiler stops with an error displaying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ERROR] Source option 1.5 is no longer supported. Use 1.6 or later.`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`[ERROR] Target option 1.5 is no longer supported. Use 1.6 or later.`**'
  prefs: []
  type: TYPE_NORMAL
- en: Later, Maven releases may behave differently in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can start the code using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the result of a sample run in the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ant and Maven are two worlds, and using one or the other may lead to heated
    debates on Internet forums. Ant gives freedom to developers to create a build
    process that fits their taste. Maven restricts the team to use a build process
    that is more standard. Some special processes that do not match any standard build,
    but which are sometimes needed in some environments, are hard to implement using
    Maven. In Ant, you can script almost anything using the built-in tasks, almost
    the same way as you can program bash. Utilizing Maven is not that simple, and,
    it often requires writing a plugin. Even though writing a plugin is not rocket
    science, developers usually like to have the possibility of making things in a
    simpler way: Scripting. We have two approaches, two mindsets and styles, and not
    a single tool to fulfill all the needs. No surprise that by the Java technologies
    were developed, a new build tool was emerging.'
  prefs: []
  type: TYPE_NORMAL
- en: Gradle tries to use the best of both worlds, utilizing techniques that were
    not available by the time Maven and Ant were first developed.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle has built-in targets and life cycle, but at the same time, you can also
    write your own targets. You can configure a project, just like using Maven, without
    scripting the tasks to do so, but at the same time, you can also script your own
    target just like in Ant. What is more, Gradle integrated Ant, so any task implemented
    for Ant is available for Gradle as well.
  prefs: []
  type: TYPE_NORMAL
- en: Maven and Ant use XML files to describe the build. Today, XML is a technology
    of the past. We still use it, and a developer should be fluent in handling, reading,
    and writing XML files, but a *modern* tool does not use XML for configuration.
    New, fancy formats such as JSON are more popular. Gradle is no exception. The
    configuration file of Gradle uses a **domain-specific language** (**DSL**) based
    on Groovy. This language is more readable for programmers and gives more freedom
    to program build processes. And, this is also the danger of Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Having the powerful JVM language Groovy in the hands of developers to create
    build tools gives a freedom and temptation to create complex build processes that
    seem to be a good idea at the start, but later may prove to be just too complex
    and hard, and, therefore, expensive to maintain. This is exactly why Maven was
    implemented in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: I have to stop before getting into another area that is the ground for heated
    and pointless debates. Gradle is an extremely powerful build tool. You should
    use it carefully, just like you would use a weapon—don't shoot your legs.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install Gradle, you will have to download the compiled binaries from the
    [https://gradle.org/gradle-download/](https://gradle.org/gradle-download/) website.
  prefs: []
  type: TYPE_NORMAL
- en: Again, I'd like to emphasize the importance of checking the download integrity
    using checksums. I have given a detailed way to do it in the section about Ant
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the Gradle website does not provide the checksum values for the
    downloadable files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle is downloadable in the ZIP format. To unpack the file, you will have
    to use the unzip command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The created subdirectory is the usable binary distribution of Gradle. Usually,
    I move it under `~/bin`, making it available only for my user on OS X. After that,
    you should add the `bin` directory of the installation to the `PATH`. To do that,
    you should edit the `~/.bashrc` file and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, restart the terminal application, or just type `. ~/.bashrc` and test
    the installation of Gradle, typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We get to the following output, as can be seen in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the project with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start the project, we will use the directory structure and `pom.xml` that
    was created by Maven itself when we started with the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It created the directories, the `pom.xml` file, and an `App.java` file. Now,
    we will extend this project by creating new files. We will code the sorting algorithm
    first in the `packt.java9.by.example.stringsort` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we create the new package in the IDE, the editor will automatically create
    the `stringsort` subdirectory under the already existing `src/main/java/packt/java9/by/example`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the new `Sort` class using the IDE will also automatically create
    a new file named `Sort.java` in this directory, and it will fill in the skeleton
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now have `App.java` containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Maven created it as a starting version. We will edit this file to provide a
    sample list that the sorting algorithm can sort. I recommend that you use the
    IDE to edit the file and also to compile and run the code. The IDE provides a
    shortcut menu to start the code and this is a bit easier than typing the command
    in Terminal. Generally, it is recommended that you get acquainted with the IDE
    features to save time avoiding repetitive tasks, such as typing terminal commands.
    Professional developers use the command line almost exclusively to test command-line
    features and use the IDE whenever it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Coding the sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maven and the IDE created the files for the sort program. They form the skeleton
    for our code, and now it is time to grow some muscles on them to let it move.
    We spent quite some time to set up the project by visiting the different build
    tools, only to learn how to compile the code. I hope that this did not distract
    you much, but anyhow, we deserve to see some real code.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create the code for the sorting code, and after that, the code
    that invokes the sorting. The code that invokes the sorting is a kind of testing
    code. For simplicity, we will now simply use a `public static void main` method
    to start the code. We will use the test framework in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for now, the code for the sorting will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is the class that does the sorting. There is only one method in this class
    that does the sorting. The argument to the method is an array containing the strings,
    and the method sorts this array. The method has no return value. This is denoted
    in the declaration using the pseudo type `void`. Methods use their arguments to
    perform some tasks, and may return one value. The arguments to the method are
    passed by value, which means that the method cannot modify the variable passed
    as argument. However, it can modify the objects the arguments contain. In this
    case, the array is modified and we will sort it. On the other hand, the `actualNames`
    variable will point to the same array and the `sort` method cannot do anything
    to make this variable point to a different array.
  prefs: []
  type: TYPE_NORMAL
- en: There is no `main` method in this class, which means that it cannot be started
    from the command line on its own. This class can only be used from some other
    class, as every Java program should have a class that has a `public static void
    main` method that we created separately.
  prefs: []
  type: TYPE_NORMAL
- en: I could also put a `main` method into the class to make it executable, but that
    is not a good practice. Real programs are composed of many classes, and one class
    should not do many things. Rather, it's the opposite. The s*ingle responsibility
    principle* says that a single class should be responsible for one single thing;
    therefore, `class sort` does the sorting. Executing the application is a different
    task, and thus it has to be implemented in a different class.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we do not implement the class containing the `main` method. Often, a
    framework provides it. For example, writing a *servlet* that runs in a servlet
    container requires containing a class that implements the `javax.servlet.Servlet`
    interface. In this case, the program seemingly does not have a `main` method.
    The actual implementation of the servlet container does. The Java command line
    starts the container and the container loads the servlets when they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example code, we implemented the `App` class containing the
    `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This code contains a string array initialized to contain constant values, creates
    a new instance of the `Sort` class, invokes the `sort` method, and then prints
    out the code to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: In real programs, we almost never have such constants in program codes; we put
    them into resource files and have some code to read the actual values. This separates
    the code from data and eases maintenance, eliminating the risk of accidental modification
    of code structure when only the data is to be changed. Similarly, we will almost
    never write anything to standard output using `System.out`. Usually, we will use
    logging possibilities that are available from different sources. There are different
    libraries that provide logging functionalities and logging is also available from
    the JDK itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for now, we will focus on simple solutions so as to not distract your focus
    from Java by the plethora of different libraries and tools. In the following section,
    we will look at the Java language constructs that we used to code the algorithm.
    First, we will look at them generally, and then, in a bit more detail. These language
    features are not independent of each other: one builds up on the other, and therefore,
    the explanation will first be general, and we will go into details in the subsections.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the algorithm and language constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The algorithm was explained at the start of the chapter. The implementation
    is in the `Sort` class inside the `sort` method, and it is only a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `n` variable holds the length of the array at the start of the sorting.
    Arrays in Java always have a property that gives the length and it is called `length`.
    When we start the sorting, we will go from the start of the array to the end of
    it and, as you may recall, the last element, *Wilson*, will walk up to the last
    position during this first iteration. Subsequent iterations will be shorter and,
    therefore, the variable `n` will be decreased.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in Java is created in code blocks. Anything that is between the `{`
    and `}` characters is a block. In the preceding example, the code of the method
    is a block. It contains commands, and some of them, like the `while` loop, also
    contain a block. Inside that block, there are two commands. One of them is a `for`
    loop, again with a block. Although we can have single expressions to form the
    body of a loop, we usually use blocks. We will discuss loops in detail in just
    a few pages.
  prefs: []
  type: TYPE_NORMAL
- en: As we could see in the preceding example, the loops can be nested, and thus
    the `{` and `}` characters form pairs. A block can be inside another block, but
    two blocks cannot overlap. When the code contains a `}` character, it is closing
    the block that was opened last.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, just like in almost any programming language, we use variables. The
    variables in Java are typed. It means that a variable can hold a value of a single
    type. It is not possible for a variable to hold an `int` type at some point in
    the program and later a `String` type. When variables are declared, their type
    is written in front of the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Variables also have visibility scope. Local variables in methods can only be
    used inside the block in which they are defined. A variable can be used inside
    methods or they can belong to a class or an object. To differentiate the two,
    we usually call these variables *fields*.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each variable has one type. In Java, there are two major groups of type: primitive
    and reference types. The primitive types are predefined, and you cannot define
    or create a new primitive type. There are eight primitive types: `byte`, `short`,
    `int`, `long`, `float`, `double`, `boolean`, and `char`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first four types, `byte`, `short`, `int`, and `long`, are signed numeric
    integer types, capable of storing positive and negative numbers on 8, 16, 32,
    and 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: The `float` and `double` types store floating point numbers on 32 and 64 bits
    in the IEEE 754 floating-point format.
  prefs: []
  type: TYPE_NORMAL
- en: The `boolean` type is a primitive type that can only be `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The `char` type is a character data type that stores a single 16-bit Unicode
    character.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each primitive type, there is a class that can store the same type of value.
    When a primitive type has to be converted to the matching class type it is done
    automatically. It is called auto boxing. These types are `Byte`, `Short`, `Integer`,
    `Long`, `Float`, `Double`, `Boolean`, and `Character`. Take, for example, the
    following variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This converts the value `113`, which is an `int` number, to an `Integer` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'These types are part of the runtime, and also part of the language. Although
    there is no primitive counterpart of it, there is a very important and ubiquitous
    class that we have already used: `String`. A string contains characters.'
  prefs: []
  type: TYPE_NORMAL
- en: The major differences between primitive types and objects are that primitive
    types cannot be used to invoke methods, but they consume less memory. The difference
    between the memory consumption and its consequences for speed is important in
    the case of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables can be a primitive type according to their declaration, or they may
    hold a reference to an object. A special object type is an array. When a variable
    holds a reference to an array, then it can be indexed with the `[` and `]` characters,
    along with an integral value consisting of 0 or a positive value ranging to one
    less than the array's length, to access a certain element of the array. Multi-dimensional
    arrays are also supported by Java when an array has elements that are also arrays.
    Arrays are indexed from zero in Java. Under or over indexing is checked at runtime,
    and the result is an exception.
  prefs: []
  type: TYPE_NORMAL
- en: An exception is special condition that interrupts the normal execution flow
    and stops the execution of the code or jumps to the closest enclosing `catch`
    statement. We will discuss exceptions and how to handle them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When a code has an array of a primitive type, the array contains many memory
    slots, each holding the value of the type. When the array has a reference type,
    in other words, when it is an array of objects, then the array elements are references
    to objects, each containing the type. In the case of `int` for example, each element
    of the array is 32-bit, which is 4 bytes. If the array is a type of `Integer`,
    then the elements are references to objects, pointers, so to say, which is usually
    64-bit using 64-bit JVM and 32-bit on 32-bit JVM. In addition to that, there is
    an `Integer` object somewhere in memory that contains the 4-byte value and also
    an object header that may be as much as 24 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The actual size of the extra information needed to administer each object is
    not defined in the standard. It may be different on different implementations
    of the JVM. The actual coding, or even the optimization of the code in an environment,
    should not depend on the actual size. However, the developers should be aware
    that this overhead exists and is in the range of around 20 or so bytes for every
    object. Objects are expensive in terms of memory consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Memory consumption is one issue, but there is something else. When the program
    works with a large amount of data and the work needs the consecutive elements
    of the array, then the CPU loads a chunk of memory into the processor cache. It
    means that the CPU can access elements of the array that are consecutively faster.
    If the array is of a primitive type, it is fast. If the array is of some class
    type, then the CPU has to access memory to get the actual value, which may be
    as much as 50 times slower.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expressions in Java are very much like in other programming languages. You
    can use the operators that may be similar from languages such as C or C++. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unary prefix and postfix increment operators (` --` and `++` before and after
    a variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unary sign (`+` and `-`) operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical (`!`) and bitwise (`~`) negation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication (`*`), division (`/`), and modulo (`%`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addition and subtraction (`+` and - again, but this time as binary operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shift operators move the values bitwise, and there is left (`<<`) and right
    (`>>`) shift and unsigned right shift (`>>>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comparing operators are `<`, `>`, `<=`, `>=`, `==`, `!=` and `instanceof`
    that result in `boolean` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are bitwise or (`|`), and (`&`), exclusive or (`^`) operators, and similarly
    logical or (`||`), and (`&&`) operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When logical operators are evaluated, they are shortcut evaluated. It means
    the right-hand operand is evaluated only if the result cannot be identified from
    the result of the left operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ternary operator is also similar to the one, like it is on C, selecting
    from one of the expressions based on some condition: `condition ? expression 1
    : expression 2`. Usually, there is no problem with the ternary operator, but sometimes
    you have to be careful as there is a complex rule controlling the type conversions
    in case the two expressions are not of the same type. It''s always better to have
    the two expressions be of the same type.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is an assignment operator (`=`) that assigns the value of an
    expression to a variable. For each binary operator, there is an assignment version
    that combines `=` with a binary operator to perform an operation involving the
    right operand and assign the result to the left operand, which must be a variable.
    These are `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `^=`, `|=`, `<<=`, `>>=`, and `>>>=`.
  prefs: []
  type: TYPE_NORMAL
- en: The operators have precedence and can be overridden by parentheses, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important part of expressions is invoking methods. Static methods can be
    invoked by the name of the class and the name of the method. For example, to calculate
    the sine of 1.22, we can write the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Math` is the class from the package `java.lang`. The method `sin` is
    invoked without using any instance of `Math`. This method is `static`, and it
    is not likely that we will ever need any other implementation of it than the one
    provided in the class `Math`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-static methods can be invoked using an instance and the name of the method
    with a dot separating the two. For example, take the following code line as an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses an instance of the class `PrintStream` that is readily
    available through a static field in the class `System`. This variable is called
    `out`, and when we write our code, we have to reference it as `System.out`. The
    method `println` is defined in the class `PrintStream` and we invoke it on the
    object referenced by the variable `out`. This example also shows that static fields
    can also be referenced through the name of the class and the field separated by
    a dot. Similarly, when we need to reference a non-static field, we can do it through
    an instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods defined in the same class from where it is invoked or inherited
    can be invoked without the class name. Invoking a non-static method defined in
    the same class or being inherited can be invoked without an instance. In this
    case, the instance is the current object the execution is in. This object is also
    available through the `this` keyword. Similarly, when we use a field of the same
    class where our code is, we simply use the name. In case of a static field, the
    class we are in by default. In the case of a non-static field, the instance is
    the object referenced by the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: You can also import a static method into your code using the `import``static`
    language feature, in which case you can invoke the method without the name of
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments of the method calls are separated using commas. Methods and method
    argument passing is an important topic that we will mention in detail in a separate
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop inside the `while` loop will go through all the elements from
    the first (indexed with zero in Java) up till the last (indexed with `n-1`). Generally,
    the `for` loop has the same syntax as in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, the initial expression is evaluated. It may contain variable declaration,
    as in our example. The variable `j` in the preceding example is visible only inside
    the block of the loop. After this, the condition is evaluated, and after each
    execution of the block, the increment expression is executed. The loop repeats
    so long as the condition is true. If the condition is false right after the execution
    of the initial expression, the loop does not execute at all. The block is a list
    of commands separated by semicolons and enclosed between the `{` and `}` characters.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `{` and `}`, enclosed block Java lets you use a single command following
    the head of the `for` loop. The same is true in the case of the `while` loop,
    and also for the `if...else` constructs. Practice shows that this is not something
    a professional should use. Professional code always uses curly braces, even when
    there is only a single command where the block is in place. This prevents the
    dangling `else` problem and generally makes the code more readable. This is similar
    to many C-like languages. Most of them allow a single command at these places,
    and professional programmers avoid using a single command in these languages for
    readability purposes.
  prefs: []
  type: TYPE_NORMAL
- en: It is ironic that the only language that strictly requires the use of the `{`
    and `}` braces at these places is Perl—the one language infamous for unreadable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop in the `for (int j = 0; j < n - 1; j++) {` sample starts from zero
    and goes to `n-2`. Writing `j < n-1` is the same, in this case, as `j <= n-2`.
    We will limit `j` to stop in the loop before the end of the section of the array,
    because we reach beyond the index `j` by one comparing and conditionally swapping
    the elements indexed by `j` and `j+1`. If we went one element further, we would
    try to access an element of the array that does not exist, and it would cause
    a runtime exception. Try and modify the loop condition to `j < n` or `j <= n-1`
    and you will get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is an important feature of Java that the runtime checks memory access and
    throws an exception in the case of bad array indexing. In the good old days, while
    coding in C, often, we faced unexplainable errors that stopped our code much later
    and at totally different code locations from where the real error was. Array index
    in C silently corrupted the memory. Java stops you as soon as you make a mistake.
    It follows the *fail-fast* approach that you also should use in your code. If
    something is wrong, the program should fail. No code should try to live with or
    overcome an error that comes from a coding error. Coding errors should be fixed
    before they cause even more damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also two more loop constructs in Java: the `while` loop and the `do`
    loop. The example contains a `while` loop: it is the outer loop that runs so long
    as there are at least two elements that may need swapping in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The general syntax and semantics of the `while` loop is very simple, as seen
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the execution of the block so long as the condition is true. If the
    condition is not true at the very start of the loop, then do not execute the block
    at all. The `do` loop is also similar, but it checks the condition *after* each
    execution of the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For some reason, programmers rarely use `do` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of the sort is the condition and the value swapping inside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one conditional command in Java, the `if` command. It has the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The meaning of the code structure is quite straightforward. If the condition
    is true, then the first block is executed, otherwise, the second block is executed.
    The `else` keyword, along with the second block, is optional. If there is nothing
    to be executed in case that the condition is false, then there is no need for
    the else branch, just like in the example. If the array element indexed with `j`
    is later in the sort order than the element `j+1,` then we swap them, but if they
    are already in order, there is nothing to do with them.
  prefs: []
  type: TYPE_NORMAL
- en: To swap the two array elements, we will use a temporary variable named `tmp`.
    The type of this variable is `String`, and this variable is declared to be `final`.
    The `final` keyword has different meanings depending on where it is used in Java.
    This may be confusing for beginners unless you are warned about it, just like
    now. A `final` class or method is a totally different thing than a `final` field,
    which is again different than a `final` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Final variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our case, `tmp` is a `final` local variable. The scope of this variable is
    limited to the block following the `if` statement, and inside this block, this
    variable gets a value only once. The block is executed many times during the code
    execution, and each time the variable gets into scope, it gets a value. However,
    this value cannot be changed in the block. This may be a bit confusing. You can
    think about it as having a new `tmp` each time the block executes. The variable
    gets declared and has an undefined value and can get a value only once.
  prefs: []
  type: TYPE_NORMAL
- en: Final local variables do not need to get the value where they are declared.
    You can assign a value to a `final` variable some time later. It is important
    that there should not be a code execution that assigns a value to a `final` variable
    that was already assigned a value before. The compiler checks it and does not
    compile the code if there is a possibility of the reassignment of a `final` variable.
  prefs: []
  type: TYPE_NORMAL
- en: To declare a variable to be final is generally to ease readability of the code.
    When you see a variable in a code declared to be `final`, you can assume that
    the value of the variable will not change and the meaning of the variable will
    always be the same wherever it was used in the method. It will also help you avoid
    some bugs when you try to modify some `final` variables and the IDE will immediately
    complain about it. In such situations, it is likely to be a programming mistake
    that is discovered extremely early.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, it is possible to write a program where all variables are `final`.
    It is generally a good practice to declare all `final` variables that can be declared
    to be `final` and, in case some variable may not be declared `final`, then try
    to find some way of coding the method a bit differently.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to introduce a new variable to do that, it probably means you were
    using one variable to store two different things. These things are of the same
    type and stored in the same variable at different times but, logically, they still
    are different things. Do not try to optimize the use of variables. Never use a
    variable because you already have a variable of the type in your code that is
    available. If it is logically a different thing, then declare a new variable.
  prefs: []
  type: TYPE_NORMAL
- en: While coding, always prefer source code clarity and readability. In Java, especially,
    the Just In Time compiler will optimize all this for you.
  prefs: []
  type: TYPE_NORMAL
- en: Although we do not explicitly tend to use the `final` keyword on the argument
    list of a method, it is good practice to make sure that your methods compile and
    work if the arguments are declared `final`. Some experts, including me, believe
    that the method parameters should have been made final by default in the language.
    This is something that will not happen in any version of Java, so long as Java
    follows the backward compatibility philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have looked at the actual code lines and have understood how the
    algorithm works, let''s look at the more global structures of the code that brings it
    together: classes and packages enclosing the methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Every file in a Java program defines a class. Any code in a Java program is
    inside a class. There is nothing like global variables or global functions as
    in C, Python, Go, or other languages. Java is totally object oriented.
  prefs: []
  type: TYPE_NORMAL
- en: There can be more than one class in a single file, but usually one file is one
    class. Later, we will see that there are inner classes when a class is inside
    another class, but, for now, we will put one class into one file.
  prefs: []
  type: TYPE_NORMAL
- en: There are some features in the Java language that we do not use. When the language
    was created, these features seemed to be a good idea. CPU, memory, and other resources,
    including mediocre developers, were also more limited than today. Some of the
    features, perhaps, made more sense because of these environmental constraints.
    Sometimes, I will mention these. In the case of classes, you can put more than
    one class into a single file so long as only one is `public`. That is bad practice,
    and we will never do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java never obsoletes these features. It is a philosophy of Java to remain compatible
    with all previous versions. This philosophy is good for the already written, huge
    amount of legacy code. Java code written and tested with an old version will work
    in a newer environment. At the same time, those features lure beginners to a wrong
    style. For this reason, sometimes, I will not even mention these features. For
    example, here, I could say: *There is one class in a file.* This would not be
    absolutely correct. At the same time, it is more or less pointless to explain
    in great detail a feature that I recommend not to be used. Later, I may simply
    skip them and "lie". There are not too many of those features.'
  prefs: []
  type: TYPE_NORMAL
- en: A class is defined using the `class` keyword and each class has to have a name.
    The name should be unique within the package (see the next section) and has to
    be the same as the name of the file. A class can implement an interface or extend
    another class, for which we will see an example later. A class can also be `abstract`,
    `final`, and `public`. These are defined with the appropriate keywords, as you
    will see in examples.
  prefs: []
  type: TYPE_NORMAL
- en: Our program has two classes. Both of them are `public`. The `public` classes
    are accessible from anywhere. Classes that are not `public` are visible only inside
    the package. Inner and nested classes can also be `private` visible only inside
    the top-level class defined on the file level.
  prefs: []
  type: TYPE_NORMAL
- en: Classes that contain a `main` method to be invoked by the Java environment should
    be `public`. That is because they are invoked by the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: The class starts at the beginning of the file right after the package declaration
    and everything between the `{` and `}` characters belong to the class. The methods,
    fields, inner or nested classes, and so on are part of the class. Generally, curly
    braces denote some block in Java. This was invented in the C language, and many
    languages follow this notation. Class declaration is some block, methods are defined
    using some block, loops, and conditional commands use blocks.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the classes, we will have to create instances of classes. These
    instances are objects. In other words, objects are created instantiating a class.
    To do that, the `new` keyword is used in Java. When the line `final Sort sorter
    = new Sort()`; is executed in the `App` class, it creates a new object instantiating
    the `Sort` class. We will also say that we created a new `Sort` object or that
    the type of the object is `Sort`. When a new object is created, a constructor
    of the object is invoked. A bit sloppy, I may say, that the constructor is a special
    *method* in the class that has the same name as the class itself and has no return
    value. That is because it *returns* the created object. To be precise, constructors
    are not methods. They are initializers and they do not return the new object.
    They work on the *not-ready-yet* object. When a constructor executing the object
    is not fully initialized, some of the final fields may not be initialized and
    the overall initialization still can fail if the constructor throws an exception.
    In our example, we do not have any constructor in the code. In such a case, Java
    creates a default constructor that accepts no argument and does not modify the
    already allocated but uninitialized object. If the Java code defines an initializer,
    then the Java compiler does not create a default one.
  prefs: []
  type: TYPE_NORMAL
- en: A class can have many constructors, each having different parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to constructors Java classes can contain initializer blocks. They
    are blocks on the class level, the same level as the constructor and methods.
    The code in these blocks is compiled into the constructors and is executed when
    the constructor is executing.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to initialize static fields in static initializer blocks.
    These are the blocks on the top level inside the class with the `static` keyword
    in front of them. They are executed only once when the class is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: We named the classes in our example `App` and `Sort`. This is a convention in
    Java to name almost everything in CamelCase.
  prefs: []
  type: TYPE_NORMAL
- en: CamelCase is when the words are written without spaces between them. The first
    word may start with lowercase or uppercase, and, to denote the start of the second
    and subsequent words, they start with uppercase. `ForExampleThisIsALongCamelCase`
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Class names start with an uppercase letter. This is not a requirement of the
    language formally, but this is a convention that every programmer should follow.
    These coding conventions help you create code that is easier to understand by
    other programmers, and lead to easier maintenance. Static code analyzer tools,
    such as Checkstyle ([http://checkstyle.sourceforge.net/](http://checkstyle.sourceforge.net/)),
    also check that the programmers follow the conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Inner, nested, local, and anonymous classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have already mentioned inner and nested classes in the previous section. Now
    we look at them in bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The details of inner and nested classes at this point may be difficult. Don't
    feel ashamed if you do not understand this section fully. If it is too difficult,
    skip to the next section and read about packages and return here later. Nested,
    inner, and local classes are rarely used, though they have their roles and use
    in Java. Anonymous classes were very popular in GUI programming with the Swing
    user interface that allowed developers to create Java GUI applications. With Java
    8 and the lambda feature, anonymous classes are not so important these days, and
    with the emerging JavaScript and browser technology, the Java GUI became less
    popular.
  prefs: []
  type: TYPE_NORMAL
- en: When a class is defined in a file on its own, it is called a top-level class.
    Classes that are inside another class are, obviously, not top-level classes. If
    they are defined inside a class on the same level as fields (variables that are
    not local to some method or other block), they are inner or nested classes. There
    are two differences between them. One is that nested classes have the `static`
    keyword before the `class` keyword at their definition, and inner classes don't.
  prefs: []
  type: TYPE_NORMAL
- en: The other difference is that instances of nested classes can exist without an
    instance of the surrounding class. Inner class instances always have a reference
    to an instance of the surrounding class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because inner class instances cannot exist without an instance of the surrounding
    class, their instance can only be created by providing an instance of the outer
    class. We will see no difference if the surrounding class instance is the actual
    `this` variable, but if we want to create an instance of an inner class from outside
    the surrounding class, then we have to provide an instance variable before the
    `new` keyword separated by a dot, just like if new were a method. For example,
    we could have a class named `TopLevel` that has a class named `InnerClass`, like
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can create an instance of the `InnerClass` from outside with only a
    `TopLevel` object, like in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As inner classes have an implicit reference to an instance of the enclosing
    class, the code inside the inner class can access the fields and the methods of
    the enclosing class.
  prefs: []
  type: TYPE_NORMAL
- en: Nested classes do not have an implicit reference to any instance of the enclosing
    class, and they may be instantiated with the `new` keyword without any reference
    to any instance of any other class. Because of that, they cannot access the fields
    of the enclosing class unless they are static fields.
  prefs: []
  type: TYPE_NORMAL
- en: Local classes are classes that are defined inside a method, constructor, or
    an initializer block. We will soon talk about initializer blocks and constructors.
    Local classes can be used inside the block where they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous classes are defined and instantiated in a single command. They are
    a short form of a nested, inner, or local class, and the instantiation of the
    class. Anonymous classes always implement an interface or extend a named class.
    The new keyword is followed by the name of the interface or the class with the
    argument list to the constructor between parentheses. The block that defines the
    body of the anonymous class stands immediately after the constructor call. In
    the case of extending an interface, the constructor can only be the one without
    argument. The anonymous class with no name cannot have its own constructors. In
    modern Java we usually use lambda instead of anonymous classes.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least—well, actually, least I should mention that nested and inner
    classes can also be nested in deeper structures. Inner classes cannot contain
    nested classes, but nested classes can contain inner classes. Why? I have never
    met anyone who could reliably tell me the real reason. There is no architectural
    reason. It could be like that. Java does not permit that. However, it is not really
    interesting. If you happen to write code that has more than one level of class
    nesting then just stop doing it. Most probably you are doing something wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes are organized into packages and the first code line in a file should
    specify the package that the class is in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you do not specify the package, then the class will be in the *default* package.
    This should not be used, except in the simplest case when you want to try some
    code. With Java 9, you can use `jshell` for this purpose, so, as opposed to previous
    versions of Java, now the suggestion becomes very simple—never put any class in
    the default package.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the packages is hierarchical. The parts of the names are separated
    by dots. Using package names helps you avoid name collisions. Names of the classes
    are usually kept short and putting them into packages helps the organization of
    the program. The full name of a class includes the name of the package the class
    is in. Usually, we will put those classes into a package that are in some way
    related, and add something to a similar aspect of a program. For example, controllers
    in an MVC pattern program are kept in a single package. Packages also help you
    avoid name collision of classes. However, this only pushes the problem from class
    name collision to package name collision. We have to make sure that the name of
    the package is unique and does not cause any problem when our code is used together
    with any other library. When an application is developed, we just cannot know
    what other libraries will be used in later versions. To be prepared for the unexpected,
    the convention is to name the packages according to some Internet domain names.
    When a development company has the domain name `acmecompany.com`, then their software
    is usually under the `com.acmecompany...`  packages. It is not a strict language
    requirement. It is only a convention to write the domain name from right to left,
    and use it as package name, but this proves to be fairly good in practice. Sometimes,
    like I do in this book, one can deviate from this practice so you can see that
    this rule is not carved in stone.
  prefs: []
  type: TYPE_NORMAL
- en: When the rubber hits the road, and the code is compiled into byte code, the
    package becomes the name of the class. Thus, the full name of the `Sort` class
    is `packt.java9.by.example.stringsort.Sort`. When you use a class from another
    package, you can use this full name or import the class into your class. Again,
    this is on the language level. Using the fully qualified name or importing makes
    no difference when Java becomes byte code.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed methods, but not in detail, and there are still some
    aspects that we should meet before we go on.
  prefs: []
  type: TYPE_NORMAL
- en: There are two methods in the sample classes. There can be many methods in a
    class. Method names are also camel cased by convention, and the name starts with
    a lowercase letter, as opposed to classes. Methods may return a value. If a method
    returns a value, the method has to declare the type of the value it returns and,
    in that case, any execution of the code has to finish with a `return` statement.
    The `return` statement has an expression after the keyword, which is evaluated
    when the method is executed and is returned by the method. It is good practice
    to have only one single return from a method but, in some simple cases, breaking
    that coding convention may be forgiven. The compiler checks the possible method
    execution paths, and it is a compile-time error if some of the paths do not return
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: When a method does not return any value, it has to be declared to be `void`.
    This is a special type that means no value. Methods that are `void`, such as the
    `public static void main` method, may simply miss the return statement and just
    end. If there is a `return` statement, there is no place for any expression defining
    a return value after the `return` keyword. Again, this is a coding convention
    to not use the `return` statement in case of a method that does not return any
    value, but in some coding patterns, this may not be followed.
  prefs: []
  type: TYPE_NORMAL
- en: Methods can be `private`, `protected`, `public`, and `static`, and we will discuss
    their meaning later.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that the `main` method that was invoked when the program started
    is a `static` method. Such a method belongs to the class and can be invoked without
    having any instance of the class. Static methods are declared with the `static`
    modifier, and they cannot access any field or method that is not static.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the `sort` method is not static, but as it does not access
    any field and does not call any non-static method (as a matter of fact, it does
    not call any method at all), it could just as well be `static`. If we change the
    declaration of the method to `public static void sort(String[] names) {` (note
    the word `static`), the program still works, but the IDE will give a warning while
    editing, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That is because you can access the method without an instance directly through
    the name of the `Sort.sort(actualNames);` class without the need of the `sorter`
    variable. Calling a static method via an instance variable is possible in Java
    (again something that seemed to be a good idea at the genesis of Java, but is
    probably not), but it may mislead the reader of the code into thinking that the
    method is an instance method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the `sort` method `static`, the `main` method can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It seems to be much simpler (it is), and, in case the method does not use any
    field, you may think that there is no reason to make a method non-static. During
    the first ten years of Java, static methods were in heavy use. There is even a
    term, utility class, which means a class that has only static methods and should
    not be instantiated. With the advent of **Inversion of Control** containers, we
    tend to use less static methods. When static methods are used, it is harder to
    use **dependency injection**, and it is also more difficult to create tests. We
    will discuss these advanced topics in the next few chapters. For now, you are
    informed as to what static methods are and that they can be used; however, usually,
    unless there is a very special need for them, we will avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will look at how classes are implemented in the hierarchy, and how
    classes may implement interfaces and extend other classes. When these features
    are looked at, we will see that there are so-called abstract classes that may
    contain abstract methods. These methods have the  `abstract` modifier, and they
    are not defined—only the name, argument types (and names), and return type are
    specified. A concrete (non-abstract) class extending the abstract class should
    define them.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of abstract method is the final method declared with the `final`
    modifier. A `final` method cannot be overridden in subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods are also declared in interfaces. A method declared in an interface does
    not define the actual behavior of the method; they do not contain the code. They
    have only the head of the method; in other words, they are abstract implicitly.
    Although nobody does, you may even use the `abstract` keyword in an interface
    when you define a method.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces look very similar to classes, but instead of using the `class` keyword,
    we use the `interface` keyword. Because interfaces are mainly used to define methods,
    the methods are `public` if no modifier is used.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can also define fields, but since interfaces cannot have instances
    (only implementing classes can have instances), these fields are all `static`
    and they also have to be `final`. This is the default for fields in interfaces,
    thus we do not need to write these if we defined fields in interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: It was a common practice to define only constants in some interfaces and then
    use these in classes. To do that, the easiest way was to implement the interface.
    Since these interfaces do not define any method, the implementation is nothing
    more than writing the implements keyword and the name of the interface into the
    header of the class declaration. This is bad practice because this way the interface
    becomes part of the public declaration of the class, although these constants
    are needed inside the class. If you need to define constants that are not local
    to a class but are used in many classes, then define them in a class and import
    the fields using `import static` or just use the name of the class and the field.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can also have nested classes, but they cannot have inner classes.
    The obvious reason for that is that inner class instances have a reference to
    an instance of the enclosing class. In the case of an interface, there are no
    instances, so an inner class could not have a reference to an instance of an enclosing
    interface, because that just does not exist. The joyful part of it is that we
    do not need to use the `static` keyword in the case of nested classes because
    that is the default, just as in the case of fields.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of Java 8, you can also have `default` methods in interfaces
    that provide default implementation of the method for the classes that implement
    the interface. There can also be `static` and `private` methods in interfaces
    since Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Methods are identified by their name and the argument list. You can reuse a
    name for a method and have different argument types; Java will identify which
    method to use based on the types of the actual arguments. This is called **method
    overloading**. Usually, it is easy to tell which method you call, but when there
    are types that extend each other, the situation becomes more complex. The standard
    defines very precise rules for the actual selection of the method that the compiler
    follows, so there is no ambiguity. However, fellow programmers who read the code
    may misinterpret overloaded methods or, at least, will have hard time identifying
    which method is actually called. Method overloading may also hinder backward compatibility
    when you want to extend your class. The general advice is to think twice before
    creating overloaded methods. They are lucrative, but may sometimes be costly.
  prefs: []
  type: TYPE_NORMAL
- en: Argument passing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, arguments are passed by value. When the method modifies an argument
    variable, then only the copy of the original value is modified. Any primitive
    value is copied during the method call. When an object is passed as an argument,
    then the copy of the reference to the object is passed.
  prefs: []
  type: TYPE_NORMAL
- en: That way, the object is available to be modified for the method. In the case
    of classes that have their primitive counterpart, and also in the case of `String`
    and some other class types, the objects simply do not provide methods or fields
    to modify the state. This is important for the integrity of the language, and
    to not get into trouble when objects and primitive values automatically get converted.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, when the object is modifiable, the method can effectively work
    on the very object it was passed to. This is also the way the `sort` method in
    our example works on the array. The same array, which is also an object itself,
    is modified.
  prefs: []
  type: TYPE_NORMAL
- en: This argument passing is much simpler than it is in other languages. Other languages
    let the developer mix the *pass by reference* and the *pass by value* argument
    passing. In Java, when you use a variable by itself as an expression to pass a
    parameter to a method, you can be sure that the variable itself is never modified.
    The object it refers to, however, in case it is mutable, may be modified.
  prefs: []
  type: TYPE_NORMAL
- en: An object is mutable if it can be modified, altering the value of some of its
    field directly or via some method call. When a class is designed in a way that
    there is no normal way to modify the state of the object after the creation of
    the object, the object is immutable. The classes `Byte`, `Short`, `Integer`, `Long`,
    `Float`, `Double`, `Boolean`, `Character`, as well as `String`, are designed in
    the JDK so that the objects are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to overcome the limitation of immutability implementation of
    certain classes using reflection, but doing that is hacking and not professional
    coding. Doing that can be done for one single purpose—getting a better knowledge
    and understanding of the inner workings of some Java classes, but nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fields are variables on the class level. They represent the state of an object.
    They are variables, with defined type and possible initial value. Fields can be
    `static`, `final`, `transient`, and `volatile`, and the access may be modified
    with the `public`, `protected`, and `private` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Static fields belong to the class. It means that there is one of them shared
    by all the instances of the class. Normal, non-static fields belong to the objects.
    If you have a field named `f`, then each instance of the class has its own `f`.
    If `f` is declared `static`, then the instances will share the very same `f` field.
  prefs: []
  type: TYPE_NORMAL
- en: The `final` fields cannot be modified after they are initialized. Initialization
    can be done on the line where they are declared, in an initializer block or in
    the constructor code. The strict requirement is that the initialization has to
    happen before the constructor returns. This way, the meaning of the `final` keyword
    is very different, in this case, from what it means in the case of a class or
    a method. A `final` class cannot be extended and a `final` method cannot be overridden
    in an extending class, as we will see in the next chapter. The `final` fields
    are either uninitialized or get a value during instance creation. The compiler
    also checks that the code does initialize all `final` fields during the object-instance
    creation or during the class loading, in case the `final` field is `static`, and
    that the code is not accessing/reading any `final` field that was not yet initialized.
  prefs: []
  type: TYPE_NORMAL
- en: It is a common misconception that the `final` fields have to be initialized
    at the declaration. It can be done in an initializer code or in a constructor.
    The restriction is that, no matter which constructor is called in case there are
    more, the `final` fields have to be initialized exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: The `transient` fields are not part of the serialized state of the object. Serialization
    is an act of converting the actual value of an object to physical bytes. Deserialization
    is the opposite when the object is created from the bytes. It is used to save
    the state in some frameworks. The code that does the serialization, `java.lang.io.ObjectOutputStream`,
    works only with classes that implement the `Serializable` interface, and uses
    only the fields from those objects that are not `transient`. Very obviously, `transient`
    fields are also not restored from the bytes that represent the serialized form
    of the object because their value is not there.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization is usually used in distributed programs. A good example is the
    session object of a servlet. When the servlet container runs on a clustered node,
    some fields of objects stored into the session object may magically disappear
    between HTTP hits. That is because serialization saves and reloads the session
    to move the session between the nodes. Serialization, in such a situation, may
    also be a performance issue if a developer does not know the side effects of the
     stored large objects in the session.
  prefs: []
  type: TYPE_NORMAL
- en: The `volatile` keyword is a keyword that tells the compiler that the field may
    be used by different threads. When a `volatile` field is accessed by any code,
    the JIT compiler generates code which ensures that the value of the field accessed
    is up to date. When a field is not volatile, the compiler-generated code may store
    the value of the field in a processor cache or registry for faster access when
    it sees that the value will be needed soon by some subsequent code fragment. In
    the case of `volatile` fields, this optimization cannot be done. Additionally,
    note that saving the value to memory and loading from there all the time may be
    50 or more times slower than accessing a value from a registry or cache.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods, constructors, fields, interfaces, and classes can have access modifiers.
    The general rule is that in case there is no modifier, the scope of the method,
    constructor, and so on, is the package. Any code in the same package can access
    it.
  prefs: []
  type: TYPE_NORMAL
- en: When the `private` modifier is used, the scope is restricted to the so-called
    compilation unit. This means the class that is in one file. What is inside one
    file can see and use anything declared to be `private`. This way, inner and nested
    classes can have access to each other's `private` variables, which may not really
    be a good programming style, but Java permits that.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of `private` is `public`. It extends the visibility to the whole
    Java program, or at least to the whole module, if the project is a Java 9 module.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a middle way: `protected`. Anything with this modifier is accessible
    inside the package and also in classes that extend the class (regardless of package)
    that the protected method, field, and so on, is in.'
  prefs: []
  type: TYPE_NORMAL
- en: Object initializers and constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an object is instantiated, the appropriate constructor is called. The
    constructor declaration looks like a method with the following deviation: the
    constructor does not have a return value. That is because the constructors work
    on the not-fully-ready instance when the `new` command operator is invoked and
    does not return anything. Constructors, having the same name as the class, cannot
    be distinguished from each other. If there is a need for more than one constructor,
    they have to be overloaded. Constructors, thus, can call each other, almost as
    if they were `void` methods with different arguments. However, there is a restriction—when
    a constructor calls another, it has to be the very first instruction in the constructor.
    You use `this()` syntax with an appropriate argument list, which may be empty,
    to invoke a constructor from another constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: The initialization of the object instance also executes initializer blocks.
    These are blocks containing executable code inside the `{` and `}` characters
    outside the methods and constructors. They are executed before the constructor
    in the order they appear in the code, together with the initialization of the
    fields in case their declarations contain value initialization.
  prefs: []
  type: TYPE_NORMAL
- en: If you see the `static` keyword in front of an initializer block, the block
    belongs to the class and is executed when the class is loaded along with the static
    field initializers.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we will compile and execute our program from the command line. There
    is nothing new in this one; we will only apply what we have learned in this chapter
    using the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This compiles the program, packages the result into a JAR file, and finally
    executes the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following result on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/00036.jpeg)**'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have developed a very basic sort algorithm. It was made
    purposefully simple so that we could reiterate the basic and most important Java
    language elements, classes, packages, variables, methods, and so on. We also looked
    at build tools, so we are not empty handed in the next chapters when projects
    will contain more than just two files. We will use Maven and Gradle in the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the very next chapter, we will make the sort program more complex, implementing
    more effective algorithms and also making our code flexible, giving us the opportunity
    to learn more advanced Java language features.
  prefs: []
  type: TYPE_NORMAL
