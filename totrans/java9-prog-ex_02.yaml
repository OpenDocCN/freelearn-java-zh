- en: The First Real Java Program - Sorting Names
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个真正的Java程序 - 排序姓名
- en: 'In the previous chapter, we got acquainted with Java, and especially with using
    the REPL tool and interactively executing some simple code. That is a good start,
    but we need more. In this chapter, we will develop a simple sort program. Using
    this code as an example, we will look at different build tools, which are frequently
    used for Java projects, and learn the basic features of the Java language. This
    chapter will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们熟悉了Java，特别是使用REPL工具和交互式执行一些简单代码。这是一个好的开始，但我们还需要更多。在这一章中，我们将开发一个简单的排序程序。使用这段代码作为示例，我们将查看常用的构建工具，这些工具经常用于Java项目，并学习Java语言的基本特性。本章将涵盖以下主题：
- en: The sorting problem
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序问题
- en: The project structure and build tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构和构建工具
- en: The Make, Ant, Maven, and Gradle build tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Make、Ant、Maven和Gradle构建工具
- en: Java language features related to the code example
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与代码示例相关的Java语言特性
- en: Getting started with sorting
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序入门
- en: The sorting problem is one of the oldest programming tasks that an engineer
    deals with. We have a set of records and we know that we want to find a specific
    one sometime later, and we want to find that one fast. To find it, we sort the
    records in a specific order that helps us find the record we want quickly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 排序问题是工程师处理的最古老的编程任务之一。我们有一组记录，我们知道我们会在以后某个时候找到特定的一个，并且我们希望快速找到它。为了找到它，我们将记录按照特定的顺序排序，这有助于我们快速找到我们想要的记录。
- en: As an example, we have the names of students with their marks on some cards.
    When students come to the office asking for their results, we look through all
    of the cards one after the other to find the name of the enquiring student. However,
    it is better if we sort the cards by the names of the students alphabetically.
    When a student makes an enquiry, we can search the mark attached to the name much
    faster.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有学生的名字和他们在一些卡片上的分数。当学生来到办公室询问他们的成绩时，我们会逐张查看所有卡片，以找到询问学生的名字。然而，如果我们将卡片按学生的名字字母顺序排序会更好。当学生询问时，我们可以更快地搜索附在名字上的分数。
- en: We can look at the middle card; if it shows the name of the student, then we
    are happy to have found the name and the mark. If the card precedes the name of
    the student alphabetically, then we will continue searching in the second half;
    otherwise, we will check the first half.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看中间的牌；如果它显示了学生的名字，那么我们就很高兴找到了名字和分数。如果这张牌在学生名字的字母顺序之前，那么我们将继续在下半部分搜索；否则，我们将检查上半部分。
- en: Following that approach, we can find the name of the student in a few steps.
    The number of steps can not be more than the number as many times the pack of
    cards can be halved. If we have two cards, then it is two steps at most. If it
    is four, then we will need three steps at most. If there are eight cards, then
    we may need four steps, but not more. If there are 1,000 cards, then we may need
    at most 11 steps, while the original, non-sorted set will need 1,000 steps, worst
    case. That is, approximately, it speeds up the search 100 times, so this is worth
    sorting the cards, unless the sorting itself takes too much time. The algorithm
    finding an element in the already sorted set we just described is called **binary
    search** ([https://en.wikipedia.org/wiki/Binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方法，我们可以通过几个步骤找到学生的名字。步骤的数量不能超过将牌组对半分所需的次数。如果有两张牌，那么最多两步。如果是四张，那么最多需要三步。如果有八张牌，那么可能需要四步，但不会更多。如果有1,000张牌，那么可能最多需要11步，而原始的非排序集合则需要1,000步，最坏的情况。也就是说，大约提高了搜索速度100倍，所以排序卡片是值得的，除非排序本身花费太多时间。我们刚才描述的找到已排序集合中元素的算法称为**二分查找**（[https://en.wikipedia.org/wiki/Binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm)）。
- en: In many cases, it is worth sorting the dataset, and there are many sorting algorithms
    to do that. There are simpler and more complex algorithms, and, as in many cases,
    more complex algorithms are the ones that run faster.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，对数据集进行排序是值得的，并且有许多排序算法可以完成这项任务。有简单和复杂的算法，而且在许多情况下，更复杂的算法运行得更快。
- en: As we are focusing on the Java programming part and not the algorithm forging,
    in this chapter, we will develop a Java code that implements a simple and not-that-fast
    algorithm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们专注于Java编程部分而不是算法锻造，在这一章中，我们将开发一个实现简单且不太快的算法的Java代码。
- en: Bubble sort
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: The algorithm that we will implement in this chapter is well-known as **bubble
    sort**. The approach is very simple. Begin at the start of the cards and compare
    the first and the second card. If the first card is later in lexicographic order
    than the second one, then swap the two cards. Then repeat this for the card that
    is at the second place now, then the third, and so on. There is a card that is
    lexicographically the latest, say Wilson. When we get this card and start to compare
    it with the next one, we will always swap them; this way, Wilson's card will travel
    to the last place where it has to be after the sort. All we have to do is repeat
    this travelling from the start and do the occasional swapping of cards again,
    but this time only to the last but one element. This time, the second latest element
    will get to its place—say, Wilkinson will be right before Wilson. If we have *n*
    cards, and we repeat this *n-1* times, all cards will get to their place.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中实现的算法是众所周知的**冒泡排序**。方法非常简单。从卡片的开头开始，比较第一张和第二张卡片。如果第一张卡片在字典顺序上比第二张卡片晚，那么交换这两张卡片。然后对现在位于第二位的卡片重复此操作，然后是第三位，以此类推。有一张字典顺序上最新的卡片，比如说威尔逊。当我们得到这张卡片并开始与下一张卡片比较时，我们总是会交换它们；这样，威尔逊的卡片就会移动到最后一个位置，它必须在排序后放在那里。我们唯一要做的就是从开始重复这个移动，偶尔再次交换卡片，但这次只交换到最后一个元素。这次，第二最新的元素将到达它的位置——比如说，威尔金森将在威尔逊之前。如果我们有*n*张卡片，并且重复*n-1*次，所有卡片都将到达它们的位置。
- en: In the following sections, we will create a Java project that implements this
    algorithm.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将创建一个实现此算法的Java项目。
- en: Getting started with project structure and build tools
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习项目结构和构建工具
- en: When a project is more complex than a single class, and it usually is, then
    it is wise to define a project structure. We will have to decide where we store
    the source files, where the resource files (those that contain some resource for
    the program, but are not Java source) are, where the `.class` files should be
    written by the compiler, and so on. Generally, the structure is mainly the directory
    setup and the configuration of the tools that perform the build.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个项目比单个类更复杂，这通常是这样的，那么定义一个项目结构是明智的。我们得决定在哪里存储源文件，资源文件（那些包含程序资源但不包含Java源文件的文件）在哪里，编译器应该将`.class`文件写入哪里，等等。一般来说，结构主要是目录设置和执行构建的工具配置。
- en: The compilation of complex programs cannot be feasibly done using the command
    line issuing `javac` commands. If we have 100 Java source files, the compilation
    will require that many `javac` commands to be issued. It can be shortened using
    wild cards, such as `javac *.java` ,or we can write a simple bash script or a
    BAT command file that does that. First, it will be just 100 lines, each compiling
    one source Java file to class file. Then, we will realize that it is only time,
    CPU, and power consuming to compile the files that are not changed since the last
    compilations so we can add some bash programming that checks the time stamp on
    the source and generated files. Then, we will probably realize that... whatever.
    At the end, we will end up with a tool that is essentially a build tool. Build
    tools are available ready made; it is not worth reinventing the wheel.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行发出`javac`命令来编译复杂程序是不可行的。如果我们有100个Java源文件，编译将需要发出那么多的`javac`命令。可以使用通配符来缩短这个过程，例如`javac
    *.java`，或者我们可以编写一个简单的bash脚本或BAT命令文件来完成这个任务。首先，它将只有100行，每行编译一个源Java文件到类文件。然后，我们会意识到，编译自上次编译以来没有改变的文件只是浪费时间、CPU和电力，因此我们可以添加一些bash编程来检查源文件和生成文件的时间戳。然后，我们可能会意识到……无论什么。最后，我们将得到一个本质上是一个构建工具的工具。构建工具是现成的，不值得重新发明轮子。
- en: Instead of creating one, we will use a build tool that is ready. There are a
    few of them that can be found at [https://en.wikipedia.org/wiki/List_of_build_automation_software](https://en.wikipedia.org/wiki/List_of_build_automation_software).
    In this chapter, we will use one called Maven; however, before jumping into the
    details of this tool, we will look at some other tools that you are likely to
    meet as a Java professional in enterprise projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会创建一个，而是会使用一个现成的构建工具。可以在[https://en.wikipedia.org/wiki/List_of_build_automation_software](https://en.wikipedia.org/wiki/List_of_build_automation_software)找到一些。在本章中，我们将使用一个名为Maven的工具；然而，在深入探讨这个工具的细节之前，我们将看看一些你作为Java专业人士在企业项目中可能会遇到的其他工具。
- en: 'In the following sections, we will discuss a bit of the four build tools:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论四种构建工具中的几种：
- en: Make
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Make
- en: Ant
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ant
- en: Maven
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Gradle
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle
- en: We will mention Make only briefly because it is not used in Java environments
    these days. However, Make was the first build tool, and many ideas that modern Java
    build tools are based on come from the *good old  *`make`. You, as a professional
    Java developer, should also be familiar with Make so that you will not freak out
    if you happen to see the use of it in a project for some purpose, and can know
    what it is and where its detailed documentation can be found.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要提及`Make`，因为它现在在Java环境中不再使用。然而，`Make`是第一个构建工具，现代Java构建工具的许多想法都源于“古老的”`make`。作为专业的Java开发者，您也应该熟悉`Make`，这样如果您在项目中偶然看到它的使用，就不会感到惊慌，并且可以了解它是什么以及其详细文档可以在哪里找到。
- en: Ant was the first build tool widely used for Java many years ago, and it is
    still used in many projects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ant是多年前广泛用于Java的第一个构建工具，它仍然被许多项目使用。
- en: Maven is newer than Ant, and it uses a different approach. We will look at it
    in detail. Maven is also the official build tool of the Apache software foundation
    for the Java project. We will also use Maven as a build tool in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Maven比Ant更新，它采用了一种不同的方法。我们将详细探讨它。Maven也是Apache软件基金会对Java项目的官方构建工具。我们也将在这个章节中使用Maven作为构建工具。
- en: Gradle is even newer, and it has started to catch up to Maven these days. We
    will use this tool in later chapters in more detail.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle甚至更新，并且它最近开始赶上Maven。我们将在后面的章节中更详细地介绍这个工具。
- en: Make
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Make
- en: The `make` program was originally created in April 1976, so this is not a new
    tool. It is included in the Unix system, so this tool is available without any
    extra installation on Linux, Mac OS X, or any other Unix-based system. Additionally,
    there are numerous ports of the tool on Windows, and some version is/was included
    in the Visual Studio compiler toolset.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`程序最初是在1976年4月创建的，所以这不是一个新工具。它包含在Unix系统中，因此这个工具在Linux、Mac OS X或任何其他基于Unix的系统上无需额外安装即可使用。此外，该工具在Windows上有许多端口，并且某些版本包含在Visual
    Studio编译器工具集中。'
- en: The Make is not tied to Java. It was created when the major programming language
    was C, but it is not tied to C or any other language. The `make` is a dependency
    description language that has a very simple syntax.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Make`与Java无关。它是在主要编程语言是C的时候创建的，但它并不局限于C或任何其他语言。`make`是一种具有非常简单语法的依赖描述语言。'
- en: The `make`, just like any other build tool, is controlled by a project description
    file. In the case of make, this file contains a rule set. The description file
    is usually named `Makefile`, but in case the name of the description file is different,
    it can be specified as a command-line option to the `make` command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`，就像任何其他构建工具一样，由一个项目描述文件控制。在`make`的情况下，这个文件包含一组规则。描述文件通常命名为`Makefile`，但如果描述文件的名称不同，可以在`make`命令的命令行选项中指定。'
- en: 'Rules in `Makefile` follow each other and consist of one or more lines. The
    first line starts at the first position (there is no tab or space at the start
    of the line) and the following lines start with a tab character. Thus, `Makefile`
    may look something like the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Makefile`中的规则依次排列，由一行或更多行组成。第一行从第一个位置开始（行首没有制表符或空格），接下来的行以制表符开头。因此，`Makefile`可能看起来像以下代码：'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This file defines three so-called targets: `run`, `hello.jar`, and `HelloWorld.class`.
    To create `HelloWorld.class`, type the following line at the command prompt:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了三个所谓的目标：`run`、`hello.jar`和`HelloWorld.class`。要创建`HelloWorld.class`，请在命令提示符下输入以下行：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make will look at the rule and see that it depends on `HelloWorld.java`. If
    the `HelloWorld.class` file does not exist, or `HelloWorld.java` is newer than
    the Java class file, `make` will execute the command that is written on the next
    line and it will compile the Java source file. If the class file was created following
    the last modification of `HelloWorld.java`, then `make` knows that there is no
    need to run the command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`将查看规则并看到它依赖于`HelloWorld.java`。如果`HelloWorld.class`文件不存在，或者`HelloWorld.java`比Java类文件新，`make`将执行下一行上的命令，并编译Java源文件。如果类文件是在`HelloWorld.java`的最后一次修改后创建的，那么`make`知道不需要运行该命令。'
- en: In the case of creating `HelloWorld.class`, the `make` program has an easy task.
    The source file was already there. If you issue the `make hello.jar` command,
    the procedure is more complex. The `make` command sees that in order to create
    `hello.jar`, it needs `HelloWorld.class`, which itself is also a target on another
    rule. Thus, it may need to be created.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`HelloWorld.class`的情况下，`make`程序的任务很简单。源文件已经存在。如果你发出`make hello.jar`命令，过程会更复杂。`make`命令看到，为了创建`hello.jar`，它需要`HelloWorld.class`，而`HelloWorld.class`本身也是另一个规则上的目标。因此，它可能需要被创建。
- en: First, it starts the problem the same way as before. If `HelloWorld.class` is
    there, and is older than `hello.jar`, there is nothing to do. If it is not there,
    or is newer than `hello.jar`, then the `jar -cf hello.jar HelloWorld.class` command
    needs to be executed, although not necessarily at the moment when it realizes
    that it has to be performed. The `make` program remembers that this command has
    to be executed sometime in the future when all the commands that are needed to
    create `HelloWorld.class` are already executed successfully. Thus, it continues
    to create the class file exactly the same way as I described earlier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它以与之前相同的方式开始解决问题。如果存在`HelloWorld.class`文件，并且它的版本比`hello.jar`旧，那么就没有什么需要做的。如果它不存在，或者版本比`hello.jar`新，那么就需要执行`jar
    -cf hello.jar HelloWorld.class`命令，尽管不一定是在意识到需要执行的那一刻。`make`程序会记住，在未来某个时刻，当所有创建`HelloWorld.class`所需的命令都已成功执行后，这个命令需要被执行。因此，它会以与我之前描述的完全相同的方式继续创建类文件。
- en: 'In general, a rule can have the following format:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个规则可以有以下格式：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `make` command can create any target using the `make target` command by
    first calculating which commands to execute and then executing them one by one.
    The commands are shell commands executing in a different process and may pose
    problems under Windows, which may render the `Makefile` files' operating system
    dependent.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`命令可以通过首先计算要执行的命令，然后逐个执行它们，使用`make target`命令创建任何目标。这些命令是在不同的进程中执行的shell命令，可能在Windows下引起问题，这可能会使`Makefile`文件的操作系统依赖。'
- en: Note that the `run` target is not an actual file that `make` creates. A target
    can be a file name or just a name for the target. In the latter case, `make` will
    never consider the target to be readily available.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`run`目标不是一个`make`实际创建的文件。目标可以是一个文件名，或者只是目标的名称。在后一种情况下，`make`永远不会认为目标是可以立即使用的。
- en: As we do not use `make` for a Java project, there is no reason to get into more
    details. Additionally, I cheated a bit by making the description of a rule simpler
    than it should be. The `make` tool has many powerful features out of the scope
    of this book. There are also several implementations that differ a little from
    each other. You will most probably meet the one made by the Free Software Foundation—the
    GNU make. And, of course, just in case of any Unix command-line tool, `man` is
    your friend. The `man make` command will display the documentation of the tool
    on the screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用`make`进行Java项目，因此没有必要深入了解。此外，我在描述规则时稍微作弊了一点，使其比应有的描述更简单。`make`工具具有许多超出本书范围的功能。还有几个实现彼此略有不同。你很可能会遇到由自由软件基金会制作的版本——GNU
    make。当然，对于任何Unix命令行工具，`man`是你的朋友。`man make`命令将在屏幕上显示工具的文档。
- en: 'The main points that you should remember about `make` are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`make`你应该记住的主要点如下：
- en: It defines the dependencies of the individual artifacts (targets) in a declarative
    way
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以声明式的方式定义了各个工件（目标）的依赖关系
- en: It defines the actions to create the missing artifacts in an imperative way
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以命令式的方式定义了创建缺失工件的动作
- en: This structure was invented decades ago and has survived up until now for most
    of the build tools, as you will see in the next few chapters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构是在几十年前发明的，并且至今为止在大多数构建工具中仍然存在，你将在接下来的几章中看到这一点。
- en: Ant
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ant
- en: The `ant` build tool was built especially for Java projects around the year
    2000\. The aim of Java to be a *write-once-run-anywhere* language needed a tool
    that can also be used in different environments. Although `make` is available
    on Unix machines, and Windows as well, `Makefiles` were not always compatible.
    There was a small problem with the use of the tab character that some editors
    replaced with space, rendering `Makefile` unusable, but this was not the major
    reason. The main problem with `make` that ignited the development of Ant is that
    the commands are shell commands. Even if the implementation of the `make` program
    was made to be compatible on different operating systems, the used commands were
    many times incompatible, and that was something make itself could not change.
    Because `make` issues external commands to build the targets, developers are free
    to use any external tool that is available for them on the development machine.
    Another machine using the same operating system just may not have the same set
    of tools invoked by `make`. This undermines the portability of the `make` built
    projects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`ant` 构建工具是在2000年左右专门为Java项目构建的。Java希望成为*一次编写，到处运行*的语言，这需要一个可以在不同环境中使用的工具。尽管`make`在Unix机器和Windows上都有，但`Makefiles`并不总是兼容。使用制表符字符存在一个小问题，一些编辑器将其替换为空格，导致`Makefile`无法使用，但这不是主要原因。`make`的主要问题，也是激发Ant开发的原因是，它的命令是shell命令。即使`make`程序的实现被制作成可以在不同的操作系统上兼容，但使用的命令很多时候是不兼容的，这是`make`本身无法改变的事情。因为`make`向外部命令发出构建目标，开发者可以自由使用他们在开发机器上可用的任何外部工具。使用相同操作系统的另一台机器可能没有`make`调用的相同工具集。这削弱了`make`构建项目的可移植性。'
- en: At the same time, Ant is following the major principles of `make`. There are
    targets that may depend on each other and there are commands that need to be executed
    in an appropriate sequence to create the targets one after the other, following
    the dependency order. The description of the dependencies and the commands is
    XML (tab issue solved) and the commands are implemented in Java (system dependency
    is solved, well... more or less).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Ant遵循`make`的主要原则。有一些目标可能相互依赖，有一些命令需要按照适当的顺序执行以创建目标，并遵循依赖顺序。依赖和命令的描述是XML（解决了制表符问题），命令是用Java实现的（解决了系统依赖问题，嗯...更多或更少）。
- en: As Ant is neither part of the operating system nor the JDK, you will have to
    download and install it separately if you want to use it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ant既不是操作系统的一部分，也不是JDK的一部分，如果您想使用它，您必须单独下载和安装。
- en: Installing Ant
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Ant
- en: Ant can be downloaded from its official website ([http://ant.apache.org](http://ant.apache.org)).
    You can download the source or the precompiled version. The easiest way is to
    download the binary in a `tar.gz` format.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从其官方网站([http://ant.apache.org](http://ant.apache.org))下载Ant。您可以下载源代码或预编译版本。最简单的方法是下载`tar.gz`格式的二进制文件。
- en: Whenever you download software from the Internet, it is highly recommended that
    you check the integrity of the downloaded file. The HTTP protocol does not contain
    error checking, and it may happen that a network error remains hidden or a malevolent
    internal proxy modifies the downloaded file. Download sites usually provide checksums
    for the downloadable files. These are usually MD5, SHA1, SHA512, or some other
    checksums.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时您从互联网下载软件，都强烈建议您检查下载文件的完整性。HTTP协议不包含错误检查，可能发生网络错误仍然隐藏或恶意内部代理修改了下载的文件。下载网站通常为可下载文件提供校验和。这些通常是MD5、SHA1、SHA512或其他校验和。
- en: When I downloaded the Apache Ant 1.9.7 version in `tar.gz` format, I also opened
    the page that led to the MD5 checksum. The checksum value is `bc1d9e5fe73eee5c50b26ed411fb0119`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我以`tar.gz`格式下载Apache Ant 1.9.7版本时，我也打开了指向MD5校验和的页面。校验和值是`bc1d9e5fe73eee5c50b26ed411fb0119`。
- en: '![](img/00027.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: 'The downloaded file can be checked using the following command line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令行检查下载的文件：
- en: '`$ md5 apache-ant-1.9.7-bin.tar.gz`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ md5 apache-ant-1.9.7-bin.tar.gz`'
- en: '`MD5 (apache-ant-1.9.7-bin.tar.gz) = bc1d9e5fe73eee5c50b26ed411fb0119`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`MD5 (apache-ant-1.9.7-bin.tar.gz) = bc1d9e5fe73eee5c50b26ed411fb0119`'
- en: The calculated MD5 checksum is the same as the one on the website, which says
    that the file integrity is not harmed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出的MD5校验和与网站上的相同，这意味着文件完整性没有受损。
- en: On the Windows operating system, no tool to calculate MD5 digest is included.
    There is a tool that Microsoft provides, called **File Integrity Checksum Verifier
    Utility**, which is available via the page [https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility](https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility).
    If you use Linux, it may happen that the `md5` or `md5sum` utility is not installed.
    In that case, you can install it using the command `apt-get` or whatever installation
    tool your Linux distribution supports.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows操作系统上，没有包含计算MD5摘要的工具。有一个由微软提供的工具，称为**文件完整性校验和验证工具**，可通过页面[https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility](https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility)获取。如果你使用Linux，可能会发生`md5`或`md5sum`实用工具未安装的情况。在这种情况下，你可以使用`apt-get`或你的Linux发行版支持的任何安装工具来安装它。
- en: 'After the file is downloaded, you can explode it to a subdirectory using the
    following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载后，你可以使用以下命令将其展开到子目录：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The created subdirectory is the usable binary distribution of Ant. Usually,
    I move it under `~/bin`, making it available only for my user on OS X. After that,
    you should set the environment variable as `ANT_HOME` to point to this directory
    and also add the `bin` directory of the installation to the `PATH`. To do that,
    you should edit the `~/.bashrc` file and add the following lines to it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的子目录是Ant的可用二进制发行版。通常，我会将其移动到`~/bin`目录下，使其仅在OS X上对我的用户可用。之后，你应该设置环境变量`ANT_HOME`指向此目录，并将安装的`bin`目录添加到`PATH`中。为此，你应该编辑`~/.bashrc`文件，并向其中添加以下行：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, restart the terminal application, or just type `. ~/.bashrc` and test
    the installation of Ant by typing the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新启动终端应用程序，或者只需输入`. ~/.bashrc`并测试Ant的安装，通过输入以下命令：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the installation was correct, you should see the preceding error message.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装正确，你应该看到前面的错误信息。
- en: Using Ant
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ant
- en: 'When you see a project to be built by Ant, you will see a `build.xml` file.
    This is the project build file, the one that Ant was missing when you checked
    that the installation was correct. It can have any other name, and you can specify
    the name of the file as a command-line option for Ant, but this is the default
    file name, as `Makefile` was for `make`. A `build.xml` sample looks like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到Ant要构建的项目时，你会看到一个`build.xml`文件。这是项目构建文件，即Ant在检查安装是否正确时缺失的那个文件。它可以有其他任何名称，你可以将文件的名称作为Ant的命令行选项指定，但这是默认文件名，就像`Makefile`对于`make`一样。一个`build.xml`示例如下：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The top-level XML tag is `project`. Each build file describes one project,
    hence the name. There are three possible attributes to the tag, which are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最高级别的XML标签是`project`。每个构建文件描述一个项目，因此得名。该标签有三个可能的属性，如下所示：
- en: '`name`: This defines the name of the project and is used by some IDEs to display
    it in the left panel identifying the project'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这定义了项目的名称，并被一些IDE用于在左侧面板中标识项目'
- en: '`default`: This names the target to use when no target is defined on the command
    line starting Ant'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：当在启动Ant时命令行上没有定义目标时，使用此目标'
- en: '`basedir`: This defines the initial directory used for any other directory
    name calculation in the build file'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basedir`：这定义了在构建文件中用于任何其他目录名称计算的初始目录'
- en: The build file can contain a description for the project, as well as properties
    in property tags. These properties can be used as variables in the attributes
    of the tasks between the `${` and `}` characters, and play an important role in
    the build process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件可以包含项目的描述，以及属性标签中的属性。这些属性可以用作`${`和`}`字符之间的任务属性中的变量，并在构建过程中发挥重要作用。
- en: The targets are defined in target XML tags. Each tag should have a name that
    uniquely identifies the target in the build file and may have a `depends` tag
    that specifies one or more other targets that this target depends on. In case
    there is more than one target, the targets are comma separated in the attribute.
    The tasks belonging to the targets are executed in the same order as the targets
    dependency chain requires, in a very similar way as we saw in the case of `make`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目标在目标 XML 标签中定义。每个标签都应该有一个唯一标识构建文件中目标的名称，并且可能有一个 `depends` 标签，指定一个或多个此目标所依赖的其他目标。如果有多个目标，则目标在属性中以逗号分隔。属于目标的任务将按照目标依赖链要求的顺序执行，这与我们在
    `make` 的情况中看到的方式非常相似。
- en: You can also add a `description` attribute to a target that is printed by Ant
    when the command-line option, `-projecthelp`, is used. This helps the users of
    the build file to know what targets are there and which does what. Build files
    tend to grow large with many targets, and when you have ten or more targets, it
    is hard to remember each and every target.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为 Ant 打印的具有 `-projecthelp` 命令行选项的目标添加一个 `description` 属性。这有助于构建文件的用户了解有哪些目标以及它们的作用。随着目标数量的增加，构建文件往往会变得很大，当你有十个或更多目标时，很难记住每一个目标。
- en: 'The sample project with `HelloWorld.java` is now arranged in the following
    directories:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `HelloWorld.java` 的示例项目现在已按以下目录排列：
- en: '`build.xml` in the `root` folder of the project'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目根目录下的 `build.xml`
- en: '`HelloWorld.java` in the `src` folder of the project'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 `src` 文件夹中的 `HelloWorld.java`
- en: The `build/` folder does not exist; it will be created during the build process
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build/` 文件夹不存在；它将在构建过程中创建'
- en: The `build/classes` and `build/jar` also do not exist yet, and will be created
    during the build process
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build/classes` 和 `build/jar` 也尚未存在，将在构建过程中创建'
- en: 'When you start the build for the `HelloWorld` project the first time, you will
    see the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次为 `HelloWorld` 项目启动构建时，你会看到以下输出：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Some unimportant lines are deleted from the actual output.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际输出中删除了一些不重要的行。
- en: Ant realizes that first it has to create the directories, then it has to compile
    the source code, and finally it can pack the `.class` files into a `.jar` file.
    Now it is up to you to remember the command to execute the `HelloWorld` application.
    It was listed already in the first chapter. Note that this time, the JAR file
    is named `HelloWorld.jar`, and it is not in the current directory. You can also
    try to read the online documentation of Ant and create a target `run` that executes
    the compiled and packed program.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Ant 实现了首先需要创建目录，然后需要编译源代码，最后才能将 `.class` 文件打包成 `.jar` 文件。现在，你需要记住执行 `HelloWorld`
    应用程序的命令。它已在第一章中列出。请注意，这次，JAR 文件名为 `HelloWorld.jar`，它不在当前目录中。你也可以尝试阅读 Ant 的在线文档，创建一个名为
    `run` 的目标，以执行编译和打包的程序。
- en: Ant has a built-in task named `java` that executes a Java class in almost the
    same way as you typed the `java` command in the terminal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ant 内置了一个名为 `java` 的任务，它以几乎与你在终端中输入 `java` 命令相同的方式执行 Java 类。
- en: Maven
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven
- en: As Ant was created to overcome the shortages of `make`, Maven was created with
    a similar intention—to overcome the shortages of Ant. You may recall that make
    could not guarantee build portability because the commands `make` executes are
    arbitrary shell commands that may be system specific. An Ant build, if all the
    tasks are available on the classpath, is portable as long as Java runs the same
    way on the different platforms.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ant 是为了克服 `make` 的不足而创建的，Maven 也是出于类似的目的——为了克服 Ant 的不足而创建的。你可能还记得，`make`
    不能保证构建的可移植性，因为 `make` 执行的命令是任意的 shell 命令，可能具有系统特定性。只要 Java 在不同平台上以相同的方式运行，只要所有任务都在类路径上可用，Ant
    构建就是可移植的。
- en: The problem with Ant is a bit different. When you download the source code of
    a project and you want to build, what will the command be? You should ask Ant
    to list all the targets and select the one that seems to be the most suitable.
    The name of the task depends on the engineer who crafted the `build.xml` file.
    There are some conventions, but they are not strict rules.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Ant 的问题略有不同。当你下载项目的源代码并想要构建时，将会使用什么命令？你应该要求 Ant 列出所有目标并选择看起来最合适的一个。任务的名称取决于编写
    `build.xml` 文件的工程师。有一些约定，但它们不是严格的规则。
- en: Where will you find the Java source files? Are they in the `src` directory or
    not? Will there also be some Groovy or other programming language files in case
    the project is polyglot? That depends. Again, there may be some conventions that
    some groups or company cultures suggest, but there is no general best industry
    practice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到Java源文件？它们是否在`src`目录下？如果项目是多语言的，是否还会有Groovy或其他编程语言的文件？这取决于。再次强调，可能会有一些某些团队或公司文化建议的惯例，但并没有普遍的最佳行业实践。
- en: When you start a new project with Ant, you will have to create the targets for
    compilation, test execution, and packaging. It is something that you will have
    already done for other projects. After the second or third project, you will just
    copy and paste your previous `build.xml` to your new project. Is that a problem?
    Yes, it is. It is copy/paste programming, even if it is *only* some build files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Ant开始一个新项目时，你必须创建编译、测试执行和打包的目标。这是你已经在其他项目中做过的。在第二个或第三个项目之后，你只需复制并粘贴你之前的`build.xml`到新项目中。这是问题吗？是的，是问题。这是复制/粘贴编程，即使它只是*仅仅*一些构建文件。
- en: Developers realized that a significant effort of the projects utilizing Ant
    is devoted to project build tool configuration, including repetitive tasks. When
    a new joiner comes to the team, they will first have to learn how the build is
    configured. If a new project is started, the build configuration has to be created.
    If it is a repetitive task, then better let the computers do it. That is generally
    what programming is all about, isn't it?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者意识到，使用Ant的项目中，相当一部分工作都投入到了项目构建工具的配置中，包括重复性任务。当新成员加入团队时，他们首先必须学习如何配置构建。如果启动了一个新项目，就必须创建构建配置。如果是重复性任务，那么最好让计算机来做。这不就是编程通常要做的事情吗？
- en: Maven approaches the build issue a bit differently. We want to build Java projects.
    Sometimes, some *Groovy* or *Jython* things, but they are also *JVM* languages;
    thus, saying that we want to build Java projects is not really a huge restriction.
    Java projects contain Java files, sometimes some other programming language's
    source files, resource files, and generally, that is it. *Ant* can do anything,
    but we do not want to do just anything with a build tool. We want to build projects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Maven在构建问题上的处理方式略有不同。我们想要构建Java项目。有时，可能会有一些Groovy或Jython的东西，但它们也是JVM语言；因此，说我们想要构建Java项目并不是一个很大的限制。Java项目包含Java文件，有时还有一些其他编程语言的源文件、资源文件，通常就是这样。Ant可以做任何事情，但我们不希望用构建工具做任何事情。我们想要构建项目。
- en: Okay, after we restricted ourselves and accepted that we do not need a build
    tool that can be used for anything, we can go on. We can require that the source
    files be under the `src` directory. There are files that are needed for the operational
    code and there are files that contain some test code and data. Therefore, we will
    have two directories, `src/test` and `src/main`. Java files are in `src/main/java`
    as well as `src/test/java`. Resource files are under `src/main/resources` and
    `src/test/resources`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在限制自己并接受我们不需要一个可以用于任何目的的构建工具之后，我们可以继续前进。我们可以要求源文件位于`src`目录下。有一些文件是操作代码所需的，还有一些文件包含一些测试代码和数据。因此，我们将有两个目录，`src/test`和`src/main`。Java文件位于`src/main/java`以及`src/test/java`。资源文件位于`src/main/resources`和`src/test/resources`。
- en: If you want to put your source files somewhere else, then don't. I mean it.
    It is possible, but I will not even tell you how. Nobody does it. I do not even
    have any idea why Maven makes it possible. Whenever you see a project that is
    using Maven as a build tool, the sources are organized like that. There is no
    need to understand the directory structure envisioned by the project's build engineer.
    It is always the same.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将源文件放在其他地方，那就不要这么做。我是认真的。虽然可能可行，但我甚至不会告诉你如何做。没有人这么做。我甚至不知道为什么Maven允许这样做。无论何时你看到使用Maven作为构建工具的项目，源文件都是这样组织的。没有必要理解项目构建工程师所设想的目录结构。它总是相同的。
- en: How about the targets and the tasks? They are also the same for all Maven-based
    projects. What else would you like to do with a Java project other than compile,
    test, package, or deploy it? Maven defines these project life cycles for us. When
    you want to compile a project using Maven as a build tool, you will have to type
    `$ mvn compile` to compile the project. You can do that even before understanding
    what the project actually is.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目标和任务又是如何的呢？在所有基于 Maven 的项目中，它们都是相同的。除了编译、测试、打包或部署 Java 项目之外，您还想用 Maven 做些什么？Maven
    为我们定义了这些项目生命周期。当您想使用 Maven 作为构建工具编译项目时，您将需要输入 `$ mvn compile` 来编译项目。即使您还不了解项目实际上是什么，您也可以这样做。
- en: As we have the same directory structure and the same goals, the actual tasks
    leading to the goals are also all the same. When we create a Maven project, we
    do not have to describe what the build process has to do and how it has to do
    it. We will have to describe the project, and only the parts that are project
    specific.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有相同的目录结构和相同的目标，导致这些目标的实际任务也都是相同的。当我们创建 Maven 项目时，我们不必描述构建过程需要做什么以及如何做。我们将不得不描述项目，以及仅限于项目特定的部分。
- en: The build configuration of a Maven project is given in an XML file. The name
    of this file is usually `pom.xml`, and it should be in the `root` directory of
    the project, which should be the current working directory when firing up Maven.
    The word **POM** stands for **Project Object Model**, and it describes the projects
    in a hierarchical way. The source directories, the packaging, and other things
    are defined in a so-called super POM. This POM is part of the Maven program. Anything
    that the POM defines, overrides the defaults defined in the super POM. When there
    is a project with multiple modules, the POMs are arranged into a hierarchy, and
    they inherit the configuration values from the parent down to the modules. As
    we will use Maven to develop our sorting code, we will see some more details later.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 项目的构建配置在一个 XML 文件中给出。这个文件的名称通常是 `pom.xml`，它应该位于项目的 `root` 目录中，这应该是启动 Maven
    时的当前工作目录。**POM** 这个词代表 **项目对象模型**，它以分层的方式描述项目。源代码目录、打包和其他内容定义在一个所谓的超级 POM 中。这个
    POM 是 Maven 程序的一部分。POM 中定义的任何内容都会覆盖超级 POM 中定义的默认值。当有一个包含多个模块的项目时，POMs 会按照层次结构排列，并且从父项目继承配置值到模块。由于我们将使用
    Maven 来开发我们的排序代码，我们将在稍后看到更多细节。
- en: Installing Maven
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Maven
- en: Maven is neither a part of the operating system nor the JDK. It has to be downloaded
    and installed in a very similar way to Ant. You can download Maven from its official
    website ([https://maven.apache.org/](https://maven.apache.org/)) under the download
    section. Currently, the latest stable version is 3.3.9\. When you download it,
    the actual release may be different; instead, use the latest stable version. You
    can download the source or the precompiled version. The easiest way is to download
    the binary in `tar.gz` format.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 既不是操作系统的一部分，也不是 JDK 的一部分。它必须以与 Ant 非常相似的方式下载和安装。您可以从其官方网站的下载部分下载 Maven（[https://maven.apache.org/](https://maven.apache.org/)）。目前，最新稳定版本是
    3.3.9。当您下载时，实际发布的版本可能不同；相反，请使用最新稳定版本。您可以下载源代码或预编译版本。最简单的方法是下载 `tar.gz` 格式的二进制文件。
- en: I cannot skip drawing your attention to the importance of checking the download
    integrity using checksums. I have detailed the way to do it in the section about
    Ant installation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能忽视提醒您检查下载完整性的重要性，使用校验和进行详细说明已在 Ant 安装部分的章节中。
- en: 'After the file is downloaded, you can explode it to a subdirectory using the
    following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载完成后，您可以使用以下命令将其解压到子目录：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The created subdirectory is the usable binary distribution of Maven. Usually,
    I move it under `~/bin`, making it available only for my user on OS X. After that,
    you should add the `bin` directory of the installation to the `PATH`. To do that,
    you should edit the `~/.bashrc` file and add the following lines to it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的子目录是 Maven 的可用二进制发行版。通常，我会将它移动到 `~/bin` 目录下，使其仅在 OS X 上对我的用户可用。之后，您应该将安装的
    `bin` 目录添加到 `PATH` 中。为此，您应该编辑 `~/.bashrc` 文件，并向其中添加以下行：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, restart the terminal application, or just type `. ~/.bashrc` and test
    the installation of Maven typing, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新启动终端应用程序，或者只需输入 `. ~/.bashrc` 并通过以下方式测试 Maven 的安装：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should see a similar message on the screen that displays the installed Maven
    version and other information.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在屏幕上看到类似的消息，显示已安装的 Maven 版本和其他信息。
- en: Using Maven
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven
- en: 'Unlike Ant, Maven helps you create the skeleton of a new project. To do that,
    you will have to type the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ant 不同，Maven 帮助您创建新项目的骨架。为此，您必须输入以下命令：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Maven will first download the actually available project types from the network
    and prompt you to select the one you want to use. This approach seemed to be a
    good idea while Maven was new. When I first started Maven, the number of listed
    projects was somewhere between 10 and 20\. Today, as I write this book, it lists
    1,635 different archetypes. This number seems more like a historical date (the
    constitution of the French Academy of Science) than a usable size list of different
    archetypes. However, do not freak out. Maven offers a default value when it asks
    for your choice, and it is good for the `HelloWorld` we go for.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 首先会从网络上下载实际可用的项目类型，并提示您选择想要使用的一个。当 Maven 还比较新的时候，这种方法看起来是个好主意。当我第一次开始使用
    Maven 时，列出的项目数量在 10 到 20 之间。今天，当我写这本书的时候，它列出了 1,635 种不同的原型。这个数字看起来更像是一个历史日期（法国科学院的宪法），而不是一个可用的不同原型的列表大小。然而，请不要慌张。当
    Maven 询问您的选择时，它会提供一个默认值，这对于我们想要的 `HelloWorld` 来说是很好的。
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The actual number may be different on your installation. Whatever it is, accept
    the suggestion and press *Enter*. After that, Maven will ask you for the version
    of the project:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的数字可能因您的安装而异。无论是什么，接受建议并按 *Enter* 键。之后，Maven 将询问项目的版本：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Select the `1.0` version that is listed as number `5`. The next thing Maven
    asks for is the group ID and the artifact ID of the project. The dependency management
    that we will discuss later uses these. I selected a group ID based on the book
    and the publisher. The artifact of the project is `SortTutorial` as we will start
    our chapter example in this project.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 选择列表中编号为 `5` 的 `1.0` 版本。接下来，Maven 会询问项目的组 ID 和工件 ID。我们将在后面讨论的依赖关系管理使用这些信息。我根据书籍和出版社选择了组
    ID。项目的工件是 `SortTutorial`，因为我们将从这个项目的章节示例开始。
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The next question is the current version of the project. We have already selected
    `1.0` and Maven offers `1.0-SNAPSHOT`. Here, I selected `1.0.0-SNAPSHOT` because
    I prefer semantic versioning.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是项目的当前版本。我们已经选择了 `1.0`，Maven 提供了 `1.0-SNAPSHOT`。在这里，我选择了 `1.0.0-SNAPSHOT`，因为我更喜欢语义版本控制。
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Semantic versioning, defined on [http://semver.org/](http://semver.org/), is
    a versioning scheme that suggests three digit version numbers as *M.m.p.* for
    *Major*, *minor*, and *patch* version numbers. This is very useful for libraries.
    You will increment the last version number if there is only a bug fix since the
    previous release. You will increment the minor number when the new release also
    contains new features, but the library is compatible with the previous version;
    in other words, any program that is using the older version can still use the
    newer version. The major release number is increased when the new version is significantly
    different from the previous one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制，定义在 [http://semver.org/](http://semver.org/) 上，是一种建议使用三位数字版本号作为 *M.m.p.*
    的版本控制方案，分别代表 *主*、*次* 和 *修补* 版本号。这对于库来说非常有用。如果自上次发布以来只有错误修复，您将增加最后一个版本号。当新版本包含新功能，但库与旧版本兼容时，您将增加次要号；换句话说，任何使用旧版本的程序仍然可以使用新版本。当新版本与旧版本有显著不同时，增加主发布号。
- en: In the case of application programs, there is no code that uses the application
    API; thus, the minor version number is not that important. It does not hurt, though,
    and it often proves to be useful to signal smaller changes in the application.
    We will discuss how to version software in the last chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序程序的情况下，没有使用应用程序 API 的代码；因此，次要版本号并不那么重要。尽管如此，它并不妨碍，而且它通常被证明是有用的，可以用来表示应用程序中的较小变化。我们将在最后一章讨论如何对软件进行版本控制。
- en: Maven handles the versions that have the `-SNAPSHOT` postfix as non-release
    versions. While we develop the code, we will have many *versions* of our code,
    all having the same snapshot version number. On the other hand, non-snapshot version
    numbers can only be used only for a single version.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 将带有 `-SNAPSHOT` 后缀的版本视为非发布版本。在我们开发代码的过程中，我们将有许多 *版本* 的代码，所有这些代码都具有相同的快照版本号。另一方面，非快照版本号只能用于单个版本。
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last question from the program skeleton generation is the name of the Java
    package. The default is the value we gave for `groupId`, and we will use this.
    It is a rare exception to use something else.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 程序骨架生成中的最后一个问题是 Java 包的名称。默认值是我们为 `groupId` 给定的值，我们将使用这个值。使用其他东西的情况很少。
- en: 'When we have specified all the parameters that are needed, the final request
    is to confirm the setting:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指定了所有需要的参数后，最后的请求是确认设置：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After entering `Y`, Maven will generate the files that are needed for the project
    and display the report about this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入 `Y` 后，Maven 将生成项目所需的文件并显示关于此的报告：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can take look at the following generated directory structure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看以下生成的目录结构：
- en: '![](img/00028.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.jpeg)'
- en: 'You can also see that it generated the following three files:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到它生成了以下三个文件：
- en: '`SortTutorial/pom.xml` that contains the **Project Object Model**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortTutorial/pom.xml` 包含 **项目对象模型**'
- en: '`SortTutorial/``src/main/java/packt/java9/by/example/App.java` that contains
    a `HelloWorld` sample application'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortTutorial/``src/main/java/packt/java9/by/example/App.java` 包含一个 `HelloWorld`
    示例应用程序'
- en: '`SortTutorial/src/test/java/packt/java9/by/example/AppTest.java` that contains
    a unit test skeleton utilizing the `junit4` library'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortTutorial/src/test/java/packt/java9/by/example/AppTest.java` 包含一个使用 `junit4`
    库的单元测试框架'
- en: 'We will discuss unit tests in the next chapter. For now, we will focus on the
    sorting application. As Maven was so kind and generated a sample class for the
    app, we can compile and run it without actual coding, just to see how we can build
    the project using Maven. Change the default directory to `SortTutorial` issuing
    `cd SortTutorial` and issue the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论单元测试。现在，我们将专注于排序应用程序。由于 Maven 非常友好，为应用程序生成了一个示例类，我们可以编译并运行它，而不需要实际编码，只是为了看看我们如何使用
    Maven 构建项目。通过执行 `cd SortTutorial` 将默认目录更改为 `SortTutorial`，然后执行以下命令：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will get the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![](img/00029.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: Maven fires up, compiles, and packages the project automatically. If not, please
    read the next info box.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 会自动启动、编译和打包项目。如果不这样做，请阅读下一个信息框。
- en: When you first start Maven, it downloads a lot of dependencies from the central
    repository. These downloads take time, and are reported on the screen, so the
    actual output may be different from what you saw in the preceding code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次启动 Maven 时，它会从中央仓库下载大量的依赖项。这些下载需要时间，并且会在屏幕上报告，所以实际的输出可能与前面代码中看到的不同。
- en: 'Maven compiles code with the default settings for Java version 1.5\. It means
    that the generated class file is compatible with Java version 1.5, and also that
    the compiler only accepts language constructs that were available already in Java
    1.5\. If we want to use newer language features, and in this book we use a lot,
    the `pom.xml` file should be edited to contain the following lines:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 使用 Java 版本 1.5 的默认设置编译代码。这意味着生成的类文件与 Java 版本 1.5 兼容，并且编译器只接受在 Java 1.5
    中已经可用的语言结构。如果我们想使用更新的语言特性，本书中我们使用了很多，那么应该编辑 `pom.xml` 文件以包含以下行：
- en: '`<build>`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`<build>`'
- en: '`    <plugins>`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`    <plugins>`'
- en: '`      <plugin>`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`      <plugin>`'
- en: '`        <groupId>org.apache.maven.plugins</groupId>`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`        <groupId>org.apache.maven.plugins</groupId>`'
- en: '`        <artifactId>maven-compiler-plugin</artifactId>`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`        <artifactId>maven-compiler-plugin</artifactId>`'
- en: '`        <configuration>`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`        <configuration>`'
- en: '`          <source>1.9</source>`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`          <source>1.9</source>`'
- en: '`          <target>1.9</target>`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`          <target>1.9</target>`'
- en: '`        </configuration>`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`        </configuration>`'
- en: '`      </plugin>`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`      </plugin>`'
- en: '`    </plugins>`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`    </plugins>`'
- en: '`  </build>`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`  </build>`'
- en: 'When using Java 9''s default settings for Maven, it becomes even more complex,
    because Java 9 does not generate class format nor restrict source compatibility
    earlier than Java 1.6\. At this very moment, as I write these lines, the latest
    Maven release is 3.3.9\. When I try to compile the preceding code without the
    modifications, the Java compiler stops with an error displaying the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Java 9 的 Maven 默认设置时，它变得更加复杂，因为 Java 9 不生成类格式，也不限制比 Java 1.6 更早的源兼容性。在我写下这些行的时候，最新的
    Maven 版本是 3.3.9。当我尝试不进行修改编译前面的代码时，Java 编译器会停止并显示以下错误：
- en: '`[ERROR] Source option 1.5 is no longer supported. Use 1.6 or later.`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ERROR] 源选项 1.5 已不再支持。请使用 1.6 或更高版本。`'
- en: '**`[ERROR] Target option 1.5 is no longer supported. Use 1.6 or later.`**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**`[ERROR] 目标选项 1.5 已不再支持。请使用 1.6 或更高版本。**`'
- en: Later, Maven releases may behave differently in the future.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以后，Maven 的发布可能会表现出不同的行为。
- en: 'Now, you can start the code using the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令开始代码：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can see the result of a sample run in the following picture:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图片中看到示例运行的输出结果：
- en: '![](img/00030.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: Gradle
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle
- en: 'Ant and Maven are two worlds, and using one or the other may lead to heated
    debates on Internet forums. Ant gives freedom to developers to create a build
    process that fits their taste. Maven restricts the team to use a build process
    that is more standard. Some special processes that do not match any standard build,
    but which are sometimes needed in some environments, are hard to implement using
    Maven. In Ant, you can script almost anything using the built-in tasks, almost
    the same way as you can program bash. Utilizing Maven is not that simple, and,
    it often requires writing a plugin. Even though writing a plugin is not rocket
    science, developers usually like to have the possibility of making things in a
    simpler way: Scripting. We have two approaches, two mindsets and styles, and not
    a single tool to fulfill all the needs. No surprise that by the Java technologies
    were developed, a new build tool was emerging.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Ant和Maven是两个世界，使用其中一个可能会导致在互联网论坛上引发激烈的争论。Ant赋予开发者创建符合自己口味的构建过程的自由。Maven则限制团队使用更标准的构建过程。某些不符合任何标准构建过程但有时在某些环境中需要的特殊过程，使用Maven很难实现。在Ant中，您可以使用内置任务几乎编写任何脚本，几乎就像您编写bash脚本一样。使用Maven并不简单，并且通常需要编写插件。尽管编写插件并非难事，但开发者通常更喜欢有以更简单的方式完成任务的可能性：脚本。我们有两种方法，两种思维方式和风格，而不是一个能满足所有需求的单一工具。因此，在Java技术发展过程中，一个新的构建工具应运而生。
- en: Gradle tries to use the best of both worlds, utilizing techniques that were
    not available by the time Maven and Ant were first developed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle试图融合两者的优点，使用在Maven和Ant最初开发时不可用的技术。
- en: Gradle has built-in targets and life cycle, but at the same time, you can also
    write your own targets. You can configure a project, just like using Maven, without
    scripting the tasks to do so, but at the same time, you can also script your own
    target just like in Ant. What is more, Gradle integrated Ant, so any task implemented
    for Ant is available for Gradle as well.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle具有内置的目标和生命周期，但与此同时，您也可以编写自己的目标。您可以通过配置项目，就像使用Maven一样，而不需要编写脚本任务来完成，但与此同时，您也可以像在Ant中一样编写自己的目标。更重要的是，Gradle集成了Ant，因此任何为Ant实现的任务也可以在Gradle中使用。
- en: Maven and Ant use XML files to describe the build. Today, XML is a technology
    of the past. We still use it, and a developer should be fluent in handling, reading,
    and writing XML files, but a *modern* tool does not use XML for configuration.
    New, fancy formats such as JSON are more popular. Gradle is no exception. The
    configuration file of Gradle uses a **domain-specific language** (**DSL**) based
    on Groovy. This language is more readable for programmers and gives more freedom
    to program build processes. And, this is also the danger of Gradle.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Maven和Ant使用XML文件来描述构建过程。如今，XML已经成为一种过时的技术。我们仍然在使用它，并且开发者应该熟练掌握处理、读取和编写XML文件，但一个*现代*的工具不会使用XML进行配置。新的、花哨的格式，如JSON，更为流行。Gradle也不例外。Gradle的配置文件使用基于Groovy的**领域特定语言**（**DSL**）。这种语言对程序员来说更易读，并为编程构建过程提供了更多自由。这也是Gradle的危险所在。
- en: Having the powerful JVM language Groovy in the hands of developers to create
    build tools gives a freedom and temptation to create complex build processes that
    seem to be a good idea at the start, but later may prove to be just too complex
    and hard, and, therefore, expensive to maintain. This is exactly why Maven was
    implemented in the first place.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将强大的JVM语言Groovy掌握在开发者手中，以创建构建工具，赋予了他们创建看似不错但后来可能证明过于复杂和难以维护的复杂构建过程的自由和诱惑。这正是Maven最初被实施的原因。
- en: I have to stop before getting into another area that is the ground for heated
    and pointless debates. Gradle is an extremely powerful build tool. You should
    use it carefully, just like you would use a weapon—don't shoot your legs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入另一个可能引发激烈且无意义的争论的领域之前，我必须停下来。Gradle是一个非常强大的构建工具。您应该小心使用它，就像您使用武器一样——不要射击自己的腿。
- en: Installing Gradle
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Gradle
- en: To install Gradle, you will have to download the compiled binaries from the
    [https://gradle.org/gradle-download/](https://gradle.org/gradle-download/) website.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Gradle，您需要从[https://gradle.org/gradle-download/](https://gradle.org/gradle-download/)网站下载编译后的二进制文件。
- en: Again, I'd like to emphasize the importance of checking the download integrity
    using checksums. I have given a detailed way to do it in the section about Ant
    installation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用校验和检查下载完整性非常重要。我在关于Ant安装的部分中给出了详细的操作方法。
- en: Unfortunately, the Gradle website does not provide the checksum values for the
    downloadable files.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Gradle 网站没有提供可下载文件的校验和值。
- en: 'Gradle is downloadable in the ZIP format. To unpack the file, you will have
    to use the unzip command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 可以以 ZIP 格式下载。要解压文件，您必须使用 unzip 命令：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The created subdirectory is the usable binary distribution of Gradle. Usually,
    I move it under `~/bin`, making it available only for my user on OS X. After that,
    you should add the `bin` directory of the installation to the `PATH`. To do that,
    you should edit the `~/.bashrc` file and add the following lines:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的子目录是 Gradle 的可用二进制发行版。通常，我会将它移动到 `~/bin` 目录下，使其仅对我的 OS X 用户可用。之后，您应该将安装的
    `bin` 目录添加到 `PATH` 中。为此，您应该编辑 `~/.bashrc` 文件并添加以下行：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, restart the terminal application, or just type `. ~/.bashrc` and test
    the installation of Gradle, typing the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新启动终端应用程序，或者只需输入 `. ~/.bashrc` 并测试 Gradle 的安装，输入以下内容：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We get to the following output, as can be seen in this screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出，如这个截图所示：
- en: '![](img/00031.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00031.jpeg)'
- en: Setting up the project with Maven
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven 设置项目
- en: 'To start the project, we will use the directory structure and `pom.xml` that
    was created by Maven itself when we started with the following command line:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动项目，我们将使用 Maven 在以下命令行启动时创建的目录结构和 `pom.xml` 文件：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It created the directories, the `pom.xml` file, and an `App.java` file. Now,
    we will extend this project by creating new files. We will code the sorting algorithm
    first in the `packt.java9.by.example.stringsort` package:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了目录，`pom.xml` 文件和 `App.java` 文件。现在，我们将通过创建新文件来扩展这个项目。我们首先将在 `packt.java9.by.example.stringsort`
    包中编写排序算法的代码：
- en: '![](img/00032.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00032.jpeg)'
- en: 'When we create the new package in the IDE, the editor will automatically create
    the `stringsort` subdirectory under the already existing `src/main/java/packt/java9/by/example`
    directory:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 IDE 中创建新包时，编辑器将自动在已存在的 `src/main/java/packt/java9/by/example` 目录下创建 `stringsort`
    子目录：
- en: '![](img/00033.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00033.jpeg)'
- en: 'Creating the new `Sort` class using the IDE will also automatically create
    a new file named `Sort.java` in this directory, and it will fill in the skeleton
    of the class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDE 创建新的 `Sort` 类也会自动在这个目录下创建一个名为 `Sort.java` 的新文件，并填充类的骨架：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will now have `App.java` containing the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将拥有包含以下代码的 `App.java`：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Maven created it as a starting version. We will edit this file to provide a
    sample list that the sorting algorithm can sort. I recommend that you use the
    IDE to edit the file and also to compile and run the code. The IDE provides a
    shortcut menu to start the code and this is a bit easier than typing the command
    in Terminal. Generally, it is recommended that you get acquainted with the IDE
    features to save time avoiding repetitive tasks, such as typing terminal commands.
    Professional developers use the command line almost exclusively to test command-line
    features and use the IDE whenever it is possible.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 以起始版本创建了它。我们将编辑这个文件以提供一个排序算法可以排序的样本列表。我建议您使用 IDE 编辑文件，并编译和运行代码。IDE 提供了一个快捷菜单来启动代码，这比在终端中输入命令要简单一些。通常，建议您熟悉
    IDE 功能以节省时间，避免重复性任务，例如输入终端命令。专业开发者几乎只使用命令行来测试命令行功能，并在可能的情况下使用 IDE。
- en: '![](img/00034.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00034.jpeg)'
- en: Coding the sort
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写排序代码
- en: Maven and the IDE created the files for the sort program. They form the skeleton
    for our code, and now it is time to grow some muscles on them to let it move.
    We spent quite some time to set up the project by visiting the different build
    tools, only to learn how to compile the code. I hope that this did not distract
    you much, but anyhow, we deserve to see some real code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 和 IDE 为排序程序创建了文件。它们形成了我们代码的骨架，现在是我们让它们变得有肌肉的时候了。我们花费了相当多的时间通过访问不同的构建工具来设置项目，只是为了学习如何编译代码。我希望这没有让您分心太多，但无论如何，我们应看到一些真正的代码。
- en: First, we will create the code for the sorting code, and after that, the code
    that invokes the sorting. The code that invokes the sorting is a kind of testing
    code. For simplicity, we will now simply use a `public static void main` method
    to start the code. We will use the test framework in later chapters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写排序代码，然后编写调用排序的代码。调用排序的代码是一种测试代码。为了简单起见，我们现在将简单地使用 `public static void
    main` 方法来启动代码。我们将在后面的章节中使用测试框架。
- en: 'As for now, the code for the sorting will look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，排序的代码将看起来像这样：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the class that does the sorting. There is only one method in this class
    that does the sorting. The argument to the method is an array containing the strings,
    and the method sorts this array. The method has no return value. This is denoted
    in the declaration using the pseudo type `void`. Methods use their arguments to
    perform some tasks, and may return one value. The arguments to the method are
    passed by value, which means that the method cannot modify the variable passed
    as argument. However, it can modify the objects the arguments contain. In this
    case, the array is modified and we will sort it. On the other hand, the `actualNames`
    variable will point to the same array and the `sort` method cannot do anything
    to make this variable point to a different array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个执行排序的类。这个类中只有一个方法用于排序。该方法接受一个包含字符串的数组作为参数，并对这个数组进行排序。这个方法没有返回值。在声明中，这通过伪类型`void`表示。方法使用它们的参数执行一些任务，并且可能返回一个值。方法的参数是通过值传递的，这意味着方法不能修改作为参数传递的变量。然而，它可以修改参数包含的对象。在这种情况下，数组将被修改，我们将对其进行排序。另一方面，`actualNames`变量将指向同一个数组，而`sort`方法无法做任何操作来使这个变量指向不同的数组。
- en: There is no `main` method in this class, which means that it cannot be started
    from the command line on its own. This class can only be used from some other
    class, as every Java program should have a class that has a `public static void
    main` method that we created separately.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中没有`main`方法，这意味着它不能从命令行自行启动。这个类只能从其他类中使用，因为每个Java程序都应该有一个包含`public static
    void main`方法的类，这是我们单独创建的。
- en: I could also put a `main` method into the class to make it executable, but that
    is not a good practice. Real programs are composed of many classes, and one class
    should not do many things. Rather, it's the opposite. The s*ingle responsibility
    principle* says that a single class should be responsible for one single thing;
    therefore, `class sort` does the sorting. Executing the application is a different
    task, and thus it has to be implemented in a different class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以在类中放入一个`main`方法使其可执行，但这不是好的做法。真正的程序由许多类组成，一个类不应该做很多事情。相反，应该是相反的。*单一职责原则*指出，一个类应该只负责一件事情；因此，`class
    sort`执行排序。执行应用程序是不同的任务，因此它必须在不同的类中实现。
- en: Often, we do not implement the class containing the `main` method. Often, a
    framework provides it. For example, writing a *servlet* that runs in a servlet
    container requires containing a class that implements the `javax.servlet.Servlet`
    interface. In this case, the program seemingly does not have a `main` method.
    The actual implementation of the servlet container does. The Java command line
    starts the container and the container loads the servlets when they are needed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会实现包含`main`方法的类。通常，一个框架会提供它。例如，编写在servlet容器中运行的*servlet*需要包含一个实现`javax.servlet.Servlet`接口的类。在这种情况下，程序表面上没有`main`方法。servlet容器的实际实现有。Java命令行启动容器，容器在需要时加载servlets。
- en: 'In the following example code, we implemented the `App` class containing the
    `main` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例代码中，我们实现了包含`main`方法的`App`类：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code contains a string array initialized to contain constant values, creates
    a new instance of the `Sort` class, invokes the `sort` method, and then prints
    out the code to the standard output.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含一个初始化为包含常量值的字符串数组，创建了一个`Sort`类的新实例，调用了`sort`方法，然后将其打印到标准输出。
- en: In real programs, we almost never have such constants in program codes; we put
    them into resource files and have some code to read the actual values. This separates
    the code from data and eases maintenance, eliminating the risk of accidental modification
    of code structure when only the data is to be changed. Similarly, we will almost
    never write anything to standard output using `System.out`. Usually, we will use
    logging possibilities that are available from different sources. There are different
    libraries that provide logging functionalities and logging is also available from
    the JDK itself.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正的程序中，我们几乎从不将这样的常量放在程序代码中；我们将它们放入资源文件中，并有一些代码来读取实际的值。这使代码与数据分离，便于维护，消除了仅更改数据时意外修改代码结构的风险。同样，我们几乎不会使用`System.out`将任何内容写入标准输出。通常，我们将使用来自不同来源的日志记录可能性。有不同库提供日志记录功能，日志记录也可以从JDK本身获得。
- en: 'As for now, we will focus on simple solutions so as to not distract your focus
    from Java by the plethora of different libraries and tools. In the following section,
    we will look at the Java language constructs that we used to code the algorithm.
    First, we will look at them generally, and then, in a bit more detail. These language
    features are not independent of each other: one builds up on the other, and therefore,
    the explanation will first be general, and we will go into details in the subsections.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 至今为止，我们将专注于简单的解决方案，以免不同库和工具的众多选择分散你对Java的注意力。在下一节中，我们将查看我们用来编写算法的Java语言结构。首先，我们将一般地查看它们，然后，在更详细地查看。这些语言特性不是相互独立的：一个建立在另一个之上，因此，解释将首先是一般的，我们将在子节中深入细节。
- en: Understanding the algorithm and language constructs
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解算法和语言结构
- en: 'The algorithm was explained at the start of the chapter. The implementation
    is in the `Sort` class inside the `sort` method, and it is only a few lines:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在章节的开始处已经解释过了。实现位于`Sort`类中的`sort`方法内，并且只有几行代码：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `n` variable holds the length of the array at the start of the sorting.
    Arrays in Java always have a property that gives the length and it is called `length`.
    When we start the sorting, we will go from the start of the array to the end of
    it and, as you may recall, the last element, *Wilson*, will walk up to the last
    position during this first iteration. Subsequent iterations will be shorter and,
    therefore, the variable `n` will be decreased.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`n`变量在排序开始时持有数组的长度。Java中的数组总是有一个属性来给出长度，这个属性叫做`length`。当我们开始排序时，我们将从数组的开始到结束进行遍历，正如你可能记得的，最后一个元素，*Wilson*，将在第一次迭代中走到最后一个位置。后续的迭代将会更短，因此变量`n`将会减少。'
- en: Blocks
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块
- en: The code in Java is created in code blocks. Anything that is between the `{`
    and `}` characters is a block. In the preceding example, the code of the method
    is a block. It contains commands, and some of them, like the `while` loop, also
    contain a block. Inside that block, there are two commands. One of them is a `for`
    loop, again with a block. Although we can have single expressions to form the
    body of a loop, we usually use blocks. We will discuss loops in detail in just
    a few pages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的代码是在代码块中创建的。任何位于`{`和`}`字符之间的内容都是一个块。在上一个示例中，方法的代码就是一个块。它包含命令，其中一些命令，如`while`循环，也包含一个块。在这个块内部，有两个命令。其中一个是`for`循环，同样包含一个块。虽然我们可以使用单个表达式来形成循环体，但我们通常使用块。我们将在接下来的几页中详细讨论循环。
- en: As we could see in the preceding example, the loops can be nested, and thus
    the `{` and `}` characters form pairs. A block can be inside another block, but
    two blocks cannot overlap. When the code contains a `}` character, it is closing
    the block that was opened last.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个示例中所看到的，循环可以嵌套，因此`{`和`}`字符形成一对。一个块可以位于另一个块内部，但两个块不能重叠。当代码包含一个`}`字符时，它是在关闭最后打开的块。
- en: Variables
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: In Java, just like in almost any programming language, we use variables. The
    variables in Java are typed. It means that a variable can hold a value of a single
    type. It is not possible for a variable to hold an `int` type at some point in
    the program and later a `String` type. When variables are declared, their type
    is written in front of the variable name.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，就像在几乎任何编程语言中一样，我们使用变量。Java中的变量是有类型的。这意味着一个变量只能持有单一类型的值。在程序中的某个时刻，一个变量不能同时持有`int`类型和`String`类型。当声明变量时，它们的类型会写在变量名之前。
- en: Variables also have visibility scope. Local variables in methods can only be
    used inside the block in which they are defined. A variable can be used inside
    methods or they can belong to a class or an object. To differentiate the two,
    we usually call these variables *fields*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也有可见作用域。方法中的局部变量只能在其定义的块内部使用。变量可以在方法中使用，或者它们可以属于一个类或一个对象。为了区分这两种，我们通常将这些变量称为*字段*。
- en: Types
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Each variable has one type. In Java, there are two major groups of type: primitive
    and reference types. The primitive types are predefined, and you cannot define
    or create a new primitive type. There are eight primitive types: `byte`, `short`,
    `int`, `long`, `float`, `double`, `boolean`, and `char`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都有一个类型。在Java中，主要有两大类型组：原始类型和引用类型。原始类型是预定义的，你不能定义或创建一个新的原始类型。有八个原始类型：`byte`、`short`、`int`、`long`、`float`、`double`、`boolean`和`char`。
- en: The first four types, `byte`, `short`, `int`, and `long`, are signed numeric
    integer types, capable of storing positive and negative numbers on 8, 16, 32,
    and 64 bits.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 前四种类型，`byte`、`short`、`int` 和 `long`，是有符号的数值整数类型，能够在 8、16、32 和 64 位上存储正数和负数。
- en: The `float` and `double` types store floating point numbers on 32 and 64 bits
    in the IEEE 754 floating-point format.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`float` 和 `double` 类型在 IEEE 754 浮点格式上以 32 位和 64 位存储浮点数。'
- en: The `boolean` type is a primitive type that can only be `true` or `false`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 类型是一种原始类型，它只能是 `true` 或 `false`。'
- en: The `char` type is a character data type that stores a single 16-bit Unicode
    character.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 类型是一种字符数据类型，存储单个 16 位 Unicode 字符。'
- en: 'For each primitive type, there is a class that can store the same type of value.
    When a primitive type has to be converted to the matching class type it is done
    automatically. It is called auto boxing. These types are `Byte`, `Short`, `Integer`,
    `Long`, `Float`, `Double`, `Boolean`, and `Character`. Take, for example, the
    following variable declaration:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种原始类型，都有一个可以存储相同类型值的类。当一个原始类型需要转换为相应的类类型时，这是自动完成的。这被称为自动装箱。这些类型包括 `Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Boolean`
    和 `Character`。以以下变量声明为例：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This converts the value `113`, which is an `int` number, to an `Integer` object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值 `113`，它是一个 `int` 数字，转换为 `Integer` 对象。
- en: 'These types are part of the runtime, and also part of the language. Although
    there is no primitive counterpart of it, there is a very important and ubiquitous
    class that we have already used: `String`. A string contains characters.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型是运行时的一部分，也是语言的一部分。尽管没有它的原始对应类型，但有一个非常重要且无处不在的类，我们已经在使用它了：`String`。字符串包含字符。
- en: The major differences between primitive types and objects are that primitive
    types cannot be used to invoke methods, but they consume less memory. The difference
    between the memory consumption and its consequences for speed is important in
    the case of arrays.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型和对象之间的主要区别是，原始类型不能用来调用方法，但它们消耗的内存更少。在数组的情况下，内存消耗及其对速度的影响非常重要。
- en: Arrays
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Variables can be a primitive type according to their declaration, or they may
    hold a reference to an object. A special object type is an array. When a variable
    holds a reference to an array, then it can be indexed with the `[` and `]` characters,
    along with an integral value consisting of 0 or a positive value ranging to one
    less than the array's length, to access a certain element of the array. Multi-dimensional
    arrays are also supported by Java when an array has elements that are also arrays.
    Arrays are indexed from zero in Java. Under or over indexing is checked at runtime,
    and the result is an exception.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以是原始类型，根据其声明，或者它们可能持有对象的引用。一个特殊的对象类型是数组。当一个变量持有数组的引用时，它可以使用 `[` 和 `]` 字符以及一个由
    0 或一个正值组成的整数值（该值小于数组的长度），来访问数组的特定元素。Java 支持多维数组，当数组有也是数组的元素时。Java 中的数组从零开始索引。在运行时检查下标越界，结果是异常。
- en: An exception is special condition that interrupts the normal execution flow
    and stops the execution of the code or jumps to the closest enclosing `catch`
    statement. We will discuss exceptions and how to handle them in the next chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是特殊条件，它中断了正常的执行流程，并停止代码的执行或跳转到最近的 `catch` 语句。我们将在下一章讨论异常及其处理方法。
- en: When a code has an array of a primitive type, the array contains many memory
    slots, each holding the value of the type. When the array has a reference type,
    in other words, when it is an array of objects, then the array elements are references
    to objects, each containing the type. In the case of `int` for example, each element
    of the array is 32-bit, which is 4 bytes. If the array is a type of `Integer`,
    then the elements are references to objects, pointers, so to say, which is usually
    64-bit using 64-bit JVM and 32-bit on 32-bit JVM. In addition to that, there is
    an `Integer` object somewhere in memory that contains the 4-byte value and also
    an object header that may be as much as 24 bytes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码有一个原始类型的数组时，数组包含许多内存槽，每个槽存储该类型的值。当数组是引用类型时，换句话说，当它是一个对象数组时，那么数组元素是对象的引用，每个对象包含该类型。以
    `int` 为例，数组的每个元素是 32 位，即 4 字节。如果数组是 `Integer` 类型，那么元素是对象的引用，可以说是指针，通常在 64 位 JVM
    上是 64 位，在 32 位 JVM 上是 32 位。此外，还有一个包含 4 字节值的 `Integer` 对象存储在内存中，还有一个可能多达 24 字节的对象头。
- en: The actual size of the extra information needed to administer each object is
    not defined in the standard. It may be different on different implementations
    of the JVM. The actual coding, or even the optimization of the code in an environment,
    should not depend on the actual size. However, the developers should be aware
    that this overhead exists and is in the range of around 20 or so bytes for every
    object. Objects are expensive in terms of memory consumption.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 管理每个对象所需额外信息的实际大小在标准中未定义。在不同的 JVM 实现中可能不同。实际的编码，甚至是在某个环境中的代码优化，都不应依赖于实际的大小。然而，开发者应该意识到这种开销存在，并且每个对象大约在
    20 个字节左右。从内存消耗的角度来看，对象是昂贵的。
- en: Memory consumption is one issue, but there is something else. When the program
    works with a large amount of data and the work needs the consecutive elements
    of the array, then the CPU loads a chunk of memory into the processor cache. It
    means that the CPU can access elements of the array that are consecutively faster.
    If the array is of a primitive type, it is fast. If the array is of some class
    type, then the CPU has to access memory to get the actual value, which may be
    as much as 50 times slower.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 内存消耗是一个问题，但还有其他问题。当程序处理大量数据并且工作需要数组的连续元素时，CPU 会将一大块内存加载到处理器缓存中。这意味着 CPU 可以更快地访问数组的连续元素。如果数组是原始类型，那么它很快。如果数组是某些类类型，那么
    CPU 必须访问内存以获取实际值，这可能会慢 50 倍。
- en: Expressions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: 'Expressions in Java are very much like in other programming languages. You
    can use the operators that may be similar from languages such as C or C++. They
    are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的表达式与其他编程语言非常相似。你可以使用类似于 C 或 C++ 这样的语言中的运算符。它们如下所示：
- en: Unary prefix and postfix increment operators (` --` and `++` before and after
    a variable)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元前缀和后缀增量运算符 (`--` 和 `++` 在变量前后)
- en: Unary sign (`+` and `-`) operators
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元符号 (`+` 和 `-`) 运算符
- en: Logical (`!`) and bitwise (`~`) negation
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑 (`!`) 和位运算 (`~`) 取反
- en: Multiplication (`*`), division (`/`), and modulo (`%`)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法 (`*`), 除法 (`/`), 和取模 (`%`)
- en: Addition and subtraction (`+` and - again, but this time as binary operators)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法和减法 (`+` 和 - 再次，但这次作为二元运算符)
- en: Shift operators move the values bitwise, and there is left (`<<`) and right
    (`>>`) shift and unsigned right shift (`>>>`)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移位运算符将值按位移动，有左 (`<<`) 和右 (`>>`) 移位，以及无符号右移 (`>>>`)
- en: The comparing operators are `<`, `>`, `<=`, `>=`, `==`, `!=` and `instanceof`
    that result in `boolean` value
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符是 `<`, `>`, `<=`, `>=`, `==`, `!=` 和 `instanceof`，它们的结果是 `boolean` 值
- en: There are bitwise or (`|`), and (`&`), exclusive or (`^`) operators, and similarly
    logical or (`||`), and (`&&`) operators
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有按位或 (`|`), 与 (`&`), 异或 (`^`) 运算符，以及类似的逻辑或 (`||`), 与 (`&&`) 运算符
- en: When logical operators are evaluated, they are shortcut evaluated. It means
    the right-hand operand is evaluated only if the result cannot be identified from
    the result of the left operand.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当逻辑运算符被评估时，它们是短路评估。这意味着只有当无法从左操作数的结果中识别出结果时，才会评估右操作数。
- en: 'The ternary operator is also similar to the one, like it is on C, selecting
    from one of the expressions based on some condition: `condition ? expression 1
    : expression 2`. Usually, there is no problem with the ternary operator, but sometimes
    you have to be careful as there is a complex rule controlling the type conversions
    in case the two expressions are not of the same type. It''s always better to have
    the two expressions be of the same type.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '三元运算符与 C 语言中的类似，根据某些条件从表达式中选择一个：`condition ? expression 1 : expression 2`。通常，三元运算符没有问题，但有时你必须小心，因为当两个表达式不是同一类型时，有一个复杂的规则控制类型转换。最好让两个表达式具有相同的类型。'
- en: Finally, there is an assignment operator (`=`) that assigns the value of an
    expression to a variable. For each binary operator, there is an assignment version
    that combines `=` with a binary operator to perform an operation involving the
    right operand and assign the result to the left operand, which must be a variable.
    These are `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `^=`, `|=`, `<<=`, `>>=`, and `>>>=`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个赋值运算符 (`=`)，它将表达式的值赋给一个变量。对于每个二元运算符，都有一个赋值版本，它将 `=` 与二元运算符组合起来执行涉及右操作数的操作，并将结果赋给左操作数，该操作数必须是变量。这些是
    `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `^=`, `|=`, `<<=`, `>>=`, 和 `>>>=`。
- en: The operators have precedence and can be overridden by parentheses, as usual.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符有优先级，并且可以通过括号覆盖，就像通常一样。
- en: 'An important part of expressions is invoking methods. Static methods can be
    invoked by the name of the class and the name of the method. For example, to calculate
    the sine of 1.22, we can write the following line:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的一个重要部分是调用方法。可以通过类名和方法名来调用静态方法。例如，为了计算 1.22 的正弦值，我们可以编写以下行：
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, `Math` is the class from the package `java.lang`. The method `sin` is
    invoked without using any instance of `Math`. This method is `static`, and it
    is not likely that we will ever need any other implementation of it than the one
    provided in the class `Math`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Math` 是来自 `java.lang` 包的类。方法 `sin` 是在不使用 `Math` 的任何实例的情况下调用的。这个方法是 `static`
    的，我们不太可能需要 `Math` 类中提供的其他实现。
- en: 'Non-static methods can be invoked using an instance and the name of the method
    with a dot separating the two. For example, take the following code line as an
    example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用实例和方法的名称来调用非静态方法，方法名称之间用点分隔。例如，以下代码行是一个例子：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code uses an instance of the class `PrintStream` that is readily
    available through a static field in the class `System`. This variable is called
    `out`, and when we write our code, we have to reference it as `System.out`. The
    method `println` is defined in the class `PrintStream` and we invoke it on the
    object referenced by the variable `out`. This example also shows that static fields
    can also be referenced through the name of the class and the field separated by
    a dot. Similarly, when we need to reference a non-static field, we can do it through
    an instance of the class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了一个 `PrintStream` 类的实例，这个实例可以通过 `System` 类中的一个静态字段轻松获得。这个变量被称为 `out`，当我们编写代码时，我们必须将其引用为
    `System.out`。`println` 方法是在 `PrintStream` 类中定义的，我们通过变量 `out` 引用的对象来调用它。这个例子还表明，静态字段也可以通过类名和字段名之间用点分隔的方式来引用。同样，当我们需要引用非静态字段时，我们可以通过类的实例来引用。
- en: Static methods defined in the same class from where it is invoked or inherited
    can be invoked without the class name. Invoking a non-static method defined in
    the same class or being inherited can be invoked without an instance. In this
    case, the instance is the current object the execution is in. This object is also
    available through the `this` keyword. Similarly, when we use a field of the same
    class where our code is, we simply use the name. In case of a static field, the
    class we are in by default. In the case of a non-static field, the instance is
    the object referenced by the `this` keyword.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一类中定义的静态方法，或者是从该类继承而来的类中定义的静态方法，可以在不使用类名的情况下调用。在同一个类或继承的类中定义的非静态方法，可以在没有实例的情况下调用。在这种情况下，实例是执行中的当前对象。这个对象也可以通过
    `this` 关键字来访问。同样，当我们使用与我们的代码相同的类的字段时，我们只需使用名称。在静态字段的情况下，默认情况下我们所在的类。在非静态字段的情况下，实例是由
    `this` 关键字引用的对象。
- en: You can also import a static method into your code using the `import``static`
    language feature, in which case you can invoke the method without the name of
    the class.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `import static` 语言特性将静态方法导入到您的代码中，在这种情况下，您可以在不使用类名的情况下调用该方法。
- en: The arguments of the method calls are separated using commas. Methods and method
    argument passing is an important topic that we will mention in detail in a separate
    subsection.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用参数之间使用逗号分隔。方法和方法参数传递是我们将在单独的小节中详细讨论的重要主题。
- en: Loops
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'The `for` loop inside the `while` loop will go through all the elements from
    the first (indexed with zero in Java) up till the last (indexed with `n-1`). Generally,
    the `for` loop has the same syntax as in C:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环内部的 `for` 循环将遍历从第一个（在 Java 中用零索引）到最后一个（在 Java 中用 `n-1` 索引）的所有元素。通常，`for`
    循环的语法与 C 语言中的相同：'
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, the initial expression is evaluated. It may contain variable declaration,
    as in our example. The variable `j` in the preceding example is visible only inside
    the block of the loop. After this, the condition is evaluated, and after each
    execution of the block, the increment expression is executed. The loop repeats
    so long as the condition is true. If the condition is false right after the execution
    of the initial expression, the loop does not execute at all. The block is a list
    of commands separated by semicolons and enclosed between the `{` and `}` characters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，评估初始表达式。它可能包含变量声明，如我们的例子所示。在先前的例子中，变量 `j` 只在循环的块内部可见。之后，评估条件，并在每次执行块之后执行增量表达式。只要条件为真，循环就会重复。如果条件在执行初始表达式后立即为假，则循环根本不会执行。块是由分号分隔的命令列表，并用
    `{` 和 `}` 字符括起来。
- en: Instead of `{` and `}`, enclosed block Java lets you use a single command following
    the head of the `for` loop. The same is true in the case of the `while` loop,
    and also for the `if...else` constructs. Practice shows that this is not something
    a professional should use. Professional code always uses curly braces, even when
    there is only a single command where the block is in place. This prevents the
    dangling `else` problem and generally makes the code more readable. This is similar
    to many C-like languages. Most of them allow a single command at these places,
    and professional programmers avoid using a single command in these languages for
    readability purposes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `{` 和 `}` 包围的代码块不同，Java 允许你在 `for` 循环的头部之后使用单个命令。在 `while` 循环的情况下也是如此，以及 `if...else`
    构造。实践表明，这并不是专业人士应该使用的东西。专业的代码总是使用大括号，即使在只有单个命令的地方也是如此。这防止了悬挂的 `else` 问题，并且通常使代码更易于阅读。这与许多类似
    C 的语言相似。它们中的大多数在这些地方允许使用单个命令，而专业的程序员为了避免可读性，在这些语言中避免使用单个命令。
- en: It is ironic that the only language that strictly requires the use of the `{`
    and `}` braces at these places is Perl—the one language infamous for unreadable
    code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种讽刺，唯一严格要求在这些地方使用 `{` 和 `}` 大括号的编程语言是 Perl——这种语言以其难以阅读的代码而闻名。
- en: 'The loop in the `for (int j = 0; j < n - 1; j++) {` sample starts from zero
    and goes to `n-2`. Writing `j < n-1` is the same, in this case, as `j <= n-2`.
    We will limit `j` to stop in the loop before the end of the section of the array,
    because we reach beyond the index `j` by one comparing and conditionally swapping
    the elements indexed by `j` and `j+1`. If we went one element further, we would
    try to access an element of the array that does not exist, and it would cause
    a runtime exception. Try and modify the loop condition to `j < n` or `j <= n-1`
    and you will get the following error message:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for (int j = 0; j < n - 1; j++) {` 样例中，循环从零开始，到 `n-2` 结束。在这种情况下，写 `j < n-1`
    与 `j <= n-2` 是相同的。我们将限制 `j` 在到达数组末尾之前停止循环，因为我们通过比较和有条件地交换索引为 `j` 和 `j+1` 的元素时，已经越过了索引
    `j`。如果我们再走一步，我们就会尝试访问一个不存在的数组元素，这将导致运行时异常。尝试将循环条件修改为 `j < n` 或 `j <= n-1`，你将得到以下错误信息：
- en: '![](img/00035.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00035.jpeg)'
- en: It is an important feature of Java that the runtime checks memory access and
    throws an exception in the case of bad array indexing. In the good old days, while
    coding in C, often, we faced unexplainable errors that stopped our code much later
    and at totally different code locations from where the real error was. Array index
    in C silently corrupted the memory. Java stops you as soon as you make a mistake.
    It follows the *fail-fast* approach that you also should use in your code. If
    something is wrong, the program should fail. No code should try to live with or
    overcome an error that comes from a coding error. Coding errors should be fixed
    before they cause even more damage.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Java 的重要特性，运行时会检查内存访问，并在出现不良数组索引的情况下抛出异常。在那些美好的旧日子里，当我们用 C 语言编码时，我们经常遇到无法解释的错误，这些错误在代码的完全不同的位置停止了我们的代码，而真正的错误却在那里。C
    语言中的数组索引在无声中破坏了内存。Java 会在你犯错时立即阻止你。它遵循了 *fail-fast* 方法，你也在你的代码中应该使用这种方法。如果有什么问题，程序应该失败。没有任何代码应该试图忍受或克服来自编码错误的错误。编码错误应该在它们造成更多损害之前得到修复。
- en: 'There are also two more loop constructs in Java: the `while` loop and the `do`
    loop. The example contains a `while` loop: it is the outer loop that runs so long
    as there are at least two elements that may need swapping in the array:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中还有两个额外的循环结构：`while` 循环和 `do` 循环。示例中包含一个 `while` 循环：它是外层循环，只要数组中至少有两个可能需要交换的元素就会运行：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The general syntax and semantics of the `while` loop is very simple, as seen
    here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如此可见，`while` 循环的通用语法和语义非常简单：
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Repeat the execution of the block so long as the condition is true. If the
    condition is not true at the very start of the loop, then do not execute the block
    at all. The `do` loop is also similar, but it checks the condition *after* each
    execution of the block:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 只要条件为真，就重复执行该块。如果循环开始时条件不为真，则根本不执行该块。`do` 循环也类似，但它是在每次执行块之后检查条件的：
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For some reason, programmers rarely use `do` loops.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，程序员很少使用 `do` 循环。
- en: Conditional execution
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件执行
- en: The heart of the sort is the condition and the value swapping inside the loop.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 排序的核心是循环中的条件和值交换。
- en: '[PRE37]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There is only one conditional command in Java, the `if` command. It has the
    following format:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中只有一个条件命令，即 `if` 命令。它具有以下格式：
- en: '[PRE38]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The meaning of the code structure is quite straightforward. If the condition
    is true, then the first block is executed, otherwise, the second block is executed.
    The `else` keyword, along with the second block, is optional. If there is nothing
    to be executed in case that the condition is false, then there is no need for
    the else branch, just like in the example. If the array element indexed with `j`
    is later in the sort order than the element `j+1,` then we swap them, but if they
    are already in order, there is nothing to do with them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 代码结构的含义非常直接。如果条件为真，则执行第一个块，否则执行第二个块。`else`关键字以及第二个块是可选的。如果条件为假时没有要执行的代码，那么就不需要`else`分支，就像示例中那样。如果用`j`索引的数组元素在排序顺序上比`j+1`的元素靠后，那么我们就交换它们，但如果它们已经是有序的，就没有必要对它们做任何事情。
- en: To swap the two array elements, we will use a temporary variable named `tmp`.
    The type of this variable is `String`, and this variable is declared to be `final`.
    The `final` keyword has different meanings depending on where it is used in Java.
    This may be confusing for beginners unless you are warned about it, just like
    now. A `final` class or method is a totally different thing than a `final` field,
    which is again different than a `final` local variable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了交换两个数组元素，我们将使用一个名为`tmp`的临时变量。这个变量的类型是`String`，并且这个变量被声明为`final`。`final`关键字在Java中的使用位置不同，其含义也不同。除非你被警告，否则这可能会让初学者感到困惑，就像现在这样。一个`final`类或方法与一个`final`字段完全不同，而`final`字段又与`final`局部变量不同。
- en: Final variables
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`final`变量'
- en: In our case, `tmp` is a `final` local variable. The scope of this variable is
    limited to the block following the `if` statement, and inside this block, this
    variable gets a value only once. The block is executed many times during the code
    execution, and each time the variable gets into scope, it gets a value. However,
    this value cannot be changed in the block. This may be a bit confusing. You can
    think about it as having a new `tmp` each time the block executes. The variable
    gets declared and has an undefined value and can get a value only once.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`tmp`是一个`final`局部变量。这个变量的作用域仅限于`if`语句之后的块，并且在这个块内部，这个变量只获得一次值。这个块在代码执行期间会执行多次，每次变量进入作用域时，它都会获得一个值。然而，这个值在块内不能被改变。这可能会有些令人困惑。你可以把它想象成每次块执行时都有一个新的`tmp`。变量被声明并具有未定义的值，并且只能获得一次值。
- en: Final local variables do not need to get the value where they are declared.
    You can assign a value to a `final` variable some time later. It is important
    that there should not be a code execution that assigns a value to a `final` variable
    that was already assigned a value before. The compiler checks it and does not
    compile the code if there is a possibility of the reassignment of a `final` variable.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最终局部变量不需要在声明的地方获取值。你可以在稍后某个时间点为`final`变量赋值。重要的是不应该有代码执行将值赋给已经赋过值的`final`变量。编译器会检查这一点，如果存在`final`变量被重新赋值的可能性，则不会编译代码。
- en: To declare a variable to be final is generally to ease readability of the code.
    When you see a variable in a code declared to be `final`, you can assume that
    the value of the variable will not change and the meaning of the variable will
    always be the same wherever it was used in the method. It will also help you avoid
    some bugs when you try to modify some `final` variables and the IDE will immediately
    complain about it. In such situations, it is likely to be a programming mistake
    that is discovered extremely early.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个变量为`final`通常是为了提高代码的可读性。当你看到代码中声明的`final`变量时，你可以假设变量的值不会改变，并且变量的意义在方法中任何使用的地方都将保持一致。这也有助于你在尝试修改某些`final`变量时避免一些错误，IDE会立即对此提出警告。在这种情况下，这很可能是编程错误，而且会在非常早期被发现。
- en: In principle, it is possible to write a program where all variables are `final`.
    It is generally a good practice to declare all `final` variables that can be declared
    to be `final` and, in case some variable may not be declared `final`, then try
    to find some way of coding the method a bit differently.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，可以编写一个所有变量都是`final`的程序。通常，将所有可以声明为`final`的变量声明为`final`是一个好的实践。如果某些变量可能不会被声明为`final`，那么尝试以不同的方式编写方法。
- en: If you need to introduce a new variable to do that, it probably means you were
    using one variable to store two different things. These things are of the same
    type and stored in the same variable at different times but, logically, they still
    are different things. Do not try to optimize the use of variables. Never use a
    variable because you already have a variable of the type in your code that is
    available. If it is logically a different thing, then declare a new variable.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要引入一个新变量来完成这个任务，这可能意味着你正在使用一个变量来存储两件不同的事情。这些事情在逻辑上仍然是不同的，尽管它们在相同类型的变量中存储，并在不同时间使用。不要试图优化变量的使用。永远不要因为你的代码中已经有了同类型的可用变量就使用它。如果它逻辑上是不同的事情，那么就声明一个新的变量。
- en: While coding, always prefer source code clarity and readability. In Java, especially,
    the Just In Time compiler will optimize all this for you.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时，始终优先考虑源代码的清晰度和可读性。在Java中，尤其是即时编译器会为你优化所有这些。
- en: Although we do not explicitly tend to use the `final` keyword on the argument
    list of a method, it is good practice to make sure that your methods compile and
    work if the arguments are declared `final`. Some experts, including me, believe
    that the method parameters should have been made final by default in the language.
    This is something that will not happen in any version of Java, so long as Java
    follows the backward compatibility philosophy.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通常不会在方法参数列表中显式使用`final`关键字，但确保如果参数被声明为`final`，你的方法仍然可以编译和运行是一个好的实践。一些专家，包括我自己，认为语言中方法参数应该默认是`final`的。但这在任何版本的Java中都不会发生，只要Java继续遵循向后兼容的哲学。
- en: Classes
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'Now that we have looked at the actual code lines and have understood how the
    algorithm works, let''s look at the more global structures of the code that brings it
    together: classes and packages enclosing the methods.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看实际的代码行并理解了算法的工作原理，让我们看看代码的更全局的结构，这些结构将它们组合在一起：封装方法的类和包。
- en: Every file in a Java program defines a class. Any code in a Java program is
    inside a class. There is nothing like global variables or global functions as
    in C, Python, Go, or other languages. Java is totally object oriented.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序中的每个文件都定义了一个类。Java程序中的任何代码都在一个类内部。Java中没有像C、Python、Go或其他语言中的全局变量或全局函数。Java是完全面向对象的。
- en: There can be more than one class in a single file, but usually one file is one
    class. Later, we will see that there are inner classes when a class is inside
    another class, but, for now, we will put one class into one file.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 单个文件中可以有多个类，但通常一个文件对应一个类。稍后，我们将看到当类在另一个类内部时，会有内部类。但就目前而言，我们将把一个类放入一个文件中。
- en: There are some features in the Java language that we do not use. When the language
    was created, these features seemed to be a good idea. CPU, memory, and other resources,
    including mediocre developers, were also more limited than today. Some of the
    features, perhaps, made more sense because of these environmental constraints.
    Sometimes, I will mention these. In the case of classes, you can put more than
    one class into a single file so long as only one is `public`. That is bad practice,
    and we will never do that.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言中有些特性我们没有使用。当语言被创建时，这些特性看起来是个好主意。CPU、内存和其他资源，包括平庸的开发者，都比现在更有限。一些特性可能因为这些环境限制而更有意义。有时，我会提到这些。在类的例子中，只要只有一个类是`public`的，你就可以在一个文件中放入多个类。这是不好的实践，我们永远不会这样做。
- en: 'Java never obsoletes these features. It is a philosophy of Java to remain compatible
    with all previous versions. This philosophy is good for the already written, huge
    amount of legacy code. Java code written and tested with an old version will work
    in a newer environment. At the same time, those features lure beginners to a wrong
    style. For this reason, sometimes, I will not even mention these features. For
    example, here, I could say: *There is one class in a file.* This would not be
    absolutely correct. At the same time, it is more or less pointless to explain
    in great detail a feature that I recommend not to be used. Later, I may simply
    skip them and "lie". There are not too many of those features.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Java永远不会使这些特性过时。Java的哲学是保持与所有先前版本的兼容性。这种哲学对已经编写的大量遗留代码是有益的。使用旧版本编写的Java代码在新环境中也能运行。同时，这些特性可能会诱使初学者走向错误的风气。因此，有时我甚至不会提到这些特性。例如，在这里，我可以说：“一个文件中有一个类。”这并不完全正确。同时，详细解释一个我不建议使用的特性多少有些无意义。以后，我可能会简单地跳过它们并“撒谎”。这些特性并不多。
- en: A class is defined using the `class` keyword and each class has to have a name.
    The name should be unique within the package (see the next section) and has to
    be the same as the name of the file. A class can implement an interface or extend
    another class, for which we will see an example later. A class can also be `abstract`,
    `final`, and `public`. These are defined with the appropriate keywords, as you
    will see in examples.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用`class`关键字定义，每个类都必须有一个名称。该名称应在包内（见下一节）是唯一的，并且必须与文件名相同。一个类可以实现一个接口或扩展另一个类，我们将在稍后看到示例。一个类也可以是`abstract`、`final`和`public`。这些是通过适当的关键字定义的，正如你将在示例中看到的那样。
- en: Our program has two classes. Both of them are `public`. The `public` classes
    are accessible from anywhere. Classes that are not `public` are visible only inside
    the package. Inner and nested classes can also be `private` visible only inside
    the top-level class defined on the file level.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序有两个类。它们都是`public`的。`public`类可以在任何地方访问。不是`public`的类只能在包内部可见。内部和嵌套类也可以是`private`的，仅在文件级别的顶层类内部可见。
- en: Classes that contain a `main` method to be invoked by the Java environment should
    be `public`. That is because they are invoked by the JVM.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 包含要由Java环境调用的`main`方法的类应该是`public`的。这是因为它们是由JVM调用的。
- en: The class starts at the beginning of the file right after the package declaration
    and everything between the `{` and `}` characters belong to the class. The methods,
    fields, inner or nested classes, and so on are part of the class. Generally, curly
    braces denote some block in Java. This was invented in the C language, and many
    languages follow this notation. Class declaration is some block, methods are defined
    using some block, loops, and conditional commands use blocks.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 类从文件的开始处开始，紧随包声明之后，`{`和`}`字符之间的所有内容都属于类。方法、字段、内部或嵌套类等都是类的一部分。通常，大括号在Java中表示某个块。这是在C语言中发明的，许多语言都遵循这种表示法。类声明是某个块，方法是通过某个块定义的，循环和条件命令使用块。
- en: When we use the classes, we will have to create instances of classes. These
    instances are objects. In other words, objects are created instantiating a class.
    To do that, the `new` keyword is used in Java. When the line `final Sort sorter
    = new Sort()`; is executed in the `App` class, it creates a new object instantiating
    the `Sort` class. We will also say that we created a new `Sort` object or that
    the type of the object is `Sort`. When a new object is created, a constructor
    of the object is invoked. A bit sloppy, I may say, that the constructor is a special
    *method* in the class that has the same name as the class itself and has no return
    value. That is because it *returns* the created object. To be precise, constructors
    are not methods. They are initializers and they do not return the new object.
    They work on the *not-ready-yet* object. When a constructor executing the object
    is not fully initialized, some of the final fields may not be initialized and
    the overall initialization still can fail if the constructor throws an exception.
    In our example, we do not have any constructor in the code. In such a case, Java
    creates a default constructor that accepts no argument and does not modify the
    already allocated but uninitialized object. If the Java code defines an initializer,
    then the Java compiler does not create a default one.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用类时，我们需要创建类的实例。这些实例是对象。换句话说，对象是通过实例化一个类来创建的。为了做到这一点，在Java中使用`new`关键字。当在`App`类中执行`final
    Sort sorter = new Sort();`这一行时，它通过实例化`Sort`类创建了一个新的对象。我们也可以说我们创建了一个新的`Sort`对象，或者该对象类型是`Sort`。当创建一个新的对象时，会调用对象的构造函数。我可能有点草率地说，构造函数是类中的一个特殊*方法*，它具有与类本身相同的名称，并且没有返回值。这是因为它*返回*创建的对象。为了更精确，构造函数不是方法。它们是初始化器，并且不返回新对象。它们在*尚未准备好*的对象上工作。当一个构造函数执行的对象尚未完全初始化时，一些最终字段可能尚未初始化，如果构造函数抛出异常，整体初始化仍然可能失败。在我们的例子中，代码中没有构造函数。在这种情况下，Java会创建一个接受无参数且不修改已分配但未初始化的对象的默认构造函数。如果Java代码定义了一个初始化器，那么Java编译器不会创建一个默认的。
- en: A class can have many constructors, each having different parameter list.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以有多个构造函数，每个构造函数都有不同的参数列表。
- en: In addition to constructors Java classes can contain initializer blocks. They
    are blocks on the class level, the same level as the constructor and methods.
    The code in these blocks is compiled into the constructors and is executed when
    the constructor is executing.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数之外，Java类还可以包含初始化块。它们是类级别的块，与构造函数和方法处于同一级别。这些块中的代码被编译到构造函数中，并在构造函数执行时执行。
- en: It is also possible to initialize static fields in static initializer blocks.
    These are the blocks on the top level inside the class with the `static` keyword
    in front of them. They are executed only once when the class is loaded.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在静态初始化块中初始化静态字段。这些是带有`static`关键字的类顶级块。它们只在类加载时执行一次。
- en: We named the classes in our example `App` and `Sort`. This is a convention in
    Java to name almost everything in CamelCase.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的例子中将类命名为`App`和`Sort`。这是Java中的一个约定，几乎所有的东西都使用驼峰式命名法。
- en: CamelCase is when the words are written without spaces between them. The first
    word may start with lowercase or uppercase, and, to denote the start of the second
    and subsequent words, they start with uppercase. `ForExampleThisIsALongCamelCase`
    name.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 驼峰式命名法是指单词之间没有空格。第一个单词可能以小写或大写字母开头，而为了表示第二个和后续单词的开始，它们以大写字母开头。`ForExampleThisIsALongCamelCase`名称。
- en: Class names start with an uppercase letter. This is not a requirement of the
    language formally, but this is a convention that every programmer should follow.
    These coding conventions help you create code that is easier to understand by
    other programmers, and lead to easier maintenance. Static code analyzer tools,
    such as Checkstyle ([http://checkstyle.sourceforge.net/](http://checkstyle.sourceforge.net/)),
    also check that the programmers follow the conventions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 类名以大写字母开头。这并不是语言形式上的要求，但这是每个程序员都应该遵循的约定。这些编码约定有助于你创建其他程序员更容易理解的代码，并有助于更容易的维护。静态代码分析工具，如Checkstyle
    ([http://checkstyle.sourceforge.net/](http://checkstyle.sourceforge.net/))，也会检查程序员是否遵循这些约定。
- en: Inner, nested, local, and anonymous classes
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部、嵌套、局部和匿名类
- en: I have already mentioned inner and nested classes in the previous section. Now
    we look at them in bit more detail.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在上一节中提到了内部和嵌套类。现在我们更详细地看看它们。
- en: The details of inner and nested classes at this point may be difficult. Don't
    feel ashamed if you do not understand this section fully. If it is too difficult,
    skip to the next section and read about packages and return here later. Nested,
    inner, and local classes are rarely used, though they have their roles and use
    in Java. Anonymous classes were very popular in GUI programming with the Swing
    user interface that allowed developers to create Java GUI applications. With Java
    8 and the lambda feature, anonymous classes are not so important these days, and
    with the emerging JavaScript and browser technology, the Java GUI became less
    popular.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，内部和嵌套类的细节可能很难理解。如果你没有完全理解这一节，不要感到羞愧。如果太难，可以跳到下一节，阅读有关包的内容，稍后再回来。尽管嵌套、内部和局部类在Java中很少使用，但它们有自己的角色和用途。匿名类在具有Swing用户界面的GUI编程中非常流行，它允许开发者创建Java
    GUI应用程序。随着Java 8和lambda功能的出现，匿名类现在不再那么重要了，随着JavaScript和浏览器技术的兴起，Java GUI变得不那么受欢迎。
- en: When a class is defined in a file on its own, it is called a top-level class.
    Classes that are inside another class are, obviously, not top-level classes. If
    they are defined inside a class on the same level as fields (variables that are
    not local to some method or other block), they are inner or nested classes. There
    are two differences between them. One is that nested classes have the `static`
    keyword before the `class` keyword at their definition, and inner classes don't.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类在单独的文件中定义时，它被称为顶级类。显然，位于另一个类内部的类不是顶级类。如果它们在字段（不是某些方法或其他代码块局部变量的变量）所在的同一级别类内部定义，它们就是内部或嵌套类。它们之间有两个区别。一个是嵌套类在其定义中有`static`关键字在`class`关键字之前，而内部类则没有。
- en: The other difference is that instances of nested classes can exist without an
    instance of the surrounding class. Inner class instances always have a reference
    to an instance of the surrounding class.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，嵌套类的实例可以在没有外围类实例的情况下存在。内部类实例始终有一个对外围类实例的引用。
- en: 'Because inner class instances cannot exist without an instance of the surrounding
    class, their instance can only be created by providing an instance of the outer
    class. We will see no difference if the surrounding class instance is the actual
    `this` variable, but if we want to create an instance of an inner class from outside
    the surrounding class, then we have to provide an instance variable before the
    `new` keyword separated by a dot, just like if new were a method. For example,
    we could have a class named `TopLevel` that has a class named `InnerClass`, like
    in the following code snippet:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 因为内部类实例不能在没有周围类实例的情况下存在，它们的实例只能通过提供外部类的实例来创建。如果周围类实例是实际的`this`变量，我们不会看到任何区别，但如果我们想从外部创建一个内部类的实例，那么我们必须在`new`关键字之前提供一个实例变量，通过点号分隔，就像`new`是一个方法一样。例如，我们可以有一个名为`TopLevel`的类，它有一个名为`InnerClass`的类，如下面的代码片段所示：
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then we can create an instance of the `InnerClass` from outside with only a
    `TopLevel` object, like in this snippet:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需使用一个`TopLevel`对象就可以从外部创建`InnerClass`的实例，就像以下代码片段所示：
- en: '[PRE40]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As inner classes have an implicit reference to an instance of the enclosing
    class, the code inside the inner class can access the fields and the methods of
    the enclosing class.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类有一个对封装类实例的隐式引用，因此内部类中的代码可以访问封装类的字段和方法。
- en: Nested classes do not have an implicit reference to any instance of the enclosing
    class, and they may be instantiated with the `new` keyword without any reference
    to any instance of any other class. Because of that, they cannot access the fields
    of the enclosing class unless they are static fields.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类没有对封装类实例的隐式引用，并且可以使用`new`关键字实例化，而不需要引用任何其他类的实例。正因为如此，除非是静态字段，否则它们不能访问封装类的字段。
- en: Local classes are classes that are defined inside a method, constructor, or
    an initializer block. We will soon talk about initializer blocks and constructors.
    Local classes can be used inside the block where they are defined.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 局部类是在方法、构造函数或初始化代码块内部定义的类。我们很快就会讨论初始化代码块和构造函数。局部类可以在定义它们的代码块内部使用。
- en: Anonymous classes are defined and instantiated in a single command. They are
    a short form of a nested, inner, or local class, and the instantiation of the
    class. Anonymous classes always implement an interface or extend a named class.
    The new keyword is followed by the name of the interface or the class with the
    argument list to the constructor between parentheses. The block that defines the
    body of the anonymous class stands immediately after the constructor call. In
    the case of extending an interface, the constructor can only be the one without
    argument. The anonymous class with no name cannot have its own constructors. In
    modern Java we usually use lambda instead of anonymous classes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类可以在单个命令中定义和实例化。它们是嵌套类、内部类或局部类的一种简写形式，并且包含类的实例化。匿名类始终实现一个接口或扩展一个命名类。新关键字后面跟着接口或类的名称，以及括号内的构造函数参数列表。定义匿名类主体的代码块紧接在构造函数调用之后。在扩展接口的情况下，构造函数只能是无参的。没有名称的匿名类不能有自己的构造函数。在现代Java中，我们通常使用lambda表达式而不是匿名类。
- en: Last but not least—well, actually, least I should mention that nested and inner
    classes can also be nested in deeper structures. Inner classes cannot contain
    nested classes, but nested classes can contain inner classes. Why? I have never
    met anyone who could reliably tell me the real reason. There is no architectural
    reason. It could be like that. Java does not permit that. However, it is not really
    interesting. If you happen to write code that has more than one level of class
    nesting then just stop doing it. Most probably you are doing something wrong.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是——实际上，我应该先提到的是，嵌套类和内部类也可以在更深层次的结构中嵌套。内部类不能包含嵌套类，但嵌套类可以包含内部类。为什么？我从未遇到过任何能可靠地告诉我真正原因的人。没有架构上的原因。它可能就是这样。Java不允许这样做。然而，这并不真正有趣。如果你碰巧编写了具有多级类嵌套的代码，那么请停止这样做。你很可能会做错事。
- en: Packages
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: Classes are organized into packages and the first code line in a file should
    specify the package that the class is in.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 类被组织成包，文件中的第一行代码应该指定类所在的包。
- en: '[PRE41]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you do not specify the package, then the class will be in the *default* package.
    This should not be used, except in the simplest case when you want to try some
    code. With Java 9, you can use `jshell` for this purpose, so, as opposed to previous
    versions of Java, now the suggestion becomes very simple—never put any class in
    the default package.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定包，那么类将位于 *默认* 包中。这不应该被使用，除非在最简单的情况下你想尝试一些代码。在Java 9中，你可以使用 `jshell` 来实现这个目的，因此，与Java的先前版本相比，现在的建议变得非常简单——永远不要将任何类放在默认包中。
- en: The name of the packages is hierarchical. The parts of the names are separated
    by dots. Using package names helps you avoid name collisions. Names of the classes
    are usually kept short and putting them into packages helps the organization of
    the program. The full name of a class includes the name of the package the class
    is in. Usually, we will put those classes into a package that are in some way
    related, and add something to a similar aspect of a program. For example, controllers
    in an MVC pattern program are kept in a single package. Packages also help you
    avoid name collision of classes. However, this only pushes the problem from class
    name collision to package name collision. We have to make sure that the name of
    the package is unique and does not cause any problem when our code is used together
    with any other library. When an application is developed, we just cannot know
    what other libraries will be used in later versions. To be prepared for the unexpected,
    the convention is to name the packages according to some Internet domain names.
    When a development company has the domain name `acmecompany.com`, then their software
    is usually under the `com.acmecompany...`  packages. It is not a strict language
    requirement. It is only a convention to write the domain name from right to left,
    and use it as package name, but this proves to be fairly good in practice. Sometimes,
    like I do in this book, one can deviate from this practice so you can see that
    this rule is not carved in stone.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 包的名称是分层的。名称的部分由点分隔。使用包名称可以帮助你避免名称冲突。类的名称通常保持简短，将它们放入包中有助于程序的组织。类的完整名称包括该类所在的包的名称。通常，我们会将那些以某种方式相关的类放入一个包中，并为程序的类似方面添加一些内容。例如，在MVC模式程序中的控制器被保存在一个单独的包中。包也有助于避免类的名称冲突。然而，这仅仅是将问题从类名冲突推到了包名冲突。我们必须确保包的名称是唯一的，并且在使用我们的代码与其他任何库一起使用时不会引起任何问题。在开发应用程序时，我们根本无法知道在以后的版本中会使用哪些其他库。为了应对意外情况，惯例是按照某些互联网域名来命名包。当一个开发公司的域名是
    `acmecompany.com` 时，他们的软件通常位于 `com.acmecompany...` 包下。这并不是严格的语言要求，而是一种惯例，即从右到左书写域名，并将其用作包名，但实践证明这相当有效。有时，就像我在这本书中所做的那样，可以偏离这一惯例，这样你就可以看到这条规则并非一成不变。
- en: When the rubber hits the road, and the code is compiled into byte code, the
    package becomes the name of the class. Thus, the full name of the `Sort` class
    is `packt.java9.by.example.stringsort.Sort`. When you use a class from another
    package, you can use this full name or import the class into your class. Again,
    this is on the language level. Using the fully qualified name or importing makes
    no difference when Java becomes byte code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当橡胶接触地面，代码编译成字节码时，包名就变成了类的名称。因此，`Sort` 类的完整名称是 `packt.java9.by.example.stringsort.Sort`。当你使用来自另一个包的类时，你可以使用这个完整名称或者将类导入到你的类中。再次强调，这在语言层面上是如此。使用完全限定名称或导入在Java成为字节码时没有区别。
- en: Methods
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: We have already discussed methods, but not in detail, and there are still some
    aspects that we should meet before we go on.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了方法，但不是非常详细，还有一些方面在我们继续之前我们应该了解。
- en: There are two methods in the sample classes. There can be many methods in a
    class. Method names are also camel cased by convention, and the name starts with
    a lowercase letter, as opposed to classes. Methods may return a value. If a method
    returns a value, the method has to declare the type of the value it returns and,
    in that case, any execution of the code has to finish with a `return` statement.
    The `return` statement has an expression after the keyword, which is evaluated
    when the method is executed and is returned by the method. It is good practice
    to have only one single return from a method but, in some simple cases, breaking
    that coding convention may be forgiven. The compiler checks the possible method
    execution paths, and it is a compile-time error if some of the paths do not return
    a value.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 样本类中有两种方法。一个类中可以有多个方法。按照惯例，方法名也是驼峰式命名，并且以小写字母开头，与类名不同。方法可以返回一个值。如果一个方法返回一个值，那么该方法必须声明返回值的类型，并且在这种情况下，任何代码执行都必须以一个`return`语句结束。`return`语句在关键字后有表达式，该方法执行时该表达式将被评估并由方法返回。只有一个单一返回值的方法是一种良好的编程习惯，但在某些简单情况下，违反这一编程习惯可能会被原谅。编译器检查可能的方法执行路径，如果某些路径没有返回值，则是一个编译时错误。
- en: When a method does not return any value, it has to be declared to be `void`.
    This is a special type that means no value. Methods that are `void`, such as the
    `public static void main` method, may simply miss the return statement and just
    end. If there is a `return` statement, there is no place for any expression defining
    a return value after the `return` keyword. Again, this is a coding convention
    to not use the `return` statement in case of a method that does not return any
    value, but in some coding patterns, this may not be followed.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法不返回任何值时，它必须声明为`void`。这是一个特殊类型，表示没有值。`void`类型的方法，如`public static void main`方法，可以简单地省略返回语句并直接结束。如果有`return`语句，则在`return`关键字之后就没有地方放置定义返回值的表达式了。再次强调，这是一个编程习惯，在不需要返回任何值的方法中不使用`return`语句，但在某些编程模式中，可能不会遵循这一习惯。
- en: Methods can be `private`, `protected`, `public`, and `static`, and we will discuss
    their meaning later.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以是`private`、`protected`、`public`和`static`，我们将在后面讨论它们的含义。
- en: We have seen that the `main` method that was invoked when the program started
    is a `static` method. Such a method belongs to the class and can be invoked without
    having any instance of the class. Static methods are declared with the `static`
    modifier, and they cannot access any field or method that is not static.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当程序启动时调用的`main`方法是一个`static`方法。这样的方法属于类，可以在没有类的实例的情况下调用。静态方法使用`static`修饰符声明，并且不能访问任何非静态的字段或方法。
- en: 'In our example, the `sort` method is not static, but as it does not access
    any field and does not call any non-static method (as a matter of fact, it does
    not call any method at all), it could just as well be `static`. If we change the
    declaration of the method to `public static void sort(String[] names) {` (note
    the word `static`), the program still works, but the IDE will give a warning while
    editing, for example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`sort`方法不是静态的，但由于它不访问任何字段也不调用任何非静态方法（实际上，它根本不调用任何方法），它完全可以是静态的。如果我们将方法的声明更改为`public
    static void sort(String[] names) {`（注意单词`static`），程序仍然可以工作，但在编辑时，IDE会给出警告，例如：
- en: '[PRE42]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That is because you can access the method without an instance directly through
    the name of the `Sort.sort(actualNames);` class without the need of the `sorter`
    variable. Calling a static method via an instance variable is possible in Java
    (again something that seemed to be a good idea at the genesis of Java, but is
    probably not), but it may mislead the reader of the code into thinking that the
    method is an instance method.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为你可以直接通过`Sort.sort(actualNames);`类的名称来访问方法，而不需要`sorter`变量。在Java中，通过实例变量调用静态方法是可能的（这再次似乎是Java诞生时的一个好主意，但可能不是），但它可能会误导代码的读者，使他们认为该方法是一个实例方法。
- en: 'Making the `sort` method `static`, the `main` method can be as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将`sort`方法定义为`static`，`main`方法可以如下所示：
- en: '[PRE43]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It seems to be much simpler (it is), and, in case the method does not use any
    field, you may think that there is no reason to make a method non-static. During
    the first ten years of Java, static methods were in heavy use. There is even a
    term, utility class, which means a class that has only static methods and should
    not be instantiated. With the advent of **Inversion of Control** containers, we
    tend to use less static methods. When static methods are used, it is harder to
    use **dependency injection**, and it is also more difficult to create tests. We
    will discuss these advanced topics in the next few chapters. For now, you are
    informed as to what static methods are and that they can be used; however, usually,
    unless there is a very special need for them, we will avoid them.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎要简单得多（确实如此），而且，如果方法没有使用任何字段，你可能认为没有必要将方法设为非静态。在Java的前十年里，静态方法被广泛使用。甚至有一个术语，工具类，指的是只包含静态方法且不应被实例化的类。随着**控制反转**容器的出现，我们倾向于使用更少的静态方法。当使用静态方法时，使用**依赖注入**会更困难，创建测试也会更加困难。我们将在下一章讨论这些高级主题。现在，你已经了解到静态方法是什么以及它们可以被使用；然而，通常，除非有非常特殊的需求，我们通常会避免使用它们。
- en: Later, we will look at how classes are implemented in the hierarchy, and how
    classes may implement interfaces and extend other classes. When these features
    are looked at, we will see that there are so-called abstract classes that may
    contain abstract methods. These methods have the  `abstract` modifier, and they
    are not defined—only the name, argument types (and names), and return type are
    specified. A concrete (non-abstract) class extending the abstract class should
    define them.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将探讨在层次结构中类是如何实现的，以及类如何实现接口和扩展其他类。当这些特性被考虑时，我们会看到所谓的抽象类，它们可能包含抽象方法。这些方法具有`abstract`修饰符，并且没有被定义——只有名称、参数类型（和名称）以及返回类型被指定。扩展抽象类（非抽象）的具体类应该定义这些方法。
- en: The opposite of abstract method is the final method declared with the `final`
    modifier. A `final` method cannot be overridden in subclasses.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法的相反面是使用`final`修饰符声明的最终方法。一个`final`方法不能在子类中被覆盖。
- en: Interfaces
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Methods are also declared in interfaces. A method declared in an interface does
    not define the actual behavior of the method; they do not contain the code. They
    have only the head of the method; in other words, they are abstract implicitly.
    Although nobody does, you may even use the `abstract` keyword in an interface
    when you define a method.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以在接口中声明。接口中声明的方法并不定义方法的实际行为；它们不包含代码。它们只有方法头；换句话说，它们是隐式抽象的。尽管没有人这样做，你甚至可以在接口中定义方法时使用`abstract`关键字。
- en: Interfaces look very similar to classes, but instead of using the `class` keyword,
    we use the `interface` keyword. Because interfaces are mainly used to define methods,
    the methods are `public` if no modifier is used.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接口看起来与类非常相似，但我们使用`interface`关键字而不是`class`关键字。因为接口主要用于定义方法，所以如果没有使用修饰符，方法默认是`public`的。
- en: Interfaces can also define fields, but since interfaces cannot have instances
    (only implementing classes can have instances), these fields are all `static`
    and they also have to be `final`. This is the default for fields in interfaces,
    thus we do not need to write these if we defined fields in interfaces.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以定义字段，但由于接口不能有实例（只有实现类可以有实例），这些字段都是`static`的，并且也必须是`final`的。这是接口中字段的默认行为，因此如果我们定义了接口中的字段，我们不需要写这些。
- en: It was a common practice to define only constants in some interfaces and then
    use these in classes. To do that, the easiest way was to implement the interface.
    Since these interfaces do not define any method, the implementation is nothing
    more than writing the implements keyword and the name of the interface into the
    header of the class declaration. This is bad practice because this way the interface
    becomes part of the public declaration of the class, although these constants
    are needed inside the class. If you need to define constants that are not local
    to a class but are used in many classes, then define them in a class and import
    the fields using `import static` or just use the name of the class and the field.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些接口中只定义常量，然后在类中使用这些常量的做法很常见。为此，最简单的方法是实现该接口。由于这些接口没有定义任何方法，实现只是将`implements`关键字和接口名称写入类声明头部的实现。这是不好的做法，因为这样接口就成为了类公共声明的一部分，尽管这些常量在类内部是需要的。如果你需要定义不是局部于类的常量，但被许多类使用，那么在类中定义它们，并使用`import
    static`导入字段，或者只需使用类名和字段名。
- en: Interfaces can also have nested classes, but they cannot have inner classes.
    The obvious reason for that is that inner class instances have a reference to
    an instance of the enclosing class. In the case of an interface, there are no
    instances, so an inner class could not have a reference to an instance of an enclosing
    interface, because that just does not exist. The joyful part of it is that we
    do not need to use the `static` keyword in the case of nested classes because
    that is the default, just as in the case of fields.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以有嵌套类，但不能有内部类。显然的原因是内部类实例有一个对封装类实例的引用。在接口的情况下，没有实例，所以嵌套类不能有对封装接口实例的引用，因为那根本不存在。令人高兴的是，在这种情况下，我们不需要在嵌套类中使用`static`关键字，因为这是默认的，就像字段的情况一样。
- en: With the advent of Java 8, you can also have `default` methods in interfaces
    that provide default implementation of the method for the classes that implement
    the interface. There can also be `static` and `private` methods in interfaces
    since Java 9.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 8的推出，你还可以在接口中有`default`方法，为实现该接口的类提供默认的方法实现。从Java 9开始，接口中也可以有`static`和`private`方法。
- en: Methods are identified by their name and the argument list. You can reuse a
    name for a method and have different argument types; Java will identify which
    method to use based on the types of the actual arguments. This is called **method
    overloading**. Usually, it is easy to tell which method you call, but when there
    are types that extend each other, the situation becomes more complex. The standard
    defines very precise rules for the actual selection of the method that the compiler
    follows, so there is no ambiguity. However, fellow programmers who read the code
    may misinterpret overloaded methods or, at least, will have hard time identifying
    which method is actually called. Method overloading may also hinder backward compatibility
    when you want to extend your class. The general advice is to think twice before
    creating overloaded methods. They are lucrative, but may sometimes be costly.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通过其名称和参数列表来识别。你可以为方法重用名称并具有不同的参数类型；Java将根据实际参数的类型来确定使用哪个方法。这被称为**方法重载**。通常，很容易判断调用的是哪个方法，但当存在相互扩展的类型时，情况变得更加复杂。标准定义了非常精确的规则，编译器会遵循这些规则来实际选择方法，因此没有歧义。然而，阅读代码的其他程序员可能会误解重载方法，或者至少在识别实际调用的是哪个方法时会遇到困难。方法重载也可能在你想扩展你的类时阻碍向后兼容性。一般的建议是在创建重载方法之前三思而后行。它们是有利可图的，但有时可能会付出代价。
- en: Argument passing
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数传递
- en: In Java, arguments are passed by value. When the method modifies an argument
    variable, then only the copy of the original value is modified. Any primitive
    value is copied during the method call. When an object is passed as an argument,
    then the copy of the reference to the object is passed.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，参数是通过值传递的。当方法修改一个参数变量时，只有原始值的副本被修改。任何原始值在方法调用期间都会被复制。当一个对象作为参数传递时，传递的是对该对象的引用的副本。
- en: That way, the object is available to be modified for the method. In the case
    of classes that have their primitive counterpart, and also in the case of `String`
    and some other class types, the objects simply do not provide methods or fields
    to modify the state. This is important for the integrity of the language, and
    to not get into trouble when objects and primitive values automatically get converted.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对象就可以被方法修改。对于有原始类型对应类的类，以及对于`String`和一些其他类类型，对象根本不提供修改状态的方法或字段。这对于语言的完整性很重要，并且当对象和原始值自动转换时，可以避免麻烦。
- en: In other cases, when the object is modifiable, the method can effectively work
    on the very object it was passed to. This is also the way the `sort` method in
    our example works on the array. The same array, which is also an object itself,
    is modified.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，当对象是可修改的，方法可以有效地对其传递给它的对象本身进行操作。这也是我们示例中的`sort`方法对数组进行操作的方式。相同的数组，它本身也是一个对象，被修改了。
- en: This argument passing is much simpler than it is in other languages. Other languages
    let the developer mix the *pass by reference* and the *pass by value* argument
    passing. In Java, when you use a variable by itself as an expression to pass a
    parameter to a method, you can be sure that the variable itself is never modified.
    The object it refers to, however, in case it is mutable, may be modified.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这种参数传递方式比其他语言要简单得多。其他语言允许开发者混合使用*按引用传递*和*按值传递*的参数传递方式。在Java中，当你仅用变量本身作为表达式来向方法传递参数时，你可以确信该变量本身永远不会被修改。然而，它所引用的对象，如果它是可变的，则可能会被修改。
- en: An object is mutable if it can be modified, altering the value of some of its
    field directly or via some method call. When a class is designed in a way that
    there is no normal way to modify the state of the object after the creation of
    the object, the object is immutable. The classes `Byte`, `Short`, `Integer`, `Long`,
    `Float`, `Double`, `Boolean`, `Character`, as well as `String`, are designed in
    the JDK so that the objects are immutable.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象如果是可变的，那么它可以被修改，直接或通过某些方法调用改变其某些字段的值。当一个类被设计成在对象创建后没有正常的方式来修改对象的状态时，该对象就是不可变的。`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Boolean`、`Character`以及`String`类在JDK中被设计成不可变的对象。
- en: It is possible to overcome the limitation of immutability implementation of
    certain classes using reflection, but doing that is hacking and not professional
    coding. Doing that can be done for one single purpose—getting a better knowledge
    and understanding of the inner workings of some Java classes, but nothing else.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反射可以克服某些类不可变实现方式的限制，但这样做是黑客行为，而不是专业的编码。这样做可以用于单一目的——更好地了解某些Java类的内部工作原理，但别无其他。
- en: Fields
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段
- en: Fields are variables on the class level. They represent the state of an object.
    They are variables, with defined type and possible initial value. Fields can be
    `static`, `final`, `transient`, and `volatile`, and the access may be modified
    with the `public`, `protected`, and `private` keywords.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 字段是类级别的变量。它们代表了一个对象的状态。它们是变量，具有定义的类型和可能的初始值。字段可以是`static`、`final`、`transient`和`volatile`，并且可以通过`public`、`protected`和`private`关键字修改访问权限。
- en: Static fields belong to the class. It means that there is one of them shared
    by all the instances of the class. Normal, non-static fields belong to the objects.
    If you have a field named `f`, then each instance of the class has its own `f`.
    If `f` is declared `static`, then the instances will share the very same `f` field.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 静态字段属于类。这意味着类中的所有实例共享一个。普通的非静态字段属于对象。如果你有一个名为`f`的字段，那么类的每个实例都有自己的`f`。如果`f`被声明为`static`，那么实例将共享同一个`f`字段。
- en: The `final` fields cannot be modified after they are initialized. Initialization
    can be done on the line where they are declared, in an initializer block or in
    the constructor code. The strict requirement is that the initialization has to
    happen before the constructor returns. This way, the meaning of the `final` keyword
    is very different, in this case, from what it means in the case of a class or
    a method. A `final` class cannot be extended and a `final` method cannot be overridden
    in an extending class, as we will see in the next chapter. The `final` fields
    are either uninitialized or get a value during instance creation. The compiler
    also checks that the code does initialize all `final` fields during the object-instance
    creation or during the class loading, in case the `final` field is `static`, and
    that the code is not accessing/reading any `final` field that was not yet initialized.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`字段在初始化后不能被修改。初始化可以在声明它们的行上完成，在初始化块中或在构造函数代码中完成。严格的要求是初始化必须在构造函数返回之前发生。这样，在这种情况下，`final`关键字的意义与在类或方法的情况下有很大的不同。一个`final`类不能被扩展，一个`final`方法不能在扩展类中被覆盖，正如我们将在下一章中看到的。`final`字段要么在实例创建期间未初始化，要么在实例创建期间获得一个值。编译器还会检查代码是否在对象实例创建期间或类加载期间初始化了所有`final`字段，如果`final`字段是`static`的，并且代码没有访问/读取尚未初始化的任何`final`字段。'
- en: It is a common misconception that the `final` fields have to be initialized
    at the declaration. It can be done in an initializer code or in a constructor.
    The restriction is that, no matter which constructor is called in case there are
    more, the `final` fields have to be initialized exactly once.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍认为`final`字段必须在声明时初始化。可以在初始化代码或构造函数中完成。限制是，无论调用哪个构造函数（如果有多个），`final`字段必须恰好初始化一次。
- en: The `transient` fields are not part of the serialized state of the object. Serialization
    is an act of converting the actual value of an object to physical bytes. Deserialization
    is the opposite when the object is created from the bytes. It is used to save
    the state in some frameworks. The code that does the serialization, `java.lang.io.ObjectOutputStream`,
    works only with classes that implement the `Serializable` interface, and uses
    only the fields from those objects that are not `transient`. Very obviously, `transient`
    fields are also not restored from the bytes that represent the serialized form
    of the object because their value is not there.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`transient`字段不是对象序列化状态的一部分。序列化是将对象的实际值转换为物理字节的操作。反序列化是当对象从字节创建时的相反操作。它用于在框架中保存状态。执行序列化的代码`java.lang.io.ObjectOutputStream`仅与实现`Serializable`接口的类一起工作，并且仅使用那些对象中不是`transient`的字段。很明显，`transient`字段也不会从表示对象序列化形式的字节中恢复，因为它们的值不存在。'
- en: Serialization is usually used in distributed programs. A good example is the
    session object of a servlet. When the servlet container runs on a clustered node,
    some fields of objects stored into the session object may magically disappear
    between HTTP hits. That is because serialization saves and reloads the session
    to move the session between the nodes. Serialization, in such a situation, may
    also be a performance issue if a developer does not know the side effects of the
     stored large objects in the session.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化通常用于分布式程序中。一个很好的例子是servlet的会话对象。当servlet容器在集群节点上运行时，存储在会话对象中的某些对象字段可能在HTTP请求之间神奇地消失。这是因为序列化保存和重新加载会话以在节点之间移动会话。在这种情况下，如果开发者不知道会话中存储的大型对象的副作用，序列化可能也会成为性能问题。
- en: The `volatile` keyword is a keyword that tells the compiler that the field may
    be used by different threads. When a `volatile` field is accessed by any code,
    the JIT compiler generates code which ensures that the value of the field accessed
    is up to date. When a field is not volatile, the compiler-generated code may store
    the value of the field in a processor cache or registry for faster access when
    it sees that the value will be needed soon by some subsequent code fragment. In
    the case of `volatile` fields, this optimization cannot be done. Additionally,
    note that saving the value to memory and loading from there all the time may be
    50 or more times slower than accessing a value from a registry or cache.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile` 关键字是一个告诉编译器该字段可能被不同线程使用的关键字。当一个 `volatile` 字段被任何代码访问时，JIT 编译器会生成代码以确保访问的字段值是最新的。当一个字段不是
    `volatile` 时，编译器生成的代码可能会将字段的值存储在处理器缓存或寄存器中，以便在它看到后续代码片段很快需要该值时，可以更快地访问。在 `volatile`
    字段的情况下，这种优化不能进行。此外，请注意，将值保存到内存中并始终从那里加载可能比从寄存器或缓存中访问值慢 50 倍或更多。'
- en: Modifiers
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰符
- en: Methods, constructors, fields, interfaces, and classes can have access modifiers.
    The general rule is that in case there is no modifier, the scope of the method,
    constructor, and so on, is the package. Any code in the same package can access
    it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 方法、构造函数、字段、接口和类可以有访问修饰符。一般规则是，如果没有修饰符，方法、构造函数等的范围是包。同一包中的任何代码都可以访问它。
- en: When the `private` modifier is used, the scope is restricted to the so-called
    compilation unit. This means the class that is in one file. What is inside one
    file can see and use anything declared to be `private`. This way, inner and nested
    classes can have access to each other's `private` variables, which may not really
    be a good programming style, but Java permits that.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `private` 修饰符时，作用域被限制在所谓的编译单元内。这意味着在一个文件中的类。一个文件内部的内容可以看到并使用被声明为 `private`
    的任何内容。这样，内部和嵌套类可以访问彼此的 `private` 变量，这可能并不是一个好的编程风格，但 Java 允许这样做。
- en: The opposite of `private` is `public`. It extends the visibility to the whole
    Java program, or at least to the whole module, if the project is a Java 9 module.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 的对立面是 `public`。它将可见性扩展到整个 Java 程序，或者至少在项目是一个 Java 9 模块的情况下，扩展到整个模块。'
- en: 'There is a middle way: `protected`. Anything with this modifier is accessible
    inside the package and also in classes that extend the class (regardless of package)
    that the protected method, field, and so on, is in.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个折中的方法：`protected`。任何带有此修饰符的内容都可以在包内部访问，也可以在扩展了包含受保护方法、字段等的类的类（无论包如何）中访问。
- en: Object initializers and constructors
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象初始化器和构造函数
- en: 'When an object is instantiated, the appropriate constructor is called. The
    constructor declaration looks like a method with the following deviation: the
    constructor does not have a return value. That is because the constructors work
    on the not-fully-ready instance when the `new` command operator is invoked and
    does not return anything. Constructors, having the same name as the class, cannot
    be distinguished from each other. If there is a need for more than one constructor,
    they have to be overloaded. Constructors, thus, can call each other, almost as
    if they were `void` methods with different arguments. However, there is a restriction—when
    a constructor calls another, it has to be the very first instruction in the constructor.
    You use `this()` syntax with an appropriate argument list, which may be empty,
    to invoke a constructor from another constructor.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象被实例化时，会调用适当的构造函数。构造函数声明看起来像是一个方法，但有以下差异：构造函数没有返回值。这是因为构造函数在 `new` 命令操作符被调用时工作在尚未完全准备好的实例上，并且不返回任何内容。具有与类相同名称的构造函数无法区分彼此。如果需要多个构造函数，它们必须被重载。因此，构造函数可以相互调用，几乎就像它们是具有不同参数的
    `void` 方法一样。然而，有一个限制——当构造函数调用另一个时，它必须是构造函数中的第一条指令。您可以使用带有适当参数列表的 `this()` 语法（可能为空）来从另一个构造函数中调用构造函数。
- en: The initialization of the object instance also executes initializer blocks.
    These are blocks containing executable code inside the `{` and `}` characters
    outside the methods and constructors. They are executed before the constructor
    in the order they appear in the code, together with the initialization of the
    fields in case their declarations contain value initialization.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对象实例的初始化也会执行初始化器块。这些块包含在 `{` 和 `}` 字符之外的方法和构造函数内部的可执行代码。它们按照在代码中出现的顺序执行，与字段初始化一起，如果它们的声明包含值初始化的话。
- en: If you see the `static` keyword in front of an initializer block, the block
    belongs to the class and is executed when the class is loaded along with the static
    field initializers.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到初始化块前有 `static` 关键字，则该块属于类，并在类加载时与静态字段初始化器一起执行。
- en: Compiling and running the program
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行程序
- en: 'Finally, we will compile and execute our program from the command line. There
    is nothing new in this one; we will only apply what we have learned in this chapter
    using the following two commands:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将从命令行编译并执行我们的程序。这里没有什么新东西；我们只会应用本章学到的知识，使用以下两个命令：
- en: '[PRE44]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This compiles the program, packages the result into a JAR file, and finally
    executes the following command:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译程序，将结果打包成 JAR 文件，并最终执行以下命令：
- en: '[PRE45]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will print the following result on the command line:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行上打印以下结果：
- en: '**![](img/00036.jpeg)**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/00036.jpeg**)'
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have developed a very basic sort algorithm. It was made
    purposefully simple so that we could reiterate the basic and most important Java
    language elements, classes, packages, variables, methods, and so on. We also looked
    at build tools, so we are not empty handed in the next chapters when projects
    will contain more than just two files. We will use Maven and Gradle in the following
    chapters.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个非常基础的排序算法。它是故意设计得如此简单，以便我们可以重复介绍基本的和最重要的 Java 语言元素，如类、包、变量、方法等。我们还探讨了构建工具，这样在下一章中，当项目包含的不仅仅是两个文件时，我们就不至于两手空空。在下一章中，我们将使用
    Maven 和 Gradle。
- en: In the very next chapter, we will make the sort program more complex, implementing
    more effective algorithms and also making our code flexible, giving us the opportunity
    to learn more advanced Java language features.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使排序程序更加复杂，实现更有效的算法，并使我们的代码更加灵活，给我们学习更多高级 Java 语言特性的机会。
