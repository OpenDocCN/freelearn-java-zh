- en: Chapter 4. Handling Job Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about essential data handling mechanisms,
    including reading, processing, and writing data from/to different sources, such
    as flat files, XML, and databases. From the previous chapters, we learned that
    Spring Batch jobs handle bulk data reading, manipulating, and writing activities.
    Through these activities, it is important to make the activity consistent through
    a transaction while interacting with files/databases. Spring Batch provides strong
    transaction support through job processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Batch transaction management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As part of the job processing, activities involve reading data from different
    sources, processing the data, and writing it to different sources, including files
    and databases. Data, as a complete set of records or in chunks, has to either
    be completely processed and written to the end system, or be tracked as failed
    records in the case of any error. Transaction management should take care of this
    operation to make it consistent, by committing the correct information and rolling
    back in case of any error. The following are the activities involved in a database
    transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: Beginning the transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing a set of records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing the transaction if no errors occur during processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling back the transaction if any errors occur during processing![Transactions](img/3372OS_04_04.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hence, a transaction is defined as a series of operations that obey the **atomic,
    consistent, isolated, and durable** (**ACID**) characteristics described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomic**: This ensures success in either all or none of the operations in
    the transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent**: This ensures that the transaction brings the resource from
    one valid state to the other valid state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolated**: One transaction''s state and effect are hidden from all other
    transactions during concurrent execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durable**: The result of a transaction should be persistent and survive a
    system crash once the transaction is completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a transaction follows these ACID characteristics, it can handle any unexpected
    errors, by aborting the error that occurs during the transaction, to gracefully
    recover the consistent state of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Batch transaction management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Batch provides transaction management through step execution, where each
    transaction is committed after successful data processing and is rolled back if
    any error is found through processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Batch manages the transactions in either of the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Tasklet steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chunk-oriented steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasklet steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tasklets are used in Spring Batch to process business-specific activities,
    such as archiving, remote interactions, and invoking services. By default, the
    `execute` method of the tasklet itself is transactional. Hence, each call to the
    `execute` method calls for a new transaction. The following is a sample tasklet
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the tasklet can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Chunk-oriented steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chunk-oriented steps processing undertakes chunks of records in a read-process-write
    mechanism, as shown in the following diagram. Each step, once the transaction
    is started, handles the data to be read, processed, and written, and after the
    successful completion of these stages, the step commits the transaction. Then,
    it follows the next transaction to handle the next set of records. If any error
    occurs in either of these steps, it rolls back the transaction and completes the
    step execution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Chunk-oriented steps](img/3372OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Hence, chunk-oriented steps are preferred for bulk data processing so that
    the entire data is divided into chunks and processed in individual transactions.
    If any exception occurs in any phase, it rolls back that transaction, hence, the
    data handling will be more efficient and complete. Failed steps, which can be
    logged and re-run with corrected information, are gracefully rolled back. The
    following is a sample chunk-oriented step configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration, we have the first step (`stepOne`) with tasklet
    and chunk within it. To ensure the order of execution, `stepOne` is the parent
    of `stepTwo`. While `stepOne` configures `itemReader` and `itemWriter`, `stepTwo`
    configures `itemProcessor`.
  prefs: []
  type: TYPE_NORMAL
- en: Listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Batch supports listeners to execute certain operations after/before
    an event occurs. Spring Batch handles each of these events, and the way transactions
    are handled in each listener is specific to that listener and how they handle
    the data. Hence, it is important to observe if the listener methods are handled
    as part of the step transaction. If not, then the application should handle such
    transactions programmatically. The following is the sample listener configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the listener can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Customizing the transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Batch allows the configurations to customize the way transactions are
    handled. The data exchange between different transactions, if processed and read
    gracefully, make the transaction clean. However, we have different ways to configure
    the visibility of transaction integrity to other interactions, called isolation
    levels. The following are the isolation levels to customize the Spring Batch transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serializable**: This is the highest isolation level. Based on lock-based
    or non-lock-based concurrency control, it ensures clean data reading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeatable reads**: This lock-based implementation maintains read and write
    locks, hence clean data is guaranteed; however, with no support for range locks,
    phantom reads may occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read committed**: This lock-based implementation maintains the write lock,
    hence it promises any data read is committed the moment it is read, and restricts
    any intermediate, uncommitted, and dirty read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read uncommitted**: This is the lowest isolation level. One transaction can
    see the uncommitted changes of other transactions as well. Hence, dirty reads
    are allowed in this level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are predefined constants for each isolation level. By default, the configuration
    is `READ_COMMITTED` for the Spring Batch isolation level. Based on the criticality
    and importance of the data to be read across transactions, one has to set the
    isolation level for that transaction. For example, a bank account transaction
    might want to read only clean, committed data from other transactions and make
    the transaction with persistent data. In such cases, one has to choose between
    the isolation level and performance of the application. The following is a sample
    isolation level configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the batch jobs are integrated with applications having other frameworks using
    similar nomenclature for configurations, then one should be careful with configurations.
    The intent of control in one technology can control others; it's better to disable
    either one of the configurations on need basis in such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The attributes on each of the batch components, as discussed in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Spring Batch Jobs"), *Getting Started with Spring
    Batch Jobs*, can help us better customize the batch job transaction configurations.
    For example, one can control the rollback transactions, in specific exception
    scenarios, by configuring `no-rollback-exception-classes`.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Batch job processing involves handling data across multiple sources.
    Such scenarios, which usually occur time and again, can be identified as transaction
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the patterns identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple transaction**: This is a transaction with a single application and
    data source (source and target)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global transaction**: This is a transaction involving more than one data
    source to be handled through the same transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple transaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simple transactions with a single batch application and a data source can be
    easily implemented with the support of Spring Batch integrated with diverse database
    interaction techniques, such as JDBC, JPA, or Hibernate supports from Spring Batch.
    The interaction would be as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple transaction](img/3372OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Global transaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If more than one data source has to be persisted through a single transaction,
    such transactions are termed as global transactions, which can managed by the
    transaction manager. It is the responsibility of the transaction manager to make
    sure the transaction obeys the ACID characteristics through its multiple data
    sources and the data is persisted consistently.
  prefs: []
  type: TYPE_NORMAL
- en: However, if an application is deployed in an integrated enterprise server, which
    supports a transaction manager, that might as well be considered against the **Java
    Transaction API** (**JTA**) based transaction manager. The following is a representation
    of a managed transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Global transaction](img/3372OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These transactions can also be configured to maintain the references of the
    one database schema as a synonym in another database schema to refer it virtually
    as a local transaction. However, the effort of creating such synonyms must be
    considered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this chapter we learned about transactions and key characteristics of
    transactions. We also learned how Spring Batch performs transaction management
    in different scenarios, including tasklet steps, chunk-oriented steps, and listeners.
    We also learned about customizing the transaction with isolation levels and attribute
    configurations. We finished this chapter with an understanding of commonly used
    transaction patterns with single and multiple data sources in a batch application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn in detail about the flow of jobs and sharing
    data between steps of the executing jobs.
  prefs: []
  type: TYPE_NORMAL
