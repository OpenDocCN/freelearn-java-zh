- en: Chapter 7. Explanation of ImageJ Constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we developed macros to ease our processing and measurements.
    We used some techniques and constructs that are particular for the macro language
    in ImageJ. In this chapter, we will look at the following topics, in preparation
    to develop our own plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks for macros and plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special classes in ImageJ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in functions for macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the NetBeans IDE for development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up for development using Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frameworks for macros and plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will look at some tools that ImageJ offers developers to deal with images
    and their processing. In the previous chapter, we looked at macros to perform
    common image-processing steps. This was already an improvement over the processing
    of time series one frame at a time, but ImageJ supports more tools and constructs
    that allow you to expand these basic tools further. In this chapter, we will look
    at some of these constructs as a preparation for the upcoming chapters, where
    we will look at plugins and their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'ImageJ has two ways to process in a more automated fashion: macros and plugins.
    Besides the macros described in the previous chapter, ImageJ also supports other
    Java-based scripting languages such as Beanshell and JavaScript, as well as the
    scripting languages Python and Ruby, among others. The plugins can be split into
    two groups as well: plugins based on the original ImageJ (that is, ImageJ1.x plugins)
    and those based on the next development of ImageJ called **ImageJ2** (ImageJ2
    plugins). The ImageJ2 development is designed to be backward compatible with ImageJ1.x,
    although this may change in the future. In this chapter, we will look at some
    of the constructs available when creating scripts and plugins. We will start by
    looking at the scripting languages supported by ImageJ.'
  prefs: []
  type: TYPE_NORMAL
- en: Macros and scripting languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the previous chapter, we can easily create an ImageJ macro by
    starting the macro recorder and performing different steps for image processing
    and measurements. We set the type to Macro in the recorder. We can do the same
    thing for two other scripting languages that ImageJ supports: **BeanShell** and
    **JavaScript**. BeanShell scripts are a type of macros, but have access to the
    full ImageJ and Java API. This means, besides the commands available in macros,
    you can also use classes and interfaces from Java, providing much more options
    in processing. The advantage of the BeanShell scripting language is that it is
    an interpreted language (it does not have to be compiled before it can be run)
    and requires only an interpreter that has a small footprint. This makes it easy
    to create fast solutions and prototyping for plugins. In the following sections,
    I will examine some of the concepts in the BeanShell scripting language. Note
    that similar results can be achieved in the JavaScript language within ImageJ,
    where the only difference is small changes in syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: BeanShell scripting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BeanShell scripting allows you to create a script with all the advantages of
    a macro, but with the added benefit of having access to the Java API. You can
    use Java code almost directly as is. However, there are a few small differences.
    BeanShell scripts have weak typing. This means, you do not need to declare the
    variable type, and you can change the type of a variable on-the-fly. In all other
    ways, it is comparable to developing Java code. If you wish to use a class or
    interface from the Java API, you need to import it first using the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This import statement tells the script interpreter that it needs to load the
    `KeyListener` class from the `java.awt.event` package. This will allow you to
    monitor key presses. The `KeyListener` class is an interface that can be attached
    to an instance of a script. The class will generate an event when a key is pressed,
    resulting in a call to the `keyPressed()` method, which has to be overwritten
    by the script. Using the `keyPressed()` method, you can perform a specific task
    when a certain key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BeanShell scripting language also supports importing existing scripts into
    a new script. This way, you can daisy-chain multiple scripts. Daisy-chaining scripts
    means you use one script''s output as input for the next script and so on. The
    advantage of this type of processing is that each script becomes a module that
    can be reused and combined in different ways to achieve different results. To
    import an existing script into your script, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will load the BeanShell script called `some_script.bsh` and give you access
    to its methods. A simple BeanShell script may consist of a series of basic ImageJ
    commands, but can also contain classes, functions, and even graphical user interfaces.
    We will now look at a few constructs used in the BeanShell scripting language
    that deal with ImageJ, images, and selections.
  prefs: []
  type: TYPE_NORMAL
- en: ImageJ main class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To access the main ImageJ window, we can use the `IJ` class to get the current
    instance of ImageJ. We can use this instance to gain access to some parameters
    that are provided by the ImageJ class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this short example, we created a variable of type `ImageJ` and stored a reference
    to the current instance of the `ImageJ` window in this variable, called `ij`.
    Next, we extracted the content of the ImageJ status line and stored it in a variable
    called `status`. Finally, we set the text of the status line to `Now we modified
    the status line text!`. Of course, this example is neither directly useful nor
    complete, but it shows you how to get access to the main `ImageJ` interface and
    modify a component of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I used two different ways of declaring and instantiating a variable: the `ij`
    variable was first declared and then instantiated, while the `status` variable
    was declared and instantiated in one line. The former would be required if your
    variable requires an extended scope (that is, across a loop or an entire class).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use the `IJ` class to execute commands that are part
    of the ImageJ menu structure using the `run()` method or methods such as `openImage()`
    to load images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line shows you how to zoom in once using the `run()` method from
    the `IJ` class. The third line shows you how to open an image using the `openImage()`
    method, which stores a reference to the image in a variable named `imp` in this
    example. To gain access to an image from within a BeanShell script, we can use
    the `openImage()`, as described earlier, to open an image. Alternatively, we could
    use the current active image (if there is an opened image):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in Fiji, which uses the ImageJ2 release candidate, it is required
    that you add the import statement before using the `IJ` class' methods. In ImageJ1.x,
    these packages are auto-loaded and the import statement is optional. To make sure
    your scripts are future proof, it is best practice to include the import statements.
  prefs: []
  type: TYPE_NORMAL
- en: Functions to process images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the ImageJ class, you have access to the currently active image as well
    as to the methods to open images. There are also methods that allow you to process
    images on a pixel level using the `ImageProcessor` class. This class provides
    methods that can modify the image at the pixel level: either a single pixel or
    a group of pixels. The following snippet shows you how to use the `ImageProcessor`
    class to change the value of a specific pixel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we opened the **Blobs** sample image and got `ImageProcessor`.
    We then inverted the LUT (the **Blobs** image uses an inverted LUT when opened)
    and put the inverted image back in the `imp` object. Finally, we set the value
    for the pixel at the coordinates (x = `64`, y = `128`) to a value of `255`. In
    this example, you will see a white pixel in one of the blobs at the location (`64,128`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the active image is an 8-bit image (as is the case for the **Blobs** image),
    this would result in a white pixel. In a 16-bit image this operation would result
    in a dark-gray pixel. If you want to know if the current image is a gray scale
    image and how many bits per pixel (8, 16, 24, or 32) it has, you could include
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to determine exactly what kind of image you are dealing
    with. If `bGray` is `true`, the image is an 8,16, or 32 float grayscale image
    or a 24-bit image with identical values for the pixels in the red, green, and
    blue channels. The `bitDepth` value will tell you which level it is. The distinction
    is small, but significant. A 24-bit image that contains color information is not
    the same as a 24-bit image that is gray. The latter can be converted to an 8-bit
    image without loss of information, while the former cannot be converted to an
    8-bit image without losing the color information.
  prefs: []
  type: TYPE_NORMAL
- en: Functions for selections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To gain access to selections in the ROI Manager, BeanShell scripts allow you
    to get an instance of the ROI Manager, which can then be used to extract the ROIs
    and use them for processing. The following code snippet takes the ROIs from the
    ROI Manager and enlarges them by `2` pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet shows you some basic scripting to deal with ROIs. We first retrieved
    an instance of the ROI Manager, which allows us to get the ROIs as an array for
    processing. In the loop, we selected each ROI and used the enlarge command to
    increase the size of the ROI by `2` pixels in the *X* and *Y* directions. Finally,
    we added the enlarged ROIs to the ROI Manager so that we could use them later
    on if we would like to. This code can be used almost verbatim as Java code. The
    first error you would receive if you tried to compile it is contained in the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This works perfectly fine in a BeanShell script, but in an ImageJ plugin, it
    will generate an error as the type of the `imp` variable is not declared. Also,
    the for loop does not declare the type for the index `i` iterator, which will
    also generate a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and running your scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have created a testable version, we can save it and try running it.
    Macros are stored with either the `.ijm` or the `.txt` extension. The `.ijm` extension
    is preferable, as it allows the distinction between regular (non-script) text
    files and macro files. Script files have their own extensions: `.bsh` for BeanShell
    and `.js` for JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: When saving the script, the naming has to adhere to the limitations of the filesystem.
    Otherwise, there are no specific restrictions for the name. The location to store
    the scripts by default is the `scripts` or `macros` folder in the ImageJ installation
    folder, which I will refer to as `$IJ_HOME`. If you wish to run scripts from the
    command line, it is best to avoid using spaces in the filename to avoid unexpected
    behavior (that is, if you forget to escape the space character).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Fiji, the `$IJ_HOME` folder is called `Fiji.app` and can be placed at any
    location in the filesystem. It is recommended that you store this folder in your
    user account's folder, where you have read and write access. On OSX systems, the
    default location for Fiji is `/Applications/Fiji.app` when using the package installer.
  prefs: []
  type: TYPE_NORMAL
- en: As described about ImageJ macros in the previous chapter, BeanShell and JavaScript
    scripts can be installed and executed in similar ways. When using Fiji, you can
    open the scripts in the code editor to run them.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins for ImageJ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous sections on the BeanShell scripting language, ImageJ
    provides an easy interface that has access to the full Java API. This also holds
    true for plugins. Besides the core ImageJ API, plugins can also access the full
    Java API by importing classes or interfaces in their source files. With the current
    developments within the ImageJ community, there is a new implementation of the
    ImageJ core code being developed, called ImageJ2\. In the following sections,
    I will briefly give an overview of some of the changes that will influence the
    development of plugins. This involves introducing some constructs that are used
    commonly in larger projects, specifically Git and Maven. Note that knowledge of
    these constructs is not essential to create plugins, but they will help in creating
    more consistent and reproducible code. These constructs are also not specific
    for ImageJ2, but the ImageJ2 project was built up around those concepts. However,
    I will start by introducing some classes that are specific for ImageJ and deal
    with handling images and selections.
  prefs: []
  type: TYPE_NORMAL
- en: ImageJ main class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main ImageJ class refers to the class that gives access to the ImageJ application.
    We already saw this class in the BeanShell sections earlier. The class is called
    IJ, which is a static utility class. As shown earlier, this class allows access
    to the current image as well as other functions. The use of this class is the
    same as shown earlier, except when writing plugins, you need to explicitly declare
    the variable type. For instance, when we wish to create a new hyperstack with
    two 16-bit channels and 10 frames and a size of 512 X 512 pixels, we could use
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we need to specify that the `imp` variable is of type `ImagePlus`,
    which differs from the scripting languages that we saw earlier. Another useful
    method of the `IJ` class is the `log()` logging method. This method prints a string
    to a log window, and displays the log window if it is not open yet. This function
    is useful for presenting intermediate results or status updates when processing
    large datasets. To use it, we can just call the method and supply the string we
    wish to print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This assumes there is a variable called `nFiles`, which stores the number of
    files that need to be processed. The log message will tell us how many files were
    processed, depending on the number of files selected when the plugin was executed.
    There are also methods to open images or get the active image, which are identical
    to the examples used in the scripting section (with the only difference that the
    type needs to be declared explicitly in a plugin).
  prefs: []
  type: TYPE_NORMAL
- en: WindowManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `WindowManager` class is a utility class in ImageJ that keeps track of
    all the windows (including images, results, and log windows), and provides methods
    that allow the selection of specific windows. Some of the most useful methods
    are `getImageTitles()`, `getImage()`, and `getCurrentImage()`. The `getImageTitles`
    method returns a `String` array with all the titles of open images. This function
    is useful to populate a list of files to allow the user to select a specific image
    for processing. The following example code will show this functionality and how
    it can be used within a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very user-friendly way of allowing the user to select the image for
    processing. Normally, ImageJ uses the last open images (the active image) by default.
    When the user has selected an image based on the title of the image, we can use
    the `getImage` method to activate that image for further processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This allows the rest of the program to use the specified image for processing.
    This code will be revisited in the chapter on plugins with user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: ImagePlus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main class for images is the `ImagePlus` class, which is the main class
    to deal with images in ImageJ. We already briefly saw the call in the code section
    earlier. When invoking the `ImagePlus` class, we gain access to several get methods
    that help with extracting information from the image. We also apply changes to
    the image using set methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows a few methods that allow you to retrieve aspects of the image
    as well as set a region in the current image. Another important method that can
    be accessed using the `ImagePlus` class is the `ImageProcessor` class, as shown
    in the first line of the code snippet. The next section will deal with this class.
  prefs: []
  type: TYPE_NORMAL
- en: ImageProcessor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ImageProcessor` class is a class that allows you to work with the pixel
    array of an image. There are four different subclasses of the `ImageProcessor`
    class, which are linked to the different image types: `ByteProcessor` for 8-bit
    and binary images, `ShortProcessor` for 16-bit images, `FloatProcessor` for 32-bit
    float images, and `ColorProcessor` for RGBα images. Some of the methods that are
    accessible from an `ImageProcessor` instance include `autoThreshold()`, `crop()`,
    `getPixel()`, and `getIntArray()`. These functions allow you to set a threshold
    on an image, crop the image, retrieve the pixel value at a specified location
    or get all the pixel values as an array, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: RoiManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `RoiManager` class gives the user access to the ROI Manager and all its
    functions. This class is essential to retrieve and manipulate the regions that
    were set either manually or programmatically. The `getRoisAsArray()` method allows
    the user to retrieve all the regions in the ROI Manager as an array, which enables
    the user to loop over all the regions for measurements or modifications to the
    regions. The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you use the `getInstance()` method to get a reference
    to the ROI Manager. If it returns a null value, you could use the constructor
    to create a new instance. After using the `getRoisAsArray()` method, you get an
    array of type `Roi`, which contains a list of regions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also merge the declaration and instantiating of the `regions` variable
    to a single statement. I prefer to declare my variables at the beginning of a
    method or class and instantiate them when I have the data available. Declaring
    a variable before instantiating it would be essential if you need the scope of
    the variable to extend beyond the point where it is instantiated or assigned.
    When a variable is used inside and outside of a loop, but the value is only assigned
    within the loop, the declaration needs to be placed outside of the loop and the
    assignment within the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The Roi class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Roi` class is a generic class that encompasses all the region types that
    ImageJ supports. You can use this class to retrieve relevant properties of a region,
    such as the bounding box of the region using the `getBounds()` method. It is also
    possible to change the size using the `grow()` method. The `Roi` class has several
    subclasses that are linked to the different region types available in ImageJ.
    Some of these subclasses have additional methods that are specific for area regions.
    For instance, the `PolygonRoi` subclass has methods to retrieve the coordinates
    of the polygon, `getXCoordinates()` and `getYCoordinates()`, which return an `int`
    array of coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The Application Programming Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with many programming languages, ImageJ has a well-documented **Application
    Programming Interface** (**API**). It describes all of the classes, methods, and
    fields that are accessible for programming. The API reference can be found on
    the ImageJ website at [http://javadoc.imagej.net/ImageJ1](http://javadoc.imagej.net/ImageJ1)
    (ImageJ1.x), [http://javadoc.imagej.net/ImageJ](http://javadoc.imagej.net/ImageJ)
    (ImageJ2), and [http://javadoc.imagej.net/Fiji](http://javadoc.imagej.net/Fiji)
    (Fiji). The API documentation is an efficient way to find classes and methods
    that can be used to extract relevant information. The classes mentioned in the
    previous sections can be found using the API page. You can also find a complete
    list of methods and fields that are available, including the return types of the
    methods. In the section on setting up an IDE to develop plugins, I will also briefly
    explain how to set up the generation of Javadoc. Javadoc is a method that parses
    your source code and extracts specially formatted comments to build up a documentation
    manual. This can be done for the ImageJ source code, which results in an API that
    can be accessed offline. I will also show you how to write your own Javadoc documentation
    and then generate an API for your own code in the chapter on plugin development.
    This is not essential for small projects, but can be very helpful for large projects
    with complex code that uses many classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up NetBeans IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now look at how to set up an **Integrated Development Environment**
    (**IDE**) that can be used to develop ImageJ as well as plugins for ImageJ. There
    are many IDEs available for Java. While this section will show you how to set
    up a specific IDE called NetBeans, many of these settings and configurations can
    be replicated in your preferred IDE.
  prefs: []
  type: TYPE_NORMAL
- en: The setup I will describe is for the NetBeans IDE, which is developed by the
    same company that manages the Java language. It can be downloaded in different
    variants, including a variant for Java development, webpage development, and C++
    development. If you only wish to develop plugins for ImageJ, the Java SE (Standard
    Edition) or Java EE (Enterprise Edition) downloads should be fine. The enterprise
    edition is similar to the standard edition, but it has additional APIs for multilevel
    and scalable applications as well as secure network applications. It is possible
    to extend the basic Java edition and add modules for web development or C++ coding
    later on using the **Plugins Manager** (**Tools** | **Plugins**).
  prefs: []
  type: TYPE_NORMAL
- en: For the upcoming sections, I will assume that the Java SE was installed. However,
    to set up the environment, it should not make a difference. It can be downloaded
    from [https://netbeans.org/downloads/](https://netbeans.org/downloads/). After
    downloading, it can be installed using the standard method for your platform.
    For Windows systems, there is an installer that can be run by double-clicking.
    For OS X, there is DMG with a package file that can be used for installation.
    For Linux systems, there is a shell script installer, and some distributions may
    supply it from their repositories. It is recommended that you use the version
    from the NetBeans website, as it is more recent than the version in many of the
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections will describe how to develop ImageJ1.x plugins without
    using project tools. This method only requires a single download and functions
    as a standalone development platform. If you wish to develop plugins using the
    Maven platform for ImageJ1.x and ImageJ2, the following sections can be skipped,
    and you can continue to the *Developing plugins using Maven* section.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering all components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the installation has completed, you should be able to launch the NetBeans
    application. When you launch it for the first time, there will be a start page
    that allows you to take a tour of the software and watch a quick tutorial project.
    You can examine the settings and adjust them to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to download the source code for ImageJ. The source code can be
    downloaded from the ImageJ website at [http://imagej.nih.gov/ij/download/src/](http://imagej.nih.gov/ij/download/src/),
    where you will find a list of different versions, from version 1.20 up to the
    most recent version (1.50a). Which version you download is not critical. However,
    it is best to use the most recent version with the recent bug fixes and functionality
    added. After the download has finished, the archive can be extracted, resulting
    in a folder named `source`. For the following sections, I will assume that the
    content of the `source` folder was extracted to the `ij/src` folder within the
    Documents folder of your user profile. This folder location will be referred to
    as the `source` folder in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The setup of the project described here follows the description given at [http://rsb.info.nih.gov/ij/developer/NBTutorial.html](http://rsb.info.nih.gov/ij/developer/NBTutorial.html),
    but with a few adjustments. First, the method to create a project does not work
    properly when using NetBeans version 8.0\. The steps described here will accomplish
    the same result but with a few key changes.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to set up a new project for ImageJ in NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, go to **File** | **New Project…**, which will open the following dialog:![Setting
    up a project](img/Insert_image_4909_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog, select the **Java** category and select **Java Free-Form Project**,
    as shown in the figure. Then, click on **Next >**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, we have to select the folder that contains the source. **Click
    on Browse…** and select the `src` folder that contains the extracted source code.
    If the copying was done properly, the remaining fields will be completed automatically
    with the correct information:![Setting up a project](img/Insert_image_4909_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now click on **Next >** to proceed to **Build and Run Actions** and then
    click on **Next** again without modifying the fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, we have to set the locations that will contain our source
    code for ImageJ and for our plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do so, add the `ij/src/ij` and `ij/src/plugins` folders in the **Source Package
    Folders** field. You can remove the first entry marked with a period from the
    source package folders. I have set the source level to JDK 1.7, which forces NetBeans
    to use a newer version of Java compared to the definition in the build instructions
    of the ImageJ source code:![Setting up a project](img/Insert_image_4909_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on **Finish** to complete the setup process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last two steps can be kept to default settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project will now be created, and the main window of NetBeans will show
    the new project in the **Projects** tab on the left-hand side. The project name
    (`ImageJ`) has two package sources below it: one for ImageJ source code (`ij`)
    and one for the plugin source code (`plugins`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Files** tab will show an overview of the files associated with the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a project](img/Insert_image_4909_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next section will look at the configuration required building build ImageJ.
  prefs: []
  type: TYPE_NORMAL
- en: Building ImageJ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now set up the environment to build ImageJ. This will allow us to create
    a functional ImageJ program from which we will be able to execute our plugins
    and macros. The first step is to modify the build instructions that will be used
    when building the ImageJ project. To do so, select the **Projects** tab and double-click
    on the `build.xml` file at the bottom of the ImageJ project to open the build
    file. This is a standard XML file that can be edited using the XML syntax. To
    disable sections of code, you can use either a comment tag (`<!-- -->`) around
    that section or delete it completely. The comment method is advised if you wish
    to restore the file to the original state. The first line that needs to be disabled
    is line 12 (I''m using comments to disable it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Save the file after making the change. Next, we will remove the two `.source`
    files from the `plugins` folder, but not the `.class` files. We can now start
    building ImageJ, by clicking on **Run** | **Build Project (ImageJ)** or pressing
    *F11*. There may be a few red warnings in the **Build output** window, but these
    can be ignored for now. At the end of the output, it should say **BUILD SUCCESSFUL**.
    We will now add the newly created ImageJ build to the project. To do so, go to
    **File** | **Project Properties (ImageJ)** and then to the **Java Sources Classpath**
    category. First, select **ij[ij]** as the source package folder and click on the
    **Add JAR/Folder** button. Browse to the `src` folder, select the `ij.jar` file,
    and press the **Choose** button. Repeat this for the `plugins [plugins]` source
    package folder, and then press **OK** to finish. We are now ready to set up the
    configuration to develop plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now create a very basic plugin to prepare everything to compile and
    debug plugins using NetBeans. First, switch to the **Files** tab and right-click
    on the plugins folder. Then, go to **New** | **Java Class** from the context menu.
    In the dialog that opens, set the **Class Name** to `Plugin_Frame` (or something
    else, but always include an underscore in the name!). It is advised that you create
    a package for the new class instead of the default package (I''m using **Template**
    as an example). Click on **Finish** to create the new Java source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a plugin](img/Insert_image_4909_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will place the following code in the newly created source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will create a plugin that inverts the LUT of the currently active image.
    Next, save the source file, and we will compile the code that we just added to
    our source file. To compile the source code, go to **Run** | **Compile File**
    or press *F9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A window will pop up to ask whether you wish to generate an ide-file-targets.xml
    file, so click on **Generate**. A new file will open that contains the build instructions
    for your plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a plugin](img/Insert_image_4909_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `ide-file-targets.xml` file, we will modify two lines. First, we will
    change line 9 to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will replace `${build.classes.dir}` with `plugins`. Next, we will comment
    line 8 (or delete it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, save the modified file and select your plugin file again. We will compile
    the file again by going to **Run** | **Compile File** or by pressing *F9*. In
    the output view, it should show that the build was successful. Next, we are going
    to set up the debugging for plugins. Select **Debug** | **Debug Project (ImageJ)**
    at which point a dialog will pop up asking for the output to be set. Click on
    **Set Output** and then on **OK** to accept the default values. Go to **Debug**
    | **Debug Project (ImageJ)** again, and NetBeans will ask to generate an `ide-targets.xml`
    file. Click on **Generate** to create the file and leave the file unaltered. For
    the final time, go to **Debug** | **Debug Project (ImageJ)**. This time, ImageJ
    will launch, and your plugin can be found in the **Plugins** menu. To start your
    plugin, select **Plugins** | **Template** | **Plugin Frame Plugin**, and your
    plugin should become visible.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you want to test or change your code, remember to close the ImageJ
    instance that was created when you select debug. Every time you select **Debug
    Project (ImageJ)**, a new ImageJ window will open. This will make it very difficult
    to keep track of which code you are actually debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Creating documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java language has a nicely integrated way of creating documentation using
    specially formatted comments within the source files. When applied consistently
    in your source files, it can be very easy to create an API document. In the next
    section, we will look at how to set up the basics for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: ImageJ Javadoc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will first generate the Javadoc for the ImageJ project. To do so, we will
    select the ImageJ project and go to **Run** | **Generate Javadoc (ImageJ)**. The
    Javadoc will be generated for the ImageJ project in a folder named `api`, which
    can be found in the `/ij` folder. It contains a list of HTML files and style files.
    To view the documentation, just view the `index.html` file in a web browser, and
    you will see the ImageJ API documentation. This view is very similar to the API
    that we saw online in the section on the API, and the information is identical.
    It is usually not necessary to generate Javadoc for the ImageJ project multiple
    times, unless you modify the documentation. In the next section, we will look
    at creating some Javadoc comments for your own plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Plugin Javadoc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To generate Javadoc for your plugins, you need to add some specially formatted
    comments to your code. There is a lot of documentation about Javadoc online, so
    the information presented here will be very basic, but should provide a useful
    starting point. To start with, you first need to decide how much documentation
    is required. You can make well-crafted documents with a lot of detail, but if
    your code is very simple, it would cost much more time to write the documentation
    than to develop the code. That being said, it will be helpful to have some documentation
    to be able to identify the function that a method serves after some time has passed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of documentation for a simple method that has input
    parameters and an output parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the basic method definition of a function to measure some properties
    of a collection of regions within an image, and it returns an array of measurements.
    To include the documentation, we will precede the function definition with the
    following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A Javadoc section needs to start with a forward slice followed by two asterisks.
    When you press enter after the Javadoc opening tag, NetBeans will generate the
    code for the input parameters (`@param`) and the return value (`@return`) automatically.
    The only thing you have to add is the actual meaning of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your code has been documented, you will have to instruct NetBeans to build
    the Javadoc code. To do this, make the following adjustments to the `build.xml`
    file by replacing the existing `javadoc` section (it should be at the end of the
    file) with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will build the ImageJ and your plugins documentation in a folder named
    `plugins_api`, located one level above your source data. If you created a package
    for your plugins, you also need to create a `package-info.java` file that contains
    the information about the package. To create this info file, right-click on your
    package in the **Projects** view and go to **New** | **Java Package Info…** from
    the context menu. Alternatively, you can also go to **New** | **Other…** in the
    menu. In the dialog that opens, just click on **OK** to accept the default values.
    The file will be generated, and you can add your package documentation right above
    the package line in the usual way. You need to create this info file for every
    package that you create.
  prefs: []
  type: TYPE_NORMAL
- en: After the documentation is compiled, you can view it by opening the `plugins_api/index.html`
    file in a browser. The ImageJ documentation will be shown first in the overview
    panel in the top-left corner. At the bottom will be your package(s). By clicking
    on them, you will see all the classes that are defined within the package. When
    you click on a class, the documentation that you supplied will be shown and can
    be browsed.
  prefs: []
  type: TYPE_NORMAL
- en: Developing plugins using Maven
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, I discussed how to set up NetBeans for the development
    of ImageJ and plugins in a standalone configuration. However, as the design of
    ImageJ is being expanded, there was a need to create a more modular approach.
    This approach involves a more project-based building of different modules into
    a single program. The advantage of such a modular approach makes for a very flexible
    application that can be expanded in the future. The disadvantage is that it requires
    a little more overhead to make sure that all dependencies are met for a fully
    functional program. This is where Apache Maven comes in. Maven is a toolset to
    describe how to build a project into a finished program and which dependencies
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: It does this using a special file called the **Project Object Model** (**POM**),
    which is an XML file. This file is stored in the root of your project and is called
    `pom.xml`. The content of the file describes some aspects of the project, such
    as a unique set of identifiers, and a list of dependencies that are required by
    the project. When you tell Maven to parse the POM file, it will collect all the
    required resources and compile the source code, run specified tests, and finally
    package the program in a JAR file. Maven is aimed at taking a clear project description
    and performing all the required tasks necessary to create the final package automatically
    without the developer needing to specify each step manually. This is what the
    previous sections described using the Ant mechanism to build code. First, let's
    look at how the POM is constructed in Maven, and how it's used to build a project.
  prefs: []
  type: TYPE_NORMAL
- en: Construction of the POM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The POM file describes the structure of a project. It describes the location
    of the source code (by default, this is `/src/main/java`) and the build directory
    where the compiled program is stored (by default, this is `/target`). The minimal
    POM file contains the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This minimal POM file will inherit all the defaults from the `Super POM` file.
    This means, everything that is not explicitly named in the POM; the default values
    will be used. This includes values such as the location of the source files, the
    `build` directory, the build file type (`.jar` by default), and other options
    such as the repositories used to download sources. For an ImageJ1.x plugin, the
    following POM is the minimal description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This describes the project using ImageJ as the parent project. This is necessary
    because the plugin we want to develop requires the ImageJ to be built. Next, we
    specified the `artifactId` using the name of our plugin; in this case, I used
    the generic name `Plugin_Name`. In the `properties` field, we stated the main
    class of the project, which is the name of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `<version>` tag within the `<parent>` tag will control which version
    of ImageJ1.x will be retrieved. Using version 7.0.0 will retrieve version 1.49q,
    while 13.2.0 will retrieve version 1.50a.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we described the dependencies that are required for the plugin, which
    is ImageJ for a plugin. Finally, we described the build process, stating that
    we want a JAR file. The manifest should include the `main` class described by
    the main-class field in the properties object. This method does not require any
    downloading of source code. The next section will explain how to set up a plugin
    for ImageJ1.x using a POM in NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Maven plugin project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using a Maven project to develop a plugin is very simple and only requires
    a few basic steps. In many cases, you can use the default values from the POM
    model, and you will only need to specify the name of your plugin(s), a version
    number, and an artifact name. We will start by creating a new Maven project using
    NetBeans by going to **File** | **New Project** from the menu. From the categories
    list, we will select **Maven**, and from the **Projects** list, we will select
    **POM Project** and click on **Next >**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next window, we can set the main properties of our plugin. For this
    example, I will create a dummy plugin that I will call `Awesome_Plugin`. I will
    place it in the NetBeans workspace folder, which is the default folder that is
    created when you install NetBeans:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I added **Group ID** and a version number, but these can be changed later on
    quite easily. After pressing **Finish**, the project will be created and added
    to your project view (if you cannot see your project view, select **Window** |
    **Projects** from the menu). If you expand the project, you will notice that there
    are three folders, with the most important one, at the moment, being **Project
    Files**. This folder contains the `pom.xml` file that we will edit next. You can
    open the POM file for editing by expanding the project files folder in the project
    or by right-clicking on the project root and selecting **Open POM** from the context
    menu. The POM file will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, NetBeans added a few more properties to the `<project>` tag,
    identifying the XML schema that was used for this POM file. It also set the `<properties>`
    tag with a tag stating the source file encoding that will be used (UTF-8). It
    also states which packaging will be used. For plugins, we need to change this
    to JAR. There are two ways to change a parameter in the POM file. The first one
    is to modify the `pom.xml` file directly by adding or modifying tags. The other
    option is to select **Properties** from the context menu by right-clicking on
    the project. This will provide a form that contains many of the fields that are
    placed in the `pom.xml` file. For the remainder of this section, I will assume
    we edit the `pom.xml` file directly, as this allows for more flexibility and gives
    access to more tags than the properties dialog provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to state that we require ImageJ to be present for our plugin, we will
    include the `<parent>` tag and its contents, as shown earlier. Next, we will take
    the `<dependencies>` tag and its contents and add them to the `pom.xml` file.
    When we now save the `pom.xml` file, you may notice that the folder structure
    in the project view changes. There are now only two folders called `Dependencies`
    and `Project Files`. You may also notice that the **Dependencies** folder contains
    two files: `ij-1.50a.jar` and `tools.jar`. These files are `required` to launch
    ImageJ. The former file is the actual ImageJ program, while the latter is a jar
    file that ImageJ requires to run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to build or run our project at this stage, we will get an error from
    NetBeans. It is complaining that the project is missing a file to build. This
    is not surprising as we haven''t stated which file we want to build. Also, we
    haven''t defined a main class yet to run, so we first need to fix this issue.
    To state where our main class will be, we will add the `<main-class>` tag to the
    `<properties>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have stated where our main class will be found, we need to specify
    how to build the project. We will do this using the `<build>` tag, as shown in
    the minimal `ImageJ POM` earlier. The line within the `<manifest>` tag describes
    that we wish to use the main class defined in the properties described by the
    `<main-class>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving the POM file, we can try to build the plugin again, but we will
    still get an error. This is because we are still missing the actual source code.
    We have created a project description, but we haven''t created a source file yet.
    We will now add a source file to our project, which must have the same name as
    the value of the `<artifactId>` tag. To add the source file, right-click on the
    project in the project view and select **New** | **Java Class**. This will open
    the **New Java Class** dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The filename needs to be set to `Awesome_Plugin` for this example, as this is
    the `artifactId` that we used up to now. The folder where we wish to place the
    file needs to be specified as `/src/main/java`, as this is the default location
    used in POM projects. Since I did not change this value, we need to specify it
    here as well. If you change the location of the source folder, you need to specify
    it in the new Java class and POM files. After clicking on **Finish**, the file
    will be created and displayed in your project inside a new folder. The `Source
    Packages` folder has been added and contains a package called `<default package>`,
    which contains your source file called `Awesome_Plugin.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to place the plugin in a specified package, you can add a package
    declaration to your source file and ask NetBeans to move the file to the correct
    folder. The latter can be done after we add the package statement. We can then
    press *Alt* + *Enter* while the cursor is on the package statement and select
    **Move class to correct folder** from the context menu. This example assumes that
    we kept the default package.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we now build the project, we will see that the build is successful, meaning
    that everything is set up correctly for building. However, when we try to run
    the project, we will need to supply the main class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The problem now is that we don''t have a main class at this stage. The source
    code only has a class declaration, but we haven''t added any code or a main method.
    To fix this, we need to add a main method to the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard main method that is common to Java programs. This method
    is not required for ImageJ plugins. The standard entry point for plugins is usually
    the run method (`Plugin` and `PlugInFilter`) or the constructor (`PlugInFrame`).
    This main method is only for the purpose of the Maven build process and to make
    sure that ImageJ is started by instantiating a new ImageJ object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line gets a reference to the plugin class that we created. In the
    next line, we extracted the full path, including the class file. This URL will
    have the following format: `file:/path/to/Awesome_Plugin.class`. In the next line,
    we removed the `file:` and the `Awesome_Plugin` parts from the beginning and end
    of the URL, respectively, using the `lastIndexOf()` method. The `clazz.getName()`
    call will return a string that will have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class Awesome_Plugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class package.name.Awesome_Plugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second format would be used if you used a package for your plugin, while
    the first format is used when you omit the package statement from your plugin.
    Using the `lastIndexOf()` method, we can include the package folders in the path
    as well, resulting in an error-free compilation and the correct placement of the
    plugin in the **Plugins** menu. We will then add the folder that contains the
    class to the `plugins.dir` property. Finally, we will start ImageJ by invoking
    a new instance using the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we have the minimal code to run and debug our plugin. When we
    run the project now, ImageJ should open, and the plugin should be visible in the
    **Plugins** menu. We can select it, but it may generate an error when we select
    the plugin from the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This would occur if you used a package definition in your class file (in my
    example, I used the `analysis.tools` package). You can solve this by adding the
    following line to the end of your main method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will run the plugin immediately after ImageJ has started. If you defined
    the class without a package statement, you would not encounter this problem. It
    is, therefore, easier to start by developing plugins using the source files without
    a package statement. In the upcoming chapters, we will look at what we need to
    do to make a functional plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ImageJ2 plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The steps to create a Maven project for an ImageJ2 plugin is very similar to
    the steps taken in the previous section. Only a small change is required in the
    POM file within the `<dependencies>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By changing the value of the `<artifactId>` tag from `ij` to `imagej`, we specify
    that we wish to implement an ImageJ2 instance. When we **Save and Build** the
    project, we will see that the `imagej-2.0.0-rc-41.jar` file has replaced the earlier
    `ij-1.50a.jar` file. We would also need the repository for the ImageJ2 project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The final change that is required is within the plugin source code. We need
    to use different import statements and change the way ImageJ is launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The syntax of ImageJ2 used in plugins is also different compared to ImageJ1.x,
    which is a topic we will discuss in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of using an IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using an IDE such as NetBeans has some benefits to help you write code. There
    are options to autocorrect coding errors and the possibility to automatically
    import dependencies. The disadvantages are not very big, but working with an IDE
    has a lot of overhead in terms of preparations and setting up. No matter how complete
    the IDE is, it can still not tell you how to solve a problem. Also, in some cases,
    it can be faster to just type the code directly using the script editor supplied
    with Fiji. The IDE is also not well suited to develop ImageJ macros, because macros
    in ImageJ are not compiled and are, therefore, not easy to integrate in the workflow
    of the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the framework of macros and plugins that are available
    in ImageJ. We looked at some of the constructs that the ImageJ API exposes for
    use in scripting and plugins. Finally, we described how to set up an IDE to develop
    ImageJ and plugins using it as standalone project or as a Maven-based project.
    You also saw how to generate documentation using the Javadoc utility.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some plugins that are available and how
    they provide a solution to image-processing problems.
  prefs: []
  type: TYPE_NORMAL
