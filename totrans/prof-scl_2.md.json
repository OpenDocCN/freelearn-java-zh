["```java\nobject Chatbot3 {\nval effects = DefaultEffects\ndef main(args: Array[String]): Unit = {\n   ….}\n   def createInitMode() = (Bye or CurrentDate or CurrentTime) otherwise InterestingIgnore\n}\n```", "```java\n       def hello(): Unit = {\n           println(\"hello\")\n        }\n      - navigate to main object\n       Insert before start of main method:\n        val example = ExampleObject\n       Insert at the beginning of the main method:\n         example.hello()\n    ```", "```java\npackage com.packt.courseware.l4\nimport math._\nclass PolarPoint(phi:Double, radius:Double) extends Point2D\n{\nrequire(phi >= - Pi && phi < Pi )\nrequire(radius >= 0)\ndef this(phi:Double) = this(phi,1.0)\noverride def length = radius\ndef x: Double = radius*cos(phi)\ndef y: Double = radius*sin(phi)\ndef * (x:Double) = PolarPoint(phi,radius*x)\n}\n```", "```java\nval p = new PolarPoint(0)\n```", "```java\ncase class PolarPoint(val phi:Double, val radius:Double) extends Point2D\n```", "```java\nobject PolarPoint{\ndef apply(phi:Double, r:Double) = new PolarPoint(phi,r)\n}\n```", "```java\n    case class CartesianPoint(x:Double, y:Double) extends Point2D {\n    override def length(): Double = x*x + y*y\n    }\n    ```", "```java\ncase class PolarPoint(phi:Double, radius:Double) extends Point2D\n```", "```java\n    val p1 = PolarPoint(Pi,1)\n    val p2 = p1.copy(phi=1)\n    ```", "```java\n    class NCPoint(val x:Int, val y:Int)\n    val ncp1 = new NCPoint(1,1)\n    val ncp2 = new NCPoint(1,1)\n    ncp1 == ncp2\n    ncp1 eq ncp2\n    ```", "```java\n    case class CPoint(x:Int, y:Int)\n    ```", "```java\n    val cp1 = CPoint(1,1)val cp2 = CPoint(1,1)cp1 == cp2cp1 eq cp2\n    ```", "```java\nval p = PolarPoint(0,1)\nval r = p match {\ncase PolarPoint(_,0) => \"zero\"\ncase x: PolarPoint if (x.radius == 1) => s\"r=1, phi=${x.phi}\"\ncase v@PolarPoint(x,y) => s\"(x=${x},y=${y})\"\ncase _ => \"not polar point\"\n}\n```", "```java\n    case class Person(firstName:String,lastName:String)\n    ```", "```java\n    def classify(p:Person): String = {\n    // insert match code here .???\n    }\n    }\n    ```", "```java\n    class PersonTest extends FunSuite {\n    test(\"Persin(Joe,_) should return A\") {\n    assert( Person.classify(Person(\"Joe\",\"X\")) == \"A\" )\n    }\n    }\n    }\n    ```", "```java\ntrait Point2D {\ndef x: Double\ndef y: Double\ndef length():Double = x*x + y*y}\n```", "```java\ncase class CartesianPoint(x:Double, y:Double) extends Point2D\n```", "```java\nval p = new Point2D {override def x: Double = 1\noverride def y: Double = 0}\nassert(p.length() == 1)\n```", "```java\ntrait A {\ndef f = \"f.A\"\n}\ntrait B {def f = \"f.B\"def g = \"g.B\"\n}\ntrait C extends A with B {override def f = \"f.C\" // won't compile without override.\n}\n```", "```java\ntrait D1 extends B1 with C{override def g = super.g}\ntrait D2 extends C with B1{override def g = super.g}\n```", "```java\ntrait Component{\ndef description(): String\n}\ntrait Transmitter extends Component{\ndef generateParams(): String\n}\ntrait Receiver extends Component{\ndef receiverParame(): String\n}\ntrait Radio extends Transmitter with Receiver\n```", "```java\ntrait Drink\n{\n def baseSubstation: String\n def flavour: String\n def description: String\n}\n\ntrait VanillaFlavour\n{\n thisFlavour: Drink =>\n\n def flavour = \"vanilla\"\n override def description: String = s\"Vanilla ${baseSubstation}\"\n}\n\ntrait SpecieFlavour\n{\n thisFlavour: Drink =>\n\n override def description: String = s\"${baseSubstation} with ${flavour}\"\n}\n\ntrait Tee\n{\n  thisTee: Drink =>\n\n  override def baseSubstation: String = \"tee\"\n\n  override def description: String = \"tee\"\n\n    def withSpecies: Boolean = (flavour != \"vanilla\")\n}\n```", "```java\ntrait Out{\nthisOut =>\n\ntrait Internal{def f(): String = thisOut.g()\n  def g(): String = .\n  }\ndef g(): String = ….\n}\n```", "```java\n    val tee = new Drink with Tee with VanillaFlavour\n    val tee1 = new Drink with VanillaFlavour with Tee\n    tee.description\n    tee1.description\n    ```", "```java\n    val tee2 = new Drink with Tee with VanillaFlavour{\n    override def description: String =\"plain vanilla tee\"\n    }\n    ```", "```java\ntrait Operation\n{\n\n  def doOperation(): Unit\n\n}\n\ntrait PrintOperation\n{\n  this: Operation =>\n\n  def doOperation():Unit = Console.println(\"A\")\n}\n\ntrait LoggedOperation extends Operation\n{\n  this: Operation =>\n\n  abstract override def doOperation():Unit = {\n    Console.print(\"start\")\n    super.doOperation()\n    Console.print(\"end\")\n  }\n}\n```", "```java\ntrait EffectsProvider extends TimeProvider {\n\n def input: UserInput\n\n def output: UserOutput\n\n}\n\nobject DefaultEffects extends EffectsProvider\n{\n override def input: UserInput = ConsoleInput\n\n override def output: UserOutput = ConsoleOutput\n\n override def currentTime(): LocalTime = LocalTime.now()\n\n override def currentDate(): LocalDate = LocalDate.now()\n}\n```", "```java\ntrait UserOutput {\n\n def write(message: String): Unit\n\n def writeln(message: String): Unit = {\n  write(message)\n  write(\"\\n\")\n }\n\n}\n\nobject ConsoleOutput extends UserOutput\n{\n\n def write(message: String): Unit = {\n  Console.print(message)\n }\n}\n```", "```java\n    object ConsoleOutput extends UserOutput{\n    def write(message: String): Unit = {\n    Console.print(message)\n    }\n    }\n    }\n    ```", "```java\n    object DefaultTimeProvider extends TimeProvider {\n    override def currentTime(): LocalTime = LocalTime.now()\n\n      override def currentDate(): LocalDate = LocalDate.now()\n      }\n\n     }\n    ```", "```java\ntrait ChatbotMode {\ndef process(message: String, effects: EffectsProvider): LineStepResult\ndef or(other: ChatbotMode): ChatbotMode = Or(this,other)\ndef otherwise(other: ChatbotMode): ChatbotMode = Otherwise(this,other)\n}\n```", "```java\nsealed trait LineStepResultcase class Processed(\n  answer:String,\n  nextMode: ChatbotMode,\n endOfDialog:Boolean) extends LineStepResult\ncase object Failed extends LineStepResult\n```", "```java\nobject Bye extends ChatbotMode {\n override def process(message: String, effects: EffectsProvider): LineStepResult =\n  if (message==\"bye\") {\n   Processed(\"bye\",this,true)\n  } else Failed\n}\n```", "```java\ncase class Or(frs: ChatbotMode, snd: ChatbotMode) extends ChatbotMode\n{\noverride def process(message: String, effects: EffectsProvider): LineStepResult ={\nfrs.process(message, effects) match {\ncase Processed(answer,nextMode,endOfDialog) => Processed(answer, Or(nextMode,snd),endOfDialog)\ncase Failed => snd.process(message,effects) match {\ncase Processed(answer,nextMode,endOfDialog) => Processed(answer, Or(nextMode,frs),endOfDialog)\ncase Failed => Failed}}\n }}\n```", "```java\ndef or(other: ChatbotMode): ChatbotMode = Or(this,other)\n```", "```java\n def createInitMode() = (Bye or CurrentDate or CurrentTime) otherwise InterestingIgnore\n```", "```java\ndef main(args: Array[String]): Unit = {\nval name = StdIn.readLine(\"Hi! What is your name? \")\nprintln(s\" $name, tell me something interesting, say 'bye' to end the talk\")\nvar mode = createInitMode()\nvar c = Processed(\"\",mode,false)\nwhile(!c.endOfDialog){\nc = c.nextMode.process(effects.input.read(),effects) match {\ncase next@Processed(_,_,_) => next\ncase Failed => // impossible, but let be here as extra control.\n      Processed(\"Sorry, can't understand you\",c.nextMode,false)}\n  effects.output.writeln(c.answer)}}\n```", "```java\n    case class Name(name:String) extends ChatbotMode {\n    override def process(message: String, effects: EffectsProvider): LineStepResult = {\n    message match {\n    case \"my name\" => if (name.isEmpty) {\n    effects.output.write(\"What is your name?\")\n    val name = effects.input.read()\n    Processed(\"hi, $name\", Name(name), false)\n    } else {\n    Processed(s\"your name is $name\",this,false)}case _ =>  Failed\n    }\n    }\n    }\n    }\n    ```", "```java\n    def createInitMode() = (Bye or CurrentDate or CurrentTime or Name(\"\")) otherwise InterestingIgnore\n    ```", "```java\n    test(\"step of my-name\") {\n      val mode = Chatbot3.createInitMode()\n      val effects = new EffectsProvider {\n        override val output: UserOutput = (message: String) => {}\n\n        override def input: UserInput = () => \"Joe\"\n\n        override def currentDate(): LocalDate = Chatbot3.effects.currentDate()\n\n        override def currentTime(): LocalTime = Chatbot3.effects.currentTime()\n      }\n      val result1 = mode.process(\"my name\",effects)\n      assert(result1.isInstanceOf[Processed])\n      val r1 = result1.asInstanceOf[Processed]\n      assert(r1.answer == \"Hi, Joe\")\n      val result2 = r1.nextMode.process(\"my name\",effects)\n      assert(result2.isInstanceOf[Processed])\n      val r2 = result2.asInstanceOf[Processed]\n      assert(r2.answer == \"Your name is Joe\")\n\n    }\n    ```", "```java\ndef f(x:Int, y:Int) = x*2 + y\nf(x=1,y=2) // 4\nf(y=1,x=2) // 5\n```", "```java\ndef f(x:Int, y:Int=2) = x*2 + y\nf(1) // 4\n```", "```java\ncase class Person(firstName: String, lastName: String)\nval p1 = Person(\"Jon\",\"Bull\")\nval p2 = p1.copy(firstName = \"Iyan\")\n```", "```java\n           case processed:Processed =>processed.copy(nextMode = Or(processed.nextMode,snd))\n        ```", "```java\n          case processed@Processed(answer,nextMode,endOfDialog) =>\n             processed.copy(nextMode = Or(nextMode,snd))\n        ```", "```java\ncase class Or(frs: ChatbotMode, snd: ChatbotMode) extends ChatbotMode{\noverride def process(message: String, \n           effects: EffectsProvider): LineStepResult = {\n   frs.process(message, effects) match {\n   case processed@Processed(answer,nextMode,endOfDialog) =>\n   processed.copy(nextMode = Or(nextMode,snd))\n   case Failed => snd.process(message,effects) match {\n   case processed@Processed(answer,nextMode,endOfDialog) =>\n   processed.copy(nextMode=Or(nextMode,frs))\n   case Failed => Failed\n   }\n   }\n   }\n   }\n}\n```", "```java\ndef f1(x:Int,y:Int) = x + y \ndef f2(x:Int)(y:Int) = x + y\n```", "```java\n     def +(v:CartesianPoint) = CartesianPoint(x+v.x,y+v.y)\n    ```", "```java\n    def f(x:Int) = x + x + 1\n    f({ println(\"A \"); 10 }) // A res: 21\n    ```", "```java\ndef f(x: =>Int) = x + x + 1\nf({ println(\"A \"); 10 }) // A A res: 21\n```", "```java\ndef until(condition: =>Boolean)(body: =>Unit) ={\nwhile(!condition) body\n}\n```", "```java\nclass RunLater(x: =>Unit){\ndef run(): Unit = x\n}\n}\n```", "```java\ndef f(x: =>Int): Int = {lazy val nx = xnx + nx + 1\n}\nf({ println(\"A \"); 10 }) // A res: 21\n```", "```java\n    class DSLExample {val name: String = \"undefined\"var code: ()=>Unit = { () => () }\n    }\n    ```", "```java\n    def test(testName:String)(testCode: =>Unit):Unit = {\n    name = testName\n     code = () => testCode }\n    ```", "```java\n    def run(): Boolean = {\n    try {\n     code()\n     true} catch {\n    case ex: Exception => \n    ex.printStackTrace()\n    false\n    \t}\n    }\n\n    ```", "```java\n    class Logger(outputStream:PrintStream, dupToConsole: Boolean, enabled: Boolean) {\n\n         …. Inset method here\n\n    }\n    ```", "```java\n    def log(message: => String): Unit = {\n    if (enabled) {\n    \tval evaluatedMessage = message\n    \tif (dupToConsole) {\n    Console.println(evaluatedMessage)\n    }\n    outputStream.println(evaluatedMessage)\n    \t}\n    }\n\n    ```"]