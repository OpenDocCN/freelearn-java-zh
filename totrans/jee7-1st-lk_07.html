<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Annotations and CDI"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Annotations and CDI</h1></div></div></div><p>Right up to this moment, we had to use annotations and dependency injections without trying to understand how they work. This chapter therefore aims to present and highlight improvements in the relevant APIs. The APIs concerned are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Common annotations for the Java Platform 1.2</li><li class="listitem" style="list-style-type: disc">Contexts and Dependency Injection 1.1</li></ul></div><div class="section" title="Common annotations for the Java platform"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec32"/>Common annotations for the Java platform</h1></div></div></div><p>The common annotations for the <a id="id428" class="indexterm"/>Java platform 1.2 Specification was developed under <a id="id429" class="indexterm"/>JSR 250. This section just gives you an overview of improvements in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/mrel/jsr250/index.html">http://jcp.org/aboutJava/communityprocess/mrel/jsr250/index.html</a>.</p><div class="section" title="The goal of this specification"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>The goal of this specification</h2></div></div></div><p>Annotations are a form of metadata that are <a id="id430" class="indexterm"/>generally used to describe, configure, or mark elements (such as class, method, and attribute) of Java code. In the following code, we use the <code class="literal">@Stateless</code> annotation to configure <code class="literal">MySessionBean</code> class as a <a id="id431" class="indexterm"/>stateless session bean, we use the <code class="literal">@Deprecated</code> annotation to mark <code class="literal">oldMethod()</code> method <a id="id432" class="indexterm"/>as obsolete, and finally we set the <code class="literal">save()</code> method with <a id="id433" class="indexterm"/>the <a id="id434" class="indexterm"/>
<code class="literal">@TransactionAttribute</code> annotation so that it will always use a dedicated transaction.</p><div class="informalexample"><pre class="programlisting">@Stateless
public class MySessionBean {

  @Deprecated
  public void oldMethod(){}
  
    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
  public void save(){}
}</pre></div><p>The annotations have been integrated into the Java language since JDK 5 and they are now widely used in many APIs. To avoid redefining some annotations in several APIs, the JCP developed the common annotations for the Java platform specification with the goal of regrouping annotations that are <a id="id435" class="indexterm"/>common to different Java EE APIs, which avoids redundancy and facilitates the maintenance of regrouped annotations. In the <a id="id436" class="indexterm"/>following code, we have the example of the <code class="literal">@Resource</code> annotation from <a id="id437" class="indexterm"/>the common annotations for the Java platform API , which permits us to access an object of type <a id="id438" class="indexterm"/>
<code class="literal">SessionContext</code> in a web container and in an EJB container.</p><div class="informalexample"><pre class="programlisting">@Stateless
public class MySessionBean {

  @javax.annotation.Resource
  private SessionContext sctx;

  //...	
}
@ManagedBean
public class MyJsfManagedBean {
  @javax.annotation.Resource
  private SessionContext sctx;
  //...
}</pre></div></div><div class="section" title="Building your own annotation"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Building your own annotation</h2></div></div></div><p>Although there are already several <a id="id439" class="indexterm"/>annotations, Java offers the opportunity to create new custom annotations if you need. To do this, you should know that an annotation is declared as a Java interface. The only difference is that, in the case of the annotation the keyword <code class="literal">interface</code> must be preceded by the character <code class="literal">@</code>. The following code shows the declaration of the custom annotation <code class="literal">Unfinished</code>. This annotation contains a parameter named <code class="literal">message</code> whose default value is <code class="literal">Nothing has been done</code>.</p><div class="informalexample"><pre class="programlisting">public @interface Unfinished {
  String message() default "Nothing has been done";
}</pre></div><p>Once you declare your annotation, you must now define its characteristics. The basic characteristics of an annotation are defined through dedicated annotations contained in the <code class="literal">java.lang.annotation</code> package. <a id="id440" class="indexterm"/>These annotations are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@Target</code>: This is used to <a id="id441" class="indexterm"/>define the element types that can be <a id="id442" class="indexterm"/>annotated (such as class, method, and attribute), for example <code class="literal">@Target({ElementType.METHOD, ElementType.TYPE})</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">@Retention</code>: This is <a id="id443" class="indexterm"/>used to define the retention level (<a id="id444" class="indexterm"/>such as <code class="literal">RUNTIME</code>, <code class="literal">CLASS</code>, or <code class="literal">SOURCE</code>) of your annotation, for example <code class="literal">@Retention(RetentionPolicy.RUNTIME)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">@Inherited</code>: This is <a id="id445" class="indexterm"/>used to say that the annotation will be <a id="id446" class="indexterm"/>automatically applied to classes that inherit from the class that has the annotation</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Documented</code>: This is used to <a id="id447" class="indexterm"/>make your annotation appear in the <a id="id448" class="indexterm"/><span class="strong"><strong>Javadoc</strong></span> of the code that contains it</li></ul></div><p>It is important to note that there are other characteristics such as the scope (set using the <code class="literal">@ScopeType</code>) in the case of custom CDI scope annotations.</p><p>After all changes, our annotation takes the form shown in the following code. According to the settings, this annotation can decorate <a id="id449" class="indexterm"/>methods, types of objects (such as <code class="literal">class</code>, <code class="literal">interface</code>, or <code class="literal">enum</code>) and attributes. It will be removed at the compile time (because the retention level is <code class="literal">SOURCE</code>).</p><div class="informalexample"><pre class="programlisting">@Target({ElementType.METHOD, ElementType.TYPE, ElementType.FIELD})
@Retention(RetentionPolicy.SOURCE)
public @interface Unfinished {
  String message() default "Nothing has been done";
}</pre></div><p>The following <a id="id450" class="indexterm"/>code <a id="id451" class="indexterm"/>demonstrates the usage of the <code class="literal">Unfinished</code> annotation:</p><div class="informalexample"><pre class="programlisting">public class App {
    @Unfinished(message = "Make sure that this element is not null")
    String size;

    @Unfinished
    public static void main(String[] args) {
        System.out.println("Hello World annotation!");
    }
}</pre></div><p>Although our annotation already looks like a standard annotation, it is not yet operational. For this, a class called <code class="literal">processor</code> must be available to the compiler. This class will describe the action to take when an item is annotated with our custom annotation.</p><p>To achieve a custom processor for Java 6 annotation, we mainly need to implement the <code class="literal">process()</code> <a id="id452" class="indexterm"/>method of the <code class="literal">javax.annotation.processing.Processor</code> interface and define the annotations supported by this <a id="id453" class="indexterm"/>processor with the <code class="literal">@SupportedAnnotationTypes</code> <a id="id454" class="indexterm"/>annotation. The following <a id="id455" class="indexterm"/>code shows the processor of our custom <code class="literal">Unfinished</code> annotation. As you can see, for the <a id="id456" class="indexterm"/>implementation of the <code class="literal">process()</code> method, we used the abstract class <code class="literal">AbstractProcessor</code> that implements the <code class="literal">Processor</code> interface. (This prevents us from having to implement all the methods defined in this interface.)</p><div class="informalexample"><pre class="programlisting">@SupportedAnnotationTypes("com.packt.ch07.annotations.Unfinished")
public class UnfinishedProcessor extends AbstractProcessor {

  /**
  * For the ServiceLoader
  */
  public UnfinishedProcessor() {
  }

  @Override
  public boolean process(Set&lt;? extends TypeElement&gt;annotations, RoundEnvironment roundEnv) {
    try {
      //For each annotated element do ...
      for (Element e :roundEnv.getElementsAnnotatedWith(Unfinished.class)) {        
        Unfinished unf = e.getAnnotation(Unfinished.class);
        System.out.println("***** Class :"+e.getEnclosingElement()+", "+ "Annotated element : " + e.getSimpleName()+", "+ " Kind : "+e.getKind()+", Message :"+unf.message()+"**** ");                
      }
    } catch (Exception ex) {
      ex.printStackTrace();
    }
    return true;
  }
}</pre></div><p>Once the processor is realized, we must <a id="id457" class="indexterm"/>now declare it so that it can be found by the compiler. The simplest way to do this is to use the Java mechanism for services declarations using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Package your annotation in a <code class="literal">JAR</code> file.</li><li class="listitem">Include a <code class="literal">META-INF/services</code> directory in this <code class="literal">JAR</code> file.</li><li class="listitem">Include a file named <code class="literal">javax.annotation.processing.Processor</code> in the <code class="literal">META-INF/services</code> directory.</li><li class="listitem">Specify in this file the fully qualified names of the processors contained in the <code class="literal">JAR</code> file (one processor per line).</li></ol></div><p>The following screenshot <a id="id458" class="indexterm"/>shows the structure of the project that contains the <a id="id459" class="indexterm"/>
<code class="literal">Unfinished</code> annotation. Failing to put the annotation and the processor in the same project as is the case of our example, you can use one project for annotations and another for processors. But whatever your option, do not forget to define the service in the <code class="literal">META-INF/services</code> project directory that contains the processor.</p><div class="mediaobject"><img src="graphics/9235OT_07_01.jpg" alt="Building your own annotation"/></div><p>The following screenshot shows the contents of the file <code class="literal">javax.annotation.processing.Processor</code>. As the package contains only a single processor, then it is obvious that we will have a <a id="id460" class="indexterm"/>single line in this file as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/9235OT_07_02.jpg" alt="Building your own annotation"/></div><p>For those using <span class="strong"><strong>Maven v2.3.2</strong></span>, to achieve the project that contains the processors, they must set the option <code class="literal">&lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;</code> in the configuration of the plugin <code class="literal">maven-compiler-plugin</code> so that the code is properly compiled.</p><p>Now you can import the package that contains the annotation in another project and use it at your convenience. When compiling our preceding <code class="literal">App</code> class, we have the following result:</p><div class="informalexample"><pre class="programlisting">***** Class :com.packt.ch07.App, Annotated element : size,  Kind : FIELD, Message : Make sure that this element is not null****
***** Class :com.packt.ch07.App, Annotated element : main,  Kind : METHOD, Message : Nothing has been done****</pre></div></div><div class="section" title="Latest improvements in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>Latest improvements in action</h2></div></div></div><p>Affected by maintenance release, the <a id="id461" class="indexterm"/>common annotation specification has not greatly changed. We have in all, the addition of a new annotation and update of some sections of the specification document.</p></div><div class="section" title="The new annotation"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec51"/>The new annotation</h2></div></div></div><p>The new annotation that was <a id="id462" class="indexterm"/>added to the specification concerns the <a id="id463" class="indexterm"/>management of priorities when using a series of classes in a given order. This is the <code class="literal">javax.annotation.priority</code> annotation.</p><p>The exact role and the ranges of acceptable values for this annotation are defined by each specification that uses it.</p><p>For example, this annotation could be used to manage the execution order of interceptors.</p></div></div></div>
<div class="section" title="Contexts and Dependency Injection"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec33"/>Contexts and Dependency Injection</h1></div></div></div><p>The Contexts and Dependency Injection(CDI) for Java EE 1.1 Specification was developed under JSR 346. This section just <a id="id464" class="indexterm"/>gives you an overview of improvements in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr346/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr346/index.html</a>.</p><div class="section" title="What is CDI ?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec52"/>What is CDI ?</h2></div></div></div><p>Introduced in the Java EE platform <a id="id465" class="indexterm"/>from Version 6, Contexts and Dependency Injection for Java EE (CDI) is a specification that has brought to the platform a set of services that simplify the management of the lifecycle of objects, and standardize and encourage the use of dependency injection in the Java EE environment. In concrete terms, this specification gives us the ability to easily link in a loosely coupled and type-safe way the different layers (presentation, business and data access) of n-tier architectures. In order to do this, the CDI primarily relies on two services that are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Context</strong></span>: This is used for the <a id="id466" class="indexterm"/>management of the lifecycle of the objects (the time of creation and destruction) based on their scope.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dependency Injection</strong></span>: This includes <a id="id467" class="indexterm"/>a number of elements such as the injection of a component into another, the choice of implementation to be injected for a given interface and the type of object provided to access the injected dependence: a proxy or a reference that gives direct access to the instance.</li></ul></div><p>To get a better idea of the power of CDI, let us take some examples.</p><div class="section" title="Example 1 – instantiation of a POJO"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec46"/>Example 1 – instantiation of a POJO</h3></div></div></div><p>Suppose we have a JSF managed bean that <a id="id468" class="indexterm"/>wants to access an instance of a POJO that <a id="id469" class="indexterm"/>implements an interface. The basic approach is to create an instance of the POJO in the managed bean by using the <code class="literal">new</code> keyword as is the case in the following code:</p><div class="informalexample"><pre class="programlisting">@ManagedBean
public class MyManagedBean {
  
  IHelloWorld hw = new HelloWorld();
  
  public String getMyHelloWorld(){
    return hw.getHelloWorld();
  }
}
public class HelloWorld implements IHelloWorld{

  @Override
  public String getHelloWorld() {
    return "Hello World";
  }    
}</pre></div><p>The drawback with this approach is that the instance of the <code class="literal">HelloWorld</code> class is created in hard code, which causes a very strong coupling <a id="id470" class="indexterm"/>between the managed bean and implementation of <a id="id471" class="indexterm"/>
<code class="literal">IHeloWorld</code> interface. Therefore, to change <a id="id472" class="indexterm"/>
<code class="literal">IHelloWorld</code> implementation, you must have an access to the managed bean and modify it.</p><p>With the CDI, the managed bean will just declare a dependency on an <code class="literal">IHelloWorld</code> instance and inject it. This gives us the following code:</p><div class="informalexample"><pre class="programlisting">@ManagedBean
public class MyManagedBean {
    
    @Inject
    IHelloWorld hw;
    
    public String getMyHelloWorld(){
        return hw.getHelloWorld();
    }
}</pre></div><p>The CDI will look for the implementation of the <code class="literal">IHelloWorld</code> interface, instantiate and inject it. Better still, the CDI will take care of managing the lifecycle of the bean that will be injected. Thus, to change the implementation of <code class="literal">IHelloWorld</code> interface, we just have to change the class <code class="literal">HelloWorld</code>. We will <a id="id473" class="indexterm"/>complete our code by specifying the scope of the POJO with <code class="literal">@RequestScoped</code> annotation.</p><div class="informalexample"><pre class="programlisting">@RequestScoped
public class HelloWorld implements IHelloWorld{
    
  //...    
}</pre></div></div><div class="section" title="Example 2 – accessing an EJB from a JSF page"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec47"/>Example 2 – accessing an EJB from a JSF page</h3></div></div></div><p>Suppose we have a JSF page where we <a id="id474" class="indexterm"/>want to access a method of an EJB <a id="id475" class="indexterm"/>component. The typical scenario requires you to first access an instance of the EJB from the managed bean associated with the JSF page and then call the EJB method in a managed bean method that will be called in the JSF page. In terms of code that can be translated as shown in the following code.</p><p>The following code is an example of an EJB component:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class MyEJB implements IMyEJB{
  
  public String getHelloWorld(){
    return "Hello world By EJB";
  }
}</pre></div><p>The following code is an example of a JSF-managed bean:</p><div class="informalexample"><pre class="programlisting">@ManagedBean
public class MyManagedBean {
  
  @EJB
  IMyEJB ejb;

  public String getMyEjbHelloWorld(){
    return ejb.getHelloWorld();
  }
}</pre></div><p>From a JSF page, we can call the method <code class="literal">myEjbHelloWorld</code>.</p><div class="informalexample"><pre class="programlisting">Hello EJB
 &lt;br/&gt;
 The message : #{myManagedBean.myEjbHelloWorld}</pre></div><p>With CDI, we do not necessarily need to go through a managed bean to access the methods of an EJB. In fact, we only need to add the <code class="literal">@Named</code> annotation to our EJB component and it will be accessed from our JSF page like a simple JSF-managed bean. The difference between the two annotations (<code class="literal">@Named</code> and <code class="literal">@ManagedBean</code>) is visible in at least two points: the first point concerns the scope. Indeed, the <code class="literal">@ManagedBean</code> annotation is specific to the JSF Specification while the <code class="literal">@Named</code> annotation can create managed beans accessible to a greater number of specifications (including JSF) and provides more flexibility in the handling of JavaBean components. The second point relates to the features available to the component. The <code class="literal">@Named</code> annotation allows you to create CDI beans, which <a id="id476" class="indexterm"/>gives you the opportunity to use features that you will not have access to in a JSF bean, such as: interceptors, <code class="literal">Producer</code>, and <code class="literal">Disposer</code>. As a general rule, it is advisable to use CDI beans whenever possible.</p><p>The following code shows an <a id="id477" class="indexterm"/>EJB component <a id="id478" class="indexterm"/>annotated with CDI <a id="id479" class="indexterm"/>
<code class="literal">@Named</code> annotation:</p><div class="informalexample"><pre class="programlisting">@Named
@Stateless
public class MyEJB implements IMyEJB {
  //...
}</pre></div><p>The following code shows the access to an EJB from a JSF page:</p><div class="informalexample"><pre class="programlisting">CDI Hello EJB

&lt;br/&gt;
The message : #{myEJB.helloWorld}</pre></div></div><div class="section" title="Example 3 – setting a bean with a specific scope for simple operations"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec48"/>Example 3 – setting a bean with a specific scope for simple operations</h3></div></div></div><p>For one reason or another you may <a id="id480" class="indexterm"/>want to implement the singleton pattern. In <a id="id481" class="indexterm"/>the traditional approach, you will implement a singleton EJB type even if you do not necessarily need all of the services that such a component offers (scalability, roles-based security, concurrency management, transaction management, and others).</p><p>With CDI, you can create your bean with the desired scope without the obligation of implementing heavy components for marginal processing. In fact, CDI offers several types of scope that can be defined using annotations (<code class="literal">@ApplicationScoped</code>, <code class="literal">@RequestScoped</code>, and <code class="literal">@SessionScoped</code>). Thus, to implement the singleton pattern without cluttering the services offered by the <a id="id482" class="indexterm"/>EJB components, we can simply use the application scope annotation of the CDI as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@ApplicationScoped
public class MySingletonBean {
    //...
}</pre></div></div><div class="section" title="Example 4 – use of objects usually created by a factory"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec49"/>Example 4 – use of objects usually created by a factory</h3></div></div></div><p>You want to send an asynchronous <a id="id483" class="indexterm"/>message via JMS from EJB. The classical <a id="id484" class="indexterm"/>approach will require you to instantiate many objects as is the case in the following code:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class SendMessageBean {

  @Resource(name = " java:global/jms/javaee7ConnectionFactory")
  private ConnectionFactory connectionFactory;
  @Resource(name = " java:global/jms/javaee7Queue")
  private Queue queue;

  public void sendMessage(String message) {
    try {
      Connection connection =connectionFactory.createConnection();
      Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
      MessageProducer messageProducer =session.createProducer(queue);
      TextMessage textMessage =session.createTextMessage(message);
      messageProducer.send(textMessage);
      connection.close();
    } catch (JMSException ex) {
      // handle exception (details omitted)
    }
  }
}</pre></div><p>With CDI, all this mass of code is <a id="id485" class="indexterm"/>reduced to a line, as shown in the following <a id="id486" class="indexterm"/>code:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class SendMessageBean2 {

  @Inject
  JMSContext context;
  @Resource(lookup = "java:global/jms/javaee7Queue")
  Queue queue;

  public void sendMessage(String message) {
    context.createProducer().send(queue, message);
  }
}</pre></div></div></div><div class="section" title="Latest improvements in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec53"/>Latest improvements in action</h2></div></div></div><p>Having been introduced to the <a id="id487" class="indexterm"/>platform from Java EE 6, CDI has become an important solution for component oriented programming in the Java EE platform. Now it only has to spread its tentacles into almost all specifications of the platform so that it can link seamlessly more components and integrate more APIs. In the long list of improvements that have been made, we will present a few including: the possibility of avoiding a bean being processed by the CDI, access to the current CDI container, access to the non contexual instances of a bean, and finally the ability to explicitly destroy bean instances. The <a id="id488" class="indexterm"/>improvement of CDI relating to interceptors and decorators will be presented in the next chapter when we will discuss the relevant specification.</p><div class="section" title="Avoiding CDI processing on a bean"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec50"/>Avoiding CDI processing on a bean</h3></div></div></div><p>Version 1.1 of the CDI <a id="id489" class="indexterm"/>Specification came with the annotation <code class="literal">@vetoed</code> that prevents an object being considered as a CDI bean. However, a bean decorated with this <a id="id490" class="indexterm"/>annotation cannot have a lifecycle similar to the contextual instance. So, it cannot be injected.</p><p>By looking at this annotation, some might wonder about its usefulness. To preserve the integrity of some data, it may happen that you need to control the use of some components. But, by using CDI, your components can be manipulated from any other component. Hence the role of the <a id="id491" class="indexterm"/>
<code class="literal">@vetoed</code> annotation. The following code shows us the use of the <code class="literal">@vetoed</code> annotation on the <code class="literal">Student</code> entity in order to avoid unknown manipulations that can lead to inconsistencies:</p><div class="informalexample"><pre class="programlisting">@Entity
@Vetoed
public class Student implements Serializable {
  @Id
  private String id;
  private String firstname;

  //...
}</pre></div></div><div class="section" title="Accessing the non contexual instance of a bean"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec51"/>Accessing the non contexual instance of a bean</h3></div></div></div><p>This version also added the <a id="id492" class="indexterm"/>ability to inject and execute lifecycle <a id="id493" class="indexterm"/>callbacks of unmanaged instances of beans. The following code demonstrates how to inject and execute lifecycle callbacks of non contexual instances of the bean <code class="literal">Student</code>:</p><div class="informalexample"><pre class="programlisting">Unmanaged&lt;Student&gt; unmanagedBean = newUnmanaged&lt;Student&gt;(Student.class);
UnmanagedInstance&lt;Student&gt; beanInstance =unmanagedBean.newInstance();
Student foo =beanInstance.produce().inject().postConstruct().get();
// Usage of the injected bean
beanInstance.preDestroy().dispose();</pre></div></div><div class="section" title="Accessing the current CDI container"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec52"/>Accessing the current CDI container</h3></div></div></div><p>The CDI Specification 1.1 has added the <a id="id494" class="indexterm"/>ability to access the current CDI container <a id="id495" class="indexterm"/>programmatically and perform some operations. The following code demonstrates how to access a CDI container to explicitly destroy a context object:</p><div class="informalexample"><pre class="programlisting">CDI container = CDI.current();
container.destroy(destroableManagedInstance);</pre></div></div><div class="section" title="Destroying CDI bean instances explicitly"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec53"/>Destroying CDI bean instances explicitly</h3></div></div></div><p>To allow explicit <a id="id496" class="indexterm"/>destruction of bean instances in applications, CDI 1.1 has <a id="id497" class="indexterm"/>introduced the <code class="literal">AlterableContext</code> interface, which contains the <code class="literal">void destroy</code>(<code class="literal">Contextual&lt;?&gt; contextual</code>) method. Extensions should implement this interface instead of the <code class="literal">Context</code> interface.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec34"/>Summary</h1></div></div></div><p>After several chapters focused on the realization of a complete system using the Java EE 7 platform, this chapter has allowed us to take a break and try to review some key concepts that we were using. Thus, we learned to make our own annotations and link layers of n-tier applications. In the next chapter, we will continue with the implementation of our application by integrating, this time, the validation of data exchanged between the different layers.</p></div></body></html>