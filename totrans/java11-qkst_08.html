<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Enhanced Enums in Project Amber</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In Java 5, enums introduced a powerful way to define finite and predefined set of constants, with type safety. Enums enabled you to define a new type (like classes or interfaces) with state and behavior. <strong class="calibre20">Project Amber</strong> is enhancing enums, taking it to the next level; by adding type variables (generics) and allowing sharper type checking for enums. These two features will enable an enum to have constant specific type information and constant specific state and behavior. These enhancements will reduce the need of refactoring enums to classes, to use generics.</p>
<p class="calibre6">In this chapter, we'll cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">What is the reason for enhancing enums?</li>
<li class="calibre11">Adding state and behavior to enum constants</li>
<li class="calibre11">How to create generic enums?</li>
<li class="calibre11">Accessing constant specific state and behavior</li>
<li class="calibre11">Perform sharper type checking for enum constants</li>
<li class="calibre11">Challenges</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction to enums in Java 5</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6"><strong class="calibre20">Enums</strong> introduced type safety to the use of constants, which were earlier defined using static final variables of type, say, <kbd class="calibre9">int</kbd>, or others. Imagine limiting the sizes of a shirt to some predefined sizes, say, <kbd class="calibre9">Small</kbd>, <kbd class="calibre9">Medium</kbd>, or <kbd class="calibre9">Large</kbd>. Here's how you can do that with an enum, say, <kbd class="calibre9">Size</kbd>:</p>
<pre class="calibre14">enum Size {SMALL, MEDIUM, LARGE} </pre>
<div class="packt_infobox">Java's coding conventions recommend use of uppercase to define enum constants (like <kbd class="calibre13">SMALL</kbd>).  Multiple words in a constant can be separated using an underscore.</div>
<p class="calibre6">Here's how you can use enum <kbd class="calibre9">Size</kbd> in a class, say, <kbd class="calibre9">Shirt</kbd>, to restrict its sizes to constants defined in enum <kbd class="calibre9">Size</kbd>:</p>
<pre class="calibre14">class Shirt { 
    Size size;              // instance variable of type Size 
    Color color; 
 
    Shirt(Size size, Color color) {      // Size object with Shirt instantiation 
        this.size = size; 
        this.color = color; 
    } 
} </pre>
<p class="calibre6">The instance variable of type <kbd class="calibre9">Size</kbd> in <kbd class="calibre9">Shirt</kbd> <span class="calibre8">class </span>limits the values that are assigned to it to <kbd class="calibre9">Size.SMALL</kbd>, <kbd class="calibre9">Size.MEDIUM</kbd> and <kbd class="calibre9">Size.LARGE</kbd>. Here's an example of how another class, say, <kbd class="calibre9">GarmentFactory</kbd> class uses enum constants to create instances of class <kbd class="calibre9">Shirt</kbd>:</p>
<pre class="calibre14">class GarmentFactory { 
    void createShirts() { 
        Shirt redShirtS = new Shirt(Size.SMALL, Color.red); 
        Shirt greenShirtM = new Shirt(Size.MEDIUM, Color.green); 
        Shirt redShirtL = new Shirt(Size.LARGE, Color.red); 
    } 
} </pre>
<div class="packt_infobox">Enums define a new type with a predefined set of constant values. Enums add type safety to the constant values.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Decompiled enum – behind the scenes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Every user defined <kbd class="calibre9">enum</kbd> implicitly extends <kbd class="calibre9">java.lang.Enum</kbd> class. Behind the scenes, the one liner enum <kbd class="calibre9">Size</kbd> (defined in the preceding section) is compiled into something similar like the following:</p>
<pre class="calibre14">final class Size extends Enum                 // 'enum' converted to final class  
{ 
    public static final Size SMALL;           // variables to store  
    public static final Size MEDIUM;          // enum constants 
    public static final Size LARGE;           //  
 
    private static final Size $VALUES[];      // array of all enum constants 
 
    static 
    {                                // static initializer 
        SMALL = new Size("SMALL", 0);         // to initialize enum constants 
        MEDIUM = new Size("MEDIUM", 1);       // 
        LARGE = new Size("LARGE", 2);         // 
        $VALUES = (new Size[] {               // 
            SMALL, MEDIUM, LARGE              // &amp; populate array of enum constants 
        }); 
    } 
    public static Size[] values() 
    { 
        return (Size[])$VALUES.clone();       // Avoiding any modification to  
    }                                // $VALUES by calling methods 
    public static Size valueOf(String s) 
    { 
        return (Size)Enum.valueOf(Size, s); 
    } 
    private Size(String s, int i) 
    { 
        super(s, i); 
    } 
} </pre>
<div class="packt_infobox">Enums are syntactic sugar. The compiler takes your enum construct and extends <kbd class="calibre13">java.lang.Enum</kbd> to create a class. It adds the variables, initializers and methods to get the required behavior.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding state and behavior to enum constants</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The enum constants can have their own state and behavior. One of the ways to do so is to define instance variables and methods in an enum. All of these are accessible to the enum constants. Let's modify the enum <kbd class="calibre9">Size</kbd> defined in the previous section, adding state and behavior to it.</p>
<p class="calibre6">Each enum constant can define a constant specific class body - defining new state and behaviour or override the default behaviour of enum methods in which it is defined. Here's an example:</p>
<pre class="calibre14">enum Size { 
    SMALL(36, 19), 
    MEDIUM(32, 20) {               // Constant specific class body  
        int number = 10;                    // variable specific to MEDIUM 
        int getSize() {                     // method specific to MEDIUM 
            return length + width; 
        } 
    }, 
    LARGE(34, 22) { 
        @Override  
        public String toText() {            // overriding method toText for  
            return "LARGE";                 // constant LARGE 
        } 
    }; 
 
    int length;                             // instance variable accessible 
    int width;                              // to all enum constants 
 
    Size(int length, int width) {           // enum constructor; accepts length 
        this.length = length;               // and width 
        this.width = width; 
    } 
 
    int getLength() {                       // method accessible to all enum 
        return length;                      // constants 
    } 
 
    int getWidth() {                        // method accessible to all enum 
        return width;                       // constants 
    }  
 
    public String toText() {              // method accessible to all enum 
        return length + " X " + width;      // constants 
    } 
} </pre>
<p class="calibre6">In the preceding example, enum Size defines three enum constants - <kbd class="calibre9">SMALL</kbd>, <kbd class="calibre9">MEDIUM</kbd> and <kbd class="calibre9">LARGE</kbd>. It also defines instance variables (<kbd class="calibre9">length</kbd> and <kbd class="calibre9">breadth</kbd>), a constructor and methods <kbd class="calibre9">getLength()</kbd>, <kbd class="calibre9">getWidth</kbd> and <kbd class="calibre9">toText()</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Accessing state and behaviour of enum constants</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">At present, an enum constant can access:</p>
<ul class="calibre10">
<li class="calibre11">State and behavior common to all enum constants</li>
<li class="calibre11">Methods overridden by an enum constant</li>
</ul>
<p class="calibre6">For the <kbd class="calibre9">Size</kbd> <span class="calibre8">enum </span>(defined in the preceding section), you can access the state and behavior common to all enum constants, as follows:</p>
<pre class="calibre14">System.out.println(Size.SMALL.toText());  // toString is defined for all constants </pre>
<p class="calibre6">The preceding code outputs:</p>
<pre class="calibre14"><strong class="calibre22">36 X 19</strong> </pre>
<p class="calibre6">You can also access the behavior, which a specific enum constant overrides:</p>
<pre class="calibre14">System.out.println(Size.LARGE.toText()); </pre>
<p class="calibre6">The preceding code outputs:</p>
<pre class="calibre14"><strong class="calibre22">LARGE</strong> </pre>
<p class="calibre6">But, you can't access the state or behavior that is specific to an enum constant:</p>
<pre class="calibre14">System.out.println(Size.MEDIUM.number);          // Doesn't compile 
System.out.println(Size.MEDIUM.getSize());       // Doesn't compile </pre>
<p class="calibre6">The <kbd class="calibre9">getSize()</kbd> <span class="calibre8">method </span>or the <kbd class="calibre9">number</kbd> <span class="calibre8">variable </span>can't be accessed using the <kbd class="calibre9">MEDIUM</kbd> <span class="calibre8">constant.</span> This is because, <kbd class="calibre9">MEDIUM</kbd> creates an anonymous class and overrides the methods of the <kbd class="calibre9">Size</kbd> <span class="calibre8">enum.</span> It can't access constant specific state or behavior because it's still referenced by a variable of the <kbd class="calibre9">Size</kbd> <span class="calibre8">type;</span> which doesn't define them. Here's an image to help you remember this:</p>
<div class="cdpaligncenter"><img src="Images/76889c86-0dcf-4762-a00e-53e8d8025604.png" width="1381" height="868" class="calibre23"/></div>
<div class="packt_infobox">Existing enums don't allow access to state or behavior that is specific to an enum constant because it create an anonymous class to do so.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Workaround to access state and behaviour of enum specific constants</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">One the ways to get around it and access enum constant specific members is to define them for all members, but allow the usage only for specific members (I know, this is a dumb way). I've removed code not relevant to show how this works, on purpose:</p>
<pre class="calibre14">enum Size {<br class="calibre2"/>    SMALL(36, 19),<br class="calibre2"/>    MEDIUM(32, 20),<br class="calibre2"/>    LARGE(34, 22);<br class="calibre2"/>    int length; // instance variable accessible<br class="calibre2"/>    int width; // to all enum constants<br class="calibre2"/>    Size(int length, int width) { // enum constructor; accepts length<br class="calibre2"/>         this.length = length; // and width<br class="calibre2"/>         this.width = width;<br class="calibre2"/>    }<br class="calibre2"/>    int getSize() {<br class="calibre2"/>       if (this == MEDIUM)<br class="calibre2"/>         return length + width;<br class="calibre2"/>       else // throws runtime exception<br class="calibre2"/>         throw new UnsupportedOperationException(); // if used with constans<br class="calibre2"/>    } // other than MEDIUM<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/></pre>
<p class="calibre6">Let's try to access method <kbd class="calibre9">getSize()</kbd> using enum constants:</p>
<pre class="calibre14">System.out.println(MEDIUM.getSize());<br class="calibre2"/>System.out.println(LARGE.getSize());</pre>
<p class="calibre6">The output of the preceding code is as follows:</p>
<pre class="calibre14"><strong class="calibre22">52</strong></pre>
<p class="calibre6">Exception in thread—<kbd class="calibre9">java.lang.UnsupportedOperationException</kbd>.</p>
<p class="calibre6">First and foremost, adding code (method <kbd class="calibre9">getSize()</kbd>) which is not applicable to all enum constants breaks encapsulation. In the preceding example, I defined <kbd class="calibre9">getSize()</kbd> in the main body, whereas only enum constant <kbd class="calibre9">MEDIUM</kbd> required the method <kbd class="calibre9">getSize()</kbd>. This is neither desirable, nor recommended.</p>
<p class="calibre6">Compare it with an arrangement of a base class and its derived classes, and adding all behavior, specific to different derived classes in your base class. This sure sounds insane to me. Please don't try it at your work.</p>
<div class="packt_infobox">Don't attempt this workaround at work; it doesn't define encapsulated code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Another example – using inheritance with enum constants</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Here's another example of an enum, which works with a set of subclasses by passing instances of subclasses to enum constructor. To get the point across, I've modified the <kbd class="calibre9">Size</kbd> <span class="calibre8">enum, </span>with which we have been working since the beginning of this chapter. Here's the modified code:</p>
<pre class="calibre14">class Measurement {}                      // base class 
class Small extends Measurement {         // derived class 
    String text = "Small";                // state specific to class Small 
} 
class Medium extends Measurement {        // derived class 
    public int getLength() {              // behavior specific to class Medium 
        return 9999; 
    } 
} 
class Large extends Measurement {}        // derived class 
 
enum Size {                                
    SMALL(new Small()),                   // constant created using Small instance 
    MEDIUM(new Medium()),                 // constant created using Medium instance 
    LARGE(new Large());                   // constant created using Large instance 
 
    private Measurement mObj;     // Measurement is base class of  
                                  // classes Small, Medium &amp; Large 
 
    Size(Measurement obj) {       // wraps Measurement instance as an Enum instance 
        mObj = obj; 
    } 
    Measurement getMeasurement() { // get the wrapped instance 
        return mObj; 
    } 
} </pre>
<p class="calibre6">Again, you can't access the state and behavior of enum constant specific code. Here's an example:</p>
<pre class="calibre14">class Test1 { 
    public static void main(String args[]) { 
        var large = Size.LARGE; 
        System.out.println(large.getMeasurement().getLength()); // doesn't compile 
                                                  // the type of the variable used 
// to wrap the value of enum  
// constant is Measurement  
    } 
} </pre>
<p class="calibre6">Here comes enhanced enums to the rescue. JEP 301 introduces enhanced enums by adding type variables or generic to it. Let's see how it works in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding generics to Enums</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Let's rewrite the enum code in the preceding example (listing 8.x), adding type variables to the enum <kbd class="calibre9">Size.</kbd> Here's the modified code:</p>
<pre class="calibre14">enum Size &lt;T extends Measurement&gt; {      // enum with type parameter 
    SMALL(new Small()), 
    MEDIUM(new Medium()), 
    LARGE(new Large()); 
 
    private T mObj; 
 
    Size(T obj) { 
        mObj = obj; 
    } 
    T getMeasurement() { 
        return mObj; 
    } 
} </pre>
<pre class="calibre14">class Measurement {} 
class Small extends Measurement { 
    String text = "Small"; 
} 
class Medium extends Measurement {} 
class Large extends Measurement { 
    public int getLength() { 
        return 40; 
    } 
}</pre>
<pre class="calibre14">class Measurement {} 
class Small extends Measurement { 
    String text = "Small"; 
} 
class Medium extends Measurement {} 
class Large extends Measurement { 
    public int getLength() { 
        return 40; 
    } 
} <br class="calibre2"/><br class="calibre2"/>class Measurement {} 
class Small extends Measurement { 
    String text = "Small"; 
} 
class Medium extends Measurement {} 
class Large extends Measurement { 
    public int getLength() { 
        return 40; 
    } 
} </pre>
<p class="calibre6">The following code can be used to access constant specific behavior, as follows:</p>
<pre class="calibre14">var large = Size.LARGE; 
System.out.println(large.getMeasurement().getLength());  </pre>
<div class="packt_infobox">With the enhanced enums (generics added), you will be able to access an enum constant specific state or behavior.</div>
<p class="calibre6">Let's work with another example of a generic enum, which can be used to restrict the user data to certain types.</p>
<p class="calibre6">The following example creates a generic enum Data, which can be passed a type parameter, <kbd class="calibre9">T</kbd>:</p>
<pre class="calibre14">public enum Data&lt;T&gt; { 
    NAME&lt;String&gt;,                // constants of generic  
    AGE&lt;Integer&gt;,                // enum Data 
    ADDRESS&lt;Address&gt;; 
} </pre>
<p class="calibre6">The class <kbd class="calibre9">FormData</kbd> defines a generic method, which can accept constant of enum <kbd class="calibre9">Data</kbd> and a value of the same type that is used for the enum constant:</p>
<pre class="calibre14">public class FormData { 
    public &lt;T&gt; void add(Data&lt;T&gt; type, T value) { 
        //..code 
    } 
} </pre>
<p class="calibre6">Here's how you can use the constants of enum <kbd class="calibre9">Data</kbd> to restrict the combination of type of values you pass to method <kbd class="calibre9">add</kbd>:</p>
<pre class="calibre14">FormData data = new FormData(); 
data.add(Data.NAME, "Pavni");            // okay; type of NAME and Pavni is String 
data.add(Data.AGE, 22);                  // okay; type of AGE and 22 is Integer 
data.add(Data.ADDRESS, "California");    // Won't compile. "California"  
                                         // is String, not Address instance </pre>
<p class="calibre6">With the mismatched data, the code fails at compilation, making it easier for the developer to correct her assumptions or program flow.</p>
<div class="packt_infobox">Compilation failures are always better than runtime exceptions. Usage of generic enum <kbd class="calibre13">Data</kbd> will make the code fail at compile time, for mismatched combination of values passed to <kbd class="calibre13">add()</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Sharper typing of enum constants</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">One of the two major goals of enhanced enums is to perform sharper type checking for enums. At present, the type of all enum constants is the enum in which they are defined. Referring to our example on enum, <kbd class="calibre9">Size</kbd>, this essentially means that the type of all the enum constants, that is, <kbd class="calibre9">SMALL</kbd>, <kbd class="calibre9">MEDIUM</kbd> and <kbd class="calibre9">LARGE</kbd>, is <kbd class="calibre9">Size</kbd>, which is incorrect (as depicted in the following image):</p>
<div class="cdpaligncenter"><img src="Images/6dda7fab-7afa-47d5-b909-8299e36dfb9b.png" width="1244" height="740" class="calibre24"/></div>
<p class="calibre6">Though enum constants are allowed to define constant specific class body, which includes variables and methods, the constant type is not sharp enough to allow access to enum constant-specific values. Even in the case of generic enums, the static type of an enum constant is not sharp enough to capture the full type information of individual constants.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this chapter, you started with how the enums in Java 5 introduced type safety to constants. You covered how enums can have state and behavior, not just the one that applies to all constants in an enum; but also specific to the constants. However, its not feasible to access the state and behavior that is specific to an enum constant, with the existing enums.</p>
<p class="calibre6">You covered how the enhanced enums can use generics and enable access to constant specific state and behaviour. With examples, you also covered how type parameters when added to enums facilitate sharper typing of enum constants.</p>


            </article>

            
        </section>
    </div>



  </body></html>