["```java\ngraph graphname {\n   a -- b -- c;\n   b -- d;\n}\n```", "```java\nname := \"Lession2-ScalaTest\"\nscalaVersion := \"2.12.4\"\nlibraryDependencies += \"org.scalatest\" %% \"scalatest\" % \"3.0.4\" % \"test\"\n```", "```java\npackage com.example\n\nimport collection.mutable.Stack\nimport org.scalatest._\n\nclass ExampleSpec extends FlatSpec with Matchers {\n  \"A Stack\" should \"pop values in last-in-first-out order\" in {\n    val stack = new Stack[Int]\n    stack.push(1)\n    stack.push(2)\n    stack.pop() should be (2)\n    stack.pop() should be (1)\n  }\n}\n```", "```java\ntest:compile                     # to compile your tests\ntest                             # to run your test-suite\ntestOnly com.example.ExampleSpec # To run just that test\n```", "```java\ntestOnly com.example.ExampleSpec\n[info] ExampleSpec:\n[info] A Stack\n[info] - should pop values in last-in-first-out order\n[info] Run completed in 282 milliseconds.\n[info] Total number of tests run: 1\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0\n[info] All tests passed.\n[success] Total time: 6 s, completed Dec 4, 2017 9:50:04 PM\n```", "```java\n    describe(\"A Set\") {\n\n      describe(\"(when empty)\") {\n        it(\"should have size 0\") {\n\n          assert(Set.empty.size == 0)\n\n        }\n\n      }\n\n    }\n    ```", "```java\n    \"An empty Set\" should \"have size 0\" in {\n\n        assert(Set.empty.size == 0)\n\n    }\n    ```", "```java\n    describe(\"A Set\") {\n\n      describe(\"(when empty)\") {\n\n        it(\"should have size 0\") {\n\n          assert(Set.empty.size == 0)\n\n        }\n\n      }\n\n    }\n    ```", "```java\n    \"A Set\" - {\n\n      \"(when empty)\" - {\n\n        \"should have size 0\" in {\n\n          assert(Set.empty.size == 0)\n\n        }\n\n      }\n\n    }\n    ```", "```java\n    property(\"An empty Set should have size 0\") {\n\n        assert(Set.empty.size == 0)\n\n    }\n    ```", "```java\n    class TVSetSpec extends FeatureSpec with GivenWhenThen {\n\n      info(\"As a TV set owner\")\n\n      info(\"I want to be able to turn the TV on and off\")\n\n      feature(\"TV power button\") {\n        scenario(\"User presses power button when TV is off\") {\n\n          Given(\"a TV set that is switched off\")\n\n          val tv = new TVSet\n          assert(!tv.isOn)\n\n          When(\"the power button is pressed\")\n\n          tv.pressPowerButton()\n\n          Then(\"the TV should switch on\")\n\n          assert(tv.isOn)\n\n        }\n\n      }\n\n    }\n    ```", "```java\npackage com.example\n\nimport collection.mutable.Stack\nimport org.scalatest._\n\nclass ExampleSpec extends FlatSpec with Matchers {\n \"A Stack\" should \"pop values in last-in-first-out order\" in {\n   val stack = new Stack[Int]\n   stack.push(1)\n   stack.push(2)\n   stack.pop() should be (2)\n   stack.pop() should be (1)\n}\n}\n```", "```java\n    import collection.mutable.Stack\n    import org.scalatest._\n\n    class ExampleSpec extends FlatSpec with Matchers {\n     \"A Stack\" should \"pop values in last-in-first-out order\" in {\n       val stack = new Stack[Int]\n       stack.push(1)\n       stack.push(2)\n       stack.pop() should be (2)\n       stack.pop() should be (1)\n     }\n    }\n    ```", "```java\nList.range(0, 10).filter(_ > 5)\nList.range(0, 10) filter (_ > 5)\n```", "```java\n\"Professional Scala\".toUpperCase()\n\"Professional Scala\".toUpperCase\n```", "```java\ndef whileLoop(condition: => Boolean)(body: => Unit): Unit =\n if (condition) {\n   body\n   whileLoop(condition)(body)\n }\n\nvar i = 2\n\nwhileLoop (i > 0) {\n println(i)\n i -= 1\n}  // prints 2 1\n```", "```java\nimplicit class StringExtensions(val self: String) extends AnyVal {\n def repeat(count: Int): String =\n  List.range(0, count).map(_ => self).fold(\"\")(_ + _)\n}\n```", "```java\n\"Professional Scala\" repeat 5\n```", "```java\nsealed trait TestResult\ncase class TestFailure(message: String) extends TestResult\ncase object TestSuccess extends TestResult\n```", "```java\ncase class TestCase(description: TestDescription, run: () => TestResult)\ncase class TestDescription(name: String, specification: String)\n```", "```java\nTestCase(\n    TestDescription(\"A stack\", \"pop values in last-in-first-out order\"),\n   TestResult.wrap({\n        val stack = new Stack[Int]\n        stack.push(1)\n        stack.push(2)\n        assert(stack.pop() == 2, \"should be (2)\")\n        assert(stack.pop() == 1, \"should be (1)\")\n    })\n)\n```", "```java\n\"A Stack (with one item)\" should \"be non-empty\" in { … code … }\n```", "```java\nimplicit class StringExtension(val name: String) extends AnyVal {\n def should(specification: String): TestDescription =\n   TestDescription(name, specification)\n}\n```", "```java\n\"A Stack (with one item)\" should \"be non-empty\"\n// Returns TestDescription(\"A Stack (with one item)\",\"be non-empty\")\n```", "```java\nTestCase(\n    \"A Stack (with one item)\" should \"be non-empty\"\n    TestResult.wrap({\n        val stack = new Stack[Int]\n        stack.push(1)\n        stack.push(2)\n        assert(stack.pop() == 2, \"should be (2)\")\n        assert(stack.pop() == 1, \"should be (1)\")\n    })\n)\n```", "```java\n\"A Stack (with one item)\" should \"be non-empty\" in { … code … }\n```", "```java\ndef in(body: => Unit): TestCase = TestCase(this, TestResult.wrap(body))\n```", "```java\n\"A Stack (with one item)\" should \"be non-empty\" in {\n    val stack = new Stack[Int]\n    stack.push(1)\n    stack.push(2)\n    assert(stack.pop() == 2, \"should be (2)\")\n    assert(stack.pop() == 1, \"should be (1)\")\n}\n```", "```java\nTestCase(\n    TestDescription(\"A stack\", \"pop values in last-in-first-out order\"),\n    TestResult.wrap({\n        val stack = new Stack[Int]\n        stack.push(1)\n        stack.push(2)\n        assert(stack.pop() == 2, \"should be (2)\")\n        assert(stack.pop() == 1, \"should be (1)\")\n    })\n)\n```", "```java\n\"A Stack\" should \"pop values in last-in-first-out order\" in {\n    val stack = new Stack[Int]\n   stack.push(1)\n    stack.push(2)\n    assert(stack.pop() == 2, \"should be (2)\")\n    assert(stack.pop() == 1, \"should be (1)\")\n}\n```", "```java\nexpected(2) from stack.pop()\n```", "```java\ncase class Assertion[A](expected: Expected[A], value: () => A)\ncase class Expected[A](expected: A)\n```", "```java\npackage com.example\ncase class Assertion[A](expected: Expected[A], value: () => A) {\n def run(): Unit = {\n val result = value()\n assert(expected.expected == result, s\"Failed asserting that ${expected.expected} == $result\")\n }\n}\ncase class Expected[A](expected: A) {\n def from(expression: => A): Assertion[A] = Assertion(\n this,\n () => expression\n )\n}\nobject Assertion {\n def expected[A](x: A): Expected[A] = Expected(x)\n}\n\n```", "```java\nobject Macros {\n\n def uppercaseImpl(c: Context)(strExpr: c.Expr[String]): c.Expr[String] = {\n   import c.universe._\n   val Literal(Constant(str: String)) = strExpr.tree\n   c.Expr[String](q\"${str.toUpperCase}\")\n }\n\n def uppercase(strExpr: String): String = macro uppercaseImpl\n}\n```", "```java\nval x = Macros.uppercase(\"testing\")\nprintln(x)\n```", "```java\ntrait Showable[T] { def show(x: T): String }\n```", "```java\nfinal case class Person(name: String)\n\nobject Person {\n implicit val showable: Showable[Person] = new Showable[Person]{\n   def show(x: Person) = s\"Person(name=${x.name})\"\n }\n}\n```", "```java\nobject Showable {\n implicit def materializeShowable[T]: Showable[T] = macro ...\n}\n```", "```java\nq\"List(10)\"\n```", "```java\nList(Literal(Constant(10)))))\n```", "```java\nimport scala.reflect.runtime.{universe => ru}\n\ndef getTypeTag[T: ru.TypeTag](obj: T) = ru.typeTag[T]\n\ngetTypeTag(List(1,2,3)).tpe.decls\n .filter(_.name.toString.length < 5)\n .foreach(d => println(s\"${d.name} : ${d.typeSignature}\"))\n```"]