- en: REST API Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API安全
- en: Spring Security can be used to secure REST APIs. This chapter begins with the
    introduction of some of the important concepts in regard to REST and the JWT.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security可以用来保护REST API。本章从介绍与REST和JWT相关的一些重要概念开始。
- en: The chapter then introduces OAuth concepts and by using hands-on coding examples,
    explains simple and advanced REST API security utilizing the Spring Security and
    Spring Boot modules in the Spring Framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接着介绍OAuth概念，并通过实际编码示例，解释如何使用Spring框架中的Spring Security和Spring Boot模块实现简单和高级REST
    API安全。
- en: We will be using the OAuth protocol in our examples to secure exposed REST API's
    utilizing Spring Security features to the fullest. We will be using the JWT to
    exchange claims between the server and client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用OAuth协议来保护暴露的REST API，并充分利用Spring Security功能。我们将使用JWT在服务器和客户端之间交换声明。
- en: 'In this chapter, we will cover the following concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下概念：
- en: Modern application architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代应用架构
- en: Reactive REST API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式REST API
- en: Simple REST API security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单REST API安全
- en: Advanced REST API security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级REST API安全
- en: Spring Security OAuth project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security OAuth项目
- en: OAuth2 and Spring WebFlux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth2和Spring WebFlux
- en: Spring Boot and OAuth2
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot和OAuth2
- en: Important concepts
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要概念
- en: Before getting into coding, we need to be conversant with some important concepts.
    This section is aimed at introducing you to some of these concepts in detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，我们需要熟悉一些重要概念。本节旨在详细介绍这些概念。
- en: REST
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: '**Representational State Transfer** (**REST**) is an architectural style presented
    by Roy Fielding in the year 2000 for developing web services. It is built on top
    of the well-known **Hypertext Transfer Protocol** (**HTTP**) and can transfer
    data in multiple formats, the most common being **JavaScript Object Notation**
    (**JSON**) and **eXtensible Markup Language** (**XML**). The status of a request
    in REST is indicated using standard HTTP status code (200: OK, 404: Page not found!,
    and so on). Being based on HTTP, security is taken care of using the already familiar
    **Secure Sockets Layer** (**SSL**) and **Transport Layer Security** (**TLS**).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）是由Roy Fielding在2000年提出的一种用于开发Web服务的架构风格。它建立在著名的**超文本传输协议**（**HTTP**）之上，并且可以以多种格式传输数据，最常见的是**JavaScript对象表示法**（**JSON**）和**可扩展标记语言**（**XML**）。REST中请求的状态使用标准的HTTP状态码表示（200：OK，404：页面未找到！等）。由于基于HTTP，因此使用已熟悉的**安全套接字层**（**SSL**）和**传输层安全**（**TLS**）来处理安全问题。'
- en: While writing such web services, you are free to use any programming language
    (Java, .NET, and so on) that is capable of making web requests based on HTTP (which
    is a de facto standard that every language supports). You have a number of well-known
    frameworks, using which developing RESTful APIs on the server side is quite easy
    and simple. Also, on the client side, there are a number of frameworks that make
    invoking RESTful APIs and handling responses straightforward and easy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写此类Web服务时，您可以使用任何能够基于HTTP（这是一个事实上的标准，每种语言都支持）发起Web请求的编程语言（Java、.NET等）。您有许多知名的框架，使用这些框架在服务器端开发RESTful
    API既简单又容易。同样，在客户端，也有许多框架使调用RESTful API和处理响应变得直接且简单。
- en: 'Since REST works on internet protocol, the caching of a web service response
    can be achieved quite easily by supplying appropriate HTTP headers (Cache-Control,
    Expires, and so on). The HTTP methods `PUT` and `DELETE` are not cacheable in
    any scenario. The following table summarizes the use of HTTP methods:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST基于互联网协议，通过提供适当的HTTP头（Cache-Control、Expires等），可以很容易地缓存Web服务响应。在任何情况下，HTTP方法`PUT`和`DELETE`都是不可缓存的。以下表格总结了HTTP方法的使用：
- en: '| **HTTP method** | **Description** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP方法** | **描述** |'
- en: '| `GET` | Retrieves a resource |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 获取资源 |'
- en: '| `POST` | Creates a new resource |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 创建新资源 |'
- en: '| `PUT` | Updates an existing resource |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 更新现有资源 |'
- en: '| `DELETE` | Deletes an existing resource |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除现有资源 |'
- en: '| `PATCH` | Makes a partial update to a resource |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 对资源进行部分更新 |'
- en: 'Table 1: HTTP method usage'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表1：HTTP方法使用
- en: A REST API request/response (data sent over the wire) can be compressed by specifying
    appropriate HTTP headers, similar to caching. The HTTP header, Accept-Encoding,
    is sent by the client to the server, to let the server know the compression algorithms
    it can understand. The server successfully compresses a response and puts out
    another HTTP header, Content-Encoding, letting the client know which algorithm
    has to be used to decompress.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: REST API请求/响应（通过网络发送的数据）可以通过指定适当的HTTP头进行压缩，类似于缓存。客户端通过发送Accept-Encoding HTTP头到服务器，让服务器知道它能够理解的压缩算法。服务器成功压缩响应，并输出另一个HTTP头Content-Encoding，告知客户端需要使用哪种算法进行解压缩。
- en: JSON Web Token (JWT)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Token (JWT)
- en: <q>"JSON Web Tokens are an open, industry standard RFC 7519 method for representing
    claims securely between two parties."</q>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <q>"JSON Web Tokens是一种开放、行业标准的RFC 7519方法，用于在双方之间安全地表示声明。"</q>
- en: '*- [https://jwt.io/](https://jwt.io/)*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*- [https://jwt.io/](https://jwt.io/)*'
- en: 'In the past, the stateless nature of HTTP was circumvented in a web application
    (most of them are stateful in nature) by associating each request with a session
    ID created on the server and then stored by the client using cookies. Each request
    sends the cookie (session ID) in the form of an HTTP header, which gets validated
    by the server, and a state (a user session) is associated with each request. In
    modern applications (we will cover this in a bit more detail in the next section),
    a server-side session ID is replaced with the JWT. The following diagram shows
    the workings of the JWT:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，HTTP的无状态特性通过将每个请求与服务器上创建的会话ID关联，并由客户端使用cookies存储来绕过Web应用程序（大多数都是状态性的）。每个请求以HTTP头的形式发送cookie（会话ID），由服务器进行验证，并将状态（用户会话）与每个请求关联。在现代应用程序中（我们将在下一节中更详细地介绍），服务器端会话ID被JWT取代。以下图表显示了JWT的工作原理：
- en: '![](img/f181c449-77aa-498b-a77a-2104f1bb75ad.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f181c449-77aa-498b-a77a-2104f1bb75ad.png)'
- en: 'Figure 1: Workings of the JWT in modern applications'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：现代应用程序中JWT的工作原理
- en: The web server, in this case, doesn't create a user session and the user session
    management capability needed for a stateful application is offloaded to other
    mechanisms.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Web服务器不创建用户会话，并且对于需要状态的应用程序，用户会话管理能力被卸载到其他机制。
- en: In the world of the Spring Framework, the Spring Session module can be employed
    to externalize the session from the web server to a central persistence store
    (Redis, Couchbase, and so on). Every request containing a valid token (JWT) is
    validated against this external store of authenticity and validity. After successful
    authentication, applications can generate a valid token and send it as a response
    to the client. The client can then store this token in any client storage mechanism
    it uses (sessionStorage, localStorage, cookies, and so on, in a browser). Using
    Spring Security, we can validate this token to ascertain the authenticity and
    validity of the user and then do whatever is required. We have a dedicated example
    in a subsequent section (Simple REST API security) of this chapter, which uses
    a basic authentication mechanism and, if successful, creates the JWT. Subsequent
    requests use the token in the HTTP header, which gets validated on the server
    to give access to other secured resources.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Framework的世界里，可以使用Spring Session模块将会话从Web服务器外部化到中央持久存储（Redis、Couchbase等）。每个包含有效令牌（JWT）的请求都会与这个外部存储的真实性和有效性进行验证。在成功认证后，应用程序可以生成一个有效的令牌并将其作为响应发送给客户端。客户端可以将此令牌存储在它使用的任何客户端存储机制中（sessionStorage、localStorage、cookies等，在浏览器中）。使用Spring
    Security，我们可以验证此令牌以确定用户的真实性和有效性，然后执行所需的操作。我们将在本章后续部分（简单的REST API安全）中提供一个专门的示例，该示例使用基本的认证机制，并在成功后创建JWT。后续请求使用HTTP头中的令牌，该令牌在服务器上进行验证，以访问其他受保护资源。
- en: 'The following points highlight some of the advantages of using the JWT:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点突出了使用JWT的一些优点：
- en: '**Better performance**: Each request, when reaching the server, has to check
    the authenticity of the token send. The authenticity of the JWT can be checked
    locally and doesn''t require an external call (say, to a database). This local
    validation is performant and reduces the overall response time for a request.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的性能**：每次请求到达服务器时，都必须检查发送的令牌的真实性。JWT的真实性可以在本地进行验证，不需要外部调用（例如，数据库）。这种本地验证性能良好，并减少了请求的整体响应时间。'
- en: '**Simplicity**: JWT is easy and simple to implement. Also, it is a well established
    format in the industry for tokens. There are a number of well-known libraries
    which can be used to easily work with the JWT.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：JWT易于实现，也是一个在行业中广泛认可的令牌格式。有许多知名的库可以用来轻松地处理JWT。'
- en: Structure of a token
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令牌的结构
- en: 'Unlike common security mechanisms, such as encryption, obscuring, and hiding,
    the JWT doesn''t encrypt or hide the data contained within. But, it does the destination
    system to check whether the token is from an authentic source. The structure of
    the JWT consists of a header, payload, and a signature. As mentioned, rather than
    encryption, the data contained within the JWT is encoded and then signed. Encoding
    does the job of transforming the data in a way that is acceptable by a variety
    of parties and signing allows us to check for its authenticity and, in fact, its
    origin:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与常见的安全机制（如加密、隐藏和隐藏）不同，JWT不加密或隐藏包含在其中的数据。但是，它确实允许目标系统检查令牌是否来自真实的来源。JWT的结构由一个头部、一个有效载荷和一个签名组成。如前所述，JWT中包含的数据不是加密的，而是编码并签名。编码的工作是将数据转换为各种方都可以接受的方式，而签名允许我们检查其真实性，实际上，其来源：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's go into more detail about each of the components constituting the token.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解构成令牌的每个组件。
- en: Header
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部
- en: 'This is a JSON object and takes the following format. It gives information
    on how the signature should be computed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JSON对象，具有以下格式。它提供了关于如何计算签名的信息：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value of `typ` specifies type of the object, and in this case, it is the
    `JWT`. The value of `alg` specifies the algorithm used to create the signature,
    and in this case it is `HMAC-SHA256`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`typ`的值指定了对象的类型，在这种情况下，它是`JWT`。`alg`的值指定了创建签名所使用的算法，在这种情况下是`HMAC-SHA256`。'
- en: Payload
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效载荷
- en: 'The payload forms the actual data (also known as a **claim**) stored in the
    JWT. According to your application''s requirements, you can put any number of
    claims into your JWT payload component. There are some predefined claims, such
    as `iss` (issuer), `sub` (subject), `exp` (expiration time), `iat` (issued at),
    and so on, that can be used, but all of these are optional:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷构成了JWT中存储的实际数据（也称为**声明**）。根据您应用程序的要求，您可以将任意数量的声明放入JWT有效载荷组件中。有一些预定义的声明，如`iss`（发行者）、`sub`（主题）、`exp`（过期时间）、`iat`（发行时间）等，可以用来，但这些都是可选的：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Signature
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签名
- en: 'The signature is formed as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 签名如下形成：
- en: 'The `header` is `base64` encoded: `base64(header)`.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`header`是`base64`编码的：`base64(header)`。'
- en: 'The `payload` is `base64` encoded: `base64(payload)`.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`payload`是`base64`编码的：`base64(payload)`。'
- en: 'Now join the values in *Step 1* and *Step 2* with a `"."` in the middle:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将*步骤1*和*步骤2*中的值用中间的`"."`连接起来：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, the signature is attained by hashing, using the algorithm specified in
    the header, the value attained in *Step 3*, and then appending it with the secret
    text (say `packtpub`) of your choice:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，签名是通过使用头部中指定的算法，对*步骤3*中获取的值进行哈希处理，然后附加您选择的秘密文本（例如`packtpub`）来获得的：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final JWT is as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的JWT如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The website [https://jwt.io/](https://jwt.io/) is a place I always visit for
    any of my JWT needs. The sample data used in this example is from that site:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是访问[https://jwt.io/](https://jwt.io/)网站来满足我的JWT需求。本例中使用的示例数据来自该网站：
- en: '![](img/6e508052-e050-47bd-8b70-db78d22598e2.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e508052-e050-47bd-8b70-db78d22598e2.png)'
- en: 'Figure 2: Screen grab from https://jwt.io/'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：来自https://jwt.io/的屏幕截图
- en: Modern application architecture
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代应用程序架构
- en: Frontends of most modern applications are not built using server-side web application
    frameworks, such as Spring MVC, **Java Server Faces** (**JSF**), and so on. Infact,
    many are built using full-fledged client-side frameworks, such as React (to be
    full-fledged, it has to be combined with other libraries), Angular, and so on.
    The previous statement doesn't mean in any way that there is no place for such
    server-side web application frameworks. According to the application you are building,
    there are specific places for each of these frameworks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代应用程序的前端不是使用服务器端Web应用程序框架（如Spring MVC、**Java Server Faces**（**JSF**）等）构建的。实际上，许多都是使用完整的客户端框架（如React（要成为完整的，它必须与其他库结合使用）、Angular等）构建的。前面的陈述并不意味着没有这样的服务器端Web应用程序框架的立足之地。根据您构建的应用程序，每个框架都有其特定的位置。
- en: When using client-side frameworks, the client code (HTML, JS, CSS, and so on)
    in general is not secured. However, the data required to render these dynamic
    pages is secured behind a RESTful endpoint.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用客户端框架时，客户端代码（HTML、JS、CSS等）通常是不安全的。然而，渲染这些动态页面所需的数据是在RESTful端点之后得到保护的。
- en: 'To secure a RESTful backend, the JWT is used to exchange claims between the
    server and the client. The JWT enables the stateless exchange of tokens between
    the two parties and takes away the burden of session management (no more sticky
    sessions or session replication between multiple server nodes) by the server.
    This enables the application to scale horizontally in a cost-effective manner:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护RESTful后端，使用JWT在服务器和客户端之间交换声明。JWT使得双方之间无状态的令牌交换成为可能，并减轻了服务器端会话管理的负担（不再需要在多个服务器节点之间进行粘性会话或会话复制）。这使得应用能够以成本效益的方式水平扩展：
- en: '![](img/841b4165-d61d-41e8-89ec-89647e225641.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/841b4165-d61d-41e8-89ec-89647e225641.png)'
- en: 'Figure 3: API-based modern application architecture'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：基于API的现代应用架构
- en: SOFEA
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOFEA
- en: '**Service-Oriented Front-End Architecture** (**SOFEA**) is of the architectural
    style which had gained popularity in the past when **S****ervice Oriented Architecture** (**SOA**)
    and was becoming common in many enterprises. In modern days, SOA is more of less
    with microservices-based architecture and the backend is reduced to a bunch of
    RESTful endpoints. The client on the other hand is becoming thicker and uses client-side
    MVC frameworks such as Angular and React, just to name a couple. However, the
    core concept of SOFEA, in which backend is just endpoints and frontend (UI) becoming
    thicker is something everyone considers in modern age web application development.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务的前端架构**（**SOFEA**）是一种在过去的SOA（服务导向架构）变得普遍时流行起来的架构风格。在当今时代，SOA更多是微服务架构，后端简化为一组RESTful端点。另一方面，客户端正在变得越来越厚，并使用客户端MVC框架，如Angular和React（仅举两例）。然而，SOFEA的核心概念，即后端只是端点，前端（UI）变得越来越厚，是现代Web应用开发中每个人都考虑的因素。'
- en: 'Some of the advantages of SOFEA are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: SOFEA的一些优点如下：
- en: The client in this is thicker (similar to thick client applications) as against
    thin client web applications that we have seen in the past. After initial view/rendering
    of pages, all the assets are downloaded from server and resides/caches on the
    client (browser). Thereafter, the server is contacted only for data when required
    by the client through XHR (Ajax) calls.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与我们过去看到的瘦客户端Web应用相比，本例中的客户端更厚（类似于厚客户端应用）。在页面初始查看/渲染之后，所有资源都从服务器下载并存储/缓存于客户端（浏览器）。此后，只有在客户端通过XHR（Ajax）调用需要数据时才会联系服务器。
- en: After the client code is downloaded, only data flows from the server to the
    client, as opposed to presentation code (HTML, JavaScript, and so on), better
    utilizing the bandwidth. As there is less data being transferred, response times
    are faster, making applications perform better.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端代码下载后，只有数据从服务器流向客户端，而不是表示代码（HTML、JavaScript等），更好地利用带宽。由于传输的数据更少，响应时间更快，使得应用性能更佳。
- en: Any number of clients can be written utilizing the same RESTful server endpoints,
    reusing APIs to the fullest.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用相同的RESTful服务器端点编写任意数量的客户端，充分利用API。
- en: These endpoints can externalize a session (in the Spring Framework, there is
    a module called **Spring Session**, which can be used to achieve this technical
    capability), thus easily achieving the horizontal scalability of the server.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些端点可以将会话外部化（在Spring框架中，有一个名为**Spring Session**的模块，可以用来实现这一技术能力），从而轻松实现服务器的水平扩展性。
- en: Better role segregation of team members in a project with APIs managed by a
    team and UI code managed by a different team.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在由团队管理的API和由不同团队管理的UI代码的项目中，团队成员的角色分离更好。
- en: Reactive REST API
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式REST API
- en: In the [Chapter 4](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml), *Authentication
    Using CAS and JAAS*, we went through the reactive Spring WebFlux web application
    framework in detail. We also looked into a lot of the reactive programming support
    provided by the Spring Framework and other Spring modules. Knowingly or unknowingly,
    we created a reactive REST API in the previous chapter's example sections. We
    used a handler and router mechanism for creating a RESTful application and also
    secured it using the *BASIC* authentication mechanism.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml)，*使用CAS和JAAS进行认证*中，我们详细介绍了reactive
    Spring WebFlux网络应用程序框架。我们还探讨了Spring框架和其他Spring模块提供的许多reactive编程支持。在上一章的示例部分中，我们有意或无意地创建了一个reactive
    REST API。我们使用处理程序和路由机制来创建RESTful应用程序，并使用*BASIC*认证机制来保护它。
- en: We saw the workings of `WebClient` (a reactive way of calling REST APIs, as
    opposed to using a blocking `RestTemplate`) and `WebTestClient` (a reactive way
    of writing test cases). We also saw the workings of Spring Data in a reactive
    way using MongoDB as the persistent store.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`WebClient`（一种调用REST API的reactive方式，与使用阻塞的`RestTemplate`相反）和`WebTestClient`（一种编写测试用例的reactive方式）的工作原理。我们还看到了使用MongoDB作为持久存储库的Spring
    Data的reactive方式。
- en: We will not go through these aspects here; we will only mention that, if you
    wish, you can make yourself comfortable with this topic by going through the section
    in [Chapter 4](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml), *Authentication Using
    CAS and JAAS*. In this chapter, we will cover where we left off from the previous
    chapter by getting to REST API security using the JWT, and then going through
    REST API security using OAuth (implementing a custom provider as opposed to using
    public providers, such as Google, Facebook, and so on).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不会在这里介绍这些方面；我们只会提到，如果您愿意，可以通过[第4章](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml)，*使用CAS和JAAS进行认证*中的部分来让自己熟悉这个主题。在本章中，我们将通过使用JWT进行REST
    API安全来继续上一章的内容，然后介绍使用OAuth进行REST API安全（实现自定义提供者，而不是使用公共提供者，如Google、Facebook等）。 '
- en: Simple REST API security
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单REST API安全
- en: 'We will use the example that we created in [Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml), *Integrating
    with Spring WebFlux* (*spring-boot-spring-webflux*) and expand on it by doing
    the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在[第5章](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml)，*与Spring WebFlux集成*
    (*spring-boot-spring-webflux*)中创建的示例，并通过以下方式对其进行扩展：
- en: Bringing the JWT support to the already existing Spring WebFlux application
    secured using basic authentication.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JWT支持引入已经使用基本认证保护的现有Spring WebFlux应用程序。
- en: Creating a new controller (`path /auth/**`) that will have new endpoints, using
    which you can authenticate the user.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的控制器（`路径 /auth/**`），它将包含新的端点，您可以使用这些端点来验证用户。
- en: Using basic authentication or the auth REST endpoint, we will generate the JWT
    on the server and send it as a response to the client. Subsequent calls from the
    client to access secured REST APIs can be achieved by using the JWT supplied as
    a HTTP header (authorization, bearer token).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本认证或auth REST端点，我们将在服务器上生成JWT并将其作为响应发送给客户端。客户端后续调用以访问受保护的REST API可以通过使用作为HTTP头（授权，bearer令牌）提供的JWT来实现。
- en: We won't be able to go into each and every detail of this project (we have a
    more important topic that we need to cover in this chapter within the stipulated
    page count). However, while going through the example, important code snippets
    will be listed down and explained in detail to some extent.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法详细说明这个项目的每个细节（我们在这个章节中还有更多重要的主题需要覆盖，且在规定的页数内）。然而，在通过示例进行说明时，重要的代码片段将被列出并详细解释。
- en: Spring Security configuration
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security配置
- en: 'In the Spring Security configuration, we tweak the `springSecurityFilterChain`
    bean, as shown in the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security配置中，我们调整了`springSecurityFilterChain`bean，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have a new `AuthenticationWebFilter` and a `AuthenticationSuccessHandler`
    configured. We also have a new `JWTAuthWebFilter` class for handling the JWT-based
    authentication configured.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们配置了一个新的`AuthenticationWebFilter`和一个`AuthenticationSuccessHandler`。我们还配置了一个新的`JWTAuthWebFilter`类来处理基于JWT的认证。
- en: 'We will be using `ReactiveUserDetailsService` with hardcoded user credentials
    for testing, as shown in the following code snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试中使用硬编码的用户凭据来`ReactiveUserDetailsService`，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Authentication success handler
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证成功处理器
- en: 'We set up a custom `AuthenticationSuccessHandler` (the source code for this
    class is shown next) in our Spring Security configuration class. On successful
    authentication, it will generate the JWT and also set a HTTP response header:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Spring Security配置类中设置了一个自定义的`AuthenticationSuccessHandler`（这个类的源代码将在下面展示）。在认证成功后，它将生成JWT并设置一个HTTP响应头：
- en: '**Header name**: `Authorization`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部名称**：`Authorization`'
- en: '**Header value**: `Bearer JWT`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部值**：`Bearer JWT`'
- en: 'Let''s take a look at the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `JWTUtil` class contains a number of utility methods dealing with the JWTs,
    such as the generation of tokens, verification of tokens, and so on. The `generateToken`
    method in the `JWTUtil` class is as shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`JWTUtil`类包含处理JWT的多个实用方法，例如生成令牌、验证令牌等。`JWTUtil`类中的`generateToken`方法如下所示：'
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Custom WebFilter namely JWTAuthWebFilter
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义WebFilter，即JWTAuthWebFilter
- en: 'Our custom `WebFilter`, named `JWTAuthWebFilter`, is entrusted with converting
    the JWT token received into appropriate classes that the Spring Security understands.
    It makes use of a converter named `JWTAuthConverter`, which does a number of things,
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义`WebFilter`，命名为`JWTAuthWebFilter`，负责将接收到的JWT令牌转换为Spring Security理解的适当类。它使用一个名为`JWTAuthConverter`的转换器，执行以下操作：
- en: Gets the authorization `payload`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取授权`payload`
- en: Extracts the token by discarding the `Bearer` string
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过丢弃`Bearer`字符串提取令牌
- en: Verifies the token
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证令牌
- en: Creates a `UsernamePasswordAuthenticationToken` class understood by Spring Security
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Spring Security理解的`UsernamePasswordAuthenticationToken`类
- en: The code snippet below shows the `JWTAuthWebFilter` class and its important
    method which does operations listed above.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了`JWTAuthWebFilter`类及其重要的方法，该方法执行上述操作。
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After this conversion, it does the actual authentication using Spring Security,
    which sets `SecurityContext` in the application, as shown in the following code
    snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此转换之后，它使用Spring Security进行实际认证，在应用程序中设置`SecurityContext`，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `JWTAuthWebFilter` class filter method does the necessary conversions and
    then the `authenticate` method does the actual authentication, and finally calls
    the `onAuthSuccess` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`JWTAuthWebFilter`类的过滤器方法执行必要的转换，然后`authenticate`方法执行实际认证，最后调用`onAuthSuccess`方法。'
- en: New controller classes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的控制器类
- en: 'We have two controllers, namely `DefaultController` (mapped to the `/` and
    `/login` paths) and `AuthController` (mapped to the `/auth` main route and `/token`
    sub-route). The `/auth/token` path can be used to retrieve the token, which can
    be used for a subsequent API call (`Bearer <Token>`). The code snippet for `AuthController`
    is as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个控制器，即`DefaultController`（映射到`/`和`/login`路径）和`AuthController`（映射到`/auth`主路由和`/token`子路由）。`/auth/token`路径可以用来检索令牌，该令牌可以用于后续的API调用（`Bearer
    <Token>`）。`AuthController`的代码片段如下所示：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the application and testing
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序并进行测试
- en: 'Run the application using the Spring Boot command shown below:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下Spring Boot命令运行应用程序：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I will be using Postman to execute the REST endpoints.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Postman来执行REST端点。
- en: 'You can get hold of the token, to include it in subsequent calls, by employing
    two methods as detailed below:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下两种方法获取令牌，以便在后续调用中包含它：
- en: 'If you access any route using basic authentication credentials, in the response
    header, you should get the token. I will be using the `/login` path with Basic
    Auth (authorization header) to get the token, as shown here:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用基本认证凭据访问任何路由，在响应头中，你应该获取到令牌。我将使用带有基本认证（授权头）的`/login`路径来获取令牌，如下所示：
- en: '![](img/d417a89e-0a43-4612-964b-8d12a8c02328.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d417a89e-0a43-4612-964b-8d12a8c02328.png)'
- en: 'Figure 4: Getting token using Basic Auth in Postman'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：在Postman中使用基本认证获取令牌
- en: 'Access the `/auth/token` endpoint with Basic Auth credentials supplied in the
    form of JSON (using the `JWTAuthRequest` class), as shown here, in Postman:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON格式提供的基本认证凭据访问`/auth/token`端点，如下所示，使用Postman：
- en: '![](img/b601600b-0c3b-4c15-8c9a-9414f2a45049.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b601600b-0c3b-4c15-8c9a-9414f2a45049.png)'
- en: 'Figure 5: Getting token using /auth/token endpoint using Basic Auth credentials
    in JSON'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：使用JSON中的基本认证凭据通过/auth/token端点获取令牌
- en: 'Using the token retrieved, call the movie endpoint, as shown here, using Postman:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用获取到的令牌调用电影端点，如下所示，使用Postman：
- en: '![](img/967a0611-eeb5-44d1-91ad-c9373acbc3cb.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/967a0611-eeb5-44d1-91ad-c9373acbc3cb.png)'
- en: 'Figure 6: Retrieving movie listing using a JWT token in Postman'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：在Postman中使用JWT令牌检索电影列表
- en: This completes the example that we were building. In this example, we secured
    the REST APIs by making use of JWT and validated them using Spring Security. As
    mentioned, this is a basic way in which you can secure your REST APIs using Spring
    Security with JWTs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们正在构建的示例。在这个示例中，我们通过使用JWT来保护REST API，并使用Spring Security进行验证。正如之前提到的，这是使用Spring
    Security和JWT保护REST API的基本方法。
- en: Advanced REST API security
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级REST API安全
- en: REST APIs can be secured by another mechanism in your web application, OAuth.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: REST API可以通过你的Web应用程序中的另一种机制进行保护，即OAuth。
- en: OAuth is an authorization framework that allows other applications with the
    right credentials access to partial/limited user profile details stored on platforms
    such as Google and Facebook. The authentication part is delegated to these services
    and if successful, appropriate grants are given to the calling client/application,
    which can be used to get access to secured resources (in our case RESTful APIs).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一个授权框架，允许其他应用程序使用正确的凭证访问存储在Google和Facebook等平台上的部分/有限用户配置文件详情。认证部分委托给这些服务，如果成功，将给予调用客户端/应用程序适当的授权，这些授权可以用来获取访问受保护资源（在我们的案例中是RESTful
    API）的权限。
- en: We have seen OAuth security using a public authentication provider in [Chapter
    3](69913c59-1186-44b2-8707-dceca721e206.xhtml), *Authentication Using CAS and
    JAAS* (in the *OAuth 2 and OpenID connect* section). However, we need not use
    these public providers; you have the choice of using your own. We will cover one
    such example in this chapter, where we will be using our own authentication provider
    and securing our Spring Boot-based reactive REST endpoints.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](69913c59-1186-44b2-8707-dceca721e206.xhtml)，*使用CAS和JAAS进行认证*（在*OAuth
    2和OpenID connect*部分）中看到了使用公共身份验证提供者的OAuth安全。然而，我们不必使用这些公共提供者；你有选择使用自己的。在本章中，我们将介绍这样一个例子，我们将使用自己的身份验证提供者并保护基于Spring
    Boot的响应式REST端点。
- en: Before getting into the example, we need to understand a bit more about OAuth,
    and also need to understand its various components. We already went through a
    lot of the details of OAuth in [Chapter 3](https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=30&action=edit#post_28), *Authentication
    Using CAS and JAAS*. We will add to those details in this section and then go
    through the code example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入示例之前，我们需要对OAuth有更多的了解，也需要了解其各种组件。我们已经在[第3章](https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=30&action=edit#post_28)中详细介绍了OAuth的很多细节，*使用CAS和JAAS进行认证*。在本节中，我们将补充这些细节，然后通过代码示例进行讲解。
- en: OAuth2 roles
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth2角色
- en: 'OAuth stipulates four roles for users and applications. The interactions between
    these roles are shown in the following diagram:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth为用户和应用程序规定了四个角色。这些角色之间的交互在以下图中展示：
- en: '![](img/6d946741-9ac2-4e7f-8504-a46b832ebb27.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d946741-9ac2-4e7f-8504-a46b832ebb27.png)'
- en: 'Figure 7: OAuth role interaction'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：OAuth角色交互
- en: We will look into each of these OAuth roles in some detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨这些OAuth角色的每一个。
- en: Resource owner
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者
- en: This is the user who owns the protected resource that is needed by the consuming
    client application. If we take Facebook or Google as the authentication provider,
    the resource owner is the actual user who has data saved on these platforms.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是拥有受保护资源并需要由消费客户端应用程序使用的用户。如果我们以Facebook或Google作为身份验证提供者，资源所有者就是实际在这些平台上保存数据的用户。
- en: Resource server
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器
- en: This is the server that has the secured resources in the form of hosted APIs.
    If we take Google or Facebook as an example, they hold the profile information,
    as well as other information, in the form of APIs. If the client application successfully
    authenticates (using the credentials provided by the user) and then the user grants
    appropriate permissions, they can get access to this information through their
    exposed APIs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是拥有以托管API形式存在的受保护资源的服务器。如果我们以Google或Facebook为例，它们以API的形式持有配置信息以及其他信息。如果客户端应用程序成功认证（使用用户提供的凭证）并且用户授予适当的权限，他们可以通过公开的API获取这些信息。
- en: Client
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: This is the application that to access the secured resources available on the
    resource server. If the user is successfully authenticated and the client application
    is given permission by the user to access the right information, the client application
    can retrieve the data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是访问资源服务器上受保护资源的应用程序。如果用户成功认证，并且客户端应用程序获得了用户的权限来访问正确的信息，客户端应用程序可以检索数据。
- en: Authorization server
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权服务器
- en: This is the server that authenticates and authorizes client applications to
    access the secured resources owned by the resource owner and on the resource server. It
    is not uncommon to see the same server performing both roles.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是验证和授权客户端应用程序访问资源所有者拥有的受保护资源以及资源服务器的服务器。同一个服务器执行这两个角色并不罕见。
- en: 'To participate in OAuth, your application has to first register with the service
    provider (Google , Facebook, and so on) against which you plan to authenticate
    by providing the application name, application URL, and callback URL. Successful
    registration of your application with the service provider gives you two values
    unique to your application: `client application_id` and `client_secret`. `client_id`
    can be exposed publicly but `client_secret` is kept hidden (private). Both these
    values are needed whenever you access the service provider. The following diagram
    shows the interactions between these roles:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要参与OAuth，您的应用程序必须首先在服务提供商（如Google、Facebook等）处注册，您需要提供应用程序名称、应用程序URL和回调URL以进行认证。您的应用程序成功注册后，您将获得两个唯一的应用程序值：`客户端应用程序ID`和`客户端密钥`。`客户端ID`可以公开，但`客户端密钥`是隐藏的（私有的）。每次访问服务提供商时都需要这两个值。以下图表显示了这些角色之间的交互：
- en: '![](img/5115c019-94ee-4e31-abfd-1458d4305577.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5115c019-94ee-4e31-abfd-1458d4305577.png)'
- en: 'Figure 8: OAuth role interaction'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：OAuth角色交互
- en: 'The steps in the preceding diagram are covered in detail here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下详细解释了前面图表中的步骤：
- en: The client application requests the resource owner to give them authorization
    to access the secured resources
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序请求资源所有者授权它们访问受保护资源
- en: If the resource owner authorizes this, the authorization grant is sent to the
    client application
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源所有者授权这样做，授权许可将发送给客户端应用程序
- en: The client application asks for a token, using the grant provided by the resource
    owner along with authentication credentials from the authorization server
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用资源所有者提供的授权以及从授权服务器获取的认证凭证请求一个令牌
- en: If the credentials and grant from the client application are valid, the authorization
    server issues an Access Token to the client application
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果客户端应用程序的凭证和授权有效，授权服务器向客户端应用程序颁发访问令牌
- en: The client application accesses the protected resources on the resource server
    using the Access Token provided
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用提供的访问令牌访问资源服务器上的受保护资源
- en: If the Access Token sent by the client application is valid, the resource server
    gives access to the secured resources
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果客户端应用程序发送的访问令牌有效，资源服务器将允许访问受保护资源
- en: Authorization grant types
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权许可类型
- en: As shown in the diagram, for the client to start calling APIs, it needs to obtain
    an authorization grant in the form of an Access Token. OAuth provides four grant
    types, which can be used according to different application requirements. The
    as to which authorization grant type to use is left with the client application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如图表所示，客户端要开始调用API，需要以访问令牌的形式获得授权许可。OAuth提供了四种授权类型，可以根据不同的应用需求使用。至于使用哪种授权类型，由客户端应用程序决定。
- en: Authorization code flow
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权代码流程
- en: 'This a is very commonly used grant type and works on redirection at the server.
    It is highly suitable for server-side applications where the source code is hosted
    on the server and nothing is available on the client. The following diagram explains
    the authorization code grant type flow:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常常用的授权类型，在服务器端通过重定向工作。它非常适合服务器端应用程序，其中源代码托管在服务器上，客户端没有任何内容。以下图表解释了授权代码授权类型的流程：
- en: '![](img/54908998-f191-4a15-bc07-7a7469a08aa6.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54908998-f191-4a15-bc07-7a7469a08aa6.png)'
- en: 'Figure 9: Authorization code flow'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：授权代码流程
- en: 'The steps in the preceding diagram are explained in detail here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下详细解释了前面图表中的步骤：
- en: 'The resource owner of the secured resource is presented with a screen in the
    browser to authorize the request. Here is a sample authorization link: `https://<DOMAIN>/oauth/authorize?response_type=code&client_id=<CLIENT_ID>&redirect_uri=<CALLBACK_URL>&scope=<SCOPE>`.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源所有者在浏览器中看到一个屏幕来授权请求。以下是一个示例授权链接：`https://<域名>/oauth/authorize?response_type=code&client_id=<客户端ID>&redirect_uri=<回调URL>&scope=<作用域>`.
- en: 'These are the important query parameters in the previous link:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在前一个链接中的重要查询参数：
- en: '`client_id`: The client application ID that we got while registering the application
    with the service provider'
  id: totrans-165
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_id`：在将应用程序注册到服务提供商时获得的客户端应用程序ID'
- en: '`redirect_uri`: After successful authorization, the server redirects to this
    URL supplied'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect_uri`：在成功授权后，服务器将重定向到提供的此URL'
- en: '`response_type`: A very important parameter the client uses to ask the server
    for the authorization code'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response_type`：客户端用来请求服务器授权代码的一个非常重要的参数'
- en: '`scope`: Specifies the level of access that it requires'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`：指定它所需的访问级别'
- en: If the resource owner (user) allows this, they click on the authorize link,
    which is sent to the authorization server.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源所有者（用户）允许这样做，他们就会点击授权链接，该链接被发送到授权服务器。
- en: If the authorization request sent to the authorization server is validated and
    found to be successful, the client receives the authorization code grant from
    the authorization server appended as a query parameter in the callback URL (<`CALLBACK_URL>?code=<AUTHORIZATION_CODE>`)
    specified in `Step 1`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发送给授权服务器的授权请求被验证并发现成功，客户端将从授权服务器接收授权代码许可，作为查询参数附加在`Step 1`中指定的回调URL（<`CALLBACK_URL>?code=<AUTHORIZATION_CODE>`）中。
- en: Using the authorization grant, the client application requests an Access Token
    from the authorization server (`https://<DOMAIN>/oauth/token?client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>&grant_type=authorization_code&code=<AUTHORIZATION_CODE>&redirect_uri=CALLBACK_URL`).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用授权许可，客户端应用程序从授权服务器请求访问令牌（`https://<DOMAIN>/oauth/token?client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>&grant_type=authorization_code&code=<AUTHORIZATION_CODE>&redirect_uri=CALLBACK_URL`）。
- en: In this URL, the client application's `client_secret` also has to be passed,
    along with the `grant_type` parameter, which states that the code passed is the
    authorization code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在此URL中，客户端应用程序的`client_secret`也必须传递，以及`grant_type`参数，该参数表示传递的代码是授权代码。
- en: The authorization server validates the credentials and authorization grant and
    sends the Access Token to the client application, preferably in the form of JSON.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器验证凭证和授权许可，并将访问令牌发送给客户端应用程序，最好是JSON格式。
- en: The client application calls the protected resource on the resource server using
    the Access Token received in *Step 5*.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用在*步骤5*中收到的访问令牌调用资源服务器上的受保护资源。
- en: If the Access Token supplied in *Step 5* is valid, the resource server gives
    access to the secured resource.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在*步骤5*中提供的访问令牌有效，资源服务器将提供对受保护资源的访问。
- en: Implicit flow
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式流程
- en: 'This is commonly used in mobile and web applications, and also works based
    on redirection. The following diagram explains the implicit code grant type flow:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于移动和Web应用程序，并且基于重定向工作。以下图解释了隐式代码授权类型流程：
- en: '![](img/8da3f363-ff0a-4d4a-9058-9247f0dc33e3.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8da3f363-ff0a-4d4a-9058-9247f0dc33e3.png)'
- en: 'Figure 10: Implicit flow'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：隐式流程
- en: 'The steps in the preceding diagram are explained in detail here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上一图中的步骤在此处进行详细解释：
- en: 'The resource owner is presented with a screen (browser) to authorize the request.
    Here is an example authorization link: `https://<DOMAIN>/oauth/authorize?response_type=token&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=<SCOPE>`.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源所有者会看到一个屏幕（浏览器）来授权请求。以下是一个示例授权链接：`https://<DOMAIN>/oauth/authorize?response_type=token&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=<SCOPE>`。
- en: It is important to note that the `response_type` specified in the previous link
    is `token`. This indicates the server should give the Access Token (this is one
    of the main differences from the authorization code flow grant type discussed
    in the previous section).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，前一个链接中指定的`response_type`是`token`。这表示服务器应提供访问令牌（这是与上一节中讨论的授权代码流授权类型的主要区别之一）。
- en: If the resource owner (user) allows this, they click on the authorize link,
    which is sent to the authorization server.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源所有者（用户）允许这样做，他们就会点击授权链接，该链接被发送到授权服务器。
- en: The user-agent (browser or mobile app) receives the Access Token in the `CALLBACK_URL`
    specified (`https://<CALLBACK_URL>#token=<ACCESS_TOKEN>`).
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户代理（浏览器或移动应用）在指定的`CALLBACK_URL`中接收访问令牌（`https://<CALLBACK_URL>#token=<ACCESS_TOKEN>`）。
- en: The user-agent goes to the specified `CALLBACK_URL`, retaining the Access Token.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户代理前往指定的`CALLBACK_URL`，保留访问令牌。
- en: The client application opens the web page (using any mechanism), which extracts
    the Access Token from the `CALLBACK_URL`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序打开网页（使用任何机制），从中提取`CALLBACK_URL`中的访问令牌。
- en: The client application now has access to the Access Token.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序现在可以访问访问令牌。
- en: The client application calls the secured API using the Access Token.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用访问令牌调用受保护的API。
- en: Client credentials
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端凭证
- en: This is one the simplest grant to implement. The client application sends credentials
    (the client's service account), along with `client_ID` and `client_secret,` to
    the authorization server. If the supplied values are valid, the authorization
    server sends the Access Token, which can be used to get access to the secured
    resources.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的授权实现之一。客户端应用程序将凭证（客户端的服务账户）、`client_ID` 和 `client_secret` 发送到授权服务器。如果提供的值有效，授权服务器将发送访问令牌，该令牌可用于访问受保护资源。
- en: Resource owner password credentials
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证
- en: Again, this is another simple type that can be easily used, but it is considered
    the most insecure of all. In this grant type, the resource owner (user) has to
    key their credentials directly into the client application interface (remember,
    the client application has access to the resource owner's credentials). The credentials
    are then used by the client application to send to the authorization server to
    get the Access Token. This grant type only works if the resource owner fully trusts
    the application through which they give their credentials to the service provider,
    as these credentials pass through the application server of the client application (they
    can therefore be stored, if the client application decides to).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这又是一种可以轻松使用的简单类型，但它被认为是所有类型中最不安全的。在这种授权类型中，资源所有者（用户）必须直接将他们的凭证输入到客户端应用程序界面（记住，客户端应用程序可以访问资源所有者的凭证）。然后，客户端应用程序使用这些凭证发送到授权服务器以获取访问令牌。这种授权类型仅在资源所有者完全信任他们提供凭证的服务提供者通过的应用程序时才有效，因为这些凭证会通过客户端应用程序的服务器（如果客户端应用程序决定的话，可以存储）。
- en: Access Token and Refresh Token
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问令牌和刷新令牌
- en: The Access Token can be used by the client application to retrieve information
    from the resource server for a stipulated time for which the token is deemed valid.
    After this, the server will reject the request with the appropriate HTTP response
    error code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌可以由客户端应用程序用于从资源服务器检索信息，该令牌被认为在指定时间内有效。在此之后，服务器将使用适当的 HTTP 响应错误代码拒绝请求。
- en: Along with the Access Token, OAuth allows the authorization server to also send
    another token, the Refresh Token. When the Access Token expires, the client application
    can use this second token to request the authorization server to provide a new
    Access Token.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问令牌外，OAuth 还允许授权服务器发送另一个令牌，即刷新令牌。当访问令牌过期时，客户端应用程序可以使用这个第二个令牌请求授权服务器提供新的访问令牌。
- en: Spring Security OAuth project
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security OAuth 项目
- en: Currently in the Spring ecosystem, OAuth support has spread to a number of projects,
    including Spring Security Cloud, Spring Security OAuth, Spring Boot, and the edition
    of Spring Security (5.x+). This has created a lot of confusion within the community
    and no single source of ownership. The approach taken by the Spring team is to
    consolidate this and start maintaining everything regarding to OAuth with Spring
    Security. Important components that are part of OAuth, namely the authorization
    server, the resource server, and next-level support for OAuth2, as well as OpenID
    Connect 1.0, are expected to be added to Spring Security by the end of 2018\.
    The Spring Security roadmap clearly states that by mid-2018, support for the resource
    server would be added, and the authorization server by the end of 2018.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在 Spring 生态系统内，OAuth 的支持已经扩展到多个项目，包括 Spring Security Cloud、Spring Security
    OAuth、Spring Boot 以及 Spring Security 的 5.x+ 版本。这导致社区内出现了很多混淆，并且没有单一的拥有源。Spring
    团队采取的方法是整合这些内容，并开始使用 Spring Security 维护所有与 OAuth 相关的内容。OAuth 的重要组成部分，包括授权服务器、资源服务器、OAuth2
    的下一级支持，以及 OpenID Connect 1.0，预计将在 2018 年底添加到 Spring Security 中。Spring Security
    的路线图明确指出，到 2018 年中，将添加对资源服务器的支持，并在 2018 年底添加对授权服务器的支持。
- en: The Spring Security OAuth project, as it stands at the time of writing this
    book, is in maintenance mode. This means that there will be a release for bug/security
    fixes, along with minor features. No major features are planned to be added to
    this project going forward.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Spring Security OAuth 项目处于维护模式。这意味着将会有针对错误/安全修复的发布，以及一些小功能。没有计划添加任何主要功能到这个项目中。
- en: The full OAuth2 feature matrix available in various Spring projects can be found
    at [https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix](https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种Spring项目中可用的完整OAuth2功能矩阵可以在[https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix](https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix)找到。
- en: At the time of writing this book, most of the features that we require to implement
    OAuth is available as part Spring Security OAuth project, which is in maintenance
    mode.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，我们实现OAuth所需的大部分功能都作为Spring Security OAuth项目的一部分提供，该项目处于维护模式。
- en: OAuth2 and Spring WebFlux
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth2和Spring WebFlux
- en: Full-fledged OAuth2 support for a Spring WebFlux application is not available
    in Spring Security at the time of writing this book. However, there is a community
    urgency around this and many things are slowly and steadily getting into Spring
    Security in this regard. Many examples are also getting baked into the Spring
    Security project that show OAuth2 with Spring WebFlux. In the [Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml),
    *Integrating with Spring WebFlux*, we saw one such example in detail. As of writing
    this book, Spring Security OAuth2 has a hard dependency on Spring MVC.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Spring Security中尚不支持Spring WebFlux应用程序的完整OAuth2支持。然而，在这方面社区有紧迫的需求，许多事情正在缓慢而稳定地进入Spring
    Security。Spring Security项目中也有很多示例被整合，展示了OAuth2与Spring WebFlux的结合。在第5章[整合Spring
    WebFlux](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml)中，我们详细看到了这样一个示例。在撰写本书时，Spring
    Security OAuth2对Spring MVC有硬依赖。
- en: Spring Boot and OAuth2
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot和OAuth2
- en: As of writing this book, Spring Boot has announced that it is dropping support
    for the Spring Security OAuth module. Instead, it will from now on with the Spring
    Security 5.x OAuth2 login features.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Spring Boot已宣布将停止支持Spring Security OAuth模块。从现在起，它将使用Spring Security 5.x
    OAuth2登录功能。
- en: 'A new module named Spring Security OAuth Boot 2 Autoconfig (its dependency
    in pom.xml is as shown in the following code snippet), ported from Spring Boot
    1.5.x, can be used to integrate Spring Security with Spring Boot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为Spring Security OAuth Boot 2 Autoconfig的新模块（其pom.xml中的依赖关系如下所示），从Spring
    Boot 1.5.x迁移而来，可以用于将Spring Security与Spring Boot集成：
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The project source code can be found at [https://github.com/spring-projects/spring-security-oauth2-boot](https://github.com/spring-projects/spring-security-oauth2-boot)).
    The full documentation for this module can be found at [https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/](https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 项目源代码可以在[https://github.com/spring-projects/spring-security-oauth2-boot](https://github.com/spring-projects/spring-security-oauth2-boot)找到。该模块的完整文档可以在[https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/](https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/)找到。
- en: Sample project
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例项目
- en: In our sample project, we will set up our own authorization server, against
    which we will authorize the APIs exposed through our resource server. We have
    movie APIs exposed on our resource server, and the client application will authenticate
    with the application (the client application is Spring Security protected) and
    then try accessing one of the movie APIs, at which point the OAuth flow will kick
    in. After a successful authorization check with the authorization server, the
    client will be given access to the requested movie APIs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们将设置自己的授权服务器，针对该服务器，我们将授权通过我们的资源服务器公开的API。我们在资源服务器上公开了电影API，客户端应用程序将与应用程序（客户端应用程序受Spring
    Security保护）进行身份验证，然后尝试访问其中一个电影API，此时OAuth流程将启动。在授权服务器成功进行授权检查后，客户端将被授予访问请求的电影API。
- en: 'We will have a parent project containing three Spring Boot projects: `oauth-authorization-server`,
    `oauth-resource-server`, and `oauth-client-app`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个包含三个Spring Boot项目的父项目：`oauth-authorization-server`、`oauth-resource-server`和`oauth-client-app`：
- en: '![](img/0a82e06b-986d-4bde-8d68-05c3fd9afa17.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a82e06b-986d-4bde-8d68-05c3fd9afa17.png)'
- en: 'Figure 11: Project structure in IntelliJ'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：IntelliJ中的项目结构
- en: We will now look at each of the individual Spring Boot projects in the subsequent
    sections. The full source code is available on the book's GitHub page under the
    `spring-boot-spring-security-oauth` project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将逐一查看后续章节中的每个Spring Boot项目。完整的源代码可以在本书的GitHub页面上的`spring-boot-spring-security-oauth`项目下找到。
- en: Authorization server
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权服务器
- en: This is a conventional Spring Boot project, which implements the authorization
    server OAuth role.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个传统的Spring Boot项目，实现了授权服务器OAuth角色。
- en: Maven dependencies
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖项
- en: 'The main dependencies to be included in the Spring Boot project''s `pom.xml`
    file are as shown in the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot项目的`pom.xml`文件中需要包含的主要依赖项如下所示：
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Spring Boot run class
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot运行类
- en: 'There is nothing special in this Spring Boot `run` class, as shown in the following
    code snippet:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，在这个Spring Boot `run`类中没有特别之处：
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Spring Security config
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security配置
- en: 'The Spring Security config class extends `WebSecurityConfigurerAdapter`. We
    will override three methods, as shown in the following code snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security配置类扩展了`WebSecurityConfigurerAdapter`。我们将覆盖三个方法，如下所示：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We `autowire` the password encoder. We then override the following methods: `globalUserDetails`,
    `authenticationManagerBean`, and `configure`. There isn't anything special to
    mention here. We define two users, managed in-memory (user and admin).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`自动装配`密码编码器。然后我们覆盖以下方法：`globalUserDetails`、`authenticationManagerBean`和`configure`。这里没有特别要提到的。我们定义了两个用户，内存中管理（用户和管理员）。
- en: Authorization server config
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权服务器配置
- en: 'This is the the most important in this Spring Boot project, where we will set
    up the authorization server configuration. We will use a new annotation, `@EnableAuthorizationServer`.
    Our configuration class will extend `AuthorizationServerConfigurerAdapter`. We
    will be using the JWT token store and will also showcase a token enhancer, using
    which you can enhance your JWT token with more claims, if deemed necessary for
    your application. The most important method in this configuration class is extracted
    as the following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个Spring Boot项目中最重要的部分，我们将设置授权服务器配置。我们将使用一个新的注解`@EnableAuthorizationServer`。我们的配置类将扩展`AuthorizationServerConfigurerAdapter`。我们将使用JWT令牌存储，并展示一个令牌增强器，使用它可以增强您的JWT令牌，如果您的应用程序认为有必要的话。这个配置类中最重要的方法如下所示：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is where we set up the client-related OAuth configuration. We set up just
    one client, and we use the in-memory option to make the example simpler to understand.
    Throughout the application, we will be using `BCrypt` as our password encoder.
    The client ID for our client app is `oAuthClientAppID` and the client secret is
    `secret`. We set up three grant types and while accessing the client, we need
    to specify the necessary scopes (movie, read, and write). After successful execution,
    the authorization server will redirect you to the specified URL (`http://localhost:8080/movie/`
    or `http://localhost:8080/movie/index`). If the URL is not correctly specified
    by the client, the server will throw an error.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们设置客户端相关的OAuth配置的地方。我们只设置了一个客户端，并使用内存选项来简化示例，使其更容易理解。在整个应用程序中，我们将使用`BCrypt`作为我们的密码编码器。我们的客户端应用程序的客户端ID是`oAuthClientAppID`，客户端密钥是`secret`。我们设置了三种授权类型，在访问客户端时，我们需要指定必要的范围（电影、读取和写入）。执行成功后，授权服务器将重定向您到指定的URL（`http://localhost:8080/movie/`或`http://localhost:8080/movie/index`）。如果客户端没有正确指定URL，服务器将抛出错误。
- en: 'The JWT token store and enhancer-related methods are as shown in the following
    code snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: JWT令牌存储和增强器相关的方法如下所示：
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code, we specify the token store, which will be used in the `tokenStore`
    method, and we also declare a `tokenEnhancer` bean. To showcase the token enhancer,
    we will be using a custom class named `CustomTokenEnhancer`; the class is as shown
    in the following code snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们指定了将在`tokenStore`方法中使用的令牌存储，并声明了一个`tokenEnhancer`豆。为了展示令牌增强器，我们将使用一个名为`CustomTokenEnhancer`的自定义类；该类如下所示：
- en: '[PRE20]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The custom token `enhancer` class implements `TokenEnhancer`. We just add new
    information (`principalinfo`) into the JWT token that contains the `toString`
    version of the `principal` object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义令牌`增强器`类实现了`TokenEnhancer`接口。我们只是将新的信息（`principalinfo`）添加到包含`principal`对象`toString`版本的JWT令牌中。
- en: Application properties
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序属性
- en: 'Since we are running all three servers locally, we have to specify different
    ports. Also, it''s important that the authorization server runs on a different
    context path. The following code snippet shows what we have in our `application.properties`
    file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们本地运行所有三个服务器，我们必须指定不同的端口。同时，授权服务器运行在不同的上下文路径上也很重要。以下代码片段显示了我们的`application.properties`文件中的内容：
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Being a Spring Boot project, it can be run by executing the `mvn spring-boot:run`
    command.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Spring Boot项目，可以通过执行`mvn spring-boot:run`命令来运行。
- en: Resource server
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器
- en: This is a conventional Spring Boot project, which implements the resource server
    OAuth role.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个传统的 Spring Boot 项目，它实现了资源服务器 OAuth 角色。
- en: Maven dependencies
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven 依赖项
- en: There isn't anything new that we are going to add in our `pom.xml`. The same
    dependencies that we had in our authorization server project apply here.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `pom.xml` 文件中，我们不会添加任何新的内容。与我们的授权服务器项目中的相同依赖项适用于此处。
- en: Spring Boot run class
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 运行类
- en: This is a typical Spring Boot `run` class, into which we put the `@SpringBootApplication`
    annotation, which does all the magic behind the scenes. Again, nothing specific
    in our Spring Boot run class applies to this project.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的 Spring Boot `run` 类，我们将 `@SpringBootApplication` 注解放入其中，它执行所有幕后的魔法。再次强调，我们的
    Spring Boot 运行类中没有任何特定于本项目的功能。
- en: Resource server config
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器配置
- en: 'This is the main resource server configuration class, where we annotate it
    with the `@EnableResourceServer` annotation and extend it from `ResourceServerConfigurerAdapter`,
    as shown in the following code snippet:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要资源服务器配置类，我们使用 `@EnableResourceServer` 注解对其进行注解，并从 `ResourceServerConfigurerAdapter`
    扩展，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Spring Security config
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 配置
- en: 'Being the resource server, we are enabling global method security so that every
    method exposing an API is secured, as shown in the following code snippet:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 作为资源服务器，我们启用了全局方法安全，这样每个公开API的方法都是安全的，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we are using `OAuth2MethodSecurityExpressionHandler` as the method security
    exception handler so that we can use annotations, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `OAuth2MethodSecurityExpressionHandler` 作为方法安全异常处理器，这样我们就可以使用注解，如下所示：
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Spring MVC config class
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC 配置类
- en: We have seen Spring MVC configuration in detail in previous chapters. In our
    example, it's a very basic Spring MVC `config` class in which `@EnableWebMvc`
    is used and implements `WebMvcConfigurer`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中详细介绍了 Spring MVC 配置。在我们的示例中，它是一个非常基本的 Spring MVC `config` 类，其中使用了 `@EnableWebMvc`
    并实现了 `WebMvcConfigurer`。
- en: Controller class
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器类
- en: 'We have one controller class, which exposes just one method (we can extend
    it further to expose more APIs). This method lists all the movies in the hardcoded
    movie list under a URL, `/movie`, as shown in the following code snippet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个控制器类，它只公开了一个方法（我们可以进一步扩展它以公开更多的API）。这个方法在URL `/movie` 下列出硬编码的电影列表中的所有电影，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We are using a `Movie` model class utilizing all the features of the `lombok`
    library, as shown in the following code snippet:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个 `Movie` 模型类，利用了 `lombok` 库的所有功能，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It has three attributes and the annotations will do all the magic and keep the
    model concise.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它有三个属性，注解将完成所有的魔法，并保持模型简洁。
- en: Application properties
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序属性
- en: Similar to the authorization server, `application.properties` just has the context
    path and port assigned.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与授权服务器类似，`application.properties` 只分配了上下文路径和端口。
- en: Being a Spring Boot project, it can be run by executing the `mvn spring-boot:run`
    command.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Spring Boot 项目，可以通过执行 `mvn spring-boot:run` 命令来运行。
- en: Client application
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端应用程序
- en: This is a conventional Spring Boot project, which implements the client OAuth
    role.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个传统的 Spring Boot 项目，它实现了客户端 OAuth 角色。
- en: Maven dependencies
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven 依赖项
- en: In our Spring Boot `pom.xml` file, new Maven dependencies for `Thymeleaf` and
    for the `lombok` library are added. The rest are all typical of a Spring Boot
    `pom.xml` file, which you are now conversant with.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Spring Boot `pom.xml` 文件中，添加了新的 Maven 依赖项，用于 `Thymeleaf` 和 `lombok` 库。其余的都是典型的
    Spring Boot `pom.xml` 文件，您现在应该很熟悉了。
- en: Spring Boot class
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 类
- en: In our example Spring Boot `run` class, there isn't anything worth mentioning.
    It is a simple class containing the all-important `main` method and the `@SpringBootApplication`
    annotation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例 Spring Boot `run` 类中，没有什么值得注意的。它是一个简单的类，包含所有重要的 `main` 方法以及 `@SpringBootApplication`
    注解。
- en: OAuth client config
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 客户端配置
- en: 'This is the main configuration class in the client application, which is annotated
    with `@EnableOAuth2Client`, as shown in the following code snippet:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端应用程序中的主要配置类，它被 `@EnableOAuth2Client` 注解，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The important aspect to look at in this class is that we initialize the OAuth2
    REST template by providing the client details, which are configured in the `application.yml`
    file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们需要关注的重要方面是，我们通过提供在 `application.yml` 文件中配置的客户详情来初始化 OAuth2 REST 模板。
- en: Spring Security config
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 配置
- en: In the Spring Security `config` class, we set up the user credentials (in-memory)
    that can be used to log in to the application and can access secured resources.
    In the `configure` method, some of the resources are marked as secured and some
    as unsecured.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security的`config`类中，我们设置了可以用于登录应用并访问受保护资源的用户凭据（内存中）。在`configure`方法中，一些资源被标记为受保护，一些则标记为未受保护。
- en: Controller classes
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器类
- en: 'We have two controller classes, `SecuredController` and `NonSecuredController`.
    As the name suggests, one is for declared secured routes and the other for unsecured
    routes. The `main` method in the secured controller that we are interested is
    shown in the following code snippet:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个控制器类，`SecuredController`和`NonSecuredController`。正如其名所示，一个是用于声明受保护路由的，另一个是用于未受保护路由的。我们感兴趣的受保护控制器中的`main`方法如下代码片段所示：
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We copied the `model` class used in the resource server project into the client
    application project as well. In an ideal scenario, all this common stuff would
    be converted into reusable JARs and set up as a dependency to both the projects.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将资源服务器项目中使用的`model`类复制到了客户端应用项目中。在理想情况下，所有这些通用内容都应该转换为可重用的JAR文件，并作为依赖项设置到两个项目中。
- en: Templates
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: The templates are quite straightforward. The root context of the application
    redirects the user to an unsecured page. We have our own custom login page and
    after a successful login, the user is navigated to a secured page containing a
    link to the secured OAuth-backed movie listing API.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 模板非常简单。应用的根上下文将用户重定向到一个未受保护页面。我们有自己的自定义登录页面，登录成功后，用户将被导航到一个包含受保护OAuth电影列表API链接的受保护页面。
- en: Application properties
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用属性
- en: 'In this project, we are using `application.yml` files and the code is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们使用`application.yml`文件，代码如下：
- en: '[PRE29]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The very important aspect of this YML file is the `movie-app-client` properties
    setup. Again, being a Spring Boot project, it can be run by executing the `mvn
    spring-boot:run` command.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YML文件非常重要的方面是`movie-app-client`属性的设置。再次强调，作为一个Spring Boot项目，可以通过执行`mvn spring-boot:run`命令来运行。
- en: Running the project
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行项目
- en: 'Start all the projects individually using the Spring Boot `mvn spring-boot:run` command.
    I am using Spring Dashboard in IntelliJ, where I can launch all the projects,
    as shown in the following screenshot:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Boot的`mvn spring-boot:run`命令逐个启动所有项目。我在IntelliJ中使用Spring Dashboard，可以启动所有项目，如下面的截图所示：
- en: '![](img/f21f02f6-d40c-4e79-a32c-324886db5c03.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f21f02f6-d40c-4e79-a32c-324886db5c03.png)'
- en: 'Figure 12: Spring Dashboard in IntelliJ'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：IntelliJ中的Spring Dashboard
- en: 'Navigate to `http://localhost:8080` and you will be redirected to the unsecured
    page of the client application, as shown here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:8080`，您将被重定向到客户端应用的未受保护页面，如下所示：
- en: '![](img/d35a94e3-cbdb-4023-9afd-1e6a48b46cfc.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d35a94e3-cbdb-4023-9afd-1e6a48b46cfc.png)'
- en: 'Figure 13: Unsecured page of client app'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：客户端应用的未受保护页面
- en: 'Click on the link, and you will be taken to the custom login page, as shown
    here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接，您将被带到自定义登录页面，如下所示：
- en: '![](img/88846da5-d718-452c-9193-ea3637bd0b20.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/88846da5-d718-452c-9193-ea3637bd0b20.png)'
- en: 'Figure 14: Custom login page of client app'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：客户端应用的自定义登录页面
- en: 'Enter the username/password as required on the page; then, clicking on Log
    In will take you to the secured page, as shown here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上按要求输入用户名/密码；然后，点击登录将带您到受保护页面，如下所示：
- en: '![](img/e0fe14e3-c9f7-45a3-8341-763f88434956.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e0fe14e3-c9f7-45a3-8341-763f88434956.png)'
- en: 'Figure 15: Secured page in client app'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：客户端应用的受保护页面
- en: 'Click on the movie API link, and you will be taken to the OAuth flow and then
    to the authorization server default login page to enter credentials, as shown
    here:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 点击电影API链接，您将被带到OAuth流程，然后到授权服务器默认登录页面输入凭据，如下所示：
- en: '![](img/6dea5c50-4ea6-4b8e-9507-b3105e8ac5e3.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/6dea5c50-4ea6-4b8e-9507-b3105e8ac5e3.png)'
- en: 'Figure 16: Authorization server login page'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图16：授权服务器登录页面
- en: 'Enter the username/password (we have kept that as user/password) and click
    on the Login button. You will be taken to the authorization page, as shown in
    the following screenshot:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 输入用户名/密码（我们将其保留为user/password）并点击登录按钮。您将被带到授权页面，如下面的截图所示：
- en: '![](img/c0889860-4aef-44de-bb61-3bd099664046.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/c0889860-4aef-44de-bb61-3bd099664046.png)'
- en: 'Figure 17: Authorization page on authorization server'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图17：授权服务器上的授权页面
- en: 'Click on Authorize and you will be taken back to the client application page,
    which displays all the movies from the resource server, as shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 点击授权，您将被带回到客户端应用页面，该页面显示资源服务器中的所有电影，如下所示：
- en: '![](img/68d63f0a-c1a8-460b-8739-1fa9ae252fbd.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68d63f0a-c1a8-460b-8739-1fa9ae252fbd.png)'
- en: 'Figure 18: Movie listing page in the client app displaying a movie API exposed
    on resource server'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图18：客户端应用中显示在资源服务器上公开的电影API的电影列表页面
- en: With this, we have completed our sample application, in which we have implemented
    all the roles that are part of OAuth.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经完成了我们的示例应用，其中我们实现了OAuth的所有角色。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by introducing you to some of the important concepts
    that are needed to follow along with it. We then covered the important characteristics
    needed in a modern web application. We quickly covered an architecture called
    **SOFEA**, which aptly covers how we would like to build modern applications.
    We then got our hands dirty by implementing security for REST APIs in the simplest
    of ways.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以向您介绍一些需要跟随本章内容的重要概念开始本章。然后，我们涵盖了现代Web应用所需的重要特性。我们迅速介绍了一个名为**SOFEA**的架构，它恰当地涵盖了我们会如何构建现代应用。然后，我们通过以最简单的方式实现REST
    API的安全性来亲自动手。
- en: In the following section, we covered how we can secure a REST API in a more
    advanced fashion employing OAuth, using a JWT. We started this section by introducing
    many concepts in regards to OAuth and finally concluded the chapter with a full-fledged
    sample project that uses OAuth and JWT.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们介绍了如何使用OAuth和JWT以更高级的方式保护REST API。我们通过介绍许多关于OAuth的概念开始这一节，并最终以一个使用OAuth和JWT的完整示例项目结束本章。
- en: After reading this chapter, you should have a clear understanding of REST, OAuth,
    and JWT. You should also be comfortable with using Spring Security in the next
    chapter, to secure the RESTful endpoints exposed in your application.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你应该对REST、OAuth和JWT有一个清晰的理解。你也应该对在下一章中使用Spring Security来保护你应用中公开的RESTful端点感到舒适。
