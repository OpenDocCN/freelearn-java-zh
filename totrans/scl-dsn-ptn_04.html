<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Abstract and Self Types</h1>
                </header>
            
            <article>
                
<p class="mce-root">Designing and writing high-quality code in software engineering is important in order to have applications that are easy to extend and maintain. This activity requires the domain to be well-known, correctly understood by a developer, and the requirements for the application to be well-defined. If any of these are absent, then writing good programs becomes quite challenging.</p>
<p>Often, engineers model the <em>world</em> using some abstractions. This helps with code extendibility and maintainability and removes duplication, which in many cases could be a reason for bugs. Good code, generally, will consist of multiple small components, that depend on and interact with each other. There are different approaches that help to achieve abstraction and interaction. We will look into the following topics in this chapter:</p>
<ul>
<li>Abstract types</li>
<li>Polymorphism</li>
<li>Self types</li>
</ul>
<p>The topics that we will cover here will be really useful when we start looking into some of the concrete design patterns. Learning about them will also help to understand the design patterns that rely on them. Moreover, the concepts covered in this chapter are useful just by themselves for writing good code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Abstract types</h1>
                </header>
            
            <article>
                
<p>One of the most common ways to parameterize classes is by using values. This is quite simple, and it is achieved by passing different values for the constructor parameters of a class. In the following example, we can pass different values for the <kbd>name</kbd> parameter of the <kbd>Person</kbd> class, and this is how we create different instances:</p>
<pre>case class Person(name: String)</pre>
<p>This way, we can create different instances and distinguish them, but this is neither interesting nor rocket science. Going further, we will focus on some more interesting parameterizations that will help us improve our code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generics</h1>
                </header>
            
            <article>
                
<p>Generics are another way of parameterizing classes. They are useful when we write a functionality whose application is the same throughout various types, and we can simply defer choosing a concrete type until later. One example every developer should be familiar with is collection classes. <kbd>List</kbd>, for example, can store any type of data, and we can have lists of integers, doubles, strings, custom classes, and so on. Still, the list implementation is always the same.</p>
<p>We can also parameterize methods. For example, if we want to implement addition, it will not change between different numerical data types. Hence, we can use generics and just write our method once instead of overloading and trying to accommodate every single type in the world.</p>
<p>Let's look at some examples:</p>
<pre>trait Adder {<br/>  def sum[T](a: T, b: T)(implicit numeric: Numeric[T]): T = <br/>   numeric.plus(a, b)<br/>}</pre>
<p>The preceding code is a bit more involved and it defines a method called <kbd>sum</kbd>, which can be used with all numeric types. This is actually a representation of <strong>ad hoc polymorphism</strong>, which we will talk about later in this chapter.</p>
<p>The following code shows how to parameterize a class to contain any kind of data:</p>
<pre>class Container[T](data: T) {<br/>  def compare(other: T) = data.equals(other)<br/>}</pre>
<p>The following snippet shows some example uses:</p>
<pre>object GenericsExamples extends Adder {<br/>  def main(args: Array[String]): Unit = {<br/>    System.out.println(s"1 + 3 = ${sum(1, 3)}")<br/>    System.out.println(s"1.2 + 6.7 = ${sum(1.2, 6.7)}")<br/>    // System.out.println(s"abc + cde = ${sum("abc", "cde")}") // compilation fails<br/><br/>    val intContainer = new Container(10)<br/>    System.out.println(s"Comparing with int: ${intContainer.compare(11)}")<br/>    <br/>    val stringContainer = new Container("some text")<br/>    System.out.println(s"Comparing with string:<br/>     ${stringContainer.compare("some text")}")<br/>  }<br/>}</pre>
<p>The output of this program will be as follows:</p>
<pre>1 + 3 = 4<br/>1.2 + 6.7 = 7.9<br/>Comparing with int: false<br/>Comparing with string: true</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Abstract types</h1>
                </header>
            
            <article>
                
<p>Another way to parameterize classes is by using abstract types. Generics have their counterparts in other languages such as Java. Unlike them, however, abstract types do not exist in Java. Let's see how our preceding <kbd>Container</kbd> example will translate into one with abstract types, rather than generics:</p>
<pre>trait ContainerAT {<br/>  type T<br/>  val data: T<br/>  <br/>  def compare(other: T) = data.equals(other)<br/>}</pre>
<p>We will use the trait in a class, as follows:</p>
<pre>class StringContainer(val data: String) extends ContainerAT {<br/>  override type T = String<br/>}</pre>
<p>After we've done this, we can have the same example as before:</p>
<pre>object AbstractTypesExamples {<br/>  def main(args: Array[String]): Unit = {<br/>    val stringContainer = new StringContainer("some text")<br/>    System.out.println(s"Comparing with string:<br/>     ${stringContainer.compare("some text")}")<br/>  }<br/>}</pre>
<p>The expected output is as follows:</p>
<pre>Comparing with string: true</pre>
<p>We could, of course, use it in a similar way to the generic example by creating an instance of the trait and specifying the parameters there. This means that generics and abstract types really give us the possibility of achieving the same thing in two different ways.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generics versus abstract types</h1>
                </header>
            
            <article>
                
<p>So, why are there both generics and abstract types in Scala? Are there any differences, and when should one be used over the other? We will try to give answers to these questions here.</p>
<p>Generics and abstract types can be interchangeable. We might have to do some extra work, but in the end, we could get what the abstract types provide using generics. Which one is chosen depends on different factors, some of which are personal preferences, such as whether someone is aiming for readability or a different kind of usage of the classes.</p>
<p>Let's have a look at an example and try to get an idea of when and how generics and abstract types are used. In this current example, we will talk about printers. Everyone knows that there are different types—paper printers, 3D printers, and so on. Each of these uses different materials to print with, for example toner, ink, or plastic, and they are used to print on different types of media such as paper or actually in the surrounding environment. We can represent something like this using an abstract type:</p>
<pre>abstract class PrintData<br/>abstract class PrintMaterial<br/>abstract class PrintMedia<br/>trait Printer {<br/>  type Data &lt;: PrintData<br/>  type Material &lt;: PrintMaterial<br/>  type Media &lt;: PrintMedia<br/>  def print(data: Data, material: Material, media: Media) =<br/>   s"Printing $data with $material material on $media media."<br/>}</pre>
<p>In order to call the <kbd>print</kbd> method, we need to have different media, types of data, and materials:</p>
<pre>case class Paper() extends PrintMedia<br/>case class Air() extends PrintMedia<br/>case class Text() extends PrintData<br/>case class Model() extends PrintData<br/>case class Toner() extends PrintMaterial<br/>case class Plastic() extends PrintMaterial</pre>
<p>Let's now make two concrete printer implementations, a laser and a 3D printer:</p>
<pre>class LaserPrinter extends Printer {<br/>  type Media = Paper<br/>  type Data = Text<br/>  type Material = Toner<br/>}<br/><br/>class ThreeDPrinter extends Printer {<br/>  type Media = Air<br/>  type Data = Model<br/>  type Material = Plastic<br/>}</pre>
<p>In the preceding code, we actually gave some specifications about the kind of data, media, and materials that these printers can be used with. This way, we can't ask our 3D printer to use toner to print something or our laser printer to print in the air. This is how we will use our printers:</p>
<pre>object PrinterExample {<br/>  def main(args: Array[String]): Unit = {<br/>    val laser = new LaserPrinter<br/>    val threeD = new ThreeDPrinter<br/><br/>    System.out.println(laser.print(Text(), Toner(), Paper()))<br/>    System.out.println(threeD.print(Model(), Plastic(), Air()))<br/>  }<br/>}</pre>
<p>The preceding code is really readable, and it allows us to specify concrete classes easily. It makes things easier to model. It is interesting to see how the preceding code would translate to generics:</p>
<pre>trait GenericPrinter[Data &lt;: PrintData, Material &lt;: PrintMaterial, Media &lt;: PrintMedia] {<br/>  def print(data: Data, material: Material, media: Media) =<br/>    s"Printing $data with $material material on $media media."<br/>}</pre>
<p>The trait is easily represented, and readability and logical correctness are not compromised here. However, we must represent concrete classes in this way:</p>
<pre>class GenericLaserPrinter[Data &lt;: Text, Material &lt;: Toner, Media &lt;: Paper] extends GenericPrinter[Data, Material, Media]<br/>class GenericThreeDPrinter[Data &lt;: Model, Material &lt;: Plastic, Media &lt;: Air] extends GenericPrinter[Data, Material, Media]</pre>
<p>This becomes quite long, and a developer could easily make a mistake. The following snippet shows how to create instances and use the classes:</p>
<pre>val genericLaser = new GenericLaserPrinter[Text, Toner, Paper]<br/>val genericThreeD = new GenericThreeDPrinter[Model, Plastic, Air]<br/>System.out.println(genericLaser.print(Text(), Toner(), Paper()))<br/>System.out.println(genericThreeD.print(Model(), Plastic(), Air()))</pre>
<p>Here, we can see that we must specify the types every time we create instances. Imagine if we have more than three generic types, some of which could be based on generics as well, for example collections. This could quickly get quite tedious and make the code look harder than it actually is.</p>
<p>On the other hand, using generics allows us to reuse <kbd>GenericPrinter</kbd> without explicitly subclassing it multiple times for each different printer representation. There is, however, the risk of making logical mistakes:</p>
<pre>class GenericPrinterImpl[Data &lt;: PrintData, Material &lt;: PrintMaterial, Media &lt;: PrintMedia] extends GenericPrinter[Data, Material, Media]</pre>
<p>If used as follows, there is a danger of making a mistake:</p>
<pre>val wrongPrinter = new GenericPrinterImpl[Model, Toner, Air]<br/>System.out.println(wrongPrinter.print(Model(), Toner(), Air()))</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Usage advice</h1>
                </header>
            
            <article>
                
<p>The previous examples show a relatively simple comparison between the use of generics and abstract types. Both are useful concepts; however, it is important to be aware of what exactly is being done in order to use the right one for the situation. Here are some tips that could help in making the right decision.</p>
<p><strong>Use generics:</strong></p>
<ul>
<li>If you need just type instantiation; a good example is the standard collection classes</li>
<li>If you are creating a family of types</li>
</ul>
<p><strong>Use abstract types:</strong></p>
<ul>
<li>If you want to allow people to mix in types using traits</li>
<li>If you need better readability in scenarios where both could be interchangeable</li>
<li>If you want to hide the type definition from the client code</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Polymorphism</h1>
                </header>
            
            <article>
                
<p>Polymorphism is something every developer who has done some object-oriented programming knows about.</p>
<div class="packt_infobox">Polymorphism helps us to write generic code that can be reused and applied to a variety of types.</div>
<p>It is important to know that there are different types of polymorphism out there, and we will be looking at them in this section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Subtype polymorphism</h1>
                </header>
            
            <article>
                
<p>This is the polymorphism every developer knows about, and it's related to overriding methods in concrete class implementations. Consider the following simple hierarchy:</p>
<pre>abstract class Item {<br/>  def pack: String<br/>}<br/><br/>class Fruit extends Item {<br/>  override def pack: String = "I'm a fruit and I'm packed in a bag."<br/>}<br/><br/>class Drink extends Item {<br/>  override def pack: String = "I'm a drink and I'm packed in a bottle."<br/>}</pre>
<p>Now, let's have a shopping basket of items and call <kbd>pack</kbd> for each of them:</p>
<pre>object SubtypePolymorphismExample {<br/>  def main(args: Array[String]): Unit = {<br/>    val shoppingBasket: List[Item] = List(<br/>      new Fruit,<br/>      new Drink<br/>    )<br/>    shoppingBasket.foreach(i =&gt; System.out.println(i.pack))<br/>  }<br/>}</pre>
<p>As you can see, here we can use the abstract type and just call the <kbd>pack</kbd> method without thinking about what exactly it is. Polymorphism will take care of printing the correct value. Our output will be as follows:</p>
<pre>I'm a fruit and I'm packed in a bag.<br/>I'm a drink and I'm packed in a bottle.</pre>
<div class="packt_tip">Subtype polymorphism is expressed using inheritance with the <kbd>extends</kbd> keyword.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Parametric polymorphism</h1>
                </header>
            
            <article>
                
<p>Parametric polymorphism in functional programming is what we showed in the previous section about generics. Generics are parametric polymorphism, and as we already saw, they allow us to define methods or data structures over any type, or a subset of a given type. Concrete types can then be specified at a later stage.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Ad hoc polymorphism</h1>
                </header>
            
            <article>
                
<p>Ad hoc polymorphism is similar to parametric polymorphism; however, in this case, the type of arguments is important, as the concrete implementation will depend on it. It is resolved at compile time, unlike subtype polymorphism, which is done during runtime. This is somewhat similar to function overloading.</p>
<p>We saw an example of it earlier in this chapter, where we created the <kbd>Adder</kbd> trait that can sum different types. Let's have another one but a bit more refined and step by step, and we will hopefully understand how things work. Our goal is to have a <kbd>sum</kbd> method that can add many different kinds of types:</p>
<pre>trait Adder[T] {<br/>  def sum(a: T, b: T): T<br/>}</pre>
<p>Next, we will create a Scala object that uses this <kbd>sum</kbd> method and exposes it to the outside world:</p>
<pre>object Adder {<br/>  def sum[T: Adder](a: T, b: T): T = implicitly[Adder[T]].sum(a, b)<br/>}</pre>
<p>What we saw in the preceding code is some syntactic sugar in Scala, and <kbd>implicitly</kbd> says that there exists an implicit conversion from the <kbd>T</kbd> type to <kbd>Adder[T]</kbd>. We can now write the following program:</p>
<pre>object AdhocPolymorphismExample {<br/>  import Adder._<br/>  def main(args: Array[String]): Unit = {<br/>    System.out.println(s"The sum of 1 + 2 is ${sum(1, 2)}")<br/>    System.out.println(s"The sum of abc + def is ${sum("abc", "def")}")<br/>  }<br/>}</pre>
<p>If we try to compile and run this, we will run into trouble and get the following errors:</p>
<pre>Error:(15, 51) could not find implicit value for evidence parameter of type com.ivan.nikolov.polymorphism.Adder[Int]<br/>  System.out.println(s"The sum of 1 + 2 is ${sum(1, 2)}")<br/>                                                 ^<br/><br/>Error:(16, 55) could not find implicit value for evidence parameter of type com.ivan.nikolov.polymorphism.Adder[String]<br/>  System.out.println(s"The sum of abc + def is ${sum("abc", "def")}")<br/>                                                      ^</pre>
<p>This indicates that our code does not know how to implicitly convert integers or strings to <kbd>Adder[Int]</kbd> or <kbd>Adder[String]</kbd>. What we have to do is define these conversions as well as tell our program what the <kbd>sum</kbd> method will do. Our <kbd>Adder</kbd> object will look like the following:</p>
<pre>object Adder {<br/>  def sum[T: Adder](a: T, b: T): T = implicitly[Adder[T]].sum(a, b)<br/><br/>  implicit val int2Adder: Adder[Int] = new Adder[Int] {<br/>    override def sum(a: Int, b: Int): Int = a + b<br/>  }<br/><br/>  // same implementation as above, but allowed when the trait has a single method<br/>  implicit val string2Adder: Adder[String] =<br/>    (a: String, b: String) =&gt; s"$a concatenated with $b"<br/>}</pre>
<p>If we compile and run our application now, we will get the following output:</p>
<pre>The sum of 1 + 2 is 3<br/>The sum of abc + def is abc concatenated with def</pre>
<p>Also, if you remember from the example at the beginning of the chapter, we were not able to use the <kbd>sum</kbd> method on strings. As you can see here, we can provide different implementations, and using it with anything is not a problem as long as we have defined a way to convert a type to <kbd>Adder</kbd>.</p>
<p>Ad hoc polymorphism allows us to extend our code without modifying the base classes. This is very useful if we are using external libraries, or if we simply are not able to change the original code for some reason. It is really powerful and is evaluated in compile time, which makes sure that our program will work as expected. Moreover, it allows us to provide function definitions for types that we have no access to (<kbd>Int</kbd> and <kbd>String</kbd>, in our case).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding functions for multiple types</h1>
                </header>
            
            <article>
                
<p>If we look back at the beginning of this chapter, where we made <kbd>Adder</kbd> work with numeric types, we will see that our last implementation of <kbd>Adder</kbd> would require us to define an operation separately for each different numeric type. Is there a way to achieve what we showed in the beginning of the chapter here as well? Yes, there is, and this is done as follows:</p>
<pre>implicit def numeric2Adder[T : Numeric]: Adder[T] = new Adder[T] {<br/>  override def sum(a: T, b: T): T = implicitly[Numeric[T]].plus(a, b)<br/>}</pre>
<p>We just defined another implicit conversion, and it will take care of the right things for us. Now, we can also write the following code:</p>
<pre>System.out.println(s"The sum of 1.2 + 6.5 is ${sum(1.2, 6.5)}")</pre>
<div class="packt_infobox">Ad hoc polymorphism is expressed using implicits to mixin behavior. It is the main building block for the <strong>type class design pattern</strong>, which we will look into later in this book.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Self types</h1>
                </header>
            
            <article>
                
<p>One of the features of good code is the separation of concerns. Developers should aim to make classes and their methods responsible for one and only one thing. This helps in testing, maintaining, and simply understanding code better. Remember—<em>simple is always better</em>.</p>
<p>However, it is inevitable that when writing real software, we will need instances of some classes within other ones in order to achieve certain functionalities. In other words, once our building blocks are nicely separated, they would have dependencies in order to perform their functionality. What we are talking about here really boils down to dependency injection. Self types provide a way to handle these dependencies in an elegant way. In this section, we will see how to use them and what they are good for.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using self types</h1>
                </header>
            
            <article>
                
<p>Self types allow us to easily separate code in our applications, and then require it from other places. Everything gets clearer with an example, so let's have a look at one. Let's assume that we want to be able to persist information into a database:</p>
<pre>trait Persister[T] {<br/>  def persist(data: T)<br/>}</pre>
<p>The <kbd>persist</kbd> method will do some transformations on the data and then insert it in our database. Of course, our code is well-written, so the database implementations are separated. We have the following for our database:</p>
<pre><span class="pl-k">import</span> <span class="pl-smi">scala.collection.</span><span class="pl-smi">mutable</span><br/><br/>trait Database[T] {<br/>  def save(data: T)<br/>}<br/><br/>trait MemoryDatabase[T] extends Database[T] {<br/>  val db: mutable.MutableList[T] = mutable.MutableList.empty<br/>  <br/>  override def save(data: T): Unit = {<br/>    System.out.println("Saving to in memory database.")<br/>    db.+=:(data)<br/>  }<br/>}<br/><br/>trait FileDatabase[T] extends Database[T] {<br/>  override def save(data: T): Unit = {<br/>    System.out.println("Saving to file.")<br/>  }<br/>}</pre>
<p>We have a base trait and then some concrete database implementations. So, how do we pass our database to <kbd>Persister</kbd>? It should be able to call the <kbd>save</kbd> method defined in the database. Our possibilities include the following:</p>
<ul>
<li>Extend <kbd>Database</kbd> in <kbd>Persister</kbd>. This would, however, also make <kbd>Persister</kbd> an instance of <kbd>Database</kbd>, and we don't want this. We will show why later.</li>
<li>Have a variable for <kbd>Database</kbd> in <kbd>Persister</kbd> and use it.</li>
<li>Use self types.</li>
</ul>
<p>We are trying to see how self types work here, so let's use this approach. Our <kbd>Persister</kbd> interface will change to the following:</p>
<pre>trait Persister[T] {<br/>  this: Database[T] =&gt;<br/>  def persist(data: T): Unit = {<br/>    System.out.println("Calling persist.")<br/>    save(data)<br/>  }<br/>}</pre>
<p>Now, we have access to the methods in <kbd>Database</kbd> and can call the <kbd>save</kbd> method inside <kbd>Persister</kbd>.</p>
<div class="packt_tip"><strong>Naming the self type<br/>
<br/></strong> In the preceding code, we included our self type using the statement—<kbd>this: Database[T] =&gt;</kbd>. This allows us to access the methods of our included types directly as if they were methods of the trait that includes them. Another way of doing the same here is by writing <kbd>self: Database[T] =&gt;</kbd> instead. There are many examples out there that use the latter approach, which is useful to avoid confusion if we need to refer to <kbd>this</kbd> in some nested trait or class definitions. Calling the methods of the injected dependencies using this approach, however, would require the developer to use <kbd>self.</kbd> in order to gain access to the required methods.</div>
<p>The self type requires any class that mixes <kbd>Persister</kbd> in, to also mix <kbd>Database</kbd> in. Otherwise, our compilation will fail. Let's create classes to persist to memory and database:</p>
<pre>class FilePersister[T] extends Persister[T] with FileDatabase[T]<br/>class MemoryPersister[T] extends Persister[T] with MemoryDatabase[T]</pre>
<p>Finally, we can use them in our application:</p>
<pre>object PersisterExample {<br/>  def main(args: Array[String]): Unit = {<br/>    val fileStringPersister = new FilePersister[String]<br/>    val memoryIntPersister = new MemoryPersister[Int]<br/><br/>    fileStringPersister.persist("Something")<br/>    fileStringPersister.persist("Something else")<br/><br/>    memoryIntPersister.persist(100)<br/>    memoryIntPersister.persist(123)<br/>  }<br/>}</pre>
<p>Here is the output of our program:</p>
<pre>Calling persist.<br/>Saving to file.<br/>Calling persist.<br/>Saving to file.<br/>Calling persist.<br/>Saving to in memory database.<br/>Calling persist.<br/>Saving to in memory database.</pre>
<p>What self types do is different from inheritance. They require the presence of some code, and thus allow us to split a functionality nicely. This can make a huge difference in maintaining, refactoring, and understanding a program.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Requiring multiple components</h1>
                </header>
            
            <article>
                
<p>In real applications, we might require more than one component using a self type. Let's show this in our example with a <kbd>History</kbd> trait that could potentially keep track of changes to roll back at some point. Ours will just do printing:</p>
<pre>trait History {<br/>  def add(): Unit = {<br/>    System.out.println("Action added to history.")<br/>  }<br/>}</pre>
<p>We need to use this in our <kbd>Persister</kbd> trait, and it will look like this:</p>
<pre>trait Persister[T] {<br/>  this: Database[T] with History =&gt;<br/>  def persist(data: T): Unit = {<br/>    System.out.println("Calling persist.")<br/>    save(data)<br/>    add()<br/>  }<br/>}</pre>
<p>Using the <kbd>with</kbd> keyword, we can add as many requirements as we like. However, if we just leave our code changes there, it will not compile. The reason for this is that we must now mix <kbd>History</kbd> in every class that uses <kbd>Persister</kbd>:</p>
<pre>class FilePersister[T] extends Persister[T] with FileDatabase[T] with History<br/>class MemoryPersister[T] extends Persister[T] with MemoryDatabase[T] with History</pre>
<p>That's it. If we now run our code, we will see this:</p>
<pre>Calling persist.<br/>Saving to file.<br/>Action added to history.<br/>Calling persist.<br/>Saving to file.<br/>Action added to history.<br/>Calling persist.<br/>Saving to in memory database.<br/>Action added to history.<br/>Calling persist.<br/>Saving to in memory database.<br/>Action added to history.</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Conflicting components</h1>
                </header>
            
            <article>
                
<p>In the preceding example, we had a requirement for the <kbd>History</kbd> trait, which has an <kbd>add()</kbd> method. What would happen if the methods in different components have the same signatures and they clash? Let's try this:</p>
<pre>trait Mystery {<br/>  def add(): Unit = {<br/>    System.out.println("Mystery added!")<br/>  }<br/>}</pre>
<p>We can now use this in our <kbd>Persister</kbd> trait:</p>
<pre>trait Persister[T] {<br/>  this: Database[T] with History with Mystery =&gt;<br/>  def persist(data: T): Unit = {<br/>    System.out.println("Calling persist.")<br/>    save(data)<br/>    add()<br/>  }<br/>}</pre>
<p>Of course, we will change all the classes that mix <kbd>Persister</kbd> in:</p>
<pre>class FilePersister[T] extends Persister[T] with FileDatabase[T] with History with Mystery<br/>class MemoryPersister[T] extends Persister[T] with MemoryDatabase[T] with History with Mystery</pre>
<p>If we try to compile our application, we will see that it results in a failure with the following messages:</p>
<pre>Error:(47, 7) class FilePersister inherits conflicting members:<br/>  method add in trait History of type ()Unit and<br/>  method add in trait Mystery of type ()Unit<br/>(Note: this can be resolved by declaring an override in class FilePersister.)<br/>class FilePersister[T] extends Persister[T] with FileDatabase[T] with History with Mystery<br/>      ^<br/><br/>Error:(48, 7) class MemoryPersister inherits conflicting members:<br/>  method add in trait History of type ()Unit and<br/>  method add in trait Mystery of type ()Unit<br/>(Note: this can be resolved by declaring an override in class MemoryPersister.)<br/>class MemoryPersister[T] extends Persister[T] with MemoryDatabase[T] with History with Mystery<br/>      ^</pre>
<p>Luckily, the error messages also contain information that tells us how we can fix the problem. This is absolutely the same case that we saw earlier while using traits, and we can provide the following fix:</p>
<pre>class FilePersister[T] extends Persister[T] with FileDatabase[T] with History with Mystery {<br/>  override def add(): Unit ={<br/>    super[History].add()<br/>  }<br/>}<br/><br/>class MemoryPersister[T] extends Persister[T] with MemoryDatabase[T] with History with Mystery {<br/>  override def add(): Unit ={<br/>    super[Mystery].add()<br/>  }<br/>}</pre>
<p>After running the example, we will see the following output:</p>
<pre>Calling persist.<br/>Saving to file.<br/>Action added to history.<br/>Calling persist.<br/>Saving to file.<br/>Action added to history.<br/>Calling persist.<br/>Saving to in memory database.<br/>Mystery added!<br/>Calling persist.<br/>Saving to in memory database.<br/>Mystery added!</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Self types and the cake design pattern</h1>
                </header>
            
            <article>
                
<p>What we saw in our preceding examples was a pure example of dependency injection. We required one component to be available in another one through self types.</p>
<div class="packt_infobox">Self types are often used for dependency injection. They are the main part of the <strong>cake design pattern</strong>, which we will become familiar with later in this book.</div>
<p>The cake design pattern relies completely on self types. It encourages engineers to write small and simple components, which declare and use their dependencies. After all the components in an application are programmed, they can be instantiated inside a common component registry and made available to the actual application. One of the nice advantages of the cake design pattern is that it actually checks during compile time whether all the dependencies would be satisfied. We will dedicate a complete section on the cake design pattern later in this book, where we will provide more details about how the pattern can actually be wired up, what advantages and drawbacks it has, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Self types versus inheritance</h1>
                </header>
            
            <article>
                
<p>In the previous section, we said that we don't want to use inheritance in order to get access to the <kbd>Database</kbd> methods. Why is that? If we had made <kbd>Persister</kbd> extend <kbd>Database</kbd>, this would mean that it would become a database itself (<em>is-a</em> relationship). However, this is not correct. It uses a database in order to achieve its functionality.</p>
<p>Inheritance exposes a subclass to the implementation details of its parent. This, however, is not always desired. According to the authors of <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, developers should favor object composition over class inheritance.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inheritance leaking functionality</h1>
                </header>
            
            <article>
                
<p>If we use inheritance, we would also leak functionality to subclasses that we do not want. Let's look at the following code:</p>
<pre>trait DB {<br/>  def connect(): Unit = {<br/>    System.out.println("Connected.")<br/>  }<br/><br/>  def dropDatabase(): Unit = {<br/>    System.out.println("Dropping!")<br/>  }<br/><br/>  def close(): Unit = {<br/>    System.out.println("Closed.")<br/>  }<br/>}<br/><br/>trait UserDB extends DB {<br/>  def createUser(username: String): Unit = {<br/>    connect()<br/>    try {<br/>      System.out.println(s"Creating a user: $username")<br/>    } finally {<br/>      close()<br/>    }<br/>  }<br/><br/>  def getUser(username: String): Unit = {<br/>    connect()<br/>    try {<br/>      System.out.println(s"Getting a user: $username")<br/>    } finally {<br/>      close()<br/>    }<br/>  }<br/>}<br/><br/>trait UserService extends UserDB {<br/>  def bad(): Unit = {<br/>    dropDatabase()<br/>  }<br/>}</pre>
<p>This could be a real-life scenario. Because this is how inheritance works, we would get access to <kbd>dropDatabase</kbd> in <kbd>UserService</kbd>. This is something we do not want, and we can fix it using self types. The DB trait stays the same. Everything else changes to the following:</p>
<pre>trait UserDB {<br/>  this: DB =&gt;<br/>  <br/>  def createUser(username: String): Unit = {<br/>    connect()<br/>    try {<br/>      System.out.println(s"Creating a user: $username")<br/>    } finally {<br/>      close()<br/>    }<br/>  }<br/><br/>  def getUser(username: String): Unit = {<br/>    connect()<br/>    try {<br/>      System.out.println(s"Getting a user: $username")<br/>    } finally {<br/>      close()<br/>    }<br/>  }<br/>}<br/><br/>trait UserService {<br/>  this: UserDB =&gt;<br/>  <br/>  // does not compile<br/>  // def bad(): Unit = {<br/>  // dropDatabase()<br/>  //}<br/>}</pre>
<p>As the comments in the code show, in this last version of the code, we do not have access to the <kbd>DB</kbd> trait methods. We can only call the methods of the type we require, and this is exactly what we wanted to achieve.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we familiarized ourselves with some concepts that help us to write better, more generic, and extendible software. We focused on abstract types, polymorphism, and self types in Scala.</p>
<p>We looked into the differences between generics and abstract type values in classes, along with some examples and usage advice. Then, we introduced the different types of polymorphism—subtype, parametric, and ad hoc. Finally, we went through self types in Scala and how to use them. We showed that self types provide a good way to encapsulate functionality and write modular code.</p>
<p>In the following chapter, we will look into the importance of separating the responsibilities of software components. We will also go through aspect-oriented programming.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  </body></html>