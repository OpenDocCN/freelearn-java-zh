<html><head></head><body>
  <div id="_idContainer188" class="Basic-Text-Frame">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-289" class="chapterTitle">Java I/O: Context-Specific Deserialization Filters</h1>
    <p class="normal">This chapter includes 13 problems related to Java serialization/deserialization processes. We start with classical problems like serializing/deserializing objects to <code class="inlineCode">byte[]</code>, <code class="inlineCode">String</code>, and XML. We continue with JDK 9 deserialization filters meant to prevent deserialization vulnerabilities, and we finish with JDK 17 (JEP 415, final) context-specific deserialization filters.</p>
    <p class="normal">At the end of this chapter, you’ll be skilled in solving almost any problem related to serializing/deserializing objects in Java.</p>
    <h1 id="_idParaDest-290" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your programming prowess on Java serialization/deserialization. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="131"><strong class="keyWord">Serializing objects to byte arrays</strong>: Write a Java application that exposes two helper methods for serializing/deserializing objects to/from <code class="inlineCode">byte[]</code>.</li>
      <li class="numberedList"><strong class="keyWord">Serializing objects to strings</strong>: Write a Java application that exposes two helper methods for serializing/deserializing objects to/from <code class="inlineCode">String</code>.</li>
      <li class="numberedList"><strong class="keyWord">Serializing objects to XML</strong>: Exemplify at least two approaches for serializing/deserializing objects to/from XML format.</li>
      <li class="numberedList"><strong class="keyWord">Introducing JDK 9 deserialization filters</strong>: Provide a brief introduction to JDK 9 deserialization filters including some insights into the <code class="inlineCode">ObjectInputFilter</code> API.</li>
      <li class="numberedList"><strong class="keyWord">Implementing a custom pattern-based ObjectInputFilter</strong>: Provide an example of implementing and setting a custom pattern-based filter via the <code class="inlineCode">ObjectInputFilter</code> API.</li>
      <li class="numberedList"><strong class="keyWord">Implementing a custom class ObjectInputFilter</strong>: Exemplify the creation of an <code class="inlineCode">ObjectInputFilter</code> via a class implementation. </li>
      <li class="numberedList"><strong class="keyWord">Implementing a custom method ObjectInputFilter</strong>: Exemplify the creation of an <code class="inlineCode">ObjectInputFilter</code> via a method implementation. </li>
      <li class="numberedList"><strong class="keyWord">Implementing a custom lambda ObjectInputFilter</strong>: Exemplify the creation of an <code class="inlineCode">ObjectInputFilter</code> via a lambda expression.</li>
      <li class="numberedList"><strong class="keyWord">Avoiding StackOverflowError at deserialization</strong>: First, write a snippet of code that can be successfully serialized but, in the deserialization phase, causes a <code class="inlineCode">StackOverflowError</code>. Second, write a filter that avoids this unpleasant scenario.</li>
      <li class="numberedList"><strong class="keyWord">Avoiding DoS attacks at deserialization</strong>: First, write a snippet of code that can be successfully serialized but, in the deserialization phase, causes a DoS attack. Second, write a filter that avoids this unpleasant scenario.</li>
      <li class="numberedList"><strong class="keyWord">Introducing JDK 17 easy filter creation</strong>: Explain and exemplify the usage of the JDK 17 <code class="inlineCode">allowFilter()</code> and <code class="inlineCode">rejectFilter()</code> methods.</li>
      <li class="numberedList"><strong class="keyWord">Tackling context-specific deserialization filters</strong>: Explain and exemplify the usage of JDK 17 Filter Factories.</li>
      <li class="numberedList"><strong class="keyWord">Monitoring deserialization via JFR</strong>: Exemplify the usage of <strong class="keyWord">Java Flight Recorder</strong> (<strong class="keyWord">JFR</strong>) for monitoring a deserialization event.</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter06"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter06</span></a>.</p>
    <h1 id="_idParaDest-291" class="heading-1">131. Serializing objects to byte arrays</h1>
    <p class="normal">In <em class="italic">Chapter 4</em>, <em class="italic">Problem 94</em>, we talked<a id="_idIndexMarker706"/> about the serialization/deserialization<a id="_idIndexMarker707"/> of Java records, so you should be pretty familiar with these operations. In a nutshell, serialization is the process of transforming an in-memory object into a stream of bytes that can also be stored in memory or written to a file, network, database, external storage, and so on. Deserialization is the reverse process, that is, recreating the object state in memory from the given stream of bytes.</p>
    <p class="normal">A Java object is serializable if its class implements <code class="inlineCode">java.io.Serializable</code> (or, <code class="inlineCode">java.io.Externalizable</code>). Accomplishing serialization/deserialization takes place via the <code class="inlineCode">java.io.ObjectOutputStream</code> and <code class="inlineCode">java.io.ObjectInputStream</code> classes and <code class="inlineCode">writeObject()</code>/<code class="inlineCode">readObject()</code> methods.</p>
    <p class="normal">For instance, let’s assume the following <code class="inlineCode">Melon</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Melon</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> weight;
  <span class="hljs-comment">// constructor, getters</span>
}
</code></pre>
    <p class="normal">And, an instance of <code class="inlineCode">Melon</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Melon</span>(<span class="hljs-string">"Gac"</span>, <span class="hljs-number">2500</span>);
</code></pre>
    <p class="normal">Serializing the <code class="inlineCode">melon</code> instance into a byte array can be accomplished as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] objectToBytes(Serializable obj) 
       <span class="hljs-keyword">throws</span> IOException { 
        
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> 
           <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ByteArrayOutputStream</span>();
        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">ois</span> 
           <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectOutputStream</span>(baos)) {
    ois.writeObject(obj);
            
    <span class="hljs-keyword">return</span> baos.toByteArray();
  } 
}
</code></pre>
    <p class="normal">Of course, we can use<a id="_idIndexMarker708"/> this helper to serialize any other object, but for the <code class="inlineCode">melon</code> instance,<a id="_idIndexMarker709"/> we call it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">byte</span>[] melonSer = Converters.objectToBytes(melon); 
</code></pre>
    <p class="normal">Deserialization is done via another helper that uses <code class="inlineCode">readObject()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">bytesToObject</span><span class="hljs-params">(</span><span class="hljs-type">byte</span><span class="hljs-params">[] bytes)</span>
       <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException {
  <span class="hljs-keyword">try</span> ( <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ByteArrayInputStream</span>(bytes);
        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectInputStream</span>(is)) {
     <span class="hljs-keyword">return</span> ois.readObject();
  }
}
</code></pre>
    <p class="normal">We can use this helper to deserialize any other object from a byte array, but for the <code class="inlineCode">melonSer</code>, we call it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melonDeser</span> <span class="hljs-operator">=</span> (Melon) Converters.bytesToObject(melonSer);
</code></pre>
    <p class="normal">The returned <code class="inlineCode">melonDeser</code> restores<a id="_idIndexMarker710"/> the initial object state even if it is not the same<a id="_idIndexMarker711"/> instance. In the bundled code, you can also see an approach based on Apache Commons Lang.</p>
    <h1 id="_idParaDest-292" class="heading-1">132. Serializing objects to strings</h1>
    <p class="normal">In the previous problem, you<a id="_idIndexMarker712"/> saw how to serialize<a id="_idIndexMarker713"/> objects to byte arrays. If we work a little bit on a byte array, we can obtain a string representation of serialization. For instance, we can rely on <code class="inlineCode">java.util.Base64</code> to encode a byte array to <code class="inlineCode">String</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public static</span> String <span class="hljs-title">objectToString</span>(Serializable obj) <span class="hljs-keyword">throws</span> IOException {       
    
    <span class="hljs-keyword">try</span> ( <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> = <span class="hljs-keyword">new</span> <span class="hljs-title">ByteArrayOutputStream</span>();
          <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">ois</span> = <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectOutputStream</span>(baos)) {
        ois.writeObject(obj);
        
        <span class="hljs-keyword">return</span> Base64.getEncoder().encodeToString(baos.toByteArray());
    }                
}
</code></pre>
    <p class="normal">A possible output looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">rO0ABXNyABZtb2Rlcm4uY2hhbGxlbmdlLk1lbG9u2WrnGA2MxZ4CAAJGAAZ3ZWlnaHRMAAR0eXBldAAST GphdmEvbGFuZy9TdHJpbmc7eHBFHEAAdAADR2Fj
</code></pre>
    <p class="normal">And, the code to obtain such a String is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">melonSer</span> = Converters.objectToString(melon);
</code></pre>
    <p class="normal">The reverse process relies on the <code class="inlineCode">Base64</code> decoder as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">stringToObject</span><span class="hljs-params">(String obj)</span> 
              <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException {
 <span class="hljs-type">byte</span>[] data = Base64.getDecoder().decode(obj);
 <span class="hljs-keyword">try</span> ( <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectInputStream</span>(
       <span class="hljs-keyword">new</span> <span class="hljs-title">ByteArrayInputStream</span>(data))) {
  <span class="hljs-keyword">return</span> ois.readObject();
 }
}
</code></pre>
    <p class="normal">Calling this method is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melonDeser</span> <span class="hljs-operator">=</span> (Melon)  
      Converters.stringToObject(melonSer);
</code></pre>
    <p class="normal">The <code class="inlineCode">melonDeser</code> object<a id="_idIndexMarker714"/> is the result of deserializing<a id="_idIndexMarker715"/> the previous string.</p>
    <h1 id="_idParaDest-293" class="heading-1">133. Serializing objects to XML</h1>
    <p class="normal">Serializing/deserializing objects<a id="_idIndexMarker716"/> to XML via<a id="_idIndexMarker717"/> the JDK API can be accomplished via <code class="inlineCode">java.beans.XMLEncoder</code>, respectively <code class="inlineCode">XMLDecoder</code>. The <code class="inlineCode">XMLEncoder</code> API relies on Java Reflection to discover the object’s fields and write them in XML format. This class can encode<a id="_idIndexMarker718"/> objects that respect the Java Beans contract (<a href="https://docs.oracle.com/javase/tutorial/javabeans/writing/index.html"><span class="url">https://docs.oracle.com/javase/tutorial/javabeans/writing/index.html</span></a>). Basically, the object’s class should contain a public no-arguments constructor and public getters and setters for <code class="inlineCode">private</code>/<code class="inlineCode">protected</code> fields/properties. Implementing <code class="inlineCode">Serializable</code> is not mandatory for <code class="inlineCode">XMLEncoder</code>/<code class="inlineCode">XMLDecoder</code>, so we can serialize/deserialize objects that don’t implement <code class="inlineCode">Serializable</code>. Here, it is a helper method that encodes the given <code class="inlineCode">Object</code> to XML:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">objectToXML</span><span class="hljs-params">(Object obj)</span> 
              <span class="hljs-keyword">throws</span> IOException {
 <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ByteArrayOutputStream</span>();
 <span class="hljs-keyword">try</span> ( <span class="hljs-type">XMLEncoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">XMLEncoder</span>(
                  <span class="hljs-keyword">new</span> <span class="hljs-title">BufferedOutputStream</span>(baos))) {
  encoder.writeObject(obj);
 }
 baos.close();
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">String</span>(baos.toByteArray());
}
</code></pre>
    <p class="normal">The reverse process (deserialization) uses the <code class="inlineCode">XMLDecoder</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">XMLToObject</span><span class="hljs-params">(String xml)</span> 
              <span class="hljs-keyword">throws</span> IOException {
 <span class="hljs-keyword">try</span> ( <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> 
    <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ByteArrayInputStream</span>(xml.getBytes());  
  <span class="hljs-type">XMLDecoder</span> <span class="hljs-variable">decoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">XMLDecoder</span>(is)) {
  <span class="hljs-keyword">return</span> decoder.readObject();
 }
}
</code></pre>
    <p class="normal">The <code class="inlineCode">XMLEncoder</code>/<code class="inlineCode">XMLDecoder</code> is much more flexible than the <code class="inlineCode">writeObject()</code>/<code class="inlineCode">readObject()</code> API. For instance, if a field/property is added/removed/renamed or its type has changed, then the decoding process skips everything it cannot decode and tries to decode as much as possible without throwing an exception.</p>
    <p class="normal">Another common approach<a id="_idIndexMarker719"/> relies on the third-party<a id="_idIndexMarker720"/> library Jackson 2.x, which comes with <code class="inlineCode">XmlMapper</code>. This library should be added as a dependency (of course, if you don’t have it already present in your project):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">dependency</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">groupId</span><span class="hljs-tag">&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/</span><span class="hljs-name">groupId</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">artifactId</span><span class="hljs-tag">&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/</span><span class="hljs-name">artifactId</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">version</span><span class="hljs-tag">&gt;</span>2.x<span class="hljs-tag">&lt;/</span><span class="hljs-name">version</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">dependency</span><span class="hljs-tag">&gt;</span>
</code></pre>
    <p class="normal">Next, we create an instance of <code class="inlineCode">XmlMapper</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">XmlMapper</span> <span class="hljs-variable">xmlMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">XmlMapper</span>();
</code></pre>
    <p class="normal">Via <code class="inlineCode">XmlMapper</code>, we can serialize objects as XML as follows (there is no problem if the object’s class doesn’t implement <code class="inlineCode">Serializable</code> and/or it doesn’t contain setters):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">objectToXMLJackson</span><span class="hljs-params">(Object obj)</span> 
              <span class="hljs-keyword">throws</span> JsonProcessingException {
 <span class="hljs-type">XmlMapper</span> <span class="hljs-variable">xmlMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">XmlMapper</span>();
 <span class="hljs-keyword">if</span> (xmlMapper.canSerialize(obj.getClass())) {
  <span class="hljs-keyword">return</span> xmlMapper.writeValueAsString(obj);
 }
 <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
}
</code></pre>
    <p class="normal">Calling this method can be done as follows (<code class="inlineCode">melon</code> is an instance of the <code class="inlineCode">Melon</code> class):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">melonSer</span> <span class="hljs-operator">=</span> Converters.objectToXMLJackson(melon);
</code></pre>
    <p class="normal">The reverse process can rely on <code class="inlineCode">readValue()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title">XMLToObjectJackson</span><span class="hljs-params">(</span>
<span class="hljs-params">       String xml, Class&lt;T&gt; clazz)</span>
              <span class="hljs-keyword">throws</span> JsonProcessingException {
 <span class="hljs-type">XmlMapper</span> <span class="hljs-variable">xmlMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">XmlMapper</span>();
 <span class="hljs-keyword">return</span> xmlMapper.readValue(xml, clazz);
}
</code></pre>
    <p class="normal">Calling this method can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melonDeser</span> <span class="hljs-operator">=</span> Converters
  .XMLToObjectJackson(melonSer, Melon.class);
</code></pre>
    <p class="normal">Take your time to explore the <code class="inlineCode">XmlMapper</code> API since it has a lot more to offer. For now, consider running the bundled code to see the XML produced by each of these two approaches.</p>
    <p class="normal">If you plan to serialize/deserialize<a id="_idIndexMarker721"/> an object to<a id="_idIndexMarker722"/> JSON, then consider <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Problem 141</em>, for a comprehensive set of examples based on JSONB, Jackson, and Gson.</p>
    <h1 id="_idParaDest-294" class="heading-1">134. Introducing JDK 9 deserialization filters</h1>
    <p class="normal">As you know from <em class="italic">Chapter 4</em>, <em class="italic">Problem 94</em>, deserialization<a id="_idIndexMarker723"/> is exposed to vulnerabilities that may cause serious security issues. In other words, between serialization–deserialization cycles, an untrusted process (attacker) can modify/alter the serialization form to execute arbitrary code, sneak in malicious data, and so on.</p>
    <p class="normal">In order to prevent such vulnerabilities, JDK 9 has introduced the possibility of creating restrictions via filters meant to accept/reject deserialization based on specific predicates. A deserialization filter intercepts a stream that expects to be deserialized and applies to it one or more predicates that should be successfully passed in order to proceed with deserialization. If a predicate fails, then deserialization doesn’t even start and the stream is rejected.</p>
    <p class="normal">There are two kinds of filters:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">JVM-wide filters</strong>: Filters applied to every deserialization<a id="_idIndexMarker724"/> that takes place in the JVM. The behavior of these filters is tightly coupled with how they are combined with other filters (if any).</li>
      <li class="bulletList"><strong class="keyWord">Stream filters</strong>: Filters that operate<a id="_idIndexMarker725"/> on all <code class="inlineCode">ObjectInputStream</code> instances of an application (<em class="italic">stream-global filters</em>) or on certain <code class="inlineCode">ObjectInputStream</code> instances (<em class="italic">stream-specific filters</em>).</li>
    </ul>
    <p class="normal">We can create the following types of filters:</p>
    <ul>
      <li class="bulletList">Filters based on patterns (known as <em class="italic">pattern-based filters</em>): These filters can be<a id="_idIndexMarker726"/> used to filter modules, packages, or classes via string patterns. They can be applied without touching the code (as JVM-wide filters) or they can be created via the <code class="inlineCode">ObjectInputFilter</code> API (as <em class="italic">pattern-based stream filters</em>).</li>
      <li class="bulletList">Filters based on the <code class="inlineCode">ObjectInputFilter</code> API: This API allows us to define filters directly in code. Usually, such filters are defined based on string patterns or Java Reflection.</li>
    </ul>
    <h2 id="_idParaDest-295" class="heading-2">Pattern-based filters</h2>
    <p class="normal">Let’s see several filters based<a id="_idIndexMarker727"/> on string patterns. For instance, this filter accepts all classes from the <code class="inlineCode">foo</code> package (and from any other package that is not <code class="inlineCode">buzz</code>) and rejects all classes from the <code class="inlineCode">buzz</code> package (a class that passes a pattern that starts with <code class="inlineCode">!</code> is rejected):</p>
    <pre class="programlisting code"><code class="hljs-code">foo.*;!buzz.*
</code></pre>
    <p class="normal">Patterns are delimited via semicolons (<code class="inlineCode">;</code>) and white spaces are considered as part of the pattern. </p>
    <p class="normal">The following filter rejects only the <code class="inlineCode">modern.challenge.Melon</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">!modern.challenge.Melon
</code></pre>
    <p class="normal">The following filter rejects the <code class="inlineCode">Melon</code> class from the <code class="inlineCode">modern.challenge</code> package and accepts all other classes from this package (the <code class="inlineCode">*</code> is the wildcard used to represent unspecified class/package/module names):</p>
    <pre class="programlisting code"><code class="hljs-code">!modern.challenge.Melon;modern.challenge.*;!*
</code></pre>
    <p class="normal">The following filter accepts all classes from the <code class="inlineCode">foo</code> package and its sub-packages (notice the <code class="inlineCode">**</code> wildcard):</p>
    <pre class="programlisting code"><code class="hljs-code">foo.**
</code></pre>
    <p class="normal">The following filter accepts all classes starting with <code class="inlineCode">Hash</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Hash*
</code></pre>
    <p class="normal">Besides filtering classes, packages, and modules, we can also define the so-called <em class="italic">resource filters</em>, which allow us<a id="_idIndexMarker728"/> to accept/reject resources based on an object’s graph complexity and size. In this context, we have <code class="inlineCode">maxdepth</code> (the maximum graph depth), <code class="inlineCode">maxarray</code> (the maximum array size), <code class="inlineCode">maxrefs</code> (the maximum number of references between objects of a graph), and <code class="inlineCode">maxbytes</code> (the maximum number of stream bytes). Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">maxdepth=<span class="hljs-number">5</span>;maxarray=<span class="hljs-number">1000</span>;maxrefs=<span class="hljs-number">50</span> foo.buzz.App
</code></pre>
    <p class="normal">Now, let’s see how we can use such filters.</p>
    <h3 id="_idParaDest-296" class="heading-3">Applying a pattern-based filter per application</h3>
    <p class="normal">If we want to apply a <em class="italic">pattern-based filter</em> to a single run<a id="_idIndexMarker729"/> of an application, then we can rely on the <code class="inlineCode">jdk.serialFilter</code> system property. Without touching the code, we use this system property at the command line as in the following example:</p>
    <pre class="programlisting con"><code class="hljs-con">java -Djdk.serialFilter=foo.**;Hash* foo.buzz.App
</code></pre>
    <p class="normal">A system property replaces a Security Property value.</p>
    <h3 id="_idParaDest-297" class="heading-3">Applying a pattern-based filter to all applications in a process</h3>
    <p class="normal">To apply a <em class="italic">pattern-based filter</em> to all applications<a id="_idIndexMarker730"/> in a process, we should follow two steps (again, we don’t touch the application code):</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In an editor (for instance, Notepad or Wordpad), open the <code class="inlineCode">java.security</code> file. In JDK 6-8, this file is located in <code class="inlineCode">$JAVA_HOME/lib/security/java.security</code>, while in JDK 9+, it is in <code class="inlineCode">$JAVA_HOME/conf/security/java.security</code>.</li>
      <li class="numberedList">Edit this file by appending the pattern to the <code class="inlineCode">jdk.serialFilter</code> Security Property.</li>
    </ol>
    <p class="normal">Done!</p>
    <h2 id="_idParaDest-298" class="heading-2">ObjectInputFilter-based filters</h2>
    <p class="normal">Via the <code class="inlineCode">ObjectInputFilter</code> API, we can create<a id="_idIndexMarker731"/> custom filters based on string patterns and Java Reflection. These filters can be applied to certain streams (<em class="italic">stream-specific filters</em>) or to all streams (<em class="italic">stream-global filters</em>) and can be implemented as <em class="italic">pattern-based filters</em>, as classes, methods, or lambda expressions. </p>
    <p class="normal">First, we implement the filter via the <code class="inlineCode">ObjectInputFilter</code> API. Second, we set the filter on all/certain <code class="inlineCode">ObjectInputStream</code> instances. Setting the filter as a <em class="italic">stream-global filter</em> is done via <code class="inlineCode">ObjectInputFilter.Config.setSerialFilter(ObjectInputFilter filter)</code>. On the other hand, setting the filter as a <em class="italic">stream-specific filter</em> can be done via <code class="inlineCode">ObjectInputStream.setObjectInputFilter(ObjectInputFilter filter)</code>.</p>
    <p class="normal">For instance, creating a <em class="italic">pattern-based filter </em>via this API can be done by calling the <code class="inlineCode">Config.createFilter(String pattern)</code> method.</p>
    <p class="normal">A custom filter defined as a class is done by implementing the <code class="inlineCode">ObjectInputFilter</code> functional interface and overriding the <code class="inlineCode">Status checkInput(FilterInfo filterInfo)</code> method.</p>
    <p class="normal">A custom filter defined as a method is commonly done via a static method as <code class="inlineCode">static ObjectInputFilter.Status someFilter(FilterInfo info) {…}</code>.</p>
    <p class="normal">And, a custom filter defined as a lambda expression is commonly expressed as <code class="inlineCode">ois.setObjectInputFilter(f -&gt; (…))</code>, where <code class="inlineCode">f</code> is <code class="inlineCode">ObjectInputFilter</code> and <code class="inlineCode">ois</code> is an instance of <code class="inlineCode">ObjectInputStream</code>.</p>
    <p class="normal">A filter returns<a id="_idIndexMarker732"/> a <em class="italic">status</em> (<code class="inlineCode">java.io.ObjectInputFilter.Status</code>), which can be <code class="inlineCode">ALLOWED</code>, <code class="inlineCode">REJECTED</code>, or <code class="inlineCode">UNDECIDED</code>.</p>
    <p class="normal">In the next problems, we will explore these statements via examples.</p>
    <h1 id="_idParaDest-299" class="heading-1">135. Implementing a custom pattern-based ObjectInputFilter</h1>
    <p class="normal">Let’s assume that we<a id="_idIndexMarker733"/> already have the <code class="inlineCode">Melon</code> class and the helper methods for serializing/deserializing objects to/from byte arrays from <em class="italic">Problem 131</em>.</p>
    <p class="normal">Creating a <em class="italic">pattern-based filter </em>via the <code class="inlineCode">ObjectInputFilter</code> API can be done by calling the <code class="inlineCode">Config.createFilter(String pattern)</code> method. For instance, the following filter rejects the <code class="inlineCode">modern.challenge.Melon</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">melonFilter</span> <span class="hljs-operator">=</span> ObjectInputFilter.Config
  .createFilter(<span class="hljs-string">"!modern.challenge.Melon;"</span>);
</code></pre>
    <p class="normal">We can set this filter as a <em class="italic">stream-global filter</em> via <code class="inlineCode">setSerialFilter()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">ObjectInputFilter.Config.setSerialFilter(melonFilter);
</code></pre>
    <p class="normal">If we need to get access to a <em class="italic">stream-global filter</em>, then we can call <code class="inlineCode">getSerialFilter()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">serialFilter</span> <span class="hljs-operator">=</span> 
  ObjectInputFilter.Config.getSerialFilter();
</code></pre>
    <p class="normal">Any stream deserialization in this application will pass through this filter, which will reject any instance of <code class="inlineCode">modern.challenge.Melon</code>. You can practice this filter in the bundled code.</p>
    <p class="normal">On the other hand, if we want to set this on a specific stream, then we can modify our <code class="inlineCode">Converters.bytesToObject()</code> method to accept a filter as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">bytesToObject</span><span class="hljs-params">(</span><span class="hljs-type">byte</span><span class="hljs-params">[] bytes, </span>
<span class="hljs-params">              ObjectInputFilter filter)</span>
                <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException {
 <span class="hljs-keyword">try</span> ( <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ByteArrayInputStream</span>(bytes);
       <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> = <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectInputStream</span>(is)) {
  <span class="hljs-comment">// set the filter            </span>
  ois.setObjectInputFilter(filter);
  <span class="hljs-keyword">return</span> ois.readObject();
  }
}
</code></pre>
    <p class="normal">If we pass <code class="inlineCode">null</code> as <code class="inlineCode">filter</code>, then the filter will not be applied. Otherwise, the passed filter will be applied to the current stream:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Melon</span>(<span class="hljs-string">"</span><span class="hljs-string">Gac"</span>, <span class="hljs-number">2500</span>);
<span class="hljs-comment">// serialization works as usual</span>
<span class="hljs-type">byte</span>[] melonSer = Converters.objectToBytes(melon);
<span class="hljs-comment">// here, we pass the melonFilter, which rejects the instances </span>
<span class="hljs-comment">// of modern.challenge.Melon, so deserialization is rejected</span>
<span class="hljs-type">Melon</span> <span class="hljs-variable">melonDeser</span> <span class="hljs-operator">=</span> (Melon) Converters.bytesToObject(
      melonSer, melonFilter);
</code></pre>
    <p class="normal">In this example, the <code class="inlineCode">melonFilter</code> will reject deserialization and the output will be as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.io.InvalidClassException: filter status: REJECTED
…
</code></pre>
    <p class="normal">You can also practice this filter<a id="_idIndexMarker734"/> in the bundled code.</p>
    <h1 id="_idParaDest-300" class="heading-1">136. Implementing a custom class ObjectInputFilter</h1>
    <p class="normal">Let’s assume that we already<a id="_idIndexMarker735"/> have the <code class="inlineCode">Melon</code> class and the helper methods for serializing/deserializing objects to/from byte arrays from <em class="italic">Problem 131</em>.</p>
    <p class="normal">An <code class="inlineCode">ObjectInputFilter</code> can be written via a dedicated class by implementing the <code class="inlineCode">ObjectInputFilter</code> functional interface as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MelonFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ObjectInputFilter</span> {
 <span class="hljs-meta">@Override</span>
 <span class="hljs-keyword">public</span> Status <span class="hljs-title">checkInput</span><span class="hljs-params">(FilterInfo filterInfo)</span> {
 Class&lt;?&gt; clazz = filterInfo.serialClass();
 <span class="hljs-keyword">if</span> (clazz != <span class="hljs-literal">null</span>) {
  <span class="hljs-comment">// or, clazz.getName().equals("modern.challenge.Melon")</span>
  <span class="hljs-keyword">return</span> 
   !(clazz.getPackage().getName().equals(<span class="hljs-string">"modern.challenge"</span>)
     &amp;&amp; clazz.getSimpleName().equals(<span class="hljs-string">"Melon"</span>))
     ? Status.ALLOWED : Status.REJECTED;
 }
 <span class="hljs-keyword">return</span> Status.UNDECIDED;
 }
}
</code></pre>
    <p class="normal">This filter is exactly the same as the <em class="italic">pattern-based filter</em>, <code class="inlineCode">!modern.challenge.Melon</code>, only that it is expressed via Java Reflection.</p>
    <p class="normal">We can set this filter as a <em class="italic">stream-global filter</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">ObjectInputFilter.Config.setSerialFilter(<span class="hljs-keyword">new</span> <span class="hljs-title">MelonFilter</span>());
</code></pre>
    <p class="normal">Or, as a <em class="italic">stream-specific filter</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melonDeser</span> <span class="hljs-operator">=</span> (Melon) Converters.bytesToObject(
  melonSer, <span class="hljs-keyword">new</span> <span class="hljs-title">MelonFilter</span>());
</code></pre>
    <p class="normal">Of course, the <code class="inlineCode">bytesToObject()</code> accepts an argument of type <code class="inlineCode">ObjectInputFilter</code> and sets this filter accordingly (<code class="inlineCode">ois</code> is the specific <code class="inlineCode">ObjectInputStream</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">ois.setObjectInputFilter(filter);
</code></pre>
    <p class="normal">In this example, the <code class="inlineCode">MelonFilter</code> will reject deserialization<a id="_idIndexMarker736"/> and the output will be as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.io.InvalidClassException: filter status: REJECTED
…
</code></pre>
    <p class="normal">You can practice both approaches (<em class="italic">stream-global</em> and <em class="italic">stream-specific</em>) in the bundled code.</p>
    <h1 id="_idParaDest-301" class="heading-1">137. Implementing a custom method ObjectInputFilter</h1>
    <p class="normal">Let’s assume that we already <a id="_idIndexMarker737"/>have the <code class="inlineCode">Melon</code> class and the helper methods for serializing/deserializing objects to/from byte arrays from <em class="italic">Problem 131</em>.</p>
    <p class="normal">An <code class="inlineCode">ObjectInputFilter</code> can be written via a dedicated method as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Filters</span> {
 <span class="hljs-keyword">private</span> <span class="hljs-title">Filters</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AssertionError</span>(<span class="hljs-string">"Cannot be instantiated"</span>);
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectInputFilter.Status <span class="hljs-title">melonFilter</span>(
               FilterInfo info) {
  Class&lt;?&gt; clazz = info.serialClass();
  <span class="hljs-keyword">if</span> (clazz != <span class="hljs-literal">null</span>) {
   <span class="hljs-comment">// or, clazz.getName().equals("modern.challenge.Melon")</span>
   <span class="hljs-keyword">return</span> 
    !(clazz.getPackage().getName().equals(<span class="hljs-string">"modern.challenge"</span>)
      &amp;&amp; clazz.getSimpleName().equals(<span class="hljs-string">"Melon"</span>))
      ? Status.ALLOWED :Status.REJECTED;
  }
  <span class="hljs-keyword">return</span> Status.UNDECIDED;
 }
}
</code></pre>
    <p class="normal">Of course, you can add more filters in this class.</p>
    <p class="normal">We can set this filter as a <em class="italic">stream-global filter</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">ObjectInputFilter.Config
                 .setSerialFilter(Filters::melonFilter);
</code></pre>
    <p class="normal">Or, as a <em class="italic">stream-specific filter</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melonDeser</span> <span class="hljs-operator">=</span> (Melon) Converters.bytesToObject(
  melonSer, Filters::melonFilter);
</code></pre>
    <p class="normal">Of course, the <code class="inlineCode">bytesToObject()</code> accepts an argument of type <code class="inlineCode">ObjectInputFilter</code> and sets this filter accordingly (<code class="inlineCode">ois</code> is the specific <code class="inlineCode">ObjectInputStream</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">ois.setObjectInputFilter(filter);
</code></pre>
    <p class="normal">In this example, the <code class="inlineCode">Filters::melonFilter</code> will reject deserialization and the output will be as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.io.InvalidClassException: filter status: REJECTED
…
</code></pre>
    <p class="normal">You can check out both<a id="_idIndexMarker738"/> approaches (<em class="italic">stream-global</em> and <em class="italic">stream-specific</em>) in the bundled code. Moreover, you can also practice another example that rejects all instances of <code class="inlineCode">Melon</code> and its subclasses based on a <em class="italic">stream-global filter</em>.</p>
    <h1 id="_idParaDest-302" class="heading-1">138. Implementing a custom lambda ObjectInputFilter</h1>
    <p class="normal">Let’s assume that we already<a id="_idIndexMarker739"/> have the <code class="inlineCode">Melon</code> class and the helper methods for serializing/deserializing objects to/from byte arrays from <em class="italic">Problem 131</em>.</p>
    <p class="normal">An <code class="inlineCode">ObjectInputFilter</code> can be written via a dedicated lambda and set as a <em class="italic">stream-global filter</em> as follows: </p>
    <pre class="programlisting code"><code class="hljs-code">ObjectInputFilter.Config
  .setSerialFilter(f -&gt; ((f.serialClass() != <span class="hljs-literal">null</span>)
  <span class="hljs-comment">// or, filter.serialClass().getName().equals(</span>
  <span class="hljs-comment">//     "modern.challenge.Melon")</span>
  &amp;&amp; f.serialClass().getPackage()
                   .getName().equals(<span class="hljs-string">"modern.challenge"</span>)
  &amp;&amp; f.serialClass().getSimpleName().equals(<span class="hljs-string">"Melon"</span>))
  ? Status.REJECTED : Status.UNDECIDED);
</code></pre>
    <p class="normal">Or, as a <em class="italic">stream-specific filter</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melonDeser</span> <span class="hljs-operator">=</span> (Melon) Converters.bytesToObject(melonSer, 
  f -&gt; ((f.serialClass() != <span class="hljs-literal">null</span>)
   <span class="hljs-comment">// or, filter.serialClass().getName().equals(</span>
   <span class="hljs-comment">//       "modern.challenge.Melon")</span>
  &amp;&amp; f.serialClass().getPackage()
                   .getName().equals(<span class="hljs-string">"modern.challenge"</span>)
  &amp;&amp; f.serialClass().getSimpleName().equals(<span class="hljs-string">"Melon"</span>))
  ? Status.REJECTED : Status.UNDECIDED); 
</code></pre>
    <p class="normal">You can practice these examples in the bundled code.</p>
    <h1 id="_idParaDest-303" class="heading-1">139. Avoiding StackOverflowError at deserialization</h1>
    <p class="normal">Let’s consider the<a id="_idIndexMarker740"/> following snippet<a id="_idIndexMarker741"/> of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 'mapOfSets' is the object to serialize/deserialize</span>
HashMap&lt;Set, Integer&gt; mapOfSets = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
Set&lt;Set&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title">HashSet</span>&lt;&gt;();
mapOfSets.put(set, <span class="hljs-number">1</span>);
set.add(set);
</code></pre>
    <p class="normal">We plan to serialize the <code class="inlineCode">mapOfSets</code> object as follows (I assume that <code class="inlineCode">Converters.objectToBytes()</code> is well-known from the previous problems):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">byte</span>[] mapSer = Converters.objectToBytes(mapOfSets);  
</code></pre>
    <p class="normal">Everything works just fine until we try to deserialize <code class="inlineCode">mapSer</code>. At that moment, instead of a valid object, we will get a <code class="inlineCode">StackOverflowError</code> as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.lang.StackOverflowError
  at java.base/java.util.HashMap$KeyIterator
    .&lt;init&gt;(HashMap.java:1626)
  at java.base/java.util.HashMap$KeySet
    .iterator(HashMap.java:991)
  at java.base/java.util.HashSet
    .iterator(HashSet.java:182)
  at java.base/java.util.AbstractSet
    .hashCode(AbstractSet.java:120)
  at java.base/java.util.AbstractSet
    .hashCode(AbstractSet.java:124)
  ...
</code></pre>
    <p class="normal">The deserialization process got stuck in the <code class="inlineCode">hashCode()</code> method of <code class="inlineCode">Set</code>. The solution is to create a filter that will reject deserialization if the object has a graph depth bigger than 2. This can be a <em class="italic">pattern-based filter</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> ObjectInputFilter.Config
  .createFilter(<span class="hljs-string">"maxdepth=2;java.base/*;!*"</span>);
</code></pre>
    <p class="normal">Next, call the deserialization process with this filter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HashMap</span> <span class="hljs-variable">mapDeser</span> <span class="hljs-operator">=</span> (HashMap) Converters
  .bytesToObject(mapSer, filter);        
</code></pre>
    <p class="normal">I assume that <code class="inlineCode">Converters.bytesToObject()</code> is well-known<a id="_idIndexMarker742"/> from the previous<a id="_idIndexMarker743"/> problems. This time, instead of getting <code class="inlineCode">StackOverflowError</code>, the deserialization is rejected by the filter. </p>
    <h1 id="_idParaDest-304" class="heading-1">140. Avoiding DoS attacks at deserialization</h1>
    <p class="normal"><strong class="keyWord">Denial-of-service</strong> (<strong class="keyWord">DoS</strong>) attacks are typically<a id="_idIndexMarker744"/> malicious actions meant<a id="_idIndexMarker745"/> to trigger, in a short period of time, a lot of requests to a server, application, and so on. Generally speaking, a DoS attack is any kind of action that intentionally/accidentally overwhelms a process and forces it to slow down or even crash. Let’s see a snippet of code that is a good candidate for representing a DoS attack in the deserialization phase:</p>
    <pre class="programlisting code"><code class="hljs-code">ArrayList&lt;Object&gt; startList = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
List&lt;Object&gt; list1 = startList;
List&lt;Object&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">101</span>; i++) {
  List&lt;Object&gt; sublist1 = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  List&lt;Object&gt; sublist2 = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  sublist1.add(<span class="hljs-string">"value: "</span> + i);
  list1.add(sublist1);
  list1.add(sublist2);
  list2.add(sublist1);
  list2.add(sublist2);
  list1 = sublist1;
  list2 = sublist2;
}
</code></pre>
    <p class="normal">We plan to serialize the <code class="inlineCode">startList</code> object as follows (I assume that <code class="inlineCode">Converters.objectToBytes()</code> is well-known from the previous problems):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">byte</span>[] startListSer = Converters.objectToBytes(startList); 
</code></pre>
    <p class="normal">Everything works just fine until we try to deserialize <code class="inlineCode">startListSer</code>. At that moment, instead of a valid object, we will get…nothing! Actually, the application starts normally, but it just hangs there in the deserialization phase. The system slows down and, after a while, it will eventually crash.</p>
    <p class="normal">The object graph is too deep to be deserialized and that leads to a behavior similar to a DoS attack. The solution is to create a filter that will reject deserialization if the object has a graph depth bigger than a safe value. This can be a <em class="italic">pattern-based filter</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> ObjectInputFilter.Config
  .createFilter(<span class="hljs-string">"maxdepth=10;java.base/*;!*"</span>);
</code></pre>
    <p class="normal">Next, call the deserialization process with this filter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">startListDeser</span> <span class="hljs-operator">=</span> (ArrayList) 
  Converters.bytesToObject(startListSer, filter);
</code></pre>
    <p class="normal">I assume that <code class="inlineCode">Converters.bytesToObject()</code> is well-known<a id="_idIndexMarker746"/> from the previous<a id="_idIndexMarker747"/> problems. This time, the deserialization is rejected by the filter and the DoS attack is prevented. </p>
    <h1 id="_idParaDest-305" class="heading-1">141. Introducing JDK 17 easy filter creation</h1>
    <p class="normal">Starting with JDK 17, we can express filters<a id="_idIndexMarker748"/> more intuitively and readably via two convenient methods named <code class="inlineCode">allowFilter()</code> and <code class="inlineCode">rejectFilter()</code>. And, since the best way to learn is with an example, here is a usage case of these two convenient methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Filters</span> {
 <span class="hljs-keyword">private</span> <span class="hljs-title">Filters</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AssertionError</span>(<span class="hljs-string">"Cannot be instantiated"</span>);
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectInputFilter <span class="hljs-title">allowMelonFilter</span><span class="hljs-params">()</span> {
  <span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> ObjectInputFilter.allowFilter( 
   clazz -&gt; Melon.class.isAssignableFrom(clazz),
           ObjectInputFilter.Status.REJECTED);
   <span class="hljs-keyword">return</span> filter;
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectInputFilter <span class="hljs-title">rejectMuskmelonFilter</span><span class="hljs-params">()</span> {
  <span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> ObjectInputFilter.rejectFilter( 
   clazz -&gt; Muskmelon.class.isAssignableFrom(clazz),
           ObjectInputFilter.Status.UNDECIDED);
   <span class="hljs-keyword">return</span> filter;
  }
}
</code></pre>
    <p class="normal">The <code class="inlineCode">allowMelonFilter()</code> relies on <code class="inlineCode">ObjectInputFilter.allowFilter()</code> to allow only objects that are instances of <code class="inlineCode">Melon</code> or subclasses of <code class="inlineCode">Melon</code>. The <code class="inlineCode">rejectMuskmelonFilter()</code> relies on <code class="inlineCode">ObjectInputFilter.rejectFilter()</code> to reject all objects that are instances of <code class="inlineCode">Muskmelon</code> or subclasses of <code class="inlineCode">Muskmelon</code>.</p>
    <p class="normal">We can use each of these filters as you already know from the previous problems, so let’s tackle another use case. Let’s assume that we have the following hierarchy of classes:</p>
    <figure class="mediaobject"><img src="../Images/B19665_06_01.png" alt="Figure 6.1.png"/></figure>
    <p class="packt_figref">Figure 6.1: An arbitrary hierarchy of classes</p>
    <p class="normal">Let’s assume that we want to deserialize<a id="_idIndexMarker749"/> only objects that are instances of <code class="inlineCode">Melon</code> or subclasses of <code class="inlineCode">Melon</code> but they are not <code class="inlineCode">Muskmelon</code> or subclasses of <code class="inlineCode">Muskmelon</code>. In other words, we allow deserializing instances of <code class="inlineCode">Melon</code> and <code class="inlineCode">Cantaloupe</code>.</p>
    <p class="normal">If we apply the <code class="inlineCode">allowMelonFilter()</code>, then we will deserialize instances of <code class="inlineCode">Melon</code>, <code class="inlineCode">Muskmelon</code>, <code class="inlineCode">Cantaloupe</code>, <code class="inlineCode">HoneyDew</code>, and <code class="inlineCode">Persian</code> since all these are <code class="inlineCode">Melon</code>.</p>
    <p class="normal">On the other hand, if we apply <code class="inlineCode">rejectMuskmelonFilter()</code>, then we will deserialize instances of <code class="inlineCode">Melon</code>, <code class="inlineCode">Cantaloupe</code>, and <code class="inlineCode">Pumpkin</code> since these are not <code class="inlineCode">Muskmelon</code>. </p>
    <p class="normal">But, if we apply <code class="inlineCode">rejectMuskmelonFilter()</code> after applying <code class="inlineCode">allowMelonFilter()</code>, then we will deserialize only <code class="inlineCode">Melon</code> and <code class="inlineCode">Cantaloupe</code>, which is exactly what we want.</p>
    <p class="normal">Intuitively, we may think to chain our filters by writing something like this (<code class="inlineCode">ois</code> is the current <code class="inlineCode">ObjectInputStream</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">ois.setObjectInputFilter(Filters.allowMelonFilter());
ois.setObjectInputFilter(Filters.rejectMuskmelonFilter());
</code></pre>
    <p class="normal">But, this will not work! It will cause a <code class="inlineCode">java.lang.IllegalStateException</code>: <em class="italic">filter cannot be set more than once</em>.</p>
    <p class="normal">The solution relies on <code class="inlineCode">ObjectInputFilter.merge(filter, anotherFilter)</code>, which returns a filter that merges the status of these two filters by applying the following logic:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Call <code class="inlineCode">filter</code> and get the returned <code class="inlineCode">status</code></li>
      <li class="numberedList">If the returned <code class="inlineCode">status</code> is <code class="inlineCode">REJECTED</code>, then return it</li>
      <li class="numberedList">Call <code class="inlineCode">anotherFilter</code> and get the returned <code class="inlineCode">otherStatus</code></li>
      <li class="numberedList">If <code class="inlineCode">anotherStatus</code> is <code class="inlineCode">REJECTED</code>, then return it</li>
      <li class="numberedList">If either <code class="inlineCode">status</code> or <code class="inlineCode">otherStatus</code> is <code class="inlineCode">ALLOWED</code>, then return <code class="inlineCode">ALLOWED</code></li>
      <li class="numberedList">Otherwise, return <code class="inlineCode">UNDECIDED</code></li>
    </ol>
    <p class="normal">Nevertheless, if <code class="inlineCode">anotherFilter</code> is <code class="inlineCode">null</code>, the filter is returned. </p>
    <p class="normal">Based on this logic, we can merge the status of <code class="inlineCode">Filters.allowMelonFilter()</code> with<a id="_idIndexMarker750"/> the status of <code class="inlineCode">Filters.rejectMuskmelonFilter()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">bytesToObject</span><span class="hljs-params">(</span><span class="hljs-type">byte</span><span class="hljs-params">[] bytes, </span>
<span class="hljs-params">       ObjectInputFilter allowFilter, </span>
<span class="hljs-params">       ObjectInputFilter rejectFilter)</span>
       <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException {
 <span class="hljs-keyword">try</span> ( <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ByteArrayInputStream</span>(bytes);  
       <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectInputStream</span>(is)) {
  <span class="hljs-comment">// set the filters</span>
  <span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">filters</span> <span class="hljs-operator">=</span> ObjectInputFilter.merge(
    allowFilter, rejectFilter);
  ois.setObjectInputFilter(filters);
  <span class="hljs-keyword">return</span> ois.readObject();
 }
}
</code></pre>
    <p class="normal">Next, let’s talk about JDK 17 Filter Factories.</p>
    <h1 id="_idParaDest-306" class="heading-1">142. Tackling context-specific deserialization filters</h1>
    <p class="normal">JDK 17 enriched the deserialization<a id="_idIndexMarker751"/> filter capabilities with the implementation of JEP 415, <em class="italic">Context-Specific Deserialization Filters</em>.</p>
    <p class="normal">Practically, JDK 17 added the so-called Filter Factories. Depending on the context, a Filter Factory can dynamically decide what filters to use for a stream. </p>
    <h2 id="_idParaDest-307" class="heading-2">Applying a Filter Factory per application</h2>
    <p class="normal">If we want to apply a Filter Factory<a id="_idIndexMarker752"/> to a single run of an application, then we can rely on the <code class="inlineCode">jdk.serialFilterFactory</code> system property. Without touching the code, we use this system property at the command line as in the following example:</p>
    <pre class="programlisting con"><code class="hljs-con">java -Djdk.serialFilterFactory=FilterFactoryName YourApp
</code></pre>
    <p class="normal">The <code class="inlineCode">FilterFactoryName</code> is the fully qualified name of the Filter Factory, which is a public class that can be accessed by the application class loader, and it was set before the first deserialization.</p>
    <h2 id="_idParaDest-308" class="heading-2">Applying a Filter Factory to all applications in a process</h2>
    <p class="normal">To apply a Filter Factory to all applications<a id="_idIndexMarker753"/> in a process, we should follow two steps (again, we don’t touch the application code):</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In an editor (for instance, Notepad or Wordpad), open the <code class="inlineCode">java.security</code> file. In JDK 6-8, this file is located in <code class="inlineCode">$JAVA_HOME/lib/security/java.security</code>, while in JDK 9+, it is in <code class="inlineCode">$JAVA_HOME/conf/security/java.security</code>.</li>
      <li class="numberedList">Edit this file by appending the Filter Factory to the <code class="inlineCode">jdk.serialFilterFactory</code> Security Property.</li>
    </ol>
    <h2 id="_idParaDest-309" class="heading-2">Applying a Filter Factory via ObjectInputFilter.Config</h2>
    <p class="normal">Alternatively, a Filter Factory<a id="_idIndexMarker754"/> can be set directly in code via <code class="inlineCode">ObjectInputFilter.Config</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">ObjectInputFilter.Config
  .setSerialFilterFactory(FilterFactoryInstance);    
</code></pre>
    <p class="normal">The <code class="inlineCode">FilterFactoryInstance</code> argument is an instance of a Filter Factory. This Filter Factory will be applied to all streams from the current application.</p>
    <h2 id="_idParaDest-310" class="heading-2">Implementing a Filter Factory</h2>
    <p class="normal">A Filter Factory is implemented<a id="_idIndexMarker755"/> as a <code class="inlineCode">BinaryOperator&lt;ObjectInputFilter&gt;</code>. The <code class="inlineCode">apply(ObjectInputFilter current, ObjectInputFilter next)</code> method provides the <em class="italic">current filter</em> and the <em class="italic">next</em> or <em class="italic">requested filter</em>.</p>
    <p class="normal">In order to see how it works, let’s assume that we have the following three filters:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Filters</span> {
 <span class="hljs-keyword">private</span> <span class="hljs-title">Filters</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AssertionError</span>(<span class="hljs-string">"Cannot be instantiated"</span>);
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectInputFilter <span class="hljs-title">allowMelonFilter</span><span class="hljs-params">()</span> {
  <span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> ObjectInputFilter.allowFilter( 
   clazz -&gt; Melon.class.isAssignableFrom(clazz),
           ObjectInputFilter.Status.REJECTED);
   <span class="hljs-keyword">return</span> filter;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectInputFilter <span class="hljs-title">rejectMuskmelonFilter</span><span class="hljs-params">()</span> {
   <span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> ObjectInputFilter.rejectFilter( 
   clazz -&gt; Muskmelon.class.isAssignableFrom(clazz),
           ObjectInputFilter.Status.UNDECIDED);
   <span class="hljs-keyword">return</span> filter;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectInputFilter <span class="hljs-title">packageFilter</span><span class="hljs-params">()</span> {
   <span class="hljs-keyword">return</span> ObjectInputFilter.Config.createFilter(
          <span class="hljs-string">"modern.challenge.*;!*"</span>);
  }
}
</code></pre>
    <p class="normal">The <code class="inlineCode">Filters.allowMelonFilter()</code> is set as a <em class="italic">stream-global filter</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">ObjectInputFilter.Config.setSerialFilter(
  Filters.allowMelonFilter());
</code></pre>
    <p class="normal">The <code class="inlineCode">Filters.rejectMuskmelonFilter()</code> is set<a id="_idIndexMarker756"/> as a <em class="italic">stream-specific filter</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Melon</span>(<span class="hljs-string">"Melon"</span>, <span class="hljs-number">2400</span>);
<span class="hljs-comment">// serialization</span>
<span class="hljs-type">byte</span>[] melonSer = Converters.objectToBytes(melon);
<span class="hljs-comment">// deserialization</span>
<span class="hljs-type">Melon</span> <span class="hljs-variable">melonDeser</span> <span class="hljs-operator">=</span> (Melon) Converters.bytesToObject(
  melonSer, Filters.rejectMuskmelonFilter());
</code></pre>
    <p class="normal">And, the <code class="inlineCode">Filters.packageFilter()</code> is set in the Filter Factory as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MelonFilterFactory</span> <span class="hljs-keyword">implements</span>
       <span class="hljs-title">BinaryOperator</span>&lt;ObjectInputFilter&gt; {
 <span class="hljs-meta">@Override</span>
 <span class="hljs-keyword">public</span> ObjectInputFilter <span class="hljs-title">apply</span><span class="hljs-params">(</span>
<span class="hljs-params">        ObjectInputFilter current, ObjectInputFilter next)</span> {
  System.out.println();
  System.out.println(<span class="hljs-string">"Current filter: "</span> + current);
  System.out.println(<span class="hljs-string">"Requested filter: "</span> + next);
  <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span> &amp;&amp; next != <span class="hljs-literal">null</span>) { 
   <span class="hljs-keyword">return</span> ObjectInputFilter.merge(
          next, Filters.packageFilter());
  }
  <span class="hljs-keyword">return</span> ObjectInputFilter.merge(next, current);
 }
}
</code></pre>
    <p class="normal">The <code class="inlineCode">MelonFilterFactory</code> is set via <code class="inlineCode">ObjectInputFilter.Config</code> before any deserialization takes place:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MelonFilterFactory</span> <span class="hljs-variable">filterFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonFilterFactory</span>();
ObjectInputFilter.Config
                 .setSerialFilterFactory(filterFactory);     
</code></pre>
    <p class="normal">Now that everything is in place, let’s see what’s happening. The <code class="inlineCode">apply()</code> method is called twice. The first time it is called is when the <code class="inlineCode">ObjectInputStream ois</code> is created, and we obtain the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">Current filter: null
Requested filter: 
predicate(modern.challenge.Filters$$Lambda$4/0x000000080
1001800@ba8a1dc, ifTrue: ALLOWED,ifFalse: REJECTED)
</code></pre>
    <p class="normal">The <em class="italic">current filter</em> is <code class="inlineCode">null</code>, and the <em class="italic">requested filter </em>is <code class="inlineCode">Filters.allowMelonFilter()</code>. Since the <em class="italic">current filter</em> is <code class="inlineCode">null</code> and the <em class="italic">requested filter</em> is not <code class="inlineCode">null</code>, we decided to return a filter as the result of merging the status of the <em class="italic">requested filter</em> with the status of the <code class="inlineCode">Filters.packageFilter()</code>.</p>
    <p class="normal">The second time the <code class="inlineCode">apply()</code> method is called happens when the <code class="inlineCode">ois.setObjectInputFilter(filter)</code> is called in <code class="inlineCode">Converters.bytesToObject(byte[] bytes, ObjectInputFilter filter)</code>. We have the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">Current filter: merge(predicate(modern.challenge.Filters$$Lambda$4/0x0000000801001800@ba8a1dc, ifTrue: ALLOWED, ifFalse:REJECTED), modern.challenge.*;!*)
Requested filter: predicate(modern.challenge.Filters$$Lambda$10/0x0000000801002a10@484b61fc, ifTrue: REJECTED, ifFalse:UNDECIDED)
</code></pre>
    <p class="normal">This time, the <em class="italic">current</em> and <em class="italic">requested filters</em> are not <code class="inlineCode">null</code>, so we merge their statuses again. Finally, all filters are successfully<a id="_idIndexMarker757"/> passed and the deserialization takes place. </p>
    <h1 id="_idParaDest-311" class="heading-1">143. Monitoring deserialization via JFR</h1>
    <p class="normal"><strong class="keyWord">Java Flight Recorder</strong> (<strong class="keyWord">JFR</strong>) is an event-based tool for the diagnosis<a id="_idIndexMarker758"/> and profiling of<a id="_idIndexMarker759"/> Java applications. This tool was initially<a id="_idIndexMarker760"/> added in JDK 7 and, since then, it has been constantly improved. For instance, in JDK 14, JFR was enriched with event streaming, and in JDK 19, with filtering event capabilities, and so on. You can find all JFR events listed and documented per JDK version at <a href="https://sap.github.io/SapMachine/jfrevents/"><span class="url">https://sap.github.io/SapMachine/jfrevents/</span></a>.</p>
    <p class="normal">Among its rich list of events, JFR can monitor and record deserialization events (the deserialization event). Let’s assume a simple application like the one from <em class="italic">Problem 131</em> (the first problem of this chapter). We start configuring JFR for monitoring the deserialization of this application by adding <code class="inlineCode">deserializationEvent.jfc</code> into the root folder of the application:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">&lt;?xml version=</span><span class="hljs-string">"1.0"</span><span class="hljs-meta"> encoding=</span><span class="hljs-string">"UTF-8"</span><span class="hljs-meta">?&gt;</span>
<span class="hljs-tag">&lt;</span><span class="hljs-name">configuration</span><span class="hljs-tag"> </span><span class="hljs-attr">version</span><span class="hljs-tag">=</span><span class="hljs-string">"2.0"</span><span class="hljs-tag"> </span><span class="hljs-attr">description</span><span class="hljs-tag">=</span><span class="hljs-string">"test"</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;</span><span class="hljs-name">event</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"jdk.Deserialization"</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"enabled"</span><span class="hljs-tag">&gt;</span>true<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"stackTrace"</span><span class="hljs-tag">&gt;</span>false<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;/</span><span class="hljs-name">event</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">configuration</span><span class="hljs-tag">&gt;</span>
</code></pre>
    <p class="normal">Practically, this file instructs JFR to monitor and record the deserialization events.</p>
    <p class="normal">Next, we use <code class="inlineCode">-XX:StartFlightRecording=filename=recording.jfr</code> to instruct JFR to record output in a file named <code class="inlineCode">recording.jfr</code>, and we continue with <code class="inlineCode">settings=deserializationEvent.jfc</code> to point out the configuration file listed previously.</p>
    <p class="normal">So, the final command is the one from this figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_06_02.png" alt="Figure 6.2.png"/></figure>
    <p class="packt_figref">Figure 6.2: Running JFR</p>
    <p class="normal">After this command is executed, you’ll see an output as in <em class="italic">Figure 6.3</em>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_06_03.png" alt="Figure 6.3.png"/></figure>
    <p class="packt_figref">Figure 6.3: The output of our application</p>
    <p class="normal">JFR has produced a file<a id="_idIndexMarker761"/> named <code class="inlineCode">recording.jfr</code>. We can easily <a id="_idIndexMarker762"/>view the content of this file via the JFR CLI. The command (<code class="inlineCode">jfr print recording.jfr</code>) and the output are available in <em class="italic">Figure 6.4</em>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_06_04.png" alt="Figure 6.4.png"/></figure>
    <p class="packt_figref">Figure 6.4: The output of JFR containing deserialization information</p>
    <p class="normal">JFR produced a single deserialization event since our application has performed a single serialization/deserialization cycle of a <code class="inlineCode">Melon</code> object. You can see the type of the object (here, <code class="inlineCode">Melon</code>) via the <code class="inlineCode">type</code> field. Since the <code class="inlineCode">Melon</code> instance is not an array, the <code class="inlineCode">arrayLength</code> was set to <code class="inlineCode">-1</code>, which means that arrays are not applicable. The <code class="inlineCode">objectReferences</code> represents the first object reference in the stream (so, <code class="inlineCode">1</code>) and the <code class="inlineCode">bytesRead</code> represents the number of bytes read from this stream (in this case, <code class="inlineCode">78</code> bytes). We also see that there was no filter present, <code class="inlineCode">filterConfigured = false</code>, and <code class="inlineCode">filterStatus = N/A</code> (not applicable). Moreover, <code class="inlineCode">exceptionType</code> and <code class="inlineCode">exceptionMessage</code> are <code class="inlineCode">N/A</code>. They are not applicable because there is no filter present. They are useful for capturing any exceptions caused by a potential filter.</p>
    <p class="normal">Besides the JFR CLI, you can use more powerful tools for consuming the deserialization event<a id="_idIndexMarker763"/> such as JDK Mission Control (<a href="https://www.oracle.com/java/technologies/jdk-mission-control.html"><span class="url">https://www.oracle.com/java/technologies/jdk-mission-control.html</span></a>) and the well-known<a id="_idIndexMarker764"/> Advanced<a id="_idIndexMarker765"/> Management<a id="_idIndexMarker766"/> Console (<a href="https://www.oracle.com/java/technologies/advancedmanagementconsole.html"><span class="url">https://www.oracle.com/java/technologies/advancedmanagementconsole.html</span></a>).</p>
    <h1 id="_idParaDest-312" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we covered a bunch of problems dedicated to handling Java serialization/deserialization processes. We started with classical problems and moved on to cover JDK 17 context-specific deserialization filters passing through JDK 9 deserialization filters on the way.</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://discord.gg/8mgytp5DGQ "><span class="url">https://discord.gg/8mgytp5DGQ</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1139613064111216156.png" alt="" role="presentation"/></p>
  </div>
</body></html>