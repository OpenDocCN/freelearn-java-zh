- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope that all that we have learned in this book provides helpful insights
    into how to build modern, lightweight, business-oriented enterprise applications.
    Maybe this book could even dissolve some outdated best practices of the past.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how modern versions of Java EE fit into a new world of software
    development, embracing container technology, cloud platforms, automation, Continuous
    Delivery, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Motivations in enterprise development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen several times in this book, engineering teams should follow
    the right motivations when developing software. The main focus of enterprise systems
    should be on their business motivations. The domain and business use cases of
    applications need to be clear, before they can deliver value to their customers.
    At the end of the day, working software that accomplishes business functionality
    is what generates revenue.
  prefs: []
  type: TYPE_NORMAL
- en: 'A helpful question that developers can ask themselves over time is: *Is what
    we''re doing helping to solve the business problem?*'
  prefs: []
  type: TYPE_NORMAL
- en: Software that aims to meet a customer's demands therefore mainly focuses on
    fulfilling business uses cases. Technology that fulfills a subordinate necessity,
    such as communication, persistence, or distribution, comes second. The chosen
    solutions should aim to solve the business demands first.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, technology, programming languages and frameworks ideally support
    the implementation of use cases without too much overhead. The team of engineers
    is advised to choose technology that they are productive and familiar with, but
    that also fits this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud and Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the necessity of moving fast in a fast moving world. It's important
    to put emphasis on agility and reactiveness towards the customer's demands, the
    time-to-market, or better, *time-to-production*. The best features don't deliver
    value, until they are in the customer's hands.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to use concepts and technology that help achieve this goal, such
    as Continuous Delivery, automation, infrastructure as code, and automated software
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what represents the biggest benefit of modern environments and cloud
    technology: *the ability to move fast*. Application environments for new projects,
    features, or test scenarios, can be created in a matter of minutes, using well-defined
    specifications. In particular, infrastructure as code and container technology
    support these attempts. Software developers deliver the environment configuration
    together with the application code, contained in the project''s repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining all contents of enterprise software thus becomes a responsibility of
    the whole engineering team. Developers, as well as operational engineers, are
    interested in shipping software that provides value to its users. The whole software
    team is accountable for achieving this goal.
  prefs: []
  type: TYPE_NORMAL
- en: This also includes the topic of software quality assurance. Delivering features
    with rapid pace is only possible if proper, automated quality verification mechanisms
    are in place. Tests that require human intervention and that don't run reliably
    or fast enough prevent fast processes and keep developers from doing more useful
    work. It's a necessity to invest effort in automated, sufficient, and reliable
    test cases that are built with maintainability and code quality in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Relevance of Java EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how Java EE enables all this. The platform supports focusing on
    business demands by enabling developers to write code without setting too many
    constraints. Use cases can be designed and implemented by following the domain's
    demands first.
  prefs: []
  type: TYPE_NORMAL
- en: The technology itself does not *want attention*. In the majority of cases, it's
    sufficient to annotate business logic which leads the application container to
    add the required technical necessities. The approaches of Java EE standards, such
    as JAX-RS, JPA, or JSON-B, accomplish the required technical integration with
    minimum effort required.
  prefs: []
  type: TYPE_NORMAL
- en: The Java EE platform especially enables engineers to seamlessly integrate multiple
    standards without configuration work. The JSR specifications that are written
    with the principles of Java EE in mind, make this possible.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Java EE has to be seen differently to how it was in the old days of J2EE.
    In fact, the programming model and runtimes have little to do with J2EE.
  prefs: []
  type: TYPE_NORMAL
- en: With the backwards-compatible nature of the platform, outdated approaches are
    still possible, but the technology has advanced a lot since then. Programming
    models and design patterns have been revisited and vastly simplified. In particular,
    the restrictions of past patterns in implementing hierarchies of technology-motivated
    interfaces, and superclasses, are gone. Developers are able to focus on business
    domains, not on the technology.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of the Java EE standards allows companies to realize vendor-independent
    applications. This avoids vendor lock-in on the technology-side. Developers are
    also not exclusively trained for vendor-specific technologies. We have seen quite
    a few cases of teams that were solely familiar with vendors that became obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE technology is not only used on the server-side. Standards such as JAX-RS,
    JSON-P, or CDI provide valuable benefits for Java SE applications as well. It
    makes sense to realize certain functionalities, such as HTTP clients, with standards
    technology that developers are familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: API updates introduced in Java EE 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book focuses on enterprise applications with Java EE 8.
  prefs: []
  type: TYPE_NORMAL
- en: There have been certain standards that have been updated in the course of this
    version. The following are the most important new features and standards.
  prefs: []
  type: TYPE_NORMAL
- en: CDI 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Java EE 8 and CDI 2.0, events cannot only be handled synchronously. As
    we have seen previously in this book, CDI natively supports handling events asynchronously.
    In fact, this was only possible before if the event observer method was a business
    method of an EJB, annotated with `@Asynchronous`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to emit and handle asynchronous CDI events, the publisher side uses
    the `fireAsync` method. The observer method parameter is annotated with `@ObservesAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another new event functionality the advent of CDI 2.0 included is the possibility
    to order event observers. Therefore, the `@Priority` annotation, which is well-known
    within the Java EE platform, is specified at the event observer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This approach guarantees that the event observers are called in the specified
    order, with lower priority numbers first. Developers should consider whether the
    situation violates loose coupling and the single point of responsibility principle,
    by needing to order the event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest feature of CDI 2.0 was the integration outside of an enterprise
    container,â€‰providing the possibility to use CDI in Java SE applications. The idea
    is that Java SE applications can also use the features of a sophisticated dependency
    injection standard. This aims to increase the acceptance of CDI outside of the
    Java EE world.
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS 2.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version 2.1 of JAX-RS mainly targeted reactive clients, SSE, and better integration
    into standards such as JSON-B. Besides these, some small improvements have been
    added.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is used more and more, and, in particular, the client receives
    new, reactive functionality to make HTTP calls and directly returning so-called
    reactive types. An example for such a type is the `CompletionStage` type. This
    type is supported natively; other types and libraries can be added via extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make reactive calls, the `rx()` method of the `Invocation.Builder`
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: As also shown in this book, JAX-RS 2.1 supports SSE, both on the client and
    on the server side. The SSE standard represents a lightweight, one-way messaging
    protocol that uses plain text messages over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: In order to match the usual approach of the Java EE platform, the JSON-B standard
    which has been added in Java EE 8 is seamlessly integrated into JAX-RS. This means
    that, similarly to JAXB, Java types that are used as request or response bodies,
    respectively, are implicitly mapped to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the new features that are part of JSON-P 1.1 and Bean Validation
    2.0 are included in JAX-RS, as well. This is possible since the specifications
    forward the specific functionality to the corresponding standards.
  prefs: []
  type: TYPE_NORMAL
- en: A smaller update that was incorporated into JAX-RS was the inclusion of the
    `@PATCH` annotation for the HTTP method of the same name. Although support of
    HTTP methods other than the provided ones was possible in JAX-RS before, it simplifies
    the usage for developers who require this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Another small but indeed helpful improvement was to include standardized HTTP
    timeout methods on the JAX-RS client. The builder methods `connectTimeout` and
    `readTimeout` handle configured timeouts. A lot of projects require this configuration,
    which previously resulted in including vendor-specific features.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the implementation of these features in [Chapter 3](329094a0-f41b-4ad1-b05e-cd52c4bb9e42.xhtml),
    *Implementing Modern Java Enterprise Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-B 1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JSON-B is a new standard that maps Java types to and from JSON structures,
    respectively. Similarly to JAXB for XML, it provides functionality to declaratively
    map objects.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage of this standard within the Java EE ecosystem is that
    applications don't need to rely on vendor-specific implementations anymore. JSON
    mapping frameworks have typically prevented enterprise applications to be built
    in a portable way. They increase the risk of breaking runtime dependencies with
    existing framework versions.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-B solves this issue by providing standardized JSON mapping. Shipping custom
    mapping frameworks such as Jackson or Johnzon is not required anymore.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-P 1.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON-P 1.0, which was introduced in Java EE 7, shipped a powerful feature to
    programmatically create and read JSON structures. The version 1.1 mainly included
    support for common JSON standards.
  prefs: []
  type: TYPE_NORMAL
- en: One of these IETF standards is **JSON Pointer** (RFC 6901). It defines a syntax
    to query JSON structures and values. By using pointers such as `"/0/user/address"`,
    JSON values are referenced, similarly to **XPath** in the XML world.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is included in the `JsonPointer` type, that is created via the
    `Json.createPointer()` method, similarly to the existing JSON-P API.
  prefs: []
  type: TYPE_NORMAL
- en: Another, newly-supported standard is **JSON Patch** (RFC 6902). RFC 6902 defines
    so-called patches and modification methods that are applied to existing JSON structures.
  prefs: []
  type: TYPE_NORMAL
- en: JSON 1.1 supports creating JSON patches via `Json.createPatch` or `Json.createPatchBuilder`,
    respectively. The corresponding JSON-P type is `JsonPatch`.
  prefs: []
  type: TYPE_NORMAL
- en: The third supported IETF standard is **JSON Merge Patch** (RFC 7386). This standard
    merges existing JSON structures to create new structures. JSON-P supports creating
    Merge Patches via `Json.createMergeDiff` or `Json.createMergePatch`, respectively,
    that result in the `JsonMergePatch`type.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these supported IETF standards, JSON-P 1.1 includes a few smaller features
    that simplify the API usage. One example is the support of Java SE 8 streams via
    pre-defined stream collectors, such as the `JsonCollectors.toJsonArray()` method.
    Another small improvement enables the creation of JSON-P values types from Java
    strings and primitives, via `Json.createValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java EE 8 updates the Bean Validation version to 2.0\. Besides including new,
    pre-defined constraints, it mainly targets support for Java SE 8.
  prefs: []
  type: TYPE_NORMAL
- en: The Java SE 8 support includes multiple, differently-configured validation constraint
    annotations. Types of the Java 8 Date and Time API are now supported; for example,
    via usage such as `@Past LocalDate date`.
  prefs: []
  type: TYPE_NORMAL
- en: Values that are contained in container types can also be validated separately,
    via parameterized type annotations. Examples for this are `Map<String, @Valid
    Customer> customers`, `List<@NotNull String> strings`, and `Optional<@NotNull
    String> getResult()`.
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation 2.0 includes new pre-defined constraints. For example, `@Email`
    validates email addresses. `@Negative` and `@Positive` verify numeric values.
    `@NotEmpty` ensures that collections, maps, arrays, or strings are not empty or
    `null`. `@NotBlank` validates that strings do not solely consist of whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: These constraints are a helpful default feature that avoids potentially defining
    this manually.
  prefs: []
  type: TYPE_NORMAL
- en: JPA 2.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java EE 8 updates the JPA specification to version 2.2\. This version mainly
    targets Java SE 8 features.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Bean Validation, the Java SE 8 support includes the Date and Time
    API. Types such as `LocalDate` or `LocalDateTime` are now natively supported for
    entity properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 2.2 makes it possible to return a query result, not only as `List<T>`
    but `Stream<T>`, using the `getResultStream()` method as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What JPA 2.2 also finally added is support to inject managed beans into attribute
    converters using CDI's `@Inject`. This increases the use and number of scenarios
    of custom attribute converters. Similar to other standards such as JSON-B, better
    CDI integration encourages reuse of Java EE components.
  prefs: []
  type: TYPE_NORMAL
- en: Also version 2.2 adds repeatable annotations, such as `@JoinColumn`, `@NamedQuery`,
    or `@NamedEntityGraph`. Since Java SE 8 allows to repeat the same annotation type
    multiple times, developers are no longer required to use the corresponding group
    annotations, such as `@JoinColumns`, for these functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Security 1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As seen in the last chapter, Security 1.0 aims to simplify the integration of
    security concerns into Java EE applications. Developers are therefore encouraged
    to use powerful functionalities such as JASPIC.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the features and usage of HTTP authentication mechanisms, identity
    stores, and security contexts in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Servlet 4.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of writing this book, HTTP/1.1 is the primarily used version of HTTP. HTTP/2
    targets the shortcomings of HTTP performance of web applications in the past.
    In particular, requesting several resources of a web based system could lead to
    suboptimal performance due to the numerous connections involved. Version 2 of
    HTTP aims to lower latency and maximize throughput by multiplexing, pipelining,
    compressing headers, and Server Push.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the changes in HTTP/2 do not affect the engineers' work compared to
    1.1\. The servlet container deals with HTTP concerns under the hood. The exception
    to this is the Server Push feature.
  prefs: []
  type: TYPE_NORMAL
- en: Server Push works in such a way that the server directly sends HTTP responses
    of resources related to a client-requested resource, following the assumption
    that the client would need these resources as well. It allows the server to send
    resources which were not explicitly requested by a client. This is a performance
    optimization technique that in web pages mainly concerns style sheets, JavaScript
    code, and other assets.
  prefs: []
  type: TYPE_NORMAL
- en: The Servlet API supports Server Push messages by using the `PushBuilder` type
    that is instantiated with the `HttpServletRequest.newPushBuilder()` method.
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2.3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Server Faces are a traditional way of building server-centric, component-based
    HTML UIs. Java EE 8 ships with the updated JSF version 2.3.
  prefs: []
  type: TYPE_NORMAL
- en: The main improvements of the version update include better CDI, WebSocket and
    AJAX integration, class-level Bean Validation, as well as support for Java SE
    8.
  prefs: []
  type: TYPE_NORMAL
- en: Since the focus of this book is clearly on the backend-side, it doesn't include
    much about JSF.
  prefs: []
  type: TYPE_NORMAL
- en: JCP and participation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Community Process** (**JCP**) defines the standards that make up
    the Java SE and EE platforms, including the Java EE umbrella standard itself.
    The individual standards are defined as **Java Specification Requests** (**JSR**),
    each forming so-called **Expert Groups**, consisting of experts and companies
    involved in enterprise software.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to standardize technology that has proven itself well in real-world
    projects. The experience of companies and individuals from these real-world projects
    is brought together to form vendor-independent Java enterprise standards.
  prefs: []
  type: TYPE_NORMAL
- en: It's highly advisable for both companies and individuals to participate in the
    JCP. It provides the ability to form the standards and the future of Java technology
    as well as to gain knowledge in this technology. The open processes of the JCP
    enable developers to get insight about how the future versions of Java EE will
    look.
  prefs: []
  type: TYPE_NORMAL
- en: Individuals and companies can also follow the standardization processes, even
    if they don't participate in the JCP. It's possible to review working states of
    the standards and provide feedback to the Expert Groups.
  prefs: []
  type: TYPE_NORMAL
- en: The Expert Groups indeed welcome constructive feedback while the specifications
    are being formed. It's very beneficial to receive feedback and experience from
    real-world projects and helps in crafting standards that suit the needs of the
    industry better.
  prefs: []
  type: TYPE_NORMAL
- en: I also was involved in shaping Java EE 8, being part of two Expert Groups, namely
    JAX-RS 2.1 and JSON-P 1.1\. I personally gained a lot of knowledge as part of
    this engagement and can encourage enterprise Java developers to look into the
    processes within the JCP.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The motivation behind the MicroProfile initiative was to build upon the Java
    EE standards and create smaller-scale profiles that target microservice architectures
    as well as experiment with features independent from standardization. Multiple
    application server vendors have been involved in this initiative that forms vendor-agreed
    de facto standards.
  prefs: []
  type: TYPE_NORMAL
- en: Server applications that support MicroProfile pride the opportunity to run Java
    EE applications that only require a smaller set of standards,â€‰in the first version
    this includes JAX-RS, CDI, and JSON-P. Similarly, application server vendors provide
    the ability to strip down runtime to a specific required set of standards.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of these approaches is that they don't add dependencies to the
    enterprise project, rather than just optimizes the runtime. Developers still write
    their applications using the same Java EE standard technology.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse Enterprise for Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In September 2017, just before publishing this book, Oracle, the steward of
    Java EE and the JCP, announced to move the Java EE platform and its standards
    to an Open Source Foundation, what emerged in **Eclipse Enterprise for Java**
    (**EE4J**). The plans aim to lower the barrier for companies and developers who
    would like to contribute and to ultimately enable to a more open technology.
  prefs: []
  type: TYPE_NORMAL
- en: However the realization of these plans will look, it's important to mention
    that the plans include the preservation of the nature of the platform. The approaches
    and techniques presented in this book will hold true in the future of enterprise
    Java.
  prefs: []
  type: TYPE_NORMAL
- en: I can repeat my message of what I have said in the past about participation
    within the JCP. However the manifestation of the standardization process of Enterprise
    Java looks, I encourage engineers and companies to have a look into Eclipse Enterprise
    for Java and to participate in defining enterprise standards. The collective knowledge
    and real world experience helped shaping the standards of Java EE, and will help
    shaping Enterprise Java in the future.
  prefs: []
  type: TYPE_NORMAL
