- en: Chapter 2. Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 动画
- en: '|   | *"Study without desire spoils the memory, and it retains nothing that
    it takes in."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"没有欲望的学习会损害记忆，它所吸收的什么也保留不住。" |   |'
- en: '|   | --*Leonardo da Vinci* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*莱昂纳多·达·芬奇* |'
- en: It is fairly simple to move actors around in Greenfoot scenarios by handling
    keyboard or mouse events and using `setLocation()` appropriately. However, we
    can do better. By animating our actors further, we can breath life into them.
    We can give our players/users the illusion of a vibrant, living world.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Greenfoot场景中通过处理键盘或鼠标事件并适当地使用`setLocation()`方法来移动角色相对简单。然而，我们可以做得更好。通过进一步动画化我们的角色，我们可以赋予它们生命。我们可以给我们的玩家/用户一个充满活力、生机勃勃的世界的错觉。
- en: 'In essence, programming animation is the art of illusion. By adding small movements
    or image changes at the right time, we beguile our users into believing our creations
    are more than just static pixels on a screen. In this chapter, you will learn
    the following techniques for animating Greenfoot actors:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，编程动画是一种幻觉艺术。通过在适当的时候添加微小的动作或图像变化，我们诱使用户相信我们的创作不仅仅是屏幕上的静态像素。在本章中，你将学习以下用于动画Greenfoot角色的技术：
- en: Image swapping and movement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像交换和移动
- en: Timing and synchronization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时和同步
- en: Easing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓动
- en: Greenfoot is a wonderful platform for creating interactive and engaging applications
    that you can share on the Internet or use as a desktop application. It is your
    desire to create these types of applications that brought you here, and, according
    to Leonardo da Vinci, it is that desire that will help you retain the information
    in this book indefinitely.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot是一个创建交互性和吸引人的应用程序的绝佳平台，您可以在互联网上共享或用作桌面应用程序。正是您创建这些类型应用程序的愿望使您来到这里，根据达芬奇的看法，正是这种愿望将帮助您无限期地保留这本书中的信息。
- en: Revisiting Avoider Game
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温避免者游戏
- en: In this chapter, we are going to continue to work on Avoider Game, which we
    created in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's
    Dive Right in…*. If you skipped that chapter, or just prefer to start off with
    a fresh copy, you can download the code for this game from this book's product
    page on the Packt Publishing website at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    Any concepts I gloss over in this chapter were most likely covered in detail in
    the previous chapter; be sure to refer to that chapter as needed. Now, open the
    `AvoiderGame` scenario in Greenfoot and read on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续完善我们在[第1章](part0014.xhtml "第1章。让我们直接进入…")“让我们直接进入…”中创建的避免者游戏。如果您跳过了那一章，或者只是想从一份全新的副本开始，您可以从Packt
    Publishing网站上的本书产品页面下载这个游戏的代码：[http://www.packtpub.com/support](http://www.packtpub.com/support)。我在本章中略过的大部分概念很可能在前一章中已经详细讨论过；如有需要，请务必参考那一章。现在，打开Greenfoot中的`AvoiderGame`场景并继续阅读。
- en: Image swapping and movement
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像交换和移动
- en: Image swapping is the age-old technique for animating. Perhaps as a child, you
    drew a stick figure in the corner of a pad of paper and slightly changed it on
    every succeeding page. When you rapidly flipped through the pages, your stick
    figure came to life. *Figure 2* shows my attempt at this type of animation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图像交换是古老的动画技术。也许在小时候，你在纸垫的角落画了一个棒状人物，并在每一页上稍作改变。当你快速翻阅页面时，你的棒状人物就活了起来。*图2*展示了我尝试的这种动画。
- en: '![Image swapping and movement](img/image00265.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图像交换和移动](img/image00265.jpeg)'
- en: 'Figure 1: This shows old-school stick figure animation'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：这展示了传统的棒状人物动画
- en: In Greenfoot, we are going to animate actors by rapidly switching between images
    and achieve the same effect as the paper animation shown in *Figure 1*. We will
    learn how to use Greenfoot's `setImage()` method to do this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Greenfoot中，我们将通过快速切换图像来动画化角色，以达到*图1*中显示的纸动画相同的效果。我们将学习如何使用Greenfoot的`setImage()`方法来实现这一点。
- en: Using setImage()
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用setImage()
- en: 'When we create a new `Actor` in Greenfoot by subclassing from the `Actor` class,
    or one of our subclasses of `Actor`, Greenfoot prompts us to enter in the name
    of our new class and to select an image for it. Greenfoot also allows us to dynamically
    set the image of our `Actor` objects while the scenario is running, using the
    method `setImage()`provided by Greenfoot''s `Actor` class. The following is an
    excerpt from Greenfoot''s documentation:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过从`Actor`类或我们的`Actor`子类之一派生新`Actor`时，Greenfoot会提示我们输入新类的名称并为其选择一个图像。Greenfoot还允许我们在场景运行时动态设置`Actor`对象的图像，使用Greenfoot的`Actor`类提供的`setImage()`方法。以下是从Greenfoot文档中摘录的内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, `setImage()` allows us to set an image of an actor by specifying
    the path to any `JPEG`, `GIF`, or `PNG` file. By default, Greenfoot looks in the
    `images` folder contained in your Greenfoot project. You should place all images
    you are going to use in your scenario in this folder.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`setImage()`允许我们通过指定任何`JPEG`、`GIF`或`PNG`文件的路径来设置演员的图像。默认情况下，Greenfoot会在你的Greenfoot项目中包含的`images`文件夹中查找。你应该将你将在场景中使用的所有图像放置在这个文件夹中。
- en: Let's use this method to animate the enemies in Avoider Game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这种方法来为Avoider游戏中的敌人添加动画效果。
- en: Making enemies less happy
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让敌人不那么开心
- en: The enemies in Avoider Game are just too happy. Let's animate them to get sad
    and disappointed, as they realize that our hero is going to avoid them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Avoider游戏中的敌人太开心了。让我们让它们变得悲伤和失望，因为它们意识到我们的英雄将避开它们。
- en: Finding assets
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找资源
- en: 'The first thing we need to do, is to find a set of appropriate smiley images
    that we can switch to for our `Enemy` actor in our scenario. Often, you''ll need
    to create your own image assets using Greenfoot''s built-in image editor, or tools
    such as GIMP or Adobe Illustrator, or you could download images from the Internet;
    there are plenty of free images available. Luckily, the default installation of
    Greenfoot already contains all the images we need. On OSX, the images are in the
    following folder:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是找到一组合适的笑脸图像，我们可以将其切换到我们的场景中的`Enemy`演员。通常，你需要使用Greenfoot内置的图像编辑器或像GIMP或Adobe
    Illustrator这样的工具来创建自己的图像资源，或者你可以从互联网上下载图像；有很多免费图像可供选择。幸运的是，Greenfoot的默认安装已经包含了我们需要的所有图像。在OSX上，图像位于以下文件夹中：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On Windows, the images are in the following folder:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，图像位于以下文件夹中：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For your convenience, I have made all the smiley images available in this book's
    file repository on the Packt Publishing website at [https://www.packtpub.com/sites/default/files/downloads/0383OS_ColoredImages.pdf](https://www.packtpub.com/sites/default/files/downloads/0383OS_ColoredImages.pdf).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我已经将所有笑脸图像放在了这本书的文件存储库中，可以在Packt Publishing网站上找到，网址为[https://www.packtpub.com/sites/default/files/downloads/0383OS_ColoredImages.pdf](https://www.packtpub.com/sites/default/files/downloads/0383OS_ColoredImages.pdf)。
- en: You'll need to place the files `smiley1.png`, `smiley3.png`, `smiley4.png`,
    and `smiley5.png` into the `images` folder in your `AvoiderGame` directory. After
    doing this, your images folder should contain the files shown in *Figure 2*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将文件`smiley1.png`、`smiley3.png`、`smiley4.png`和`smiley5.png`放入你的`AvoiderGame`目录下的`images`文件夹中。完成此操作后，你的图像文件夹应包含*图2*中显示的文件。
- en: '![Finding assets](img/image00266.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![查找资源](img/image00266.jpeg)'
- en: 'Figure 2: These are the contents of the images folder in your AvoiderGame project.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2*：这是你的AvoiderGame项目中的图像文件夹内容。'
- en: Now that we have our images available to us, we can start coding.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了可用的图像，我们可以开始编码了。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that once you set an actor's image to one provided by Greenfoot at creation
    time, such as `skull.png` in *Figure 2*, Greenfoot automatically places the image
    in your `images` folder. So, instead of copying the smiley images from their location
    on the disk, you could have created a new actor and then set the image of this
    actor to be each of the smiley faces in turn. Then, you could just delete this
    new actor. You will see that your images folder will look like that shown in *Figure
    2*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦你将演员的图像设置为Greenfoot在创建时提供的图像，例如*图2*中的`skull.png`，Greenfoot会自动将图像放置在你的`images`文件夹中。因此，你不必从磁盘上的位置复制笑脸图像，你可以创建一个新的演员，然后依次将这个演员的图像设置为每个笑脸。然后，你可以简单地删除这个新演员。你会发现你的图像文件夹看起来就像*图2*中显示的那样。
- en: Calling setImage() based on Actor location
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 根据演员位置调用setImage()
- en: 'Double-click on the `Enemy` actor in the **Actor classes** section of Greenfoot''s
    main scenario window to begin editing the `Enemy` code. We practice good functional
    decomposition and simply add a call to `changeDispositon()` in the `act()` method
    of `Enemy`; we will write that method soon. Your `act()` method should now look
    like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Greenfoot主场景窗口的**演员类**部分双击`Enemy`演员以开始编辑`Enemy`代码。我们练习良好的功能分解，并在`Enemy`的`act()`方法中简单地添加对`changeDispositon()`的调用；我们很快就会编写这个方法。现在你的`act()`方法应该看起来像这样：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we will implement the `changeDisposition()` method. In this method, we
    want to change the disposition of the enemies, as they slowly realize they will
    not get the hero. Let's presume our enemies remain optimistic until they reach
    the middle of the screen. After that, we will slowly have them succumb to despair.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现`changeDisposition()`方法。在这个方法中，我们想要改变敌人的状态，因为他们逐渐意识到他们不会得到英雄。让我们假设我们的敌人直到达到屏幕中间都保持乐观。之后，我们将逐渐让他们陷入绝望。
- en: 'In the implementation of `changeDisposition()`, we are going to use an instance
    variable to keep track of what image we need to display next. You need to add
    this variable *declaration* and *initialization* right below the declaration of
    the speed instance variable (at the top of the class outside of any method):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`changeDisposition()`方法的实现中，我们将使用一个实例变量来跟踪我们需要显示的下一张图片。您需要在速度实例变量的声明下方添加这个变量**声明**和**初始化**（在类顶部任何方法之外）：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With that in place, we can now view the implementation of `changeDisposition()`.
    The following is our code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们现在可以查看`changeDisposition()`的实现。以下是我们的代码：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The logic behind this code is simple. We want to pick specific locations in
    the downward motion of the enemy to change the image. One complication is that
    the enemy''s speed can be changed through the `setSpeed()` method. We use this
    method in the `AvoiderWorld` class to increase the speed of the enemy, so as to
    increase the difficulty of the game. So, we cannot simply change the image of
    the enemy with code such as `if( ypos == 300)` because the actor might never have
    a *y* position of exactly `300`. For example, if the enemy''s speed was 7, then
    it would have the following *y* positions as it went down: 7, 14, 21, …, 294,
    301, 308, and so on.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码背后的逻辑很简单。我们想要在敌人下落的过程中选择特定的位置来更改图片。一个复杂的问题是敌人的速度可以通过`setSpeed()`方法来改变。我们在`AvoiderWorld`类中使用这个方法来增加敌人的速度，以增加游戏的难度。因此，我们不能简单地使用像`if(
    ypos == 300)`这样的代码来更改敌人的图片，因为演员可能永远不会有一个精确的**y**位置为`300`。例如，如果敌人的速度是7，那么它下落时的**y**位置如下：7,
    14, 21, …, 294, 301, 308，等等。
- en: As we can see, the enemy never has a *y* position of exactly 300\. You might
    next want to try code such as `if( ypos > 300 )`; however, this is suboptimal,
    as this will cause the image to *continually be set for every y position it has
    over 300*. Therefore, we should take the approach demonstrated in `changeDisposition()`
    and use `timeToChange` to control a one-time, sequential image change.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，敌人永远不会有一个精确的**y**位置为300。你可能接下来想要尝试像`if( ypos > 300 )`这样的代码；然而，这并不是最优的，因为这会导致图片在超过300的每个y位置上**持续**被设置。因此，我们应该采用`changeDisposition()`中展示的方法，并使用`timeToChange`来控制一次性的、顺序的图片更改。
- en: Now that we understand the logic behind `changeDisposition()`, let's go over
    it line by line. The first thing we do is create variables to hold the positions
    where we want to change the image of the enemy. These positions are based on the
    height of the scenario; `marker1` is at 50 percent of this height, `marker2` is
    at 75 percent of this height, and `marker3` is at a position slightly before the
    enemy exits off the bottom of the screen. The `if` statements test for two conditions
    before changing the image of the actor. It checks to see whether to use `timeToChange`
    to that specific image and whether the actor has passed a given *y* position.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了`changeDisposition()`背后的逻辑，让我们逐行分析。我们首先创建变量来保存我们想要更改敌人图片的位置。这些位置基于场景的高度；`marker1`位于高度的50%，`marker2`位于高度的75%，而`marker3`位于敌人从屏幕底部退出之前的一个稍微靠前的位置。`if`语句在更改演员图片之前测试两个条件。它检查是否使用`timeToChange`来更改特定图片，以及演员是否已经通过了一个给定的**y**位置。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In the previous code, there are lines that convert a decimal number (of type
    `double`) into a whole number (of type `int`), such as this one:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，有一些行将十进制数字（类型为`double`）转换为整数（类型为`int`），例如这一行：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For more information on converting one variable into another (also called casting),
    refer to the following link:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将一个变量转换为另一个变量（也称为类型转换）的更多信息，请参阅以下链接：
- en: '[http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html](http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html](http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html)'
- en: 'Compile your Greenfoot scenario and play the game. See if you can get a score
    greater than 250! *Full disclosure: after writing that last sentence I played
    the game four times in a row and got the following scores: 52, 33, 28, 254\. Woot!
    254!*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编译你的 Greenfoot 场景并玩游戏。看看你是否能获得超过 250 分的分数！**完全坦白：在写下最后一句话后，我连续玩了四次游戏，得到了以下分数：52，33，28，254。哇！254！**
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Functional decomposition**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能分解**'
- en: Functional decomposition is closely related to the top-down design, a process
    of repeatedly redefining the problem in terms of smaller, less complex subproblems.
    When you are writing code for a specific action or functionality in your program,
    try to think of smaller methods you could write that you could compose to solve
    the larger issue.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 功能分解与自顶向下的设计密切相关，这是一个通过将问题重新定义为更小、更简单的子问题来反复定义问题的过程。当你为程序中的特定动作或功能编写代码时，尝试思考你可以编写的更小的方法，你可以将它们组合起来解决更大的问题。
- en: Typically, you would like to write methods that contain less than 40 lines of
    code and which only implement one well-defined task. I actually prefer to go much
    smaller when possible. You'll find code is easier to write, debug, and modify
    if you follow this practice. In this book, I use functional decomposition. You'll
    notice that the `act()` methods throughout the book mainly contain a sequence
    of calls to other methods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望编写少于 40 行代码的方法，并且只实现一个定义良好的任务。实际上，如果可能的话，我更喜欢做得更小。你会发现，如果你遵循这个实践，代码编写、调试和修改都会更容易。在这本书中，我使用了功能分解。你会发现，书中所有的
    `act()` 方法主要包含对其他方法的调用序列。
- en: Using setLocation()
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 setLocation()
- en: The method `setImage()` is by far the most useful Greenfoot method for animating
    actors; however, moving an actor in certain ways can also produce interesting
    effects. We already use `setLocation()` to move both the enemies and our hero;
    let's use it now to animate the background star field to make it seem like we
    are flying through space.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`setImage()` 方法是 Greenfoot 中用于动画角色的最有用的方法；然而，以某些方式移动角色也可以产生有趣的效果。我们已经使用 `setLocation()`
    来移动敌人和我们的英雄；现在让我们用它来动画背景星系，使其看起来像我们在穿越太空。'
- en: Creating a star field
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建星系
- en: Our star field is going to provide various sized stars moving in the background
    at various speeds, to produce the effect of moving through space at high speed.
    Creating a star field is very simple and we have already written very similar
    code. Imagine that our enemies had the image of a small speck of light, instead
    of a smiley face and we had many more of them. Voila! You have a star field.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供各种大小、以不同速度在背景中移动的星星，以产生高速穿越太空的效果。创建星系非常简单，我们已经有非常相似的代码。想象一下，如果我们的敌人有一个小光点的图像，而不是笑脸，而我们有很多这样的敌人。哇！你就有了一个星系。
- en: A blank slate
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一张白纸
- en: If we are going to create our own dynamic star field, then we no longer need
    the current background image associated with `AvoiderWorld`. However, if we change
    this class to have no image associated with it, then we will get a white background—not
    a very good representation of outer space.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要创建自己的动态星系，那么我们就不再需要与 `AvoiderWorld` 关联的当前背景图像。然而，如果我们把这个类改为没有与之关联的图像，那么我们将会得到一个白色背景——这不是外太空的一个很好的表现。
- en: The solution is to create a new pure black, 600 x 400 pixel image and then select
    that as the background image for the `AvoiderWorld` class. Start up your favorite
    image editor or use Greenfoot's built-in editor, create a big black rectangle,
    save it as a PNG file in your **Avoider** project's `images` folder, and then
    set `AvoiderWorld` to use this new image as the background.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个新的纯黑色、600 x 400 像素的图像，然后将其作为 `AvoiderWorld` 类的背景图像。启动你最喜欢的图像编辑器或使用
    Greenfoot 内置的编辑器，创建一个大黑矩形，将其保存为 PNG 文件到你的 **Avoider** 项目的 `images` 文件夹中，然后将 `AvoiderWorld`
    设置为使用这个新图像作为背景。
- en: The Star class
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 星类
- en: For our stars, we are going to do something a little different. Instead of setting
    the image of the star to a file containing a graphic, we are going to dynamically
    draw the image. This will be easy to do since a speck of light is not very complicated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的星星，我们将做一些不同的事情。我们不会将星星的图像设置为包含图形的文件，而是将动态绘制图像。由于光点并不复杂，这将很容易做到。
- en: To create our star actor, right-click on the `Actor` class in the **Actor classes**
    section and choose **New subclass…**. In the **New class** window that pops up,
    enter `Star` as **New class name** and choose **No image** as **New class image**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的星星演员，在**Actor类**部分右键单击`Actor`类，并选择**新建子类…**。在弹出的**新建类**窗口中，将**新类名称**输入为`Star`，并将**新类图像**选择为**无图像**。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, we went over how to create new actors in [Chapter 1](part0014.xhtml
    "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在[第1章](part0014.xhtml "第1章。让我们直接进入…")中讲解了如何创建新的演员，*让我们直接进入…*。
- en: 'Open up a code editor window for your new `Star` class and add the following
    constructor to it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的代码编辑器窗口，为你的新`Star`类添加以下构造函数：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This constructor dynamically creates an image to use for the image of our `Star`
    class. First, we create a new image that has a width of `10` pixels and a height
    of `10` pixels. Next, we set the color to use for any drawing we do in this image.
    We gain access to the `Color` class (see the information box below to learn more
    about it) by adding the following `import` statement at the top of our class file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数动态创建了一个用于`Star`类图像的图像。首先，我们创建了一个宽度为`10`像素、高度为`10`像素的新图像。接下来，我们设置用于在这个图像中绘制任何内容的颜色。我们通过在类文件顶部添加以下`import`语句来获取对`Color`类的访问权限（有关更多信息，请参阅下面的信息框）：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After setting the color, we draw an oval using the `fillOval()` method. The
    first two parameters of `fillOval()` specify the offset of the upper-left corner
    of the shape we are drawing from the offset of the upper-left corner of our image.
    *Figure 3* displays this mapping. The next two parameters of `fillOval()` specify
    the width and height of the bounding box containing our oval. Since our width
    and height are the same, `fillOval()` will draw a circle. Finally, we set the
    image of our actor to be the new image we just created.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置颜色后，我们使用`fillOval()`方法绘制一个椭圆形。`fillOval()`的第一个两个参数指定了我们正在绘制的形状的左上角相对于我们图像左上角的偏移量。*图3*显示了这种映射。`fillOval()`的下一个两个参数指定了包含我们的椭圆形的边界框的宽度和高度。由于我们的宽度和高度相同，`fillOval()`将绘制一个圆。最后，我们将演员的图像设置为刚刚创建的新图像。
- en: '![The Star class](img/image00267.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Star类](img/image00267.jpeg)'
- en: 'Figure 3: This shows the effect of using values of 8 and 5 for the first two
    parameters of fillOval()'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：这显示了使用fillOval()的第一个两个参数值为8和5的效果
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Working with color**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理颜色**'
- en: In the `Star()` constructor, we do an operation that involves color. There are
    several different ways to represent color on computers (and basically anything
    with a screen), and we are going to use an RGBA color model. If you are curious,
    you can read more about it at [http://en.wikipedia.org/wiki/RGBA_color_space](http://en.wikipedia.org/wiki/RGBA_color_space).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Star()`构造函数中，我们进行了一个涉及颜色的操作。计算机（以及基本上任何带有屏幕的东西）上有几种不同的方式来表示颜色，我们将使用RGBA颜色模型。如果你对此好奇，你可以在[http://en.wikipedia.org/wiki/RGBA_color_space](http://en.wikipedia.org/wiki/RGBA_color_space)上了解更多关于它的信息。
- en: Luckily, we don't have to know much about the theory. Java provides a class—`Color`—that
    manages most of the complexity for us. To get this `Color` class into your code,
    you need to have an `import` statement at the top of the file. The import statement
    is `import java.awt.Color;`. If you don't add this to the code above, you'll get
    compile errors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要了解太多关于理论的知识。Java提供了一个名为`Color`的类，它为我们管理了大部分的复杂性。要将这个`Color`类引入到你的代码中，你需要在文件顶部添加一个`import`语句。这个`import`语句是`import
    java.awt.Color;`。如果你没有将这个添加到上面的代码中，你会得到编译错误。
- en: To learn more about this `Color` class, look at the official documentation at
    [http://docs.oracle.com/javase/7/docs/api/java/awt/Color.html](http://docs.oracle.com/javase/7/docs/api/java/awt/Color.html).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这个`Color`类的信息，请查看官方文档[http://docs.oracle.com/javase/7/docs/api/java/awt/Color.html](http://docs.oracle.com/javase/7/docs/api/java/awt/Color.html)。
- en: 'The next thing to do to our `Star` class, is fill in the `act()` method. We
    just need to slowly move this actor down the screen and then remove it once it
    has exited off the bottom of the screen. We use `setLocation()` to do the former
    and the `checkRemove()` method to do the latter. The following is the completed
    code for both `act()` and `checkRemove()`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要为`Star`类添加的是`act()`方法。我们只需要慢慢将这个演员向下移动到屏幕底部，然后一旦它从屏幕底部移出就将其移除。我们使用`setLocation()`来完成前者，使用`checkRemove()`方法来完成后者。以下是`act()`和`checkRemove()`方法完成的代码：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `checkRemove()` method is exactly the same code as the one used in the
    `Enemy` class and explained in [Chapter 1](part0014.xhtml "Chapter 1. Let''s Dive
    Right in…"), *Let''s Dive Right in…*. In fact, there are many similarities between
    the `Star` class and the `Enemy` class, so much so, that I think we should pre-emptively
    add the `setSpeed()` method the `Enemy` has to the `Star` class, as it is very
    likely we will need it later in our implementation of a moving star field. Add
    this method to the `Star` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkRemove()`方法与在`Enemy`类中使用并解释过的代码完全相同，请参阅[第1章](part0014.xhtml "第1章。让我们直接进入…")，“让我们直接进入…”。实际上，`Star`类和`Enemy`类之间有很多相似之处，以至于我认为我们应该提前将`Enemy`类中的`setSpeed()`方法添加到`Star`类中，因为在我们的移动星星场实现中，我们很可能需要它。将此方法添加到`Star`类中：'
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just as we did in the `Enemy` class, we need to add the instance variable `speed`
    at the top of the class. Here''s the code for the variable declaration:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`Enemy`类中所做的那样，我们需要在类的顶部添加实例变量`speed`。以下是变量声明的代码：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We should make one more change in the `act()` method to now use the `speed`
    variable to move `Star` objects. Change the `setLocation()` code in the `act()`
    method to this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在`act()`方法中再进行一次修改，现在使用`speed`变量来移动`Star`对象。将`act()`方法中的`setLocation()`代码修改为如下：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete code for the `Star` class is shown in *Figure 4*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Star`类的完整代码在*图4*中展示。'
- en: '![The Star class](img/image00268.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![星星类](img/image00268.jpeg)'
- en: 'Figure 4: This shows the completed Star class implementation'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：这显示了完成的`Star`类实现
- en: This would be a great time to compile the scenario and make sure you do not
    have any spelling errors. We have not added any stars to our game, so you will
    not notice any difference in the game. Adding stars is what we are going to do
    next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是编译场景并确保你没有拼写错误的好时机。我们还没有在我们的游戏中添加星星，所以你不会注意到游戏中的任何区别。添加星星是我们接下来要做的。
- en: Creating a moving field
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建移动场
- en: 'We will generate our stars in the `AvoiderWorld` class. Open the editor window
    for this class and add a line of code to the `act()` method to call the method
    `generateStars()`, which we haven''t written yet, but will soon. Your `act()`
    method should now look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`AvoiderWorld`类中生成我们的星星。打开这个类的编辑器窗口，并在`act()`方法中添加一行代码来调用我们尚未编写的`generateStars()`方法，但很快就会编写。你的`act()`方法现在应该看起来像这样：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `generateStars()` method creates new stars in a way similar to how `generateEnemies()`
    creates new enemies. Here is the code for `generateStars()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateStars()`方法以类似于`generateEnemies()`创建新敌人的方式创建新的星星。以下是`generateStars()`的代码：'
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `if` statement determines whether or not we want to create a star at this
    point in time. With a 35 percent probability, we will create a star, which ultimately
    creates a fairly dense star field. Inside the `if` statement, we create a new
    `Star` object and add it to the `World`. Add this code and compile and run the
    game, and see what you think. Do you like the stars? They're OK, but it looks
    a little more like it's raining golf balls. We can do better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句决定了我们是否想在此时创建一个星星。有35%的概率我们会创建一个星星，这最终会创建一个相当密集的星星场。在`if`语句内部，我们创建一个新的`Star`对象并将其添加到`World`中。添加此代码并编译运行游戏，看看你的想法。你喜欢星星吗？它们还可以，但看起来有点像在下雨的高尔夫球。我们可以做得更好。'
- en: Using parallax
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用视差
- en: Parallax is the effect that closer objects seem to be in different positions
    relative to farther objects based on the viewing angle. For example, if you have
    ever looked out of a car window and watched trees go by, you'll notice that the
    trees closer to you seem to move faster than the trees in the background. We can
    use this phenomenon to give the illusion of depth to our star field.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 视差是近处的物体似乎相对于远处的物体在观看角度上处于不同位置的效果。例如，如果你曾经从汽车窗户向外看，并观察树木移动，你会注意到靠近你的树木似乎比背景中的树木移动得更快。我们可以利用这种现象给我们的星星场带来深度感。
- en: Let's change our `generateStars()` method to create two types of stars. Some
    will be near and some will be far. Nearer stars will move faster and be brighter
    than stars that are further away, but we will generate more stars that are far
    away. If you imagine our screen as a window out into space, we will have a wider
    view of objects that are far away, as opposed to close by. Therefore, we need
    more of them. *Figure 5* illustrates this point.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`generateStars()`方法修改为创建两种类型的星星。一些会靠近，一些会远离。靠近的星星会移动得更快，亮度也会比远离的星星高，但我们将会生成更多远离的星星。如果你将我们的屏幕想象成一个通向太空的窗口，我们将看到更远处的物体，而不是近处的物体。因此，我们需要更多的星星。*图5*展示了这一点。
- en: '![Using parallax](img/image00269.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用视差](img/image00269.jpeg)'
- en: 'Figure 5: This demonstrates that you have a wider field of view for objects
    that are further away when looking through a window'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：这表明，通过窗户看去，对于更远处的物体，你的视野更宽。
- en: 'Finally, we want to add some random variation in the stars, so that the resulting
    star field does not look too uniform. Here''s our parallax-augmented `generateStars()`
    method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望添加一些随机的变化到星星中，这样生成的星星场就不会看起来太均匀。这是我们的视差增强的 `generateStars()` 方法：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have added accessing the current image of the star, changing the image, and
    then setting it to be the new image for the star. The inner `if-else` statement
    handles the changes for nearby and faraway stars. With a 30 percent chance, the
    star will be a near one. Nearby stars are faster (`setSpeed()`), brighter (`setTransparency()`),
    and larger (`scale()`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了访问当前星星图像、更改图像并将其设置为新的星星图像的功能。内部的 `if-else` 语句处理了附近和远处的星星的变化。有30%的几率星星会是近处的。附近的星星速度更快（`setSpeed()`）、亮度更高（`setTransparency()`）和更大（`scale()`）。
- en: The `setTransparency()` method accepts one integer parameter that specifies
    how *see-through* the image is. You would enter in the value `255` for a completely
    opaque object and 0 for a completely transparent object. We make stars that are
    far away more transparent so that more of the black background will come through
    and make it less bright. The `scale()` method on `GreenfootImages` changes the
    size of the image, so that it fits into the bounding box defined by the first
    two parameters of this method. As we can see in the code, nearby stars are scaled
    to fit into a 4 x 4 pixel image and stars further away are scaled to fit into
    a 2 x 2 pixel image.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTransparency()` 方法接受一个整数参数，用于指定图像的透明度。对于完全不透明的物体，你应输入值 `255`；对于完全透明的物体，输入
    `0`。我们使远处的星星更透明，这样更多的黑色背景就会透过来，使其不那么明亮。`GreenfootImages` 上的 `scale()` 方法用于改变图像的大小，以便它适合由该方法的前两个参数定义的边界框。正如我们在代码中所看到的，附近的星星被缩放到一个
    4 x 4 像素的图像中，而远处的星星被缩放到一个 2 x 2 像素的图像中。'
- en: We are so close to finishing our star field. Compile and run the scenario and
    see what you think of it up to now.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离完成星星场已经非常接近了。编译并运行场景，看看你现在对这个场景的看法。
- en: The star field is looking great, but there are still two problems. First, when
    the game starts, the background is completely black, and then stars start to fall.
    To really keep the illusion that you are in space, we need the game to start in
    a field of stars. Second, the stars are being generated over the enemies, our
    hero, and the score counter; this really wrecks the illusion that they are far
    away. Let's fix this.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 星空看起来很棒，但仍然有两个问题。首先，当游戏开始时，背景是完全黑色的，然后星星开始下落。为了真正保持你在太空中的错觉，我们需要游戏从星星场开始。其次，星星正在生成在敌人、我们的英雄和得分计数器上方；这真的破坏了它们远处的错觉。让我们来修复这个问题。
- en: 'Solving the issue that the stars are in front of other actors on the screen
    is a one-liner. Here''s the line of code you need to add to the constructor in
    `AvoiderWorld`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 解决星星在屏幕上其他角色前面的问题只需要一行代码。这是你需要添加到 `AvoiderWorld` 构造函数中的代码行：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `setPaintOrder()`method is defined in the `World` class that `AvoiderWorld`
    subclasses. This method allows you set the order of classes displayed on the screen.
    So, we list the `Avatar` class first (it will be at the top of everything), then
    the `Enemy` class, and last the `Counter` class. With this ordering, for example,
    our enemies will be displayed above the score. Any class not listed will be drawn
    behind all the ones listed; therefore, our stars will be behind all actors on
    the screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPaintOrder()` 方法定义在 `World` 类中，`AvoiderWorld` 是其子类。这个方法允许你设置屏幕上显示的类的顺序。因此，我们首先列出
    `Avatar` 类（它将在所有东西的顶部），然后是 `Enemy` 类，最后是 `Counter` 类。按照这种顺序，例如，我们的敌人将显示在得分上方。任何未列出的类都将绘制在所有已列出的类之后；因此，我们的星星将位于屏幕上所有角色的后面。'
- en: 'Drawing the initial field of stars is easy if we make a small change to the
    `generateStars()` method. Presently, our stars are hardcoded to start with a *y*
    coordinate of `-1` because of this line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对 `generateStars()` 方法进行小的修改，绘制初始的星星场就很容易了。目前，我们的星星由于这一行而硬编码为从 `-1` 的 *y*
    坐标开始：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we change `generateStars()` to take one integer parameter that specifies
    the *y* value to draw the star at, then we can use this method to create the initial
    star field. Take the first line of `generateStars()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `generateStars()` 修改为接受一个整数参数，该参数指定绘制星星的 *y* 值，那么我们可以使用这个方法来创建初始的星星场。看
    `generateStars()` 的第一行：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Change it to this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这样：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Take the last line of the method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 取方法中的最后一行：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Change it to this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这个：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These two line changes allow us to specify any starting *y* value for our stars.
    Because of this change, we need to change the call to `generateStars()` in our
    `act()` method to the following line of code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个行更改使我们能够为我们的星星指定任何起始*y*值。由于这个更改，我们需要在`act()`方法中将`generateStars()`的调用更改为以下代码行：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you compile and run the scenario, the only difference you should see is
    that the stars are now truly in the background. We still need to add one simple
    method definition and call to draw the initial star field. The method definition
    is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行场景，你应该看到的唯一区别是星星现在真正在背景中。我们仍然需要添加一个简单的方法定义和调用来绘制初始星星场。方法定义如下：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the height of our game is four hundred, then this method calls `generateStars()`
    four hundred times. Each time, it supplies a different *y* value to draw stars
    on. We will fill up the screen with stars by adding this line to our constructor:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们游戏的高度是四百，那么这种方法会调用`generateStars()`四百次。每次，它都会提供一个不同的*y*值来绘制星星。我们将通过在构造函数中添加这一行来用星星填满屏幕：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have made a lot of changes to the `AvoiderWorld` class definition, making
    it increasingly likely that you may have put code in the wrong place. Here is
    the full listing of the `AvoiderWorld` class you can use to check your code against:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`AvoiderWorld`类的定义进行了很多更改，这使得你可能在错误的地方放置了代码的可能性越来越大。以下是你可以用来检查你的代码的`AvoiderWorld`类的完整列表：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compile and run your game. This is getting good. Your game should look like
    the screenshot shown in *Figure 6A*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行你的游戏。这已经很不错了。你的游戏应该看起来像*图6A*中显示的截图。
- en: '![Using parallax](img/image00270.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![使用视差](img/image00270.jpeg)'
- en: 'Figure 6A: This shows our game up to now'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图6A：这显示了到目前为止的游戏
- en: Using GreenfootImage
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用GreenfootImage
- en: Wait a minute. How did I know about Greenfoot's `GreenfootImage` class and the
    `setColor()` and `fillOval()` methods it contains? The answer is simply that I
    read the documentation. I learned that Greenfoot provides the class `GreenfootImage`
    to aid in the handling and manipulation of images. In general, Greenfoot provides
    a useful set of classes to help programmers create interactive applications. We
    learned about the `World` class and `Actor` class in [Chapter 1](part0014.xhtml
    "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…*. *Figure 6B* displays
    all the classes Greenfoot provides.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下。我是怎么知道Greenfoot的`GreenfootImage`类以及它包含的`setColor()`和`fillOval()`方法的？答案是简单的，因为我阅读了文档。我了解到Greenfoot提供了`GreenfootImage`类来帮助处理和操作图像。一般来说，Greenfoot提供了一套有用的类来帮助程序员创建交互式应用程序。我们在[第1章](part0014.xhtml
    "第1章。让我们直接进入…")中学习了`World`类和`Actor`类，*让我们直接进入…*。*图6B*显示了Greenfoot提供的所有类。
- en: '![Using GreenfootImage](img/image00271.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使用GreenfootImage](img/image00271.jpeg)'
- en: 'Figure 6B: This shows the classes provided by Greenfoot to help you write applications.
    This screenshot is taken directly from Greenfoot''s help documentation.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图6B：这显示了Greenfoot提供的类，以帮助你编写应用程序。此截图直接来自Greenfoot的帮助文档。
- en: You can access Greenfoot's documentation by going to Greenfoot's website, as
    I suggested in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"),
    *Let's Dive Right in…*. If you are not online, you can access the documentation
    by selecting the **Help** menu option in Greenfoot's main menu and then selecting
    **Greenfoot Class Documentation** from the drop-down menu. This will bring up
    Greenfoot's class documentation in your default web browser.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问Greenfoot的网站来访问Greenfoot的文档，正如我在[第1章](part0014.xhtml "第1章。让我们直接进入…")中建议的那样，*让我们直接进入…*。如果你不在网上，你可以通过在Greenfoot的主菜单中选择**帮助**菜单选项，然后从下拉菜单中选择**Greenfoot类文档**来访问文档。这将使用默认的网页浏览器打开Greenfoot的类文档。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Greenfoot's class documentation is very short and concise. You should take 20–30
    minutes to read about each class Greenfoot provides and each method contained
    in those classes. This will be a very good investment of your time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot的类文档非常简短和简洁。你应该花20-30分钟阅读Greenfoot提供的每个类以及这些类中包含的每个方法。这将是一个非常值得的时间投资。
- en: Timing and synchronization
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间和同步
- en: Timing is very important in creating realistic animations in Greenfoot. Often,
    we have the need for an actor to do temporary animation in response to an event.
    We need a way to allow (or prevent) things for a certain amount of time. It is
    possible to wait for a specific amount of time using the `SimpleTimer` class provided
    by Greenfoot (you can import it into your scenario in the same way you imported
    the `Counter` class in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right
    in…"), *Let's Dive Right in…*); however, waiting for a specific amount of time
    is rarely the right choice.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Greenfoot中创建逼真的动画时，时间安排非常重要。我们经常需要让演员对事件做出临时的动画反应。我们需要一种方式来允许（或阻止）某些事物持续一定的时间。使用Greenfoot提供的`SimpleTimer`类（你可以像在[第1章](part0014.xhtml
    "第1章。让我们直接进入…")中导入`Counter`类一样将其导入你的场景中），你可以等待特定的时间；然而，等待特定的时间很少是正确的选择。
- en: Why is that? Well, Greenfoot provides the player/user with the ability to slow
    down and speed up a scenario via the **Speed** slider that is located at the bottom
    of Greenfoot's main scenario window. If you waited for 2 seconds in your code
    and then the player sped the game up, the 2 seconds wait would last much longer
    in the game relative to the speed of everything else; the reverse effect would
    happen if the user slowed down the scenario. We want to use a method for "waiting"
    in Greenfoot that scales with the speed of the game.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？好吧，Greenfoot为玩家/用户提供了一种通过位于Greenfoot主场景窗口底部的**速度**滑块来加快或减慢场景的能力。如果你在代码中等待了2秒钟，然后玩家加快了游戏速度，那么相对于其他所有事物的速度，2秒钟的等待时间在游戏中会持续更长；如果用户减慢了场景，则会产生相反的效果。我们希望使用一种在Greenfoot中“等待”的方法，该方法与游戏速度成比例。
- en: 'We will look at three different ways to time events in Greenfoot: delay variables,
    random actions, and triggered events.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨在Greenfoot中计时事件的三种不同方法：延迟变量、随机动作和触发事件。
- en: Delay variables
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟变量
- en: Delay variables are very similar to the concept of a timer. However, instead
    of counting seconds (or milliseconds), we will count the number of calls to the
    `act()` method that have gone by. This will exactly scale with the **Speed** slider,
    as this slider controls the time between `act()` method calls. Next, we will take
    a look at an example of using a delay variable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟变量与计时器的概念非常相似。然而，我们不会计算秒数（或毫秒数），而是计算调用`act()`方法的次数。这将与**速度**滑块精确成比例，因为该滑块控制`act()`方法调用之间的时间。接下来，我们将查看使用延迟变量的示例。
- en: Hurting the avatar
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伤害头像
- en: 'Our game is a little unforgiving. If you touch an enemy once, you die. Let''s
    change the game, so that you take damage for every hit and it takes four hits
    to kill our hero. The first thing we need to do, is create an instance variable
    that is going to keep track of the health of our hero. Add this instance variable
    to the top of the `Avatar` class outside of any method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏有点苛刻。如果你触碰到敌人一次，你就会死亡。让我们改变游戏，这样你每次被击中都会受到伤害，而杀死我们的英雄需要四次打击。我们需要做的第一件事是创建一个实例变量，该变量将跟踪我们英雄的健康状况。将此实例变量添加到`Avatar`类的顶部，任何方法之外：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Every time our hero touches an enemy, we are going to subtract one from this
    variable. When this variable is `0`, we will end the game.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的英雄接触到敌人时，我们将从这个变量中减去一个。当这个变量为`0`时，我们将结束游戏。
- en: When our hero is hit by an enemy, we want to provide visual feedback to the
    player. We could do this with a health bar or life indicator at the top of the
    game; however, let's just animate our hero so that it *looks* injured. To do this,
    we need to create copies of the `skull.png` image that is used to represent an
    instance of the `Avatar` class and augment them to look damaged. You can make
    the changes using an image editor, such as GIMP, Adobe Illustrator, or others.
    *Figure 7* shows my versions of the damaged `skull.png` image. Make sure you name
    your skull images exactly the way I did. The first image `skull.png` is already
    in the images folder; the other three need to be named `skull1.png`, `skull2.png`,
    and `skull3.png`. The reason why it is so important to name them in this manner
    will become apparent soon.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的英雄被敌人击中时，我们希望向玩家提供视觉反馈。我们可以通过在游戏顶部添加健康条或生命指示器来实现这一点；然而，让我们只是让我们的英雄看起来受伤。为此，我们需要创建`skull.png`图像的副本，该图像用于表示`Avatar`类的实例，并增强它们以看起来受损。你可以使用图像编辑器，如GIMP、Adobe
    Illustrator或其他编辑器来做出这些更改。*图7*显示了受损的`skull.png`图像的版本。确保你将你的头骨图像命名为与我完全相同的方式。第一个图像`skull.png`已经在图像文件夹中；其他三个需要命名为`skull1.png`、`skull2.png`和`skull3.png`。为什么以这种方式命名如此重要，很快就会变得明显。
- en: '![Hurting the avatar](img/image00272.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![伤害头像](img/image00272.jpeg)'
- en: 'Figure 7: These are my four copies of skull.png showing increased damage. They
    are named skull.png, skull1.png, skull2.png, and skull3.png, respectively.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：这是我的四个`skull.png`副本，显示了增加的伤害。它们分别命名为skull.png、skull1.png、skull2.png和skull3.png。
- en: 'Presently, our `act()` method in the `Avatar` class looks like the following
    code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`Avatar`类中的`act()`方法如下所示：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are going to change the implementation of `checkForCollisions()` to handle
    our hero having life and looking damaged. It presently looks like the following
    code snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`checkForCollisions()`函数的实现，以处理我们的英雄拥有生命并看起来受损的情况。目前的代码片段如下所示：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We need to change it to this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其更改为：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we can see, we added quite a bit of code. The first `if` statement checks
    the two conditions that need to be true before we take damage from an enemy: firstly,
    that enough time has passed since the last time we took damage from an enemy,
    and secondly, that we are presently touching an instance of the `Enemy` class.
    When the hero touches an enemy and takes damage, we want to give our hero a short
    time of invulnerability in order to move away, without continuing to take damage
    every time the `act()` method is called. If we didn''t do this, the hero would
    take four hits before you could blink your eye. We use the `hitDelay` integer
    variable to count how long to wait. If we have been hit, we set `hitDelay` to
    `50`, as shown in the `else` part of the inner `if-else` statement. The last `if`
    statement in the function continues to decrement `hitDelay`. When `hitDelay` gets
    to `0`, we can be hit by an enemy and no longer decrement `hitDelay`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们添加了相当多的代码。第一个`if`语句检查在受到敌人伤害之前需要满足的两个条件：首先，自上次我们受到敌人伤害以来已经过去了足够的时间，其次，我们现在正在接触`Enemy`类的一个实例。当英雄接触到敌人并受到伤害时，我们希望给我们的英雄一段短暂的不可伤害时间，以便移动，而不会在每次调用`act()`方法时继续受到伤害。如果我们不这样做，英雄会在你眨眼之前受到四次打击。我们使用`hitDelay`整型变量来计算等待时间。如果我们已经受到打击，我们将`hitDelay`设置为`50`，如内层`if-else`语句的`else`部分所示。函数中的最后一个`if`语句继续递减`hitDelay`。当`hitDelay`减到`0`时，我们可以被敌人击中，并且不再递减`hitDelay`。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Java increment and decrement operators**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java增量与递减运算符**'
- en: 'In the last bit of code, we used Java''s increment (`++`) and decrement (`--`)
    operators quite a bit. They simply add one or subtract one, respectively, from
    the variable they are applied to. However, there is a bit of subtlety you need
    to be aware of in their use. Look at the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一段代码中，我们大量使用了Java的增量（`++`）和递减（`--`）运算符。它们简单地分别从它们应用的变量中加一或减一。然而，在使用它们时有一些微妙之处需要你注意。看看以下代码：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that the increment operator can be applied before (prefix) or after
    (postfix) the variable. After this code completes, `x` is `2`, `y` is `1`, and
    `z` is `1`. You might be surprised that `z` is `1` and not `2`. The reason is
    that the postfix increment operator will return the value of the variable before
    it is incremented. Refer to the following link for more information:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，增量运算符可以应用于变量之前（前缀）或之后（后缀）。在这段代码完成后，`x`是`2`，`y`是`1`，`z`是`1`。你可能惊讶`z`是`1`而不是`2`。原因是后缀增量运算符将在变量递增之前返回变量的值。有关更多信息，请参阅以下链接：
- en: '[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html)'
- en: In the inner `if-else` statement, we know we have been hit by an enemy. We check
    to see if our `health` is `0`; if it is, we are dead, and the game ends as before.
    If we still have `health`, we decrement our `health`, change our image, and set
    `hitDelay`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在内层`if-else`语句中，我们知道我们已经受到敌人的打击。我们检查我们的`health`是否为`0`；如果是，我们就死了，游戏就像以前一样结束。如果我们还有`health`，我们就减少我们的`health`，更改我们的图像，并设置`hitDelay`。
- en: 'The way we change our image to the next, more damaged, image is based on how
    we named the files earlier. We build the name of the file by concatenating the
    `skull` string with an integer and then again with the `.png` string. This method
    provides us with a short and easy programmatic way of changing the image. The
    alternative would be to use a `switch` statement that calls `setImage()` with
    different file names based on the value of `health`. In our new version of `checkForCollisions()`,
    we used two new instance variables; we still need to declare and initialize those
    variables. Add these lines at the top of the class under the declaration of the
    `health` variable we added at the beginning of this section:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图像更改为下一个更损坏的图像的方式是基于我们之前如何命名文件。我们通过将`skull`字符串与一个整数连接，然后再与`.png`字符串连接来构建文件名。这种方法为我们提供了一种简短且易于程序化的更改图像的方法。另一种选择是使用`switch`语句，根据`health`的值调用带有不同文件名的`setImage()`。在我们的新版本`checkForCollisions()`中，我们使用了两个新的实例变量；我们仍然需要声明和初始化这些变量。在添加本节开头添加的`health`变量下方添加这些行：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, compile your scenario and verify that your hero takes four hits to die.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译你的场景并验证你的英雄需要受到四次攻击才能死亡。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `hitDelay` variable is a good example of a delay variable. Throughout the
    rest of the book, we will use delay variables to time various activities. Make
    sure you understand how we use `hitDelay` before continuing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`hitDelay`变量是延迟变量的一个好例子。在本书的其余部分，我们将使用延迟变量来计时各种活动。在继续之前，请确保你理解我们如何使用`hitDelay`。'
- en: Random actions
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机动作
- en: Random actions are one of the most effective ways to approximate simple intelligence
    or natural phenomena. It repeats actions in a non-predictable way and adds both
    suspense and challenge to a game. We already randomly generate a flow of enemies
    our hero has to avoid. We will now use them to improve our star field animation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随机动作是模拟简单智能或自然现象的最有效方法之一。它以不可预测的方式重复动作，并为游戏增添了悬念和挑战。我们已经在随机生成英雄需要躲避的敌人流。我们现在将使用它们来改进我们的星系动画。
- en: Blinking
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闪烁
- en: 'The stars already look great and provide a real sense of movement in the game.
    We are going to enhance them by making them twinkle like real stars. To do this,
    we use the method `setTransparency()` to make the star completely *see-through*
    and use a delay variable to wait for a short period of time before making the
    star opaque again. We will use Greenfoot''s random number generator to ensure
    that the stars twinkle infrequently. First, we add a method call, `checkTwinkle()`,
    to the `act()` method in the `Star` class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 星星已经看起来很棒，并为游戏提供了真正的运动感。我们将通过让它们像真正的星星一样闪烁来增强它们。为此，我们使用`setTransparency()`方法使星星完全*透明*，并使用延迟变量等待一段时间后再将星星再次变得不透明。我们将使用Greenfoot的随机数生成器来确保星星的闪烁不频繁。首先，我们在`Star`类的`act()`方法中添加一个方法调用`checkTwinkle()`：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We need to add the following delay variable and the variable to hold the current
    transparency of the object at the top of the class under the declaration of the
    `speed` variable:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`speed`变量声明下添加以下延迟变量以及用于存储对象顶部当前透明度的变量：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is an implementation of `checkTwinkle()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`checkTwinkle()`的实现：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's look at the `else` part of the outer `if-else` statement. With a small
    random probability, we set `twinkleTime` (our delay variable) to `10`, save the
    current transparency of the star so that we can restore it later, and then set
    the transparency to `0`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看外部`if-else`语句的`else`部分。以很小的随机概率，我们将`twinkleTime`（我们的延迟变量）设置为`10`，保存星星当前透明度以便稍后恢复，然后将透明度设置为`0`。
- en: The `if` part of the initial `if-else` statement decrements `twinkleTime` if
    it is greater than `0` and restores the transparency of our star when `twinkleTime`
    equals `1`. Because `twinkleTime` is only set to `10`, the star will only be invisible
    for a very short period of time. This short flicker gives the illusion that the
    star twinkles.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 初始`if-else`语句的`if`部分，如果`twinkleTime`大于`0`，则递减`twinkleTime`，当`twinkleTime`等于`1`时恢复我们星星的透明度。因为`twinkleTime`只设置为`10`，所以星星将只在极短的时间内不可见。这种短暂的闪烁给人一种星星闪烁的错觉。
- en: Compile and run the scenario and see whether you can catch a star twinkling.
    If you have a hard time verifying this, change the frequency at which the twinkling
    occurs and try again.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行场景，看看你是否能捕捉到星星的闪烁。如果你在验证这一点上有困难，请改变闪烁发生的频率并再次尝试。
- en: Triggered events
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发事件
- en: Triggering a change in an actor when a certain event occurs is another way to
    do animation. For example, you might have an enemy actor that will only chase
    you when you get within a certain range. You might also have an actor respond
    to keyboard events or location.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个事件发生时触发演员的变化是另一种动画方式。例如，你可能有一个敌人演员，只有当你进入一定范围内时，它才会追逐你。你也可能有一个演员对键盘事件或位置做出响应。
- en: In this section, we are going to give our hero eyes. Obviously, our hero is
    very concerned with nearby enemies and definitely wants to keep an eye on them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将给我们的英雄添加眼睛。显然，我们的英雄非常关心附近的敌人，肯定想密切关注他们。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Adding animated eyes to an actor is a fantastic way to give that actor personality.
    Eyes are very expressive and can easily portray excitement, sadness, or fear.
    Never hesitate to add animated eyes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 给演员添加动画眼睛是赋予该演员个性的一种极好的方式。眼睛非常富有表情，可以轻松地表达兴奋、悲伤或恐惧。不要犹豫，添加动画眼睛。
- en: Adding eyes
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加眼睛
- en: This might seem a bit weird, but we are going to create a separate `Eye` actor.
    We are going to do this for a couple of reasons. First, to get the eyes to look
    around is going to take a fair amount of code. We can encapsulate this code in
    the `Eye` class and keep our `Avatar` class more streamlined. Second, having the
    eyes as separate entities means we could add them to future actors and they would
    still work even if we changed the image of the `Avatar` class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇怪，但我们将创建一个单独的 `Eye` 角色演员。我们这样做有几个原因。首先，要让眼睛四处看需要相当多的代码。我们可以将这段代码封装在
    `Eye` 类中，并使我们的 `Avatar` 类更加简洁。其次，将眼睛作为独立的实体意味着我们可以将它们添加到未来的演员中，即使我们改变了 `Avatar`
    类的图像，它们仍然可以正常工作。
- en: The alternative would be to create a skull image with eyes for every direction
    we would want to look. The fact that we have different images for our hero to
    show different levels of damage would further complicate matters. Therefore, we
    are going to create a separate `Eye` actor.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是为我们想要看的每个方向创建一个带有眼睛的头骨图像。我们为英雄创建不同图像以显示不同等级的伤害的事实将进一步复杂化问题。因此，我们将创建一个单独的
    `Eye` 角色演员。
- en: 'Create a new subclass of `Actor` called `Eye`. Do not associate an image with
    this `Actor` class. We will dynamically draw an image of an eye and redraw it
    appropriately when we need to look in a different direction. Here is the implementation
    of the `Eye` class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `Actor` 子类，命名为 `Eye`。不要将图像与这个 `Actor` 类关联。我们将动态绘制一个眼睛的图像，并在需要朝不同方向看时适当地重新绘制它。以下是
    `Eye` 类的实现：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The two main methods of this class are the `drawEye()` method and the `lookAtEnemies()`
    method. The `drawEye()` image uses the same methods to draw an eye that we used
    to draw the image of a star in the `Star` class. For an eye, we just need to draw
    one additional black circle to serve as the iris. The method `drawEye()` takes
    two integer parameters that provide the position of the iris in the eye. This
    offset portion of `fillOval()` was demonstrated in *Figure 3*. To summarize, the
    first `fillOval()` command draws the larger white part of the eye, and the second
    `fillOval()` command draws the small black iris at a given offset to simulate
    staring in a certain direction.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的主要有两个方法：`drawEye()` 方法和 `lookAtEnemies()` 方法。`drawEye()` 图像使用与我们在 `Star`
    类中绘制星星图像相同的方法来绘制眼睛。对于眼睛，我们只需要绘制一个额外的黑色圆圈作为瞳孔。`drawEye()` 方法接受两个整数参数，提供瞳孔在眼睛中的位置。`fillOval()`
    的偏移部分在 *图 3* 中进行了演示。总结来说，第一个 `fillOval()` 命令绘制了眼睛较大的白色部分，第二个 `fillOval()` 命令在给定的偏移量处绘制了小的黑色瞳孔，以模拟朝某个方向注视。
- en: 'The `lookAtEnemies()` method finds all enemies within a given distance of the
    eye and uses `drawEye()` to stare at the first enemy it finds. Using `if` statements
    to compare the *x* and *y* position of the enemy with its own position, the eye
    classifies the enemy as being in one of four quadrants: upper-left, lower-left,
    upper-right, and lower-right. Using this information, `drawEye()` is called with
    the integer parameters `(1,1)`, `(1,3)`, `(3,1)`, and `(3,3)`, respectively. *Figure
    8* demonstrates the correlation between the quadrant the enemy is in and the call
    to `drawEye()`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookAtEnemies()` 方法会在眼睛给定距离内找到所有敌人，并使用 `drawEye()` 方法注视它找到的第一个敌人。通过使用 `if`
    语句比较敌人的 *x* 和 *y* 位置与自己的位置，眼睛将敌人分类为四个象限之一：左上，左下，右上和右下。利用这些信息，`drawEye()` 方法分别使用整数参数
    `(1,1)`，`(1,3)`，`(3,1)` 和 `(3,3)` 被调用。*图 8* 展示了敌人所在的象限与 `drawEye()` 调用之间的相关性。'
- en: '![Adding eyes](img/image00273.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![添加眼睛](img/image00273.jpeg)'
- en: 'Figure 8: This shows the mapping between the position of the enemy and the
    call to drawEye()'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：这显示了敌人位置与调用 `drawEye()` 的映射
- en: 'In `lookAtEnemies()`, we used a new collision detection method called `getObjectsInRange()`.
    This method differs from `getOneIntersectingObject()` in two ways. First, instead
    of using the bounding box of the calling `Actor` class to determine whether a
    collision occurred, it draws a circle around the calling `Actor` class that has
    a radius of the size defined by the first parameter of `getObjectsInRange()`.
    This method returns all of the enemies found in that circle, instead of just one
    enemy. The enemies are returned in a Java `List` array. At the top of our `Eye`
    class, we need to include the code `import java.util.List;` to work with the `List`
    data type. We only have the ability to stare at one enemy at a time, so we choose
    to stare at the first enemy in this list using the method `get()` and passing
    it the integer value `0` to access it. Here''s Greenfoot''s documentation on `getObjectsInRange()`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `lookAtEnemies()` 中，我们使用了一种新的碰撞检测方法，称为 `getObjectsInRange()`。此方法与 `getOneIntersectingObject()`
    有两种不同之处。首先，它不是使用调用 `Actor` 类的边界框来确定是否发生碰撞，而是在调用 `Actor` 类周围绘制一个半径由 `getObjectsInRange()`
    的第一个参数定义的圆。此方法返回该圆中找到的所有敌人，而不仅仅是单个敌人。敌人以 Java `List` 数组的形式返回。在 `Eye` 类的顶部，我们需要包含
    `import java.util.List;` 代码以使用 `List` 数据类型。我们一次只能盯着一个敌人，所以我们选择使用 `get()` 方法并传递整数值
    `0` 来访问列表中的第一个敌人。以下是 Greenfoot 关于 `getObjectsInRange()` 的文档：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding line of code returns all objects within range `radius` around
    this object. An object is within range if the distance between its center and
    this object's center is less than, or equal to, `radius`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码返回围绕此对象半径为 `radius` 的所有对象。一个对象如果在范围内，意味着其中心与该对象中心的距离小于或等于 `radius`。
- en: 'The parameters of the the `getObjectsInRange()` methods are described as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`getObjectsInRange()` 方法的参数描述如下：'
- en: '`radius`: This is the radius of the circle (in cells)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radius`：这是圆的半径（以单元格为单位）'
- en: '`cls`: This is the class of objects to look for (passing `null` will find all
    objects)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cls`：这是要查找的对象的类（传递 `null` 将查找所有对象）'
- en: Giving our hero sight
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给我们的英雄赋予视力
- en: 'Now that we have an `Actor` class called `Eye`, we just need to make a few
    modifications to the `Avatar` class in order to add eyes to our hero. We need
    to create two eyes, place them on our hero, and then we need to make sure the
    eyes stay in place every time our hero moves. We start by adding instance variables
    to the `Avatar` class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为 `Eye` 的 `Actor` 类，我们只需要对 `Avatar` 类进行一些修改，以便为我们的英雄添加眼睛。我们需要创建两个眼睛，将它们放在我们的英雄身上，然后我们需要确保每次我们的英雄移动时眼睛都保持在原位。我们首先向
    `Avatar` 类添加实例变量：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then create and place those eyes on the skull image by adding this method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过添加此方法在头骨图像上创建并放置这些眼睛：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Initially, you might think that we could create the eyes and add them in the
    constructor method for `Avatar`. Normally, this would be an excellent location
    for code that is run once at creation time. The problem is that before we can
    add the eyes to the world, an instance of the `Avatar` class needs to be in a
    world. If we look at the code in `AvoiderWorld` that adds our hero, we see this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，你可能认为我们可以在 `Avatar` 类的构造方法中创建眼睛并添加它们。通常，这会是运行一次的代码的理想位置。问题是，在我们可以将眼睛添加到世界中之前，`Avatar`
    类的实例需要存在于一个世界中。如果我们查看 `AvoiderWorld` 中的代码，添加我们的英雄，我们会看到这个：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The creation of our hero is a two-step process. First, an instance of the `Avatar`
    class is created (the first line), and then we add this instance to the world
    (the second line). Notice that the constructor runs before that object is placed
    in a world, so we cannot access the instance of the world we are in via the method
    `getWorld()`. The developers of Greenfoot recognized that some actors will need
    to access the world they are in to complete their initialization, so they added
    the `addedToWorld()` method to the `Actor` class. The `Actor` class overrides
    this method when initialization requires world access, and it will be called by
    Greenfoot every time an actor is added to a world. We use this method in our `Avatar`
    class in order to place the eyes on our hero.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们英雄的创建是一个两步的过程。首先，创建`Avatar`类的一个实例（第一行），然后我们将这个实例添加到世界中（第二行）。注意，构造函数在对象放置到世界中之前运行，所以我们不能通过`getWorld()`方法访问我们所在的世界实例。Greenfoot的开发者意识到一些角色将需要访问它们所在的世界以完成初始化，因此他们在`Actor`类中添加了`addedToWorld()`方法。当初始化需要访问世界时，`Actor`类会重写此方法，并且每当一个角色被添加到世界中时，Greenfoot都会调用它。我们在`Avatar`类中使用此方法来将眼睛放置在我们的英雄身上。
- en: 'We have now created our eyes and added them to our hero. Now, we just need
    to ensure that the eyes stay with our hero whenever it moves. To do that, we add
    the following lines to our `followMouse()` function in the `Avatar` class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了眼睛并将它们添加到了我们的英雄身上。现在，我们只需要确保眼睛在英雄移动时始终伴随着它。为此，我们在`Avatar`类的`followMouse()`函数中添加以下几行代码：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code is added after the following line of code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码添加在以下代码行之后：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Why do the 10s and 8s in the `setLocation()` call `leftEye` and `rightEye`?
    These are the values that correctly place the eyes in the sockets of our hero.
    I determined these values through trial and error. *Figure 9* presents the details.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`setLocation()`调用中的10s和8s会对应`leftEye`和`rightEye`？这些是正确放置眼睛在英雄眼窝中的值。我是通过试错法确定这些值的。*图9*展示了详细信息。
- en: '![Giving our hero sight](img/image00274.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![赋予我们的英雄视力](img/image00274.jpeg)'
- en: 'Figure 9: This shows how the location of the eyes was determined'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：展示了眼睛位置是如何确定的
- en: It is now time to have some fun. Compile and run your game and enjoy the fruits
    of your labor. Your game should look like the screenshot shown in *Figure 10*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候享受乐趣了。编译并运行你的游戏，享受你的劳动成果。你的游戏应该看起来像*图10*中所示的截图。
- en: '![Giving our hero sight](img/image00275.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![赋予我们的英雄视力](img/image00275.jpeg)'
- en: 'Figure 10: Our game has animated enemies, a moving background star field (with
    twinkles), and a hero with eyes that visually changes when hit'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：我们的游戏有动画敌人、移动的背景星系（带有闪烁）以及当被击中时视觉上会变化的英雄
- en: Easing
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓动
- en: 'For our last major section of this chapter, we are going to look at using easing
    equations to move our actors around in interesting ways. Easing functions use
    easing equations to calculate position as a function of time. Just about every
    animation you''ve seen on the web, your mobile device, or in the movies uses easing
    at some point in time. We are going to add three new actors to our game that move
    according to three different easing functions: linear, exponential, and sinusoidal.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个大节中，我们将探讨使用缓动方程以有趣的方式移动我们的角色。缓动函数使用缓动方程来计算作为时间函数的位置。几乎你见过的每一个网页、移动设备或电影中的动画，在某个时间点都使用了缓动。我们将在游戏中添加三个新的角色，它们根据三种不同的缓动函数移动：线性、指数和正弦。
- en: Power-ups and power-downs
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速和减速
- en: Power-ups are an excellent way to add new challenges and balance player skill.
    Power-ups provide players with momentary boosts in speed, power, health, or some
    other game-related skill. They often appear randomly and might not be in the most
    convenient location, so they require players to make fast, real-time decisions
    where they have to weigh the risk of moving to the power-up versus its beneficial
    effects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 加速是添加新挑战和平衡玩家技能的绝佳方式。加速为玩家提供速度、力量、健康或其他与游戏相关的技能的短暂提升。它们通常随机出现，可能不在最方便的位置，因此需要玩家快速做出实时决策，权衡移动到加速器与它的有益效果之间的风险。
- en: Similarly, we can create randomly appearing game objects that negatively affect
    the player's ability to do well. I call these *power-downs*. They also require
    the player to make fast, real-time decisions, but now they are deciding between
    avoiding them and staying on their current trajectory and suffering the negative
    impact.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以创建随机出现的游戏对象，这些对象会负面影响玩家的表现。我称这些为*减弱效果*。它们也要求玩家做出快速、实时的决策，但现在他们需要在避开它们和保持当前轨迹并承受负面影响之间做出选择。
- en: We are going to add two new actors to our game that will be power-downs and
    one new actor that will be a power-up. All three of them will use easing for movement.
    We will first introduce a new `Actor` class that will contain all the common code
    for easing and being a power item (power-up or power-down.) Our power-ups and
    power-downs will inherit from this class. It is good object-oriented programming
    practice to use inheritance and polymorphism to write concise, flexible, and maintainable
    code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在游戏中添加两个新的角色作为减弱效果，以及一个新角色作为增强效果。所有这三个角色都将使用缓动进行移动。我们首先介绍一个新的`Actor`类，它将包含所有关于缓动和作为增强或减弱效果的公共代码。我们的增强和减弱效果将从这个类继承。使用继承和多态来编写简洁、灵活和可维护的代码是良好的面向对象编程实践。
- en: Base class
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基类
- en: 'Creating a well-thought-out base class for our power items will provide the
    means to easily create new power items and augment existing ones in the future.
    Before we talk about the code for our new class, we need to import a new Greenfoot-supplied
    class into our project, in the same way we imported the `Counter` class in [Chapter
    1](part0014.xhtml "Chapter 1. Let''s Dive Right in…"), *Let''s Dive Right in…*.
    The class we are going to import is `SmoothMover`. We need this class as it more
    accurately tracks the position of `Actor`. Here''s an excerpt from its documentation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的增强效果创建一个经过深思熟虑的基类将提供轻松创建新增强效果和增强现有效果的途径。在我们讨论新类的代码之前，我们需要将一个新的Greenfoot提供的类导入到我们的项目中，就像我们在[第1章](part0014.xhtml
    "第1章。让我们直接进入…")中导入`Counter`类一样，*让我们直接进入…*。我们将导入的类是`SmoothMover`。我们需要这个类，因为它更准确地跟踪`Actor`的位置。以下是其文档的摘录：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To import this class, click on **Edit** in Greenfoot's main menu and then click
    on **Import Class…** in the drop-down menu that appears. In the **Import Class**
    window that appears next, select `SmoothMover` on the left-hand side and then
    click on the **Import** button.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入这个类，请点击Greenfoot主菜单中的**编辑**，然后在出现的下拉菜单中点击**导入类…**。在随后出现的**导入类**窗口中，在左侧选择`SmoothMover`，然后点击**导入**按钮。
- en: Now that we have `SmoothMover` in our project, we can create the `PowerItems`
    class. Right-click `SmoothMover` and choose **New subclass…**. You will not need
    to associate an image with this class, so choose **No Image** in the **Scenario
    Images** section in the **New class** window.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在项目中有了`SmoothMover`，我们可以创建`PowerItems`类。右键点击`SmoothMover`并选择**新建子类…**。您不需要为此类关联图像，因此在**场景图像**部分选择**无图像**。
- en: 'Let''s take a look at the implementation of `PowerItems` (our new base class
    for power-ups and power-downs):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`PowerItems`（我们为增强和减弱效果而创建的新基类）的实现：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We first need to discuss all the instance variables of this class. There are
    seven of them. Two of them are used to track the starting coordinates (`origX`
    and `origY`) and two of them are used to track the ending coordinates (`targetX`
    and `targetY`). The instance variable `expireTime` specifies how many calls of
    the `act()` method this actor should execute before removing itself. In other
    words, it specifies the lifespan of the actor. The `duration` instance variable
    simply saves the initial value of `expireTime`. The `expireTime` variable is continually
    decremented until it reaches a value of 0, but we need to know its original value
    for our easing equations. The `counter` variable records how many times this actor
    has moved. *Figure 11* shows these variables pictorially.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要讨论这个类的所有实例变量。共有七个。其中两个用于跟踪起始坐标（`origX`和`origY`），另外两个用于跟踪结束坐标（`targetX`和`targetY`）。实例变量`expireTime`指定这个演员在移除自己之前应该执行多少次`act()`方法的调用。换句话说，它指定了演员的生命周期。`duration`实例变量简单地保存`expireTime`的初始值。`expireTime`变量会不断递减，直到达到0，但我们需要知道其原始值用于缓动方程。`counter`变量记录这个演员移动了多少次。*图11*展示了这些变量的图形表示。
- en: '![Base class](img/image00276.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![基类](img/image00276.jpeg)'
- en: 'Figure 11: This shows the meaning of the instance variables in PowerItems graphically'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：此图以图形方式展示了PowerItems中实例变量的含义
- en: The instance variables are initialized in the constructor except for `origX`
    and `origY`, which are initialized in the method `addedToWorld()` (the purpose
    of this method was discussed earlier in this chapter), so that we can set them
    to the current *x* and *y* location of the actor.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量在构造函数中初始化，除了`origX`和`origY`，它们在`addedToWorld()`方法中初始化（该方法在本章前面已经讨论过），这样我们就可以将它们设置为actor当前的*x*和*y*位置。
- en: Because of our judicious use of functional decomposition, the `act()` method
    is straightforward to understand. First, it moves the actor by calling `easing()`.
    Next, `checkHitAvatar()` is called to see if it collided with our hero. This method
    is `abstract`, which means its implementation is left to subclasses of this class.
    This is done because each subclass will want to apply its own unique effect on
    our hero if they did collide. Last, it checks to see whether the `act()` method
    has been called `expireTime` times. If so, `PowerItem` has had its desired lifespan,
    and it's time to remove it. We will talk about the specific implementation of
    `easing()`, `checkHitAvatar()`, and `checkExpire()` next.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们明智地使用了功能分解，`act()`方法很容易理解。首先，它通过调用`easing()`来移动actor。接下来，调用`checkHitAvatar()`来查看它是否与我们的英雄发生了碰撞。这个方法是`abstract`的，这意味着它的实现留给这个类的子类。这样做是因为每个子类都希望在它们发生碰撞时对我们的英雄应用其独特的效果。最后，它检查`act()`方法是否被调用`expireTime`次。如果是这样，`PowerItem`已经达到了其期望的生命周期，是时候移除它了。我们将在下一节讨论`easing()`、`checkHitAvatar()`和`checkExpire()`的具体实现。
- en: The `easing()` method is really the key method of this class. It contains a
    generic form of an easing equation that is flexible enough to allow us to define
    many different types of interesting movements. The method moves the actor some
    fraction of the way between the starting point and the endpoint. It starts by
    calculating the percentage of the distance we need to travel at this point in
    time between the origin value and the target value in the *x* direction and a
    similar calculation for the *y* direction and saves those values in the local
    variables `fX` and `fY`, respectively. Next, we use the `curveX()` and `curveY()`
    functions to manipulate these percentages, and then we use those percentages in
    a call to `setLocation()`. As with `checkHitAvatar()`, `curveX()` and `curveY()`
    are `abstract`, as their details depend on the classes that subclass from `PowerItems`.
    We'll discuss the `abstract` methods `checkHitAvatar()`, `curveX()`, and `curveY()`,
    as well as provide a detailed example in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`easing()`方法实际上是这个类的关键方法。它包含了一个缓动方程的通用形式，足够灵活，允许我们定义许多不同类型的有趣运动。该方法将actor移动到起点和终点之间的一定比例的位置。它首先计算在当前时间点，我们需要在*x*方向上从原始值到目标值之间移动的距离的百分比，以及*y*方向上的类似计算，并将这些值分别保存在局部变量`fX`和`fY`中。接下来，我们使用`curveX()`和`curveY()`函数来操纵这些百分比，然后我们使用这些百分比在调用`setLocation()`时。与`checkHitAvatar()`一样，`curveX()`和`curveY()`也是`abstract`的，因为它们的细节取决于从`PowerItems`派生的类。我们将在下一节讨论`abstract`方法`checkHitAvatar()`、`curveX()`和`curveY()`，并提供一个详细的示例。'
- en: Before that, let's look quickly at the last method in the `act()` method of
    `PowerItems`. The last method, `checkExpire()`, simply removes the actor when
    `expireTime` reaches 0.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，让我们快速看一下`PowerItems`的`act()`方法中的最后一个方法。最后一个方法`checkExpire()`，当`expireTime`达到0时，简单地移除actor。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Abstract classes**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象类**'
- en: Abstract classes are an effective way to share code and instance variables between
    several related classes. In the abstract class, you implement as much code as
    you can without needing specific knowledge that would be contained in a child
    class (subclass). For us, the class `PowerItems` is an abstract class that contains
    the code common to all of our power-ups and power-downs. Visit [http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html](http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html)
    for more information on abstract classes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是共享几个相关类之间代码和实例变量的有效方式。在抽象类中，你可以实现尽可能多的代码，而不需要包含在子类（子类）中的特定知识。对我们来说，`PowerItems`类是一个抽象类，它包含了我们所有增强和减弱的通用代码。有关抽象类的更多信息，请访问[http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html](http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html)。
- en: Linear easing
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性缓动
- en: The first power-down we are going to add to the game is one that temporarily
    stuns our hero if touched. Keeping with our game's motif, where good things (smiley
    faces) are bad, we will make our new power-down look like a cupcake. To create
    our new `Actor`, right-click `PowerItems` in the **Actor classes** section of
    Greenfoot's main scenario window, and select **New subclass…** from the menu that
    appears. Name the class `Cupcake` and choose the image of the muffin (it looks
    like a cupcake to me!) located in the **food** category.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `Cupcake` class in an editor window, and make it look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Because we are inheriting from the code from `PowerItems`, `Cupcake` is pretty
    short and concise. The constructor for this class merely passes its parameters
    to the constructor in `PowerItems`. Since `PowerItems` is an abstract class, we
    need to implement the abstract methods in `PowerItems` (`curveX()`, `curveY()`,
    and `checkHitAvatar()`) here.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The `Cupcake` class is going to be our example of *linear easing*. It will move
    in constant, linear steps from the starting position to the ending position. Because
    it is linear, our `curveX()` and `curveY()` methods are extremely simple. They
    don't change the input parameter at all.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear easing](img/image00277.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: This is an example showing how instances of the Cupcake class move
    linearly across the screen'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the example shown in *Figure 12*. In this example, `Cupcake`
    was called with the target location **(150, 100)** and an expire time of `4` and
    was added to the world at the location **(10,10)**. Location **(a)** shows the
    initial values of the object. Locations **(b)**, **(c)**, **(d)**, and **(e)**
    show the values associated with the object after one, two, three, and four `act()`
    method calls, respectively. As we can see, this actor moves in a straight line.
    To better understand linear easing, let''s discuss why the values are as shown
    at location **(b)**. After initialization (shown at location **(a)**), the functions
    in the `act()` method (inherited from `PowerItems`) are called. The `easing()`
    method sets `counter` to 1 and then sets `fX` and `fY` to 0.25, as shown in this
    code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `curveX()` and `curveY()` methods in `Cupcake` do not alter `fX` and `fY`.
    For the given values, the first parameter to `setLocation()` has a value of 45
    *((150 * 0.25) + (10 * 0.75))* for its first parameter and 32.5 *((100*0.25) +
    (10 * 0.75))* for its second parameter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: After `easing()`, the next method called in the `act()` method is `checkHitAvatar()`.
    This method simply invokes the method `stun()` on an instance of `Avatar` (our
    hero) if it collides with it. The `stun()` method will be shown after all the
    power-ups and power-downs have been discussed. At this time, we will show all
    the changes needed to the `Avatar` class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Exponential easing
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have discussed most of the theory behind power-ups and power-downs,
    we can quickly discuss the remaining ones. The next actor we are going to add
    is a power-up. It will heal our hero from some of the damage sustained. Given
    the motif of our game, this beneficial actor will have to look bad. We will make
    it a rock.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: To create our new `Actor` class, right-click on `PowerItems` in the **Actor
    classes** section of Greenfoot's main scenario window and select **New subclass…**
    from the menu that appears. Name the class `Rock` and choose the image `rock.png`
    located in the **nature** category.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `Rock` class in an editor window and change it to this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The two main differences between the `Cupcake` class and the `Rock` class are
    the implementation of `curveY()` and the fact that `checkHitAvatar()` calls `addHealth()`
    instead of `stun()`. We will describe `addHealth()` later, as mentioned earlier.
    The changes in `curveY()` give this actor a curved directory by cubing the value
    it is given. The effect of this is demonstrated in the example shown in *Figure
    13*. Compare the changes in the *y* position for each location. The *y* value
    grows exponentially. First, it only moves 1.4 pixels (from location **(a)** to
    location **(b)**) and in the end, jumps approximately 52 pixels (from location
    **(d)** to location **(e)**).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![Exponential easing](img/image00278.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: This is an example showing how instances of the Rock class move
    exponentially in the y direction across the screen'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Sinusoidal easing
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last power-down we are adding is `Clover`. It will slow our hero down for
    a short time and employ *sinusoidal easing*. To create this class, right-click
    on `PowerItems` in the **Actor classes** section of Greenfoot''s main scenario
    window and select **New subclass…** from the menu that appears. Name the class
    `Clover` and choose the image of the `shamrock` located in the **nature** category.
    Open it in an editor window and change it to this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Like the `Rock` class, the `Clover` class does something unique in its `curveY()`
    method. It imports Java's math library at the top of the class and uses `Math.sin()`
    in its implementation of `curveY()`. This makes the *y* motion oscillate like
    a sine wave.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In `Clover`, `checkHitAvatar()` calls `lagControls()`on the instance of the
    `Avatar` class it collided with, instead of `stun()` or `addHealth()`. In the
    next section, we will implement `stun()`, `addHealth()`, and `lagControls()` in
    the `Avatar` class.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the Avatar class
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To accommodate the effects of our new power items, the `Avatar` class needs
    to implement a few methods and change some existing ones. These methods are `stun()`,
    `addHealth()`, and `lagControls()`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's an extra challenge before continuing ahead in the chapter. Try to implement
    these methods yourself. Think each one through and rough them out on paper. The
    worst case scenario for attempting this is that you learn a lot.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementations of `stun()` and `lagControls()` involves adding delay variables
    and using them to affect movement. In the `Avatar` class, all movement is handled
    in the `followMouse()` method. To stun our hero, we only need to disable the `followMouse()`
    method for a small period of time. Here is how we would change this method:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We also need to define the `stunDelay` instance variable at the top of the
    class:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This follows the pattern of usage for the instance variable `hitDelay` we added
    at the beginning of this chapter. It was our example of a delay variable. Now,
    we implement `stun()`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Every time `stun()` is invoked, the `followMouse()` method will not work for
    50 cycles (calls of the `act()` method).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `lagControls()` is similar, except that we need to temporarily
    change the movement, instead of blocking it. Again, we need to change the `followMouse()`
    method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s first add the instance variable `lagDelay` and then talk about how it
    is used in `followMouse()`. Add this line at the top of the class under `stunDelay`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'While `lagDelay` is a value greater than 0, it will implement the laggy controls.
    In the inner `if-else` statement in the above method, the lag is implemented by
    only moving our hero one-fortieth of the way to the location of the mouse. This
    makes our hero slowly crawl towards the location of the mouse. The delay variable,
    `lagDelay`, is decremented until it is less than 0\. How does it get above 0?
    It is set in the `lagControls()` method called by the `Clover` class. Here is
    the code for that method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'All we need to do now is implement the `addHealth()` method. Here is the code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method simply undoes the damage that occurs when we hit an enemy. This
    method does nothing if we are already at full health; otherwise, it increments
    the `health` instance variable, decrements `nextImage`, so that it stays in sync
    with the image we are displaying, and sets the image of the `Avatar` to the previous,
    less damaged image. Pretty cool!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'We made some substantial changes to the `Avatar` class. Here is its code in
    its entirety:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We are so close to trying all this out. We just need to randomly create and
    add the power-ups and power-downs in the `AvoiderWorld` class.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the AvoiderWorld class
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to create three new instance variables at the top of the `AvoiderWorld`
    class to specify the probability we use to generate one of our new power items.
    Add these lines of code under the declaration and initialization of `nextLevel`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Initially, the creation of these items will not be very frequent, but we will
    change that by incrementing them in the `increaseLevel()` function. Here is the
    code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the `act()` method, we call a function to generate enemies and another to
    generate stars. Following this pattern, add this line to the `act()` method:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Because all of the power item classes inherits from `PowerItems`, we can use
    polymorphism to write some pretty concise code. Here is the implementation of
    `generatePowerItems()`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It''s pretty nice that we can use one method to create our new power items—`generatePowerItem()`.
    This method takes an integer describing the type of power item we want to create
    and a frequency to generate those particular items. Here''s the implementation:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This method looks a lot like our other methods that generate actors. It will
    generate an item at a given random rate and place those items to emerge from either
    the left or the right of the screen towards a randomly generated place in the
    interior of the screen. The local variable `targetX` will be any valid *x* coordinate
    on the screen, except for a `40` pixel wide border on the left and right of the
    screen. We just want to ensure that it travels long enough to be seen and that
    it has an impact on the game. The variable `targetY` has slightly tighter constraints.
    We only want to generate a *y* value in the upper half of the screen, plus an
    initial `20` pixels to prevent the actor from traveling too close to the top of
    the screen. The inner `if-else` statement simply chooses from placing the object
    either on the left or the right of the screen for its initial location.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'The real difference here, from how we generated other actors, is the call to
    `createPowerItem()`. Since we are using this method to generate any one of three
    power items, we can''t hardcode the creation of a specific item, such as, `new
    Cupcake();`. We use `createPowerItem()` to create the right object that matches
    the type parameter of `generatePowerItems()`. Here''s the implementation of `createPowerItem()`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This method creates a new `Cupcake`, `Clover`, or `Rock` power item based on
    type.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: We have really added a lot to this game, and now it's time to compile and test
    it out. Normally, you would not want to add this much code without testing small
    parts along the way. For example, we could have just implemented the `Rock` power-up
    completely and tested it before adding the other power items. For pedagogical
    reasons, it made sense to continue in the manner we did. I hope you don't encounter
    too many typos when you compile your code. By methodically checking your code
    against the code in this chapter and paying close attention to the compile error
    messages, you should be able to eliminate any mistakes quickly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to refresh yourself on how a Java switch statement works, refer
    to the following link:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Compile, debug, and play. This game is getting good. Check out my screenshot
    in *Figure 14*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![Changes to the AvoiderWorld class](img/image00279.jpeg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: Here''s Avoider Game complete with power-ups, power-downs, and all
    sorts of bling'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Avoider Game
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Avoider Game is getting more complete and fun to play. In [Chapter 5](part0034.xhtml
    "Chapter 5. Interactive Application Design and Theory"), *Interactive Application
    Design and Theory*, we will look at game design theory on how to build fun and
    engaging games. At that time, we will revisit our game and increase its playability.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的避免者游戏变得越来越完整，玩起来更有趣。在[第五章](part0034.xhtml "第五章. 交互式应用设计理论")《交互式应用设计理论》中，我们将探讨游戏设计理论，了解如何构建有趣且引人入胜的游戏。那时，我们将重新审视我们的游戏并提高其可玩性。
- en: Your assignment
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的作业
- en: When an `Avatar` object is hit, it is invulnerable to being hit again for a
    short time. Unfortunately, we have provided no visual feedback to the player that
    indicates this is happening or when it expires. Your assignment is to make the
    hero blink while it cannot be hit. Look at the `Star` class for a hint on how
    to make an object blink.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个`Avatar`对象被击中时，它会在短时间内对再次被击中免疫。不幸的是，我们没有为玩家提供任何视觉反馈来指示这一事件的发生或何时结束。你的任务是让英雄在不能被击中时眨眼。查看`Star`类以获取如何使对象眨眼的提示。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of material in this chapter. You learned several important
    techniques for animating actors, including image swapping, delay variables, parallax,
    and easing. Our enemies, our hero, and the background, all have more life. You
    should use all the techniques of this chapter when creating games, simulations,
    animated shots, or educational applications.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。你学习了几个重要的动画角色技术，包括图像交换、延迟变量、视差和缓动。我们的敌人、我们的英雄和背景都更加生动。你应该在创建游戏、模拟、动画镜头或教育应用时使用本章的所有技术。
