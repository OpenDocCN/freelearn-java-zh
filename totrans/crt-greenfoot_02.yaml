- en: Chapter 2. Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Study without desire spoils the memory, and it retains nothing that
    it takes in."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Leonardo da Vinci* |'
  prefs: []
  type: TYPE_TB
- en: It is fairly simple to move actors around in Greenfoot scenarios by handling
    keyboard or mouse events and using `setLocation()` appropriately. However, we
    can do better. By animating our actors further, we can breath life into them.
    We can give our players/users the illusion of a vibrant, living world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, programming animation is the art of illusion. By adding small movements
    or image changes at the right time, we beguile our users into believing our creations
    are more than just static pixels on a screen. In this chapter, you will learn
    the following techniques for animating Greenfoot actors:'
  prefs: []
  type: TYPE_NORMAL
- en: Image swapping and movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timing and synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greenfoot is a wonderful platform for creating interactive and engaging applications
    that you can share on the Internet or use as a desktop application. It is your
    desire to create these types of applications that brought you here, and, according
    to Leonardo da Vinci, it is that desire that will help you retain the information
    in this book indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting Avoider Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to continue to work on Avoider Game, which we
    created in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's
    Dive Right in…*. If you skipped that chapter, or just prefer to start off with
    a fresh copy, you can download the code for this game from this book's product
    page on the Packt Publishing website at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    Any concepts I gloss over in this chapter were most likely covered in detail in
    the previous chapter; be sure to refer to that chapter as needed. Now, open the
    `AvoiderGame` scenario in Greenfoot and read on.
  prefs: []
  type: TYPE_NORMAL
- en: Image swapping and movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image swapping is the age-old technique for animating. Perhaps as a child, you
    drew a stick figure in the corner of a pad of paper and slightly changed it on
    every succeeding page. When you rapidly flipped through the pages, your stick
    figure came to life. *Figure 2* shows my attempt at this type of animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image swapping and movement](img/image00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: This shows old-school stick figure animation'
  prefs: []
  type: TYPE_NORMAL
- en: In Greenfoot, we are going to animate actors by rapidly switching between images
    and achieve the same effect as the paper animation shown in *Figure 1*. We will
    learn how to use Greenfoot's `setImage()` method to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Using setImage()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we create a new `Actor` in Greenfoot by subclassing from the `Actor` class,
    or one of our subclasses of `Actor`, Greenfoot prompts us to enter in the name
    of our new class and to select an image for it. Greenfoot also allows us to dynamically
    set the image of our `Actor` objects while the scenario is running, using the
    method `setImage()`provided by Greenfoot''s `Actor` class. The following is an
    excerpt from Greenfoot''s documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `setImage()` allows us to set an image of an actor by specifying
    the path to any `JPEG`, `GIF`, or `PNG` file. By default, Greenfoot looks in the
    `images` folder contained in your Greenfoot project. You should place all images
    you are going to use in your scenario in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use this method to animate the enemies in Avoider Game.
  prefs: []
  type: TYPE_NORMAL
- en: Making enemies less happy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The enemies in Avoider Game are just too happy. Let's animate them to get sad
    and disappointed, as they realize that our hero is going to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Finding assets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first thing we need to do, is to find a set of appropriate smiley images
    that we can switch to for our `Enemy` actor in our scenario. Often, you''ll need
    to create your own image assets using Greenfoot''s built-in image editor, or tools
    such as GIMP or Adobe Illustrator, or you could download images from the Internet;
    there are plenty of free images available. Luckily, the default installation of
    Greenfoot already contains all the images we need. On OSX, the images are in the
    following folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, the images are in the following folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For your convenience, I have made all the smiley images available in this book's
    file repository on the Packt Publishing website at [https://www.packtpub.com/sites/default/files/downloads/0383OS_ColoredImages.pdf](https://www.packtpub.com/sites/default/files/downloads/0383OS_ColoredImages.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to place the files `smiley1.png`, `smiley3.png`, `smiley4.png`,
    and `smiley5.png` into the `images` folder in your `AvoiderGame` directory. After
    doing this, your images folder should contain the files shown in *Figure 2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding assets](img/image00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: These are the contents of the images folder in your AvoiderGame project.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our images available to us, we can start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that once you set an actor's image to one provided by Greenfoot at creation
    time, such as `skull.png` in *Figure 2*, Greenfoot automatically places the image
    in your `images` folder. So, instead of copying the smiley images from their location
    on the disk, you could have created a new actor and then set the image of this
    actor to be each of the smiley faces in turn. Then, you could just delete this
    new actor. You will see that your images folder will look like that shown in *Figure
    2*.
  prefs: []
  type: TYPE_NORMAL
- en: Calling setImage() based on Actor location
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Double-click on the `Enemy` actor in the **Actor classes** section of Greenfoot''s
    main scenario window to begin editing the `Enemy` code. We practice good functional
    decomposition and simply add a call to `changeDispositon()` in the `act()` method
    of `Enemy`; we will write that method soon. Your `act()` method should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will implement the `changeDisposition()` method. In this method, we
    want to change the disposition of the enemies, as they slowly realize they will
    not get the hero. Let's presume our enemies remain optimistic until they reach
    the middle of the screen. After that, we will slowly have them succumb to despair.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the implementation of `changeDisposition()`, we are going to use an instance
    variable to keep track of what image we need to display next. You need to add
    this variable *declaration* and *initialization* right below the declaration of
    the speed instance variable (at the top of the class outside of any method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, we can now view the implementation of `changeDisposition()`.
    The following is our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic behind this code is simple. We want to pick specific locations in
    the downward motion of the enemy to change the image. One complication is that
    the enemy''s speed can be changed through the `setSpeed()` method. We use this
    method in the `AvoiderWorld` class to increase the speed of the enemy, so as to
    increase the difficulty of the game. So, we cannot simply change the image of
    the enemy with code such as `if( ypos == 300)` because the actor might never have
    a *y* position of exactly `300`. For example, if the enemy''s speed was 7, then
    it would have the following *y* positions as it went down: 7, 14, 21, …, 294,
    301, 308, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the enemy never has a *y* position of exactly 300\. You might
    next want to try code such as `if( ypos > 300 )`; however, this is suboptimal,
    as this will cause the image to *continually be set for every y position it has
    over 300*. Therefore, we should take the approach demonstrated in `changeDisposition()`
    and use `timeToChange` to control a one-time, sequential image change.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the logic behind `changeDisposition()`, let's go over
    it line by line. The first thing we do is create variables to hold the positions
    where we want to change the image of the enemy. These positions are based on the
    height of the scenario; `marker1` is at 50 percent of this height, `marker2` is
    at 75 percent of this height, and `marker3` is at a position slightly before the
    enemy exits off the bottom of the screen. The `if` statements test for two conditions
    before changing the image of the actor. It checks to see whether to use `timeToChange`
    to that specific image and whether the actor has passed a given *y* position.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous code, there are lines that convert a decimal number (of type
    `double`) into a whole number (of type `int`), such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information on converting one variable into another (also called casting),
    refer to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html](http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile your Greenfoot scenario and play the game. See if you can get a score
    greater than 250! *Full disclosure: after writing that last sentence I played
    the game four times in a row and got the following scores: 52, 33, 28, 254\. Woot!
    254!*'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Functional decomposition**'
  prefs: []
  type: TYPE_NORMAL
- en: Functional decomposition is closely related to the top-down design, a process
    of repeatedly redefining the problem in terms of smaller, less complex subproblems.
    When you are writing code for a specific action or functionality in your program,
    try to think of smaller methods you could write that you could compose to solve
    the larger issue.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you would like to write methods that contain less than 40 lines of
    code and which only implement one well-defined task. I actually prefer to go much
    smaller when possible. You'll find code is easier to write, debug, and modify
    if you follow this practice. In this book, I use functional decomposition. You'll
    notice that the `act()` methods throughout the book mainly contain a sequence
    of calls to other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using setLocation()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method `setImage()` is by far the most useful Greenfoot method for animating
    actors; however, moving an actor in certain ways can also produce interesting
    effects. We already use `setLocation()` to move both the enemies and our hero;
    let's use it now to animate the background star field to make it seem like we
    are flying through space.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a star field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our star field is going to provide various sized stars moving in the background
    at various speeds, to produce the effect of moving through space at high speed.
    Creating a star field is very simple and we have already written very similar
    code. Imagine that our enemies had the image of a small speck of light, instead
    of a smiley face and we had many more of them. Voila! You have a star field.
  prefs: []
  type: TYPE_NORMAL
- en: A blank slate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we are going to create our own dynamic star field, then we no longer need
    the current background image associated with `AvoiderWorld`. However, if we change
    this class to have no image associated with it, then we will get a white background—not
    a very good representation of outer space.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to create a new pure black, 600 x 400 pixel image and then select
    that as the background image for the `AvoiderWorld` class. Start up your favorite
    image editor or use Greenfoot's built-in editor, create a big black rectangle,
    save it as a PNG file in your **Avoider** project's `images` folder, and then
    set `AvoiderWorld` to use this new image as the background.
  prefs: []
  type: TYPE_NORMAL
- en: The Star class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For our stars, we are going to do something a little different. Instead of setting
    the image of the star to a file containing a graphic, we are going to dynamically
    draw the image. This will be easy to do since a speck of light is not very complicated.
  prefs: []
  type: TYPE_NORMAL
- en: To create our star actor, right-click on the `Actor` class in the **Actor classes**
    section and choose **New subclass…**. In the **New class** window that pops up,
    enter `Star` as **New class name** and choose **No image** as **New class image**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, we went over how to create new actors in [Chapter 1](part0014.xhtml
    "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up a code editor window for your new `Star` class and add the following
    constructor to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor dynamically creates an image to use for the image of our `Star`
    class. First, we create a new image that has a width of `10` pixels and a height
    of `10` pixels. Next, we set the color to use for any drawing we do in this image.
    We gain access to the `Color` class (see the information box below to learn more
    about it) by adding the following `import` statement at the top of our class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After setting the color, we draw an oval using the `fillOval()` method. The
    first two parameters of `fillOval()` specify the offset of the upper-left corner
    of the shape we are drawing from the offset of the upper-left corner of our image.
    *Figure 3* displays this mapping. The next two parameters of `fillOval()` specify
    the width and height of the bounding box containing our oval. Since our width
    and height are the same, `fillOval()` will draw a circle. Finally, we set the
    image of our actor to be the new image we just created.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Star class](img/image00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: This shows the effect of using values of 8 and 5 for the first two
    parameters of fillOval()'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Working with color**'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Star()` constructor, we do an operation that involves color. There are
    several different ways to represent color on computers (and basically anything
    with a screen), and we are going to use an RGBA color model. If you are curious,
    you can read more about it at [http://en.wikipedia.org/wiki/RGBA_color_space](http://en.wikipedia.org/wiki/RGBA_color_space).
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we don't have to know much about the theory. Java provides a class—`Color`—that
    manages most of the complexity for us. To get this `Color` class into your code,
    you need to have an `import` statement at the top of the file. The import statement
    is `import java.awt.Color;`. If you don't add this to the code above, you'll get
    compile errors.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about this `Color` class, look at the official documentation at
    [http://docs.oracle.com/javase/7/docs/api/java/awt/Color.html](http://docs.oracle.com/javase/7/docs/api/java/awt/Color.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do to our `Star` class, is fill in the `act()` method. We
    just need to slowly move this actor down the screen and then remove it once it
    has exited off the bottom of the screen. We use `setLocation()` to do the former
    and the `checkRemove()` method to do the latter. The following is the completed
    code for both `act()` and `checkRemove()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkRemove()` method is exactly the same code as the one used in the
    `Enemy` class and explained in [Chapter 1](part0014.xhtml "Chapter 1. Let''s Dive
    Right in…"), *Let''s Dive Right in…*. In fact, there are many similarities between
    the `Star` class and the `Enemy` class, so much so, that I think we should pre-emptively
    add the `setSpeed()` method the `Enemy` has to the `Star` class, as it is very
    likely we will need it later in our implementation of a moving star field. Add
    this method to the `Star` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we did in the `Enemy` class, we need to add the instance variable `speed`
    at the top of the class. Here''s the code for the variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We should make one more change in the `act()` method to now use the `speed`
    variable to move `Star` objects. Change the `setLocation()` code in the `act()`
    method to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for the `Star` class is shown in *Figure 4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Star class](img/image00268.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: This shows the completed Star class implementation'
  prefs: []
  type: TYPE_NORMAL
- en: This would be a great time to compile the scenario and make sure you do not
    have any spelling errors. We have not added any stars to our game, so you will
    not notice any difference in the game. Adding stars is what we are going to do
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a moving field
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will generate our stars in the `AvoiderWorld` class. Open the editor window
    for this class and add a line of code to the `act()` method to call the method
    `generateStars()`, which we haven''t written yet, but will soon. Your `act()`
    method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `generateStars()` method creates new stars in a way similar to how `generateEnemies()`
    creates new enemies. Here is the code for `generateStars()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement determines whether or not we want to create a star at this
    point in time. With a 35 percent probability, we will create a star, which ultimately
    creates a fairly dense star field. Inside the `if` statement, we create a new
    `Star` object and add it to the `World`. Add this code and compile and run the
    game, and see what you think. Do you like the stars? They're OK, but it looks
    a little more like it's raining golf balls. We can do better.
  prefs: []
  type: TYPE_NORMAL
- en: Using parallax
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Parallax is the effect that closer objects seem to be in different positions
    relative to farther objects based on the viewing angle. For example, if you have
    ever looked out of a car window and watched trees go by, you'll notice that the
    trees closer to you seem to move faster than the trees in the background. We can
    use this phenomenon to give the illusion of depth to our star field.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change our `generateStars()` method to create two types of stars. Some
    will be near and some will be far. Nearer stars will move faster and be brighter
    than stars that are further away, but we will generate more stars that are far
    away. If you imagine our screen as a window out into space, we will have a wider
    view of objects that are far away, as opposed to close by. Therefore, we need
    more of them. *Figure 5* illustrates this point.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using parallax](img/image00269.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: This demonstrates that you have a wider field of view for objects
    that are further away when looking through a window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to add some random variation in the stars, so that the resulting
    star field does not look too uniform. Here''s our parallax-augmented `generateStars()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have added accessing the current image of the star, changing the image, and
    then setting it to be the new image for the star. The inner `if-else` statement
    handles the changes for nearby and faraway stars. With a 30 percent chance, the
    star will be a near one. Nearby stars are faster (`setSpeed()`), brighter (`setTransparency()`),
    and larger (`scale()`).
  prefs: []
  type: TYPE_NORMAL
- en: The `setTransparency()` method accepts one integer parameter that specifies
    how *see-through* the image is. You would enter in the value `255` for a completely
    opaque object and 0 for a completely transparent object. We make stars that are
    far away more transparent so that more of the black background will come through
    and make it less bright. The `scale()` method on `GreenfootImages` changes the
    size of the image, so that it fits into the bounding box defined by the first
    two parameters of this method. As we can see in the code, nearby stars are scaled
    to fit into a 4 x 4 pixel image and stars further away are scaled to fit into
    a 2 x 2 pixel image.
  prefs: []
  type: TYPE_NORMAL
- en: We are so close to finishing our star field. Compile and run the scenario and
    see what you think of it up to now.
  prefs: []
  type: TYPE_NORMAL
- en: The star field is looking great, but there are still two problems. First, when
    the game starts, the background is completely black, and then stars start to fall.
    To really keep the illusion that you are in space, we need the game to start in
    a field of stars. Second, the stars are being generated over the enemies, our
    hero, and the score counter; this really wrecks the illusion that they are far
    away. Let's fix this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving the issue that the stars are in front of other actors on the screen
    is a one-liner. Here''s the line of code you need to add to the constructor in
    `AvoiderWorld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `setPaintOrder()`method is defined in the `World` class that `AvoiderWorld`
    subclasses. This method allows you set the order of classes displayed on the screen.
    So, we list the `Avatar` class first (it will be at the top of everything), then
    the `Enemy` class, and last the `Counter` class. With this ordering, for example,
    our enemies will be displayed above the score. Any class not listed will be drawn
    behind all the ones listed; therefore, our stars will be behind all actors on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing the initial field of stars is easy if we make a small change to the
    `generateStars()` method. Presently, our stars are hardcoded to start with a *y*
    coordinate of `-1` because of this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we change `generateStars()` to take one integer parameter that specifies
    the *y* value to draw the star at, then we can use this method to create the initial
    star field. Take the first line of `generateStars()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the last line of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These two line changes allow us to specify any starting *y* value for our stars.
    Because of this change, we need to change the call to `generateStars()` in our
    `act()` method to the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and run the scenario, the only difference you should see is
    that the stars are now truly in the background. We still need to add one simple
    method definition and call to draw the initial star field. The method definition
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the height of our game is four hundred, then this method calls `generateStars()`
    four hundred times. Each time, it supplies a different *y* value to draw stars
    on. We will fill up the screen with stars by adding this line to our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have made a lot of changes to the `AvoiderWorld` class definition, making
    it increasingly likely that you may have put code in the wrong place. Here is
    the full listing of the `AvoiderWorld` class you can use to check your code against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run your game. This is getting good. Your game should look like
    the screenshot shown in *Figure 6A*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using parallax](img/image00270.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6A: This shows our game up to now'
  prefs: []
  type: TYPE_NORMAL
- en: Using GreenfootImage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Wait a minute. How did I know about Greenfoot's `GreenfootImage` class and the
    `setColor()` and `fillOval()` methods it contains? The answer is simply that I
    read the documentation. I learned that Greenfoot provides the class `GreenfootImage`
    to aid in the handling and manipulation of images. In general, Greenfoot provides
    a useful set of classes to help programmers create interactive applications. We
    learned about the `World` class and `Actor` class in [Chapter 1](part0014.xhtml
    "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…*. *Figure 6B* displays
    all the classes Greenfoot provides.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using GreenfootImage](img/image00271.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6B: This shows the classes provided by Greenfoot to help you write applications.
    This screenshot is taken directly from Greenfoot''s help documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: You can access Greenfoot's documentation by going to Greenfoot's website, as
    I suggested in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"),
    *Let's Dive Right in…*. If you are not online, you can access the documentation
    by selecting the **Help** menu option in Greenfoot's main menu and then selecting
    **Greenfoot Class Documentation** from the drop-down menu. This will bring up
    Greenfoot's class documentation in your default web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Greenfoot's class documentation is very short and concise. You should take 20–30
    minutes to read about each class Greenfoot provides and each method contained
    in those classes. This will be a very good investment of your time.
  prefs: []
  type: TYPE_NORMAL
- en: Timing and synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timing is very important in creating realistic animations in Greenfoot. Often,
    we have the need for an actor to do temporary animation in response to an event.
    We need a way to allow (or prevent) things for a certain amount of time. It is
    possible to wait for a specific amount of time using the `SimpleTimer` class provided
    by Greenfoot (you can import it into your scenario in the same way you imported
    the `Counter` class in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right
    in…"), *Let's Dive Right in…*); however, waiting for a specific amount of time
    is rarely the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: Why is that? Well, Greenfoot provides the player/user with the ability to slow
    down and speed up a scenario via the **Speed** slider that is located at the bottom
    of Greenfoot's main scenario window. If you waited for 2 seconds in your code
    and then the player sped the game up, the 2 seconds wait would last much longer
    in the game relative to the speed of everything else; the reverse effect would
    happen if the user slowed down the scenario. We want to use a method for "waiting"
    in Greenfoot that scales with the speed of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at three different ways to time events in Greenfoot: delay variables,
    random actions, and triggered events.'
  prefs: []
  type: TYPE_NORMAL
- en: Delay variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delay variables are very similar to the concept of a timer. However, instead
    of counting seconds (or milliseconds), we will count the number of calls to the
    `act()` method that have gone by. This will exactly scale with the **Speed** slider,
    as this slider controls the time between `act()` method calls. Next, we will take
    a look at an example of using a delay variable.
  prefs: []
  type: TYPE_NORMAL
- en: Hurting the avatar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our game is a little unforgiving. If you touch an enemy once, you die. Let''s
    change the game, so that you take damage for every hit and it takes four hits
    to kill our hero. The first thing we need to do, is create an instance variable
    that is going to keep track of the health of our hero. Add this instance variable
    to the top of the `Avatar` class outside of any method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Every time our hero touches an enemy, we are going to subtract one from this
    variable. When this variable is `0`, we will end the game.
  prefs: []
  type: TYPE_NORMAL
- en: When our hero is hit by an enemy, we want to provide visual feedback to the
    player. We could do this with a health bar or life indicator at the top of the
    game; however, let's just animate our hero so that it *looks* injured. To do this,
    we need to create copies of the `skull.png` image that is used to represent an
    instance of the `Avatar` class and augment them to look damaged. You can make
    the changes using an image editor, such as GIMP, Adobe Illustrator, or others.
    *Figure 7* shows my versions of the damaged `skull.png` image. Make sure you name
    your skull images exactly the way I did. The first image `skull.png` is already
    in the images folder; the other three need to be named `skull1.png`, `skull2.png`,
    and `skull3.png`. The reason why it is so important to name them in this manner
    will become apparent soon.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hurting the avatar](img/image00272.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: These are my four copies of skull.png showing increased damage. They
    are named skull.png, skull1.png, skull2.png, and skull3.png, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Presently, our `act()` method in the `Avatar` class looks like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to change the implementation of `checkForCollisions()` to handle
    our hero having life and looking damaged. It presently looks like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we added quite a bit of code. The first `if` statement checks
    the two conditions that need to be true before we take damage from an enemy: firstly,
    that enough time has passed since the last time we took damage from an enemy,
    and secondly, that we are presently touching an instance of the `Enemy` class.
    When the hero touches an enemy and takes damage, we want to give our hero a short
    time of invulnerability in order to move away, without continuing to take damage
    every time the `act()` method is called. If we didn''t do this, the hero would
    take four hits before you could blink your eye. We use the `hitDelay` integer
    variable to count how long to wait. If we have been hit, we set `hitDelay` to
    `50`, as shown in the `else` part of the inner `if-else` statement. The last `if`
    statement in the function continues to decrement `hitDelay`. When `hitDelay` gets
    to `0`, we can be hit by an enemy and no longer decrement `hitDelay`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Java increment and decrement operators**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last bit of code, we used Java''s increment (`++`) and decrement (`--`)
    operators quite a bit. They simply add one or subtract one, respectively, from
    the variable they are applied to. However, there is a bit of subtlety you need
    to be aware of in their use. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the increment operator can be applied before (prefix) or after
    (postfix) the variable. After this code completes, `x` is `2`, `y` is `1`, and
    `z` is `1`. You might be surprised that `z` is `1` and not `2`. The reason is
    that the postfix increment operator will return the value of the variable before
    it is incremented. Refer to the following link for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In the inner `if-else` statement, we know we have been hit by an enemy. We check
    to see if our `health` is `0`; if it is, we are dead, and the game ends as before.
    If we still have `health`, we decrement our `health`, change our image, and set
    `hitDelay`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we change our image to the next, more damaged, image is based on how
    we named the files earlier. We build the name of the file by concatenating the
    `skull` string with an integer and then again with the `.png` string. This method
    provides us with a short and easy programmatic way of changing the image. The
    alternative would be to use a `switch` statement that calls `setImage()` with
    different file names based on the value of `health`. In our new version of `checkForCollisions()`,
    we used two new instance variables; we still need to declare and initialize those
    variables. Add these lines at the top of the class under the declaration of the
    `health` variable we added at the beginning of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, compile your scenario and verify that your hero takes four hits to die.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `hitDelay` variable is a good example of a delay variable. Throughout the
    rest of the book, we will use delay variables to time various activities. Make
    sure you understand how we use `hitDelay` before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Random actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Random actions are one of the most effective ways to approximate simple intelligence
    or natural phenomena. It repeats actions in a non-predictable way and adds both
    suspense and challenge to a game. We already randomly generate a flow of enemies
    our hero has to avoid. We will now use them to improve our star field animation.
  prefs: []
  type: TYPE_NORMAL
- en: Blinking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The stars already look great and provide a real sense of movement in the game.
    We are going to enhance them by making them twinkle like real stars. To do this,
    we use the method `setTransparency()` to make the star completely *see-through*
    and use a delay variable to wait for a short period of time before making the
    star opaque again. We will use Greenfoot''s random number generator to ensure
    that the stars twinkle infrequently. First, we add a method call, `checkTwinkle()`,
    to the `act()` method in the `Star` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the following delay variable and the variable to hold the current
    transparency of the object at the top of the class under the declaration of the
    `speed` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an implementation of `checkTwinkle()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the `else` part of the outer `if-else` statement. With a small
    random probability, we set `twinkleTime` (our delay variable) to `10`, save the
    current transparency of the star so that we can restore it later, and then set
    the transparency to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` part of the initial `if-else` statement decrements `twinkleTime` if
    it is greater than `0` and restores the transparency of our star when `twinkleTime`
    equals `1`. Because `twinkleTime` is only set to `10`, the star will only be invisible
    for a very short period of time. This short flicker gives the illusion that the
    star twinkles.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run the scenario and see whether you can catch a star twinkling.
    If you have a hard time verifying this, change the frequency at which the twinkling
    occurs and try again.
  prefs: []
  type: TYPE_NORMAL
- en: Triggered events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Triggering a change in an actor when a certain event occurs is another way to
    do animation. For example, you might have an enemy actor that will only chase
    you when you get within a certain range. You might also have an actor respond
    to keyboard events or location.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to give our hero eyes. Obviously, our hero is
    very concerned with nearby enemies and definitely wants to keep an eye on them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding animated eyes to an actor is a fantastic way to give that actor personality.
    Eyes are very expressive and can easily portray excitement, sadness, or fear.
    Never hesitate to add animated eyes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding eyes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This might seem a bit weird, but we are going to create a separate `Eye` actor.
    We are going to do this for a couple of reasons. First, to get the eyes to look
    around is going to take a fair amount of code. We can encapsulate this code in
    the `Eye` class and keep our `Avatar` class more streamlined. Second, having the
    eyes as separate entities means we could add them to future actors and they would
    still work even if we changed the image of the `Avatar` class.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative would be to create a skull image with eyes for every direction
    we would want to look. The fact that we have different images for our hero to
    show different levels of damage would further complicate matters. Therefore, we
    are going to create a separate `Eye` actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new subclass of `Actor` called `Eye`. Do not associate an image with
    this `Actor` class. We will dynamically draw an image of an eye and redraw it
    appropriately when we need to look in a different direction. Here is the implementation
    of the `Eye` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The two main methods of this class are the `drawEye()` method and the `lookAtEnemies()`
    method. The `drawEye()` image uses the same methods to draw an eye that we used
    to draw the image of a star in the `Star` class. For an eye, we just need to draw
    one additional black circle to serve as the iris. The method `drawEye()` takes
    two integer parameters that provide the position of the iris in the eye. This
    offset portion of `fillOval()` was demonstrated in *Figure 3*. To summarize, the
    first `fillOval()` command draws the larger white part of the eye, and the second
    `fillOval()` command draws the small black iris at a given offset to simulate
    staring in a certain direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lookAtEnemies()` method finds all enemies within a given distance of the
    eye and uses `drawEye()` to stare at the first enemy it finds. Using `if` statements
    to compare the *x* and *y* position of the enemy with its own position, the eye
    classifies the enemy as being in one of four quadrants: upper-left, lower-left,
    upper-right, and lower-right. Using this information, `drawEye()` is called with
    the integer parameters `(1,1)`, `(1,3)`, `(3,1)`, and `(3,3)`, respectively. *Figure
    8* demonstrates the correlation between the quadrant the enemy is in and the call
    to `drawEye()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding eyes](img/image00273.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: This shows the mapping between the position of the enemy and the
    call to drawEye()'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `lookAtEnemies()`, we used a new collision detection method called `getObjectsInRange()`.
    This method differs from `getOneIntersectingObject()` in two ways. First, instead
    of using the bounding box of the calling `Actor` class to determine whether a
    collision occurred, it draws a circle around the calling `Actor` class that has
    a radius of the size defined by the first parameter of `getObjectsInRange()`.
    This method returns all of the enemies found in that circle, instead of just one
    enemy. The enemies are returned in a Java `List` array. At the top of our `Eye`
    class, we need to include the code `import java.util.List;` to work with the `List`
    data type. We only have the ability to stare at one enemy at a time, so we choose
    to stare at the first enemy in this list using the method `get()` and passing
    it the integer value `0` to access it. Here''s Greenfoot''s documentation on `getObjectsInRange()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code returns all objects within range `radius` around
    this object. An object is within range if the distance between its center and
    this object's center is less than, or equal to, `radius`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters of the the `getObjectsInRange()` methods are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`radius`: This is the radius of the circle (in cells)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cls`: This is the class of objects to look for (passing `null` will find all
    objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving our hero sight
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have an `Actor` class called `Eye`, we just need to make a few
    modifications to the `Avatar` class in order to add eyes to our hero. We need
    to create two eyes, place them on our hero, and then we need to make sure the
    eyes stay in place every time our hero moves. We start by adding instance variables
    to the `Avatar` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create and place those eyes on the skull image by adding this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, you might think that we could create the eyes and add them in the
    constructor method for `Avatar`. Normally, this would be an excellent location
    for code that is run once at creation time. The problem is that before we can
    add the eyes to the world, an instance of the `Avatar` class needs to be in a
    world. If we look at the code in `AvoiderWorld` that adds our hero, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The creation of our hero is a two-step process. First, an instance of the `Avatar`
    class is created (the first line), and then we add this instance to the world
    (the second line). Notice that the constructor runs before that object is placed
    in a world, so we cannot access the instance of the world we are in via the method
    `getWorld()`. The developers of Greenfoot recognized that some actors will need
    to access the world they are in to complete their initialization, so they added
    the `addedToWorld()` method to the `Actor` class. The `Actor` class overrides
    this method when initialization requires world access, and it will be called by
    Greenfoot every time an actor is added to a world. We use this method in our `Avatar`
    class in order to place the eyes on our hero.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now created our eyes and added them to our hero. Now, we just need
    to ensure that the eyes stay with our hero whenever it moves. To do that, we add
    the following lines to our `followMouse()` function in the `Avatar` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is added after the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Why do the 10s and 8s in the `setLocation()` call `leftEye` and `rightEye`?
    These are the values that correctly place the eyes in the sockets of our hero.
    I determined these values through trial and error. *Figure 9* presents the details.
  prefs: []
  type: TYPE_NORMAL
- en: '![Giving our hero sight](img/image00274.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: This shows how the location of the eyes was determined'
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to have some fun. Compile and run your game and enjoy the fruits
    of your labor. Your game should look like the screenshot shown in *Figure 10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Giving our hero sight](img/image00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: Our game has animated enemies, a moving background star field (with
    twinkles), and a hero with eyes that visually changes when hit'
  prefs: []
  type: TYPE_NORMAL
- en: Easing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our last major section of this chapter, we are going to look at using easing
    equations to move our actors around in interesting ways. Easing functions use
    easing equations to calculate position as a function of time. Just about every
    animation you''ve seen on the web, your mobile device, or in the movies uses easing
    at some point in time. We are going to add three new actors to our game that move
    according to three different easing functions: linear, exponential, and sinusoidal.'
  prefs: []
  type: TYPE_NORMAL
- en: Power-ups and power-downs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Power-ups are an excellent way to add new challenges and balance player skill.
    Power-ups provide players with momentary boosts in speed, power, health, or some
    other game-related skill. They often appear randomly and might not be in the most
    convenient location, so they require players to make fast, real-time decisions
    where they have to weigh the risk of moving to the power-up versus its beneficial
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can create randomly appearing game objects that negatively affect
    the player's ability to do well. I call these *power-downs*. They also require
    the player to make fast, real-time decisions, but now they are deciding between
    avoiding them and staying on their current trajectory and suffering the negative
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add two new actors to our game that will be power-downs and
    one new actor that will be a power-up. All three of them will use easing for movement.
    We will first introduce a new `Actor` class that will contain all the common code
    for easing and being a power item (power-up or power-down.) Our power-ups and
    power-downs will inherit from this class. It is good object-oriented programming
    practice to use inheritance and polymorphism to write concise, flexible, and maintainable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Base class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a well-thought-out base class for our power items will provide the
    means to easily create new power items and augment existing ones in the future.
    Before we talk about the code for our new class, we need to import a new Greenfoot-supplied
    class into our project, in the same way we imported the `Counter` class in [Chapter
    1](part0014.xhtml "Chapter 1. Let''s Dive Right in…"), *Let''s Dive Right in…*.
    The class we are going to import is `SmoothMover`. We need this class as it more
    accurately tracks the position of `Actor`. Here''s an excerpt from its documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To import this class, click on **Edit** in Greenfoot's main menu and then click
    on **Import Class…** in the drop-down menu that appears. In the **Import Class**
    window that appears next, select `SmoothMover` on the left-hand side and then
    click on the **Import** button.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have `SmoothMover` in our project, we can create the `PowerItems`
    class. Right-click `SmoothMover` and choose **New subclass…**. You will not need
    to associate an image with this class, so choose **No Image** in the **Scenario
    Images** section in the **New class** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of `PowerItems` (our new base class
    for power-ups and power-downs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We first need to discuss all the instance variables of this class. There are
    seven of them. Two of them are used to track the starting coordinates (`origX`
    and `origY`) and two of them are used to track the ending coordinates (`targetX`
    and `targetY`). The instance variable `expireTime` specifies how many calls of
    the `act()` method this actor should execute before removing itself. In other
    words, it specifies the lifespan of the actor. The `duration` instance variable
    simply saves the initial value of `expireTime`. The `expireTime` variable is continually
    decremented until it reaches a value of 0, but we need to know its original value
    for our easing equations. The `counter` variable records how many times this actor
    has moved. *Figure 11* shows these variables pictorially.
  prefs: []
  type: TYPE_NORMAL
- en: '![Base class](img/image00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: This shows the meaning of the instance variables in PowerItems graphically'
  prefs: []
  type: TYPE_NORMAL
- en: The instance variables are initialized in the constructor except for `origX`
    and `origY`, which are initialized in the method `addedToWorld()` (the purpose
    of this method was discussed earlier in this chapter), so that we can set them
    to the current *x* and *y* location of the actor.
  prefs: []
  type: TYPE_NORMAL
- en: Because of our judicious use of functional decomposition, the `act()` method
    is straightforward to understand. First, it moves the actor by calling `easing()`.
    Next, `checkHitAvatar()` is called to see if it collided with our hero. This method
    is `abstract`, which means its implementation is left to subclasses of this class.
    This is done because each subclass will want to apply its own unique effect on
    our hero if they did collide. Last, it checks to see whether the `act()` method
    has been called `expireTime` times. If so, `PowerItem` has had its desired lifespan,
    and it's time to remove it. We will talk about the specific implementation of
    `easing()`, `checkHitAvatar()`, and `checkExpire()` next.
  prefs: []
  type: TYPE_NORMAL
- en: The `easing()` method is really the key method of this class. It contains a
    generic form of an easing equation that is flexible enough to allow us to define
    many different types of interesting movements. The method moves the actor some
    fraction of the way between the starting point and the endpoint. It starts by
    calculating the percentage of the distance we need to travel at this point in
    time between the origin value and the target value in the *x* direction and a
    similar calculation for the *y* direction and saves those values in the local
    variables `fX` and `fY`, respectively. Next, we use the `curveX()` and `curveY()`
    functions to manipulate these percentages, and then we use those percentages in
    a call to `setLocation()`. As with `checkHitAvatar()`, `curveX()` and `curveY()`
    are `abstract`, as their details depend on the classes that subclass from `PowerItems`.
    We'll discuss the `abstract` methods `checkHitAvatar()`, `curveX()`, and `curveY()`,
    as well as provide a detailed example in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Before that, let's look quickly at the last method in the `act()` method of
    `PowerItems`. The last method, `checkExpire()`, simply removes the actor when
    `expireTime` reaches 0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Abstract classes**'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes are an effective way to share code and instance variables between
    several related classes. In the abstract class, you implement as much code as
    you can without needing specific knowledge that would be contained in a child
    class (subclass). For us, the class `PowerItems` is an abstract class that contains
    the code common to all of our power-ups and power-downs. Visit [http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html](http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html)
    for more information on abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: Linear easing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first power-down we are going to add to the game is one that temporarily
    stuns our hero if touched. Keeping with our game's motif, where good things (smiley
    faces) are bad, we will make our new power-down look like a cupcake. To create
    our new `Actor`, right-click `PowerItems` in the **Actor classes** section of
    Greenfoot's main scenario window, and select **New subclass…** from the menu that
    appears. Name the class `Cupcake` and choose the image of the muffin (it looks
    like a cupcake to me!) located in the **food** category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `Cupcake` class in an editor window, and make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Because we are inheriting from the code from `PowerItems`, `Cupcake` is pretty
    short and concise. The constructor for this class merely passes its parameters
    to the constructor in `PowerItems`. Since `PowerItems` is an abstract class, we
    need to implement the abstract methods in `PowerItems` (`curveX()`, `curveY()`,
    and `checkHitAvatar()`) here.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cupcake` class is going to be our example of *linear easing*. It will move
    in constant, linear steps from the starting position to the ending position. Because
    it is linear, our `curveX()` and `curveY()` methods are extremely simple. They
    don't change the input parameter at all.
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear easing](img/image00277.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: This is an example showing how instances of the Cupcake class move
    linearly across the screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the example shown in *Figure 12*. In this example, `Cupcake`
    was called with the target location **(150, 100)** and an expire time of `4` and
    was added to the world at the location **(10,10)**. Location **(a)** shows the
    initial values of the object. Locations **(b)**, **(c)**, **(d)**, and **(e)**
    show the values associated with the object after one, two, three, and four `act()`
    method calls, respectively. As we can see, this actor moves in a straight line.
    To better understand linear easing, let''s discuss why the values are as shown
    at location **(b)**. After initialization (shown at location **(a)**), the functions
    in the `act()` method (inherited from `PowerItems`) are called. The `easing()`
    method sets `counter` to 1 and then sets `fX` and `fY` to 0.25, as shown in this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `curveX()` and `curveY()` methods in `Cupcake` do not alter `fX` and `fY`.
    For the given values, the first parameter to `setLocation()` has a value of 45
    *((150 * 0.25) + (10 * 0.75))* for its first parameter and 32.5 *((100*0.25) +
    (10 * 0.75))* for its second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: After `easing()`, the next method called in the `act()` method is `checkHitAvatar()`.
    This method simply invokes the method `stun()` on an instance of `Avatar` (our
    hero) if it collides with it. The `stun()` method will be shown after all the
    power-ups and power-downs have been discussed. At this time, we will show all
    the changes needed to the `Avatar` class.
  prefs: []
  type: TYPE_NORMAL
- en: Exponential easing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have discussed most of the theory behind power-ups and power-downs,
    we can quickly discuss the remaining ones. The next actor we are going to add
    is a power-up. It will heal our hero from some of the damage sustained. Given
    the motif of our game, this beneficial actor will have to look bad. We will make
    it a rock.
  prefs: []
  type: TYPE_NORMAL
- en: To create our new `Actor` class, right-click on `PowerItems` in the **Actor
    classes** section of Greenfoot's main scenario window and select **New subclass…**
    from the menu that appears. Name the class `Rock` and choose the image `rock.png`
    located in the **nature** category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `Rock` class in an editor window and change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The two main differences between the `Cupcake` class and the `Rock` class are
    the implementation of `curveY()` and the fact that `checkHitAvatar()` calls `addHealth()`
    instead of `stun()`. We will describe `addHealth()` later, as mentioned earlier.
    The changes in `curveY()` give this actor a curved directory by cubing the value
    it is given. The effect of this is demonstrated in the example shown in *Figure
    13*. Compare the changes in the *y* position for each location. The *y* value
    grows exponentially. First, it only moves 1.4 pixels (from location **(a)** to
    location **(b)**) and in the end, jumps approximately 52 pixels (from location
    **(d)** to location **(e)**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Exponential easing](img/image00278.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: This is an example showing how instances of the Rock class move
    exponentially in the y direction across the screen'
  prefs: []
  type: TYPE_NORMAL
- en: Sinusoidal easing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last power-down we are adding is `Clover`. It will slow our hero down for
    a short time and employ *sinusoidal easing*. To create this class, right-click
    on `PowerItems` in the **Actor classes** section of Greenfoot''s main scenario
    window and select **New subclass…** from the menu that appears. Name the class
    `Clover` and choose the image of the `shamrock` located in the **nature** category.
    Open it in an editor window and change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Like the `Rock` class, the `Clover` class does something unique in its `curveY()`
    method. It imports Java's math library at the top of the class and uses `Math.sin()`
    in its implementation of `curveY()`. This makes the *y* motion oscillate like
    a sine wave.
  prefs: []
  type: TYPE_NORMAL
- en: In `Clover`, `checkHitAvatar()` calls `lagControls()`on the instance of the
    `Avatar` class it collided with, instead of `stun()` or `addHealth()`. In the
    next section, we will implement `stun()`, `addHealth()`, and `lagControls()` in
    the `Avatar` class.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the Avatar class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To accommodate the effects of our new power items, the `Avatar` class needs
    to implement a few methods and change some existing ones. These methods are `stun()`,
    `addHealth()`, and `lagControls()`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's an extra challenge before continuing ahead in the chapter. Try to implement
    these methods yourself. Think each one through and rough them out on paper. The
    worst case scenario for attempting this is that you learn a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementations of `stun()` and `lagControls()` involves adding delay variables
    and using them to affect movement. In the `Avatar` class, all movement is handled
    in the `followMouse()` method. To stun our hero, we only need to disable the `followMouse()`
    method for a small period of time. Here is how we would change this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define the `stunDelay` instance variable at the top of the
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows the pattern of usage for the instance variable `hitDelay` we added
    at the beginning of this chapter. It was our example of a delay variable. Now,
    we implement `stun()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Every time `stun()` is invoked, the `followMouse()` method will not work for
    50 cycles (calls of the `act()` method).
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `lagControls()` is similar, except that we need to temporarily
    change the movement, instead of blocking it. Again, we need to change the `followMouse()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first add the instance variable `lagDelay` and then talk about how it
    is used in `followMouse()`. Add this line at the top of the class under `stunDelay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'While `lagDelay` is a value greater than 0, it will implement the laggy controls.
    In the inner `if-else` statement in the above method, the lag is implemented by
    only moving our hero one-fortieth of the way to the location of the mouse. This
    makes our hero slowly crawl towards the location of the mouse. The delay variable,
    `lagDelay`, is decremented until it is less than 0\. How does it get above 0?
    It is set in the `lagControls()` method called by the `Clover` class. Here is
    the code for that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need to do now is implement the `addHealth()` method. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This method simply undoes the damage that occurs when we hit an enemy. This
    method does nothing if we are already at full health; otherwise, it increments
    the `health` instance variable, decrements `nextImage`, so that it stays in sync
    with the image we are displaying, and sets the image of the `Avatar` to the previous,
    less damaged image. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: 'We made some substantial changes to the `Avatar` class. Here is its code in
    its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We are so close to trying all this out. We just need to randomly create and
    add the power-ups and power-downs in the `AvoiderWorld` class.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the AvoiderWorld class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to create three new instance variables at the top of the `AvoiderWorld`
    class to specify the probability we use to generate one of our new power items.
    Add these lines of code under the declaration and initialization of `nextLevel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, the creation of these items will not be very frequent, but we will
    change that by incrementing them in the `increaseLevel()` function. Here is the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `act()` method, we call a function to generate enemies and another to
    generate stars. Following this pattern, add this line to the `act()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Because all of the power item classes inherits from `PowerItems`, we can use
    polymorphism to write some pretty concise code. Here is the implementation of
    `generatePowerItems()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s pretty nice that we can use one method to create our new power items—`generatePowerItem()`.
    This method takes an integer describing the type of power item we want to create
    and a frequency to generate those particular items. Here''s the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This method looks a lot like our other methods that generate actors. It will
    generate an item at a given random rate and place those items to emerge from either
    the left or the right of the screen towards a randomly generated place in the
    interior of the screen. The local variable `targetX` will be any valid *x* coordinate
    on the screen, except for a `40` pixel wide border on the left and right of the
    screen. We just want to ensure that it travels long enough to be seen and that
    it has an impact on the game. The variable `targetY` has slightly tighter constraints.
    We only want to generate a *y* value in the upper half of the screen, plus an
    initial `20` pixels to prevent the actor from traveling too close to the top of
    the screen. The inner `if-else` statement simply chooses from placing the object
    either on the left or the right of the screen for its initial location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real difference here, from how we generated other actors, is the call to
    `createPowerItem()`. Since we are using this method to generate any one of three
    power items, we can''t hardcode the creation of a specific item, such as, `new
    Cupcake();`. We use `createPowerItem()` to create the right object that matches
    the type parameter of `generatePowerItems()`. Here''s the implementation of `createPowerItem()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This method creates a new `Cupcake`, `Clover`, or `Rock` power item based on
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We have really added a lot to this game, and now it's time to compile and test
    it out. Normally, you would not want to add this much code without testing small
    parts along the way. For example, we could have just implemented the `Rock` power-up
    completely and tested it before adding the other power items. For pedagogical
    reasons, it made sense to continue in the manner we did. I hope you don't encounter
    too many typos when you compile your code. By methodically checking your code
    against the code in this chapter and paying close attention to the compile error
    messages, you should be able to eliminate any mistakes quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to refresh yourself on how a Java switch statement works, refer
    to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Compile, debug, and play. This game is getting good. Check out my screenshot
    in *Figure 14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Changes to the AvoiderWorld class](img/image00279.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: Here''s Avoider Game complete with power-ups, power-downs, and all
    sorts of bling'
  prefs: []
  type: TYPE_NORMAL
- en: Avoider Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Avoider Game is getting more complete and fun to play. In [Chapter 5](part0034.xhtml
    "Chapter 5. Interactive Application Design and Theory"), *Interactive Application
    Design and Theory*, we will look at game design theory on how to build fun and
    engaging games. At that time, we will revisit our game and increase its playability.
  prefs: []
  type: TYPE_NORMAL
- en: Your assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an `Avatar` object is hit, it is invulnerable to being hit again for a
    short time. Unfortunately, we have provided no visual feedback to the player that
    indicates this is happening or when it expires. Your assignment is to make the
    hero blink while it cannot be hit. Look at the `Star` class for a hint on how
    to make an object blink.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of material in this chapter. You learned several important
    techniques for animating actors, including image swapping, delay variables, parallax,
    and easing. Our enemies, our hero, and the background, all have more life. You
    should use all the techniques of this chapter when creating games, simulations,
    animated shots, or educational applications.
  prefs: []
  type: TYPE_NORMAL
