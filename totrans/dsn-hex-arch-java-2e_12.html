<html><head></head><body>
<div id="_idContainer080">
<h1 class="chapter-number" id="_idParaDest-194"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-195"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.2.1">Using RESTEasy Reactive to Implement Input Adapters</span></h1>
<p><span class="koboSpan" id="kobo.3.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">input adapter</span></strong><span class="koboSpan" id="kobo.5.1"> is </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.6.1">like a front door that exposes all the features provided by a hexagonal system. </span><span class="koboSpan" id="kobo.6.2">Whenever a user or other application wants to communicate with a hexagonal system, they reach one of the available input adapters. </span><span class="koboSpan" id="kobo.6.3">With such adapters, we can provide different ways to access the same functionality within the hexagonal system. </span><span class="koboSpan" id="kobo.6.4">If a client does not support HTTP communication, we can implement an adapter using a different protocol. </span><span class="koboSpan" id="kobo.6.5">The significant advantage here is that removing or adding new adapters does not influence the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">domain logic.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Due to the hexagonal architecture’s decoupling and well-encapsulating nature, we can change technologies without any or major changes occurring in the system </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">domain logic.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we’ll continue our journey in exploring the exciting features of Quarkus. </span><span class="koboSpan" id="kobo.10.2">One feature that fits quite well with implementing input adapters is the </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">RESTEasy Reactive JAX-RS implementation</span></strong><span class="koboSpan" id="kobo.12.1">, which </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.13.1">is a part of the Quarkus framework. </span><span class="koboSpan" id="kobo.13.2">RESTEasy Reactive proposes an asynchronous and event-driven way to expose HTTP endpoints. </span><span class="koboSpan" id="kobo.13.3">So, we’ll learn how to integrate such Reactive capabilities with input adapters from a </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">We’ll cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Exploring the approaches to handling </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">server requests</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Implementing input adapters with </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">RESTEasy Reactive</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Adding OpenAPI and </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Swagger UI</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Testing Reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">input adapters</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.25.1">By the end of this chapter, you’ll know how to implement and test input adapters with reactive behavior. </span><span class="koboSpan" id="kobo.25.2">You’ll also know how to publish the API for these input adapters using OpenAPI and </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Swagger UI.</span></span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.28.1">To compile and run the code examples presented in this chapter, you need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.30.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.32.1"> installed on your computer. </span><span class="koboSpan" id="kobo.32.2">They are available for the Linux, Mac, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter12"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter12</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.38.1">Exploring the approaches to handling server’s requests</span></h1>
<p><span class="koboSpan" id="kobo.39.1">In client-server communication, we have a process flow where a client sends a request, the server receives it, and it starts to do some work. </span><span class="koboSpan" id="kobo.39.2">Once the server finishes its work, it replies to the client with a result. </span><span class="koboSpan" id="kobo.39.3">From the client’s perspective, this flow does not change. </span><span class="koboSpan" id="kobo.39.4">It’s always about sending a request and receiving a response. </span><span class="koboSpan" id="kobo.39.5">What can change, though, is how the server can internally handle how a request </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">is processed.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">There are two approaches to handling the server’s request processing: </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">reactive</span></strong><span class="koboSpan" id="kobo.43.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">imperative</span></strong><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">So, let’s see how a server can handle </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">requests imperatively.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.47.1">Imperative</span></h2>
<p><span class="koboSpan" id="kobo.48.1">In a traditional web</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.49.1"> application running</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.50.1"> on </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Tomcat</span></strong><span class="koboSpan" id="kobo.52.1">, every request that’s received by the server triggers the creation of a worker thread on something</span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.53.1"> called a </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">thread pool</span></strong><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">In Tomcat, a thread pool is a mechanism that controls the life cycle and availability of worker threads that serve application requests. </span><span class="koboSpan" id="kobo.55.3">So, when you make a server request, Tomcat pulls a dedicated thread from the thread pool to serve your request. </span><span class="koboSpan" id="kobo.55.4">This worker thread relies on blocking I/O to access databases and other systems. </span><span class="koboSpan" id="kobo.55.5">The following diagram illustrates how the imperative </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">approach works:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.57.1"><img alt="Figure 12.1 – The imperative approach" src="image/B19777_12_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.58.1">Figure 12.1 – The imperative approach</span></p>
<p><span class="koboSpan" id="kobo.59.1">As shown in the preceding diagram, </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">Server</span></strong><span class="koboSpan" id="kobo.61.1"> needs to create a new I/O blocking worker thread for </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">each request.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Once a</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.64.1"> worker thread has been created and allocated to serve a request, it is blocked until the request is fulfilled. </span><span class="koboSpan" id="kobo.64.2">The server has a limited number of threads. </span><span class="koboSpan" id="kobo.64.3">If you have lots of long-running requests and continue to send such requests before the server can finish them, the server will run out of threads, which will lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">system failures.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">Thread creation and management is also expensive. </span><span class="koboSpan" id="kobo.66.2">The server expends valuable resources in creating and switching between threads to serve </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">client requests.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">So, the bottom line of the imperative approach is that a worker thread is blocked to serve one – and only one – request at a time. </span><span class="koboSpan" id="kobo.68.2">To serve more requests concurrently, you need to provide more worker threads. </span><span class="koboSpan" id="kobo.68.3">Also, the imperative approach influences how the code is written. </span><span class="koboSpan" id="kobo.68.4">Imperative code is somewhat more straightforward to understand because things are </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">treated sequentially.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Now, let’s see how the reactive approach contrasts with the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">imperative one.</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.72.1">Reactive</span></h2>
<p><span class="koboSpan" id="kobo.73.1">As you may imagine, the</span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.74.1"> idea behind the reactive approach is that you don’t need to block a thread to fulfill a request. </span><span class="koboSpan" id="kobo.74.2">Instead, the system can use the same thread to process different requests simultaneously. </span><span class="koboSpan" id="kobo.74.3">In the imperative approach, we have worker threads that handle only one request at a time, while in the reactive approach, we have I/O non-blocking threads that handle multiple requests concurrently. </span><span class="koboSpan" id="kobo.74.4">Here, we can see how the reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">approach works:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.76.1"><img alt="Figure 12.2 – The reactive approach" src="image/B19777_12_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.77.1">Figure 12.2 – The reactive approach</span></p>
<p><span class="koboSpan" id="kobo.78.1">As shown in the preceding diagram, a single non-blocking thread can handle </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">multiple requests.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">In the reactive approach, we have a sense of continuation. </span><span class="koboSpan" id="kobo.80.2">Instead of the sequential nature of the imperative approach, with Reactive, we can see that things have continuity. </span><span class="koboSpan" id="kobo.80.3">By continuation, we mean that whenever a Reactive-ready server receives a request, such a request is dispatched as an I/O operation with an attached continuation. </span><span class="koboSpan" id="kobo.80.4">This continuation works like a callback that is triggered and continues to execute the request once the server returns with a response. </span><span class="koboSpan" id="kobo.80.5">If this request needs to fetch a database or any remote system, the server won’t block the I/O thread while waiting for a response. </span><span class="koboSpan" id="kobo.80.6">Instead, the I/O thread will trigger an I/O operation with an attached continuation and will release the I/O thread to accept </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">other requests.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.83.1">following diagram illustrates how I/O threads trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">I/O operations:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.85.1"><img alt="Figure 12.3 – I/O thread flow" src="image/B19777_12_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.86.1">Figure 12.3 – I/O thread flow</span></p>
<p><span class="koboSpan" id="kobo.87.1">As we can see, an I/O thread calls a non-blocking task that triggers an I/O operation and returns immediately. </span><span class="koboSpan" id="kobo.87.2">This happens because the I/O thread does not need to wait for the first I/O operation to finish to call a second one. </span><span class="koboSpan" id="kobo.87.3">While the first I/O operation is still executing, the same I/O thread calls for another non-blocking task. </span><span class="koboSpan" id="kobo.87.4">Once the I/O operation has concluded, the I/O thread resumes execution by finishing the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">non-blocking tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">By avoiding </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.90.1">wasting any time and resources that exist in the imperative approach, the reactive approach makes makes optimized use of threads as they don’t while waiting for an I/O operation to </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">be finished.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Next, we’ll learn how to implement reactive input adapters using the RESTEasy Reactive JAX-RS implementation provided </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">by Quarkus.</span></span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.94.1">Implementing input adapters with RESTEasy Reactive</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.95.1">RESTEasy Reactive</span></strong><span class="koboSpan" id="kobo.96.1"> is a</span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.97.1"> JAX-RS implementation that supports both imperative and reactive HTTP endpoints. </span><span class="koboSpan" id="kobo.97.2">Such an</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.98.1"> implementation integrates with </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">Vert.x</span></strong><span class="koboSpan" id="kobo.100.1">, which is a toolkit that we can use to build distributed Reactive systems. </span><span class="koboSpan" id="kobo.100.2">RESTEasy Reactive and Vert.x work together in Quarkus to provide </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">Reactive capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">To understand what a Reactive endpoint looks like, we will integrate RESTEasy Reactive with the input adapters of the topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">inventory system.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">Let’s start by configuring the required </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">Maven dependencies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy-reactive&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy-reactive-
      jackson&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</span></pre> <p><span class="koboSpan" id="kobo.107.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">quarkus-resteasy-reactive</span></strong><span class="koboSpan" id="kobo.109.1">, we bring the Reactive libraries, including Reactive </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.110.1">RESTEasy and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">Mutiny</span></strong><span class="koboSpan" id="kobo.112.1"> library, which we’ll use to create code in a reactive fashion. </span><span class="koboSpan" id="kobo.112.2">We</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.113.1"> will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">quarkus-resteasy-reactive-jackson</span></strong><span class="koboSpan" id="kobo.115.1"> for deserialization tasks involving the </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">Reactive responses.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Once we have the dependencies configured, we can start implementing the Reactive input adapter for router management in the topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">inventory system.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.119.1">Implementing the Reactive input adapter for router management</span></h2>
<p><span class="koboSpan" id="kobo.120.1">We’ll work </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.121.1">on top of </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.122.1">the existing input adapters that we created in </span><a href="B19777_08.xhtml#_idTextAnchor174"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.123.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.124.1">, </span><em class="italic"><span class="koboSpan" id="kobo.125.1">Building the Framework Hexagon</span></em><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">We’ll change those input adapters to enable JAX-RS and Reactive capabilities. </span><span class="koboSpan" id="kobo.126.3">We’ll execute the following steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">do so:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.128.1">Let’s start by defining the top-level path for requests related to router management on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">RouterManagementAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.131.1">
@ApplicationScoped
@Path("/router")
public class RouterManagementAdapter {
    @Inject
    RouterManagementUseCase routerManagementUseCase;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.132.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">@Path</span></strong><span class="koboSpan" id="kobo.134.1"> annotation to map a URL path to a resource in the system. </span><span class="koboSpan" id="kobo.134.2">We can use this annotation on top of a class or </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">a method.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.136.1">The only field of this class is </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.138.1">, which is injected using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">@Inject</span></strong><span class="koboSpan" id="kobo.140.1"> annotation. </span><span class="koboSpan" id="kobo.140.2">By utilizing this use case reference, we gain access to system features related to </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">router management.</span></span></p></li> <li><span class="koboSpan" id="kobo.142.1">Next, let’s</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.143.1"> define </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.144.1">a Reactive endpoint to retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">a router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.146.1">
@GET
@Path("/{id}")
public Uni&lt;Response&gt; retrieveRouter(Id id) {
    return Uni.createFrom()
            .item(
               routerManagementUseCase.
</span><span class="koboSpan" id="kobo.146.2">               retrieveRouter(id))
            .onItem()
            .transform(
             router -&gt; router != null ?
</span><span class="koboSpan" id="kobo.146.3">             Response.ok(f) :
             Response.ok(null))
            .onItem()
            .transform(Response.Response
                Builder::build);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.147.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">@GET</span></strong><span class="koboSpan" id="kobo.149.1"> annotation says that only </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">HTTP GET</span></strong><span class="koboSpan" id="kobo.151.1"> requests are allowed. </span><span class="koboSpan" id="kobo.151.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">@Path("/{id}")</span></strong><span class="koboSpan" id="kobo.153.1"> annotation from the method level is concatenated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">@Path("/router")</span></strong><span class="koboSpan" id="kobo.155.1"> annotation from the class level. </span><span class="koboSpan" id="kobo.155.2">So, to reach this </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.157.1"> method, we have to send a request </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">/router/{id}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.161.1">Also, note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">@PathParam("id")</span></strong><span class="koboSpan" id="kobo.163.1"> annotation, which we use to capture a parameter from </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">the URL.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.165.1">What makes</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.166.1"> this endpoint a Reactive one is its </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">Uni&lt;Response&gt;</span></strong><span class="koboSpan" id="kobo.168.1"> response type. </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">Uni</span></strong><span class="koboSpan" id="kobo.170.1"> is one of the two types provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">Mutiny</span></strong><span class="koboSpan" id="kobo.172.1"> library. </span><span class="koboSpan" id="kobo.172.2">In addition to </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">Uni</span></strong><span class="koboSpan" id="kobo.174.1">, there is also the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Multi</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1"> type.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.177.1">We </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.178.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Uni</span></strong><span class="koboSpan" id="kobo.180.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">Multi</span></strong><span class="koboSpan" id="kobo.182.1"> types to represent what kind of data we’re dealing with. </span><span class="koboSpan" id="kobo.182.2">For example, if your response returns just one item, you should use </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Uni</span></strong><span class="koboSpan" id="kobo.184.1">. </span><span class="koboSpan" id="kobo.184.2">Otherwise, if your response is like a stream of data, such as those that come from a messaging server, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Multi</span></strong><span class="koboSpan" id="kobo.186.1"> may be more suited for </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">your purpose.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.188.1">By calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Uni.createFrom().item(routerManagementUseCase.retrieveRouter(id))</span></strong><span class="koboSpan" id="kobo.190.1">, we’re creating a pipeline that executes </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">routerManagementUseCase.retrieveRouter(id)</span></strong><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">The result is captured on </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">transform(f -&gt; f != null ? </span><span class="koboSpan" id="kobo.193.2">Response.ok(f) : Response.ok(null))</span></strong><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">If the request is successful, we get </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Response.ok(f)</span></strong><span class="koboSpan" id="kobo.196.1">; otherwise, we get </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">Response.ok(null)</span></strong><span class="koboSpan" id="kobo.198.1">. </span><span class="koboSpan" id="kobo.198.2">Finally, we</span><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.199.1"> call </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">transform(Response.ResponseBuilder::build)</span></strong><span class="koboSpan" id="kobo.201.1"> to transform the result into a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">Uni&lt;Response&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1"> object.</span></span></p><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">Response.ResponseBuilder::build</span></strong><span class="koboSpan" id="kobo.205.1"> is a method reference that could be written as the following lambda expression: (</span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">Response.ResponseBuilder responseBuilder) -&gt; responseBuilder.build()</span></strong><span class="koboSpan" id="kobo.207.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">responseBuilder</span></strong><span class="koboSpan" id="kobo.209.1"> represents the object parameter we receive, followed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">build</span></strong><span class="koboSpan" id="kobo.211.1"> method call to create a  new </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Response</span></strong><span class="koboSpan" id="kobo.213.1"> object. </span><span class="koboSpan" id="kobo.213.2">We favor the method reference approach because we write less code to accomplish the </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">same thing.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.215.1">The remaining endpoints we are about to implement all follow a similar approach to the one </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">described previously.</span></span></p></li> <li><span class="koboSpan" id="kobo.217.1">After implementing an endpoint to retrieve a router, we can implement an endpoint to</span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.218.1"> remove a router from </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">the system:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.220.1">
@DELETE
@Path("/{id}")
public Uni&lt;Response&gt; removeRouter(@PathParam("id") Id
  id) {
    return Uni.createFrom()
            .item(
             routerManagementUseCase.removeRouter(id))
            .onItem()
            .transform(
             router -&gt; router != null ?
</span><span class="koboSpan" id="kobo.220.2">             Response.ok(router) :
             Response.ok(null))
            .onItem()
            .transform(Response.Response
              Builder::build);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.221.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">@DELETE</span></strong><span class="koboSpan" id="kobo.223.1"> annotation corresponds to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">HTTP DELETE</span></strong><span class="koboSpan" id="kobo.225.1"> method. </span><span class="koboSpan" id="kobo.225.2">Again, we are</span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.226.1"> defining a </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Path</span></strong><span class="koboSpan" id="kobo.228.1"> parameter on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">@Path("/{id}")</span></strong><span class="koboSpan" id="kobo.230.1"> annotation. </span><span class="koboSpan" id="kobo.230.2">The method body has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Uni</span></strong><span class="koboSpan" id="kobo.232.1"> pipeline that executes </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">routerManagementUseCase.removeRouter(id)</span></strong><span class="koboSpan" id="kobo.234.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Uni&lt;Response&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.238.1">Let’s implement the endpoint to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">new router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.240.1">
@POST
@Path("/")
public Uni&lt;Response&gt; createRouter(CreateRouter cre
  ateRouter) {
    /** Code omitted **/
    return Uni.createFrom()
            .item(
               routerManagementUseCase.
</span><span class="koboSpan" id="kobo.240.2">               persistRouter(router))
            .onItem()
            .transform(
             router -&gt; router != null ?
</span><span class="koboSpan" id="kobo.240.3">             Response.ok(f) :
             Response.ok(null))
            .onItem()
            .transform(Response.Response
               Builder::build);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.241.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">@POST</span></strong><span class="koboSpan" id="kobo.243.1"> annotation </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.244.1">because we’re creating a new resource. </span><span class="koboSpan" id="kobo.244.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">@Path("/")</span></strong><span class="koboSpan" id="kobo.246.1"> annotation at the method level, when concatenated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">@Path("/router")</span></strong><span class="koboSpan" id="kobo.248.1"> annotation at the class level, generates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">/router/</span></strong><span class="koboSpan" id="kobo.250.1"> path. </span><span class="koboSpan" id="kobo.250.2">We have the Reactive code in the method body to handle the request and </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">Uni&lt;Response&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.254.1">Next, we </span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.255.1">will implement the endpoint so that a router can be added to a </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">core router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.257.1">
@POST
@Path("/add")
public Uni&lt;Response&gt; addRouterToCoreRouter(AddRouter
  addRouter) {
    /** Code omitted **/
    return Uni.createFrom()
            .item(routerManagementUseCase.
</span><span class="koboSpan" id="kobo.257.2">                    addRouterToCoreRouter(router,
                      coreRouter))
            .onItem()
            .transform(
             router -&gt; router != null ?
</span><span class="koboSpan" id="kobo.257.3">             Response.ok(router) :
             Response.ok(null))
            .onItem()
            .transform(Response.Response
               Builder::build);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.258.1">Again, we </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.259.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">@POST</span></strong><span class="koboSpan" id="kobo.261.1"> annotation here. </span><span class="koboSpan" id="kobo.261.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">@Path("/add")</span></strong><span class="koboSpan" id="kobo.263.1"> annotation at </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.264.1">the method level, when concatenated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">@Path("/router")</span></strong><span class="koboSpan" id="kobo.266.1"> at the class level, generates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">/router/add</span></strong><span class="koboSpan" id="kobo.268.1"> path. </span><span class="koboSpan" id="kobo.268.2">The Reactive code creates a pipeline to execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">routerManagementUseCase.addRouterToCoreRouter(router, coreRouter)</span></strong><span class="koboSpan" id="kobo.270.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">Uni&lt;Response&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.274.1">Finally, we must implement the endpoint to remove a router from a </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">core router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.276.1">
@DELETE
@Path("/{routerId}/from/{coreRouterId}")
public Uni&lt;Response&gt; removeRouterFromCoreRouter(
    /** Code omitted **/
    return Uni.createFrom()
            .item(routerManagementUseCase.
</span><span class="koboSpan" id="kobo.276.2">                    removeRouterFromCoreRouter(
                    router, coreRouter))
            .onItem()
            .transform(
             router -&gt; router != null ?
</span><span class="koboSpan" id="kobo.276.3">                  Response.ok(f) :
                  Response.ok(null))
            .onItem()
            .transform(Response.Response
               Builder::build);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.277.1">Here, we </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.278.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">@DELETE</span></strong><span class="koboSpan" id="kobo.280.1"> annotation to handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">HTTP DELETE</span></strong><span class="koboSpan" id="kobo.282.1"> requests. </span><span class="koboSpan" id="kobo.282.2">In</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.283.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">@Path</span></strong><span class="koboSpan" id="kobo.285.1"> annotation, we have two path parameters – </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">routerId</span></strong><span class="koboSpan" id="kobo.287.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">coreRouterId</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">We use these two parameters to obtain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">Router</span></strong><span class="koboSpan" id="kobo.291.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.293.1"> objects when we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">routerManagementUseCase. </span><span class="koboSpan" id="kobo.294.2">removeRouterFromCoreRouter(router, coreRouter)</span></strong><span class="koboSpan" id="kobo.295.1"> inside the pipeline provided </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Uni</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.299.1">As we can see, when using Quarkus, it does not take too much to shift from an imperative to a Reactive way of implementing REST endpoints. </span><span class="koboSpan" id="kobo.299.2">Much of the work is done behind the scenes by the framework and </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">its libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Now, let’s move on and implement Reactive input adapters for </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">switch management.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.303.1">Implementing the Reactive input adapter for switch management</span></h2>
<p><span class="koboSpan" id="kobo.304.1">Following a </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.305.1">similar approach to the one we followed in the previous section, we can implement </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.306.1">the Reactive input adapters for switch management by executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.308.1">We will start by enabling JAX-RS on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">SwitchManagementAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.311.1">
@ApplicationScoped
@Path("/switch")
public class SwitchManagementAdapter {
    @Inject
    SwitchManagementUseCase switchManagementUseCase;
    @Inject
    RouterManagementUseCase routerManagementUseCase;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.312.1">This</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.313.1"> class is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">@Path("/switch")</span></strong><span class="koboSpan" id="kobo.315.1">, so all the switch management-related requests will be directed to it. </span><span class="koboSpan" id="kobo.315.2">Following this, we inject both </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.317.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.319.1"> to execute operations on the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">Application hexagon.</span></span></p></li> <li><span class="koboSpan" id="kobo.321.1">To enable switch retrieval in the topology and inventory system, we need to implement the Reactive behavior on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">retrieveSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.323.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.324.1">
@GET
@Path("/{id}")
public Uni&lt;Response&gt; retrieveSwitch(@PathParam("id")
  Id switchId) {
    return Uni.createFrom()
            .item(
             switchManagementUseCase.
</span><span class="koboSpan" id="kobo.324.2">             retrieveSwitch(switchId))
            .onItem()
            .transform(
             aSwitch -&gt; aSwitch != null ?
</span><span class="koboSpan" id="kobo.324.3">             Response.ok(aSwitch) :
             Response.ok(null))
            .onItem()
            .transform(Response.Response
               Builder::build);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.325.1">By adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">@GET</span></strong><span class="koboSpan" id="kobo.327.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">@Path</span></strong><span class="koboSpan" id="kobo.329.1"> annotations, we activate JAX-RS on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">retrieveSwitch</span></strong><span class="koboSpan" id="kobo.331.1"> method. </span><span class="koboSpan" id="kobo.331.2">We place </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">switchManagementUseCase.retrieveSwitch(switchId)</span></strong><span class="koboSpan" id="kobo.333.1"> so that it’s executed inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">Mutiny</span></strong><span class="koboSpan" id="kobo.335.1"> pipeline that </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Uni&lt;Response&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.339.1">The</span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.340.1"> call </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.341.1">on </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">item</span></strong><span class="koboSpan" id="kobo.343.1"> returns immediately. </span><span class="koboSpan" id="kobo.343.2">It triggers the operation that’s executed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">retrieveSwitch</span></strong><span class="koboSpan" id="kobo.345.1"> method and allows the thread to continue serving other requests. </span><span class="koboSpan" id="kobo.345.2">The result is obtained when we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">onItem</span></strong><span class="koboSpan" id="kobo.347.1">, which represents the continuation of the operation that’s triggered when we </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">item</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.351.1">Next, we </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.352.1">must add </span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.353.1">Reactive behavior to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">createAndAddSwitchToEdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
@POST
@Path("/create/{edgeRouterId}")
public Uni&lt;Response&gt; createAndAddSwitchToEdgeRouter(
            CreateSwitch createSwitch,
            @PathParam("edgeRouterId") Id
              edgeRouterId){
    /** Code omitted **/
    return Uni.createFrom()
            .item((EdgeRouter)
              routerManagementUseCase.
</span><span class="koboSpan" id="kobo.356.2">              persistRouter(router))
            .onItem()
            .transform(
             router -&gt; router != null ?
</span><span class="koboSpan" id="kobo.356.3">             Response.ok(f) :
             Response.ok(null))
            .onItem()
            .transform(Response.Response
              Builder::build);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.357.1">The preceding method handles the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">HTTP POST</span></strong><span class="koboSpan" id="kobo.359.1"> requests to create a switch object and add it to an edge router. </span><span class="koboSpan" id="kobo.359.2">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">routerManagementUseCase.persistRouter(router)</span></strong><span class="koboSpan" id="kobo.361.1"> method here, which is wrapped inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">Mutiny</span></strong><span class="koboSpan" id="kobo.363.1"> pipeline, to </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">Uni&lt;Response&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.367.1">Finally, we </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.368.1">must</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.369.1"> define the Reactive endpoint to remove a switch from an </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">edge router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
@DELETE
@Path("/{switchId}/from/{edgeRouterId}")
public Uni&lt;Response&gt; removeSwitchFromEdgeRouter(
        @PathParam("switchId") Id switchId,
        @PathParam("edgeRouterId") Id
          edgeRouterId) {
    /** Code omitted **/
    return Uni.createFrom()
            .item(
             (EdgeRouter)routerManagementUseCase.
</span><span class="koboSpan" id="kobo.371.2">              persistRouter(router))
            .onItem()
            .transform(
             router -&gt; router != null ?
</span><span class="koboSpan" id="kobo.371.3">             Response.ok(f) :
             Response.ok(null))
            .onItem()
            .transform(Response.Response
              Builder::build);
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.372.1">As we did with</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.373.1"> our previous removal operation, where we removed a router from a core router, we</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.374.1"> use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">@DELETE</span></strong><span class="koboSpan" id="kobo.376.1"> annotation to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">removeSwitchFromEdgeRouter</span></strong><span class="koboSpan" id="kobo.378.1"> method only accept the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">HTTP DELETE</span></strong><span class="koboSpan" id="kobo.380.1"> requests. </span><span class="koboSpan" id="kobo.380.2">We pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">Path</span></strong><span class="koboSpan" id="kobo.382.1"> parameters, </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">switchId</span></strong><span class="koboSpan" id="kobo.384.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">edgeRouterId</span></strong><span class="koboSpan" id="kobo.386.1">, to obtain the switch and edge router objects required for </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">the operation.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">After defining the Reactive endpoints for </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">retrieveSwitch</span></strong><span class="koboSpan" id="kobo.390.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">createAndAddSwitchToEdgeRouter</span></strong><span class="koboSpan" id="kobo.392.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">removeSwitchFromEdgeRouter</span></strong><span class="koboSpan" id="kobo.394.1">, we can start implementing the Reactive input adapter for </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">network management.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.396.1">Implementing the Reactive input adapter for network management</span></h2>
<p><span class="koboSpan" id="kobo.397.1">As you</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.398.1"> may imagine, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">network</span></strong><span class="koboSpan" id="kobo.400.1"> Reactive input adapter follows the same standard that’s </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.401.1">used by the router and switch Reactive adapters. </span><span class="koboSpan" id="kobo.401.2">In the following steps, we will enable Reactive behavior for endpoints related to </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">network management:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.403.1">Let’s start by enabling JAX-RS on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">NetworkManagementAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.405.1">input adapter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.406.1">
@ApplicationScoped
@Path("/network")
public class NetworkManagementAdapter {
    @Inject
    SwitchManagementUseCase switchManagementUseCase;
    @Inject
    NetworkManagementUseCase networkManagementUseCase;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.407.1">At this point, you may be familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">@Path</span></strong><span class="koboSpan" id="kobo.409.1"> annotation at the class level. </span><span class="koboSpan" id="kobo.409.2">We inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.411.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.413.1"> uses cases to assist in the operations that are executed by this </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">input adapter.</span></span></p></li> <li><span class="koboSpan" id="kobo.415.1">Next, we </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.416.1">must</span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.417.1"> define a Reactive endpoint so that networks can be added to </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">a switch:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.419.1">
@POST
@Path("/add/{switchId}")
public Uni&lt;Response&gt; addNetworkToSwitch(AddNetwork
  addNetwork,</span><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.420.1"> @PathParam("switchId") Id switchId) {
    /** Code omitted **/
    return Uni.createFrom()
            .item(
              networkManagementUseCase.
</span><span class="koboSpan" id="kobo.420.2">               addNetworkToSwitch(
               network, networkSwitch))
            .onItem()
            .transform(
              f -&gt; f != null ?
</span><span class="koboSpan" id="kobo.420.3">              Response.ok(f) :
              Response.ok(null))
            .onItem()
            .transform(Response.Response
               Builder::build);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.421.1">The</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.422.1"> idea we apply here is the same one we applied to the previous implementations. </span><span class="koboSpan" id="kobo.422.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.424.1"> method, we add some Reactive code</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.425.1"> that will use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Mutiny</span></strong><span class="koboSpan" id="kobo.427.1"> pipeline to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">networkManagementUseCase.addNetworkToSwitch( network, networkSwitch)</span></strong><span class="koboSpan" id="kobo.429.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Uni&lt;Response&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.433.1">Finally, we must define the Reactive endpoint to remove a network from </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">a switch:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.435.1">
@DELETE
@Path("/{networkName}/from/{switchId}")
public Uni&lt;Response&gt; removeNetworkFromSwitch(@Path
  Param("networkName") String networkName, @Path
    Param("switchId") Id         switchId) {
    /** Code omitted **/
    return Uni.createFrom()
            .item(
             networkManagementUseCase.
</span><span class="koboSpan" id="kobo.435.2">             removeNetworkFromSwitch(
             networkName, networkSwitch))
            .onItem()
            .transform(
              f -&gt; f != null ?
</span><span class="koboSpan" id="kobo.435.3">              Response.ok(f) :
              Response.ok(null))
            .onItem()
            .transform(Response.Response
              Builder::build);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.436.1">Here, we </span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.437.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">@DELETE</span></strong><span class="koboSpan" id="kobo.439.1"> annotation and two path parameters, </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">networkName</span></strong><span class="koboSpan" id="kobo.441.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">switchId</span></strong><span class="koboSpan" id="kobo.443.1">, to remove a network from a switch. </span><span class="koboSpan" id="kobo.443.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Mutiny</span></strong><span class="koboSpan" id="kobo.445.1"> pipeline, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">networkManagementUseCase.removeNetworkFromSwitch(networkName, networkSwitch)</span></strong><span class="koboSpan" id="kobo.447.1">. </span><span class="koboSpan" id="kobo.447.2">The pipeline result </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">Uni&lt;Response&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.451.1">With that, we have</span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.452.1"> finished implementing the Reactive input adapter for network management. </span><span class="koboSpan" id="kobo.452.2">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">RouterManagementAdapter</span></strong><span class="koboSpan" id="kobo.454.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">SwitchManagementAdapter</span></strong><span class="koboSpan" id="kobo.456.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">NetworkManagementAdapter</span></strong><span class="koboSpan" id="kobo.458.1"> input adapters are ready to serve HTTP requests in a </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">Reactive way.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">These three input adapters and their endpoints form the hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">system API.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">In this section, we not only learned how to create ordinary REST endpoints, but we also went the extra mile by using RESTEasy Reactive to enable Reactive behavior on the input adapter’s endpoints. </span><span class="koboSpan" id="kobo.462.2">That’s a fundamental step to tap into the advantages that a Reactive approach can provide. </span><span class="koboSpan" id="kobo.462.3">With the Reactive approach, we no longer need to depend on I/O blocking threads, which may consume more computing resources than I/O non-blocking threads. </span><span class="koboSpan" id="kobo.462.4">I/O blocking threads need to wait for I/O operations to finish. </span><span class="koboSpan" id="kobo.462.5">I/O non-blocking threads are more efficient because the same thread can handle several I/O operations at the </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">same time.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">The next section will cover how to use OpenAPI and Swagger UI to publish the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">system API.</span></span></p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.466.1">Adding OpenAPI and Swagger UI</span></h1>
<p><span class="koboSpan" id="kobo.467.1">Understanding and interacting with third-party systems is sometimes a non-trivial undertaking. </span><span class="koboSpan" id="kobo.467.2">In the best scenario, we may have the system documentation, an organized code base, and a set of APIs that, together, help us understand what the system does. </span><span class="koboSpan" id="kobo.467.3">In the worst scenario, we have none of these things. </span><span class="koboSpan" id="kobo.467.4">This challenging situation requires courage, patience, and persistence to venture into trying to understand a tangled code base with </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">intricate complexities.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">OpenAPI </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.470.1">represents an honorable effort to increase our capacity to express and understand what a system does. </span><span class="koboSpan" id="kobo.470.2">Originally based on the Swagger specification, the OpenAPI </span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.471.1">specification standardizes how APIs are documented and described so that anyone can grasp the capabilities offered by a system without </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">much effort.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">We spent the previous section implementing the Reactive input adapters that form the API of our hexagonal system. </span><span class="koboSpan" id="kobo.473.2">To make this system more understandable to other people and systems, we’ll use OpenAPI to describe the functionalities provided by the input adapters and their endpoints. </span><span class="koboSpan" id="kobo.473.3">Also, we’ll </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.474.1">enable </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">Swagger UI</span></strong><span class="koboSpan" id="kobo.476.1">, a web application that presents a clear and organized view of the </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">system’s APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">Quarkus comes </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.479.1">with built-in support </span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.480.1">for the </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">OpenAPI v3</span></strong><span class="koboSpan" id="kobo.482.1"> specification. </span><span class="koboSpan" id="kobo.482.2">To enable it, we need the following </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">Maven dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
&lt;dependencies&gt;
  &lt;</span><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.485.1">dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-smallrye-openapi&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</span></pre> <p><span class="koboSpan" id="kobo.486.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">quarkus-smallrye-openapi</span></strong><span class="koboSpan" id="kobo.488.1"> dependency provides the libraries that contain the OpenAPI annotations we can use to describe the Reactive endpoint methods on the input adapter classes. </span><span class="koboSpan" id="kobo.488.2">This dependency lets us configure Swagger </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">UI, too.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">Remember that we configured four Java modules: </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">domain</span></strong><span class="koboSpan" id="kobo.492.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">application</span></strong><span class="koboSpan" id="kobo.494.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">framework</span></strong><span class="koboSpan" id="kobo.496.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">bootstrap</span></strong><span class="koboSpan" id="kobo.498.1">. </span><span class="koboSpan" id="kobo.498.2">To activate and configure Swagger UI, we need to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">resource/application.properties</span></strong><span class="koboSpan" id="kobo.500.1"> file inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">bootstrap</span></strong><span class="koboSpan" id="kobo.502.1"> module. </span><span class="koboSpan" id="kobo.502.2">Here is how we can configure </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">this file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.504.1">
quarkus.swagger-ui.always-include=true
quarkus.swagger-ui.urls-primary-name=Topology &amp; Inventory
quarkus.swagger-ui.theme=material
quarkus.swagger-ui.title=Topology &amp; Inventory - Network
  Management System
quarkus.swagger-ui.footer=&amp;#169; 2021 | Davi Vieira
quarkus.swagger-ui.display-operation-id=true
mp.openapi.extensions.smallrye.info.title=Topology &amp; Inven
  tory API
mp.openapi.extensions.smallrye.info.version=1.0
mp.openapi.extensions.smallrye.info.description=Manage net
  works assets</span></pre> <p><span class="koboSpan" id="kobo.505.1">We set </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">quarkus.swagger-ui.always-include</span></strong><span class="koboSpan" id="kobo.507.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">true</span></strong><span class="koboSpan" id="kobo.509.1"> to ensure that Swagger UI will also be available when the application is started using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">prod</span></strong><span class="koboSpan" id="kobo.511.1"> (production) profile – one of</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.512.1"> the built-in Quarkus profiles. </span><span class="koboSpan" id="kobo.512.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">quarkus.swagger-ui.theme</span></strong><span class="koboSpan" id="kobo.514.1">, we can configure the interface theme. </span><span class="koboSpan" id="kobo.514.2">We will use the remaining properties to provide a high-level description of </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">Let’s learn how to use </span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.517.1">the OpenAPI annotations to expose and describe the hexagonal system’s endpoints. </span><span class="koboSpan" id="kobo.517.2">Look at the following example from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">RouterManagementAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.519.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
@ApplicationScoped
@Path("/router")
@Tag(name = "Router Operations", description = "Router man
  agement operations")
public class RouterManagementAdapter {
    @GET
    @Path("/retrieve/{id}")
    @Operation(operationId = "retrieveRouter",
    description = "Retrieve a router from the network
      inventory")
    public Uni&lt;Response&gt; retrieveRouter(@PathParam("id")
      Id id) {
     /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.521.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">@Tag</span></strong><span class="koboSpan" id="kobo.523.1"> annotation, which is used at the class level, lets us define the metadata information that’s applied for all the endpoints defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">RouterManagementAdapter</span></strong><span class="koboSpan" id="kobo.525.1"> class. </span><span class="koboSpan" id="kobo.525.2">This</span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.526.1"> means that the method endpoints, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.528.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">RouterManagementAdapter</span></strong><span class="koboSpan" id="kobo.530.1"> class, will inherit that class-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">Tag</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">@Operation</span></strong><span class="koboSpan" id="kobo.536.1"> annotation</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.537.1"> to provide details of an operation. </span><span class="koboSpan" id="kobo.537.2">In the preceding code, we’re describing the operation that’s performed at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">/retrieve/{id}</span></strong><span class="koboSpan" id="kobo.539.1"> path. </span><span class="koboSpan" id="kobo.539.2">We have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">operationId</span></strong><span class="koboSpan" id="kobo.541.1"> parameter here, which is used to uniquely identify the endpoint, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">description</span></strong><span class="koboSpan" id="kobo.543.1"> parameter, which is used to provide a meaningful </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">operation description.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">To make Quarkus and Swagger UI display a fancy UI of our hexagonal system’s API, we just need to add these OpenAPI annotations to the classes and methods (properly configured with JAX-RS) that we want to expose on </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">Swagger UI.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">You can compile and run the application using the code from this book’s GitHub repository. </span><span class="koboSpan" id="kobo.547.2">Make sure that you execute the following commands in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">chapter12</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.549.1"> directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.550.1">
$ mvn clean package
$ java -jar bootstrap/target/bootstrap-1.0-SNAPSHOT-runner.jar</span></pre> <p><span class="koboSpan" id="kobo.551.1">This will open the following URL on </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">your browser:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
http://localhost:8080/q/swagger-ui/</span></pre> <p><span class="koboSpan" id="kobo.554.1">Also, you’ll see something similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.556.1"><img alt="Figure 12.4 – Swagger UI from topology and inventory system" src="image/B19777_12_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.557.1">Figure 12.4 – Swagger UI from topology and inventory system</span></p>
<p><span class="koboSpan" id="kobo.558.1">In the preceding </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.559.1">screenshot, the operations are grouped into </span><strong class="bold"><span class="koboSpan" id="kobo.560.1">Network Operations</span></strong><span class="koboSpan" id="kobo.561.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.562.1">Router Operations</span></strong><span class="koboSpan" id="kobo.563.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.564.1">Switch Operations</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">These groups come from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">@Tag</span></strong><span class="koboSpan" id="kobo.567.1"> annotation </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.568.1">we inserted for each of the input adapter classes. </span><span class="koboSpan" id="kobo.568.2">Each endpoint inherited its respective </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">@Tag</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.570.1">metadata information.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">So far, we have our hexagonal system properly configured with Reactive endpoints that are well documented with OpenAPI and Swagger UI. </span><span class="koboSpan" id="kobo.571.2">Now, let’s learn how to test these endpoints to ensure they are working </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">as expected.</span></span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.573.1">Testing Reactive input adapters</span></h1>
<p><span class="koboSpan" id="kobo.574.1">Our testing efforts started on the </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.575.1">Domain hexagon by unit testing the core system components. </span><span class="koboSpan" id="kobo.575.2">Then, we moved on to the Application hexagon, where we could test the</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.576.1"> use cases using </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">behavior-driven design</span></strong><span class="koboSpan" id="kobo.578.1"> techniques. </span><span class="koboSpan" id="kobo.578.2">Now that we have implemented Reactive REST endpoints on the Framework hexagon, we need to find a way to </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">test them.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">Fortunately, Quarkus comes well equipped when it comes to endpoint testing. </span><span class="koboSpan" id="kobo.580.2">To get started, we need the </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">following dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.582.1">
&lt;dependencies&gt;</span><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.583.1">
  &lt;dependency&gt;
    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
    &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</span></pre> <p><span class="koboSpan" id="kobo.584.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">rest-assured</span></strong><span class="koboSpan" id="kobo.586.1"> dependency </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.587.1">allows us to test HTTP endpoints. </span><span class="koboSpan" id="kobo.587.2">It provides an intuitive library that’s very useful for making requests and extracting responses from </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">HTTP calls.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">To see how it works, let’s implement a test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">router/retrieve/{routerId}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1"> endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
@Test
@Order(1)
public void retrieveRouter() throws IOException {
    var expectedRouterId =
      "b832ef4f-f894-4194-8feb-a99c2cd4be0c";
    var routerStr = given()
            .contentType("application/json")
            .pathParam("routerId", expectedRouterId)
            .when()
            .get("/router/retrieve/{routerId}")
            .then()
            .statusCode(200)
            .extract()
            .asString();
    var actualRouterId =
    getRouterDeserialized(routerStr).getId().getUuid()
      .toString();
    assertEquals(expectedRouterId, actualRouterId);
}</span></pre> <p><span class="koboSpan" id="kobo.594.1">To create a request, we </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.595.1">can use the static </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">io.restassured.RestAssured.given</span></strong><span class="koboSpan" id="kobo.597.1"> method. </span><span class="koboSpan" id="kobo.597.2">We can specify the content type, parameters, HTTP method, and body of a request with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">given</span></strong><span class="koboSpan" id="kobo.599.1"> method. </span><span class="koboSpan" id="kobo.599.2">After sending the request, we can check its status with </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">statusCode</span></strong><span class="koboSpan" id="kobo.601.1">. </span><span class="koboSpan" id="kobo.601.2">To obtain the response, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">extract</span></strong><span class="koboSpan" id="kobo.603.1">. </span><span class="koboSpan" id="kobo.603.2">In the following example, we’re getting the response in the form of a string. </span><span class="koboSpan" id="kobo.603.3">This is because the return type of the Reactive endpoint is </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">Uni&lt;Response&gt;</span></strong><span class="koboSpan" id="kobo.605.1">. </span><span class="koboSpan" id="kobo.605.2">So, the result is a </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">JSON string.</span></span></p>
<p><span class="koboSpan" id="kobo.607.1">We need to deserialize the JSON string into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">Router</span></strong><span class="koboSpan" id="kobo.609.1"> object before running assertions. </span><span class="koboSpan" id="kobo.609.2">The deserialization work is accomplished by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">getRouterDeserialized</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
public static Router getRouterDeserialized(String jsonStr)
  throws IOException {
    var mapper = new ObjectMapper();
    var module = new SimpleModule();
    module.addDeserializer(Router.class, new
      RouterDeserializer());
    mapper.registerModule(module);
    var router = mapper.readValue(jsonStr, Router.class);
    return router;
}</span></pre> <p><span class="koboSpan" id="kobo.613.1">This method receives a JSON string as a parameter. </span><span class="koboSpan" id="kobo.613.2">This JSON string is passed to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">ObjectMapper</span></strong><span class="koboSpan" id="kobo.615.1"> mapper when we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">mapper.readValue(jsonStr, Router.class)</span></strong><span class="koboSpan" id="kobo.617.1">. </span><span class="koboSpan" id="kobo.617.2">In addition to providing a mapper, we also need to extend and implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">deserialize</span></strong><span class="koboSpan" id="kobo.619.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">com.fasterxml.jackson.databind.deser.std.StdDeserializer</span></strong><span class="koboSpan" id="kobo.621.1"> class. </span><span class="koboSpan" id="kobo.621.2">In the preceding example, this implementation is provided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">RouterDeserializer</span></strong><span class="koboSpan" id="kobo.623.1">. </span><span class="koboSpan" id="kobo.623.2">This deserializer will transform the JSON string</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.624.1"> into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">Router</span></strong><span class="koboSpan" id="kobo.626.1"> object, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
public class RouterDeserializer extends StdDeserial
  izer&lt;Router&gt; {
    /** Code omitted **/
    @Override
    public Router deserialize(JsonParser jsonParser,
    DeserializationContext ctxt)
            throws IOException {
        JsonNode node =
        jsonParser.getCodec().readTree(jsonParser);
        var id = node.get("id").get("uuid").asText();
        var vendor = node.get("vendor").asText();
        var model = node.get("model").asText();
        var ip = node.get("ip").get("ipAddress").asText();
        var location = node.get("location");
        var routerType = RouterType.valueOf(
          node.get("routerType").asText());
        var routersNode = node.get("routers");
        var switchesNode = node.get("switches");
        /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.629.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">deserialize</span></strong><span class="koboSpan" id="kobo.631.1"> method intends to map every relevant JSON attribute to a domain type. </span><span class="koboSpan" id="kobo.631.2">We perform</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.632.1"> this mapping by retrieving the values we want from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">JsonNode</span></strong><span class="koboSpan" id="kobo.634.1"> object. </span><span class="koboSpan" id="kobo.634.2">After mapping the values that we want, we can create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">router</span></strong><span class="koboSpan" id="kobo.636.1"> object, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
var router = RouterFactory.getRouter(
        Id.withId(id),
        Vendor.valueOf(vendor),
        Model.valueOf(model),
        IP.fromAddress(ip),
        getLocation(location),
        routerType);</span></pre> <p><span class="koboSpan" id="kobo.639.1">Once all the values have been retrieved, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">RouterFactory.getRouter</span></strong><span class="koboSpan" id="kobo.641.1"> to produce a </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">Router</span></strong><span class="koboSpan" id="kobo.643.1"> object. </span><span class="koboSpan" id="kobo.643.2">Because a router may have child routers and switches, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">fetchChildRouters</span></strong><span class="koboSpan" id="kobo.645.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">fetchChildSwitches</span></strong><span class="koboSpan" id="kobo.647.1"> so that they also have </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">StdDeserializer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.649.1"> implementations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.650.1">
fetchChildRouters(routerType, routersNode, router);
fetchChildSwitches(routerType, switchesNode, router);</span></pre> <p><span class="koboSpan" id="kobo.651.1">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">fetchChildRouters</span></strong><span class="koboSpan" id="kobo.653.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">fetchChildSwitches</span></strong><span class="koboSpan" id="kobo.655.1"> methods because a router may have child routers and switches that need to be deserialized. </span><span class="koboSpan" id="kobo.655.2">These methods will perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">required deserialization.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">After deserializing the JSON string response, we can run the assertion on a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">Router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.660.1">
var actualRouterId = getRouterDeserialized(router
  Str).getId().getUuid().toString();
assertEquals(expectedRouterId, actualRouterId);</span></pre> <p><span class="koboSpan" id="kobo.661.1">To test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">/router/retrieve/{routerId}</span></strong><span class="koboSpan" id="kobo.663.1"> endpoint, we are checking whether the ID of the router that’s been retrieved by the Reactive endpoint is equal to the one we passed in </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">the request.</span></span></p>
<p><span class="koboSpan" id="kobo.665.1">You can run this and other tests that are available in this book’s GitHub repository by executing the following command inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">Chapter12</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1"> directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.668.1">
$ mvn test</span></pre> <p><span class="koboSpan" id="kobo.669.1">The output of</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.670.1"> the preceding code will be similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.672.1">
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running dev.davivieira.topologyinventory.framework.adapters.input.rest.NetworkManagementAdapterTest
2021-09-29 00:47:36,825 INFO  [io.quarkus] (main) Quarkus 2.2.1.Final on JVM started in 2.550s. </span><span class="koboSpan" id="kobo.672.2">Listening on: http://localhost:8081
2021-09-29 00:47:36,827 INFO  [io.quarkus] (main) Profile test activated.
</span><span class="koboSpan" id="kobo.672.3">2021-09-29 00:47:36,827 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy-reactive, resteasy-reactive-jackson, smallrye-context-propagation, smallrye-openapi, swagger-ui]
[EL Info]: 2021-09-29 00:47:38.812--ServerSession(751658062)--EclipseLink, version: Eclipse Persistence Services - 3.0.1.v202104070723
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.418 s - in dev.davivieira.topologyinventory.framework.adapters.input.rest.NetworkManagementAdapterTest
[INFO] Running dev.davivieira.topologyinventory.framework.adapters.input.rest.RouterManagementAdapterTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.226 s - in dev.davivieira.topologyinventory.framework.adapters.input.rest.RouterManagementAdapterTest
[INFO] Running dev.davivieira.topologyinventory.framework.adapters.input.rest.SwitchManagementAdapterTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.085 s - in dev.davivieira.topologyinventory.framework.adapters.input.rest.SwitchManagementAdapterTest
2021-09-29 00:47:39,675 INFO  [io.quarkus] (main) Quarkus stopped in 0.032s</span></pre> <p><span class="koboSpan" id="kobo.673.1">The preceding output describes the execution of the Reactive endpoint tests for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">RouterManagementAdapter</span></strong><span class="koboSpan" id="kobo.675.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">SwitchManagementAdapter</span></strong><span class="koboSpan" id="kobo.677.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">NetworkManagementAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.679.1">input adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">One benefit </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.681.1">of executing these endpoint tests is that we are not only testing the endpoint functionality on the Framework hexagon but also performing comprehensive tests that check the behavior of all the hexagons of </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">the system.</span></span></p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.683.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.684.1">In this chapter, we had the opportunity to dive into more Quarkus features, especially RESTEasy Reactive. </span><span class="koboSpan" id="kobo.684.2">We started by reviewing what imperative and reactive mean in the context of </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">client-server communication.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">Then, we learned that Quarkus provides RESTEasy Reactive as its JAX-RS implementation, enabling us to implement Reactive endpoints on input adapters. </span><span class="koboSpan" id="kobo.686.2">After that, we exposed the hexagonal system’s API using OpenAPI and Swagger UI. </span><span class="koboSpan" id="kobo.686.3">To ensure we implemented the Reactive endpoints correctly, we wrote the endpoint tests using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">rest-assured</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.688.1"> library.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">In the next chapter, we’ll continue exploring the Reactive capabilities offered by Quarkus and emphasize the data persistence aspects with </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">Hibernate Reactive.</span></span></p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.691.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.692.1">What is the difference between imperative and </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">reactive requests?</span></span></li>
<li><span class="koboSpan" id="kobo.694.1">What is the name of the JAX-RS implementation provided </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">by Quarkus?</span></span></li>
<li><span class="koboSpan" id="kobo.696.1">What is the purpose </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">of OpenAPI?</span></span></li>
<li><span class="koboSpan" id="kobo.698.1">Which library should we use in Quarkus to test </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">HTTP endpoints?</span></span></li>
</ol>
<h1 id="_idParaDest-208"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.700.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.701.1">Imperative can only handle one request at a time using an I/O blocking worker thread. </span><span class="koboSpan" id="kobo.701.2">Reactive can handle multiple requests using I/O </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">non-blocking threads.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.703.1">RESTEasy Reactive.</span></span></li>
<li><span class="koboSpan" id="kobo.704.1">It’s used to standardize the way APIs are described </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">and documented.</span></span></li>
<li><span class="koboSpan" id="kobo.706.1">We should use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">rest-assured</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.708.1"> library.</span></span></li>
</ol>
</div>
</body></html>