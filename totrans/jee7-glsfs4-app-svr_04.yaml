- en: Chapter 4. Enterprise JavaBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enterprise JavaBeans are server side components that encapsulate business logic
    of an application. Enterprise JavaBeans simplify application development by automatically
    managing transaction management and security. There are two types of Enterprise
    JavaBeans: Session beans, which execute business logic, and message-driven beans,
    which act as a message listener.'
  prefs: []
  type: TYPE_NORMAL
- en: Readers familiar with J2EE may notice that Entity Beans haven't been mentioned
    in the previous paragraph. In Java EE 5, Entity Beans were deprecated in favor
    of the **Java Persistence API** (**JPA**). Entity Beans are still supported for
    backwards compatibility, however, the preferred way of performing Object-relational
    mapping is through JPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Session beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple session bean
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A more realistic example
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a session bean to implement the DAO design pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton session beans
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Message-driven beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions in Enterprise JavaBeans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container-managed transactions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean-managed transactions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise JavaBeans life cycles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stateful session bean life cycle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A stateless session bean life cycle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Message-driven bean life cycle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The EJB Timer Service
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: EJB Security
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to session beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've previously mentioned, session beans typically encapsulate business
    logic. In Java EE, only one or two artifacts need to be created in order to create
    a session bean, namely, the bean itself and an optional business interface. These
    artifacts need to be decorated with the proper annotations to let the EJB container
    know they are session beans.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: J2EE required application developers to create several artifacts in order to
    create a session bean. These artifacts included the bean itself, a local or remote
    interface (or both), a local home or a remote home interface (or both), and an
    XML deployment descriptor. As we shall see in this chapter, EJB development was
    greatly simplified in Java EE.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a simple session bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example illustrates a very simple session bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Stateless` annotation lets the EJB container know that this class is
    a stateless session bean. There are three types of session beans: stateless, stateful,
    and singleton. Before we explain the difference between these types of session
    beans, we need to clarify how an instance of an EJB is provided to an EJB client
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: When a stateless or stateful session bean is deployed, the EJB container creates
    a series of instances of each session bean. This is what is typically referred
    to as an EJB pool. When an EJB client application obtains an instance of EJB,
    the application server (GlassFish, in our case) provides one of the instances
    in the pool to the client application.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between stateful and stateless session beans is that stateful
    session beans maintain a conversational state with the client, whereas stateless
    session beans do not. In simple terms, what this means is that when an EJB client
    application obtains an instance of a stateful session bean, we are guaranteed
    that the values of any instance variables in the bean will be consistent across
    method calls. It is safe to modify any instance variables on a stateful session
    bean, since they will retain their values for the next method call. The EJB container
    saves the conversational state by passivating stateful session beans, and retrieves
    that state when the bean is activated. Conversational state is the reason why
    the life cycle of stateful session beans is a bit more complex than that of stateless
    session beans and message driven beans (EJB life cycle is discussed later in this
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The EJB container may provide any instance of EJB from the pool when an EJB
    client application requests an instance of a stateless session bean. Since we
    are not guaranteed the same instance for every method call, values set to any
    instance variables in a stateless session bean may be "lost" (they are not really
    lost; the modification is in another instance of the EJB in the pool).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than being decorated with the `@Stateless` annotation, there is nothing
    special about the previous class. Notice that it implements an interface called
    `SimpleSession`. This interface is the bean''s business interface. The `SimpleSession`
    interface is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The only peculiar thing about this interface is that it is decorated with the
    `@Remote` annotation. This annotation indicates that this is a remote business
    interface. What this means is that the interface may be in a different JVM than
    the client application invoking it. Remote business interfaces may even be invoked
    across the network.
  prefs: []
  type: TYPE_NORMAL
- en: Business interfaces may also be decorated with the `@Local` interface. This
    annotation indicates that the business interface is a local business interface.
    Local business interface implementations must be in the same JVM as the client
    application invoking its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Since remote business interfaces can be invoked either from the same JVM or
    a different one than the client application, at first glance, we might be tempted
    to make all of our business interfaces remote. Before doing so, we must remind
    ourselves of the fact that the flexibility provided by remote business interfaces
    comes with a performance penalty, since method invocations are made under the
    assumption that they will be made across the network. As a matter of fact, most
    typical Java EE applications consist of web applications acting as client applications
    for EJBs; in such cases, the client application and the EJB are running on the
    same JVM, therefore local interfaces are used a lot more frequently than remote
    business interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have compiled the session bean and its corresponding business interface,
    we need to place them in a JAR file and deploy them. Just like with WAR files,
    the easiest way to deploy an EJB JAR file is by copying it to `[glassfish installation
    directory]/glassfish/domains/domain1/autodeploy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the session bean and its corresponding business interface,
    let''s take a look at a client sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous code simply declares an instance variable of the type `net.ensode.SimpleSession`,
    which is the business interface for our session bean. The instance variable is
    decorated with the `@EJB` annotation. The `@EJB` annotation lets the EJB container
    know that this variable is a business interface for a session bean. The EJB container
    then injects an implementation of the business interface for the client code to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our client is a standalone application (as opposed to being a Java EE
    artifact, such as a WAR file or another EJB JAR file), in order for it to be able
    to access the code deployed in the server, it must be placed in a JAR file and
    executed through the appclient utility. The appclient utility is a GlassFish-specific
    tool that allows standalone Java applications to access resources deployed to
    the application server. This utility can be found at `[glassfish installation
    directory]/glassfish/bin/`. Assuming that this directory is in the `PATH` environment
    variable and that we''ve placed our client code in a JAR file called `simplesessionbeanclient.jar`,
    we will execute the previous client code by typing the following command in the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the previous command results in the following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That is the output of the `SessionBeanClient` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using Maven to build our code. For this example, we used the Maven Assembly
    plugin ([http://maven.apache.org/plugins/maven-assembly-plugin/](http://maven.apache.org/plugins/maven-assembly-plugin/))
    to build a client JAR file that includes all dependencies; this frees us from
    having to specify all the dependent JAR files in the `-classpath` command-line
    option of the `appclient` utility. To build this JAR file, simply invoke `mvn
    assembly:assembly` from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the output is simply the return value of the `getMessage()`
    method we implemented in the session bean. The second line of output displays
    the fully qualified class name of the class implementing the business interface.
    Notice that the class name is not the fully qualified name of the session bean
    we wrote; instead, what is actually provided is an implementation of the business
    interface created behind the scenes by the EJB container.
  prefs: []
  type: TYPE_NORMAL
- en: A more realistic example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw a very simple, "Hello world" type of example.
    In this section, we will show a more realistic example. Session beans are frequently
    used as **Data Access Objects** (**DAOs**). Sometimes, they are used as wrappers
    for JDBC calls and other times, they are used to wrap calls to obtain or modify
    JPA entities. In this section, we will take the latter approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to implement the DAO design pattern in
    a session bean. Before looking at the bean implementation, let''s look at the
    business interface it corresponds to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the previous code is a remote interface implementing three methods:
    `the saveCustomer()` method saves customer data to the database, the `getCustomer()`
    method obtains data for a customer from the database, and the `deleteCustomer()`
    method deletes customer data from the database. Two of these methods take an instance
    of the `Customer` entity we developed in [Chapter 3](ch03.html "Chapter 3. Object
    Relational Mapping with JPA"), *Object Relational Mapping with JPA*, as their
    parameters. The third method, `getCustomer()`, takes a `Long` value representing
    the ID of the `Customer` object we wish to retrieve from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at the session bean implementing the previous business
    interface. As we are about to see in the following code, there are some differences
    between the way the JPA code is implemented in a session bean and the way it is
    implemented in a plain old Java object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between our session bean and previous JPA examples is that
    JPA calls were wrapped between calls to `UserTransaction.begin()` and `UserTransaction.commit()`.
    The reason we had to do this is because JPA calls are required to be wrapped in
    a transaction; if they are not wrapped in a transaction, most JPA calls will throw
    `TransactionRequiredException`. In this case we don't have to explicitly wrap
    JPA calls in a transaction as in previous examples, since session bean methods
    are implicitly transactional; there is nothing we need to do to make them that
    way. This default behavior is what is known as **Container-Managed Transactions**.
    Container-managed transactions are discussed in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 3](ch03.html "Chapter 3. Object Relational Mapping
    with JPA"), *Object Relational Mapping with JPA*, when a JPA entity is retrieved
    from one transaction and updated to a different transaction, the `EntityManager.merge()`
    method needs to be invoked to update the data in the database. Invoking `EntityManager.persist()`
    in this case will result in a `Cannot persist detached object` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking session beans from web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frequently, Java EE applications consist of web applications acting as clients
    for EJBs. Before Java EE 6, the most common way of deploying a Java EE application
    that consists of both a web application and one or more session beans was by packaging
    both the WAR file for the web application and the EJB JAR files into an EAR (Enterprise
    Archive) file.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE 6 simplified the packaging and deployment of applications consisting
    of both EJB's and web components.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will develop a JSF application with a CDI named bean acting
    as a client to the DAO session bean we just discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make this application act as an EJB client, we will develop a `CustomerController`
    named bean so that it delegates the logic to save a new customer to the database
    to the `CustomerDaoBean` session bean we developed in the previous section. We
    will develop a `CustomerController` named bean, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, all we had to do was declare an instance of the `CustomerDaoBean`
    session bean and decorate it with the `@EJB` annotation so that an instance of
    the corresponding EJB is injected, and then invoke the EJB `saveCustomer()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we injected an instance of the session bean directly into our client
    code. The reason we can do this is because of a feature introduced in Java EE
    6\. When using Java EE 6 or newer, we can do away with local interfaces and use
    session bean instances directly in our client code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have modified our web application to be a client for our session
    bean, we need to package it in a WAR (web archive) file and deploy it in order
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to singleton session beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A new type of session bean that was introduced in Java EE 6 is the singleton
    session bean. A single instance of each singleton session bean exists per application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Singleton session beans are useful to cache database data. Caching frequently
    used data in a singleton session bean increases performance, since it greatly
    minimizes trips to the database. The common pattern is to have a method in our
    bean decorated with the `@PostConstruct` annotation; in this method, we retrieve
    the data we want to cache. Then we provide a setter method for the bean''s clients
    to call. The following example illustrates this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since our bean is a singleton, all of its clients would access the same instance,
    avoiding multiple queries to the database. Additionally, since it is a singleton,
    it is safe to specify an instance variable, as all clients access the same instance
    of the bean.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous method calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it is useful to do some processing asynchronously, that is, invoke
    a method call and return control to the client immediately, without making the
    client wait for the method to finish.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier versions of Java EE, the only way to invoke EJB methods asynchronously
    was using message-driven beans (which is discussed in the next section). Although
    message-driven beans are fairly easy to write, they do require some configuration
    before they can be used, such as setting up JMS message queues or topics.
  prefs: []
  type: TYPE_NORMAL
- en: EJB 3.1 introduced the `@Asynchronous` annotation, which can be used to mark
    a method in a session bean as asynchronous. When an EJB client invokes an asynchronous
    method, control immediately goes back to the client, without waiting for the method
    to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous methods can only return void or an implementation of the `java.util.concurrent.Future`
    interface. The `Future` interface was introduced in Java 5 and represents the
    result of an asynchronous computation. The following example illustrates both
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When our asynchronous method returns void, the only thing we need to do is decorate
    the method with the `@Asynchronous` annotation, then call it as usual from the
    client code.
  prefs: []
  type: TYPE_NORMAL
- en: If we need a return value, this value needs to be wrapped in an implementation
    of the `jav.util.concurrent.Future` interface. The Java EE API provides a convenience
    implementation in the form of the `javax.ejb.AsyncResult` class. Both the `Future`
    interface and the `AsyncResult` class use generics, so we need to specify our
    return type as the type parameter of these artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Future` interface has several methods we can use to cancel the execution
    of an asynchronous method, check to see whether or not the method is finished,
    get the return value of the method, and check to see whether or not the method
    is canceled. The following table lists these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cancel(boolean mayInterruptIfRunning)` | This method cancels method execution.
    If the boolean parameter is `true`, this method will attempt to cancel the method
    execution even if it is already running. |'
  prefs: []
  type: TYPE_TB
- en: '| `get()` | This method will return the "unwrapped" return value of the method;
    it will be of the type parameter of the `Future` interface implementation returned
    by the method. |'
  prefs: []
  type: TYPE_TB
- en: '| `get(long timeout, TimeUnit unit)` | This method will attempt to get the
    `unwrapped` return value of the method; the return value will be of the type parameter
    of the `Future` interface implementation returned by the method. This method will
    block for the amount of time specified by the first parameter. The unit of time
    to wait is determined by the second parameter, the `TimeUnit` enum has constants
    for NANOSECONDS, MILLISECONDS, SECONDS, MINUTES, and so on. Refer to its Javadoc
    documentation for the complete list. |'
  prefs: []
  type: TYPE_TB
- en: '| `isCancelled()` | This method returns `true` if the method has been cancelled;
    otherwise, it returns `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `isDone()` | This method returns `true` if the method has finished executing;
    otherwise, it returns `false`. |'
  prefs: []
  type: TYPE_TB
- en: As we can see, the `@Asynchronous` annotation makes it very easy to make asynchronous
    calls without suffering the overhead of having to set up message queues or topics.
    It is certainly a welcome addition to the EJB specification.
  prefs: []
  type: TYPE_NORMAL
- en: Message-driven beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Message Service** (**JMS**) is a Java EE API used for asynchronous
    communication between different applications. JMS messages are stored in either
    message queues or message topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of a message-driven bean is to consume messages from a JMS queue
    or a JMS topic, depending on the messaging domain used (refer to [Chapter 8](ch08.html
    "Chapter 8. The Java Message Service"), *The Java Message Service*). A message-driven
    bean must be decorated with the `@MessageDriven` annotation. The `mappedName`
    attribute of this annotation must contain the JNDI name of the JMS message queue
    or JMS message topic that the bean will be consuming messages from. The following
    example illustrates a simple message driven bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended, but not required, for message-driven beans to implement the
    `javax.jms.MessageListener` interface. However, message-driven beans must have
    a method called `onMessage()` whose signature is identical to that in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Client applications never invoke a message-driven bean's methods directly. Instead,
    they put messages in a message queue or topic, then the bean consumes those messages
    and acts appropriately. The previous example simply prints the message to standard
    output, since message-driven beans execute within an EJB container; standard output
    gets redirected to a log. To see the messages in the GlassFish's server log, open
    the `[GlassFish installation directory]/glassfish/domains/domain1/logs/server.log`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in Enterprise JavaBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier in this chapter, by default, all EJB methods are automatically
    wrapped in a transaction. This default behavior is known as **Container-managed
    transactions**, since transactions are managed by the EJB container. Application
    developers may also choose to manage transactions themselves; this can be accomplished
    using bean-managed transactions. Both of these approaches are discussed in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Container-managed transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because EJB methods are transactional by default, we run into an interesting
    dilemma when an EJB method is invoked from client code that is already in a transaction.
    How should the EJB container behave? Should it suspend the client transaction,
    execute its method in a new transaction, then resume the client transaction? Should
    it not create a new transaction and execute its method as part of the client transaction?
    Should it throw an exception?
  prefs: []
  type: TYPE_NORMAL
- en: By default, if an EJB method is invoked by a client code that is already in
    a transaction, the EJB container will simply execute the session bean method as
    part of the client transaction. If this is not the behavior we need, we can change
    it by decorating the method with the `@TransactionAttribute` annotation. This
    annotation has a `value` attribute that determines how the EJB container will
    behave when the session bean method is invoked within an existing transaction
    and also when it is invoked outside any transactions. The value of the `value`
    attribute is typically a constant defined in the `javax.ejb.TransactionAttributeType`
    enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the possible values for the `@TransactionAttribute`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| @TransactionAttribute value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.MANDATORY` | Forces the method to be invoked as
    part of a client transaction. If this method is called outside any transactions,
    it will throw a `TransactionRequiredException` exceptiom |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.NEVER` | The method is never executed in a transaction.
    If it is invoked as part of a client transaction, it will throw a `RemoteException`
    exception No transaction is created if the method is not invoked within a client
    transaction. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.NOT_SUPPORTED` | The method is invoked as part
    of a client transaction, the client transaction is suspended and the method is
    executed outside any transaction. After the method is executed, the client transaction
    is resumed. No transaction is created if the method is not invoked within the
    client transaction. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.REQUIRED` | The method is invoked as part of a
    client transaction, it is executed as part of that transaction. If the method
    is invoked outside a transaction, a new transaction is created for the method.
    This is the default behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.REQUIRES_NEW` | The method is invoked as part of
    a client transaction, that transaction is suspended, and a new transaction is
    created for the method. Once the method executes, the client transaction is resumed.
    If the method is called outside a transaction, a new transaction is created for
    the method. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.SUPPORTS` | The method is invoked as part of a
    client transaction, it is executed as part of that transaction. If the method
    is invoked outside a transaction, no new transaction is created for the method.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Although the default transaction attribute is reasonable in most cases, it
    is good to be able to override this default if necessary. For example, transactions
    have a performance impact. Therefore, being able to turn off transactions for
    a method that does not need them is beneficial. For a case like this, we would
    decorate our method, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Other transaction attribute types can be declared by annotating the methods
    with the corresponding constant in the `TransactionAttributeType` enum.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to override the default transaction attribute consistently across
    all methods in a session bean, we can decorate the session bean class with the
    `@TransactionAttribute` annotation; the value of its `value` attribute will be
    applied to every method in the session bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Container-managed transactions are automatically rolled back whenever an exception
    is thrown within an EJB method. Additionally, we can programmatically roll back
    a container-managed transaction by invoking the `setRollbackOnly()` method on
    an instance of `javax.ejb.EJBContext` corresponding to the session bean in question.
    The following example is a new version of the session bean we saw earlier in this
    chapter, modified to roll back transactions if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the DAO session bean, we deleted the `saveCustomer()` method
    and made the `saveNewCustomer()` and `updateCustomer()` methods public. Each of
    these methods now checks to see whether or not the `customerId` field is set correctly
    for the operation we are trying to perform (`null` for inserts and not `null`
    for updates). It also checks to make sure the object to be persisted is not `null`.
    If any of the checks result in invalid data, the method simply rolls back the
    transaction by invoking the `setRollBackOnly()` method on the injected instance
    of `EJBContext` and does not update the database.
  prefs: []
  type: TYPE_NORMAL
- en: Bean-managed transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen, container-managed transactions make it ridiculously easy to
    write code that is wrapped in a transaction. After all, there is nothing special
    that we need to do to make them that way; as a matter of fact, some developers
    are sometimes not even aware that they are writing code that will be transactional
    in nature when they develop session beans. Container-managed transactions cover
    most of the typical cases that we will encounter. However, they do have a limitation:
    each method can be wrapped in at most a single transaction. With container-managed
    transactions, it is not possible to implement a method that generates more than
    one transaction, this can be accomplished using bean-managed transactions, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we implemented a method named `saveMultipleNewCustomers()`.
    This method takes a `List` of customers as its sole parameter. The intention of
    this method is to save as many elements in `ArrayList` as possible. An exception
    saving one of the entities should not stop the method from attempting to save
    the remaining elements. This behavior is not possible using container-managed
    transactions, since if an exception is thrown when saving one of the entities
    it would roll back the whole transaction. The only way to achieve this behavior
    is through bean-managed transactions.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the previous example, we declare that the session bean uses bean-managed
    transactions by decorating the class with the `@TransactionManagement` annotation,
    and using `TransactionManagementType.BEAN` as the value for its `value` attribute
    (the only other valid value for this attribute is `TransactionManagementType.CONTAINER`,
    but since this is the default value, it is not necessary to specify it).
  prefs: []
  type: TYPE_NORMAL
- en: To be able to programmatically control transactions, we inject an instance of
    `javax.transaction.UserTransaction`, which is then used in the `for` loop within
    the `saveMultipleNewCustomers()` method to begin and commit transactions in each
    iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to roll back a bean-managed transaction, we can do so by simply calling
    the `rollback()` method on the appropriate instance of `javax.transaction.UserTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, it is worth noting that even though all the examples in this
    section were implemented as session beans, the concepts apply to message-driven
    beans as well.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise JavaBean life cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise JavaBeans go through different states in their life cycle. Each type
    of EJB has different states. States specific to each type of EJB are discussed
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: The stateful session bean life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Readers with experience in previous versions of J2EE may remember that in previous
    versions of the specification, session beans were required to implement the `javax.ejb.SessionBean`
    interface. This interface provided methods to be executed at certain points in
    the session bean''s life cycle. Methods provided by the `SessionBean` interface
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ejbActivate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ejbPassivate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ejbRemove()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setSessionContext(SessionContext ctx)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three methods were meant to be executed at certain points in the bean's
    life cycle. In most cases, there was nothing to do in the implementation of these
    methods. This fact resulted in the vast majority of session beans implementing
    empty versions of these methods. Thankfully, starting with Java EE 5, it is no
    longer necessary to implement the `SessionBean` interface, however, if necessary,
    we can still write methods that will get executed at certain points in the bean's
    life cycle. We can achieve this by decorating methods with specific annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Before explaining the annotations available to implement life cycle methods,
    a brief explanation of the session bean life cycle is in order. The life cycle
    of a stateful session bean is different from that of a stateless session bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stateful session bean''s life cycle contains three states: **Does Not Exist**,
    **Ready**, and **Passive**, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The stateful session bean life cycle](img/6886_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before a stateful session bean is deployed, it is in the Does Not Exist state.
    Upon successful deployment, the EJB container does any required dependency injections
    for the bean and the bean goes into the Ready state. At this point, the bean is
    ready to have its methods called by a client application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a stateful session bean is in Ready state, the EJB container may decide
    to passivate it, that is, to move it from main memory to secondary storage. When
    this happens, the bean goes into **Passive** state. If an instance of a stateful
    session bean hasn''t been accessed for a period of time, the EJB container will
    set the bean to the Does Not Exist state. By default, GlassFish will send a stateful
    session bean to the Does Not Exist state after 90 minutes of inactivity. This
    default can be changed by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the GlassFish administration console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Configuration** node in the tree to the left-hand side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **server-config** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **EJB Container** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down towards the bottom of the page and modify the value of the **Removal
    Timeout** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Save** button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![The stateful session bean life cycle](img/6886_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This technique sets the timeout value for all stateful session beans. If we
    need to modify the timeout value for a specific session bean, we need to include
    a `glassfish-ejb-jar.xml` deployment descriptor in the JAR file containing the
    session bean. In this deployment descriptor, we can set the timeout value as the
    value of the `<removal-timeout-in-seconds>` element, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Even though we are not required to create an `ejb-jar.xml` file for our session
    beans anymore (which used to be the case in previous versions of the J2EE specification),
    we can still write one if we wish to. The `<ejb-name>` element in the `glassfish-ejb-jar.xml`
    deployment descriptor must match the value of the element of the same name in
    `ejb-jar.xml`. If we choose not to create an `ejb-jar.xml` file, this value must
    match the name of the EJB class. The timeout value for the stateful session bean
    must be the value of the `<removal-timeout-in-seconds>` element; as the name of
    the element suggests, the unit of time to use is seconds. In the previous example,
    we set the timeout value to 600 seconds, or 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Any methods in a stateful session bean decorated with the `@PostActivate` annotation
    will be invoked just after the stateful session bean has been activated. This
    is equivalent to implementing the `ejbActivate()` method in previous versions
    of J2EE. Similarly, any method decorated with the `@PrePassivate` annotation will
    be invoked just before the stateful session bean is passivated; this is equivalent
    to implementing the `ejbPassivate()` method in previous versions of J2EE.
  prefs: []
  type: TYPE_NORMAL
- en: When a stateful session bean in the Ready state times out and is sent to the
    Does not Exist state, any method decorated with the `@PreDestroy` annotation is
    executed. If the session bean times out in the Passive state, methods decorated
    with the `@PreDestroy` annotation are not executed. Additionally, if a client
    of the stateful session bean executes a method decorated with the `@Remove` annotation,
    all methods decorated with the `@PreDestroy` annotation are executed and the bean
    is marked for garbage collection. Decorating a method with the `@Remove` annotation
    is equivalent to implementing the `ejbRemove()` method in previous versions of
    the J2EE specification.
  prefs: []
  type: TYPE_NORMAL
- en: The `@PostActivate`, `@PrePassivate`, and `@Remove` annotations are valid only
    for stateful session beans, whereas the `@PreDestroy` and `@PostConstruct` annotations
    are valid for stateful session beans, stateless session beans, and message-driven
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: The stateless session bean life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A stateless session bean life cycle contains only the **Does Not Exist** and
    **Ready** states, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The stateless session bean life cycle](img/6886_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Stateless session beans are never passivated. A stateless session bean's methods
    can be decorated with the `@PostConstruct` and `@PreDestroy` annotations. Just
    like with stateful session beans, any methods decorated with the `@PostConstruct`
    annotation will be executed when the stateless session bean goes from the Does
    Not Exist to the Ready State, and any methods decorated with the `@PreDestroy`
    annotation will be executed when a stateless session bean goes from the Ready
    state to the Does Not Exist state. Stateless session beans are never passivated,
    any `@PrePassivate` and `@PostActivate` annotations in a stateless session bean
    are simply ignored by the EJB container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with stateful session beans, we can control how GlassFish manages
    the life cycle of stateless session beans (and message-driven beans) via the administration
    web console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The stateless session bean life cycle](img/6886_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Initial and Minimum Pool Size** refers to the minimum number of beans in
    the pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum Pool Size** refers to the maximum number of beans in the pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pool Resize Quantity** refers to how many beans will be removed from the
    pool when the **Pool Idle Timeout** value expires'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pool Idle Timeout** refers to the number of seconds of inactivity to let
    pass before removing beans from the pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previous settings affect all `poolable` EJBs, such as stateless session
    beans and message-driven beans. Just as with stateful session beans, these settings
    can be overridden on a case-by-case basis by adding a GlassFish specific `glassfish-ejb-jar.xml`
    deployment descriptor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `<steady-pool-size>` line corresponds to **Initial and Minimum Pool Size**
    in the GlassFish web console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<max-pool-size>` line corresponds to **Maximum Pool Size** in the GlassFish
    web console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<resize-quantity>` line corresponds to **Pool Resize Quantity** in the
    GlassFish web console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<pool-idle-timeout-in-seconds>` line corresponds to **Pool Idle Timeout**
    in the GlassFish web console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message-driven bean life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like stateless session beans, message-driven beans exist only in the Does
    Not Exist and Ready states, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message-driven bean life cycle](img/6886_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The above image is exactly the same as the previous one. Message-driven beans
    have the same life cycle as stateless session beans. Therefore, the image to illustrate
    the life cycle was re-used.
  prefs: []
  type: TYPE_NORMAL
- en: A message-driven bean can have methods decorated with the `@PostConstruct` and
    `@PreDestroy` methods. Methods decorated with the `@PostConstruct` method are
    executed just before the bean goes into the Ready state. Methods decorated with
    the `@PreDestroy` annotation are executed just before the bean goes to the Does
    Not Exist state.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the EJB Timer Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stateless session beans and message-driven beans can have a method that is
    executed periodically at regular intervals of time. This can be accomplished using
    the **EJB Timer Service**. The following example illustrates how to take advantage
    of this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we injected an implementation of the `javax.ejb.TimerService`
    interface by decorating an instance variable of this type with the `@Resource`
    annotation. We then created a timer by invoking the `createTimer()` method of
    the `TimerService` instance.
  prefs: []
  type: TYPE_NORMAL
- en: There are several overloaded versions of the `createTimer()` method. The one
    we chose to use takes an instance of `java.util.Date` as its first parameter;
    this parameter is used to indicate the first time the timer should expire (go
    off). In the example, we chose to use a brand new instance of the `Date` class,
    which, in effect, makes the timer expire immediately. The second parameter of
    the `createTimer()` method is the amount of time to wait, in milliseconds, before
    the timer expires again. In our example, the timer is set to expire every five
    seconds. The third parameter of the `createTimer()` method can be an instance
    of any class implementing the `java.io.Serializable` interface. Since a single
    EJB can have several timers executing concurrently, this third parameter is used
    to uniquely identify each of the timers. If we don't need to identify the timers,
    `null` can be passed as a value for this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The EJB method invoking `TimerService.createTimer()` must be called from an
    EJB client. Placing this call in an EJB method decorated with the `@PostConstruct`
    annotation to start the timer automatically when the bean is placed in the Ready
    state will result in an `IllegalStateException` exception to be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: We can stop a timer by invoking its `cancel()` method. There is no way to directly
    obtain a single timer associated with an EJB. What we need to do is invoke the
    `getTimers()` method on the instance of `TimerService` that is linked to the EJB;
    this method will return a Collection containing all the timers associated with
    the EJB. We can then iterate through the collection and cancel the correct one
    by invoking its `getInfo()` method. This method will return the `Serializable`
    object we passed as a parameter to the `createTimer()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, any EJB method decorated with the `@Timeout` annotation will be executed
    when a timer expires. Methods decorated with this annotation must return void
    and take a single parameter of type `javax.ejb.Timer`. In our example, the method
    simply writes a message to the server log.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class is a standalone client for the previous EJB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example simply starts a timer, waits for a couple of seconds,
    and then starts a second timer. It then sleeps for 30 seconds and then stops both
    timers. After deploying the EJB and executing the client, we should see some entries
    like the following in the server log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These entries are created each time one of the timers expires.
  prefs: []
  type: TYPE_NORMAL
- en: Calendar-based EJB timer expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example in the previous section has one disadvantage: the `startTimer()`
    method in the session bean must be invoked from a client in order to start the
    timer. This restriction makes it difficult to have the timer start as soon as
    the bean is deployed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java EE 6 introduced calendar-based EJB timer expressions. Calendar-based expressions
    allow one or more methods in our session beans to be executed at a certain date
    and time. For example, we could configure one of our methods to be executed every
    night at 8:10 p.m., which is exactly what the following example does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this example, we set up the time when the method will be executed
    via the `javax.ejb.Schedule` annotation. In this particular example, we set up
    our method to be executed at 8:10 p.m. by setting the `hour` attribute of the
    `@Schedule` annotation to `"20"`, and its minute attribute to `"10"`. The value
    of the `hour` attribute is 24 hour based; hour 20 is equivalent to 8:00 p.m.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Schedule` annotation has several other attributes that allows a lot of
    flexibility in specifying when the method should be executed; we could, for instance,
    have a method being executed on the third Friday of every month, or the last day
    of the month, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists all the attributes in the `@Schedule` annotation
    that allow us to control when the annotated method will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description | Example values | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dayOfMonth` | The day of the month. | `"3"`: the third day of the month`"Last"`:
    the last day of the month`"-2"`: two days before the end of the month`"1st Tue"`:
    the first Tuesday of the month | `"*"` |'
  prefs: []
  type: TYPE_TB
- en: '| `dayOfWeek` | The day of the week | `"3"`: every Wednesday`"Thu"`: every
    Thursday | `"*"` |'
  prefs: []
  type: TYPE_TB
- en: '| `hour` | The hour of the day (24 hour based) | `"14"`: 2:00 p.m. | `"0"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `minute` | The minute of the hour | `"10"`: ten minutes after the hour |
    `"0"` |'
  prefs: []
  type: TYPE_TB
- en: '| `month` | The month of the year | `"2"`: February`"March"`: March | `"*"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `second` | The second of the minute | `"5"`: five seconds after the minute
    | `"0"` |'
  prefs: []
  type: TYPE_TB
- en: '| `timezone` | The timezone ID | `"America/New York"` | `""` |'
  prefs: []
  type: TYPE_TB
- en: '| `year` | The four-digit year | `"2010"` | `"*"` |'
  prefs: []
  type: TYPE_TB
- en: In addition to single values, most attributes accept the asterisk (`"*"`) as
    a wildcard, meaning that the annotated method will be executed regularly (every
    day, hour, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can specify more than one value by separating the values with
    commas, for example, if we need a method to be executed every Tuesday and Thursday,
    we could annotate the method as `@Schedule(dayOfWeek="Tue, Thu")`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify a range of values; the first and last values are separated
    by a hyphen (*-*). To execute a method from Monday through Friday, we could use
    `@Schedule(dayOfWeek="Mon-Fri")`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we could specify that we need the method to be executed every
    n units of time (for example, every day, every 2 hours, every 10 minutes, and
    so on). To do something like this, we could use `@Schedule(hour="*/12")`, which
    would execute the method every 12 hours.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `@Schedule` annotation provides a lot of flexibility in terms
    of how to specify when we need our methods executed. In addition, it provides
    us the advantage of not needing a client call to activate the scheduling. It also
    has the advantage of using cron-like syntax; therefore, developers familiar with
    this Unix tool will feel right at home using this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: EJB Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise JavaBeans allow us to declaratively decide which users can access
    their methods. For example, some methods might only be available to users in certain
    roles. A typical scenario is that only users with the role of administrator can
    add, delete, or modify other users in the system.
  prefs: []
  type: TYPE_NORMAL
- en: The following example is a slightly modified version of the DAO session bean
    we saw earlier in this chapter. In this version, some methods that were previously
    private are made public. Additionally, the session bean was modified to allow
    only users in certain roles to access its methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we declare what roles have access to the methods using the `@RolesAllowed`
    annotation. This annotation can take either a single string or an array of strings
    as its parameter. When a single string is used as a parameter for this annotation,
    only users with the role specified by the parameter can access the method. If
    an array of Strings is used as the parameter, users with any of the roles specified
    by the array's elements can access the method.
  prefs: []
  type: TYPE_NORMAL
- en: The `@RolesAllowed` annotation can be used to decorate an EJB class, in which
    case, its values apply to either all the methods in the EJB, or to one or more
    methods. In the second case, its values apply only to the method the annotation
    is decorating. If, like in our previous example, both the EJB class and one or
    more of its methods are decorated with the `@RolesAllowed` annotation, the method
    level annotation takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application roles need to be mapped to a security realm''s group name (refer
    to [Chapter 9](ch09.html "Chapter 9. Securing Java EE Applications"), *Securing
    Java EE Applications*, for details). This mapping, along with what realm to use,
    is set in the `glassfish-ejb-jar.xml` deployment descriptor, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `<security-role-mapping>` element of `glassfish-ejb-jar.xml` performs the
    mapping between application roles and the security realm's group. The value of
    the `<role-name>` subelement must contain the application role; this value must
    match the value used in the `@RolesAllowed` annotation. The value of the `<group-name>`
    subelement must contain the name of the security group in the security realm used
    by the EJB. In our example, we map two application roles to their corresponding
    groups in the security realm. Although in this particular example the name of
    the application role and the security group match, this does not need to be the
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Automatically matching roles to security groups**'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to automatically match any application roles to identically named
    security groups in the security realm. This can be accomplished by logging in
    to the GlassFish web console, clicking on the **Configuration** node, clicking
    on **Security**, then clicking on the checkbox labeled **Default Principal To
    Role Mapping**, and saving this configuration change.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in our example, the security realm to use for authentication is defined
    in the `<realm>` subelement of the `<as-context>` element. The value of this subelement
    must match the name of a valid security realm in the application server. Other
    sub elements of the `<as-context>` element include `<auth-method>`, the only valid
    value for this element is `username_password`, and `<required>`, the only valid
    values of which are `true` and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Client authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the client code accessing a secured EJB is part of a web application the
    user of which has already been authenticated (the user logged in through the web
    interface), then the user's credentials will be used to determine whether or not
    the user should be allowed to access the method they are trying to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standalone clients must be executed through the `appclient` utility. The following
    code illustrates a typical client for the previous, secured session bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, there is nothing the code is doing in order to authenticate
    the user. The session bean is simply injected into the code via the `@EJB` annotation
    and used as usual. The reason this works is because the `appclient` utility takes
    care of authenticating the user after invoking the client code via the `appclient`
    utility as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `appclient` utility will present the user with a log in window when it
    attempts to invoke a secure method on EJB, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client authentication](img/6886_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Assuming that the credentials are correct and the user has the appropriate
    permissions, the EJB code will execute, and we should see the expected output
    from the `Client` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to implement business logic via stateless and
    stateful session beans. Additionally, we covered how to implement message-driven
    beans to consume JMS messages.
  prefs: []
  type: TYPE_NORMAL
- en: We also explained how to take advantage of the transactional nature of EJBs
    to simplify implementing the Data Access Object (DAO) pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we explained the concept of container-managed transactions and
    how to control them using the appropriate annotations. We also explained how to
    implement Bean Managed Transactions for cases in which container-managed transactions
    are not enough to satisfy our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycles for the different types of Enterprise JavaBeans were covered, including
    an explanation on how to have EJB methods automatically invoked by the EJB container
    at certain points in the life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered how to have EJB methods invoked periodically by the EJB container
    by taking advantage of the EJB timer service.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explained how to make sure EJB methods are only invoked by authorized
    users by annotating the EJB classes and/or methods and by adding the appropriate
    entries to the `glassfish-ejb-jar.xml` deployment descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover Contexts and Dependency Injection.
  prefs: []
  type: TYPE_NORMAL
