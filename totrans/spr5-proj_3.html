<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Blogpress - A Simple Blog Management System</h1>
                </header>
            
            <article>
                
<p>Spring supports the development of enterprise-grade applications on the Java platform. There are numerous such application that come under its purview, popular among which are Spring <strong>Model-View-Controller</strong> (<strong>MVC</strong>), Spring Security, Spring Data, Spring Batch, and Spring Cloud.</p>
<p>In the previous two chapters, we started exploring Spring MVC framework along with other building blocks, like Spring Data and RestTemplate, along with JavaScript frameworks like Angular, Bootstrap, and jQuery to build the web-based application. We have also seen how to build a reactive web application with the help of WebFlux, a framework for creating reactive web applications.</p>
<p><span>Creating an enterprise-ready </span>S<span>pring-</span><span>based application requires heavy configuration, which makes the process of development quite tedious and cumbersome. On top of this, setting up the complex dependencies also needs lots of effort. </span><span>Quite often, the libraries used in Spring-based web applications require common configuration to bind them together.</span></p>
<p><span>Considering any standard Spring-based application, you might need to perform certain repetitive tasks, specifically for configuration, for example, importing required modules and libraries to resolve dependencies; doing configuration related to various layers of application, such as data source and transaction management at the DAO layer, and view resolver and resource management at the web layer, and so on.</span></p>
<p><span>This is a mandated procedure that has to be followed while creating any Spring-based web application. </span>In short, developers often resort to duplicating the configuration across application and may not following the best practices while integrating libraries.</p>
<p>All these factors inspired the Spring team to come up with a framework that provides integration for all the Spring libraries through auto-configuration, <span>which basically eliminates the repetitive jobs for you. I</span>n addition to this, it provides production-ready features, such as application metrics and monitoring, and logging and deployment guidelines. This framework is known as Spring Boot.</p>
<p>In this chapter, we will continue <span>our journey and </span>look at building different components required for a blog management web application using Spring libraries and other third-party libraries all bound together with auto-configuration provided by Spring Boot and some overrides done by us to the auto-configuration.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li style="font-weight: 400">Project skeleton with Spring Boot</li>
<li style="font-weight: 400">The main flow of the application in the Spring MVC framework</li>
<li style="font-weight: 400">Presentation layer with <strong>Thymeleaf</strong> and <kbd>Mustache.js</kbd></li>
<li style="font-weight: 400">Making the application secure with Spring Security—covering authentication and authorization</li>
<li style="font-weight: 400">Developing the backend layer in Elasticsearch, which holds the application data and provides REST-based CRUD operations</li>
<li style="font-weight: 400">Developing Spring MVC REST service</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>All the code used in this chapter can be downloaded from the following GitHub link: <a href="https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter03/blogpress">https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter03/blogpress</a>. The code can be executed on any operating system, although it has only been tested on Windows.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application overview</h1>
                </header>
            
            <article>
                
<p>Taking a real-life example is the best approach to explore and understand the concepts of a given framework context. The idea is not to show how to build the web application; instead, we will show the important components which are part of the application so that anyone can just pick one component and use it in another application. You can always find the complete working solution in the code downloaded for the book.</p>
<p>Let's jump into action. First, we will go through the brief about our application—blog. We will call it <strong>Blogpress</strong>. Please note that it will not be a full-fledged blogging application; instead, we will develop it with the following functionalities:</p>
<ul>
<li style="font-weight: 400">Landing page—shows a list of blogs with the links to each blog.</li>
<li style="font-weight: 400">When a user clicks on any of the blogs, the system opens it in view mode along with all (approved) comments.</li>
<li style="font-weight: 400">A user can add comments to the same screen.</li>
<li style="font-weight: 400">Apart from this, a user can search for the blog with given search text, targeting the title or body of the blog.</li>
<li style="font-weight: 400">There is a login feature. Two people can log into the application—a blog user and an admin:
<ul>
<li style="font-weight: 400">Blog user can add/update/delete the blog. He can only edit the blogs he created.</li>
<li style="font-weight: 400">Admin user can perform all possible operations a blog user can do plus manage (approve or reject) the comments given by the anonymous user.</li>
</ul>
</li>
<li style="font-weight: 400">When any user adds a comment, an email will be sent to the admin user to moderate it. Once the comment is approved, an email will be sent back to the user as a notification.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project skeleton with Spring Boot</h1>
                </header>
            
            <article>
                
<p>Spring Boot automates the process of creating the configuration which speeds up the development process. In short, Spring Boot makes the development life cycle shorter, with minimal or no configuration for building production-ready applications or services. It uses the convention-over-configuration methodology to provide rapid application development.</p>
<p>Spring Boot is not meant to provide any new features; instead, as it is established on top of the Spring Framework, it uses existing Spring Framework features to provide a preconfigured application skeleton out of the box, which is a getting-started mode of development.</p>
<p>Spring Boot has various advantages over conventional ways of creating a Spring-based application, as follows:</p>
<ul>
<li style="font-weight: 400">Has automated configuration</li>
<li style="font-weight: 400">Manages dependency with ease</li>
<li style="font-weight: 400">Supports an embedded server to make the development process easy and straightforward</li>
<li style="font-weight: 400">Provides support for building the application with Maven or Gradle out of the box</li>
<li style="font-weight: 400">Eases integration with other Spring modules</li>
<li style="font-weight: 400">Speeds up the development process</li>
<li style="font-weight: 400">Supports command lines and IDEs to develop and test the application with ease</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring IDE Spring Tool Suite</h1>
                </header>
            
            <article>
                
<p>Let's start developing our blog application—Blogpress. As described, we will start creating the application with Spring Boot first. Developing an application with an IDE is the most straightforward, easy, convenient, and favorable approach preferred by the majority of developers today. We use IDEs to develop our application.</p>
<p>Spring provides an Eclipse-based IDE called <strong>Spring Tool Suite</strong> (<strong>STS</strong>) to develop any Spring-based application with ease. Download the latest version of STS from the link <a href="https://spring.io/tools">https://spring.io/tools.</a></p>
<div class="packt_infobox">The STS is available with Eclipse, along with Visual Studio and Atom-based code editors. You can use either of them for your convenience.</div>
<p>We will use the STS (an Eclipse-based IDE) to build the application in this chapter. Download STS, unzip it in your local folder, and open the <kbd>.exe</kbd> file to start the STS. Once started, create a new <span class="packt_screen">Spring Starter Project</span> of the <span class="packt_screen">Spring Boot</span> <span>type </span>with the following attributes:</p>
<ul>
<li><span class="packt_screen">Name</span>: <kbd>blogpress</kbd></li>
<li><span class="packt_screen">Type</span>: <span class="packt_screen">Maven</span> (you can also select <span class="packt_screen">Gradle</span>)</li>
<li><span class="packt_screen">Packaging</span>: <span class="packt_screen">Jar</span></li>
<li><span class="packt_screen">Java Version</span>: <span class="packt_screen">8</span> (or above)</li>
<li><span class="packt_screen">Language</span>: <span class="packt_screen">Java</span></li>
<li><span class="packt_screen">Group</span>: This would be a Maven <kbd>groupId</kbd>, so give the appropriate value</li>
<li><span class="packt_screen">Artifact</span>: This would be a Maven <kbd>artifactId</kbd>, so give the appropriate value</li>
<li><span class="packt_screen">Version</span>: <kbd>0.0.1-SNAPSHOT</kbd>—the build version of our application build</li>
<li><span class="packt_screen">Description</span>: <kbd>A simple blog management system</kbd></li>
</ul>
<div class="packt_infobox">You can create a Spring Boot application from a command window as well. Spring provides a tool called Spring <strong>command-line interface</strong> (<strong><span>CLI</span></strong>) for this. Another way of creating a Spring Boot starter project is with <a href="https://start.spring.io/">https://start.spring.io/</a>. You need to define the dependencies and it will allow users to download the entire project structure from the web.</div>
<p>Keeping all default options, click <span class="packt_screen">Finish</span> to create the Spring Boot application. You will see the following dependencies in <kbd>pom.xml</kbd>:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</pre>
<p>Spring Boot provides various starters, specific for each dependency so that their JARs are available in the classpath. Since we want to develop a web application (Spring MVC), we keep the starter <kbd>spring-boot-starter-web</kbd> in the previous code (in fact, it is added while creating a project in the STS).</p>
<p>Spring provides a set of dependencies for a specific functionality in the form of a starter. It is a convenient way of managing dependencies in a Spring Boot application. When you specify a particular starter, Spring Boot will pull all (recursive) dependencies in your application for you. For example, if you wish to add a data store to your application with JPA, simply add <kbd>spring-boot-starter-jpa</kbd> to <kbd>pom.xml</kbd> in your Spring Boot application. All dependency will be carried out by Spring Boot so that you can focus on business implementations.</p>
<p>You will see <kbd>spring-boot-starter-parent</kbd> in the parent element of <kbd>pom.xml</kbd>. This is the magic of Spring Boot. Your application extends all Spring Boot capabilities by this declaration, as following snippet shows:</p>
<pre>&lt;parent&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br/>  &lt;version&gt;2.1.0.BUILD-SNAPSHOT&lt;/version&gt;<br/>  &lt;relativePath/&gt;<br/>&lt;/parent&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Model-View-Controller web flow</h1>
                </header>
            
            <article>
                
<p>The next step is to add Spring MVC capabilities. In the previous step, the required starter dependencies for the web are added to the <kbd>pom.xml</kbd> file. Next, we will define Spring MVC artifacts in our application.</p>
<p>Since this is a Spring Boot application, we are not required to declare everything from scratch. It is essential to define the controllers and view layer. First, we will declare a Spring MVC controller, as in the following snippet:</p>
<pre>@Controller<br/>public class BlogController {<br/>  private Logger logger = LoggerFactory.getLogger(BlogController.class);<br/>  @GetMapping("/")<br/>  public String showLandingPage(Model model) {<br/>    logger.info("This is show home page method ");<br/>    return "home";<br/>  }<br/>}</pre>
<p>The <kbd>@Controller</kbd> annotation describes this class as a Spring MVC controller. It basically instructs the Spring Boot application that this component will serve a web-based request. It matches the correct URL pattern to call a specific controller and its method.</p>
<p class="mce-root"><span>In the previous declaration, we only gave the URL pattern to the controller method. However, Spring allows you to declare URL patterns for the controller as well. Since our application requires only certain functionalities, one controller is sufficient, and hence, we haven’t declared the URL pattern for the controller. So, all web requests</span> <span>(with the</span> <kbd>http://host/context/controllerUrlPattern</kbd> <span>pattern) for the current application will be routed to this controller.</span></p>
<div class="mce-root packt_infobox"><span>The <kbd>@RequestMapping("/controllerUrlPattern")</kbd> annotation is used to describe URL patterns at the controller level. In this scenario, the</span> <kbd>http://host/context/controllerUrlPattern</kbd> pattern <span>will reach this controller. The URL pattern of all of its methods will be appended after <kbd>http://host/context/controllerUrlPattern</kbd>.</span></div>
<div class="packt_tip">It is always good practice to use a logger. Spring provides the <kbd>LoggerFactory</kbd> class to get a logger instance for the current class. You can call various methods like <kbd>info</kbd>, <kbd>debug</kbd>, <kbd>error</kbd>, and so on at appropriate places.</div>
<p>The Spring MVC controller method can be mapped with a distinct URL so that it can be triggered by a matching request URL pattern. The <kbd>showLandingPage()</kbd> method is a controller method in the previous case. It is mapped with the URL <kbd>/</kbd> and this means the <kbd>http://localhost:8080/blogpress/</kbd> URL (considering you run the application in your local with the <kbd>8080</kbd> port and <kbd>blogpress</kbd> is the name of your application) will call this method.</p>
<p>This method returns a string, <kbd>home</kbd>, which represents the component from the presentation layer. Spring MVC is flexible enough to choose the desired presentation framework. So, it is absolutely unnecessary to use specific technology as your presentation layer. You can use <span><strong>JavaServer Pages</strong> (</span><strong>JSP</strong>s), Thymeleaf, or a UI framework such as Angular as your frontend for a Spring MVC web application.</p>
<p>In this chapter, we will use Thymeleaf to build the presentation layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Presentation layer with Thymeleaf</h1>
                </header>
            
            <article>
                
<p>Thymeleaf is a template engine used to process various templates in XML, HTML, JavaScript, CSS, and plain TEXT on the server side. You might have a question: why Thymeleaf? We already have JSP. What are the benefits of using Thymeleaf over JSP?</p>
<p>The answer is, Thymeleaf is designed with a natural templating concept and provides a design prototype support without affecting the use of the template. In other words, due to its nature, Thymeleaf can be used by both developers and design teams without being locked-in or having a dependency between either of them.</p>
<p>Another good thing about Thymeleaf is that it is designed in accordance with web standards, mainly HTML5. This will make it easy for you to fully validate the templates if that is required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How Thymeleaf works</h1>
                </header>
            
            <article>
                
<p>For our blogging application, we will use the Thymeleaf HTML template. The very first step for working with Thymeleaf is to instruct Spring Boot so that it can make all the necessary configurations specific to Thymeleaf readily available for our application. Add the following entry in <kbd>pom.xml</kbd>:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-Thymeleaf &lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Thymeleaf provides certain tags (a kind of JSP tags) to embed dynamic values into the template. We will first go through the bare minimum tags that we intend to use in our Blogpress application. The mechanism of inserting a dynamic value into the Thymeleaf template is different than what you might have seen in JSP tags, so it is quite vital to be familiar with it before starting to use it.</p>
<div class="packt_tip"><span>You can see another starter for Thymeleaf. This is how Spring Boot makes the developer's life easy.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dialects, processors, and expression objects</h1>
                </header>
            
            <article>
                
<p>Dialects are a set (or group) of features that you use in your template, including pre- and post-processing logic and expression objects. Processing logic (of embedding the dynamic HTML and value in the template) is carried out by objects called a processor, while expression objects are used to describe standard expression for performing a specific operation. In short, processor objects deal with the DOM node or element, while expression objects are used to evaluate the expression.</p>
<p>Dialects can be used along with processors, or expression objects, or both. Let's see how a dialect can be declared and used in the template:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html &gt;<br/><br/>&lt;span th:text="${name}"&gt;</pre>
<p>In previous snippet, <kbd>th</kbd> is called the dialect prefix. It means that all attributes and tags provided by this dialect start with <kbd>th:</kbd>. This is a standard and out-of-the-box dialect, and it is just sufficient for most of our scenario. You can consider dialect similar to <em>Taglibs</em> in JSP.</p>
<div class="packt_infobox">You can define more than one dialect in your template. Additionally, you can create your own custom dialect with custom processing logic in custom processors.</div>
<p>The <kbd>text</kbd> attribute represents a processor that simply puts the value for the span while <kbd>${...}</kbd> describes the value expression object, which simply pulls the attribute value stored in the model. The following are the types of expression objects available in Thymeleaf:</p>
<ul>
<li style="font-weight: 400"><strong>Variable expression objects:</strong> They are used to show the value of the model attribute. They are in the form of Spring <strong>e<span>xpression language</span></strong> (<strong><span>EL</span></strong>). They can be described with the <kbd>${...}</kbd> syntax.</li>
<li style="font-weight: 400"><strong>Selection expression object:</strong> These are similar to expression objects but can only be applied to the previously selected object. They can be used with the <kbd>*{...}</kbd> syntax.</li>
<li style="font-weight: 400"><strong>Message (i18n) expressions:</strong> These are used for internationalization purposes and bringing language-specific messages. You can use the <kbd>#{...}</kbd> syntax.</li>
<li style="font-weight: 400"><strong>Link (URL) expressions:</strong> These are used to employ links dynamically. For example, form action, HREF, linking JS/CSS, or other static resources, and so on. Use the <kbd>@{...}</kbd> syntax for them.</li>
<li style="font-weight: 400"><strong>Fragment expressions:</strong> This represents a fragment of the template and can be reused in similar or other templates. They can be utilized with the <kbd>~{...}</kbd> syntax.</li>
</ul>
<p>Next, we will see some of the processors that we are going to use in our following application. They can be used along with various expression objects listed as follows:</p>
<ul>
<li style="font-weight: 400"><kbd>th:text</kbd>—This is used along with value expression objects to place dynamic text for HTML elements like <kbd>span</kbd>, <kbd>li</kbd>, <kbd>div</kbd>, and so on</li>
<li style="font-weight: 400"><kbd>th:value</kbd>—The value of the input element can be supplied with this processor</li>
<li style="font-weight: 400"><kbd>th:action</kbd>—This can be used to supply the action value to HTML form</li>
<li style="font-weight: 400"><kbd>th:href</kbd>—As its name suggests, this is used to provide an URL in the link (to import CSS) and tags in HTML</li>
<li style="font-weight: 400"><kbd>th:src</kbd>—This is used to provide source URL for script (and other such) elements in HTML dynamically</li>
<li style="font-weight: 400"><kbd>th:each</kbd>—This is used with <kbd>th:text</kbd> in the loop to construct repetitive HTML code, that is, rows of HTML tables</li>
<li style="font-weight: 400"><kbd><strong>th:if</strong></kbd> and <kbd>th:unless</kbd>—These are used to place dynamic values conditionally</li>
</ul>
<p>Thymeleaf supports defining attributes and element names in HTML5 style. For example, instead of writing <kbd>th:text</kbd>, you can write <kbd>data-th-text</kbd> as an attribute in an HTML element, and it is considered a custom element in HTML5.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why Thymeleaf is a natural template</h1>
                </header>
            
            <article>
                
<p>We have seen the processors of standard dialect are placed as an attribute of HTML element. Because of this arrangement, the browser can render the Thymeleaf template as a correct HTML file, even before they are processed by the template engine.</p>
<p>This is quite possibly because the browser simply ignores them, considering them custom attributes, so there is no issue in displaying them. The same cannot be possible in the case of JSP. For example, the JSP with the following tag is not rendered in the browser:</p>
<pre>&lt;form:input name="name" path=”name”/&gt;</pre>
<p>And if you write it with Thymeleaf, it will be as follows:</p>
<pre>&lt;input type="text" name="name" value="Nilang" th:value="${name}" /&gt;</pre>
<p>The browser will display the preceding code perfectly. Additionally, Thymeleaf allows you to supply the (optional) value attribute (<kbd>Nilang</kbd> in our case), which will be displayed statically when run on the browser. When the same code is processed by the Thymeleaf template engine, the value will be substituted by evaluation of the <kbd>${name}</kbd> <span>expression</span> on the fly.</p>
<p>This is the reason why Thymeleaf is called a natural template engine. It allows the designer to work with the developer without producing dependency on either side.</p>
<p>Now, let's discuss which Thymeleaf templates we are going to use in our blog application. When you create a Spring Boot application, you will see a <kbd>templates</kbd> file in the <kbd>src/main/resources</kbd> folder. All our Thymeleaf templates reside there.</p>
<p>We are going to use following templates in our application:</p>
<ul>
<li style="font-weight: 400"><kbd>header.html</kbd>: This template contains a common JS/CSS inclusion header, along with a navigation bar. It is included in all other templates.</li>
<li style="font-weight: 400"><kbd>home.html</kbd>: Shows home page content.</li>
<li style="font-weight: 400"><kbd>login.html</kbd>: Allows the user to login into the system.</li>
<li style="font-weight: 400"><kbd>user-page.html</kbd>: Once a blog user logs in, he will land on this page.</li>
<li style="font-weight: 400"><kbd>view-blog.html</kbd>: Opens a particular blog in read-only mode.</li>
<li style="font-weight: 400"><kbd>search.html</kbd>: Shows the search result.</li>
<li style="font-weight: 400"><kbd>new-blog.html</kbd>: A blog user or admin can create a new blog through this template.</li>
<li style="font-weight: 400"><kbd>manage-comments.html</kbd>: An admin user can approve/reject comments.</li>
<li style="font-weight: 400"><kbd>edit-blog.html</kbd>: Allows a blog user/admin user to edit the existing blog.</li>
<li style="font-weight: 400"><kbd>admin-page.html</kbd>: Once an admin user logs in, they will land on this page.</li>
</ul>
<p>We will first add two templates—<kbd>home</kbd> and <kbd>header</kbd>. Before going further, let’s see one more cool feature of Thymeleaf that we will use in our application. Just like JSP, you can include a template into another template. Additionally, Thymeleaf allows you to include only some portion (fragment) of the template instead of the whole template, which is not possible with JSP.</p>
<p>This is a great feature, as you can define common fragments in one template and include them in others. In our case, we have defined common header items in a <kbd>header.html</kbd> template as in the following snippet:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html &gt;<br/>&lt;head th:fragment="jscssinclude"&gt;<br/>    &lt;!-- Required meta tags --&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes"&gt;<br/>    &lt;!-- Bootstrap CSS --&gt;<br/>    &lt;link rel="stylesheet" th:href="@{/css/bootstrap.min.css}"&gt;<br/>    &lt;link rel="stylesheet" th:href="@{/css/blogpress.css}"&gt;<br/><br/>    &lt;script th:src="@{/js/jquery.min.js}" type="text/javascript"&gt;&lt;/script&gt;<br/>    &lt;script th:src="@{/js/popper.js}" type="text/javascript"&gt;&lt;/script&gt;<br/>    &lt;script th:src="@{/js/bootstrap.min.js}" type="text/javascript"&gt;&lt;/script&gt;<br/><br/>    &lt;title th:text="${pageTitle}"&gt;Title&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;div th:fragment="header_navigation"&gt;<br/>    &lt;div class="jumbotron text-center jumbotron-fluid" <br/>        style="margin-bottom:0; padding:2rem 1 rem" &gt;<br/>         &lt;h1&gt;Blog Press&lt;/h1&gt;<br/>         &lt;p&gt;Let's do Blogging ..!&lt;/p&gt;<br/>     &lt;/div&gt;<br/>     &lt;nav class="navbar navbar-expand-sm bg-dark navbar-dark"&gt;<br/>          &lt;button class="navbar-toggler" type="button" <br/>              data-toggle="collapse" data-target="#collapsibleNavbar"&gt;<br/>              &lt;span class="navbar-toggler-icon"&gt;&lt;/span&gt;<br/>          &lt;/button&gt;<br/>          &lt;div class="collapse navbar-collapse" id="collapsibleNavbar"&gt;<br/>              &lt;ul class="navbar-nav"&gt;<br/>                  &lt;li class="nav-item"&gt;<br/>                      &lt;a class="nav-link" th:href="@{/}"&gt;Home&lt;/a&gt;<br/>                  &lt;/li&gt;<br/>               &lt;/ul&gt;<br/>          &lt;/div&gt;<br/>      &lt;/nav&gt;<br/>    &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p><span>The fragment is defined by the <kbd>th:fragment</kbd> tag. You can see how Thymeleaf tags (with dialect prefix, processors, and expression objects) are used to import various static resources (JS/CSS) along, with adding a dynamic value to HTML elements (<kbd>${pageTitle}</kbd> , in our case).</span></p>
<p>We can include this header (which is defined as the fragment) in other templates. For example, in our <kbd>home.html</kbd> template, we have used it as follows:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html &gt;<br/>  &lt;head th:replace="header :: jscssinclude"&gt;&lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div th:replace="header :: header_navigation"&gt;&lt;/div&gt;<br/>    This is Home page<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>The <kbd>th:replace</kbd> tag is used to refer the fragment code from other templates. You need to just put the name of the template (from where you are referring fragments) with two colons (<kbd>::</kbd>) and the name of the fragment (that you have defined with the <kbd>th:fragment</kbd> tag). This is how Thymeleaf allows you to refer a set of template codes as a fragment to other templates.</p>
<div class="packt_infobox">We have defined another fragment, called <kbd>header_navigation</kbd>, which is referred to in the home template in the previous code snippet. It is used to show a navigation menu for our application.</div>
<p>At this moment, we also need to put static resources (JS/CSS) into our application. You will see a static folder in the project structure where all static resources should be placed. Spring Boot will consider everything in the static folder as a static resource. Create <kbd>css</kbd>, <kbd>img</kbd>, and <kbd>js</kbd> folders under the static folder and place the following resources in them:</p>
<ul>
<li style="font-weight: 400">To the <kbd>css</kbd> folder, add the following:
<ul>
<li style="font-weight: 400"><kbd>bootstrap.min.css</kbd></li>
</ul>
</li>
<li style="font-weight: 400"><span>To the</span><span> </span><kbd>js</kbd> folder<span>, add the following</span>:
<ul>
<li style="font-weight: 400"><kbd>Bootstrap.min.js</kbd></li>
<li style="font-weight: 400"><kbd>Jquery.min.js</kbd></li>
<li style="font-weight: 400"><kbd>popper.js</kbd></li>
</ul>
</li>
</ul>
<p>Now it is time to run our application to see the home page. You can build and deploy it on a server and access it with the <kbd>http://localhost:8080/blogpress</kbd> <span>URL, and you will see the home page with a header and navigation bar. Next, we have to make our application secure with Spring security. Security is an important aspect and core concern for any application today.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making the application secure with Spring Security</h1>
                </header>
            
            <article>
                
<p>Our Blogpress application has a login functionality to access certain pages and functionalities that are not accessible by a normal (anonymous) user. It requires a good amount of effort to incorporate it if we build authentication and authorization on our own from scratch. Spring provides a feature called Spring Security, which does exactly what we need here.</p>
<p>Spring Security is an open source, highly comprehensive, powerful, and customizable framework used to implement authentication and authorization in J2EE-based web applications. It is a sub-project (module) of the Spring Framework.</p>
<p>Before talking further, it is important to understand the difference between authentication and authorization.</p>
<p>Authentication is the process of <strong>validating</strong> or determining someone or something in what it claims to be. There are several mechanisms to perform authentication. The most straightforward way of performing authentication is to provide a username and password. Other ways include through LDAP, single sign-on, OpenId, and OAuth.</p>
<p>On the other hand, authorization is more related to the <strong>permission</strong> of the actions you are allowed to do. In short, authentication means <strong>who you are</strong> and authorization means <strong>what can you do</strong> in the system.</p>
<p>Spring Security provides many features out of the box, including authentication, authorization, protection against CSRF attack, servlet API integration support, Spring MVC integration, remember-me features, SSO implementation support, LDAP authentication support, OpenID integration, web service security support, WebSocket security support, Spring Data integration, and many more.</p>
<p>Though the latest version (at the time of writing this is 5.1.0) of Spring Security supports both XML and annotation support, you still need to do a good amount of configuration if you set it on your own. But you don’t have to worry, as Spring Boot is with you.</p>
<p>Spring Boot also supports Spring Security integration. Just like integration with other modules, you need to add a required starter for Spring Security to work with Spring Boot. Add the following dependency in the <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>As soon as you put the previously mentioned configuration in place, Spring Security becomes active and will not allow accessing even public pages of the application without valid credentials. When you hit <kbd>http://localhost:8080/blogpress</kbd>, you will see a login screen.</p>
<p>Spring Security with its default (auto) configuration, allows you to log in with a specific credential. The username will be <kbd>user</kbd> and password will be generated randomly by Spring Security and printed in the server log like this:</p>
<p><span class="packt_screen">Using generated security password: 89ca7b55-6a5d-4dd9-9d02-ae462e21df81</span>.</p>
<p>You can override the username and password in a <kbd>property</kbd> file. In the project structure, you will see the <kbd>application.properties</kbd> file in the <kbd>src/main/resources</kbd> folder. Just add following two properties to it:</p>
<pre>spring.security.user.name=nilang<br/>spring.security.user.password=password</pre>
<p>Now you can access the application with the previously mentioned credentials, but you still need authentication for accessing even public pages. By default, Spring Security is activated with the default (or auto-) configuration, which secures all the endpoints. This is not we want. So we need to instruct Spring Security which endpoints (URLs) we want to make secure and which we do not.</p>
<p>For this, first, we need to disable the default security <span>(auto-)</span> configuration. There are two possible options here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Excluding auto-configuration</h1>
                </header>
            
            <article>
                
<p>Add an <kbd>exclude</kbd> attribute to the <kbd>@SpringBootApplication</kbd> annotation for the main <kbd>bootstrap</kbd> class, as in the following snippet:</p>
<pre>@SpringBootApplication(exclude = { SecurityAutoConfiguration.class })<br/>public class BlogpressApplication {<br/><br/>  public static void main(String[] args) {<br/>    SpringApplication.run(BlogpressApplication.class, args);<br/>  }<br/>}</pre>
<p>Alternatively, you can add the following property in the <kbd>application.properties</kbd> file:</p>
<pre>spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration</pre>
<p>You can take either of the previously described ways to disable or exclude the security <span>(auto-)</span> configuration. Excluding the auto-configuration is appropriate only in certain scenarios where you need to integrate the security provided by a custom provider.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Substituting auto-configuration</h1>
                </header>
            
            <article>
                
<p>Another way of disabling the auto-security configuration is to surpass it with our own custom configuration. Spring Security is a highly customizable framework and provides a fine-grained access mechanism based on URL and role.</p>
<p>To substitute auto-configuration with custom configuration, we need to specify the configuration class, as in the following snippet:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>@ComponentScan("com.nilangpatel.blogpress")<br/>public class WebSecurityConfig extends WebSecurityConfigurerAdapter {<br/>  …..<br/>}</pre>
<p>The <kbd>WebSecurityConfig</kbd> custom configuration class extends the <kbd>WebSecurityConfigurerAdapter</kbd> abstract class. This abstract class has certain extension points (in the form of abstract methods for which you can provide your custom implementation) and default implementation for the common tasks.</p>
<p>Since our class (<kbd>WebSecurityConfig</kbd>) provides custom configuration, we have to define it with the <kbd>@Configuration</kbd> and <kbd>@ComponentScan("com.nilangpatel.blogpress")</kbd> annotations. You need to give the package (where the custom configuration class resides) name into the <kbd>@ComponentScan</kbd> annotation.</p>
<p>The <kbd>@EnableWebSecurity</kbd> annotation is also important because we are disabling the default security configuration. Without it, our application will not start. We will now override one method of the <kbd>WebSecurityConfigurerAdapter</kbd> class that will be used to define the web configuration and add one additional method that will be used to define user details:</p>
<pre>@Override<br/>public void configure(WebSecurity web) throws Exception {<br/>  web.ignoring().antMatchers("/js/**");<br/>  web.ignoring().antMatchers("/css/**");<br/>}</pre>
<p>Spring Security by default applies to all requests—including static resources as well. This method is used to define an escape sequence for static resources. Spring Security will block them by default if they are not configured <span>to be ignored here</span>. In the absence of the previously discussed configuration, the static resource will not be loaded into the browser so you will not see any <kbd>javascript</kbd>, <kbd>css</kbd>, or <kbd>images</kbd> files. Next, we will add user's details to the same class as follows:</p>
<pre>// create users and admin<br/>@Autowired<br/>public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {<br/><br/>  BCryptPasswordEncoder encoder = passwordEncoder();<br/>  auth.inMemoryAuthentication() .passwordEncoder(encoder)<br/>    .withUser("blogUser1").password(encoder.encode("password")).authorities("USER")<br/>    .and()<br/>    .withUser("blogUser2").password(encoder.encode("password")).authorities("USER")<br/>    .and()<br/>    .withUser("blogAdmin").password(encoder.encode("password")).authorities("ADMIN");<br/>}<br/><br/>@Bean<br/>public BCryptPasswordEncoder passwordEncoder() {<br/>  return new BCryptPasswordEncoder();<br/>}</pre>
<p>The <kbd>configureGlobal</kbd> method is used here to create a username with a password and role on the fly. It is declared with the <kbd>@Autowired</kbd> annotation so that Spring will inject the object of the <kbd>AuthenticationManagerBuilder</kbd> class in it. The <kbd>AuthenticationManagerBuilder</kbd> class is used to provide the implementation of <kbd>AuthenticationManager</kbd>. As we have seen, Spring Security allows various mechanisms for authentication, and provides an implementation of <kbd>AuthenticationManager</kbd> for each of those mechanisms, such as in-memory authentication, LDAP authentication, JDBC authentication, OAuth authentication, and so on.</p>
<p>To make the thing simple, we have used in-memory authentication, which simply puts the user details in memory. This is not ideal for production, however. You are supposed to create user details in a database, and Spring Security is flexible enough to support this scenario as well.</p>
<p>Making the password secure is the most important, core part of any security framework, and hence Spring Security provides an encoding mechanism for this. <span>It provides</span> <kbd>BCryptPasswordEncoder</kbd> , which is an encoder class used to encode the password. It uses the <strong>bcrpt</strong> algorithm for encoding, which is a very strong password hashing routine widely used in Spring Security today.</p>
<div class="packt_infobox">Spring Security also provides a class called <kbd>NoOpPasswordEncoder</kbd> in case you wish to store the password as it is (in plain text form). However, starting with version 5, Spring has decided to deprecate it and it may be removed in future releases. This is because putting passwords as plain text is not encouraged and can lead to a security breach. So you should never use the <kbd>NoOpPasswordEncoder</kbd> class (not even for any POC).</div>
<p>We have used a method named <kbd>configureGlobal</kbd> , but you are absolutely free to choose the one you feel appropriate.</p>
<p>Next, we will override one more method, which is an extension point, to provide custom security settings for each of the endpoints we have in our application, as in the following snippet:</p>
<pre>@Override<br/>protected void configure(HttpSecurity http) throws Exception {<br/>  http.authorizeRequests()<br/>    .antMatchers("/").permitAll()<br/>    .antMatchers("/controlPage/")<br/>    .hasAnyAuthority("ROLE_USER","ROLE_ADMIN")<br/>    .and()<br/>  .formLogin().loginPage("/login").permitAll()<br/>    .defaultSuccessUrl("/controlPage")<br/>    .failureUrl("/login?error=true")<br/>    .and()<br/>  .logout()<br/>    .permitAll().logoutSuccessUrl("/login?logout=true");<br/>}</pre>
<p>We override the configure method (having <kbd>HttpSecurity</kbd> as a method parameter) to provide custom security configuration. If you open the original configure method of the parent class (<kbd>WebSecurityConfigurerAdapter</kbd>), it looks like the following snippet. Just putting the reference of the original method side by side will help you to understand what custom configuration we provide for our Blogpress application:</p>
<pre>protected void configure(HttpSecurity http) throws Exception {<br/>  http.authorizeRequests()<br/>    .anyRequest().authenticated()<br/>    .and()<br/>    .formLogin().and()<br/>    .httpBasic();<br/>}</pre>
<p>The default <kbd>configure</kbd> method simply authenticates all requests. It allows a user to authenticate with a form-based login and supports HTTP basic authentication. This is the reason we were getting a default login page as soon as Spring Security was activated in Spring Boot with no custom security configuration.</p>
<div class="packt_infobox">In the Spring Security paradigm, <kbd>principal</kbd> refers to the username while <kbd>authorities</kbd> refers to the roles a user has. Keeping these terminologies in mind while working with Spring Security will help you understand the concepts better.</div>
<p>Now, let's see what customization we did in our overridden configure method as follows:</p>
<ul>
<li style="font-weight: 400">The <kbd>antMatchers("/", "/home").permitAll()</kbd> line will allow the listed URLs without any authentication. It means the <kbd>/</kbd> (default URL —<kbd>http://localhost:8080/blogpress</kbd>) URL is accessible publicly. You can provide any further URLs in comma-separated lists here.</li>
<li style="font-weight: 400">The next <kbd>antMatchers("/controlPage").hasAnyAuthority("ROLE_USER","ROLE_ADMIN")</kbd> line makes the <kbd>/controlPage</kbd> URL accessible to any user with the <kbd>ROLE_USER</kbd> or <kbd>ROLE_ADMIN</kbd> roles.</li>
<li style="font-weight: 400">The next <kbd>formLogin().loginPage("/login").permitAll()</kbd> line allows us to set the login page URL. We kept the <kbd>/login</kbd> URL, but you can give any custom login URL. Since the login page should be accessible publicly, the <kbd>permitAll()</kbd> method will make the login URL accessible to all.</li>
<li style="font-weight: 400">Once Spring Security authenticates the user, it will send to a success page. You can configure the custom success page with <kbd>defaultSuccessUrl("/controlPage")</kbd>. In this case, the success URL is <kbd>/controlPage</kbd>.</li>
<li style="font-weight: 400">Similarly in case authentication fails, it should send to the error page. The <kbd>failureUrl("/login?error=true")</kbd> line will send the flow to the <kbd>/login</kbd> URL (along with parameters) on failed authentication.</li>
<li style="font-weight: 400">Finally, the <kbd>permitAll().logoutSuccessUrl("/login?logout=true")</kbd> line configured the logout page. Once a user logs out, the system will trigger the <kbd>/login</kbd> URL (along with parameters).</li>
</ul>
<p>We have added our custom security configuration; now it is time to add methods in Spring MVC corresponding to each <span>URL</span> we mentioned in the previous Spring configuration. Add the following methods in Spring MVC:</p>
<pre>@GetMapping("/")<br/>  public String showHomePage(Model model) {<br/>    logger.info("This is show home page method ");<br/>    setProcessingData(model, BlogpressConstants.TITLE_HOME_PAGE);<br/>    return "home";<br/>  }<br/>@GetMapping("/controlPage")<br/>  public String showControlPage(Model model) {<br/>    logger.info("This is control page ");<br/>      setProcessingData(model, BlogpressConstants.TITLE_LANDING_CONTROL_PAGE);<br/>      return "control-page";<br/>  }<br/>@GetMapping("/login")<br/>  public String showLoginPage(@RequestParam(value = "error",required = false) String error,<br/>      @RequestParam(value = "logout", required = false) String logout,Model model) {<br/>    logger.info("This is login page URL ");<br/>    if (error != null) {<br/>      model.addAttribute("error", "Invalid Credentials provided.");<br/>    }<br/>    if (logout != null) {<br/>      model.addAttribute("message", "Logged out");<br/>    }<br/>    setProcessingData(model, BlogpressConstants.TITLE_LOGIN_PAGE);<br/>    return "login";<br/>  }</pre>
<p>The <kbd>showHomePage</kbd> method is responsible for showing the home page when a user clicks on the <span class="packt_screen">Home</span> link from navigation. It is associated with <kbd>/</kbd> URL and will show the <kbd>home.html</kbd> (Thymeleaf) template. In addition, this method is also called when you hit the <kbd>http://localhost:8080/blogpress</kbd> URL.</p>
<p>The <kbd>showControlPage</kbd> method is associated with the <kbd>/controlPage</kbd> URL and will be called on successful authentication. This method drives the user to the <kbd>control-page.html</kbd> (Thymeleaf) template, which shows administrative links based on the role. For example, a user with the <kbd>ROLE_ADMIN</kbd> role can see the links for <span class="packt_screen">Manage Blogs</span> and <span class="packt_screen">Manage Comments,</span> while a user with the <kbd>ROLE_USER</kbd> role will see only the <span class="packt_screen">Manage Blogs</span> link.</p>
<p>The <kbd>showLoginPage</kbd> method represents the login functionality. It is associated with the <kbd>/login</kbd> URL. It stores messages based on parameter values along with the page title attribute, which is used to display a title of the page (in the <kbd>header.html</kbd> template). Finally, it opens the <kbd>login.html</kbd> template.</p>
<p>Apart from these methods, the following methods are added, which stores model attributes that are available in Thymeleaf templates directly using the <kbd>${}</kbd> expression:</p>
<pre>@ModelAttribute("validUserLogin")<br/>public boolean isUserLoggedIn() {<br/>  return SecurityContextHolder.getContext().getAuthentication() != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication().isAuthenticated() &amp;&amp;<br/>       //when Anonymous Authentication is enabled<br/>       !(SecurityContextHolder.getContext().getAuthentication() instanceof AnonymousAuthenticationToken); <br/>}<br/><br/>@ModelAttribute("currentUserName")<br/>public String getCurrentUserName() {<br/>    return SecurityContextHolder.getContext().getAuthentication().getName();<br/>}<br/>@ModelAttribute("hasAdminRole")<br/>  public boolean checkIfUserHasAdminRole(){<br/>    return checkIfUserHasRole(BlogpressConstants.ROLE_ADMIN);<br/>  }<br/>@ModelAttribute("hasUserRole")<br/>  public boolean checkIfUserHasUserRole(){<br/>    return checkIfUserHasRole(BlogpressConstants.ROLE_USER);<br/>  }<br/>private boolean checkIfUserHasRole(String roleName) {<br/>     boolean hasUserRole =      SecurityContextHolder.getContext().getAuthentication().getAuthorities().stream()<br/>                .anyMatch(r -&gt; r.getAuthority().equals(roleName));<br/>     return hasUserRole;<br/>  }</pre>
<p>The <kbd>isUserLoggedIn</kbd> method checks if any user is currently logged in. It will be called by the<kbd>${validUserLogin}</kbd> expression in the <span>Thymeleaf</span> template. The <span><kbd>getCurrentUserName</kbd> method simply provides the c</span><span>urrent logged-in username. The <kbd>checkIfUserHasUserRole</kbd> and <kbd>checkIfUserHasAdminRole</kbd> methods simply check the respective roles.</span> <span>You can see how the <kbd>SecurityContextHolder</kbd> class is used to fetch user login details. This class is responsible to store currently authenticated user's details, also known as principle.</span></p>
<p>We have gradually shaped up the Blogpress application, and it is now equipped with Spring MVC, Thymeleaf, and Spring Security. All this rapid development is possible with the help of Spring Boot. The next part we are going to develop is a data layer, which is the most important and crucial part of our application. As we mentioned, we will construct the data layer in <strong>Elasticsearch</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Storing data with Elasticsearch</h1>
                </header>
            
            <article>
                
<p>Elasticsearch is a highly <span>scalable</span> and full-text search open source RESTful searching, indexing, and analytics engine developed on top of <strong>Lucene</strong>. It is one of the most popular search engines for building enterprise applications today. It can save, search, and analyze data in big volumes very quickly. Mainly, it is used for applications where complex searching is required.</p>
<p>It is developed in Java and provides near real-time results. It is designed to work in a distributed environment to provide high availability and scalability. It is document-oriented, stores complex entity structures in JSON format, and provides a web interface to interact with.</p>
<p>Elasticsearch is mainly used in applications when searching for a large amount of matching products (for example, e-Commerce), using auto-complete features for partially typed input, or analyzing the huge quantities of raw data stored in a distributed fashion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Artifacts</h1>
                </header>
            
            <article>
                
<p>It is important to understand a few terminologies that are frequently used with Elasticsearch, which will help you to understand how Elasticsearch is built and how it works. They are the core of Elasticsearch. We will look at each of them in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Documents</h1>
                </header>
            
            <article>
                
<p>The basic unit of information that is stored in Elasticsearch is called a <strong>document</strong>. You can consider a document equivalent to an entity in the <strong>r<span>elational database management system</span></strong> (<strong>RDBMS</strong>). For example, a document can be created for an employee, another document is for a salary, and so forth. A document will be indexed by the Elasticsearch engine, and they are presented in JSON format. Each document is associated with the document type. You can relate a document type with a <strong>Plain Old Java Object</strong> (<strong>POJO</strong>) class while a document as an object of POJO class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Indexes</h1>
                </header>
            
            <article>
                
<p>An index is a group of documents having a similar structure. You can define an <strong>index</strong> for employee data, another for salary data, and so on. An index can be identified by a name associated with it. An index name is used for indexing, searching along with CRUD operations for the documents it comprises. You can define as many indexes as you want. An index is always independent of another index. A group of indexes is referred to as indices in Elasticsearch.</p>
<p>Prior to version 6.0.0, Elasticsearch allowed the creation of multiple document types for a given index. For example, you can create document types for users and employees (or even more) for index organization. Starting with version 6, Elasticsearch put a restriction of allowing only one document type for a given index. So, you need to create a separate index for each of the document types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clusters and nodes</h1>
                </header>
            
            <article>
                
<p>Elasticsearch is a distributed system, means it can scale horizontally and runs on more than one server to handle a huge amount of data with optimal speed. The network of such servers is called a <strong>cluster,</strong> where as the single server is referred to as a node.</p>
<p>Nodes and clusters are both identified by name. For nodes, Elasticsearch generates a default random <strong><span>universally unique identifier</span></strong> (<strong>UUID</strong>) on startup. If you wish, you can change the default name. The node name is important as it will help to administer the servers associated with the node name.</p>
<p>The cluster name is used by a node to join it. By default, all nodes are associated with the cluster with the <kbd>elasticsearch</kbd> name. You can create as many nodes as you want for a given cluster.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shards and replicas</h1>
                </header>
            
            <article>
                
<p>Elasticsearch stores data in the form of documents, which are grouped into an index. In the case of a huge amount of data, the number of documents in a single index may cross the limit of the underlying hardware capacity. For example, more than a trillion documents stored in a single index may need up to <strong>100 GB</strong> of space, which it may not be possible to store in a single node.</p>
<p>As a solution to this problem, Elasticsearch provides a mechanism to break the index into multiple pieces; each can be considered a separate index and can be stored in multiple nodes. The pieces of an index are called <strong>shards</strong>. This will also improve search performance as the search can be performed simultaneously on multiple shards.</p>
<p>Replica, as its name suggest, is a copy of shards. They are created for fail over; in case one shard is down or goes offline, a replica will be used to provide service and make the system highly available.</p>
<p>In short, an index can be divided into multiple shards; each shard can have zero or more replicas. So each index has one primary shard, along with zero or more replica shards. By default, Elasticsearch associates five primary shards for each index along with one replica (as of the latest stable version 6.4.1).</p>
<p>For our Blogpress application, we will keep the default values, a single node having an index with default shards and replica settings. The name of the index will be <kbd>blog</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with Elasticsearch</h1>
                </header>
            
            <article>
                
<p>Elasticsearch provides a way to interact with it for searching, indexing, and performing other CRUD operations. It provides a RESTful API for the interaction, so you can use various HTTP methods (<kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>DELETE</kbd>, and so on) to deal with any operation on Elasticsearch.</p>
<p>Elasticsearch does not maintain the state of the request, and hence each request is independent, and information is exchanged in JSON format. Various HTTP methods are used to perform CRUD operations on Elasticsearch. For example, a <kbd>GET</kbd> method is used to retrieve the data, while <kbd>PUT</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd> are used to update or delete records.</p>
<p>Since Elasticsearch exposes REST APIs, you can use any REST client (for example, <strong>Postman</strong>) to work with it. Furthermore, to analyze and visualize the data, Elasticsearch provides another free and open source tool called <strong>Kibana</strong>. It provides a simple browser-based interface to perform search, view, and other CRUD operations along with rich data analysis, presented in a variety of tables, charts, and map-<span>like memory, as well as disk utilization, indices, and document information. It also helps to manage the indices and document types, perform CRUD operations for document data, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation</h1>
                </header>
            
            <article>
                
<p>Let's first install Elasticsearch. Download the Elasticsearch ZIP bundle from <a href="https://www.elastic.co/downloads">https://www.elastic.co/downloads</a>. Unzip it in your local drive and run <kbd>bin/elasticsearch</kbd>. By default, it will be available on the <kbd>9200</kbd> port. Once up and running, you can access it with <kbd>http://localhost:9200</kbd>.</p>
<p>You can download and install Kibana from the same <a href="https://www.elastic.co/downloads">https://www.elastic.co/downloads</a> URL. Unzip the bundle and run <kbd>bin/kibana</kbd>. You can access Kibana on the <kbd>5601</kbd> port, that is, <kbd>http://localhost:5601</kbd>.</p>
<div class="packt_infobox">Elasticsearch also provides MSI Installer for Windows, which is a straightforward way to install Elasticsearch on a Windows machine.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Elasticsearch RESTful API</h1>
                </header>
            
            <article>
                
<p>Next, we quickly look at some of the APIs to perform various activities on Elasticsearch. Since Elasticsearch provides REST interface to interact with, you can use any REST client, such as Postman. Alternatively, you can use <strong>Kibana</strong> <span class="packt_screen">Dev Tools</span> to execute REST calls. There is a small difference between them.</p>
<p>We will understand various RESTful API by taking an example of a <kbd>student</kbd> entity. The purpose is to explain how to create a <kbd>students</kbd> index; create the <kbd>student</kbd> document type; add, update, and delete <kbd>student</kbd> data; and delete the document type and index.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an index – students</h1>
                </header>
            
            <article>
                
<p>With your REST client (Postman), <span>enter the following</span>:</p>
<ul>
<li><strong>URL</strong>: <kbd>http://localhost:9200/students</kbd></li>
<li><strong>Method</strong>: <span class="packt_screen">PUT</span></li>
<li><strong>Type</strong>: <span class="packt_screen">JSON (application/json)</span></li>
<li><span class="packt_screen">Body</span>:</li>
</ul>
<pre style="padding-left: 90px">{<br/>}</pre>
<p>With Kibana, go to the <span class="packt_screen">Dev Tools</span> option in Kibana and type the following script:</p>
<pre style="padding-left: 60px">PUT students<br/>{<br/><br/>}</pre>
<p>You will see the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6d85e406-033f-47e0-bc85-e9021ded34a2.png" style="width:20.83em;height:6.17em;"/></p>
<p>We have created a <kbd>student</kbd> index without any explicit settings, so Elasticsearch has created the index with default settings—five shards and one replica. You can see these details in Kibana from the <span class="packt_screen">Management</span> option. In case you wish to give the precise number of shards and replicas (instead of the default five and one), you can add the JSON <span>setting</span> in the body while creating the <kbd>student</kbd> index as follows:</p>
<p>With REST client (Postman), <span>enter the following</span>:</p>
<ul>
<li><strong>URL</strong>: <kbd>http://localhost:9200/students</kbd></li>
<li><strong>Method</strong>: <span class="packt_screen">PUT</span></li>
<li><strong>Type</strong>: <span><span class="packt_screen">JSON (application/json)</span></span></li>
<li><span class="packt_screen">Body</span>:</li>
</ul>
<pre style="padding-left: 90px"> {<br/>    "settings" : {<br/>        "index" : {<br/>            "number_of_shards" : 3, <br/>            "number_of_replicas" : 2 <br/>        }<br/>    }<br/> }</pre>
<p>With Kibana, go to <span class="packt_screen">Dev Tools</span> and type the following script:</p>
<pre>PUT student<br/>{<br/>    "settings" : {<br/>        "index" : {<br/>            "number_of_shards" : 3, <br/>            "number_of_replicas" : 2 <br/>        }<br/>    }<br/>}</pre>
<p>In the previous case, the index is created with three shards and two replicas. This is how you can specify particular settings while creating an index in Elasticsearch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a document type – student</h1>
                </header>
            
            <article>
                
<p>The very next thing in the sequence after creating an index is the creation of the document type. We will create a document type named <kbd>student</kbd> within the <kbd>students</kbd> index. Again, it can be done with REST client or with Kibana. We will see both options in detail.</p>
<p>With REST client (Postman), <span>enter the following</span><strong>:</strong></p>
<ul>
<li><strong>URL</strong>: <kbd>http://localhost:9200/students/_mapping/student</kbd></li>
<li><strong>Method</strong><span>:</span> <span class="packt_screen">POST</span></li>
<li><strong>Type</strong><span>: <span class="packt_screen">JSON (application/json)</span></span></li>
<li><span class="packt_screen">Body</span>:</li>
</ul>
<pre style="padding-left: 90px">{<br/>    "properties":{<br/>      "id":{"type":"long"},<br/>      "name":{"type":"text"},<br/>      "standard":{"type":"integer"},<br/>      "division":{"type":"text"},<br/>      "gender":{"type":"text"}<br/>    }<br/> }</pre>
<p>With Kibana, go to <span class="packt_screen">Dev Tools</span> option and add the following script:</p>
<pre>PUT students/_mapping/student<br/>{<br/>  "properties": {<br/>    "id":{"type":"long"},<br/>    "name":{"type":"text"},<br/>    "standard":{"type":"integer"},<br/>    "division":{"type":"text"},<br/>    "Gender":{"type":"text"}<br/>   }<br/>}</pre>
<p>You can use either of these options to create the document type. We have created the <kbd>student</kbd> document type with ID, name, standard, division, and gender properties within the <kbd>students</kbd> index<em>.</em> Our structure is ready to add the data into Elasticsearch. Next, we will see how to insert the data for <kbd>student</kbd> type that we have defined.</p>
<div class="packt_infobox">Prior to version 6, Elasticsearch allows creating multiple document types in the same index. Starting with 6, they make a restriction of creating only one document type within that index.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a document (student data)</h1>
                </header>
            
            <article>
                
<p>With REST client (Postman), <span>enter the following</span>:</p>
<ul>
<li><strong>URL</strong>: <kbd>http://localhost:9200/students/student/1</kbd></li>
<li><strong>Method</strong>: <span class="packt_screen">PUT</span></li>
<li><strong>Type</strong>: <span><span class="packt_screen">JSON (application/json)</span></span></li>
<li><span class="packt_screen">Body</span>:</li>
</ul>
<pre style="padding-left: 90px">{<br/>    "name":"Nilang",<br/>    "standard":3,<br/>    "division":"B",<br/>    "gender":"M"<br/>}</pre>
<p>With Kibana, go to the <span class="packt_screen">Dev Tools</span> option and type the following script:</p>
<pre>PUT students/student/1<br/>{<br/>    "name":"Nilang",<br/>    "standard":3,<br/>    "division":"B",<br/>    "gender":"M"<br/>}</pre>
<p>You can verify the inserted data with the following REST API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading a document (student data)</h1>
                </header>
            
            <article>
                
<p>With REST client, <span>enter the following</span><strong>:</strong></p>
<ul>
<li><strong>URL</strong>: <kbd>http://localhost:9200/students/student/1</kbd></li>
<li><strong>Method</strong>: <span class="packt_screen">GET</span></li>
</ul>
<p>With Kibana, enter the following:</p>
<pre>GET students/student/1</pre>
<p>You will get the following JSON as an output:</p>
<pre>{<br/>    "_index": "students",<br/>    "_type": "student",<br/>    "_id": "1",<br/>    "_version": 1,<br/>    "found": true,<br/>    "_source": {<br/>        "name": "Nilang",<br/>        "standard": 1,<br/>        "division": "B",<br/>        "gender": "M"<br/>    }<br/>}</pre>
<p>First, it shows the index and document type. The <span><kbd>_id</kbd> attribute represents the ID that we supplied in the</span> <kbd>http:/localhost:9200/students/student/1</kbd> <span>URL while creating the data. If you use any existing <kbd>_id</kbd>, Elasticsearch will simply update that record with current values. The</span> <span><kbd>_version</kbd> attribute represents the number of times the records are updated. The</span> <span><kbd>_source</kbd> attribute represents the data that we supplied.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating a document (student data)</h1>
                </header>
            
            <article>
                
<p>To update the data, the same syntax is used as an add document. While adding, the ID is not present in the system, if present, the existing data will be updated with the value provided. For example, the following command will update existing students' record having <kbd>_id</kbd> equal to five.</p>
<p>With a REST client (Postman), use the following<strong>:</strong></p>
<ul>
<li><strong>URL</strong>: <kbd>http://localhost:9200/students/student/5</kbd></li>
<li><strong>Method</strong>: <span class="packt_screen">POST</span></li>
<li><strong>Type</strong>: <span><span class="packt_screen">JSON (application/json)</span></span></li>
<li><span class="packt_screen">Body</span>:</li>
</ul>
<pre style="padding-left: 90px">{<br/>    "name":"Robert",<br/>    "standard":6,<br/>    "division":"C",<br/>    "gender":"M"<br/>}</pre>
<p>With Kibana, go to the <span class="packt_screen">Dev Tools</span> and execute the following query:</p>
<pre>PUT students/student/5<br/>{<br/>    "name":"Robert",<br/>    "standard":6,<br/>    "division":"C",<br/>    "gender":"M"<br/>}</pre>
<p>Inserting and updating operations use similar syntax and if you try to add the record with an ID that already exists, then that record will be updated by mistake. To avoid this, you can use the <kbd>localhost:9200/students/student/1/_create</kbd> URL. This will throw an error if a record already exists with a <kbd>1</kbd> ID. Similarly, you can use <kbd>localhost:9200/students/student/1/_update</kbd> in case you wish to update the record. It will throw an error if a record does not exist while updating it.</p>
<div class="packt_infobox">While adding the document record, if you do not provide <kbd>_id</kbd>, Elasticsearch will auto-generate one for you.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting a document (student data)</h1>
                </header>
            
            <article>
                
<p>Deleting the document is straightforward. You need to use the HTTP <kbd>DELETE</kbd> method. Just specify <kbd>_id</kbd> of the document you wish to delete, as follows.</p>
<p>With a REST client (Postman), do the following:</p>
<ul>
<li><strong>URL</strong>: <kbd>http://localhost:9200/students/student/1</kbd></li>
<li><strong>Method</strong>: <span class="packt_screen">DELETE</span></li>
</ul>
<p>With Kibana, use the following:</p>
<pre>DELETE students/student/1</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Searching a query</h1>
                </header>
            
            <article>
                
<p>Elasticsearch provides a search facility by passing <kbd>/_search</kbd> at the end of the URL. It can be applied after the server URL, the index, or the type. For example, in our case, if we want to search a student document having name equals to <kbd>nilang</kbd>, we have to use the query as follows.</p>
<p>With a REST client (Postman), use the following:</p>
<ul>
<li><strong>URL</strong>: <kbd>http://localhost:9200/students/student/_search?q=name:nilang</kbd></li>
<li><strong>Method</strong>: <span class="packt_screen">GET</span></li>
</ul>
<p class="mce-root"/>
<p>With Kibana, use<strong>:</strong></p>
<pre>GET students/student/_search?q=name:nilang</pre>
<p>Alternatively, you can use the following syntax for searching. It is quite useful for a complex search with multiple search criteria for multiple fields:</p>
<pre>GET students/student/_search<br/>{<br/>  "query": {<br/>      "match": {<br/>        "name": "nilang"<br/>      }<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating index and document types for Blogpress</h1>
                </header>
            
            <article>
                
<p>After getting the basics of how the index and document type are created, along with inserting document data in Elasticsearch, we will create these artifacts for a Blogpress application. In this application, we need to store the data for blogs and comments. The blog and comments have a one- to-many relationship (one blog has multiple comments), we will create an index structure in such a way that multiple comments will be associated with a single blog.</p>
<p>Elasticsearch provides nested data types to index arrays of objects and maintains them as an independent document. We will maintain an array of comments for a single blog. We will give the index name of <kbd>blog</kbd> and set the document type, to <kbd>blog</kbd>. The following is a script you can run to create a <kbd>blog</kbd> index:</p>
<pre>PUT blog<br/>{<br/>  "mappings":{<br/>    "blog":{<br/>      "properties":{<br/>        "title":{"type":"text"},<br/>        "body":{"type":"text"},<br/>        "status":{"type":"text"},<br/>        "createdBy":{"type":"text"},<br/>        "createdDate":{"type":"date",<br/>                "format": "MM-dd-yyyy'T'HH:mm:ss"},<br/>        "publishDate":{"type":"date",<br/>                           "format": "MM-dd-yyyy'T'HH:mm:ss"},<br/>       "comments":{<br/>        "type":"nested",<br/>        "properties":{<br/>          "id":{"type":"text"},<br/>          "parentId":{"type":"keyword"},<br/>          "childSequence":{"type":"integer"},<br/>          "position":{"type":"text"},<br/>          "status":{"type":"keyword"},<br/>          "level":{"type":"integer"},<br/>          "user":{"type":"text"},<br/>          "emailAddress":{"type":"text"},<br/>          "commentText":{"type":"text"},<br/>          "createdDate":{"type":"date",<br/>                 "format": "MM-dd-yyyy'T'HH:mm:ss"}<br/>          }<br/>        }<br/>      }<br/>  }<br/>  }<br/>}</pre>
<p>In the previous script, we created an index and document type together. The element next to <kbd>mappings</kbd> represents the name of the document type while the index name is with the <kbd>PUT</kbd> HTTP method (<kbd>blog</kbd> in our case). All properties are self-explanatory apart from the comments that are defined as the <kbd>nested</kbd> type, along with their properties. The format of the date can be set with a <kbd>format</kbd> attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Elasticsearch integration with Spring Data</h1>
                </header>
            
            <article>
                
<p>We will configure Elasticsearch as a database to provide various CRUD operations for Blogpress applications. We will use Spring Data for this integration. Spring Data provides an abstract layer for data access from various providers, such as a relational database, a non-relational database, a map-reduced framework, and cloud services.</p>
<p>For each of these data providers, Spring supplies a set of libraries to interact with, while maintaining the abstraction to interact with them in a symmetrical manner. Spring Data spans across various modules, including Spring Data Common, Spring Data JPA, Spring Data REST, Spring Data LDAP, Spring Data MongoDB, Spring Data JDBC, and many more. Spring Data Elasticsearch is one of them t provide data access with Elasticsearch search engines.</p>
<p>We will use the Spring Data Elasticsearch module for the Blogpress application. The very first thing is to make this module available in our application. Unsurprisingly, this can be done by defining a starter in <kbd>pom.xml</kbd> as follows:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Elasticsearch provides a Java API to interact with it programmatically. Soon after you activate the above starter, the required JARs will be added in the classpath to access the Elasticsearch Java API. At this moment, we need to instruct the Spring Data Elasticsearch module about the <span>cluster name, port, and</span> hostname on which the Elasticsearch server is running. You can define these configurations in the <kbd>application.properties</kbd> file (in the <kbd>src/main/resource</kbd> folder) as follows:</p>
<pre>elasticsearch.clustername=elasticsearch<br/>elasticsearch.host=localhost<br/>elasticsearch.port=9300</pre>
<p>This is equivalent to defining a database URL, the driver class name, and credentials for database interaction with Spring Data. The next step is to define a configuration class, which basically uses the previous details and prepares the required artifacts to interact with Elasticsearch, as follows:</p>
<pre>@Configuration<br/>@EnableElasticsearchRepositories(basePackages = "com.nilangpatel.blogpress.repository")<br/>@ComponentScan(basePackages = { "com.nilangpatel.blogpress.config" })<br/>public class ElasticDataConfig {<br/><br/>     @Value("${elasticsearch.host}")<br/>      private String esHost;<br/><br/>      @Value("${elasticsearch.port}")<br/>      private int esPort;<br/><br/>      @Value("${elasticsearch.clustername}")<br/>      private String esClusterName;<br/><br/>      @Bean<br/>      public Client client() throws Exception {<br/><br/>          TransportClientFactoryBean transportClientFactory = new TransportClientFactoryBean();<br/>          transportClientFactory.setClusterName(esClusterName);<br/>          transportClientFactory.afterPropertiesSet();<br/>          <br/>          return transportClientFactory.getObject()<br/>                    .addTransportAddress(<br/>            new TransportAddress(InetAddress.getByName(esHost), esPort));<br/>      }<br/><br/>      @Bean<br/>      public ElasticsearchTemplate elasticsearchTemplate() throws Exception {<br/>          return new ElasticsearchTemplate(client());<br/>      }<br/><br/>}</pre>
<p>This class reads the cluster name, port, and host values defined in the <kbd>application.properties</kbd> file with the <kbd>@Value</kbd> annotation. The <kbd>client()</kbd> method uses the <kbd>TransactionClientFactory</kbd> object to read the configuration data and return an object of the <kbd>TransportClient</kbd> class, which represents the client interface to interact with Elasticsearch.</p>
<p>The next <kbd>elasticsearchTemplate()</kbd> method uses this client object and creates the <kbd>ElasticsearchTemplate</kbd> object. Spring provides the data access template class for each of the data providers. The object of the <kbd>ElasticsearchTemplate</kbd> class is initialized with the object of the <kbd>TransportClient</kbd> class. This method is defined with the <kbd>@Bean</kbd> annotation so that the object of <kbd>ElasticsearchTemplate</kbd> is accessible with the <kbd>@Autowired</kbd> annotation to other classes.</p>
<p><span>This initialization happens when starting an application.</span> The <kbd>ElasticsearchTemplate</kbd> class is the single point of interaction of the Elasticsearch engine with Spring Data. The <kbd>@EnableElasticsearchRepositories</kbd> annotation in this class is used to point the Spring JPA repository package that we are going to define next. Before that, we will first define a model class that represents a document in Elasticsearch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Data Elasticsearch model class</h1>
                </header>
            
            <article>
                
<p><span>Spring Data facilitate the <strong>Data Access Object</strong> (<strong>DAO</strong>) layer implementation for the various data providers. The DAO mechanism makes the system loosely coupled by providing data access abstraction, allowing the changes in the underlying data provider without affecting the business implementation.</span></p>
<p><span>It allows the interaction with the data layer in an object-oriented manner. It means you can create, read, update, and delete the data with an entity class object. This abstraction is also applicable for the Spring Data Elasticsearch module. You can access the data in the form of objects. For this, we need to define a model (entity) class that represents the data structure that we defined in Elasticsearch as follows:</span></p>
<pre>@Document(indexName = "blog", type = "blog")<br/>public class Blog {<br/><br/>  @Id<br/>  private String _id;<br/>  private String title;<br/>  private String body;<br/>  private String status;<br/>  private String createdBy;<br/>  <br/>  @JsonFormat<br/>    (shape = JsonFormat.Shape.STRING, pattern = "MM-dd-yyyy'T'HH:mm:ss")<br/>  private Date createdDate;<br/><br/>  @JsonFormat<br/>    (shape = JsonFormat.Shape.STRING, pattern = "MM-dd-yyyy'T'HH:mm:ss")<br/>  private Date publishDate;<br/>  <br/>  @Field(includeInParent=true, type = FieldType.Nested)<br/>  private List&lt;Comment&gt; comments;<br/><br/>// Getter and setters for above properties</pre>
<p>The model class is a POJO with a <kbd>@Document</kbd> <span>annotation,</span> which defines the index and document type name this class is associated with. The objects of the <kbd>Blog</kbd> class previously represent the document data for the <kbd>blog</kbd> index and the <kbd>blog</kbd> document in Elasticsearch. The <kbd>@Id</kbd> annotation is used to define a unique id for blog documents. You can relate it to the p<span>rimary key</span> in the relational database. The date fields are defined with the <kbd>@JsonFormat</kbd> annotation, which is used to define the desired date format.</p>
<p>The <kbd>@Field</kbd> annotation is used to define additional metadata about the field. For example, in the case of comments, it is defined as a <kbd>nested</kbd> type as there is no direct mapping of <span>Elasticsearch <kbd>nested</kbd> types</span> available in Java. For other properties, the Java types are directly mapped with Elasticsearch types. <span>Next, we will define a DAO layer with Spring Data.</span></p>
<div class="packt_infobox">The date format that we mentioned in the mapping script should be exactly matched with the date format defined in the POJO class with the <kbd>@JsonFormat</kbd> annotation. If not, the system will show an error while inserting the record.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting Elasticsearch with Spring Data</h1>
                </header>
            
            <article>
                
<p>Spring Data has a concept called a <strong>repository</strong> that is an abstraction of a data store. Designed to add an additional layer, it brings great power and flexibility by making the repository abstraction and providing the concrete implementation of repositories (with all boilerplate code) for each of the data providers.</p>
<p>For Elasticsearch, Spring Data provides a repository interface called <kbd>ElasticsearchRepository</kbd>. This interface (and its parent interface) has all the required methods to interact with Elasticsearch. To reap the benefits of Spring Data, we need to extend this interface so that <span>Spring Data supplies concrete implementation on the fly automatically. Apparently, all the required CRUD methods are available in standard DAO out of the box.</span></p>
<p class="mce-root">Let's leverage Spring Data capabilities for Elasticsearch for the Blogpress application. First, let's define the custom repository interface that extends <kbd>ElasticsearchRepository&lt;T, ID extends Serializable&gt;</kbd>, where <kbd>T</kbd> represents an entity class and <kbd>ID</kbd> represents a unique ID in the entity class as follows:</p>
<pre>public interface BlogRepository extends ElasticsearchRepository&lt;Blog, String&gt;</pre>
<p>The <kbd>Blog</kbd> entity class has <kbd>_Id</kbd> (a string) as a unique identifier (declared with the <kbd>@Id</kbd> annotation). Our DAO layer with all basic CRUD operations is ready. It is always a good idea to define the service class, presenting the service layer. So we will declare the <kbd>BlogService</kbd> service class as follows:</p>
<pre>@Component<br/>public class BlogService {<br/>  @Autowired<br/>  private BlogRepository blogRepository;<br/>....<br/>}</pre>
<p>With the <kbd>@Autowired</kbd> annotation, Spring will inject the object of <kbd>BlogRepository</kbd> into our service class, which can be used to perform various CRUD operations. Next, we can start performing CRUD operations for blog data in Elasticsearch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CRUD operations in Elasticsearch with Spring Data</h1>
                </header>
            
            <article>
                
<p>The basic structure of DAO and the service layer is ready. We can now start performing CRUD operations. <span>As we have seen, just by declaring a custom repository interface, Spring provides all basic CRUD operations in the</span> <span>DAO layer.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding blog data</h1>
                </header>
            
            <article>
                
<p><span>First, we will create a new blog record. For that, add method in <kbd>BlogService</kbd> class as follows:</span></p>
<pre>public void addUpdateBlog(Blog blog) {<br/>    blogRepository.save(blog);<br/>  }</pre>
<p>The object of <kbd>BlogRepository</kbd> is injected by Spring and can be used to perform an add operation. This service method should be called from Spring controller. Add the following methods in controller class to manage the functionality of adding (or updating) new blog:</p>
<pre>@GetMapping("/showAddNew")<br/>  public String showAddNew(Model model) {<br/>    logger.info("This is addNew page URL ");<br/>    setProcessingData(model, BlogpressConstants.TITLE_NEW_BLOG_PAGE);<br/>    return "add-new";<br/>  }<br/>  <br/>  @PostMapping("/addNewBlog")<br/>  public String addNewBlog(@RequestParam(value = "title",required = true) String title,<br/>       @RequestParam(value = "body",required = true) String body,Model model) {<br/>    <br/>    logger.info("Adding new blog with title :"+title );<br/>    Blog blog = new Blog();<br/>    blog.setTitle(title);<br/>    blog.setBody(body);<br/>    blog.setCreatedBy(getCurrentUserName());<br/>    blog.setCreatedDate(new Date());<br/>    blog.setPublishDate(new Date());<br/>    blog.setStatus(BlogStatus.PUBLISHED.getStatus());<br/>    <br/>    blogService.addNewBlog(blog);<br/>    <br/>    return "home";<br/>  }</pre>
<p>The <kbd>showAddNew()</kbd> method simply opens the <kbd>add-new.html</kbd> Thymeleaf template.When a user clicks on the <span class="packt_screen">Add New</span> link from navigation, this method will be called and will show this template where the user can add a new blog with a title and body.</p>
<p>The second method—<kbd>addNew</kbd>, which is declared with the <kbd>@PostMapping</kbd> annotation takes a <kbd>title</kbd> and <kbd>body</kbd> as request parameters, creates an object of a <kbd>Blog</kbd> type, sets those values and call the <kbd>addNewBlog()</kbd> method of service class. You can execute the following query in Kibana to see the inserted data in Elasticsearch:</p>
<pre>GET blog/blog/_search</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading blog data</h1>
                </header>
            
            <article>
                
<p>Next is to show the blog entries on the home page in a tabular format. When a user clicks on it, the system will open the blog in am detailed view (showing the title, full body, and all comments). To list blogs on the home page, we will fetch the blog data from Elasticsearch programmatically. Add the following method in the <kbd>BlogService</kbd> class:</p>
<pre>public List&lt;Blog&gt; getAllBlogs() {<br/>    List&lt;Blog&gt; blogList = new ArrayList&lt;Blog&gt;();<br/>    Iterable&lt;Blog&gt; blogIterable = blogRepository.findAll();<br/>    Iterator&lt;Blog&gt; blogIterator = blogIterable.iterator();<br/>    while(blogIterator.hasNext()) {<br/>      blogList.add(blogIterator.next());<br/>    }<br/>    return blogList;<br/>  }</pre>
<p>The <kbd>getAllBlogs()</kbd> method simply calls the <kbd>findAll()</kbd> method on <kbd>blogRepository</kbd> to get all blog entries. This service method can be called from the controller to show these data on the home page. Instead of a regular controller, we will use the REST controller to showcase how we can leverage the Spring REST controller to present the data. We will cover this in a short while, so keep reading.</p>
<div class="packt_infobox">It is always advisable to use the repository method with pagination. Since the purpose of this chapter is to showcase various components and how they work, I have not used the pagination to make things simple.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Searching blog data</h1>
                </header>
            
            <article>
                
<p>Since this is a blog application, search is an obvious feature. We will allow a user to search the blogs by matching the search text with blog title and body. We can search the documents <span>by passing</span> <kbd>/_search</kbd> <span>at the end of the URL. Elasticsearch provides a Boolean query to search the data based on various conditions.</span></p>
<p>In our case, the search text should be matched with either title or body or both. It can be achieved through a Boolean search query as follows:</p>
<pre>GET blog/blog/_search<br/>{<br/>  "query": {<br/>    "bool": {<br/>      "should": [<br/>        { "match": { "title": "java" }},<br/>        { "match": { "body": "java" }}<br/>      ]<br/>    }<br/>  }<br/>}</pre>
<p>The <kbd>should</kbd> criteria is equivalent to the <em>OR</em> condition. Elasticsearch provides the <kbd>must</kbd> criteria, in case if you want to search with the <em>AND</em> condition. You can specify as many attributes as you want. The string <kbd>java</kbd> is the search text. This query can be written programmatically in Java as follows:</p>
<pre>QueryBuilder booleanQry = QueryBuilders.boolQuery()<br/>                     .should(QueryBuilders.termQuery("title", searchTxt))<br/>                     .should(QueryBuilders.termQuery("body", searchTxt));<br/>    <br/>    SearchResponse response = elasticsearchTemplate.getClient().prepareSearch("blog")<br/>          .setTypes("blog")<br/>          .setQuery(booleanQry)<br/>          .execute().actionGet();</pre>
<p>We are creating a Boolean query and configure the search text with the title and body attribute. The search result will be returned back in JSON format with the <kbd>response</kbd> object. You can parse the JSON to get the desired output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding comment data with Elasticsearch aggregation</h1>
                </header>
            
            <article>
                
<p>The blog has been added to the system. Now a user can add a comment. So next, we will see how to add a comment. As discussed, the <kbd>Comment</kbd> document type is defined as a <kbd>nested</kbd> type in the blog document. It means the blog document contains an array of comment objects, making a one-to-many relationship. We also need to create a comment model class as follows:</p>
<pre>public class Comment {<br/>  private String id;<br/>  private String blogId;<br/>  private String parentId;<br/>  private int childSequence;<br/>  private String position;<br/>  private String status;<br/>  private int level;<br/>  private String user;<br/>  private String emailAddress;<br/>  private String commentText;<br/>  <br/>  @JsonFormat<br/>    (shape = JsonFormat.Shape.STRING, pattern = "MM-dd-yyyy'T'HH:mm:ss")<br/>  private Date createdDate;<br/><br/>//Getter and Setter methods<br/>.....<br/>}</pre>
<p>Since this is nested within a blog, there is no need to define the <kbd>@Document</kbd> annotation as it is not directly associated with any document type. While adding the comment, there is certain metadata that needs to be taken care of, as follows:</p>
<ul>
<li>We are providing the comment with reply functionality. Once a user does reply to any comment, it will be added one level down, considering it as child comment. To maintain this, we use the <kbd>level</kbd> attribute, which simply shows at which level this comment is placed.</li>
<li>The <kbd>blogId</kbd> attribute simply holds the ID of a blog with which this comment is associated. Since this is a nested object, in most of the cases, it is not required to have a parent document ID. But we are going to show the comment list to an admin user to moderate and reply back. To make comment administration simple, we have just added <kbd>blogId</kbd> in the comment.</li>
<li>The <kbd>parentId</kbd> attribute holds the ID of parent comment, if it is placed as a reply, or else it will be zero.</li>
<li>The <span><kbd>childSequence</kbd></span> attribute simply shows the sequence number at a particular level. For example, if there are total two replies (at the second level) and a user tries to add a third reply (at the second level), then the <kbd>childSequence</kbd> attribute will be three. This attribute is used to construct a value of the <kbd>position</kbd> attribute.</li>
<li>The <kbd>position</kbd> attribute will be combination of <kbd>level</kbd> and <kbd>childSequence</kbd>. This is used to sort the comments so that they are displayed in the correct order for a given blog.</li>
</ul>
<p>Since a comment is a <kbd>nested</kbd> type of blog, there is no such method to save only comments. Instead, we need to fetch all comments, add the new one to the associated blog, and then save the whole blog. Everything is straightforward, except getting the value of <kbd>childSequence</kbd>. We will see how to get maximum <kbd>childSequence</kbd> in a given level with the following aggregate query:</p>
<pre>GET blog/blog/_search<br/>{<br/>  "query": {<br/>    "match": {<br/>      "_id": "1huEWWYB1CjEZ-A9sjir"<br/>    }<br/>  },<br/>  "aggs": {<br/>    "aggChild": {<br/>      "nested": {<br/>        "path": "comments"<br/>      },<br/>      "aggs": {<br/>        "filterParentId": {<br/>          "filter": {<br/>            "nested": {<br/>              "path": "comments",<br/>              "query": {<br/>                "match": {<br/>                  "comments.parentId": "0"<br/>                }<br/>              }<br/>            }<br/>          },<br/>          "aggs": {<br/>            "maxChildSeq": {<br/>              "max": {<br/>                "field": "comments.childSequence"<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p>Before we can understand the query, we need to look at what aggregation is. In Elasticsearch, an aggregation is a mechanism used to provide aggregated data on a search query. They are used to compose complex queries. They come under four categories, as follows:</p>
<ul>
<li>Bucketing</li>
<li>Metric</li>
<li>Matrix</li>
<li>Pipeline</li>
</ul>
<p>Each of these aggregation types can be used in a nested fashion, meaning it can be used as a sub-aggregation to another, to solve very complex queries. Now, let's go back to the query to find <kbd>childSequence</kbd> and understand it.</p>
<p>The very first <kbd>query</kbd> criteria matches the value against <kbd>blogId</kbd> (<kbd>_id</kbd>). Any attribute given to the <kbd>query</kbd> criteria in the beginning will match its value against the <kbd>blog</kbd> attribute. The next is the aggregate query that is applied to the <kbd>nested</kbd> document—<kbd>comments</kbd>. Each aggregate query has a name. The first aggregate query has the <kbd>aggChild</kbd> name.</p>
<p>Going further, the next aggregate query with the <kbd>filterParentId</kbd> name simply matches <kbd>parentId</kbd>, which is nothing but the parent comment ID. It is required to find <kbd>childSequence</kbd> under given a comment as a parent comment. For top-level comments, this must be zero. The last aggregate query with the <kbd>maxChildSeq</kbd> name simply finds the maximum of <kbd>childSequence</kbd>. It uses maximum criteria. Each <kbd>nested</kbd> aggregate query simply applies the search criteria to results given by the preceding aggregate query. You will get results of this query similar to the following:</p>
<pre>  "aggregations": {<br/>    "aggChild": {<br/>      "doc_count": 4,<br/>      "filterParentId": {<br/>        "doc_count": 2,<br/>        "maxChildSeq": {<br/>          "value": 3<br/>        }<br/>      }<br/>    }<br/>  }</pre>
<p><span>The query result contains other information, but we will only focus on <kbd>aggregation</kbd>. The result shows a document count at each aggregate query. The value of <kbd>maxChildSeq</kbd> is three means there are three comments at level one (top-level comment), so when a user adds a new (top-level) comment, <kbd>childSequnce</kbd> will be four.</span></p>
<p>This was the REST-based query. For the Blogpress application, we need to execute similar queries in the Java class. Elasticsearch provides Java APIs to perform anything that can be done through REST query. When we define a starter for Elasticsearch in Spring Boot, the required Elasticsearch JAR files are available in the classpath. To write the preceding query with Java APIs, we need to write a custom fetch method in our Elasticsearch repository.</p>
<p>Spring Data is an extensible framework, allowing us to provide customized implementation of a repository on top of what it provides out of the box. So first we will extend the Elasticsearch repository with following steps.</p>
<ol>
<li>Define a custom repository interface called <kbd>BlogRepositoryCustom</kbd>.</li>
<li>The <kbd>BlogRepository</kbd> interface that we created initially should extend this interface, along with <kbd>ElasticsearchRepository&lt;Blog, String&gt;</kbd>, as follows:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">public interface BlogRepository extends ElasticsearchRepository&lt;Blog, String&gt;,BlogRepositoryCustom</pre>
<ol start="3">
<li>Define the custom repository implementation class that implements the <kbd>BlogRepositoryCustom</kbd> interface as follows:</li>
</ol>
<pre style="padding-left: 60px">@Repository<br/>public class BlogRepositoryCustomImpl implements BlogRepositoryCustom {<br/><br/>  private static Logger logger = LoggerFactory.getLogger(BlogRepositoryCustomImpl.class);<br/>  <br/>  @Autowired<br/>  private ElasticsearchTemplate elasticsearchTemplate;<br/>  <br/>  ....<br/>  <br/>}</pre>
<p>This class must be declared with the <kbd>@Repository</kbd> annotation. We can define any custom method in this class. We want to write a method with an Elasticsearch Java API to find the maximum child sequence at a given level, so we will write it in this class as follows:</p>
<pre>public int getCurrentChildSequence(String blogId,String parentCommentId) {<br/>    int currentChildSeq=0;<br/>    TermQueryBuilder termQueryBuilder = new TermQueryBuilder("comments.parentId", parentCommentId);<br/>    <br/>    NestedAggregationBuilder aggregationBuilder = AggregationBuilders.nested("aggChild",  "comments").subAggregation(AggregationBuilders.filter("filterParentId", termQueryBuilder).subAggregation(AggregationBuilders.max("maxChildSeq").field("comments.childSequence")));<br/>    TermQueryBuilder rootTermQueryBuilder = new TermQueryBuilder("_id", blogId);<br/>    SearchResponse response = elasticsearchTemplate.getClient().prepareSearch("blog")<br/>      .setTypes("blog")<br/>      .setQuery(rootTermQueryBuilder)<br/>      .addAggregation(aggregationBuilder)<br/>      .execute().actionGet();<br/><br/>    if(response !=null) {<br/>      if(response.getAggregations() !=null) {<br/>        List&lt;Aggregation&gt; aggLst = response.getAggregations().asList();<br/>        if(aggLst !=null) {<br/>          Aggregation resultAgg = aggLst.get(0);<br/>          if(resultAgg !=null) {<br/>            //getMaxChildSequenceFromJson method parse the json to get max child sequence<br/>            currentChildSeq = getMaxChildSequenceFromJson(resultAgg.toString());<br/>          }<br/>        }<br/>      }<br/>    }<br/>    //Adding one to set next sequence<br/>    currentChildSeq=currentChildSeq+1;<br/>    return currentChildSeq;<br/>  }</pre>
<p>The <kbd>AggregationBuilders</kbd> class is used to construct an aggregate query. The Elasticsearch Java API is self-explanatory and simple. You can easily relate this Java API query with a REST query. We first create a nested aggregate query and then add a filter aggregate query as a sub-aggregation followed by a <kbd>max</kbd> aggregation.</p>
<p>The value of <kbd>blogId</kbd> is added with a <kbd>TermQueryBuilder</kbd> class. Finally, we get an Elasticsearch client from <kbd>elasticsearchTemplate</kbd> and initiate search by providing an index name (<kbd>blog</kbd>), a document type (<kbd>blog</kbd>), a root level query (for <kbd>blogId</kbd>), and at the end setting the aggregations. This Java API returns the aggregation JSON that we got for REST query, which you can process with a JSON API to get the desired result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading comment data with Elasticsearch aggregation</h1>
                </header>
            
            <article>
                
<p>Once comments are added, they must be visible when the user opens the blog. This scenario is straightforward. Since comments are nested objects of a blog, when we read a blog with the following API, all its comments are also available as part of the blog object:</p>
<pre> Optional&lt;Blog&gt; blogObj = blogRepository.findById(blogId);<br/>    if(blogObj.isPresent()) {<br/>      return blogObj.get();<br/>    }else {<br/>      return null;<br/>    }</pre>
<p>The <kbd>findById</kbd> method is provided out of the box by a default repository implementation, available during runtime. We pass <kbd>blogId</kbd>, and it will fetch all details of the blog along with comments (as nested objects).</p>
<p>The second scenario for reading comment is the admin user opens the manage-comment page, where all comments are displayed for moderation purposes. In this case, the system will show all comments added to any of the blogs, so it is necessary to bring all comments from all blogs.</p>
<p>The first way of achieving this is to fetch all blogs, take the comments, and append them to build the comments list. But this is not an ideal solution as it requires many things to be done manually. We can use Elasticsearch aggregation queries to do this. By default, the <kbd>nested</kbd> objects cannot be fetched directly as a parent object, so it requires aggregation:</p>
<pre>GET blog/blog/_search<br/>{<br/>  "aggs": {<br/>    "aggChild": {<br/>      "nested": {<br/>        "path": "comments"<br/>      },<br/>      "aggs": {<br/>        "aggSortComment": {<br/>          "top_hits": {<br/>            "sort": [<br/>              {<br/>                "comments.createdDate": {<br/>                  "order": "desc"<br/>                }<br/>              }<br/>            ],"from": 0, <br/>            "size": 10<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p>This query has the <kbd>top_hits</kbd> aggregation, which simply lists all <kbd>nested</kbd> objects. We need the data in descending order of <kbd>createdDate</kbd> (recently added should be placed on top), so sorting criteria is added. The <kbd>from</kbd> and <kbd>size</kbd> criteria are used for pagination. The <kbd>from</kbd> <span>criteria</span> represents the offset from first record, while <kbd>size</kbd> shows the total record per page.</p>
<div class="packt_infobox">By default, <kbd>top_hits</kbd> will return three records if you have not provided the <kbd>size</kbd> <span>value.</span> Also, the maximum allowed size is 100 so while using <kbd>top_hits</kbd>, you have to use pagination.</div>
<p>This query returns the result. Aggregation data for full results is shown in the following snippet:</p>
<pre>"aggregations": {<br/>    "aggChild": {<br/>      "doc_count": 7,<br/>      "aggSortComment": {<br/>        "hits": {<br/>          "total": 7,<br/>          "max_score": null,<br/>          "hits": [<br/>            {<br/>              "_index": "blog",<br/>              "_type": "blog",<br/>              "_id": "Bsz2Y2YBksR0CLn0e37E",<br/>              "_nested": {<br/>                "field": "comments",<br/>                "offset": 2<br/>              },<br/>              "_score": null,<br/>              "_source": {<br/>                "id": "e7EqiPJHsj1539275565438",<br/>                "blogId": "Bsz2Y2YBksR0CLn0e37E",<br/>                "parentId": "0",<br/>                "childSequence": 2,<br/>                "position": "1.2",<br/>                "status": "M",<br/>                "level": 1,<br/>                "user": "Nilang Patel",<br/>                "emailAddress": "nilprofessional@gmail.com",<br/>                "commentText": "installatin of java. great blog",<br/>                "createdDate": "10-11-2018T16:32:45"<br/>              },<br/>              "sort": [<br/>                1539275565000<br/>              ]<br/>            },<br/>            { <br/>              .... Other JSON Objects, each represents comment data.<br/>            }...<br/>         ]<br/>      }<br/>    }<br/>  } <br/>}</pre>
<p>You can write the previous query with the Elasticsearch Java API as follows:</p>
<pre>public List&lt;Comment&gt; getAllComments(int from, int size){<br/><br/>    NestedAggregationBuilder aggregation = AggregationBuilders.nested("aggChild", "comments").<br/>        subAggregation(AggregationBuilders.topHits("aggSortComment").sort("comments.createdDate", SortOrder.DESC).from(from).size(size));<br/>            <br/><br/>    SearchResponse response = elasticsearchTemplate.getClient().prepareSearch("blog")<br/>        .setTypes("blog")<br/>        .addAggregation(aggregation)<br/>        .execute().actionGet();<br/>    <br/>    List&lt;Aggregation&gt; responseAgg = response.getAggregations().asList();<br/>    //getAllCommentsFromJson method process the json and return desire data.<br/>    return getAllCommentsFromJson(responseAgg.get(0).toString());<br/>  }</pre>
<p>Again, this is self-explanatory. First, we are creating a nested aggregation query with <kbd>AggregationBuilders</kbd> and adding the sub-aggregation of the <kbd>top_hits</kbd> type, along with sorting criteria with the <kbd>from</kbd> and <kbd>size</kbd> settings. The process of getting a response is identical to what we used in the method to get the maximum child sequence.</p>
<p>In case we need to display comments with a specific status value, we can use the following query:</p>
<pre>GET blog/blog/_search<br/>{<br/>  "_source": false,<br/>  "aggs": {<br/>    "aggChild": {<br/>      "nested": {<br/>        "path": "comments"<br/>      },<br/>      "aggs": {<br/>        "aggStatsComment": {<br/>          "terms": {<br/>            "field": "comments.status",<br/>            "include": "K"<br/>          },<br/>          "aggs": {<br/>            "aggSortComment": {<br/>              "top_hits": {<br/>                "sort": [<br/>                  {<br/>                    "comments.createdDate": {<br/>                      "order": "desc"<br/>                    }<br/>                  }<br/>                ],<br/>                "from": 0,<br/>                "size": 10<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p>The term aggregation query has been added which checks the value of the status field. You can use a wildcard (<kbd>*</kbd>) for matching criteria, for example, <kbd>A*</kbd> will match all statuses starting with <kbd>A</kbd>. The equivalent Java API appears as follows:</p>
<pre>public List&lt;Comment&gt; getCommentsForStatus(String status,int from, int size) {<br/>    <br/>     IncludeExclude includeExclude = new IncludeExclude(status, null);<br/>    <br/>     NestedAggregationBuilder aggregation = AggregationBuilders.nested("aggChild", "comments").<br/>                    subAggregation(AggregationBuilders.terms("aggStatsComment").<br/>                    field("comments.status").includeExclude(includeExclude).<br/>                    subAggregation(AggregationBuilders.topHits("aggSortComment").size(10).sort("com ments.createdDate", SortOrder.DESC))<br/>    );<br/><br/>    SearchResponse response = elasticsearchTemplate.getClient().prepareSearch("blog")<br/>      .setTypes("blog")<br/>      .addAggregation(aggregation)<br/>      .execute().actionGet();<br/>    <br/>    List&lt;Aggregation&gt; responseAgg = response.getAggregations().asList();<br/>    <br/>    return getAllCommentsWithStatusFromJson(responseAgg.get(0).toString());<br/>    <br/>  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating and deleting comment data with Elasticsearch</h1>
                </header>
            
            <article>
                
<p>Updating a <kbd>nested</kbd> object is straightforward. Elasticsearch does not provide a direct way to update a specific <kbd>nested</kbd> object. Instead, you need to fetch all the <kbd>nested</kbd> objects from the root document, find the particular <kbd>nested</kbd> object (possibly by some unique identifier), update it, assign the <kbd>nested</kbd> object list back to the root document, and save the root document. For example, we can update the status for specific comment (<kbd>nested</kbd>) objects of a blog with the following method. It is defined in the service class:</p>
<pre>public void updateCommentStatus(String blogId,String commentId, List&lt;Comment&gt; commentList, String updatedStatus) {<br/>    if(commentList !=null) {<br/>      for(Comment comment: commentList) {<br/>        if(comment.getId().equals(commentId)) {<br/>          comment.setStatus(updatedStatus);<br/>          break;<br/>        }<br/>      }<br/>        Blog blog = this.getBlog(blogId);<br/>        blog.setComments(commentList);<br/>        blogRepository.save(blog);<br/>    }<br/>  }</pre>
<p>Deleting of a comment is similar. Just remove the required comment object from the list and save the blog object to delete the comment.</p>
<div class="packt_infobox">Another way of achieving a one-to-many relationship in Elasticsearch is through the parent-child structure. However, it is slower than the <kbd>nested</kbd> objects. The only drawback with the <kbd>nested</kbd> object is whenever any <kbd>nested</kbd> object is updated, the root document needs to be re-indexed. But due to retrieval of data, this is comparatively fast, and the <kbd>nested</kbd> objects are preferred to the parent-child structure.</div>
<p>We have understood how to interact with Elasticsearch and fetch data. Next we will see how to display those data at the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying data with RESTful web services in Spring</h1>
                </header>
            
            <article>
                
<p>Spring provides RESTful web service implementations with its web MVC module. With each annotation, the creation of a REST web service is more or less like web MVC architecture. The RESTful web services can be built with the help of a REST controller. The noticeable difference between a web MVC and REST controller is the way they create the HTTP response.</p>
<p>A traditional web MVC uses various view technologies (such as JSP, Thymeleaf, and so on) to build a response, while the REST controller returns objects that are converted into JSON (or XML, based on the configuration), and finally sent as a HTTP response. For our Blogpress application, we will use RESTful services in the following two use cases:</p>
<ul>
<li>Showing blog lists on the home page</li>
<li>Showing blog comments when a particular blog is open for view</li>
</ul>
<p>To achieve this, we will write new controller class as follows:</p>
<pre>@RestController<br/>@RequestMapping("api")<br/>public class BlogRESTController {<br/><br/>private Logger logger = LoggerFactory.getLogger(BlogRESTController.class);<br/>@Autowired<br/>private BlogService blogService;<br/><br/>@RequestMapping(value = "/listBlogs", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)<br/>public ResponseEntity&lt;List&lt;Blog&gt;&gt; getAllBlogJSON() {<br/>    logger.info("getting all blog data in json format ");<br/>    List&lt;Blog&gt; allBlogs = blogService.getAllBlogs();<br/>    return new ResponseEntity&lt;List&lt;Blog&gt;&gt;(allBlogs, HttpStatus.OK);<br/>  } <br/>  <br/>@RequestMapping(value = "/listAllComments", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)<br/>public ResponseEntity&lt;List&lt;Comment&gt;&gt; getAllCommentJSON() {<br/>    logger.info("getting all blog data in json format ");<br/>    List&lt;Comment&gt; allComments = blogService.getAllComments(0, 100);<br/>    return new ResponseEntity&lt;List&lt;Comment&gt;&gt;(allComments, HttpStatus.OK);<br/>  }<br/>}</pre>
<p>The REST controller must be defined with the <kbd>@RestController</kbd> annotation. Since we have two controllers now (one is the normal web MVC , and the second is the REST controller), we defined request mapping with <kbd>@RequestMapping</kbd> to differentiate the URL pattern.</p>
<p>The <kbd>@RequestMapping</kbd> annotation defines the method URL, HTTP method name and MIME type of the output this method produces. The <kbd>getAllBlogJSON()</kbd> method gets list of <kbd>Blog</kbd> objects and sends it with <kbd>ResponseEntity</kbd>, along with the HTTP response code. The <kbd>ResponseEntity</kbd> class represents the response body, header, and status code, and this class is used to prepare the HTTP response. To use it, the only thing required is to define it as return type of method (end point).</p>
<div class="packt_infobox">Alternatively, the <kbd>@ResponseBody</kbd> annotation (at method level) can be used to produce a HTTP response. <kbd>ResponseEntity</kbd> does exactly same as <kbd>@ResponseBody</kbd> , but provides some additional features, including setting the HTTP response code so it is better.</div>
<p>The <kbd>ResponseEntity</kbd> type is generic, so you can send any type of object with it. Both methods return the objects of <kbd>Blog</kbd> and <kbd>Comment</kbd>, respectively. Spring automatically converts the object list into a JSON string and returns it as a HTTP body. The <kbd>MediaType</kbd> class provides various mime types. The first method is accessible with the<kbd>http://localhost:8080/api/listBlogs</kbd> URL, and the second method with <kbd>http://localhost:8080/api/listAllComments</kbd>.</p>
<p>Next we will see how to present this data with a presentation layer. For our Blogpress application, we used the Thymeleaf template to construct a view layer. Thymeleaf templates are processed at server side. We will use another template engine called <strong>Mustache</strong> for client-side processing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a UI with the Mustache template</h1>
                </header>
            
            <article>
                
<p>The Mustache is a web template available for many languages, like JavaScript, Ruby, PHP, Python, Perl, Android, C++, Java, and so on, with a language-specific implementation. In our Blogpress application, we will use Mustache for JavaScript, so we need to include <kbd>Mustache.js</kbd> in the Blogpress application. Let's first understand the use case where <kbd>Mustache.js</kbd> is appropriate.</p>
<p>Quite often, to show dynamic values in HTML, we mix the data with HTML fragments and then update the DOM markup to show the final output. The following is the sample example for this approach:</p>
<pre>$("#addAddress").live('click', function(){;<br/>       var oldAddress = "";//Assume that oldAddress value supplied from server side.<br/>       var newContent = "&lt;div id='group2' class='accordion-group'&gt;" +<br/>                        "&lt;input type='text' id='address' class='textbox-input'"+ oldAddress +"/&gt;"                            + "&lt;/div&gt;";<br/>       $("#accordion1").html(newContent);<br/> });</pre>
<p>This kind of code n<span>ot only</span> creates a maintenance nightmare, but it mixes the UI and dynamic data logic together, thus causing <span>tight coupling between them. This prevents the code being reused and breaks the separation of the concern principle.</span></p>
<p>The best solution for this kind of problem is to use some sort of HTML template. There are many client-side HTML template engines available today, <kbd>Mustache.js</kbd> is one of them, and we have chosen it to construct a few of the pages for our Blogpress application. Let's see how it works by taking a very simple example as follows:</p>
<pre>    &lt;div id="studentSection"&gt;&lt;/div&gt;<br/>    <br/>    &lt;script id="greeting_template" type="text/template"&gt;<br/>        &lt;div&gt;<br/>          Hello, &lt;b&gt;&lt;span&gt;{{firstName}}&lt;/span&gt;&lt;/b&gt;   &lt;span&gt;{{lastName}}&lt;/span&gt;<br/>        &lt;div&gt;<br/>    &lt;/script&gt; <br/>    &lt;script type="text/javascript"&gt;<br/>          var template = $("#greeting_template").html();<br/>          var student = {"firstName":"Nilang","lastName":"Patel"};<br/>          var text = Mustache.render(template, student);<br/>          $("#studentSection").html(text);<br/>    &lt;/script&gt;</pre>
<p>This example is self-explanatory. The template has been defined with <kbd>&lt;script&gt;</kbd> of the <kbd>text/template</kbd> type. With <kbd>Mustache.js</kbd>, we are reading the template and passing the <kbd>student</kbd> object. In the template, the <strong><kbd>{{...}}</kbd></strong> notation is used to insert dynamic values. This not only makes the code clear, but can accommodate any future change with ease.</p>
<p><kbd>Mustache.js</kbd> is a logic-less template, which means it does not contain procedural statements such as if-else, for, and so on, but we can use tags to achieve some sort of loop and conditional. For our Blogpress application, we are using <kbd>Mustache.js</kbd> in the following two pages:</p>
<ul>
<li><span class="packt_screen">Home</span> page to show all blogs in list format with minimal information</li>
<li><span class="packt_screen">Manage Comment</span> page where all comments are listed for moderation and reply for the admin user</li>
</ul>
<p>First, we will deal with the home page where all blogs are shown in list format. The following is the code for the Mustache template on the home page:</p>
<pre>&lt;!-- Define the template --&gt;<br/>      &lt;script id="blog_template" type="text/template"&gt;<br/>        {{#blogs}}<br/>         &lt;div class="card bg-white mb-3"&gt;<br/>           &lt;div class="card-body"&gt;<br/>          &lt;h5 class="card-title"&gt;{{title}}&lt;/h5&gt;<br/>          &lt;p class="card-text"&gt;{{body}}&lt;/p&gt;<br/>           &lt;form th:action="@{/viewBlog}" method="post"&gt;<br/>            &lt;input type="hidden" name="blogId" value="{{id}}"&gt;<br/>            &lt;button type="submit" class="btn btn-primary"&gt;Read More ..&lt;/button&gt;<br/>           &lt;/form&gt;<br/>           &lt;/div&gt;<br/>           &lt;div class="card-footer text-muted"&gt;<br/>          By : &lt;b&gt;{{createdBy}}&lt;/b&gt;   comments: &lt;b&gt;{{comments.length}}&lt;/b&gt;   Published on &lt;b&gt;{{publishDateForDisplay}}&lt;/b&gt;<br/>           &lt;/div&gt;<br/>         &lt;/div&gt;<br/>        {{/blogs}} <br/>      &lt;/script&gt;<br/>    <br/>       &lt;div class="container"&gt;<br/>          &lt;div class="blogpress-section" id="blogList"&gt;<br/>          &lt;/div&gt;<br/>       &lt;/div&gt;<br/>       <br/>     &lt;script th:inline="javascript" type="text/javascript"&gt;<br/>       jQuery(document).ready(function(){<br/>        var blogData = {};<br/>        var template = $("#blog_template").html();<br/>        jQuery.get(/*[[@{/api/listBlogs}]]*/, function(data, status){<br/>          blogData["blogs"] = data;<br/>              var text = Mustache.render(template, blogData);<br/>              $("#blogList").html(text); <br/>          });<br/>      });<br/>    &lt;/script&gt;</pre>
<p>The first script tag defines the template with the <kbd>text/template</kbd> type. The <kbd>{{#blogs}}</kbd> and <kbd>{{/blogs}}</kbd> expressions are evaluated in two ways. If a blog key exists and has a false value or empty list (if it's a type of array), the HTML code in between will not be displayed. If it's true or a non-empty list (array), then it will render the in-between HTML.</p>
<p>In our case, we want to show the blog list with the <kbd>Mustache.js</kbd> template. The data is populated from a REST web service (which eventually calls a REST controller) through Ajax. If successful, the data is stored in the <kbd>blogData</kbd> object with <kbd>blogs</kbd> as a key. This key is used in the <kbd>Mustache.js</kbd> template (<kbd><span>{{#blogs}} ....</span><span>{{/blogs}}</span></kbd>) to iterate the blog array. The individual attribute is placed with the <kbd>{{...}}</kbd> expression. For example, <kbd>{{body}}</kbd> will display a value of a body attribute from the blog object. <kbd>Mustache.render</kbd> <span>takes the template and data, and produces the final output that is appended in <kbd>div</kbd> with the</span> <kbd>blogList</kbd> ID.</p>
<p>We have used <kbd>th:inline</kbd> in the second script tag. This is a Thymeleaf tag. In case you need to substitute the value in the script tag, you need to define it with <kbd>th:inline</kbd>. The Thymeleaf value can be inserted with the <kbd>/*[[,,,]]*/</kbd> notation. In this case, we are passing a dynamic URL so we have used <kbd>@{/api/listBlogs}</kbd> inside <kbd>/*[ .. ]*/</kbd> (so that the final URL would be <kbd>http://localhost:8080/api/listBlogs</kbd>). This will look like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c1a2c38c-d19c-4c64-893e-6d6686375599.png" style="width:35.00em;height:23.17em;"/></p>
<p>Another page is the managed comment page where the comments are displayed with the <kbd>Mustache.js</kbd> template, as follows:</p>
<pre>&lt;script id="comment_template" type="text/template"&gt;<br/>        {{#comments}}<br/>         &lt;div class="card bg-white mb-3"&gt;<br/>           &lt;div class="card-body"&gt;<br/>          &lt;div class="card-title"&gt;<br/>            &lt;div class="clearfix"&gt;<br/>              &lt;p class="mb-0"&gt;<br/>                By &lt;span class="float-left"&gt;{{user}}&lt;/span&gt;<br/>                On &lt;span class="float-right"&gt;{{createdDateForDisplay}}&lt;/span&gt;<br/>              &lt;/p&gt;<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>          &lt;p class="card-text"&gt;{{commentText}}&lt;/p&gt;<br/>           &lt;div class="card-footer text-muted"&gt;<br/>            {{#showApproveReject}}<br/>             &lt;div&gt;<br/>              &lt;form th:action="@{/updateCommentStatus}" method="post" id="updateCommentStatusFrm-{{id}}"&gt;<br/>              &lt;input type="hidden" name="blogId" value="{{blogId}}"&gt;<br/>              &lt;input type="hidden" name="commentId" value="{{id}}"&gt;<br/>              &lt;input type="hidden" name="commentStatus" id="commentStatus-{{id}}" value=""&gt;<br/>              &lt;button type="button" class="btn btn-primary" id="approveComment-{{id}}"&gt;Approve&lt;/button&gt;<br/>              &lt;button type="button" class="btn btn-primary" id="rejectComment-{{id}}"&gt;Reject&lt;/button&gt;<br/>              &lt;/form&gt;<br/>             &lt;/div&gt;<br/>            {{/showApproveReject}}<br/>            {{#showReply}}<br/>             &lt;div&gt;<br/>                 &lt;form th:action="@{/replyComment}" method="post"&gt;<br/>                 &lt;input type="hidden" name="blogId" value="{{blogId}}"&gt;<br/>                 &lt;input type="hidden" name="commentId" value="{{commentId}}"&gt;<br/>                 &lt;button type="button" class="btn btn-primary"&gt;Reply&lt;/button&gt;<br/>                 &lt;/form&gt;<br/>               &lt;/div&gt;<br/>            {{/showReply}}<br/>            &lt;/div&gt;<br/>           &lt;/div&gt;<br/>         &lt;/div&gt;<br/>        {{/comments}} <br/>      &lt;/script&gt;<br/><br/>        &lt;div class="container"&gt;<br/>          &lt;div class="blogpress-section" id="commentList"&gt;&lt;/div&gt;<br/>        &lt;/div&gt;<br/><br/>    &lt;script th:inline="javascript" type="text/javascript"&gt;<br/>       jQuery(document).ready(function(){<br/>        var commentData = {};<br/>        var template = $("#comment_template").html();<br/>        jQuery.get(/*[[@{/api/listAllComments}]]*/, function(data, status){<br/>          for (var i = 0; i &lt; data.length; i++) {<br/>              var comment = data[i];<br/>              if(comment.status === 'M'){<br/>                comment["showApproveReject"]="true";<br/>              }<br/>              if(comment.status === 'A'){<br/>                comment["showReply"]="true";<br/>              }<br/>          }<br/>          commentData["comments"] = data;<br/>              var text = Mustache.render(template, commentData);<br/>              $("#commentList").html(text); <br/>          });<br/>      });<br/>    &lt;/script&gt;</pre>
<p>This template is similar to what we have seen for blog lists on the home page. The additional thing here is the population of the <kbd>showApproveReject</kbd> and <kbd>showReply</kbd> attributes with the <kbd>true</kbd> value. Since Mustache is a logic-less template, there is no direct provision for a conditional statement, such as if-else. The only way of adding a condition is with the <kbd>{{#attribute}} ... {{/attribute}}</kbd> expression, where it will check if an attribute key is available and set to <kbd>true</kbd>.</p>
<p>In the <span class="packt_screen">Manage Comment</span> page, each comment is listed for admin moderation. If a comment status is <span class="packt_screen">M</span> (moderate), the system shows buttons—<span class="packt_screen">Approve</span> and <span class="packt_screen">Reject</span>. If it is approved (status <span class="packt_screen">A</span>) then the system will show an option to <span class="packt_screen">Reply</span> to the comment. With the <kbd>Mustache.js</kbd> template, we cannot directly check the status value. So, two additional keys (<kbd>showApproveReject</kbd> and <kbd>showReply</kbd>) are added in the comment object and set it to <kbd>true</kbd>, based on the value of the status.</p>
<p>This will look like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a4215b73-53c5-4a3d-8936-e85149e29746.png" style="width:53.33em;height:22.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have been on a long journey. There is no better way to build an application than taking a real-life scenario and learning about the underlying concepts, tools, and technology. In this chapter, we took a blog application and built various layers with a set of frameworks.</p>
<p>Taking the Spring Framework as a foundation, we began our journey with Spring Boot—a rapid tool to propel the development, with all the underlying configuration to be done with a kind of auto-mode. We framed the first layer with the Spring MVC web framework in conjunction with Thymeleaf. Being a natural template engine, Thymeleaf is another way of constructing a view layer. We built the authentication and authorization, a very important part of the application, with Spring Security.</p>
<p>We implemented the data source of the Blogpress application with Elasticsearch—an open source highly scalable search engine, mainly used for indexing and analyzing purposes. After exploring basic concepts, we learned how to create an index, document type, and add the document data, followed by how to search them in Elasticsearch, by taking a sample of a <kbd>student</kbd> entity.</p>
<p>Moving on further, we learned to create the data structure with a nested object for our Blogpress application. Inserting data into and retrieving it from the nested object with various searching and aggregation mechanisms were the main crux of the data layer we implemented in Elasticsearch.</p>
<p>Taking a further step to bridge the persistence layer developed in Elasticsearch with the front-facing layer in Spring MVC, we used the Spring Data module. Then we leveraged the extension capabilities of the Spring Data framework to implement customized queries with the Elasticsearch Java API. In the end, we saw how the client-side template engine <kbd>Mustache.js</kbd> is useful to solve the problem of mixing the logic of dynamic data with HTML fragments.</p>
<p>In the next chapter, we will focus on making the application secure with Spring Security. We will talk more about the integration of Spring Security with OAuth 2—a widely used protocol for authorization. We will also look at <strong>Lightweight Directory Access Protocol</strong> (<strong>LDAP</strong>) integration with Spring Security to build a central application that supports authentication and authorization.</p>


            </article>

            
        </section>
    </body></html>