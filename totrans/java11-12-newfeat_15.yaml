- en: Miscellaneous Improvements in JDK 12
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 12 中的其他改进
- en: Java 12 is the latest **Short Term Support** (**STS**) release by Oracle. However,
    the industry is still warming to migrating to the latest **Long-Term-Support** (**LTS**)
    Java release by Oracle, that is, Java 11.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 12 是 Oracle 发布的最新 **短期支持**（**STS**）版本。然而，行业仍在逐渐接受迁移到 Oracle 的最新 **长期支持**（**LTS**）Java
    版本，即 Java 11。
- en: The notable features in JDK 12 are the addition of Shenandoah GC and `switch`
    expressions. We covered `switch` expressions in [Chapter 11](7d0cca79-35c9-4912-9414-12db320d684d.xhtml),
    *Switch Expressions*. Since a detailed coverage of Shenandoah GC is beyond the
    scope of this book, I'm covering it in this chapter with the remaining additions
    and updates to Java 12.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 12 中的显著特性是 Shenandoah 垃圾回收器和 `switch` 表达式的添加。我们在第 11 章 [Switch Expressions](7d0cca79-35c9-4912-9414-12db320d684d.xhtml)
    中介绍了 `switch` 表达式。由于对 Shenandoah 垃圾回收器的详细覆盖超出了本书的范围，我在本章中介绍了它，包括对 Java 12 的剩余添加和更新。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Shenandoah—a low-pause-time GC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shenandoah – 一种低暂停时间的垃圾回收器
- en: The microbenchmark suite
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微基准测试套件
- en: The **Java Virtual Machine** (**JVM**) Constants API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 虚拟机**（**JVM**）常量 API'
- en: One AArch64 port, not two
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AArch64 端口，而不是两个
- en: Default CDS archives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认 CDS 归档
- en: Abortable mixed collections for G1
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1 可中止的混合收集
- en: Promptly return unused committed memory from G1
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1 及时返回未使用的已提交内存
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To use the features that are included in this chapter, you should have JDK 12
    or a later version on your system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中包含的功能，您应该在您的系统上安装 JDK 12 或更高版本。
- en: Since this chapter covers multiple features in Java 12, let's quickly map the
    features with their **JDK Enhancement Proposal** (**JEP**) number and scope.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章涵盖了 Java 12 中的多个功能，让我们快速将功能与其 **JDK 增强提案**（**JEP**）编号和范围进行映射。
- en: Mapping features of JDK 12 scope and JEP
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射 JDK 12 范围和 JEP 的功能
- en: 'The following table lists the JDK 12 features covered in this chapter, their
    corresponding JEP number, and their scope:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了本章中涵盖的 JDK 12 功能、它们对应的 JEP 编号和它们的范围：
- en: '| **JEP** | **Scope** | **Description** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **JEP** | **范围** | **描述** |'
- en: '| 189 | Implementation | Shenandoah—a low-pause-time GC |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 189 | 实现 | Shenandoah – 一种低暂停时间的垃圾回收器 |'
- en: '| 230 | JDK | The microbenchmark suite |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 230 | JDK | 微基准测试套件 |'
- en: '| 334 | SE | The JVM constants API |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 334 | SE | JVM 常量 API |'
- en: '| 340 | JDK | One AArch64 port, not two |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 340 | JDK | 一个 AArch64 端口，而不是两个 |'
- en: '| 341 | JDK | Default CDS archives |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 341 | JDK | 默认 CDS 归档 |'
- en: '| 344 | Implementation | Abortable mixed collections for G1 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 344 | 实现 | G1 可中止的混合收集 |'
- en: '| 346 | Implementation | Promptly return unused committed memory from G1 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 346 | 实现 | G1 及时返回未使用的已提交内存 |'
- en: Let's get started with the first feature.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个功能开始。
- en: Shenandoah – a low-pause-time GC
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shenandoah – 一种低暂停时间的垃圾回收器
- en: Proposed and developed by engineers at Red Hat, Shenandoah GC promises significantly
    low pauses. It is a region-based GC that collects garbage in a parallel and concurrent
    manner. It is interesting to note that the pause times are independent of the
    application's live data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Red Hat 的工程师提出并开发，Shenandoah 垃圾回收器承诺具有显著低的暂停时间。它是一种基于区域的垃圾回收器，以并行和并发的方式收集垃圾。值得注意的是，暂停时间与应用程序的存活数据无关。
- en: 'With hardware engineering and lower costs, servers have more memory and processing
    power than ever before. Modern applications are increasingly demanding lower pause
    times—with **Service Level Agreement** (**SLA**) applications that guarantee response
    times of 10 to 500 ms. To meet the lower end of this range, a GC should be able
    to accomplish multiple tasks, including the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随着硬件工程和成本的降低，服务器比以往任何时候都有更多的内存和计算能力。现代应用程序越来越需要更低的暂停时间——对于保证 10 到 500 毫秒响应时间的
    **服务级别协议**（**SLA**）应用程序。为了满足这个范围的低端，垃圾回收器应该能够完成多个任务，包括以下内容：
- en: Use algorithms that enable programs to execute with the given memory
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用能够使程序在给定内存上执行的算法
- en: Keep the pause times low (that is, below 10 ms)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持暂停时间低（即低于 10 毫秒）
- en: Is this attainable with, say, a Java application that uses 200 GB memory? This
    isn't possible with the compacting algorithms, which will exceed the limit of
    10 ms, even for compacting 10% of this memory. Shenandoah uses an algorithm that
    compacts the memory concurrently while the Java threads are running. In this case,
    objects are moved during a concurrent GC cycle and all of its references immediately
    access the newer copy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否可行，比如说，一个使用200 GB内存的Java应用程序？使用压缩算法是不可能的，即使是压缩10%的内存，也会超过10毫秒的限制。Shenandoah
    使用了一种算法，在Java线程运行的同时并发压缩内存。在这种情况下，对象在并发GC周期中移动，并且所有引用对象都立即访问新的副本。
- en: Concurrent compaction isn't simple. When GC moves a live object, it must **atomically**
    update all references to the object, pointing to the new object. However, to find
    all of the references, the entire heap should be scanned; this sounds infeasible.
    To get around this, the Shenandoah GC adds a **forwarding pointer** to each object,
    with each use of that object going through that pointer. This simplifies the process
    of moving around objects. The Shenandoah GC thread or application thread can copy
    an object and use compare and swap to update the forwarding pointer. In case of
    contention, only one compare and swap will succeed. With the addition of the forwarding
    pointer, Shenandoah GC uses more space than other GC algorithms.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并发压缩并不简单。当GC移动一个活动对象时，它必须**原子性地**更新所有指向该对象的引用，指向新对象。然而，为了找到所有引用，整个堆都应该被扫描；这听起来不可行。为了解决这个问题，Shenandoah
    GC为每个对象添加了一个**转发指针**，每次使用该对象时都会通过该指针。这简化了移动对象的过程。Shenandoah GC线程或应用程序线程可以复制一个对象并使用比较和交换来更新转发指针。在竞争的情况下，只有一个比较和交换会成功。通过添加转发指针，Shenandoah
    GC比其他GC算法使用更多的空间。
- en: Each Shenandoah GC cycle consists of four phases. A Shenandoah GC cycle begins
    with **Initial Marking**, in which it *stops the world* and scans the root set.
    In phase two, that is, **Concurrent Marking**, it marks the live objects and updates
    references, concurrently. In the third phase, **Final Marking**, it *stops the
    world* and scans the root set again, copying and updating roots to updated copies.
    The last phase, **Concurrent Compaction**, evacuates live objects from the targeted
    regions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Shenandoah GC周期由四个阶段组成。Shenandoah GC周期从**初始标记**开始，此时它会**停止世界**并扫描根集。在第二阶段，即**并发标记**阶段，它会并发地标记活动对象并更新引用。在第三阶段，**最终标记**阶段，它会**停止世界**并再次扫描根集，复制并更新根集到更新的副本。最后一个阶段，**并发压缩**，将活动对象从目标区域中移除。
- en: Shenandoah is a region-based GC. It isn't a generational GC that focuses on
    collecting the youngest objects. This is based on the hypothesis that most objects
    die young. However, applications with caches hold on to the objects long enough,
    and so generational GC algorithms don't work with them. To get around this, Shenandoah
    uses the **Least Recently Used** (**LRU**) cache benchmark that enables it to
    keep its pause time low.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Shenandoah 是基于区域的GC。它不是一个关注收集最年轻对象的代际GC。这是基于这样一个假设：大多数对象都是年轻时死亡的。然而，具有缓存的应用程序会长时间保留对象，因此代际GC算法无法与它们一起工作。为了解决这个问题，Shenandoah
    使用了**最近最少使用**（**LRU**）缓存基准测试，这使得它能够保持其暂停时间很低。
- en: Shenandoah never compacts humongous objects (that is, objects that can't fit
    in one region and require multiple regions). If the Shenandoah GC cycle determines
    that a humongous object is no longer live, its region is immediately reclaimed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Shenandoah永远不会压缩巨型对象（即无法适应一个区域且需要多个区域的对象）。如果Shenandoah GC周期确定一个巨型对象不再活动，其区域将立即被回收。
- en: The main target of Shenandoah GC is to increase the responsiveness of the JVM
    by lowering the count and duration of GC cycles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Shenandoah GC的主要目标是通过降低GC周期的数量和持续时间来提高JVM的响应性。
- en: The microbenchmark suite
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微基准测试套件
- en: 'Based on **Java Microbenchmark Harness** (**JMH**), this feature adds a basic
    suite of microbenchmarks to the JDK source code, with the following proposed directory
    structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基于**Java Microbenchmark Harness**（**JMH**），此功能向 JDK 源代码添加了一组基本的微基准测试，以下为建议的目录结构：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since the microbenchmark suite will be located with the JDK source code, it
    will make it simpler for developers to locate and run existing microbenchmarks,
    and create new ones. As existing features are updated or removed from a JDK version,
    it will be simple to update a microbenchmark. Also, when developers run a microbenchmark
    they can use JMH's powerful filtering to run selected benchmarks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微基准测试套件将位于JDK源代码中，这将使开发者更容易定位和运行现有的微基准测试，并创建新的测试。当现有功能被更新或从JDK版本中删除时，更新微基准测试将变得简单。此外，当开发者运行微基准测试时，他们可以使用JMH强大的过滤功能来运行选定的基准测试。
- en: Although the microbenchmark suite and its building will be integrated with JDK
    and its build system, it will have a separate target. Developers will need to
    specify additional parameters to execute it to keep the build time for normal
    JDK low.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微基准测试套件及其构建将与JDK及其构建系统集成，但它将有一个单独的目标。开发者需要指定额外的参数来执行它，以保持正常JDK的构建时间低。
- en: As the name suggests, with benchmarking you can compare builds or releases.
    Hence, the microbenchmarks support JDK (*N*) for the new JDK and JDK (*N-1*) for
    the previous release. The benchmarks depend on JMH in the same way that unit tests
    depend on TestNG or `jtreg`. JMH is used during the build process and is packaged
    as part of the resulting JAR file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，通过基准测试，你可以比较构建或发布版本。因此，微基准测试支持新JDK的JDK (*N*) 和旧版本的JDK (*N-1*)。基准测试依赖于JMH，就像单元测试依赖于TestNG或`jtreg`一样。JMH在构建过程中使用，并被打包为结果JAR文件的一部分。
- en: The JVM constants API
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM常量API
- en: This JEP introduces an API to standardize the description and loading of class
    constants.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JEP引入了一个API来标准化类常量的描述和加载。
- en: Every Java class has a constant pool. It either stores simple values such as
    strings and integers or values to represent classes or methods. Class constant
    pool values are used as operand values for the **ldc** (**load constant**) bytecode
    instruction. These constants can also be used by the **invokedynamic** bytecode instruction—in
    the static argument list of a bootstrap method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java类都有一个常量池。它存储简单的值，如字符串和整数，或者表示类或方法的值。类常量池值用作**ldc**（**加载常量**）字节码指令的操作数值。这些常量也可以由**invokedynamic**字节码指令使用——在启动方法的静态参数列表中。
- en: When either an ldc or invokedynamic instruction executes, it represents the
    constant value as a Java data type value, a class, an integer, or a string. Until
    now, the responsibility of modeling bytecode instructions and loading constants
    was on the class that wanted to manipulate class files. This usually takes the
    focus of these classes off their business logic, moving it to the specifics of
    how to model bytecode instructions and load class constants. This is clearly a
    good candidate to separate the concerns and define the API to work with the *how*
    part.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行ldc或invokedynamic指令时，它将常量值表示为Java数据类型值、一个类、一个整数或一个字符串。到目前为止，建模字节码指令和加载常量的责任在于想要操作类文件的类。这通常会使这些类的业务逻辑焦点转移到如何建模字节码指令和加载类常量的具体细节上。这显然是一个很好的候选者，可以将关注点分离并定义用于处理*如何*部分的API。
- en: Also, it isn't easy for classes to implement this functionality by themselves,
    because loading class constants isn't a simple process for non-string and non-integer
    values. Class loading is a complex process and has multiple points of failure.
    Class loading is dependent on the host environment, including the existence of
    classes, the ability to gain access to them, and their relevant permissions. Class
    loading could also fail during the linking process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类本身实现此功能并不容易，因为对于非字符串和非整数值，加载类常量不是一个简单的过程。类加载是一个复杂的过程，有多个故障点。类加载依赖于宿主环境，包括类的存在、访问它们的能力以及它们的相应权限。类加载也可能在链接过程中失败。
- en: An absence of a standardized library to handle these functions of loading constants
    also results in mismatched expectations between programs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏一个标准化的库来处理这些加载常量的功能，也导致了程序之间期望的不匹配。
- en: JDK 12 defines a new package, `java.lang.invoke.constant`, which defines a family
    of value-based symbolic reference types. It can be used to describe all types
    of loadable constants. A symbolic constant uses a nominal form and essentially
    excludes a constant from its loading or accessibility context. The package includes
    types such as `ClassDesc`, `MethodTypeDesc`, `MethodHandleDesc`, and `DynamicConstantDes`
    to describe various constants. Data types such as `String`, `Integer`, `Long`,
    `Float`, and `Double` are also used to represent simple class constants.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 12 定义了一个新的包，`java.lang.invoke.constant`，它定义了一组基于值的符号引用类型。它可以用来描述所有可加载的常量。符号常量使用名义形式，本质上排除了常量从其加载或可访问性上下文。该包包括如`ClassDesc`、`MethodTypeDesc`、`MethodHandleDesc`和`DynamicConstantDes`等类型来描述各种常量。数据类型如`String`、`Integer`、`Long`、`Float`和`Double`也用于表示简单的类常量。
- en: There are varied use cases of this package. Libraries that parse or generate
    bytecodes need to describe classes and method handles in a symbolic manner. Bootstraps
    for invokedynamic will get simpler because they will be able to work with symbolic
    representation, rather than working with live classes and method handles. It will
    be simpler for the compiler and offline transformers to describe classes and their
    members, which can't be loaded into the running **Virtual Machine** (**VM**).
    Compiler plugins, such as annotation processors, also need to describe uses classes
    and their members in symbolic terms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该包有多种用途。需要解析或生成字节码的库需要以符号方式描述类和方法句柄。invokedynamic 的引导将变得更加简单，因为它们将能够与符号表示一起工作，而不是与活生生的类和方法句柄一起工作。对于编译器和离线转换器来说，描述无法加载到运行**虚拟机**（**VM**）中的类及其成员将变得更加简单。编译器插件，如注解处理器，也需要以符号术语描述使用类及其成员。
- en: One AArch64 port, not two
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 AArch64 版本，而不是两个
- en: Until version 12, JDK had two 64-bit ARM ports, even though both produce an
    AArch64 implementation. As a maintenance feature, this JEP removes all sources
    related to the 64-bit 64-bit ARM platform and retains the 64-bit ARM AArch64 port.
    It will prevent the duplication of work to maintain two ports. As part of the
    process, the option to build this port will also be removed from JDK. It will
    also validate that the 32-bit ARM port continues to work as expected and that
    it isn't affected by these changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 直到版本 12，JDK 有两个 64 位 ARM 版本，尽管两者都产生 AArch64 实现。作为一个维护特性，这个 JEP 删除了与 64 位 ARM
    平台相关的所有源代码，并保留了 64 位 ARM AArch64 版本。这将防止维护两个版本的工作重复。在这个过程中，还将从 JDK 中移除构建此版本的选择。它还将验证
    32 位 ARM 版本是否按预期继续工作，并且这些更改不会影响它。
- en: Default CDS archives
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认 CDS 存档
- en: To understand the enhancements to CDS archives with JDK 12, let's quickly recap
    what CDS is and how it impacts your applications. I covered this briefly in [Chapter
    2](210b06d5-c434-43dd-90a7-23c1d83d69bf.xhtml), *AppCDS*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 JDK 12 对 CDS 存档的增强，让我们快速回顾一下 CDS 是什么以及它如何影响您的应用程序。我在[第 2 章](210b06d5-c434-43dd-90a7-23c1d83d69bf.xhtml)，“AppCDS”中简要介绍了这一点。
- en: What is CDS?
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 CDS？
- en: A commercial feature with Oracle JVM since Java 8, CDS helps to reduce the start
    up time of a Java application and its memory footprint. This is especially notable
    when you are working with multiple JVMs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 8 以来，CDS 是 Oracle JVM 的一项商业功能，它有助于减少 Java 应用程序的启动时间和内存占用。当您与多个 JVM 一起工作时，这一点尤为明显。
- en: On startup, JVM prepares the environment for execution. It includes bytecode
    loading, verification, linking, and initializing of the core classes and interfaces.
    The classes and interfaces are combed into the runtime state of the JVM so that
    they can be executed. It also includes method areas and constant pools.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，JVM 为执行准备环境。这包括字节码加载、验证、链接和核心类和接口的初始化。这些类和接口被整理到 JVM 的运行状态中，以便它们可以执行。它还包括方法区域和常量池。
- en: These set of core classes and interfaces don't change unless you update your
    JVM. So, every time you start your JVM, it performs the *same* steps to get the
    environment up for execution. Imagine that you could dump the result to a file,
    which could be read by your JVM at startup. The subsequent startups could get
    the environment up and running without performing the intermediate steps of loading,
    verification, linking, and initialization; welcome to CDS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心类和接口只有在您更新 JVM 时才会改变。因此，每次您启动 JVM，它都会执行相同的步骤来为执行准备环境。想象一下，您可以将结果导出到一个文件中，该文件可以在
    JVM 启动时被读取。随后的启动可以跳过加载、验证、链接和初始化的中间步骤；欢迎来到 CDS。
- en: When you install JRE, CDS creates a shared archive file from a predefined set
    of classes from the system JAR file. Classes are verified by the class loaders
    before they can be used and this process applies to all of the classes. To speed
    up this process, the installation process loads these classes into an internal
    representation and then dumps that representation to `classes.jsa`—the shared
    archive file. When the JVM starts or restarts, the shared archive file is memory
    mapped to save the loading of those classes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装JRE时，CDS会从系统JAR文件中预定义的类集合创建一个共享存档文件。在类可以使用之前，它们会被类加载器验证，这个过程适用于所有类。为了加快这个过程，安装过程将这些类加载到内部表示中，然后将该表示转储到`classes.jsa`——共享存档文件。当JVM启动或重启时，共享存档文件会被内存映射以节省加载这些类的过程。
- en: When the JVM's metadata is shared among multiple JVM processes, it results in
    a smaller memory footprint. Loading classes from a populated cache are faster
    than loading them from the disk; they are also partially verified. This feature
    is also beneficial for Java applications that start new JVM instances.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM的元数据在多个JVM进程之间共享时，它会导致更小的内存占用。从已填充的缓存中加载类比从磁盘加载它们更快；它们也部分经过验证。这个特性对启动新JVM实例的Java应用程序也有益。
- en: Using CDS archives have reportedly resulted in the reduction of the application
    start up time by more than 30% on basic programs such as `HelloWorld` with JDK
    11\. This number is even higher on numerous 64-bit platforms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CDS存档据报道在JDK 11中使基本程序（如`HelloWorld`）的应用程序启动时间减少了30%以上。在许多64位平台上，这个数字甚至更高。
- en: Enhancing CDS
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强CDS
- en: Often, developers end up not using a feature that could enhance the performance
    of their application—out of ignorance—by just missing a step. Or should we call
    it a usability issue?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，开发者由于疏忽而未能使用本可以提升其应用程序性能的功能——仅仅是因为遗漏了一步。或者我们应该称之为可用性问题吗？
- en: 'At present, even though the JDK includes a default class list, it can be used
    with the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，尽管JDK包含默认的类列表，但它可以用以下命令使用：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though this behavior is documented, developers miss reading the document,
    and hence, can't use this feature.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种行为有文档记录，但开发者忽略了阅读文档，因此无法使用这个特性。
- en: JDK 12 modifies the build process. It runs the `java -Xshare:dump` command after
    linking it to the class list. To ensure that the CDS archive file is part of the
    JDK image, the shared archive file is placed in the `lib/server` directory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 12修改了构建过程。它在将`java -Xshare:dump`命令链接到类列表之后运行。为了确保CDS存档文件是JDK镜像的一部分，共享存档文件被放置在`lib/server`目录中。
- en: The shared archive file is used **automatically** during application startup,
    since `-Xshare:auto` is the default option with the server VM in JDK 11\. So,
    unless it is specifically turned off using the `-Xshare:off` option, developers
    and applications will continue using it without executing any additional commands
    or set up.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动时，共享存档文件会**自动**使用，因为`-Xshare:auto`是JDK 11中服务器虚拟机的默认选项。所以，除非使用`-Xshare:off`选项将其明确关闭，否则开发者和应用程序将继续使用它，而无需执行任何额外的命令或设置。
- en: CDS includes a predefined list of classes and interfaces from the core Java
    API. For the inclusion of specific API or application classes, or for specific
    GC behavior, developers can create and use a custom archive file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: CDS包含来自核心Java API的预定义类和接口列表。为了包含特定的API或应用程序类，或者为了特定的GC行为，开发者可以创建并使用自定义存档文件。
- en: Abortable mixed collections for G1
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1的可中止混合收集
- en: Developers are increasingly demanding more definite behavior from GCs. For instance,
    wouldn't you prefer to execute your application with a GC that guarantees an upper
    limit to its pause timings?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者越来越要求GC有更明确的行为。例如，你难道不希望使用一个保证其暂停时间上限的GC来执行你的应用程序吗？
- en: When working with G1 GC in Java 12, you can abort *mixed collections* if they
    exceed your specified limit. Note that you can't abort *all* categories of G1
    GC pauses.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Java 12中使用G1 GC时，如果混合收集超过了你指定的限制，你可以中止它们。请注意，你不能中止G1 GC暂停的所有类别。
- en: A mixed collection includes both *young* and *old* memory regions for G1 to
    clean. An analysis system selects the set of regions, collectively called a **collection
    set**, for G1 GC to work on. Prior to JDK 12, G1 GC could exceed the maximum pause
    time when the collection set was too large, the collection set included too many
    old regions, or the collection set included regions with *stale* data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 混合集合包括 G1 清理的 *年轻* 和 *旧* 内存区域。分析系统选择一组区域，统称为 **集合集**，供 G1 GC 处理。在 JDK 12 之前，当集合集太大、包含太多旧区域或包含具有
    *陈旧* 数据的区域时，G1 GC 可能会超过最大暂停时间。
- en: With JDK 12, when G1 collects live objects from mixed collections, it can do
    so in an incremental manner, so that it doesn't exceed the maximum pause timings.
    This process splits the collection set into mandatory and optional parts. After
    G1 completes collecting live objects from the mandatory collection, it collects
    objects from the optional set, if time permits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JDK 12 时，当 G1 从混合集合中收集活动对象时，它可以以增量方式执行，这样就不会超过最大暂停时间。这个过程将集合集分为强制性和可选性部分。在
    G1 完成从强制性集合收集活动对象后，如果时间允许，它将收集可选集合中的对象。
- en: Promptly return unused committed memory from G1
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 G1 中及时返回未使用的已提交内存
- en: An additional enhancement to G1 GC—to return the Java heap memory to the **Operating
    System** (**OS**) when idle. This enhancement is most likely to be triggered by
    the increase in container environments that are used to run applications on the
    JVM.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC 的一个附加增强功能——在空闲时将 Java 堆内存返回到 **操作系统**（**OS**）。这个增强功能最有可能由用于在 JVM 上运行应用程序的容器环境数量的增加而触发。
- en: Prior to Java 12, G1 returned memory from the Java heap in two cases—while performing
    a full GC or during a concurrent cycle. However, neither of these instances happen
    very often. In fact, G1 performs a full GC as its last resort to free up memory.
    A concurrent cycle is subjected to the Java heap allocation and occupancy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 12 之前，G1 在两种情况下从 Java 堆中返回内存——在执行完全 GC 或在并发周期期间。然而，这两种情况都不太常见。实际上，G1
    将完全 GC 作为其最后手段来释放内存。并发周期受到 Java 堆分配和占用的影响。
- en: This GC behavior has multiple disadvantages—organizations pay more for the memory
    even though it isn't used in an efficient manner in container environments, and
    service providers under-utilize their resources. In this enhancement, the JVM
    determines the *idle* times for an application and returns the memory to the OS.
    This makes a lot of sense since the usage of applications isn't the same across
    the days of the week or even hours of a day. This enhancement can save organizations
    a lot of money when deploying their application to environments that provide resources
    as a service.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 GC 行为具有多个缺点——即使在容器环境中以高效的方式使用内存，组织也需要为内存支付更多费用，并且服务提供商未能充分利用其资源。在这个增强功能中，JVM
    确定应用程序的 *空闲* 时间并将内存返回给操作系统。这很有意义，因为应用程序的使用在每周的每一天或每天的每个小时都是不同的。当组织将应用程序部署到提供资源作为服务的环境中时，这个增强功能可以节省组织大量的费用。
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we browsed through the various additions and modifications
    to JDK 12, barring one of its preview language features of `switch` expressions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们浏览了 JDK 12 的各种新增和修改，但排除了其预览语言特性之一的 `switch` 表达式。
- en: The features covered in this chapter were mostly related to the JDK and its implementation.
    We covered one of the newest additions to the growing GC family—Shenandoah. A
    concurrent GC, Shenandoah promises ultra-low pause times for modern Java applications,
    irrespective of their memory sizes. The other two GC features mentioned—abortable
    mixed collections for G1 and promptly return unused committed memory from G1—also
    enhance the existing G1 GC.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中涵盖的功能大多与 JDK 及其实现相关。我们涵盖了增长中的 GC 家族中最新添加的一个——Shenandoah。Shenandoah 是一个并发
    GC，它承诺为现代 Java 应用程序提供超低暂停时间，无论其内存大小如何。提到的其他两个 GC 功能——G1 的可中止混合集合和从 G1 中及时返回未使用的已提交内存——也增强了现有的
    G1 GC。
- en: The JVM constants API introduces a new package and classes to represent class
    constraints symbolically. Apart from easing its usage across libraries and classes,
    the JVM constant API will standardize the constants. Default CDS archives improve
    the process of the creation of archive files. The removal of the source for an
    AArch64 ARM port is more related to housekeeping.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 常量 API 引入了一个新的包和类来以符号方式表示类约束。除了简化其在库和类之间的使用外，JVM 常量 API 还将标准化常量。默认 CDS 存档提高了存档文件创建的过程。移除
    AArch64 ARM 端口的源代码更多与维护相关。
- en: In the next chapter, we will look into the details and features of Project Amber.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解Project Amber的细节和特性。
