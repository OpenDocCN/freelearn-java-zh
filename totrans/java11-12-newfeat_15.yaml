- en: Miscellaneous Improvements in JDK 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 12 is the latest **Short Term Support** (**STS**) release by Oracle. However,
    the industry is still warming to migrating to the latest **Long-Term-Support** (**LTS**)
    Java release by Oracle, that is, Java 11.
  prefs: []
  type: TYPE_NORMAL
- en: The notable features in JDK 12 are the addition of Shenandoah GC and `switch`
    expressions. We covered `switch` expressions in [Chapter 11](7d0cca79-35c9-4912-9414-12db320d684d.xhtml),
    *Switch Expressions*. Since a detailed coverage of Shenandoah GC is beyond the
    scope of this book, I'm covering it in this chapter with the remaining additions
    and updates to Java 12.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Shenandoah—a low-pause-time GC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microbenchmark suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Java Virtual Machine** (**JVM**) Constants API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One AArch64 port, not two
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default CDS archives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abortable mixed collections for G1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promptly return unused committed memory from G1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the features that are included in this chapter, you should have JDK 12
    or a later version on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Since this chapter covers multiple features in Java 12, let's quickly map the
    features with their **JDK Enhancement Proposal** (**JEP**) number and scope.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping features of JDK 12 scope and JEP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table lists the JDK 12 features covered in this chapter, their
    corresponding JEP number, and their scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JEP** | **Scope** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 189 | Implementation | Shenandoah—a low-pause-time GC |'
  prefs: []
  type: TYPE_TB
- en: '| 230 | JDK | The microbenchmark suite |'
  prefs: []
  type: TYPE_TB
- en: '| 334 | SE | The JVM constants API |'
  prefs: []
  type: TYPE_TB
- en: '| 340 | JDK | One AArch64 port, not two |'
  prefs: []
  type: TYPE_TB
- en: '| 341 | JDK | Default CDS archives |'
  prefs: []
  type: TYPE_TB
- en: '| 344 | Implementation | Abortable mixed collections for G1 |'
  prefs: []
  type: TYPE_TB
- en: '| 346 | Implementation | Promptly return unused committed memory from G1 |'
  prefs: []
  type: TYPE_TB
- en: Let's get started with the first feature.
  prefs: []
  type: TYPE_NORMAL
- en: Shenandoah – a low-pause-time GC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proposed and developed by engineers at Red Hat, Shenandoah GC promises significantly
    low pauses. It is a region-based GC that collects garbage in a parallel and concurrent
    manner. It is interesting to note that the pause times are independent of the
    application's live data.
  prefs: []
  type: TYPE_NORMAL
- en: 'With hardware engineering and lower costs, servers have more memory and processing
    power than ever before. Modern applications are increasingly demanding lower pause
    times—with **Service Level Agreement** (**SLA**) applications that guarantee response
    times of 10 to 500 ms. To meet the lower end of this range, a GC should be able
    to accomplish multiple tasks, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use algorithms that enable programs to execute with the given memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the pause times low (that is, below 10 ms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is this attainable with, say, a Java application that uses 200 GB memory? This
    isn't possible with the compacting algorithms, which will exceed the limit of
    10 ms, even for compacting 10% of this memory. Shenandoah uses an algorithm that
    compacts the memory concurrently while the Java threads are running. In this case,
    objects are moved during a concurrent GC cycle and all of its references immediately
    access the newer copy.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent compaction isn't simple. When GC moves a live object, it must **atomically**
    update all references to the object, pointing to the new object. However, to find
    all of the references, the entire heap should be scanned; this sounds infeasible.
    To get around this, the Shenandoah GC adds a **forwarding pointer** to each object,
    with each use of that object going through that pointer. This simplifies the process
    of moving around objects. The Shenandoah GC thread or application thread can copy
    an object and use compare and swap to update the forwarding pointer. In case of
    contention, only one compare and swap will succeed. With the addition of the forwarding
    pointer, Shenandoah GC uses more space than other GC algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Each Shenandoah GC cycle consists of four phases. A Shenandoah GC cycle begins
    with **Initial Marking**, in which it *stops the world* and scans the root set.
    In phase two, that is, **Concurrent Marking**, it marks the live objects and updates
    references, concurrently. In the third phase, **Final Marking**, it *stops the
    world* and scans the root set again, copying and updating roots to updated copies.
    The last phase, **Concurrent Compaction**, evacuates live objects from the targeted
    regions.
  prefs: []
  type: TYPE_NORMAL
- en: Shenandoah is a region-based GC. It isn't a generational GC that focuses on
    collecting the youngest objects. This is based on the hypothesis that most objects
    die young. However, applications with caches hold on to the objects long enough,
    and so generational GC algorithms don't work with them. To get around this, Shenandoah
    uses the **Least Recently Used** (**LRU**) cache benchmark that enables it to
    keep its pause time low.
  prefs: []
  type: TYPE_NORMAL
- en: Shenandoah never compacts humongous objects (that is, objects that can't fit
    in one region and require multiple regions). If the Shenandoah GC cycle determines
    that a humongous object is no longer live, its region is immediately reclaimed.
  prefs: []
  type: TYPE_NORMAL
- en: The main target of Shenandoah GC is to increase the responsiveness of the JVM
    by lowering the count and duration of GC cycles.
  prefs: []
  type: TYPE_NORMAL
- en: The microbenchmark suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on **Java Microbenchmark Harness** (**JMH**), this feature adds a basic
    suite of microbenchmarks to the JDK source code, with the following proposed directory
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since the microbenchmark suite will be located with the JDK source code, it
    will make it simpler for developers to locate and run existing microbenchmarks,
    and create new ones. As existing features are updated or removed from a JDK version,
    it will be simple to update a microbenchmark. Also, when developers run a microbenchmark
    they can use JMH's powerful filtering to run selected benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Although the microbenchmark suite and its building will be integrated with JDK
    and its build system, it will have a separate target. Developers will need to
    specify additional parameters to execute it to keep the build time for normal
    JDK low.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, with benchmarking you can compare builds or releases.
    Hence, the microbenchmarks support JDK (*N*) for the new JDK and JDK (*N-1*) for
    the previous release. The benchmarks depend on JMH in the same way that unit tests
    depend on TestNG or `jtreg`. JMH is used during the build process and is packaged
    as part of the resulting JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM constants API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This JEP introduces an API to standardize the description and loading of class
    constants.
  prefs: []
  type: TYPE_NORMAL
- en: Every Java class has a constant pool. It either stores simple values such as
    strings and integers or values to represent classes or methods. Class constant
    pool values are used as operand values for the **ldc** (**load constant**) bytecode
    instruction. These constants can also be used by the **invokedynamic** bytecode instruction—in
    the static argument list of a bootstrap method.
  prefs: []
  type: TYPE_NORMAL
- en: When either an ldc or invokedynamic instruction executes, it represents the
    constant value as a Java data type value, a class, an integer, or a string. Until
    now, the responsibility of modeling bytecode instructions and loading constants
    was on the class that wanted to manipulate class files. This usually takes the
    focus of these classes off their business logic, moving it to the specifics of
    how to model bytecode instructions and load class constants. This is clearly a
    good candidate to separate the concerns and define the API to work with the *how*
    part.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it isn't easy for classes to implement this functionality by themselves,
    because loading class constants isn't a simple process for non-string and non-integer
    values. Class loading is a complex process and has multiple points of failure.
    Class loading is dependent on the host environment, including the existence of
    classes, the ability to gain access to them, and their relevant permissions. Class
    loading could also fail during the linking process.
  prefs: []
  type: TYPE_NORMAL
- en: An absence of a standardized library to handle these functions of loading constants
    also results in mismatched expectations between programs.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 12 defines a new package, `java.lang.invoke.constant`, which defines a family
    of value-based symbolic reference types. It can be used to describe all types
    of loadable constants. A symbolic constant uses a nominal form and essentially
    excludes a constant from its loading or accessibility context. The package includes
    types such as `ClassDesc`, `MethodTypeDesc`, `MethodHandleDesc`, and `DynamicConstantDes`
    to describe various constants. Data types such as `String`, `Integer`, `Long`,
    `Float`, and `Double` are also used to represent simple class constants.
  prefs: []
  type: TYPE_NORMAL
- en: There are varied use cases of this package. Libraries that parse or generate
    bytecodes need to describe classes and method handles in a symbolic manner. Bootstraps
    for invokedynamic will get simpler because they will be able to work with symbolic
    representation, rather than working with live classes and method handles. It will
    be simpler for the compiler and offline transformers to describe classes and their
    members, which can't be loaded into the running **Virtual Machine** (**VM**).
    Compiler plugins, such as annotation processors, also need to describe uses classes
    and their members in symbolic terms.
  prefs: []
  type: TYPE_NORMAL
- en: One AArch64 port, not two
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until version 12, JDK had two 64-bit ARM ports, even though both produce an
    AArch64 implementation. As a maintenance feature, this JEP removes all sources
    related to the 64-bit 64-bit ARM platform and retains the 64-bit ARM AArch64 port.
    It will prevent the duplication of work to maintain two ports. As part of the
    process, the option to build this port will also be removed from JDK. It will
    also validate that the 32-bit ARM port continues to work as expected and that
    it isn't affected by these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Default CDS archives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the enhancements to CDS archives with JDK 12, let's quickly recap
    what CDS is and how it impacts your applications. I covered this briefly in [Chapter
    2](210b06d5-c434-43dd-90a7-23c1d83d69bf.xhtml), *AppCDS*.
  prefs: []
  type: TYPE_NORMAL
- en: What is CDS?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A commercial feature with Oracle JVM since Java 8, CDS helps to reduce the start
    up time of a Java application and its memory footprint. This is especially notable
    when you are working with multiple JVMs.
  prefs: []
  type: TYPE_NORMAL
- en: On startup, JVM prepares the environment for execution. It includes bytecode
    loading, verification, linking, and initializing of the core classes and interfaces.
    The classes and interfaces are combed into the runtime state of the JVM so that
    they can be executed. It also includes method areas and constant pools.
  prefs: []
  type: TYPE_NORMAL
- en: These set of core classes and interfaces don't change unless you update your
    JVM. So, every time you start your JVM, it performs the *same* steps to get the
    environment up for execution. Imagine that you could dump the result to a file,
    which could be read by your JVM at startup. The subsequent startups could get
    the environment up and running without performing the intermediate steps of loading,
    verification, linking, and initialization; welcome to CDS.
  prefs: []
  type: TYPE_NORMAL
- en: When you install JRE, CDS creates a shared archive file from a predefined set
    of classes from the system JAR file. Classes are verified by the class loaders
    before they can be used and this process applies to all of the classes. To speed
    up this process, the installation process loads these classes into an internal
    representation and then dumps that representation to `classes.jsa`—the shared
    archive file. When the JVM starts or restarts, the shared archive file is memory
    mapped to save the loading of those classes.
  prefs: []
  type: TYPE_NORMAL
- en: When the JVM's metadata is shared among multiple JVM processes, it results in
    a smaller memory footprint. Loading classes from a populated cache are faster
    than loading them from the disk; they are also partially verified. This feature
    is also beneficial for Java applications that start new JVM instances.
  prefs: []
  type: TYPE_NORMAL
- en: Using CDS archives have reportedly resulted in the reduction of the application
    start up time by more than 30% on basic programs such as `HelloWorld` with JDK
    11\. This number is even higher on numerous 64-bit platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing CDS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, developers end up not using a feature that could enhance the performance
    of their application—out of ignorance—by just missing a step. Or should we call
    it a usability issue?
  prefs: []
  type: TYPE_NORMAL
- en: 'At present, even though the JDK includes a default class list, it can be used
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Even though this behavior is documented, developers miss reading the document,
    and hence, can't use this feature.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 12 modifies the build process. It runs the `java -Xshare:dump` command after
    linking it to the class list. To ensure that the CDS archive file is part of the
    JDK image, the shared archive file is placed in the `lib/server` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The shared archive file is used **automatically** during application startup,
    since `-Xshare:auto` is the default option with the server VM in JDK 11\. So,
    unless it is specifically turned off using the `-Xshare:off` option, developers
    and applications will continue using it without executing any additional commands
    or set up.
  prefs: []
  type: TYPE_NORMAL
- en: CDS includes a predefined list of classes and interfaces from the core Java
    API. For the inclusion of specific API or application classes, or for specific
    GC behavior, developers can create and use a custom archive file.
  prefs: []
  type: TYPE_NORMAL
- en: Abortable mixed collections for G1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers are increasingly demanding more definite behavior from GCs. For instance,
    wouldn't you prefer to execute your application with a GC that guarantees an upper
    limit to its pause timings?
  prefs: []
  type: TYPE_NORMAL
- en: When working with G1 GC in Java 12, you can abort *mixed collections* if they
    exceed your specified limit. Note that you can't abort *all* categories of G1
    GC pauses.
  prefs: []
  type: TYPE_NORMAL
- en: A mixed collection includes both *young* and *old* memory regions for G1 to
    clean. An analysis system selects the set of regions, collectively called a **collection
    set**, for G1 GC to work on. Prior to JDK 12, G1 GC could exceed the maximum pause
    time when the collection set was too large, the collection set included too many
    old regions, or the collection set included regions with *stale* data.
  prefs: []
  type: TYPE_NORMAL
- en: With JDK 12, when G1 collects live objects from mixed collections, it can do
    so in an incremental manner, so that it doesn't exceed the maximum pause timings.
    This process splits the collection set into mandatory and optional parts. After
    G1 completes collecting live objects from the mandatory collection, it collects
    objects from the optional set, if time permits.
  prefs: []
  type: TYPE_NORMAL
- en: Promptly return unused committed memory from G1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An additional enhancement to G1 GC—to return the Java heap memory to the **Operating
    System** (**OS**) when idle. This enhancement is most likely to be triggered by
    the increase in container environments that are used to run applications on the
    JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Java 12, G1 returned memory from the Java heap in two cases—while performing
    a full GC or during a concurrent cycle. However, neither of these instances happen
    very often. In fact, G1 performs a full GC as its last resort to free up memory.
    A concurrent cycle is subjected to the Java heap allocation and occupancy.
  prefs: []
  type: TYPE_NORMAL
- en: This GC behavior has multiple disadvantages—organizations pay more for the memory
    even though it isn't used in an efficient manner in container environments, and
    service providers under-utilize their resources. In this enhancement, the JVM
    determines the *idle* times for an application and returns the memory to the OS.
    This makes a lot of sense since the usage of applications isn't the same across
    the days of the week or even hours of a day. This enhancement can save organizations
    a lot of money when deploying their application to environments that provide resources
    as a service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we browsed through the various additions and modifications
    to JDK 12, barring one of its preview language features of `switch` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The features covered in this chapter were mostly related to the JDK and its implementation.
    We covered one of the newest additions to the growing GC family—Shenandoah. A
    concurrent GC, Shenandoah promises ultra-low pause times for modern Java applications,
    irrespective of their memory sizes. The other two GC features mentioned—abortable
    mixed collections for G1 and promptly return unused committed memory from G1—also
    enhance the existing G1 GC.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM constants API introduces a new package and classes to represent class
    constraints symbolically. Apart from easing its usage across libraries and classes,
    the JVM constant API will standardize the constants. Default CDS archives improve
    the process of the creation of archive files. The removal of the source for an
    AArch64 ARM port is more related to housekeeping.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into the details and features of Project Amber.
  prefs: []
  type: TYPE_NORMAL
