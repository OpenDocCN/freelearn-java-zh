<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building a Reactive Web Application</h1>
                </header>
            
            <article>
                
<p class="mce-root">We began our journey by exploring some of the basics of the Spring Framework and its module system in <a href="87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml">Chapter 1</a>, <em>Creating an Application to List World Countries with their GDP</em>. Let's leave all the new and advanced topics of Spring Framework for now and, in this chapter, look at one of the most popular topics: how to make highly scalable and responsive applications by adopting a reactive paradigm. </p>
<p>The world of technology is migrating from blocking, synchronous, and thread-driven implementation to non-blocking, asynchronous, and event-based systems, which are <span>resilient and </span>capable of managing a very large volume of data with a consistent response time. This is the core concern addressed by a reactive system.</p>
<p>From the perspective of the programming model, Reactive Programming has influenced the paradigm shift from an imperative style to a declarative composition of asynchronous logic. Spring Framework did this by incorporating Reactive Streams capabilities into its core framework from version 5.</p>
<p><span>In this chapter, we will discuss and explore Reactive Programming from various dimensions and angles with the following exciting topics:</span></p>
<ul>
<li>What is a reactive system</li>
<li>Introduction to Reactive programming</li>
<li>Reactive Programming basics, benefits, and features</li>
<li>Reactive Programming in Java</li>
<li>Introduction to WebFlux</li>
<li>Spring supports for Reactive Programming</li>
<li>A functional way of working in Reactive Programming with WebFlux </li>
<li>WebSocket support in a reactive paradigm</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>All the code used in this chapter can be downloaded from the following GitHub link: <a href="https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter02">https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter02</a>. The code can be executed on any operating system, although it has only been tested on Windows.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive system</h1>
                </header>
            
            <article>
                
<p>The word reactive has become popular today and has different meanings for different people, such as lightweight, real time, <span>asynchronous, </span>streaming, and so on. <strong>Reactive</strong>, in broader terms, refers to a set of design techniques or principles, and is a way to consider the system architecture in a distributed environment. It comprises tooling, design methodologies, and implementation procedures. </p>
<p>The analogy of a team can be used to describe a reactive system: individual players working with each other to achieve a desired goal. The interaction between the components is the main quality that differentiates a Reactive System from other systems. Components can operate individually or still work in harmony with others to achieve the intended result as a whole system. In other words, it is the system design that allows individual sub-applications to form a single logical system, perform specific tasks, and remain aware of each other. This enables decision-making, like load balancing, scaling up and down, failover mitigation, and so on.</p>
<p><span>While talking about reactive topics, mainly in the context of software design and development, people generally use the terms <strong>Reactive System</strong> and <strong>Reactive Programming</strong> interchangeably, although they are not exactly the same. A reactive system is message-driven and associated with distributed process communication over the network, whereas Reactive Programming is generally event driven and handled locally.</span></p>
<p>A Reactive System is considered to be the same as an asynchronous message-based system by many software engineers. But as per the reactive manifesto, the Reactive System is an architectural way of developing a distributed system in a responsive style. It has the following essential characteristics:</p>
<ul>
<li><strong>Responsive:</strong> It suggests a system should process and respond to a request in a reasonable time.</li>
</ul>
<ul>
<li><strong>Resilient:</strong> It suggests that even in case of failure, the system should remain responsive. In short, any kind of error should not put a system in a non-responsive state. All possible factors that may cause a system error must be well handled without causing a system halt.</li>
<li><strong>Elastic:</strong> A system should stay responsive even with a variable load. It should be flexible to scale up and down based on the load, and handle it with reasonable resource usage. To achieve this, the application must be designed in a way to avoid any central bottleneck.</li>
<li><strong>Message-driven:</strong> Components within a Reactive System should interact with each other with asynchronous message passing. This brings a loose coupling between components, isolation in responsibility, and transparency in location.</li>
</ul>
<p>Among these characteristics, responsiveness, resilience, and elasticity are the standard requirements for almost every real-world application today. They look simple and straightforward, but are tricky to implement. It is the message-driven requirement that distinguishes a responsive system from others.</p>
<p>A Reactive System uses an asynchronous message-passing mechanism to interact among components. It also furnishes a non-blocking mechanism to control the data flow. While building a Reactive System, at all relevant points, the data processing operations are composed as stream flows. In short, a Reactive System is focused on stream processing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Programming</h1>
                </header>
            
            <article>
                
<p>Reactive Programming can be used to build a Reactive System. By definition, <strong>Reactive Programming</strong> is a programming practice or pattern that is aligned around the data flow and the propagation of the changes. The changes in data are automatically propagated by the underlying execution model through the data flow. </p>
<p>To make it simple, Reactive Programming is a way to handle asynchronous data streams in a more effective manner. In other words, it is programming dealing with an asynchronous data stream, or it can be called the subset of asynchronous programming. Reactive Programming is a way of execution where new information will push the flow forward, rather than having the <span>flow</span> controlled by an execution thread.</p>
<p>The data stream is a series of business events that happen during the system execution, such as various keyboard or mouse events, HTML field changes, HTTP requests, notification, REST API data fetch, triggering validations, changing of web component state, data updates, or anything else that can cause a change in the data stream or alter a program behavior. </p>
<p>In short, Reactive Programming covers a dynamic reaction in the stream that is caused by the asynchronous data flow. When the changes happen in one component, a reactive library or framework will automatically propagate those changes to other components. It is quite possible to define a static order in which the changes are propagated.</p>
<p>The following diagram shows how Reactive Programming is different to imperative programming:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0706314d-9be6-4982-bbcf-c07d4b00c25e.png" style="width:40.75em;height:23.08em;"/></p>
<p>In <strong>imperative programming</strong>, the threads talk to each other in a synchronous way that results in blocking communication. A thread has to wait until the dependent thread of a resource is free, which can cause inefficient utilization and an easy bottleneck situation in the system. On the other hand, Reactive Programming doesn't need to wait; in fact, it is informed once the resource is available so that it can do other work in the meantime. This reduces the risk of the system hanging and makes it responsive. This effectively maintains smooth resource usage. </p>
<p>Reactive Programming suggests breaking down the given requirements into separate and individual steps that can be accomplished in an asynchronous, non-blocking style, and later on, combined to form a final output. In the Reactive Programming context, asynchronous means that the processing of a message or event occurs at some arbitrary time, most probably in the future.</p>
<p>The asynchronous and non-blocking nature of Reactive Programming is particularly useful in application environments where resources are shared; there is no need to halt the thread of execution while a resource is elsewhere engaged.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basics of Reactive Programming</h1>
                </header>
            
            <article>
                
<p>In a procedural programming model, a task is described as a series of actions executed in a sequential order. On the other hand, the Reactive Programming model facilitates the necessary arrangement to propagate the changes, which help in deciding what to do instead of how to do it. </p>
<p>Let's understand the concept with a very basic example, as follows:</p>
<pre>    int num1=3;<br/>    int num2=5;<br/>    int num3 = num1 + num2;<br/>    <br/>    System.out.println("Sum is --&gt;"+num3);<br/>    num1=6;<br/>    num2=8;<br/>    System.out.println("Sum is --&gt;"+num3);</pre>
<p>This is what we generally do in a procedural programming style. In this code, we are simply doing a summation of two numbers assigned to the third number and then printing it. In the next line, we are changing the value of the initial two numbers, but it doesn't update the third number. This is because <kbd>num1 + num2</kbd> is evaluated and assigned to <kbd>num3</kbd> on that line only. Now consider the same equation in an Excel sheet as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e8c00769-ab38-455b-98c9-8dcdc5d03102.png" style="width:32.50em;height:19.33em;"/></p>
<p>In this case, the changes of the <strong>E</strong> and <strong>F</strong> columns always listen to the <strong>G</strong> column. This is what Reactive Programming does. It propagates the changes to the one interested in those changes. </p>
<p>You might have used Reactive Programming unknowingly in your day-to-day coding practice. For example, if you have created a user registration screen where you validate the username entered by a user who is already present in the system, makes an Ajax call and shows an appropriate message saying <span class="packt_screen">This username is already used</span>.</p>
<p>Another example is the listener or callback function that you define with a mouse click or keystroke on the web page. In these cases, mouse click and focus out events (for username validation) can be considered as a stream of events that you can listen to and execute appropriate action or functions on.</p>
<p><span>This is just one usage of the event stream. </span>Reactive programming allows you to observe and react to any changes caused by the stream of events, like changes in a database, user input, property updates, data from external resources, and so on. Let's understand it by taking a real-life example. </p>
<p>Let's say you want to invest in mutual funds and there are many companies who provide facilities to invest on your behalf. They also produce statistics about the performance of various funds along with their history, market share, capital investment ratio, and so on. Based on this, they give some categories like moderate risk, low risk, moderately high risk, high risk, and so on. They also give a rating based on the performance of each fund.</p>
<p>The rating and the category will suggest that users choose a particular fund based on their requirement (short term, long term, and so on) and the type of risk they can afford. The changes happen in the rating and the category can be considered as an event (or data) stream that<span> will cause a system to change the suggestion to the user</span>. Another practical example of a data stream would be a social media feed, such as Facebook, Twitter, and so on.</p>
<p><strong>Function reactive</strong> is a paradigm of reacting to the data stream in a functional way, providing additional features such as filters, combine, buffers, maps, and lot others. Using them, you can perform certain operations on a data stream, which help it to react in a better way. Taking the previous <span>example of a </span>mutual fund, the filter function can be used to suggest only those funds that are safe for investment in a real-time manner. </p>
<p>Reactive Programming is mainly used to build an interactive user interface and other systems that need time interaction, such as graphical applications, animations, simulations, chatbots, and so on. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backpressure</h1>
                </header>
            
            <article>
                
<p>One of the important concepts that you should know about in Reactive Programming is backpressure.<span> It significantly improves Reactive Programming over the traditional code. </span><span>What exactly is it? I</span>t is considered as one of the non-blocking regulatory mechanisms used to send asynchronous messages or feedback to the source of a stream for load regulation. <span>Communication back to the stream sender could possibly be a request or alert to stop. However, it could also be about the receiver's intent to process more messages. The communication back to the sender has to be non-blocking. This is important.</span></p>
<p>Consider the situation where observables (source of an event) send out the data at a higher rate than the subscribers can actually handle. In this case, the subscribers would be in a stress condition, unable to handle the flow properly, and there is a high chance the system would behave unexpectedly. To avoid this situation, there must be some arrangement for conveying the speed at which the subscribers can consume the data, back to the observables.</p>
<p>The mechanism for notifying the source of the event saying,<span> </span><em>Hey, I am under pressure,</em> <em>so don't send a further message as I can consume X amount of messages at a particular time</em>,<span> </span>is called <strong>backpressure</strong>. <span>In the absence of this, the system may keep increasing the buffer size until it runs out of memory error. </span>Backpressure is required when emission happens at a faster rate than consumption. It will make sure the system remains resilient under the load and will provide information that is used to make the decision, whether the system needs additional resources or not. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits of Reactive Programming</h1>
                </header>
            
            <article>
                
<p>A few years ago, the user interaction was limited to just filling in the form on a web page and submitting it to the server. It was just enough for self-sufficient applications at the time. Today, in the era of the mobile and responsive requirement, a rich user interface showing real-time information is expected to provide wide interactive possibilities.</p>
<p>Also, different types of apps like cloud environments, distributed apps, IoT, and real-time applications need lots of user interaction. This can be achieved by Reactive Programming. It is used to build loosely coupled, responsive, and scalable applications that are more tolerant of failure. There are many advantages of using Reactive Programming, as follows:</p>
<ul>
<li><span><strong>Resource utilization:</strong> One of the essential benefits of Reactive Programming is optimizing hardware resource utilization, like the processor, memory, network, and so on. It also improves the performance by reducing serialization.</span></li>
</ul>
<ul>
<li><strong>Enhanced user experience:</strong> Reactive Programming provides better and improved user experience by using an asynchronous mechanism that makes the application smoother and responsive and easy to interact with.</li>
<li><strong>Consistency:</strong> You can design the API with lots more consistency for everything, including database call, frontend, network, computation, or anything else you may need with Reactive Programming.</li>
<li><strong>Handle with ease:</strong> Reactive Programming has first-class support and obvious mechanisms for asynchronous operations out of the box. Also, it makes handling UI interaction and event management easier.</li>
<li><strong>Simple thread management:</strong> Reactive Programming makes it simpler than regular threading mechanisms. Complex threading implementations, making the parallel work in a synchronous manner, and executing the callbacks when the function is done is easier to achieve with Reactive Programming.</li>
<li><strong>Increased developer productivity:</strong> In a typical imperative programming model, the developer has to do lots of work to maintain a straightforward approach to achieve an asynchronous and non-blocking computation. Reactive Programming, on the other hand, addresses the challenge by providing these features out of the box so the developer does not need explicit coordination between elements.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Programming techniques</h1>
                </header>
            
            <article>
                
<p>Reactive Programming is event-based in most cases. In Reactive Programming, the APIs are exposed in the following two flavors:</p>
<ul>
<li><strong>Callback:</strong> In this type, the anonymous routines are registered to event sources as callback functions. They will be invoked when the event is triggered by the data flow.</li>
<li><strong>Declarative:</strong> The events are observed through well-defined functional compositions, like a filter, map, and other stream-based operations, like count, trigger, and so on.</li>
</ul>
<p>Reactive Programming puts the importance on data flow rather than the flow of control, so it is not uncommon to consider it as a data flow programming. There are various techniques that are used to achieve Reactive Programming as follows:</p>
<ul>
<li><strong>Futures and promise:</strong> It is referred to as a technique to define the variable and assign its value. Though futures and promise are used interchangeably, they are not exactly the same. The future is used to describe a read-only view of a variable (or, say, define the variable), while the promise is a writable, single assignment container that is used to set the value of a variable in future. </li>
<li><strong>Reactive Streams:</strong> It is defined as a standard for the processing of asynchronous streams that enables non-blocking, backpressure transmutations between sources from where the events are initiated and the destination where they are observed.</li>
<li><strong>Data flow variables:</strong> It is a variable whose value depends on a given input, operations, and other cells, and is updated automatically when changes happen to source entities. You can think of a data flow variable as a spreadsheet cell, where a change in the value of one cell causes a ripple effect to others based on the assigned formula.</li>
</ul>
<p>In addition to this, there are various frontend libraries available, like React.js, AngularJS, Ractive.js, Node.js, and so on, which are used to develop reactive frontend applications. Other programming languages and frameworks providing native support for reactive applications are Scala, Clojure, and GoLang, along with Java 9 and Spring 5. We will see reactive features of Spring 5 later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Programming in Java</h1>
                </header>
            
            <article>
                
<p><span>An asynchronous processing approach is a perfect fit while dealing with a huge volume of data or a large set of users. It will make the system responsive and improve the overall user experience. Implementing asynchronous processing in Java with the custom code would be cumbersome and harder to implement. Reactive Programming would be beneficial in this scenario.</span></p>
<p>Java doesn't provide native support for Reactive Programming like other JVM-based programming languages such as Scala or Clojure do. However, from version 9, Java has started supporting Reactive Programming natively. Apart from native support in Java 9, there are other implementation layers that help to achieve Reactive Programming with an older version of Java (such as Java 8). We will see a few of them, as follows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Streams</h1>
                </header>
            
            <article>
                
<p>Reactive Streams is described simply as an initiative to provide a standard for asynchronous stream processing with non-blocking backpressure. It is a small and straightforward statement. However, it is essential to note that the first focus here is on the asynchronous stream processing and not just on the asynchronous programming. As discussed earlier, asynchronous systems have been around for a long time.</p>
<p>Before processing a stream, comes receiving the stream data. Asynchronously, this would mean managing the risk of uncertainties in the world of streams. For example, how much more data or messages could there be? Another challenge might be how to know when the stream has finished sending data. There could be a lot of questions, and we will see all of them in a little while<em>.</em></p>
<p><span>Reactive Streams is used to perform Reactive Programming in Java. It is an API specification or, say, low-level contract given by the collaborations of various companies like Pivotal, Netflix, Red Hat, Twitter, Lightbend (previously known as Typesafe), Kaazing, Oracle, and many more. You can consider the Reactive Streams API to be just like JPA or JDBC. The actual implementations are provided by various vendors.</span></p>
<p><span>For example, JPA specifications have various vendors like Hibernate, TopLink, Apache OpenJPA that provide actual implementation. Similarly, there are many popular JVM-based libraries that support Reactive Programming like Reactor, Akka stream, Ratpack, Vert.x, and so on. They all provide an implementation of the Reactive Streams specifications, which bring interchangeability.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Streams specifications</h1>
                </header>
            
            <article>
                
<p>Let's try to understand in more detail, what the specifications for Reactive Streams are. <span>It is dealing with the asynchronous processing of a stream. </span>Let’s look at the specification available at<span> </span><a href="https://github.com/reactive-streams/reactive-streams-jvm">https://github.com/reactive-streams/reactive-streams-jvm</a><span> </span>. It comprises the following two parts:</p>
<ul>
<li><strong>API</strong>: This describes the specification.</li>
<li><strong>Technology Compatibility Kit</strong><span> </span>(<strong>TCK</strong>): This <span>is a criteria or standard test suite for compliance testing of implementations. In short, it will make sure the given implementation conforms to the declared specification. </span></li>
</ul>
<p>Taking a closer look at the API, we find that it is rather simple and comprises just four interfaces as follows:</p>
<ul>
<li><strong>Publisher</strong>: This interface represents an entity that acts as a supplier of an unbounded number of sequenced events or elements. It will publish the elements as per the requirement of the subscriber.</li>
<li><strong>Subscriber:</strong> It represents a consumer of an event from a publisher. For that, it will subscribe to the publisher. </li>
<li><strong>Subscription:</strong> This interface illustrates the process of subscribing or registering of a subscriber to a publisher. </li>
</ul>
<ul>
<li><strong>Processor:</strong> It is a composition of both the publisher and subscriber. It represents a processing stage that implements the contract of both. </li>
</ul>
<p>Java 9 has started providing native support for Reactive Streams. The implementation of these interfaces is part of the Flow API in Java 9. Looking at the structure of JAR containing the Reactive Streams, we find the following structure:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/946a8436-aacd-43e4-9a11-d8b1498daa00.png" style="width:28.67em;height:22.42em;"/></div>
<p>This seems rather <span>straightforward, </span>and implementing a set of a few interfaces shouldn’t be a challenge for any developer in Java. Are we able to go to production with the implementation of these interfaces, and will it give us a stable system? Are we ready to get started with the reactive development? The answers are, <em>not quite yet</em>.</p>
<p><span>Passing the messages in an asynchronous way is the key area of focus for Reactive Streams. It ensures that it is not just the consumer that is protected from being overwhelmed by all the distributed systems. The Publisher is also safeguarded in case one or more subscribers is slow to process the messages. It primarily says that this is the way you should pass a message from thread <em>A</em> to thread <em>B</em> in a protected manner, to ensure both the</span><span> p</span>ublisher<span> </span><span>and the</span><span> s</span>ubscriber<span> </span><span>are protected.</span></p>
<p>Let’s dig further into the specifications, (we will come to the TCK a little later) and see how they correspond with the original statement of the Reactive Streams manifesto. Starting with the publisher, we see that the specifications also define a set of rules that must be adhered to by the implementer of the specifications.</p>
<p>The rules are defined for all the four interfaces: publisher, subscriber, subscription, and processor. It won’t be possible to go through all the rules here, and neither it is required, as the rules are available at:<span> </span><a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md">https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md</a><span> </span>.</p>
<p>However, in order to draw some relevance from the Reactive Streams manifesto, let’s look at some of the important rules. We will analyze one or two rules each from all four interfaces to help you understand how they are laid out. Do have a look at the glossary table before reading these rules and specifications.</p>
<p>You should have a look at the rest of the rules, as going through them will give you a good idea about how detailed the rules are. By the time you finish reading all the rules, you will have a very good grasp of what to expect from the implementation of Reactive Streams.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publisher rules</h1>
                </header>
            
            <article>
                
<p><kbd>Publisher</kbd> has the following interface definition:</p>
<pre>  public static interface Publisher&lt;T&gt; { <br/>       public void subscribe(Subscriber&lt;? super T&gt; subscriber); <br/>  }</pre>
<p>Rule number 1.1 says, the total number of <kbd>onNext</kbd><em> </em>signaled by a <kbd>Publisher</kbd> to <kbd>Subscriber</kbd> must be less than, or equal to, the total number of elements requested by that <kbd>Subscriber</kbd><em> </em>Subscription at all times<em>.</em> There are multiple facets to this definition here. Let’s try to analyze them one by one:</p>
<ul>
<li>First and foremost, there has to be a request for a message from<span> </span><kbd>Subscriber</kbd><span> (</span>total number <span>→ </span>1 - N) to<span> </span><kbd>Publisher</kbd>. Therefore,<span> </span><kbd>Publisher</kbd><em><span> </span></em>cannot start sending messages to unsuspecting subscribers on its own as these subscribers might still be deciding when to start receiving messages. Furthermore, some might still be performing some initial tasks in order to start receiving the message.</li>
<li>Secondly, only after the request is received by <kbd>Publisher</kbd> can it begin transmitting the messages to<span> </span><kbd>Subscriber</kbd>. In response to the request for messages from<span> </span><kbd>Publisher</kbd>, Subscriber receives<span> </span><kbd>Subscription</kbd>. Now<span> </span><kbd>Subscriber</kbd><em><span> </span></em>can use <kbd>Subscription</kbd> to interact with <kbd>Publisher</kbd> and vice versa. How many messages <kbd>Publisher</kbd> should send is mentioned in <kbd>Subscription</kbd> so the requested messages by <kbd>Subscribers</kbd> should be less than or equal to that number <kbd><span>[</span>message count<span> </span><span>&lt;=</span><span> </span>total number]</kbd><span>. </span></li>
<li>Thirdly,<span> </span><kbd>Publisher</kbd><span> </span>cannot send more messages to<span> </span><kbd>Subscriber</kbd><span> </span>than requested by <kbd>Subscriber</kbd>.</li>
</ul>
<p class="mce-root"/>
<p>These three points together form a part of the backpressure we mentioned when we began with Reactive Streams.</p>
<p>And yes, the count requested by <span> </span><kbd>Subscriber</kbd><span> </span>from<span> </span><kbd>Publisher</kbd><span> </span>is not binding on <kbd>Publisher</kbd><span> </span>as per the other rule, not binding with respect to the count of messages. <kbd>Publisher</kbd><span> </span>is allowed to send <span>less</span> than the requested count of messages from <kbd>Subscriber</kbd>. This can be described with the following.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscriber rules</h1>
                </header>
            
            <article>
                
<p><kbd>Subscriber</kbd> has the following interface definition:</p>
<pre>public interface Subscriber&lt;T&gt; {<br/>    public void onSubscribe(Subscription s);<br/>    public void onNext(T t);<br/>    public void onError(Throwable t);<br/>    public void onComplete();<br/>}</pre>
<p>Rule number 2.1 says, A <kbd>Subscriber</kbd> must signal demand via Subscription.request(long n) to receive <kbd>onNext</kbd> signals.<em> </em>This rule is in line with <kbd>Publisher</kbd> rule number 1.1 in the sense that it  establishes the responsibility of <kbd>Subscriber</kbd> to inform when and how many messages it is able and willing to receive.</p>
<p>Rule number 2.4 says, <kbd>.onComplete()</kbd> and <kbd>Subscriber.onError(Throwable t)</kbd> must consider the <kbd>Subscription</kbd> cancelled after having received the signal<em>.</em> Here again, the design intention at play is highlighted. The design sequence of sending ensures that the process of the message being sent from <kbd>Publisher</kbd> to <kbd>Subscriber</kbd> is completely decoupled. Therefore, <kbd>Publisher</kbd> is not bound by the <kbd>Subscriber</kbd> intent to keep listening, hence ensuring a non-blocking arrangement.</p>
<p>As soon as <kbd>Publisher</kbd> sends out a message, it has no messages to be sent with<span> </span><kbd>Subscriber.onComplete()</kbd><span> and </span>the <kbd>Subscription</kbd> object is no longer valid/available. This is similar to when an exception is thrown back with<span> </span><kbd>Subscriber.onError(Throwable t)</kbd><em>.</em><span> </span>The <kbd>Subscription</kbd> object can no longer be utilized by  <kbd>Subscriber</kbd> to request more messages.</p>
<p>It is worthwhile mentioning another couple of rules around the same design. These are rules number 2.9 and 2.10 concerning<span> </span><kbd>Subscription.request(long n)</kbd>. The rule says that a<span> </span><kbd>Subscriber</kbd><span> </span>can get the <kbd>onError</kbd> signal or the <kbd>onComplete</kbd> signal with or without a preceding call to<span> </span><kbd>Subscription.request(long n)</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscription rules</h1>
                </header>
            
            <article>
                
<p>The following interface describes the <kbd>Subscription</kbd> notation:</p>
<pre>public interface Subscription {<br/>    public void request(long n);<br/>    public void cancel();<br/>}</pre>
<p>The rule number 3.2 says, <kbd>Subscription</kbd> must allow the <kbd>Subscriber</kbd> to call <kbd>Subscription.request</kbd> synchronously from within <kbd>onNext</kbd> or <kbd>onSubscribe</kbd><em>.</em> It talks about preventing both <kbd>Publisher</kbd> and <kbd>Subscriber</kbd> by restricting posting of the message only when  <kbd>Publisher</kbd> gets the signal for a further request from <kbd>Subscriber</kbd>. This happens in a synchronous manner to avoid a stack overflow.</p>
<p>In a similar context, another rule, number 3.3, states, <kbd>Subscription.request()</kbd> must place an upper bound on possible synchronous recursion between <kbd>Publisher</kbd> and <kbd>Subscriber</kbd><em>.</em> It complements rule 3.2 in a sense by deciding an upper limit in the recursive interaction between <kbd>Publisher</kbd> and <kbd>Subscriber</kbd> in the form of the <kbd>onNext()</kbd> and <kbd>request()</kbd> call. Setting the upper limit will avoid blowing out when calling a thread stack. The rules starting from number 3.5 to 3.15 describe the behavior of cancelling and completing the request.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processor rules</h1>
                </header>
            
            <article>
                
<p><kbd>Processor</kbd> is described with the following interface definition:</p>
<pre>public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {<br/>}</pre>
<p>It has just two rules. The first rule talks about the contract that must be followed by both <kbd>Subscriber</kbd> and <kbd>Publisher</kbd> , while the second rule is intended to handle the error situation, either recover or propagate to <kbd>Subscriber</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Streams TCK</h1>
                </header>
            
            <article>
                
<p>Implementing the interfaces defined in Reactive Streams specification is not just suffice to build Reactive Streams. The specification comprises a set of components and rules. The components part is taken care of with four interfaces we discussed, while the rules are defined by Reactive Streams <strong>Technology Compatibility Kit</strong> (<strong>TCK</strong>).</p>
<p>The Reactive Streams TCK is a guideline to Reactive Streams implementors to verify their implementations against the rules defined in the specifications. The TCK is developed with a testing framework in Java called <strong>TestNG</strong> and can be used in other JVM-based programming languages, like Kotlin and Scala. </p>
<p>TCK covers most of the rules, but not all, defined in the specification because for some of the rules, it is not possible to construct automated test cases. So theoretically, it can't be verified fully against the specification; however, it is helpful to validate most of the important rules.</p>
<p>TCK comprises four TestNG test classes and contains test cases, which can be extended by <span>implementers </span>and provide their implementation of <kbd>Publisher</kbd>, <kbd>Subscriber</kbd>, <kbd>Subscription</kbd>, and <kbd>Processor</kbd> to validate against the specification rules. You can get it in further detail from the link: <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck">https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RxJava</h1>
                </header>
            
            <article>
                
<p>Starting with version 8, Java began supporting reactivity features as inbuilt capability, yet they were not used widely and didn't become popular among developers. However, some third party implementations of Reactive Programming in Java showed its advantages and it grew in popularity in the Java community.</p>
<p>There is nothing but the set of tools called <strong>Reactive Extension</strong> (or simply ReactiveX) allowing implementation of Reactive Programming <span>for composing asynchronous and event-based programs using observable sequences. It is a Java VM (Virtual Machine) implementation of Reactive Extension. </span><span>Initially written on Microsoft platforms,</span> Reactive Extension offers reactive capabilities to various other programming languages, and one of the most popular among them is RxJava for the Java programming language.</p>
<p>It was the first Reactive Extension API specific to the Java platform<em>. </em>RxJava is compatible with older versions of Java and provides a facility to write asynchronous, event-based programs for both Java and Android platforms, which is very convenient. <span>ReactiveX also covers other programming languages with Reactive Extension, like RxJs, Rx.Net, UnixRx, RxScala, RxCloujure, RxCPP, Rx.rb, and RxKotlin, along with other platforms and frameworks like RxCocoa, RxAndroid, and RxNetty. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Anatomy of RxJava </h1>
                </header>
            
            <article>
                
<p>RxJava basically extends the observer pattern to support iteration on the sequence of event/data and allows the forming of sequences at the same time as abstracting away the low-level details, like threading, synchronization, concurrency, and thread safety. </p>
<p>At the time of writing, the current version of RxJava-2.6 has a single dependency on Reactive Streams API and provides support for Java 6 and the later versions, along with Android 2.3+. Before going deep into RxJava, let's look at the basic building blocks of ReactiveX as follows:</p>
<ul>
<li><kbd>Observable</kbd>: It is  basically a data stream or in other words a source of data. It can emit the data just one time or periodically in a continuous manner, based on the configuration. <kbd>Observable</kbd> can send out specific data on particular events based on the operators used with <kbd>Observable</kbd>.  In short, <kbd>Observable</kbd> is the supplier of data to other components. </li>
<li><kbd>Observer</kbd>: The data stream emitted by <kbd>Observable</kbd> is consumed by Observers. For that, they need to subscribe to  <kbd>Observable</kbd> using the <kbd>subscribeOn()</kbd> method. One ore more observers can be subscribed to <kbd>Observable</kbd>. When  <kbd>Observable</kbd> sends the data, all registered observers receive the data with the <kbd>onNext()</kbd> callback method. Once the data is received, you can perform any operation on that. In case any error occurred during the transmission, observers will get the error data with the <kbd>onError()</kbd> callback.</li>
<li><kbd>Scheduler</kbd>:<strong> </strong>They are used for thread management to achieve asynchronous programming in ReactiveX. They will instruct <kbd>Observable</kbd> and <kbd>Observer</kbd> to choose particular thread on which they can execute the operations. For that, <kbd>Scheduler</kbd> provide the <kbd>observerOn()</kbd> and <kbd>scheduleOn()</kbd> methods for the <kbd>Observer</kbd> and <kbd>Observable</kbd> respectively.</li>
</ul>
<p>Let's understand these concepts with a practical example. We will create a Maven project in Eclipse with settings as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a177cf08-19f9-42db-af13-7b18e75118aa.png" style="width:33.33em;height:30.75em;"/></p>
<p>We need to give RxJava specific dependency. The current version at this moment is 2.2.6. After adding the dependency,  <kbd>pom.xml</kbd> should look as follows:</p>
<pre>&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br/>  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/>  &lt;groupId&gt;rx-java&lt;/groupId&gt;<br/>  &lt;artifactId&gt;simple-rx-java-demo&lt;/artifactId&gt;<br/>  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br/>  &lt;name&gt;Simple RxJava demo&lt;/name&gt;<br/>  &lt;dependencies&gt;<br/>    <strong>&lt;dependency&gt;</strong><br/><strong>      &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;</strong><br/><strong>      &lt;artifactId&gt;rxjava&lt;/artifactId&gt;</strong><br/><strong>      &lt;version&gt;2.2.6&lt;/version&gt;</strong><br/><strong>    &lt;/dependency&gt;</strong><br/>  &lt;/dependencies&gt;<br/>&lt;/project&gt;</pre>
<p>Create a new Java class with an appropriate package and add the following code to it:</p>
<pre>public class RxJavaBasics {<br/>  public static void main(String[] args) {<br/>    /* Observable */<br/>    Observable&lt;String&gt; adminUsers = <br/>        Observable.just("Dave", <br/>                "John", <br/>                "Nilang", <br/>                "Komal",<br/>                "David");<br/>    <br/>    /* Observer in form of lambda expression */<br/>    adminUsers.subscribe(s -&gt; System.out.println(s));<br/>  }<br/>}</pre>
<p>The <kbd>adminUsers</kbd> instance is of type <kbd>Observable&lt;String&gt;</kbd> that pushes five strings literals (name of admin users), which is essentially a data stream or the source of data. For simplicity, we have taken String Literals, but <kbd>Observable</kbd> can push the data or events from any source, such as a database query result, social media feed, REST API response, or anything similar.<br/>
The <kbd>Observable.just()</kbd> method is used to emit a fixed set of string literals. The last line of the code describes how the <kbd>Observer</kbd> can subscribe to <kbd>Observable</kbd> with the <kbd>subscribe()</kbd> method. It is defined as a lambda expression that specifies what to do with the string it receives from <kbd>Observable</kbd>. This relation can be described in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cd64d3e2-a436-40b8-bf0c-6115074fbd17.png" style="width:44.50em;height:19.08em;"/></p>
<p class="mce-root"/>
<p>In this code, <kbd>Observer</kbd> is simply printing the string literal. RxJava provides several operators that can be used in between <kbd>Observable</kbd> and <kbd>Observer</kbd><em>.</em> These operators are used to transform or manipulate each pushed data passed in between. Each operator processes the data coming from previous <kbd>Observable</kbd> and returns new <kbd>Observable</kbd>. Let's use one of the operators called <kbd>map</kbd> and update the code as follows:</p>
<pre>adminUsers.map(s-&gt;s.startsWith("D") ? s:"*******")<br/>                .subscribe(s -&gt; System.out.println(s));</pre>
<p>In this code, the data emitted by the <kbd>adminUsers</kbd> observable is passed through a map operator before being sent to <kbd>Observer</kbd>. The <kbd>map</kbd> operator here provides a lambda expression, which is used to process the submitted data from <kbd>adminUsers</kbd>. It basically prints the return string if it starts with <kbd>D</kbd> or else simply returns a string with an asterisk mark (<kbd>*</kbd>). The  <kbd>map</kbd> operator returns new <kbd>Observable</kbd> that returns the data processed by the <kbd>map</kbd> operator and finally sends it to <kbd>Observer</kbd>. You will see the output, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5d72c518-2035-4803-a37e-fd3542deda26.png" style="width:5.50em;height:6.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observer event calls</h1>
                </header>
            
            <article>
                
<p>What we discussed so far is very high-level information about how we can use <kbd>Observable</kbd> in RxJava. It basically pushes (emits) the items (data or events) of a given type through a series of operators (if defined) until it reaches  <kbd>Observer</kbd>. Let's dig into more details to understand which mechanism works under the hood between this interaction and how RxJava complies with Reactive Streams specifications.</p>
<p><kbd>Observable</kbd> interacts with <kbd>Observers</kbd> through the following event calls:</p>
<ul>
<li><kbd>onNext</kbd>: This is the call from where data/events are being sent, one at a time, down to all registered <kbd>Observers</kbd>.</li>
<li><kbd>onComplete</kbd>: This event is used to signal completion of communication to all. </li>
<li> <kbd>Observers</kbd>: It simply denotes no more <kbd>onNext</kbd> calls happen.</li>
<li><kbd>onError</kbd>: In case any error occurs before an <kbd>onComplete()</kbd> call, an <kbd>onError()</kbd> event is used to signal the error from <kbd>Observable</kbd> to <kbd>Observers</kbd>. <kbd>Observable</kbd> will stop emitting the data and <kbd>Observers</kbd> will handle the error.</li>
</ul>
<p>These events are defined as an <kbd>abstract</kbd> method in the <kbd>Observer</kbd> type, and we will see the implementation type later in this chapter. First let's see how these event calls happen during the interaction with the following code:</p>
<pre>public class RxJavaCreateDemo {<br/><br/>  public static void main(String[] args) {<br/>    Observable&lt;String&gt; daysOfWeek = Observable.create(<br/>        sourceEmitter -&gt; {<br/>        try {<br/>          sourceEmitter.onNext("Sunday");<br/>          sourceEmitter.onNext("Monday");<br/>          sourceEmitter.onNext("Tuesday");<br/>          sourceEmitter.onNext("Wednesday");<br/>          sourceEmitter.onNext("Thursday");<br/>          sourceEmitter.onNext("Friday");<br/>          sourceEmitter.onNext("Saturday");<br/>          sourceEmitter.onComplete();<br/>         }catch(Exception e) {<br/>            sourceEmitter.onError(e);<br/>         }<br/>      });<br/>    Observable&lt;String&gt; daysInUpperCase= daysOfWeek.map(day-&gt;day.toUpperCase())<br/>                                             .filter(day-&gt;day.startsWith("S"));<br/>    daysInUpperCase.subscribe(day-&gt;System.out.println("Day is --&gt;"+day));<br/>  }<br/>}</pre>
<p> <kbd>Observable.create()</kbd> is a factory method and used to create <kbd>Observable</kbd> with the emitter. The <kbd>onNext()</kbd> method of the emitter is used to emit (send) the data/events (one at a time) to the <kbd>Observable</kbd> chain (and finally to registered <kbd>Observers</kbd>). The <kbd>onComplete()</kbd> method is used to terminate further communication.</p>
<p>If you try to make an <kbd>onNext()</kbd> call after <kbd>onComplete()</kbd>, the data will not be transmitted. In case any error occurs, the <kbd>onError()</kbd> method is called. It is used to push up the error to the <kbd>Observable</kbd> chain where it is handled by <kbd>Observer</kbd>. In this code, there is no chance of any exception, but you can handle any error with <kbd>onError()</kbd>.</p>
<p>We have used the <kbd>map</kbd> and <kbd>filter</kbd> operators to refine the data to uppercase and starting with <kbd>D</kbd> respectively. Finally, they are printed by <kbd>Observer</kbd>. The flow of data will happen from <kbd>onNext()</kbd> →<kbd>map</kbd>→<kbd>filter</kbd>→<kbd>Observer</kbd>.  Each operator will return new <kbd>Observable</kbd> class in the chain. </p>
<p>You notice that in the first example we used the <kbd>Observable.just()</kbd> method to emit the data. It internally invokes the <kbd>onNext()</kbd> method for each of the values pushed. On getting the last value, it will call <kbd>onComplete()</kbd>. So <kbd>Observable.just()</kbd> is equivalent to <kbd>Observable.create()</kbd> calling <kbd>onNext()</kbd> on each data and <kbd>onComplete()</kbd> on last one. The <kbd>create()</kbd> method is generally used for sources that are not reactive in nature. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable for iterators</h1>
                </header>
            
            <article>
                
<p><kbd>Observable</kbd> provides support to emit the data from any iterable sources, for example, lists, maps, sets, and so on. It will call <kbd>onNext()</kbd> on each item of an iterable type, and once the iterator is over, it will call <kbd>onComplete()</kbd> <span>automatically. Iterable in Java is commonly used in collection frameworks, so <kbd>Observable</kbd> with iterable can be used while fetching data from collection classes.</span></p>
<p><span>Let's see how to use it as follows:</span></p>
<pre>public class RxJavaIterableDemo {<br/>  public static void main(String[] args) {<br/>    List&lt;EmployeeRating&gt; employeeList = new ArrayList&lt;EmployeeRating&gt;();<br/>    EmployeeRating employeeRating1 = new EmployeeRating();<br/>    employeeRating1.setName("Lilly");<br/>    employeeRating1.setRating(6);<br/>    employeeList.add(employeeRating1);<br/><br/>    employeeRating1 = new EmployeeRating();<br/>    employeeRating1.setName("Peter");<br/>    employeeRating1.setRating(5);<br/>    employeeList.add(employeeRating1);<br/><br/>    employeeRating1 = new EmployeeRating();<br/>    employeeRating1.setName("Bhakti");<br/>    employeeRating1.setRating(9);<br/>    employeeList.add(employeeRating1);<br/><br/>    employeeRating1 = new EmployeeRating();<br/>    employeeRating1.setName("Harmi");<br/>    employeeRating1.setRating(9);<br/>    employeeList.add(employeeRating1);<br/><br/>    Observable&lt;EmployeeRating&gt; employeeRatingSource = <br/>                                Observable.fromIterable(employeeList);<br/><br/>    employeeRatingSource.filter(employeeRating -&gt; <br/>                employeeRating.getRating() &gt;=7).subscribe(empRating -&gt; <br/>                System.out.println("Star Employee: " + empRating.getName() <br/>                + " Rating : "+empRating.getRating()));<br/>  }<br/>}</pre>
<p>We are populating the list of <kbd>EmployeeRating</kbd> and creating <kbd>Observable</kbd> with the<kbd>fromIterable()</kbd> method by passing this list. The class <kbd>EmployeeRating</kbd> is a simple POJO containing the <kbd>name</kbd> and <kbd>rating</kbd> attributes as follows:</p>
<pre>class EmployeeRating{<br/>  private String name;<br/>  private int rating;<br/>  public String getName() {<br/>    return name;<br/>  }<br/>  public void setName(String name) {<br/>    this.name = name;<br/>  }<br/>  public int getRating() {<br/>    return rating;<br/>  }<br/>  public void setRating(int rating) {<br/>    this.rating = rating;<br/>  }<br/>}</pre>
<p>RxJava conforms to Reactive Streams specification by providing an implementation of interfaces. Let's recall that the <kbd>onNext()</kbd>, <kbd>onError()</kbd>, <kbd>onSubscribe()</kbd>, and <kbd>onComplete()</kbd> methods are part of the Observer interface. RxJava provides an implementation of these interfaces to handle respective events. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom Observers</h1>
                </header>
            
            <article>
                
<p>We have seen how data emits from <kbd>Observable</kbd>, passes through a down stream of operators and eventually reaches <kbd>Observer</kbd>. Apparently, we can say that the data is transmitted from a series of <kbd>Observable</kbd> because each operator returns new <kbd>Observable</kbd> , which forms an <kbd>Observable</kbd> chain. The first <kbd>Observable</kbd> where the emission originates is called the <kbd>Observable</kbd> source. Therefore, we can say that <kbd>Observable.create()</kbd> and <kbd>Observable.just()</kbd> return the <kbd>Observable</kbd> source.</p>
<p>We can provide our custom implementation to handle the <kbd>Observer</kbd> events as follows:</p>
<pre>public class RxJavaCustomObserverDemo {<br/><br/>  public static void main(String[] args) {<br/><br/>    Observable&lt;String&gt; months =<br/>        Observable.just("January", "February", "March", "April", <br/>            "May","June","July","August");<br/><br/>    Observer&lt;String&gt; customObserver = new Observer&lt;String&gt;() {<br/>      @Override<br/>      public void onSubscribe(Disposable d) {<br/>        System.out.println(" Subscription initiated ...");<br/>      }<br/>      @Override<br/>      public void onNext(String value) {<br/>        System.out.println("The value " + value +" is received from Observable");<br/>      }<br/>      @Override<br/>      public void onError(Throwable e) {<br/>        e.printStackTrace();<br/>      }<br/>      @Override<br/>      public void onComplete() {<br/>        System.out.println("Done!");<br/>      }<br/>    };<br/><br/>    months.filter(month -&gt; month.endsWith("y"))<br/>            .subscribe(customObserver);<br/>  }<br/>}</pre>
<p>Like previous examples, we have defined the <kbd>Observable</kbd> with the list of months. We also defined custom <kbd>Observers</kbd> with an implementation of various methods that will be called on for a specific event. When we register the observer (<kbd>customObserver</kbd> in our case), <kbd>Observable</kbd> will call the <kbd>onSubscribe()</kbd> method on <kbd>Observer</kbd>. </p>
<p>Every time when <kbd>Observable</kbd> emits the data, it will call <kbd>onNext()</kbd> of registered observers, which will then be processed by observers. On sending the last data, <kbd>Observable</kbd> will call the <kbd>onComplete()</kbd> method on <kbd>Observer</kbd>. In case if any error occurs in between, <kbd>Observable</kbd> will call <kbd>onError()</kbd> method on <kbd>Observer</kbd>.</p>
<p>Certainly, the data will be passed through the <kbd>Observable</kbd> chain. In the previous case, the data emitted from the <kbd>Observable</kbd> source (<kbd>months</kbd> in this case) will be forwarded downstream to the <kbd>filter</kbd> operator, which will then reach the Observer or endpoint where the data is consumed and processed. By processed, we mean the data can be saved to the database, sent as a server response, written to the external document management system, composed as a structure for UI rendering, or simply printed in the console.</p>
<p>You will get an output as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b47c535e-e710-4c86-a677-40b006a98446.png" style="width:25.00em;height:7.00em;"/></p>
<div class="packt_infobox">In this example, we have used an anonymous class to provide a custom implementation of O<span>bserver's methods. However, y</span>ou can use a lambda expression for this purpose.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable types</h1>
                </header>
            
            <article>
                
<p>In the examples we have seen in previous subsections of the RxJava section, the data was created within Observable.  However, in the real scenario, that data comes from other sources like databases, REST APIs, and so on. The representation of any set of data/values is referred to as the producer. Observables are divided broadly into the following two categories based on where the procedure is cited.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cold Observable</h1>
                </header>
            
            <article>
                
<p>When the <kbd>Observable</kbd> itself creates the procedure or, say, <kbd>Observable</kbd> produces the data stream itself, it is said to be cold <kbd>Observable</kbd>. Generally <kbd>Observable</kbd> is lazy in nature, meaning it only emits the data when any <kbd>Observer</kbd> subscribes to it. Cold <kbd>Observable</kbd> always starts a fresh execution for each subscriber. </p>
<p>In other words, cold <kbd>Observable</kbd> emits separate data/event streams for individual Observers. All examples we have seen so far were of a cold <kbd>Observable</kbd> type, where we have created a data stream with the <kbd>just()</kbd> or <kbd>create()</kbd> method. Let's see how cold <kbd>Observable</kbd> works for more than one Observer subscribed, with the following example.</p>
<pre>public class RxJavaColdObservable {<br/>  public static void main(String[] args) {<br/>    Observable&lt;String&gt; source =<br/>        Observable.just("One","Two","Three","Four","Five");<br/>    //first observer<br/>    source.filter(data-&gt;data.contains("o"))<br/>       .subscribe(data -&gt; System.out.println("Observer 1 Received:" + data));<br/>    //second observer<br/>    source.subscribe(data -&gt; System.out.println("Observer 2 Received:" + data));<br/>  }<br/>}</pre>
<p>In this code, the data is created by <kbd>Observable</kbd> itself so it is called <strong>cold Observable</strong>.  We have subscribed two different Observers. When you run this code, you will get an output as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e87f0f89-91c7-4f0c-9e0b-6b8fc87e0818.png" style="width:14.58em;height:9.17em;"/></p>
<p>Cold <kbd>Observable</kbd> provides a separate data stream for each <kbd>Observer</kbd> so when we applied the filter for first <kbd>Observer</kbd> there is no effect in the second <kbd>Observer</kbd>. Also if there are more than one <kbd>Observer</kbd>, then <kbd>Observable</kbd> will emit the sequence of data to all observers one by one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hot Observable</h1>
                </header>
            
            <article>
                
<p>Hot <kbd>Observable</kbd>, on the other hand, has the producer created or activated outside of it. Hot <kbd>Observable</kbd> emits the stream that is shared by all observers. Let's see the example, as follows:</p>
<pre>public class RxJavaHotObservable1 {<br/>  public static void main(String args[]) {<br/>    Observable&lt;Long&gt; observableInterval = Observable.interval(2, TimeUnit.SECONDS);<br/>    PublishSubject&lt;Long&gt; publishSubject = PublishSubject.create();<br/>    observableInterval.subscribe(publishSubject);<br/>    publishSubject.subscribe(i -&gt; System.out.println("Observable #1 : "+i));<br/>    addDelay(4000);<br/>    publishSubject.subscribe(i -&gt; System.out.println("Observable #2 : "+i));<br/>    addDelay(10000); <br/>  }<br/>  private static void addDelay(int miliseconds) {<br/>    try {<br/>            Thread.sleep(miliseconds);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>  }<br/>}</pre>
<p>The <kbd>observableInterval</kbd> observable emits the event instead of data in this example. The <kbd>interval</kbd> method is used to emit sequential numbers at given intervals. We have used <kbd>PublishSubject</kbd> to make this observable as a hot type.  It can be behave as either <kbd>Observable</kbd> or <kbd>Observer</kbd>. It is part of the <kbd>Observable</kbd> chain in this case. We then simply add two subscribers to <kbd>PublishSubject</kbd><span> </span>with some delay in between. You will get an output as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a217de70-15dd-4b7d-b788-333717a26b7d.png" style="width:11.00em;height:15.50em;"/></p>
<p>The second <kbd>Observer</kbd> is subscribed after some delay to the first <kbd>Observer</kbd>. The <kbd>Observable</kbd> emits the sequential number every two seconds. The second <kbd>Observer</kbd> starts at the fourth second. Hot <kbd>Observable</kbd> emits just a single stream, which is shared across all <kbd>Observers</kbd>. So, in the case of the second <kbd>Observer</kbd>, the actual value is started from <kbd>2</kbd> instead of <kbd>0</kbd> as it subscribes after some time. </p>
<p>In this sense, hot <kbd>Observable</kbd> can be compared with a subscription to a radio station. A person who starts listening will not be able to hear what was played before he subscribed, as it is common to all subscribers (or say Observers in Reactive language). There are other ways to create hot <kbd>Observable</kbd>. We will see one of them as follows:</p>
<pre>public class RxJavaHotObservable2 {<br/>  public static void main(String args[]) {<br/>    Observable&lt;Long&gt; observableInt = Observable.interval(2, TimeUnit.SECONDS);<br/>    ConnectableObservable&lt;Long&gt; connectableIntObservable = observableInt.publish();<br/>    connectableIntObservable.subscribe(i -&gt; System.out.println("Observable #1 : "+i));<br/>    connectableIntObservable.connect();<br/>    addDelay(7000);<br/>    connectableIntObservable.<br/>       subscribe(i -&gt; System.out.println("Observable #2 : "+i));<br/>    addDelay(10000);<br/>  }<br/>  <br/>  private static void addDelay(int miliseconds) {<br/>    try {<br/>            Thread.sleep(miliseconds);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>  }<br/>}</pre>
<p>In this code, hot Observable is created with <kbd>ConnectableObservable</kbd>. It will not start emitting the data until the <kbd>connect</kbd> method is called on it, making it more controllable. Soon after the <kbd>connect</kbd> method is called, it will start a single stream, which is shared across the Observers. You will get an output as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/94131b24-bdd1-43f9-8bcd-2faec6bfba0f.png" style="width:10.33em;height:15.92em;"/></p>
<p>You can see how the second Observer missed the first few items as it was subscribed with some delay. You can convert any cold Observable to <kbd>ConnectableObservable</kbd> by calling the <kbd>publish</kbd> method on it. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other ways to get Observable</h1>
                </header>
            
            <article>
                
<p>So far we have seen how to get <kbd>Observable</kbd> with <kbd>just()</kbd>, <kbd>create()</kbd>, and <kbd>interval()</kbd>. However, there are other sources to get the <kbd>Observable</kbd>. You can get full details about each source from at:<a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables">https://github.com/ReactiveX/RxJava/wiki/Creating-Observables</a>:</p>
<ol>
<li><kbd>range</kbd>: If you want to emit a consecutive range of integers, you can use the <kbd>Observable.range(int from, int to)</kbd> call. As its name suggests, it will start emitting a number from the start value in increments until the end count is reached.</li>
<li><kbd>empty</kbd>:<span> </span>In a rare situation, you need to create <kbd>Observable</kbd> that emits nothing and calls<span> </span><kbd>onComplete()</kbd>. In this case, you can use this source type with the<span> </span><kbd>Observable.empty()</kbd><span> </span>call. </li>
<li><kbd>never</kbd>:<span> </span>It is equivalent to <kbd>empty</kbd> with the difference being that this will never make a call to <kbd>onComplete()</kbd> and keep the <kbd>Observable</kbd> waiting to emit a state. This is also used less frequently. </li>
<li><kbd>error</kbd>:<span> </span>If you wish to create <kbd>Observable</kbd> that immediately calls<span> </span><kbd>onError()</kbd>, you can use this source with the <kbd>Observable.error()</kbd> call. It is used for testing purposes mainly.</li>
<li><kbd>future</kbd>: It was introduced way back and used as a placeholder for the result that is not yet produced. <kbd>Observable</kbd> is more powerful than <kbd>future</kbd> but if you are using old libraries, you can convert <kbd>Observable</kbd> to <kbd>future</kbd> with the <kbd>Observable.future()</kbd> call.</li>
<li><kbd>defer</kbd>: This is basically used to create a separate state for each <kbd>Observer</kbd>. It is useful when the source of the stream is stateful. If you want your observers to reflect the changes happening to the  <kbd>Observable</kbd> state, then you can use this source type with an <kbd>Observable.defer()</kbd> call.</li>
<li><kbd>single</kbd>: <span>This type of <kbd>Observable</kbd> just emits a single value and can be used with a</span> <kbd>Single.just()</kbd> <span>method call.</span></li>
<li><kbd>maybe</kbd>: It is similar to the <kbd>single</kbd> type, the only difference that it emits zero or one data at maximum and can be used with a <kbd>Maybe.just()</kbd> call.</li>
<li><kbd>fromCallable</kbd>:<span> </span>If you want to perform certain actions of computation before emitting the data, you can use this source with an<span> </span><kbd>Observable.fromCallable()</kbd><span> </span>call.<span> </span>In case any error occurs and you want to pass it to the <kbd>Observable</kbd> chain through an <kbd>onError()</kbd> call instead of throwing the error, you can use this source type. </li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operators</h1>
                </header>
            
            <article>
                
<p>We have seen operators like map and filter in previous examples. They are basically used to perform a specific operation on the stream of data and return new <kbd>Observable</kbd> to form an <kbd>Observable</kbd> chain. Operators themselves are <kbd>Observers</kbd> to the <kbd>Observable</kbd> they are called on.</p>
<p>RxJava has a rich set of operators used to perform various operations with the following categories:</p>
<ul>
<li><strong>Creating observables:</strong> The set of operators used to create new <kbd>Observable</kbd>.</li>
<li><strong>Transforming observables:</strong> Operators used to transform items emitted by observables they called upon.</li>
<li><strong>Filtering observable:</strong> Operators used to emit selective data.</li>
<li><strong>Combining observable:</strong> Used to combine multiple source observables to form a single <kbd>Observable</kbd>.</li>
<li><strong>Error handling:</strong> Operators that are used to recover from the error condition notified from <kbd>Observable</kbd>.</li>
<li><strong>Utility Operator:</strong> <span>Used to perform some</span> <span>miscellaneous operations with <kbd>Observable</kbd>.</span></li>
<li><strong>Conditional and Boolean operators:</strong> Used to evaluate one or more <kbd>Observable</kbd> or even emitted items.</li>
<li><strong>Mathematical and aggregate:</strong> Operators used to perform various operations on the entire sequence of emitted data.</li>
</ul>
<p>It is good to visit: <a href="http://reactivex.io/documentation/operators.html">http://reactivex.io/documentation/operators.html</a>, <a href="http://reactivex.io/documentation/operators.html">to get full details about each of the operators, instead of having details<span> listed</span> here.</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project Reactor</h1>
                </header>
            
            <article>
                
<p>The Reactor can be called the reactive library on top of the JDK. Java doesn’t support Reactive Programming natively, and Reactor is one of the many libraries out there. Reactor comes from the open source group Pivotal and conforms to the Reactive Streams standard. It is built on Java 8 and ReactiveX vocabulary. </p>
<p>It is worthwhile to note here that, although asynchronous seems to be an important attribute for  Reactive Programming, the Reactor doesn't force you to go asynchronous/synchronous, as it supports both. It depends on the scheduler chosen. That choice is yours. I<span>n order to understand the Reactor in a better way, we need to understand Reactive Streams in more detail.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactor features</h1>
                </header>
            
            <article>
                
<p>Reactor provides event-based architecture and is used to handle a large volume of requests concurrently and asynchronously, making a non-blocking and backpressure equipped system. With the Project Reactor, you have no need to implement Reactive Streams yourself as it provides a set of modules, which are embedded and interoperable. It provides the following stunning features:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling data stream with high volume</h1>
                </header>
            
            <article>
                
<p>Project Reactor is capable of providing an API support for specific data cardinality, ranging from generating endless streams to publishing just a single data entry.</p>
<p>Instead of waiting for the entire data stream to process, Project Reactor enables the subscribers to handle the elements of a stream as they arrive. This makes the data processing operation more flexible and optimized by improving <span>resource utilization. The memory required to be allocated to a </span>subscriber is limited because data processing happens in a subset of items arriving at a particular time, rather than processing entire data streams in one go. Also, this makes the system more responsive as the results will start as soon as the first set of elements is received, instead of waiting until all items have been received and processed to deliver a final output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Push-pull mechanism</h1>
                </header>
            
            <article>
                
<p>Project Reactor has good assistance for proving a push/pull feature. There are practical scenarios where consumers intake the data at a slower rate than the producer emits them. In this case, the producer will raise the event and wait for Observers to pull it. In some situations, the consumer works faster than the producer. To handle it, consumers wait for the events to be pushed from the producer side. Project Reactor enables this flow to be dynamic in nature whenever necessary. It will be controlled by the rate of production and consumption.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling concurrency independently </h1>
                </header>
            
            <article>
                
<p class="mce-root">The reactor execution paradigm is capable of handling concurrency independently, which truly makes it concurrency agnostic. The Reactor library handles the data stream in a more abstract way, rather than talking about how to execute different types of streams. The transactions happening during various operations are safe out of the box. Reactor provides a set of operators that handle different synchronous streams in different ways.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operators</h1>
                </header>
            
            <article>
                
<p>Reactor provides a set of operators that plays a vital role in the execution model by handling different synchronous streams in different ways. These operators can be used to filter, map, select, transform, and combine the data streams. They can be combined with other operators to build high-level, easy-to-operate, and highly customized data pipelines to process streams in the way you want.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactor sub-projects</h1>
                </header>
            
            <article>
                
<p>Project r<span>eactor</span> consists of various sub-projects as follows:</p>
<ul>
<li><strong>Reactor Core:</strong> This project provides an implementation of Reactive Streams specification. Spring Framework 5.0 provides support for Reactive Programming with the Reactor Core sub-project as a foundation.</li>
<li><strong>Reactor Test:</strong> This contains necessary utilities for test verification.</li>
<li><strong>Reactor Extra:</strong> On top of Reactor Core, this project provides various operators to work on the data stream to perform required operations.</li>
<li><strong>Reactor IPC:</strong> This project provides backpressure furnished and non-blocking inter-process communication support over various network protocols, like HTTP, TCP, UDP, and web sockets. Due to this nature, this module is also helpful when building asynchronous microservice architectures.</li>
<li><strong>Reactor Netty: </strong>It is used to provide a reactive feature to Netty, a client server framework to develop network applications.</li>
<li><strong>Reactive Kafka: </strong>It is a reactive API for Apache Kakfa-based projects. It is used to communicate with Kakfa in a non-blocking and functional way. </li>
<li><strong>Reactive RabbitMQ: </strong>This project is used to equip RabbitMQ  (a message broker system) with reactive capabilities.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactor types</h1>
                </header>
            
            <article>
                
<p>Project Reactor is built with two core types based on the number of elements they process. They are considered as main building blocks to create a Reactive System using Reactor. They are <kbd>Flux</kbd> and <kbd>Mono</kbd>. They both implement the <kbd>Publisher&lt;T&gt;</kbd> interface and c<span>onform to</span> Reactive Streams <span>specification, and  are furnished with reactive-pull and back-pressure facility. They also have </span>several other useful methods. Let's explore the details as follows: </p>
<ul>
<li class="mce-root"><kbd>Flux</kbd>: It can be considered the equivalent of RxJava's Observable and can emit zero or more items, ending successfully or with an error signal. In short, it represents asynchronous event streams having zero or more elements. </li>
<li class="mce-root"><kbd>Mono</kbd>: It can emit, at most, one element at a time. It is equivalent of the <kbd>Single</kbd> <span>and</span> <kbd>Maybe</kbd><span> </span><span>Observable type from the RxJava side. A <kbd>Mono</kbd> type can be used for one-to-one request-response model implementation; for example, a task wish to send a completion signal can use a <kbd>Mono</kbd> type reactor.</span></li>
</ul>
<p>The clear difference between the number of elements a reactor type can handle provides useful semantics and makes it an easy decision to choose which reactor type. If the model is sort of <em>fire and forget</em> then choose the <kbd>Mono</kbd> type. If execution is dealing with multiple data items or elements in the stream, then the <kbd>Flux</kbd> type is more appropriate.</p>
<p>Additionally, various operators play a vital role in deciding the type of reactor. For example, calling a<kbd>single()</kbd> method on a <kbd>Flux&lt;T&gt;</kbd> type will return <kbd>Mono&lt;T&gt;</kbd>, while concatenating multiple entities of type <kbd>Mono&lt;T&gt;</kbd> together with <kbd>concatWith()</kbd> will result in the <kbd>Flux&lt;T&gt;</kbd> type. The reactor type can influence which operators we can use with it. For example, some operators are applicable to either one of  <kbd>Flux</kbd> or <kbd>Mono</kbd> while others can be used for both of them. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactor in action </h1>
                </header>
            
            <article>
                
<p>Let's learn more about the reactor API with a practical example. Create a new Maven project similar to what we created in the <em>Anatomy of RxJava</em> section. The current version of the Project Reactor at the time of writing  is 3.2.6. <span>We need to provide a Maven dependency for the reactor as follows:</span></p>
<pre>&lt;project <br/>  <br/>  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 <br/>             http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br/>  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/>  &lt;groupId&gt;reactor-demo&lt;/groupId&gt;<br/>  &lt;artifactId&gt;simple-reactor-demo&lt;/artifactId&gt;<br/>  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br/>  &lt;name&gt;Smiple Reactor Dmo&lt;/name&gt;<br/>  &lt;dependencies&gt;<br/>    <strong>&lt;dependency&gt;</strong><br/><strong>      &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;</strong><br/><strong>      &lt;artifactId&gt;reactor-core&lt;/artifactId&gt;</strong><br/><strong>      &lt;version&gt;3.2.6.RELEASE&lt;/version&gt;</strong><br/><strong>    &lt;/dependency&gt;</strong><br/>  &lt;/dependencies&gt;<br/>&lt;/project&gt;</pre>
<p>When we define a Reactor dependency, Reactive Streams JAR will be added as a transitive dependency. Next, is to add a Java class as follows:</p>
<pre>public class ReactorBasic {<br/>  private static List&lt;String&gt; carModels = Arrays.asList(<br/>              "Era","Magna","Sportz","Astha","Astha(O)");<br/>  public static void main(String args[]) {<br/>       Flux&lt;String&gt; fewWords = Flux.just("Hello", "World");<br/>       Flux&lt;String&gt; manyWords = Flux.fromIterable(carModels);<br/>       Mono&lt;String&gt; singleWord = Mono.just("Single value");<br/>       fewWords.subscribe(t-&gt;System.out.println(t));<br/>       System.out.println("-----------------------------");<br/>       manyWords.subscribe(System.out::println);<br/>       System.out.println("-----------------------------");<br/>       singleWord.subscribe(System.out::println);<br/>  }<br/>}</pre>
<p>We have used <kbd>Flux</kbd> and <kbd>Mono</kbd> to create various publishers. The  <kbd>just()</kbd> method is used to populate the stream. We can<span> also</span> reach the iterable types (like <kbd>List</kbd>, <kbd>Set</kbd>, <kbd>n</kbd>) to form a data stream with the <kbd>fromIterable()</kbd> method. A few other methods like <kbd>from()</kbd>, <kbd>fromArray()</kbd> , and <kbd>fromStream()</kbd> are used to construct data streams from other producers, arrays, and existing Java streams, respectively, and can be used as follows:</p>
<pre>public class ReactorFromOtherPublisher {<br/>  public static void main(String[] args) {<br/>    Flux&lt;String&gt; fewWords = Flux.just("One","Two");<br/>    /* from array */<br/>    Flux&lt;Integer&gt; intFlux = Flux.fromArray(new Integer[]{1,2,3,4,5,6,7});<br/>    /* from Java 8 stream */<br/>    Flux&lt;String&gt; strFlux = Flux.fromStream(Stream.of(<br/>      "Ten", "Hundred", "Thousand", "Ten Thousands", "Lac","Ten Lac", "Crore"));<br/>    /* from other Publisher */<br/>    Flux&lt;String&gt; fromOtherPublisherFlux = Flux.from(fewWords);<br/>    intFlux.subscribe(System.out::println);<br/>    strFlux.subscribe(System.out::println);<br/>    fromOtherPublisherFlux.subscribe(System.out::println);<br/>  }<br/>}</pre>
<p>The subscriber can be plugged with the <kbd>subscribe()</kbd> method. <span>This is similar to what we have done with Observable in RxJava. </span>With <kbd>Flux</kbd>, we can create a publisher with the finite or infinite stream.</p>
<p>We can<span> also</span> control to generate a stream with a value or just an empty stream. All of that can be done with a few utility methods provided by the <kbd>Flux</kbd> class as follows:</p>
<ul>
<li><kbd>Flux.empty()</kbd>: It is used to generate an empty stream having no values and only executes completion events.</li>
<li><kbd>Flux.error()</kbd>: It is used to signal the error condition by generating an error stream with no any value but only errors.</li>
<li><kbd>Flux.never()</kbd>: As its name suggests, it generates a stream with no events of any type.</li>
<li><kbd>Flux.defer()</kbd>: It is used to construct a publisher when a subscriber makes the subscription to <kbd>Flux</kbd>. In short, it is lazy in nature.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of subscribers</h1>
                </header>
            
            <article>
                
<p>The <kbd>Flux</kbd> and <kbd>Mono</kbd> classes both allow Java 8 lambda expressions as a subscriber. They also support various overloaded versions of the <kbd>subscribe()</kbd> method, as per the following code.</p>
<pre>public class ReactorWithSubscriberWays {<br/><br/>  public static void main(String[] args) {<br/>    List&lt;String&gt; monthList = Arrays.asList(<br/>            "January","February","March","April","May");<br/>    <br/>    Flux&lt;String&gt; months = Flux.fromIterable(monthList);<br/>/* 1) No events is consumed. */<br/>    months.subscribe();<br/>/* 2) Only value event is consumed */<br/>    months.subscribe(month-&gt;System.out.println("-&gt;"+month));<br/>    <br/>/* 3) Value and Error (total 2) events are handled */<br/>    months.subscribe(month-&gt;System.out.println("--&gt;"+month),<br/>              e-&gt;e.printStackTrace());<br/>    <br/>/* 4) Value, Error and Completion (total 3) events are subscribed */<br/>    months.subscribe(month-&gt;System.out.println("---&gt;"+month),<br/>                    e-&gt;e.printStackTrace(),<br/>            ()-&gt;System.out.println("Finished at THIRD PLACE.. !!"));<br/>    <br/>/* 5) Value, Error, Completion and Subscription (total 4) events are subscribed */<br/>    months.subscribe(month-&gt;System.out.println("----&gt;"+month),<br/>                                       e-&gt;e.printStackTrace(),<br/>      ()-&gt;System.out.println("Finished at FOURTH PLACE ..!!"),<br/>             s -&gt; {System.out.println("Subscribed :");<br/>                   s.request(5L);});<br/>  }<br/>}</pre>
<p>The <kbd>Flux</kbd> class is created with list of strings. There are five different variations of using the <kbd>subscribe()</kbd> method, and each has provision to capture various events. The detail is as follows:</p>
<ul>
<li>The first version does not consume any event.</li>
<li>The second variant consumes the value event and it is defined with a lambda expression.</li>
<li>The third <kbd>subscribe()</kbd> method listens to error events as a second argument along with the value events. We are simply printing stack-trace through lambda expressions. </li>
<li>The fourth one consumes value, error, and completion events. On completion of a data stream, the completion event will be executed, which we listen to with a lambda expression. </li>
<li>The fifth version consumes value, error, completion, and subscription events. The last parameter of the <kbd>Subscription</kbd> type makes this version of <kbd>subscribe()</kbd> a special case. The <kbd>Subscription</kbd> type has a method called <kbd>request()</kbd>. The publisher will not send any event until, and unless, the subscriber sends a demand signal with a <kbd>Subscription.request()</kbd> call. This is only applicable if <kbd>Subscription</kbd> is defined for the subscriber. We have to make a method call as <kbd>s.request(5L)</kbd>, meaning the publisher can only send five elements. It is less than than the total value in publisher and fires a completion event. In our case, the total elements in a data stream is five, and so it will call a completion event. If you pass fewer than five, you will not get a completion event call. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom subscribers</h1>
                </header>
            
            <article>
                
<p>In a certain scenario, calling a <kbd>Subscribe</kbd> method on <kbd>Publisher</kbd> is not appropriate and you may want to write custom subscriber with own handling. Reactor framework provides support for defining custom subscribers by extending the <kbd>reactor.core.publisher.BaseSubscriber&lt;T&gt;</kbd> abstract class. You don't need to implement the <kbd>Subscribe</kbd> interface of Reactive Streams specification directly. Instead, you need to just extend this class to apply the custom implementation as follows:</p>
<pre>static class CustomSubscriber extends BaseSubscriber&lt;String&gt;{<br/>  @Override<br/>  protected void hookOnSubscribe(Subscription subscription) {<br/>  System.out.println("Fetching the values ...!!");<br/>  subscription.request(10);<br/> }<br/>  @Override<br/>  protected void hookOnNext(String value) {<br/>  System.out.println("Fetchig next value in hookOnNext()--&gt;"+value);<br/> }<br/>  @Override<br/>  protected void hookOnComplete() { <br/>  System.out.println("Congratulation, Everything is completed successfully ..!!");<br/> }<br/>  @Override<br/>  protected void hookOnError(Throwable throwable) {<br/>  System.out.println("Opps, Something went wrong ..!! "+throwable.getMessage());<br/> }<br/>  @Override<br/>  protected void hookOnCancel() {<br/>  System.out.println("Oh !!, Operation has been cancelled ..!! ");<br/> }<br/>  @Override<br/>  protected void hookFinally(SignalType type) {<br/>  System.out.println("Shutting down the operation, Bye ..!! "+type.name());<br/> }<br/>}</pre>
<p>The  <kbd>BaseSubscriber</kbd> class provides various hook methods, which represent the corresponding event. It is a placeholder to provide a custom implementation. Implementing these methods is similar to using various versions of the <kbd>subscribe()</kbd> method that we have seen in the <em>Type of subscriber</em> section. For example, if you only implement the <kbd>hookOnNext</kbd>, <kbd>hookOnError</kbd> , and <kbd>hookOnComplete</kbd> methods, then it is equivalent to the fourth version of <kbd><span>subscribe</span>()</kbd>.</p>
<p>The  <kbd>hookOnSubscribe()</kbd> method facilitates a subscription event. The backpressure is provided with <kbd>subscription.request()</kbd>. You can request as many element, as you want. For example, update the code for the <kbd>hookOnSubscribe()</kbd> method as follows:</p>
<pre> @Override<br/>     protected void hookOnSubscribe(Subscription subscription) {<br/>       System.out.println("Fetching the values ...!!");<br/>       for(int index=0; index&lt;6;index++) {<br/>         try {<br/>          Thread.sleep(1000);<br/>        } catch (InterruptedException e) {<br/>          e.printStackTrace();<br/>        }<br/>         subscription.request(1);<br/>       }<br/>     }</pre>
<p>We are requesting<span> records</span> one-by-one by calling <kbd>subscription.request(1)</kbd> in a loop. To get an idea how it works, we put a two-second delay in between so you will get a record for every two requests. Once all data is completed, it will trigger the completion event and the <kbd>hookOnComplete()</kbd> method will be called. The output would be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82109b35-b274-45f0-a097-21e7a1dee3bb.png" style="width:40.83em;height:15.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactor lifecycle methods</h1>
                </header>
            
            <article>
                
<p>Reactor provides lifecycle methods to capture various events happening in publisher-subscriber communication. Those lifecycle methods are aligned with Reactive Streams specification. Reactor lifecycle methods can be used to hook custom implementation for a given event. Let's understand how that works with the following code:</p>
<pre>public class ReactorLifecycleMethods {<br/><br/>  public static void main(String[] args) {<br/>    List&lt;String&gt; designationList = Arrays.asList(<br/>        "Jr Consultant","Associate Consultant","Consultant",<br/>        "Sr Consultant","Principal Consultant");<br/>    Flux&lt;String&gt; designationFlux = Flux.fromIterable(designationList);<br/><br/>    designationFlux.doOnComplete(<br/>        () -&gt; System.out.println("Operation Completed ..!!"))<br/>    .doOnNext(<br/>        value -&gt; System.out.println("value in onNext() -&gt;"+value))<br/>    .doOnSubscribe(subscription -&gt; {<br/>      System.out.println("Fetching the values ...!!");<br/>      for(int index=0; index&lt;6;index++) {<br/>          try {<br/>            Thread.sleep(1000);<br/>          } catch (InterruptedException e) {<br/>          e.printStackTrace();<br/>          }<br/>          subscription.request(1);<br/>        }<br/>      })<br/>    .doOnError(<br/>        throwable-&gt; {<br/>          System.out.println("Opps, Something went wrong ..!! "<br/>              +throwable.getMessage());<br/>        })<br/>    .doFinally(<br/>        (signalType-&gt;<br/>          System.out.println("Shutting down the operation, Bye ..!! "<br/>          +signalType.name())))<br/>    .subscribe();<br/>  }</pre>
<p>We are creating the <kbd>Flux</kbd> object with data from a list and then calling various lifecycle methods, like <kbd>doOnComplete()</kbd>, <kbd>doOnNext()</kbd>,  <kbd>doOnSubscribe()</kbd>, <kbd>doOnError()</kbd>, and <kbd>doOnTerminate()</kbd> in a chain. Finally, we call the <kbd>subscribe()</kbd> method, which does not consume the events, but all lifecycle methods will be executed as appropriate events are triggered. </p>
<p>This is similar to the custom subscriber implementation in the <em>Custom subscribers</em> section. You will see a similar output. The details of these lifecycle methods are as follows:</p>
<ul>
<li><kbd>doOnComplete()</kbd>: Once all the data is received by the <kbd>Subscriber</kbd>, this method will be called.  </li>
<li><kbd>doOnNext()</kbd>: This method will listen to the value event coming from the producer.</li>
<li><kbd>doOnSubscribe()</kbd>: Used to plug  <kbd>Subscription</kbd>. It can control the backpressure by defining how many more elements are required with a <kbd>subscription.request()</kbd> call.</li>
<li><kbd>doOnError()</kbd>: If any error occurs, this method will be executed. </li>
<li><kbd>doOnTerminate()</kbd>: Once the operation is completed, either successfully or with error, this method will be called. It will not be considered on a manual cancellation event.</li>
<li><kbd>doOnEach()</kbd>: As the name suggests, it will be called for all <kbd>Publisher</kbd> events raised during stream processing.</li>
<li><kbd>doFinally()</kbd>: This will be called on stream closures due to error, cancellation, or successful completion of events.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ratpack</h1>
                </header>
            
            <article>
                
<p>Ratpack is <span>set of Java libraries which are event driven, </span>non-blocking, high performance, and asynchronous in nature to build scalable services with HTTP. It conforms to the Reactive Streams specification, meaning it comes with interoperability out of the box. It is built on Netty—a framework to build a client-server application over the network with quick and easy development.</p>
<p>It is a web framework to develop efficient and lightweight JVM-based applications. It has its own testing library to easily set up test cases. Spring provides support for Ratpack. You can get more information about Ratpack from its official site:  <a href="https://ratpack.io">https://ratpack.io</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Akka stream</h1>
                </header>
            
            <article>
                
<p>Akka stream provides an implementation of Reactive Streams specifications on top of the Akka toolkit that uses Actor patterns for  the concurrency execution model. It processes the stream of data asynchronously and in a non-blocking backpressure way with Actor. Apart from Java, Akka also works well with Scala language. Explore more about the Akka stream at the link <a href="https://akka.io/docs">https://akka.io/docs</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vert.x</h1>
                </header>
            
            <article>
                
<p>Vert.x is another tool kit provided by the Eclipse Foundation project used to build a JVM-based Reactive System. It also provides an implementation of Reactive Streams specifications similar to Ratpack. Vert.x supports and allows the use of RxJava to build a Reactive System. Needless to say, Vert.x is event based and non-blocking in nature. It supports various programming languages, like Java, JavaScript, Ruby, Groovy, Ceylon, Scala, Kotlin, and so on. You can learn more about it at:  <a href="https://vertx.io">https://vertx.io</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive support in Spring Framework</h1>
                </header>
            
            <article>
                
<p>Spring is a modular framework and used to build every aspect of an application from the web to the persistence layer. Each module is considered as a sub-framework and targeted for a specific area of development. For example, to support a web layer with a servlet API,  the Spring MVC module was included in the Spring Framework. </p>
<p>Similarly, to support a reactive stack in the web layer, Spring WebFlux was introduced in Spring Framework 5. It is fully non-blocking, backpressure, asynchronous, and compliant with Reactive Streams specifications. It can be run on Servlet 3.1+, Netty, and Undertow containers.</p>
<p>Spring Framework has both the stacks, Spring Web MVC and spring-WebFlux, and developers are free to use either of them, or in some scenarios to mix both of them to develop a Spring-based web application. The typical example would be using spring MVC controller with reactive WebClient; we will talk more about this in the latter part of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring WebFlux</h1>
                </header>
            
            <article>
                
<p>Spring 5 impressively supports creating a Reactive System with Spring WebFlux . It is a new reactive web application framework, developed based on the Project Reactor API and can also be used to build microservices. The most remarkable and direct benefit of making any application reactive is to bring asynchronous qualities to it.</p>
<p>Non-reactive and traditional Java-based applications use thread mechanisms for asynchronous and parallel programming. However, usage of the thread is not competent and scalable in any manner. On the other hand, Spring WebFlux encourages event loop-based programming, which is asynchronous and non-blocking in manner. <span>This section introduces WebFlux in the context of the Spring Framework and Reactive Programming.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring MVC versus Spring WebFlux</h1>
                </header>
            
            <article>
                
<p>Spring MVC has been part of the Spring Framework since version 2, and since then, has been a de facto standard when developing web-based applications with Spring Framework. To support Reactive Programming, Spring has introduced the WebFlux module. Therefore, it is important to understand the similarities and differences between Spring MVC and Spring WebFlux.</p>
<p><span>The Spring team has done it the hard way and kept the WebFlux syntax similar to the Spring MVC, but under the hood it has completely new technology. </span>One of the prime differences between these two modules is the mechanism by which they handle the request. Spring MVC is based on a pure servlet API and works with a thread pool. This means that, every request has one thread from the controller to the persistence layer and may be blocked for the resources it needs.</p>
<p>However, Spring WebFlux is based on reactive architecture and works with the event loop mechanism, providing non-blocking support out of the box. In the event loop mechanism, everything happens as a reaction to the event. It is similar to a callback function; when any event happens, the callback function gets triggered. The concept event loop was introduced by Node.js.</p>
<p>Internally, WebFlux needs servlet API support, which works as an adapter layer, so that WebFlux can be deployed on both servlet and non-servlet containers. Spring MVC is built on top of a servlet API, which is synchronous (like Filter, Servlet, and so on) by nature and also performs blocking IO streams.</p>
<p>WebFlux, on other hand, is developed on asynchronous API (WebHandler, WebFilter, and so on) and non-blocking IO mechanisms, like <kbd>Flux</kbd> and <kbd>Mono</kbd> , which are used to handle the stream with a maximum of one value and many elements, respectively. Although Spring WebFlux is based on reactor and used by default, it also supports other reactive implementations, like Java 9 Flow API, RxJava, and Akka stream. </p>
<p><span>Both the frameworks, however, support some common features like using some annotation (like <kbd>@Controller</kbd> and <kbd>@RequestMapping</kbd>) and support for some well-known servers. </span></p>
<p>We are talking about Reactive Programming support in String with WebFlux; it does not mean Spring MVC is of no use. Both frameworks are addressing separate concern to the application. Like any framework, WebFlux may not be the best choice for all the application types. </p>
<p>So instead of choosing the framework by its features, you need to select it as per the requirement. There is absolutely no need to port your existing Spring MVC application completely to WebFlux if it is working perfectly well. The excellent part of WebFlux is that it can be used in conjunction with Spring MVC (if needed explicitly) without any problems. </p>
<p>Apart from this, if your existing Spring MVC application has a dependency on other parts that are synchronous and blocking in nature then, adapting WebFlux specific changes will obstruct from taking full benefits of reactive paradigm. You can decide, however, to pick WebFlux if your application is mainly handling the stream of data. If scalability and performance are what you are looking for then you can use WebFlux specific changes in your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive span across Spring modules</h1>
                </header>
            
            <article>
                
<p>By introducing a reactive web framework, WebFlux , Spring also made necessary changes in other modules to provide first-class support for WebFlux. Spring Boot, Spring Security, Thymeleaf, and Spring Data are among the few modules that are equipped with WebFlux capabilities. This can be described with the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7676979f-25e9-46da-aceb-6a29a9fef044.png" style="width:50.17em;height:36.75em;"/></p>
<p>Spring Data has adopted a reactive paradigm and started supporting infinite streams from the database with the <kbd>@Tailable</kbd>annotation. Spring Data JPA is mostly associated with RDBMS, which is blocking in nature so it cannot support Reactive Programming.</p>
<p>Spring MVC is <span>inherently </span>blocking in nature; however, we can use Reactive Programming for some of the parts, which can be converted to be reactive. For example, the Spring MVC controller can be equipped with the <kbd>Flux</kbd> and <kbd>Mono</kbd> types to handle the data stream in a reactive way.</p>
<p>Apart from this, a few annotations like <kbd>@Controller</kbd>, <kbd>@RequestMapping</kbd>, and so on are supported in WebFlux so you can convert a Spring MVC application to WebFlux in an incremental manner. We will see more details about reactive support in Spring Framework through WebFlux by creating a sample application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring WebFlux application</h1>
                </header>
            
            <article>
                
<p><span>We will create a sample web application</span><span> with the WebFlux framework. The application will simply access existing student information from a data store. Instead of making a fully fledged application, we will focus more on how to access data in a reactive manner with the WebFlux framework.</span></p>
<p><span>We will use Spring Boot to kickstart the development. For t</span>hose who are new to Spring Boot, it is a tool and part of Spring Horizon, which is designed to speed up and simplify the bootstrapping and development of new Spring-based applications.</p>
<p>You might have come across bulky XML and other configurations repeatedly in Spring projects. The Spring team was well aware of this and has finally developed a tool called Spring Boot, aimed at freeing the developer from providing a boilerplate configuration, which is not only tedious but time consuming.</p>
<p>We will create a sample web application<span> </span>using MongoDB as a data store. While working with Reactive Programming, it is recommended to use non-blocking and reactive capable datastores, like MongoDB, Couchbase, Cassandra, and so on. We will use a tool called <span><strong>Spring Tool Suite</strong> </span>(<strong><span>STS</span></strong>), which is an Eclipse-based IDE. It provides support for creating Spring Boot-based applications. Download it from: <a href="https://spring.io/tools3/sts/all">https://spring.io/tools3/sts/all</a> and install it in your local machine. </p>
<div class="packt_infobox">The STS link given here is version 3.x. At the time of writing, the current version of STS is 4.x. All the codes created in this book are with STS 3.x so the link given is version 3.x. However, you can download the latest version of STS and play with the code without any problems. </div>
<p>Once downloaded, open it, select the<span> </span><em><span class="packt_screen">File</span> | <span class="packt_screen">New</span><span> </span>|<span> </span></em><span class="packt_screen">Spring Starter Project</span><span> </span>menu and fill the form as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6e3d6a05-6110-42c1-a873-a1366090b9de.png" style="width:39.00em;height:30.08em;"/></p>
<p>Click on the<span> </span><span class="packt_screen">Next</span><span> </span>button, and you will be asked to define the dependencies. Choose the following dependencies. You can use the textbox, <span class="packt_screen">Available</span><span> </span>to search for a particular dependency:</p>
<ul>
<li><strong>Web:</strong><span> </span>Used to add Spring MVC specific dependencies.</li>
<li><strong>Reactive Web:</strong><span> </span>To add WebFlux specific dependencies.</li>
<li><strong>DevTools:</strong><span> </span>Helpful for development as it will auto-refresh the changes in the embedded container to see the changes quickly. </li>
<li><strong>Reactive MongoDB:</strong><span> </span>Spring Data dependency for MongoDB that works in a reactive paradigm. Make sure you don't select<span> </span>MongoDB,<span> </span>which is a dependency to work with MongoDB in the non-reactive model.</li>
</ul>
<p>Click on<span> </span><span class="packt_screen">Finish,</span><span> </span>and you will see a project is created in the<span> </span><span class="packt_screen">Package Explorer</span><span> </span>(or<span> </span><span class="packt_screen">Project Explorer</span>) section of STS. Once the project is created, we will perform the following steps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MongoDB installation</h1>
                </header>
            
            <article>
                
<p>First, you need to install MongoDB into your local machine. It is distributed as a standalone server as well as a cloud service. Download the latest version from: <a href="https://www.mongodb.com/download-center/community">https://www.mongodb.com/download-center/community</a>. Choose the <span>appropriate</span> OS from the list and install it on your machine. </p>
<p>MongoDB doesn't has any UI to access it. However, it provides another tool called Compass and can be downloaded from: <a href="https://www.mongodb.com/download-center/compass">https://www.mongodb.com/download-center/compass</a>. Choose the appropriate version and target platform and download them. In most cases, it is directly executable. By default, MongoDB is accessible with the <kbd>27017</kbd> port. Just connect Compass to the MongoDB server to make sure it is running before connecting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MongoDB data structure</h1>
                </header>
            
            <article>
                
<p>Before using MongoDB, it is important to understand the schema and data structure used in it. Like a relational database, we need to first create a database in MongoDB. Along with the database, we also need to create a collection. You can consider a collection to be similar to the database table in RDBMS. </p>
<p>Connect the Compass (default: no credentials) and click on the <span class="packt_screen">CREATE DATABASE</span> button, and you will see model windows as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f78bb8f4-b00b-4848-8fb3-dd8f463fad8a.png" style="width:63.92em;height:19.92em;"/></p>
<p>You need to give the <span class="packt_screen">Database Name</span> and <span class="packt_screen">Collection Name</span><em> </em>and click on the <span class="packt_screen">CREATE DATABASE</span> button from the model window. You can now insert the data for student collection into MongoDB.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Spring Data repository</h1>
                </header>
            
            <article>
                
<p>Spring Data provides a consistent Spring-based programming model to access data. It abstracts away the low-level boilerplate details and can be used to access a wide variety of data stores including the SQL (relational and non-relational) database, map-reduce frameworks, cloud-based data services, and so on. The Spring Data repository basically implements the data access layer and provides abstract access to interact with the underlying data store.</p>
<p>We will configure the Spring Data repository to interact with MongoDB. The first step is to create an entity object (domain model). Spring Data allows accessing data in an object-oriented way, so first we need to define the entity class and provide the necessary mapping with the persistence model. An entity class can be created as follows:</p>
<pre>@Document(collection="Student")<br/>public class Student {<br/>  @Id<br/>  @JsonIgnore<br/>  private String id;<br/>  <br/>  @NotNull(message="Roll no can not be empty")<br/>  private Integer rollNo;<br/>  <br/>  @NotNull(message="Name can not be empty")<br/>  private String name;<br/>  <br/>  @NotNull(message="Standard can not be empty")<br/>  private Integer standard;<br/><br/> //.. getter and setter<br/>}</pre>
<p>This POJO class represents the student entity in MongoDB with the <kbd>@Document</kbd> annotation. You need to give the same collection name here that we created in MongoDB. The attribute ID will be autogenerated by MongoDB and can be considered as a primary key for the <kbd>Student</kbd> entity so it is marked with the <kbd>@Id</kbd> annotation.</p>
<p>Next add a Spring Data repository. Spring provide repository support for specific data stores. For MongoDB, the Spring Data repository should looks as follows:</p>
<pre>@Repository<br/>public interface StudentMongoRepository extends ReactiveMongoRepository&lt;Student, String&gt;{<br/>  public Mono&lt;Student&gt; findByRollNo(Integer rollNo);<br/>  public Mono&lt;Student&gt; findByName(String name);<br/>}</pre>
<p>Spring Data provides the <kbd>ReactiveMongoRepository</kbd> interface that can be extended to define a custom repository. It is of the <kbd>Student</kbd> type, which is an object entity type when we want to interact with MongoDB and <kbd>String</kbd> , which represent the primary key (ID in our case).</p>
<p>The Spring Data repository provides a nice feature called the <strong>query</strong> method, which is used to access data based on specific column or  attribute values by following a certain naming convention. For example, <kbd>findByName(String name)</kbd> will return  <kbd>StudentData</kbd> with the matching name. Spring Data provides underlying implementation of these methods out of the box. For simplicity, we kept just two methods.</p>
<p>To make sure the Spring application connects to MongoDB, we need to add the following properties in the <kbd>application.properties</kbd> file:</p>
<pre>spring.data.mongodb.host=localhost<br/>spring.data.mongodb.port=27017<br/>spring.data.mongodb.database=StudentData</pre>
<p>This is equivalent to defining connection properties in a database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebFlux programming models</h1>
                </header>
            
            <article>
                
<p>Spring WebFlux is flexible enough to support different development patterns. You can create an application in WebFlux with the following two programming models:</p>
<ul>
<li><strong>Annotated controller</strong>: This is much similar than the Spring MVC controller.</li>
<li><strong>Functional end point</strong>:  Functional end points are used to process and route requests with functional programming features.</li>
</ul>
<p>We will explore both these options in the sample WebFlux application that we created <span>with the Spring Data repository and entity class</span>. The next part is to create a controller, which can be done in the following two ways.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Annotated controller</h1>
                </header>
            
            <article>
                
<p>WebFlux provides support for annotation-based configurations in a similar to the Spring MVC framework. To begin with, we will create an annotated controller class that publishes the Reactive Streams of the <kbd>Student</kbd> entity from the server side as follows:</p>
<pre>@RestController<br/>@RequestMapping("api")<br/>public class StudentWebFluxController {<br/><br/>  @Autowired<br/>  private StudentMongoRepository studentMongoRepository;<br/>  <br/>  @GetMapping("/getStudent/{rollNo}")<br/>  public Mono&lt;ResponseEntity&lt;Student&gt;&gt; getStudent(@PathVariable("rollNo") Integer rollNo) {<br/>    Mono&lt;Student&gt; studentMonoObj = studentMongoRepository.findByRollNo(rollNo);<br/>    return studentMonoObj.map(student -&gt; ResponseEntity.ok(student))<br/>        .defaultIfEmpty(ResponseEntity.notFound().build());<br/>  }<br/>}</pre>
<p> <kbd>StudentWebFluxController</kbd> is the annotated controller. It is similar to the Spring MVC controller. The <kbd>@RestController</kbd> <span>annotation </span>is used to define this controller as a REST controller. The <kbd>@RequestMapping</kbd> annotation is used to define the URL mapping for this controller.  </p>
<p>The <kbd>studentMongoRepository</kbd> Spring Data repository supports non-blocking Reactive Streams. The <kbd>getStudent()</kbd> method will return a single <kbd>Student</kbd> object based on the <kbd>rollNo</kbd> input value. However, the return type is not just in response to <kbd>Student</kbd>; instead, it is of the <kbd>Mono</kbd> type because it returns at most one element, so the <kbd>Mono</kbd> type is more appropriate.</p>
<p>The repository gives <kbd>Mono&lt;Student&gt;</kbd> based on <kbd>rollNo</kbd>; then we call the map function to map the object of the <kbd>Mono&lt;Student&gt;</kbd> type to <kbd>Mono&lt;ResponseEntity&lt;Student&gt;&gt;</kbd> , which will be then taken care of by the WebFlux framework to return the student data. Add some values directly from MongoDB and try to access it with the URLs <a href="http://localhost:8080/api/getStudent/21">http://localhost:8080/api/getStudent/21</a> (using the <kbd>8080</kbd> port, and student <kbd>rollNo</kbd> is <kbd>21</kbd>) in REST client (for example, Postman), and you will get an output as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2e5e5589-fb50-4f7f-81cf-8e3340895527.png" style="width:56.00em;height:22.00em;"/></p>
<p>In case we want to access more than one student, we need to use the <kbd>Flux</kbd> return type as it emits 0 to N elements. Let's add one more method to the controller to fetch all the students as follows:</p>
<pre>  @GetMapping("/getAllStudent")<br/>  public Flux&lt;Student&gt; getAllStudent() {<br/>    Flux&lt;Student&gt; allStudents = studentMongoRepository.findAll();<br/>    return allStudents;<br/>  }</pre>
<p>Add some more student data from MongoDB and hit the URL <a href="http://localhost:8080/api/getAllStudent">http://<span>localhost:8080/api/getAllStudent</span></a> <span>and you will see results as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2a4c5d53-2e30-4c7c-a57d-fbdc2bc1473b.png" style="width:26.25em;height:30.67em;"/></p>
<p>The WebFlux controller endpoint returns a Publisher in the form of either <kbd>Flux</kbd> or <kbd>Mono</kbd>. In the second method where we return all the students, it can be in the form of a <strong>Server-Sent Event</strong> (<strong>SSE</strong>) to the browser. For that, you need to define the return type as <kbd>text/event-stream</kbd>. The SSE is the technology allowing a browser to receive automatic updates from the server via an HTTP connection. </p>
<p>What does this mean? If we have a very huge stream, then the WebFlux controller will send the data as it receives from a reactive repository (from MongoDB in our case) and send it to the browser, instead of fetching all the records, which results in a blocking condition. This is how large volumes of streams are handled in Reactive Programming with Spring WebFlux. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional endpoint</h1>
                </header>
            
            <article>
                
<p>Spring Framework 5 supports functional programming models for reactive web applications with WebFlux. This is an alternative to using the Spring MVC-style annotated controller. The functional style programming in Spring WebFlux uses the following essential components:</p>
<ul>
<li class="mce-root"><kbd>HandlerFunction</kbd>:<strong> </strong>It is used to handle the request. It is an alternative to the Spring MVC controller handler methods and works similar to it. </li>
<li class="mce-root"><kbd>RouterFunction</kbd>:<span> It is used to route incoming HTTP requests.</span> <kbd>RouterFunction</kbd> <span>is an alternative to using request mapping with the</span> <kbd>@RequestMapping</kbd> annotation <span>and works similar to it. </span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Artifacts required in functional-style Reactive Programming </h1>
                </header>
            
            <article>
                
<p>Let's first understand these components. They are defined as an interface in Spring WebFlux. The <kbd>HandlerFunction</kbd> interface looks as follows:</p>
<pre>@FunctionalInterface<br/>public interface HandlerFunction&lt;T extends ServerResponse&gt; {<br/>  Mono&lt;T&gt; handle(ServerRequest request);<br/>}</pre>
<p>This interface is similar to the <kbd>Function&lt;T,R&gt;</kbd> type, which takes the value (of the <kbd>T</kbd>type) and returns another value (of the <kbd>R</kbd>type). In this case, it is equivalent to <kbd>Function&lt;ServerRequest,Mono&lt;T&gt;</kbd> . It is much like a servlet. The <kbd>T</kbd> type is the response type of the function that should implement the <kbd>ServerReponse</kbd> interface, which represents the server-side HTTP response.</p>
<p>The  <kbd>handle()</kbd> method takes the <kbd>ServerRequest</kbd> object type and returns a <kbd>Mono</kbd>  object type. <kbd>ServerRequest</kbd> represents the HTTP request, and we can get headers and the body of a request from this. Both <kbd>ServerRequest</kbd> and <kbd>ServerResponse</kbd> are part of the reactive API of Spring WebFlux. </p>
<p>You may notice that instead of putting both requests and responses in the same method call, the response is returned from the <kbd>handle()</kbd> method, which really makes it side-effect free and easy to test. Let's see what <kbd>RouterFunction</kbd> looks like. Again it is of the interface type as follows:</p>
<pre>@FunctionalInterface<br/>public interface RouterFunction&lt;T extends ServerResponse&gt; {<br/>  Mono&lt;HandlerFunction&lt;T&gt;&gt; route(ServerRequest request);<br/>  //.. other methods.<br/>}</pre>
<p class="mce-root">This interface has the <kbd>route()</kbd> method that returns <kbd>HandlerFunction</kbd> , which matches the given request. This method is used to create routes by applying <kbd>RequestPredicate</kbd>. When the predicate matches, it will return the handler function, which basically processes the request.  <span><kbd>RequestPredicate</kbd> is  the Java8 functional interface and part of the reactive API of Spring WebFlux. It is used to test the given <kbd>ServerRequest</kbd> for the routing and looks as follows:</span></p>
<pre>@FunctionalInterface<br/>public interface RequestPredicate {<br/>  boolean test(ServerRequest request);<br/>//Other functions<br/>}</pre>
<p>Let's create the controller in functional-style programming. We will write a controller that works exactly the same to the annotated controller but in a functional way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prerequisite for a functional approach in Spring WebFlux</h1>
                </header>
            
            <article>
                
<p>To work in functional way, the very first thing we need to do is to make our project WebFlux aware. For that we need to add the <kbd>@EnableWebFlux</kbd> annotation to the main bootstrap class as follows:</p>
<pre>@SpringBootApplication<br/><strong>@EnableWebFlux</strong><br/>public class SpringWebFluxDemoApplication {<br/> // other code ..<br/>}</pre>
<p>We also need to instruct Spring that the application is of the <kbd>reactive</kbd> type by adding the following property in the <kbd>application.properties</kbd> file:</p>
<pre>spring.main.web-application-type=reactive</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining routers and handlers</h1>
                </header>
            
            <article>
                
<p>The next part is to define the router and handler for getting the student data. Let's recall that routers are used to route the request as they serve the purpose of <kbd>@RequestMapping</kbd> in the annotated controller, while handlers actually process the incoming request, which is similar to the <span>Spring MVC c</span>ontroller handler method. The router class looks as follows:</p>
<pre>@Configuration<br/>public class StudentRouter {<br/>    @Autowired<br/>    private StudentHandler studentHandler;<br/>     @Bean<br/>      RouterFunction&lt;ServerResponse&gt; returnStudent() {<br/>          return RouterFunctions.route(RequestPredicates.GET("/api/f/getStudent/{rollNo}"),<br/>              studentHandler::getStudent);<br/>      }<br/>     @Bean<br/>      RouterFunction&lt;ServerResponse&gt; returnAllStudent() {<br/>          return RouterFunctions.route(RequestPredicates.GET("/api/f/getAllStudent"),<br/>              studentHandler::getAllStudent);<br/>      }<br/>}</pre>
<p>It is required to declare the router class with the <kbd>@Configuration</kbd> annotation so that Spring container will pick this class at the time of context loading and do the necessary configuration. We have two methods to get a single student and list of all the student data, respectively. </p>
<p class="mce-root">The router is created with the <kbd>RouterFunctions.route()</kbd> call. The <kbd>RouterFunctions</kbd> utility class has lots of useful functions. The <kbd>route()</kbd> method needs two parameters. The first parameter is of the <kbd>RequestPredicate</kbd>. type Another helper class <kbd>RequestPredicates</kbd> is used to define <span><kbd>RequestPredicate</kbd> with </span>the URL pattern for each router method. The  <kbd><span>RequestPredicate</span></kbd> class has various methods corresponding to HTTP methods.</p>
<p>We have used the <kbd>GET</kbd> method as we want to pull data from REST client with the <kbd>GET</kbd> method. The important thing here is to define any path variable along with the URL pattern that will be received in the handler to perform the necessary operations.</p>
<p>The second parameter is of the <kbd>HandlerFunction&lt;T&gt;</kbd> type, which is supplied by the corresponding method of the <kbd>StudentHandler</kbd> class. The  <kbd>studentHandler::getStudent</kbd> and <kbd>studentHandler::getAllStudent</kbd> <span> double column notations </span>will call the <kbd>getStudent()</kbd> and <kbd>getAllStudent()</kbd> methods  of the <kbd>StudentHandler</kbd> class respectively. The <kbd>StudentHandler</kbd> class should look as follows:</p>
<pre>@Component<br/>public class StudentHandler {<br/>  @Autowired<br/>  private StudentMongoRepository studentMongoRepository;<br/><br/>  public Mono&lt;ServerResponse&gt; getStudent(ServerRequest serverRequest) {<br/>    int rollNo = getInt(serverRequest.pathVariable("rollNo"));<br/>    Mono&lt;Student&gt; studentMonoObj = studentMongoRepository.findByRollNo(rollNo);<br/>    return ServerResponse.ok().body(studentMonoObj, Student.class);<br/>  }<br/>  public Mono&lt;ServerResponse&gt; getAllStudent(ServerRequest serverRequest) {<br/>    Flux&lt;Student&gt; allStudents = studentMongoRepository.findAll();<br/>    return ServerResponse.ok().body(allStudents, Student.class);<br/>  }<br/>  private int getInt(String intStr) {<br/>    int returnVal=0;<br/>    if(intStr !=null !intStr.isEmpty()) {<br/>      try {<br/>        returnVal = Integer.parseInt(intStr);<br/>      }catch(Exception e) {<br/>        e.printStackTrace();<br/>      }<br/>    }<br/>    return returnVal;<br/>  }<br/>}</pre>
<p>Each handler method will have the object of <kbd>ServerRequest</kbd> as a parameter, which will be supplied by the Spring WebFlux framework while they are called from routers. The  <span><kbd>ServerRequest</kbd> class represents the HTTP request, and we can get parameters and body out of it.</span></p>
<p>In the <kbd>getStudent()</kbd> method, we are reading the <kbd>rollNo</kbd> path variable, and passing it to the repository method to get student data. The name of the path variable here must be the same as the path variable declared as part of the URL pattern in a router (<kbd>/api/f/getStudent/{<strong>rollNo</strong>}</kbd>). Finally, the <kbd>ServerResponse</kbd> class is used to construct a response and return it. To differentiate the functional endpoint, we have updated the URL pattern (added <kbd>/f/</kbd> in between to denote its functional endpoints). You will get a similar output to the annotated controller.</p>
<p>The handler methods are not required to be defined with the <kbd>@Bean</kbd> annotation or else you will get an error while starting the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Combining handler and router</h1>
                </header>
            
            <article>
                
<p>We have written two different classes for the handler and router; however, we can declare the configuration that covers the functionality of both the router and handler in a single class. This can be done by combining the handler and router method pair in one single method as follows:</p>
<pre>@Configuration<br/>public class StudentRouterHandlerCombined {<br/><br/>  @Autowired<br/>  private StudentMongoRepository studentMongoRepository;<br/>  <br/>  @Bean<br/>  RouterFunction&lt;ServerResponse&gt; returnStudentWithCombineFun(){<br/>    <br/>        HandlerFunction&lt;ServerResponse&gt; studentHandler = <br/>                serverRequest -&gt; {<br/>                 int rollNo = getInt(serverRequest.pathVariable("rollNo"));<br/>                 return ServerResponse.ok().<br/>                    body(studentMongoRepository.findByRollNo(rollNo)<br/>                    , Student.class);<br/>             };<br/>    <br/>    RouterFunction&lt;ServerResponse&gt; studentResponse =<br/>        RouterFunctions.route(<br/>             RequestPredicates.GET("/api/f/combine/getStudent/{rollNo}"),<br/>             studentHandler);<br/>    <br/>    return studentResponse;<br/>    }<br/>  <br/>  @Bean<br/>  RouterFunction&lt;ServerResponse&gt; returnAllStudentWithCombineFun(){<br/>        HandlerFunction&lt;ServerResponse&gt; studentHandler = <br/>                serverRequest -&gt; <br/>                 ServerResponse.ok().<br/>                 body(studentMongoRepository.findAll(), Student.class);<br/>    <br/>    RouterFunction&lt;ServerResponse&gt; studentResponse =<br/>        RouterFunctions.route(<br/>            RequestPredicates.GET("/api/f/combine/getAllStudent"),<br/>            studentHandler);<br/>    <br/>    return studentResponse;<br/>    }<br/>  <br/>  private int getInt(String intStr) {<br/>    int returnVal=0;<br/>    if(intStr !=null !intStr.isEmpty()) {<br/>      try {<br/>        returnVal = Integer.parseInt(intStr);<br/>      }catch(Exception e) {<br/>        e.printStackTrace();<br/>      }<br/>    }<br/>    return returnVal;<br/>  }<br/>}</pre>
<p>This class has two methods to fetch a single student and all students, respectively. In each method, we first create an instance of the handler and then pass it into the <kbd>route()</kbd> method while creating the router. The lambda expression is used to define the handler. The code is easy and straightforward. Again to make it unique, we have changed the URL pattern by adding <kbd>/combine/</kbd> in between so the endpoints of getting a single student and all students can be accessed with the URL <a href="http://localhost:8080/api/f/combine/getStudent/21">http://localhost:8080/api/f/combine/getStudent/21</a> and <a href="http://localhost:8080/api/f/combine/getAllStudent">http://localhost:8080/api/f/combine/getAllStudent,</a> respectively. <span>You will get a similar output to when we defined handler and router separately. </span></p>
<p>You might be wondering how this works under the hood. The bean of the <kbd>RouterFunctionMapping</kbd> type scans the packages and retrieves all <kbd>RouterFunctions</kbd> at the time of starting the application. This bean is created within <kbd>WebFluxConfigurationSupport</kbd>, which is the headquarters of the Spring WebFlux configuration. All these things start happening when we define the <kbd>@EnableWebFlux</kbd> annotation to the main bootstrap class along with the <kbd>spring.main.web-application-type=reactive</kbd> property.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composite routers</h1>
                </header>
            
            <article>
                
<p>If you have lots of routers in your configuration, you can basically compose them into a chain with the <kbd>and</kbd> operator. In the previous example, we defined two routers in two different methods. This can be combined in just one method as follows:</p>
<pre>@Configuration<br/>public class StudentCompositeRoutes {<br/><br/>  @Autowired<br/>  private StudentMongoRepository studentMongoRepository;<br/><br/>  @Bean<br/>  RouterFunction&lt;ServerResponse&gt; compositeRoutes(){<br/><br/>    RouterFunction&lt;ServerResponse&gt; studentResponse =<br/>        RouterFunctions.route(RequestPredicates.<br/>            GET("/api/f/composite/getStudent/{rollNo}"),<br/>            serverRequest -&gt; {<br/>              int rollNo = getInt(serverRequest.pathVariable("rollNo"));<br/>              return ServerResponse.ok().<br/>                  body(studentMongoRepository.<br/>                      findByRollNo(rollNo), Student.class);<br/>            })<br/>        .and(<br/>            RouterFunctions.route(RequestPredicates.<br/>                GET("/api/f/composite/getAllStudent"),<br/>                serverRequest -&gt; <br/>            ServerResponse.ok().<br/>            body(studentMongoRepository.findAll(), Student.class))<br/>            );<br/><br/>    return studentResponse;<br/>  }<br/>  private int getInt(String intStr) {<br/>    int returnVal=0;<br/>    if(intStr !=null  !intStr.isEmpty()) {<br/>      try {<br/>        returnVal = Integer.parseInt(intStr);<br/>      }catch(Exception e) {<br/>        e.printStackTrace();<br/>      }<br/>    }<br/>    return returnVal;<br/>  }<br/>}</pre>
<p>The <kbd>and</kbd> operator is used to combine two routers. Also, the second parameter of the <kbd>rout()</kbd> function, which is of the  <kbd>HandlerFunction&lt;T&gt;</kbd> type, is defined with a lambda expression. This is how you can composite multiple routers in a single chain call with the <kbd>and</kbd> operator. To distinguish this feature, we again alter the endpoint URL pattern as we have added <kbd>/composite/</kbd> instead of <kbd>/combine/</kbd> to the URL pattern. Needless to say that you will get a similar output in this case as well. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebSocket support</h1>
                </header>
            
            <article>
                
<p>WebSocket is a protocol that allows full-duplex, two-way communication between a server and a client. While establishing the connection, it uses HTTP for the initial handshake. Once done, it will request a protocol upgrade. The Spring WebFlux framework supports reactive WebSocket communication between a client and server based on  the Java WebSocket API. Defining WebSocket is a two-step process as follows:</p>
<ul>
<li>Define the handler to manage the WebSocket request</li>
<li>Define mapping to access  the specific handler</li>
</ul>
<p>In WebFlux, the WebSockets are handled by implementing the <kbd>WebSocketHandler</kbd> interface. It has one method called<kbd>handle()</kbd>. It is provided with the object of <kbd>WebSocketSession</kbd> every time a connection is established to the handler. As its name suggests,  <kbd>WebSocketSession</kbd> represents the connection formed by a single client. </p>
<p>Two separate streams  accessible through the <kbd>receive()</kbd> and <kbd>send()</kbd> methods of the <kbd>Flux</kbd> type, are associated with <kbd>WebSocketSession</kbd> for handling incoming requests and outgoing messages respectively. We will first define  handler mapping as follows:</p>
<pre> @Autowired<br/> SampleWebSocketHandler studentWebSocketHandler;<br/><br/> @Bean<br/> public HandlerMapping webSockertHandlerMapping() {<br/>   Map&lt;String, WebSocketHandler&gt; map = new HashMap&lt;&gt;();<br/>   map.put("/student", studentWebSocketHandler);<br/><br/>   SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();<br/>   mapping.setUrlMap(map);<br/>   return mapping;<br/> }<br/> @Bean<br/> public WebSocketHandlerAdapter handlerAdapter() {<br/>   return new WebSocketHandlerAdapter();<br/> }</pre>
<p>The <kbd>@Bean</kbd> annotated method <kbd>webSockertHandlerMapping</kbd> is used to map our custom handler with a specific URL pattern by which it can be accessible. The <kbd>SampleWebSocketHandler</kbd> <span> custom handler </span>is injected with the <kbd>@Autowired</kbd> annotation and looks as follows:</p>
<pre>@Component<br/>public class SampleWebSocketHandler implements WebSocketHandler{<br/><br/>  private ObjectMapper objMapper = new ObjectMapper();<br/>  <br/>  @Autowired<br/>  StudentMongoRepository studentMongoRepository;<br/>  <br/>  @Override<br/>  public Mono&lt;Void&gt; handle(WebSocketSession webSocketSession) {<br/>    Flux&lt;Student&gt; allStudentSource = studentMongoRepository.findAll();<br/>    System.out.println(" ****** Incoming messages ****** ");<br/>    webSocketSession.receive().subscribe(System.out::println);<br/>    <br/>    System.out.println(" ****** Sending Student data ****** ");<br/>    return webSocketSession.send(allStudentSource.map(student-&gt;{<br/>      return writeValueAsSTring(student);<br/>     }).map(webSocketSession::textMessage)<br/>     );<br/>  }<br/><br/>  private String writeValueAsSTring(Object obj) {<br/>    try {<br/>      return objMapper.writeValueAsString(obj);<br/>    } catch (JsonProcessingException e) {<br/>      e.printStackTrace();<br/>    }<br/>    return "No data";<br/>  }<br/>}</pre>
<p>The  <kbd>SampleWebSocketHandler</kbd> class provides an implementation of the <kbd>WebSocketHandler</kbd> interface with the <kbd>handle()</kbd> method. In that method, we are simply fetching all student data from <kbd>StudentMongoRepository</kbd> and calling the <kbd>send()</kbd> method on <kbd>WebSocketSession</kbd>. In the <kbd>send()</kbd> method, we first convert the <kbd>Student</kbd> object to JSON string with <kbd>ObjectMapper</kbd> and finally call the <kbd>textMessage()</kbd> method of <span><kbd>WebSocketSession</kbd> to convert it to <kbd>WebSocketMessage</kbd>.</span></p>
<p>Next, is to create the client. We will write client code in JavaScript and call the server from the browser to see how the stream data is received one by one. You can create one HTML file with the following code.</p>
<pre>&lt;html&gt;<br/>  &lt;body&gt;<br/>    Hello<br/>  &lt;/body&gt;<br/>  &lt;script&gt;<br/>      var socket = new WebSocket('ws://localhost:8080/student');<br/>      socket.addEventListener('message', function (event) {<br/>      window.alert('message from server: ' + event.data);<br/>      });<br/>  &lt;/script&gt;<br/>&lt;/html&gt;</pre>
<p>Almost all modern browsers support WebSocket communication. Open this HTML in a browser and you will see student data one by one with a browser alert. This is how WebSocket communication happens in the reactive paradigm of Spring WebFlux. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Reactive is definitely a promising new technology that will help to build a scalable and high-performance application. Spring has done an impressive job of supporting Reactive Systems with a new framework called WebFlux. Reactive is the future of next-generation applications, and it is needed almost everywhere: datastores, middle layers, frontends, or even mobile platforms.</p>
<p>Through this chapter, we learned the basics of Reactive Systems and Reactive Programming followed by various techniques to achieve it. We then learned about Reactive Streams, which is one of the most popular ways of implementing a Reactive System. Starting with the Reactive Streams specifications and the basic fundamentals, we explored various JVM-based libraries that provide an implementation for a particular specification. We did some hands-on work with RxJava and Project Reactor and learned the underlying principles. </p>
<p class="mce-root">In the same direction, we have seen how the Spring Framework provides support in a reactive paradigm. We have then explored the Spring WebFlux framework by creating a Spring Boot-based web application. Apart from annotated based support for WebFlux, which is like Spring MVC, Spring also supports creating Reactive Systems with functional programming paradigms. We explored various options in functional programming with a series of examples.</p>
<p class="mce-root">To gain full advantage of the reactive capability of Spring WebFlux, the data store should also support Reactive Programming, and that was the reason we chose MongoDB as a datastore, and we learned how to configure it in a web application with the Spring Boot tool. </p>
<p>It has been a very exciting journey so far, and we will continue our journey in the next chapter by exploring the interesting topic of the integration of Elasticsearch with the Spring Framework. We will develop a sample application called <strong>Blogpress</strong>. We will also look in more detail at Spring Boot, Thymeleaf, and so on; stay tuned and ready to explore further in the next chapter.</p>


            </article>

            
        </section>
    </body></html>