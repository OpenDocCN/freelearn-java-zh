<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Getting Started with the Play Framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Getting Started with the Play Framework</h1></div></div></div><p>This chapter commences our journey into web development in Scala. Web development has become an area where the choice of architectures and frameworks is tremendous. Finding the right tool for the job is not always a straightforward task as it ranges from traditional Java EE or Spring-based architectural styles to more recent Ruby on Rails-like approaches. Most of the existing solutions still rely on the adoption of the servlet-container model, whether they use lightweight containers such as Jetty/Tomcat or support <span class="strong"><strong>EJBs</strong></span> (<span class="strong"><strong>Enterprise JavaBeans</strong></span>) <a id="id247" class="indexterm"/>such as JBoss, Glassfish, WebSphere, or WebLogic. Many online articles and conference talks have tried to compare some of the alternatives, and as these frameworks evolve rapidly and sometimes focus on different aspects (such as frontend versus backend), compiling a fair and accurate list remains difficult. In the Scala world, alternatives to create web applications range from lightweight frameworks such as Unfiltered, Spray, or Scalatra to full-featured solutions such as the Lift or the Play Frameworks.</p><p>We have chosen to concentrate on the <a id="id248" class="indexterm"/>Play Framework, because it embraces important features that we think are the key to maintainable, modern software development. Some of the advantages of the Play Framework are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Play Framework is scalable and robust. It can handle large loads because it is built on a fully asynchronous model on the top of technologies that are ready to handle multicore architectures such as Akka, a framework to build concurrent and distributed applications that we will cover in <a class="link" href="ch08.html" title="Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency">Chapter 8</a>, <span class="emphasis"><em>Essential Properties of Modern Applications – Asynchrony and Concurrency</em></span>.</li><li class="listitem" style="list-style-type: disc">It provides us with enhanced developer productivity by promoting ease of use, promoting the <span class="strong"><strong>DRY</strong></span> (short for <span class="strong"><strong>Don't Repeat Yourself</strong></span>) <a id="id249" class="indexterm"/>principle, and taking advantage of the expressiveness and conciseness of Scala. In addition to that, the hit refresh workflow of Play by which you can simply refresh your browser and get instant feedback on the changes you make is a real boost in the productivity, in contrast with the longer deployment cycles of the Java servlet and EJB containers.</li><li class="listitem" style="list-style-type: disc">It provides good integration with the existing legacy of infrastructure based on the JVM.</li><li class="listitem" style="list-style-type: disc">It provides good integration with modern, client-side development trends that heavily rely on JavaScript/CSS and their surrounding ecosystem, including frameworks such as AngularJS or WebJars. Moreover, the <span class="strong"><strong>LESS</strong></span> (short for <span class="strong"><strong>Leaner CSS</strong></span>) dynamic <a id="id250" class="indexterm"/>stylesheet language as well as CoffeeScript, a small and elegant language that compiles to JavaScript, are supported by Play Framework without any additional integration.</li></ul></div><p>The Play Framework Version 2.<span class="emphasis"><em>x</em></span> <a id="id251" class="indexterm"/>exists both for Java and Scala, which is an additional strength as Java developers will probably get acquainted with the differences more quickly and may have previous experience with the Java version before moving on to Scala.</p><p>Several alternatives are offered to rapidly get you started with the Play Framework and create a minimalistic <code class="literal">helloworld</code> project. Note that all these alternatives create projects based on SBT, as we mentioned briefly in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>.</p><div class="section" title="Getting started with the classic Play distribution"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Getting started with the classic Play distribution</h1></div></div></div><p>Download the <a id="id252" class="indexterm"/>classic Play distribution from <a class="ulink" href="http://www.playframework.com/download">http://www.playframework.com/download</a>, and unpack the <code class="literal">.zip</code> archive in a directory of your choice. Add this directory to your path (so that running the <code class="literal">play</code> command anywhere on your <a id="id253" class="indexterm"/>filesystem will create a new application). With this alternative, you can open a terminal window and enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play new &lt;PROJECT_NAME&gt;   (for example  play new playsample)</strong></span>
</pre></div><p>The following output will be displayed:</p><div class="mediaobject"><img src="graphics/3637OS_05_01.jpg" alt="Getting started with the classic Play distribution"/></div><p>We just need to press <span class="emphasis"><em>Enter</em></span> as we have already given a project name on the previous command. The following will be displayed on pressing <span class="emphasis"><em>Enter</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Which template do you want to use for this new application? </strong></span>
<span class="strong"><strong>  1             - Create a simple Scala application</strong></span>
<span class="strong"><strong>  2             - Create a simple Java application</strong></span>
<span class="strong"><strong>&gt; 1</strong></span>
<span class="strong"><strong>OK, application playsample is created.</strong></span>

<span class="strong"><strong>Have fun!</strong></span>
</pre></div><p>That's all; in less than a minute, we already have a fully working web app that we can now execute. As it is an SBT project (where the <code class="literal">sbt</code> command has been renamed <code class="literal">play</code> instead), we can just navigate to the root of the created project and start our Play session as if we were working on an SBT project. <a id="id254" class="indexterm"/>This is done as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; cd playsample</strong></span>
<span class="strong"><strong>&gt; play run</strong></span>
<span class="strong"><strong>[info] Loading project definition…</strong></span>
<span class="strong"><strong>--- (Running the application from SBT, auto-reloading is enabled) ---</strong></span>

<span class="strong"><strong>[info] play - Listening for HTTP on /0:0:0:0:0:0:0:0:9000</strong></span>

<span class="strong"><strong>(Server started, use Ctrl+D to stop and go back to the console...)</strong></span>
</pre></div><p>Notice that the application is started on port 9000 by default. If you want a different port, you can type the following command instead:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play</strong></span>
</pre></div><p>This will bring you to the Play (SBT) session, and from there, you can choose the port to listen to. This can be done as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[playsample] $ run 9095</strong></span>
<span class="strong"><strong>[info] play - Listening for HTTP on /0:0:0:0:0:0:0:0:9095</strong></span>
</pre></div><p>Another alternative is to enter <code class="literal">&gt; play "run 9095"</code> in the terminal.</p><p>Launch a browser at <code class="literal">http://localhost:9095/</code> (9000 if you are running using the default port), and you should see the <a id="id255" class="indexterm"/>
<span class="strong"><strong>Welcome to Play</strong></span> page on your running portal:</p><div class="mediaobject"><img src="graphics/3637OS_05_02.jpg" alt="Getting started with the classic Play distribution"/></div></div></div>
<div class="section" title="Getting started with the Typesafe Activator"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Getting started with the Typesafe Activator</h1></div></div></div><p>Using the same method that we <a id="id256" class="indexterm"/>used earlier in the book to create projects based on the Activator templates, getting started with a Play project through the Activator is very straightforward. Just go to the Typesafe Activator installation directory and enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ./activator ui</strong></span>
</pre></div><p>This will launch the activator in a browser window. The most basic Scala Play project is found in the <code class="literal">hello-play-scala</code> template. Once you have selected the template, notice the default location that indicates where the project will be created and then click on <span class="strong"><strong>Create</strong></span>.</p><p>Let's run our sample project either directly from the activator browser view or from a terminal window by navigating to the root directory of the created project and entering the following command in the command prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ./activator run</strong></span>
</pre></div><p>Once the server is listening on port 9000, you can open the <code class="literal">http://localhost:9000/</code> URL in a browser. Compilation is triggered only once you access the URL, so it may take a few seconds for the application to show up. What should come up in your browser is similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_05_03.jpg" alt="Getting started with the Typesafe Activator"/></div></div>
<div class="section" title="Architecture of a Play application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Architecture of a Play application</h1></div></div></div><p>To perceive in a better way how a <a id="id257" class="indexterm"/>Play application is built, we first need to understand a few of its architectural aspects.</p><div class="section" title="Visualizing the framework stack"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec37"/>Visualizing the framework stack</h2></div></div></div><p>Before we start <a id="id258" class="indexterm"/>exploring the code behind a typical sample Play application, let's visualize the architecture of the framework using a couple of <a id="id259" class="indexterm"/>diagrams. First, the overall diagram of the technology stack composed of Play is shown as follows:</p><div class="mediaobject"><img src="graphics/3637OS_05_12.jpg" alt="Visualizing the framework stack"/></div><p>On top of the JVM resides the Akka Framework, a framework to manage concurrent operations based on the actor model, which we will cover later in <a class="link" href="ch08.html" title="Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency">Chapter 8</a>, <span class="emphasis"><em>Essential Properties of Modern Applications – Asynchrony and Concurrency</em></span>. While most web frameworks today still rely on servlet containers such as Tomcat or JBoss, the novelty of Play is to avoid following this model by focusing on making applications stateless when code can be <span class="strong"><strong>hot swapped</strong></span>, <a id="id260" class="indexterm"/>that is, replaced at runtime. Although widely used and deployed in commercial environments, servlet containers suffer from additional overheads, such as the one thread per request problem, which can limit the scalability when handling large loads. For a developer, the time gained by avoiding the redeployment of a partial or full <code class="literal">.ear</code> or <code class="literal">.war</code> archive every time a change in the code is made can be significant.</p><p>On top of Akka resides a REST/HTTP integration layer, based on Spray (an open source toolkit to build REST/HTTP-based integration layers, now called Akka-Http), which produces and consumes embeddable REST services. This makes Play pertinent to the modern ways of writing web applications, where the backend and frontend communicate through HTTP REST services, exchanging mostly JSON/XML messages that can be rendered as HTML5 and, therefore, embrace the full power of frontend JavaScript frameworks.</p><p>Finally, to be able to integrate with many other technologies of all kinds, such as relational or NoSQL-based databases, security frameworks, social networks, cloud-based or Big Data solutions, a large list of <a id="id261" class="indexterm"/>Play plugins and modules are <a id="id262" class="indexterm"/>listed at <a class="ulink" href="http://www.playmodules.net">http://www.playmodules.net</a>.</p></div><div class="section" title="Exploring the request-response lifecycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Exploring the request-response lifecycle</h2></div></div></div><p>Play follows the <a id="id263" class="indexterm"/>well-known MVC pattern, and the <a id="id264" class="indexterm"/>lifecycle of the web request can be seen as follows:</p><div class="mediaobject"><img src="graphics/3637OS_05_05.jpg" alt="Exploring the request-response lifecycle"/></div><p>To go through the various steps of this workflow, we are going to explore a sample <code class="literal">helloworld</code> application that is part of the Play distribution. This <code class="literal">helloworld</code> application is a little more sophisticated and, therefore, more interesting than the pure getting started examples that we launched previously either via the Typesafe Activator or the plain <code class="literal">&gt; play new &lt;project&gt;</code> command to create a project from scratch.</p><p>The <code class="literal">helloworld</code> application that we consider here can be found under the <code class="literal">&lt;play installation root&gt;/samples/scala/helloworld</code> directory (we have used the Play 2.2.1 distribution at the time of this writing).</p><p>As for any Play project within the distribution that already contains the <code class="literal">sbteclipse</code> plugin, we can directly generate Eclipse-related files by entering the following command in a command prompt (at the level of the project root directory):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play eclipse</strong></span>
</pre></div><p>Note that as Play commands are just a thin layer on the top of SBT, we can reuse the same syntax, that is, <code class="literal">&gt; play eclipse</code> rather than <code class="literal">&gt; sbt eclipse</code>. Once these are imported into the IDE, you can <a id="id265" class="indexterm"/>see the general source layout of a Play application in the <span class="strong"><strong>Package Explorer</strong></span> panel on the left-hand side, as shown <a id="id266" class="indexterm"/>in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_05_06.jpg" alt="Exploring the request-response lifecycle"/></div><p>Let's first run the application to see what it looks like using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play run</strong></span>
</pre></div><p>Open a browser at <code class="literal">http://localhost:9000/</code> and you should see a small web form similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_05_07.jpg" alt="Exploring the request-response lifecycle"/></div><p>Enter the required information and <a id="id267" class="indexterm"/>click on <span class="strong"><strong>Submit</strong></span> to verify that you get your name displayed a specified number of times.</p><p>The first step in the request flow <a id="id268" class="indexterm"/>appears in the <code class="literal">conf/routes</code> file, which is shown as follows:</p><div class="informalexample"><pre class="programlisting"># Routes
# This file defines all application routes (Higher priority routes first)
# ~~~~

# Home page
GET    /              controllers.Application.index

# Hello action
GET    /hello         controllers.Application.sayHello

# Map static resources from the /public folder to the /assets URL path
GET    /assets/*file  controllers.Assets.at(path="/public", file)</pre></div><p>This is the place where we can define a mapping between HTTP request URLs and the controller code that needs to handle the request on the Play server, shown in the following format:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;REQUEST_TYPE(GET, POST...)&gt; &lt;URL_RELATIVE_PATH&gt; &lt;CONTROLLER_METHOD&gt;</strong></span>
</pre></div><p>For instance, accessing the <code class="literal">http://localhost:9000/hello</code> URL in the browser matches the following route:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>GET  /  controllers.Application.index</strong></span>
</pre></div><p>The <code class="literal">index</code> method, <a id="id269" class="indexterm"/>taking no arguments, will be called on the <code class="literal">controller.Application.scala</code> class.</p><p>This way of presenting the routing of the URLs to the controllers is different from the standard Java way found, for instance, <a id="id270" class="indexterm"/>in JAX-RS or Spring MVC, <a id="id271" class="indexterm"/>where each controller is annotated instead. In our opinion, the routing file approach gives us a clear overview of what the API supports, that is, the documentation, and it makes a Play application RESTful by default.</p><p>Even if it seems that the <code class="literal">routes</code> file is a configuration file, it is indeed compiled and any typo or reference to a nonexistent controller method will be quickly identified. Replace <code class="literal">controllers.Application.index</code> with <code class="literal">controllers.Application.wrongmethod</code>, save the file, and just click on the reload button in the browser (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>R</em></span>). You should get the error nicely displayed in the browser, as seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_05_08.jpg" alt="Exploring the request-response lifecycle"/></div><p>Notice how precise the error message is and how the exact failing line in the file is pointed out. This great way to display error messages on reloading the browser is one of the many features that makes <a id="id272" class="indexterm"/>programmers more productive. Similarly, even if there is no mapping error in the routes file, accessing a nonmapped URL that is under development (such as <code class="literal">http://localhost:9000/hi)</code> will display an error as well as the content of the <code class="literal">routes</code> file to show us which <a id="id273" class="indexterm"/>URLs are possible to invoke. This can be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_05_09.jpg" alt="Exploring the request-response lifecycle"/></div></div><div class="section" title="Handling a request in the controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec39"/>Handling a request in the controller</h2></div></div></div><p>Moving on, let's <a id="id274" class="indexterm"/>take a look at the <code class="literal">Application</code> class that receives and processes the <code class="literal">GET</code> request:</p><div class="informalexample"><pre class="programlisting">object Application extends Controller {
  /**
   * Describes the hello form.
   */
  val helloForm = Form(
    tuple(
      "name" -&gt; nonEmptyText,
      "repeat" -&gt; number(min = 1, max = 100),
      "color" -&gt; optional(text)
    )
  )

  // -- Actions
  /**
   * Home page
   */
  def index = Action {
    Ok(html.index(helloForm))
  }

  /**
   * Handles the form submission.
   */
  def sayHello = Action { implicit request =&gt;
    helloForm.bindFromRequest.fold(
      formWithErrors =&gt; BadRequest(html.index(formWithErrors)),
      {case (name, repeat, color) =&gt; Ok(html.hello(name, repeat.toInt, color))}
    )
  }
}</pre></div><p>The <code class="literal">index</code> method performs the <code class="literal">Action</code> block, which is a function (<code class="literal">Request[AnyContent] =&gt; Result</code>), that takes the request and returns a <code class="literal">Result</code> object. The input parameter of the <code class="literal">Request</code> type is not shown here in the <code class="literal">index</code> method as it is implicitly passed and <a id="id275" class="indexterm"/>we are not using it in the body of the function; we could have written <code class="literal">def index = Action { implicit request =&gt;</code> instead, if we wanted to. The one liner <code class="literal">Ok(html.index(helloForm))</code> means that the returned result should have an HTTP status equal to 200, that is, <code class="literal">Ok</code>, and consist of binding the <code class="literal">html.index</code> view to the <code class="literal">helloForm</code> model.</p><p>The model in this tiny example consists of a <code class="literal">Form</code> object defined in <code class="literal">val</code> earlier in the file. This can be seen as follows:</p><div class="informalexample"><pre class="programlisting">val helloForm = Form(
  tuple(
    "name" -&gt; nonEmptyText,
    "repeat" -&gt; number(min = 1, max = 100),
    "color" -&gt; optional(text)
  )
)</pre></div><p>Each parameter is described as a <code class="literal">key -&gt; value</code> pair, where <code class="literal">key</code> is the name of the parameter and <code class="literal">value</code> is the result of a function applied to the parameter that will produce a <code class="literal">play.api.data.Mapping</code> object. Such mapping functions are very useful to be able to perform a validation on the form parameters. Here, the <code class="literal">Form</code> parameters are expressed as a tuple object, but we could create more complex objects such as case classes. The sample project named <span class="emphasis"><em>forms</em></span> in the Play distribution contains examples of this more advanced way of handling validation. The <code class="literal">fold</code> method encountered in the <code class="literal">sayHello</code> method of the controller is a way to accumulate validation errors to be able to report all of these errors at once. Let's enter a <a id="id276" class="indexterm"/>few mistakes (such as leaving the <code class="literal">name</code> field blank or entering characters when numbers are required) when filling out the form to verify how errors are displayed. This can be seen <a id="id277" class="indexterm"/>in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_05_10.jpg" alt="Handling a request in the controller"/></div></div><div class="section" title="Rendering the view"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec40"/>Rendering the view</h2></div></div></div><p>The template <a id="id278" class="indexterm"/>used to render the <a id="id279" class="indexterm"/>view is found under the <code class="literal">views/index.scala.html</code> file.<code class="literal"> </code>This template is shown as follows:</p><div class="informalexample"><pre class="programlisting">@(helloForm: Form[(String,Int,Option[String])])
@import helper._

@main(title = "The 'helloworld' application") {

    &lt;h1&gt;Configure your 'Hello world':&lt;/h1&gt;

    @form(action = routes.Application.sayHello, args = 'id -&gt; "helloform") {
        @inputText(
            field = helloForm("name"),
            args = '_label -&gt; "What's your name?", 'placeholder -&gt; "World"
        )

        @inputText(
            field = helloForm("repeat"),
            args = '_label -&gt; "How many times?", 'size -&gt; 3, 'placeholder -&gt; 10
        )

        @select(
            field = helloForm("color"), 
            options = options(
                "" -&gt; "Default",
                "red" -&gt; "Red",
                "green" -&gt; "Green",
                "blue" -&gt; "Blue"
            ),
            args = '_label -&gt; "Choose a color"
        )

        &lt;p class="buttons"&gt;
            &lt;input type="submit" id="submit"&gt;
        &lt;p&gt;
    }
}</pre></div><p>One of the strengths of the Play template engine is that it is based on the Scala language itself. This is good news because we do not need to learn any new templating syntax; we can reuse the Scala constructs, without any additional integration. Moreover, the templates are compiled so that we get <a id="id280" class="indexterm"/>compile-time errors whenever we make a mistake; the errors will show up in the browser in the same way that they showed up for routes or the plain controller Scala code. This fast feedback can save us a lot of time <a id="id281" class="indexterm"/>compared to the more traditional techniques of using <a id="id282" class="indexterm"/>
<span class="strong"><strong>JSPs</strong></span> (<span class="strong"><strong>JavaServer Pages</strong></span>) in Java web development.</p><p>The declarations at the top of the template contain the bound variables that will be populated throughout the template. The template markup can produce an output of any kind, such as HTML5, XML, or plain text. <a id="id283" class="indexterm"/>Templates can also include other templates.</p><p>In the previous example, the <code class="literal">@main(title = "The 'helloworld' application"){ &lt;block&gt; ...} </code>statement refers to the <code class="literal">main.scala.html</code> view file itself, displayed as follows:</p><div class="informalexample"><pre class="programlisting">@(title: String)(content: Html)

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;@title&lt;/title&gt;
        &lt;link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/main.css")"&gt;
        &lt;link rel="shortcut icon" type="image/png" href="@routes.Assets.at("images/favicon.png")"&gt;
        &lt;script src="@routes.Assets.at("javascripts/jquery-1.6.4.min.js")" type="text/javascript"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;a href="@routes.Application.index"&gt;@title&lt;/a&gt;
        &lt;/header&gt;

        &lt;section&gt;
            @content
        &lt;/section&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>As you can see, <code class="literal">@(title: String)(content: Html)</code> at the top of this file matches <code class="literal">(title = "The 'helloworld' application"){ &lt;block of template with code&gt; ...}</code> from the previous template. This is how templates call each other.</p><p>The <code class="literal">@</code> sign indicates <a id="id284" class="indexterm"/>that the Scala code follows either directly with the name of a variable or a method to be invoked, or with a full block of code given between brackets, that is, <code class="literal">@{ …code … }</code>.</p><p>The response (<code class="literal">views/hello.scala.html</code>) template, once the web form has been submitted, contains a <code class="literal">for</code> loop to <a id="id285" class="indexterm"/>display the <code class="literal">name</code> field a number of times. This is shown as follows:</p><div class="informalexample"><pre class="programlisting">@(name: String, repeat: Int, color: Option[String])
@main("Here is the result:") {
    &lt;ul style="color: @color.getOrElse("inherited")"&gt;
        <span class="strong"><strong>@for(_ &lt;- 1 to repeat) {</strong></span>
<span class="strong"><strong>            &lt;li&gt;Hello @name!&lt;/li&gt;</strong></span>
<span class="strong"><strong>        }</strong></span>
    &lt;/ul&gt;
    &lt;p class="buttons"&gt;
        &lt;a href="@routes.Application.index"&gt;Back to the form&lt;/a&gt;
    &lt;/p&gt;
}</pre></div></div></div>
<div class="section" title="Playing with authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Playing with authentication</h1></div></div></div><p>A frequent piece of functionality <a id="id286" class="indexterm"/>needed when designing a new web application involves authentication and authorization. Authentication usually requires that the user provide the credentials to log in to the application in the form of a username/password. Authorization is the mechanism by which the system can ensure that a user can perform only the operations that he/she is entitled to. In this section, we are going to extend our <code class="literal">helloworld</code> sample with security features that are part of the Play distribution, as a way to demonstrate how the usage of traits in Scala can provide an elegant solution to conventional problems.</p><p>Let's define a new controller that we will call <code class="literal">Authentication</code>, which contains common methods such as <code class="literal">login</code> to retrieve a sign-in page, <code class="literal">authenticate</code> and <code class="literal">check</code> to perform the verification of the authentication, and <code class="literal">logout</code> to go back to the login page. This is done as follows:</p><div class="informalexample"><pre class="programlisting">object Authentication extends Controller {

  val loginForm = Form(
    tuple(
      "email" -&gt; text,
      "password" -&gt; text
    ) verifying ("Invalid email or password", result =&gt; result match {
      case (email, password) =&gt; check(email, password)
    })
  )

  def check(username: String, password: String) = {
    (username == "thomas@home" &amp;&amp; password == "1234")  
  }

  def login = Action { implicit request =&gt;
    Ok(html.login(loginForm))
  }

  def authenticate = Action { implicit request =&gt;
    loginForm.bindFromRequest.fold(
      formWithErrors =&gt; BadRequest(html.login(formWithErrors)),
      user =&gt; Redirect(routes.Application.index).withSession(Security.username -&gt; user._1)
    )
  }

  def logout = Action {
    Redirect(routes.Authentication.login).withNewSession.flashing(
      "success" -&gt; "You are now logged out."
    )
  }
}</pre></div><p>Similar to the <code class="literal">index</code> method that <a id="id287" class="indexterm"/>belongs to the <code class="literal">Application</code> controller from the previous section, the <code class="literal">login</code> <a id="id288" class="indexterm"/>method here consists of binding a form (named <code class="literal">loginForm</code>) to a view (named <code class="literal">html.login</code>, corresponding to the file <code class="literal">views/login.scala.html</code>). A simple template for a view that consists <a id="id289" class="indexterm"/>of two text fields to capture an e-mail/username and password is shown as follows:</p><div class="informalexample"><pre class="programlisting">@(form: Form[(String,String)])(implicit flash: Flash)

@main("Sign in") {
        
        @helper.form(routes.Authentication.authenticate) {
            
            @form.globalError.map { error =&gt;
                &lt;p class="error"&gt;
                    @error.message
                &lt;/p&gt;
            }
            
            @flash.get("success").map { message =&gt;
                &lt;p class="success"&gt;
                    @message
                &lt;/p&gt;
            }
            
            &lt;p&gt;
                &lt;input type="email" name="email" placeholder="Email" id="email" value="@form("email").value"&gt;
            &lt;/p&gt;
            &lt;p&gt;
                &lt;input type="password" name="password" id="password" placeholder="Password"&gt;
            &lt;/p&gt;
            &lt;p&gt;
                &lt;button type="submit" id="loginbutton"&gt;Login&lt;/button&gt;
            &lt;/p&gt;
            
        }
        
        &lt;p class="note"&gt;
            Try login as &lt;em&gt;thomas@@home&lt;/em&gt; with &lt;em&gt;1234&lt;/em&gt; as password.
        &lt;/p&gt;
            
}</pre></div><p>Notice how the <code class="literal">thomas@@home</code> username shows us that you can escape the special <code class="literal">@</code> character by entering it twice.</p><p>Now we have the logic to handle an HTML login page with the submission of the credentials to be authenticated, but we are still lacking the missing piece that will wrap a conventional invocation of a method from any controller that we want to protect. Moreover, this logic will redirect us to the <a id="id290" class="indexterm"/>login page in case the username (a property stored in our <code class="literal">request.session</code> object and retrieved from a cookie) is not present. It can be described in a trait as follows:</p><div class="informalexample"><pre class="programlisting">trait Secured {

  def username(request: RequestHeader) = request.session.get(Security.username)

  def onUnauthorized(request: RequestHeader) = Results.Redirect(routes.Authentication.login)

  def withAuth(f: =&gt; String =&gt; Request[AnyContent] =&gt; SimpleResult) = {
    Security.Authenticated(username, onUnauthorized) { user =&gt;
      Action(request =&gt; f(user)(request))
    }
  }
}</pre></div><p>We can add this trait to the same <code class="literal">Authentication.scala</code> controller class. The <code class="literal">withAuth</code> method wraps our <code class="literal">Action</code> invocations by applying the <code class="literal">Security.Authenticated</code> method around them. To be able to use this trait, we just need to mix it in in our controller class as follows:</p><div class="informalexample"><pre class="programlisting">object Application extends Controller <span class="strong"><strong>with Secured</strong></span> {
  …
}</pre></div><p>Once the trait is part of our controller, we can replace an <code class="literal">Action</code> method with a <code class="literal">withAuth</code> method instead. For example, <a id="id291" class="indexterm"/>when invoking the <code class="literal">index</code> method, we replace the <code class="literal">Action</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * Home page
 */
def index = <span class="strong"><strong>withAuth</strong></span> { username =&gt; implicit request =&gt;
  Ok(html.index(helloForm))
}</pre></div><p>To be able to execute our new functionality, we should not forget to add the extra methods from the <code class="literal">Authentication.scala</code> controller to the routes' definitions (the compiler will flag this if we omit them):</p><div class="informalexample"><pre class="programlisting"># Authentication
GET    /login    controllers.Authentication.login
POST   /login    controllers.Authentication.authenticate
GET    /logout   controllers.Authentication.logout</pre></div><p>Let's rerun the application and invoke the <code class="literal">http://localhost:9000/</code> page. We should be routed to the <code class="literal">login.html</code> page rather than the <code class="literal">index.html</code> page. This is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_05_11.jpg" alt="Playing with authentication"/></div><p>Try to log in with both the erroneous and correct e-mail/password combinations to verify that the authentication has been implemented correctly.</p><p>This basic authentication mechanism is just an example of how you can easily extend the applications in Play. It demonstrates the use of the Action composition, a technique that can also be applied to many other aspects—for example, logging or modifying requests—and is a good alternative to interceptors.</p><p>There are, of course, external modules <a id="id292" class="indexterm"/>that you can use with Play if you need to achieve authentication through other services; for instance, modules based on standards such as OAuth, OAuth2, or OpenID. The SecureSocial module is a good example to do this and is available at <a class="ulink" href="http://securesocial.ws">http://securesocial.ws</a>.</p></div>
<div class="section" title="Practical tips when using Play"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Practical tips when using Play</h1></div></div></div><p>We will conclude this chapter with a <a id="id293" class="indexterm"/>couple of recommendations that will help with the daily usage of the Play Framework.</p><div class="section" title="Debugging with Play"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec41"/>Debugging with Play</h2></div></div></div><p>Due to the declarative nature of <a id="id294" class="indexterm"/>functional programming and the powerful type checking mechanism of the compiler, debugging should happen less often when dealing with Scala code. However, if you need to debug a Play application in a situation, you might as well run a remote debugging session as you would in Java. To achieve this, just start your Play application with an extra debug command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play debug run</strong></span>
</pre></div><p>You should see an extra information line in the output that displays the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Listening for transport dt_socket at address: 9999</strong></span>
</pre></div><p>From here, you can add break points in your code and start a remote debugging configuration in Eclipse by navigating to the menu named <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Debug Configurations…</strong></span>
</p><p>Right-click on <span class="strong"><strong>Remote Java Application</strong></span> and select <span class="strong"><strong>New</strong></span>. Just make sure that you enter <code class="literal">Port:9999</code> in the <span class="strong"><strong>Connection Properties</strong></span> <a id="id295" class="indexterm"/>form and then start debugging by clicking on the <span class="strong"><strong>Debug</strong></span> button.</p></div><div class="section" title="Dealing with version control"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Dealing with version control</h2></div></div></div><p>Typical files that can be ignored <a id="id296" class="indexterm"/>when maintaining the code under version control tools such as GIT are located as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">logs</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">project/project</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">project/target</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">target</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">tmp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">dist</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">.cache</code></li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we introduced the Play Framework and covered typical examples where requests are routed to controllers and rendered through views following the well-known MVC pattern. We saw that the usage of the Scala syntax inside the definition of routes and templates gives us the extra benefit of compile-time safety. Such help provided to the programmer largely increases productivity and avoids spelling mistakes while refactoring, making the whole experience more enjoyable.</p><p>We also added some basic HTTP authentication to a <code class="literal">helloworld</code> application sample. In the next chapter, we are going to tackle the issue of Persistence/ORM, a part that is essential in any web application, involving the usage of a database in the backend to store and retrieve data. We will see how to integrate the existing persistence standards used in Java, such as JPA, and will introduce a novel but powerful approach to Persistence through the Slick framework.</p></div></body></html>