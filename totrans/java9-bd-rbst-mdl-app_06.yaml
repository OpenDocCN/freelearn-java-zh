- en: Migrating Applications to Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took a close look at the structure of Java modules
    as specified by Project Jigsaw and examined how Project Jigsaw was implemented
    to improve the Java platform. We also reviewed key internal changes to the Java
    platform with specific focus on the new modular system. We started with a modular
    primer where we learned about Java 9's modular system in terms of benefits and
    requirements. Next, we explored how Java 9 introduced modularity to the JDK. This
    included a look at how the source code was reorganized for Java 9\. We also explored
    the JDK's seven primary tool categories and learned that Java 9 modularity extends
    to runtime images resulting in more maintainability, better performance, and increased
    security. The concept of **link time** was introduced as an optional phase between
    compile-time and runtime. We concluded the chapter with a look at the **Java linker**
    and how Java 9 encapsulates internal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how to migrate our existing applications to
    the Java 9 platform. We will look at both manual and semi-automated migration
    processes. Java 9 is a major release with numerous changes to the JDK so developers
    should not be surprised if their Java 8 code no longer works with Java 9\. This
    chapter aims to provide you with insights and processes to get your Java 8 code
    working with Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Quick review of Project Jigsaw
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How modules fit into the Java landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migration planning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advice from Oracle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick review of Project Jigsaw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project Jigsaw is the Java project that encompasses several change recommendations
    to the Java platform. As you have read in earlier chapters, Java 9''s greatest
    changes involve modules and modularity. The initiative to move to modules in Java
    was driven by Project Jigsaw. The need for modularity stemmed from two major challenges
    with Java:'
  prefs: []
  type: TYPE_NORMAL
- en: Classpath
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will review both of those challenges and see how they were addressed
    and overcome with the new release to the Java platform, Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Classpath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to Java 9, the classpath was problematic and the source of developer
    anguish. This was evident in the numerous developer forums and, fortunately, Oracle
    was paying attention. Here are the several instances in which the classpath can
    be problematic; here are two primary cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The first case involves having two or more versions of a library on your development
    computer. The way this was previously handled by the Java system was inconsistent.
    Which library was used during the class loading process was anyone's guess. This
    resulted in an undesired lack of specificity--not enough details regarding which
    library was loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second case is in exercising the most advanced features of the class loader.
    Often times, this type of class loader usage resulted in the most errors and bugs.
    These were not always easy to detect and resulted in a lot of extra work for developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classpaths, before Java 9, were almost always very lengthy. Oracle, in a recent
    presentation, shared a classpath that contained 110 JAR files. This type of unwieldy
    classpath makes it difficult to detect conflicts or even determine if anything
    was missing and if so, what might be missing. The re-envisioning of the Java platform
    as a modular system made these classpath issues a thing of the past.
  prefs: []
  type: TYPE_NORMAL
- en: Modules solve the pre-Java 9 classpath problem by providing reliable configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The monolithic nature of the JDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java has continually evolved in an impressive fashion since 1995 and with each
    evolutionary step, the JDK grew larger. As with Java 8, the JDK had become prohibitively
    large. Prior to Java 9, there were several problematic issues stemming from the
    monolithic nature of the JDK, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Because the JDK is so large, it does not fit on very small devices. In some
    development sectors this is enough reason to find a non-Java solution for software
    engineering problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The oversized JDK resulted in waste. It was wasteful in terms of processing
    and memory when running on devices, networks, and the cloud. This stems from the
    fact that the entire JDK is loaded, even when only a small subset of the JDK is
    required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the Java platform has great performance when running, the startup performance,
    in terms of load and launch times, leaves much to be desired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vast number of internal APIs has also been a pain point. Because so many
    internal APIs existed and were used by developers, the system has been difficult
    to evolve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The existence of internal APIs has made it difficult to make the JDK secure
    and scalable. With so many internal dependencies, isolating security and scalability
    issues has been overly problematic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The answer to the monolithic woes of the JDK is the module. Java 9 introduced
    the module and its own modular system. One of the great updates to the platform
    is that only the modules needed are compiled, as opposed to the entire JDK. This
    modular system is covered throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Modules solve the pre-Java 9 JDK monolithic issue by providing strong encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: How modules fit into the Java landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from the following illustration, packages are comprised of classes
    and interfaces, and modules are comprised of packages. Modules are a container
    of packages. This is the basic premise, at a very high level, of Java 9's new
    modular system. It is important to view modules as part of the modular system
    and not simply as a new level of abstraction above packages, as the illustration
    might suggest.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/882b9ebe-d7f3-4148-9877-d30761fcc485.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, modules are new to Java 9 and they, as you would expect, require declaration
    before they can be used. A module''s declaration includes names of other modules
    in which it has a dependency. It also exports packages for other modules that
    have dependencies to it. Modular declarations are arguably the most important
    modular issue to address as you start developing with Java 9\. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When programming a Java 9 application, your module declarations will be placed
    in a `module-info.java` file. Once this file is completed, you simply run `javac`,
    the Java Compiler, to generate the `module-info.class` Java class file. You accomplish
    this task in the same manner that you currently compile your `.java` files into
    `.class` files.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create modular JAR files that have your `module-info.class` file
    at its root. This represents a great level of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Base module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When programming Java 9 applications, or porting existing applications programmed
    with older versions of Java, the base module (`java.base`) must be used. Every
    module requires the `java.base` module because it defines the critical, or foundational,
    Java platform APIs. Here are the contents of the `java.base` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `java.base` module does not require any modules and it exports
    numerous packages. It can be useful to have a list of these exports handy so you
    know what is available to you as you start creating applications using the new
    Java platform, Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that in the previous section, we did not include the `requires
    java.base;` line of code in our declaration of our `com.three19.irisScan` module.
    The updated code is provided as follows and now includes the `requires java.base;`
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you do not include the `requires java.base;` line of code in your module
    declarations, the Java Compiler will automatically include it.
  prefs: []
  type: TYPE_NORMAL
- en: Reliable configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As suggested earlier in this chapter, modules provide a reliable configuration
    of our Java 9 applications that solves the classpath problem in earlier versions
    of the Java platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java reads and interprets modular declarations making the modules readable.
    These readable modules permit the Java platform to determine if any modules are
    missing, if there are duplicate libraries declared, or there are any other conflicts.
    In Java 9, very specific error messages will be generated and output by the compiler
    or at runtime. Here is an example of a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of a runtime error that would occur if the module `com.three19.isrisCore`
    was not found, but required by the `com.three19.irisScan` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Strong encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, you read that Java 9''s strong encapsulation remedied
    the monolithic JDK issue. Encapsulation, in Java 9, is driven by the information
    in the `module-info.java` file. The information in this file lets Java know what
    modules are dependent upon others and what each of them exports. This underscores
    the importance of ensuring our `module-info-java` files are properly configured.
    Let''s look at an example written with standard Java code, nothing new in Java
    9 in the way this was coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d158dbd8-12a3-4967-8461-1f43137bd878.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, the `com.three19.irisScan` module has an `irisScanner`
    package intended for internal use and an `irisScanResult` class. If the `com.three19.access`
    application tries to import and use the `irisScanResult` class, the following
    error message will be produced by the Java Compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If for some reason the compiler does not catch this error, although it would
    be very unlikely, the following runtime error would occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The detailed error messages will make debugging and troubleshooting much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Migration planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The changes to the Java platform are significant and Java 9 is considered a
    major release. It would be naive to think our current Java applications will work
    seamlessly on Java 9\. While that might be the case, at least for simple programs,
    it is prudent to plan ahead and consider the issues you are most likely to encounter.
    Before we look at these issues, let's test a simple Java application in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a simple Java application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code consists of a single Java class, `GeneratePassword.` This
    class prompts the user for a desired password length and then generates a password
    based on the user''s requested length. If the user asks for a length shorter than
    8, the default length of 8 will be used. This code was written with the Java SE
    1.7 JRE System Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we test the `GeneratePassword` app on a Mac running
    Java 8\. As you can see, we start by querying Java to verify the current version.
    In this test, Java `1.8.0_121` was used. Next, we compile the `GeneratePassword`
    Java file using the `javac` utility. Lastly, we run the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25190f7c-a461-46e7-b135-5fd939b71b8f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding test, `GeneratePassword.java` was successfully
    compiled with the `GeneratePassword.class` file resulting. The application was
    run using the `java GeneratePassword` command. The user was prompted for a desired
    password length and `32` was entered. The application then successfully generated
    a 32-character random password and provided the appropriate output.
  prefs: []
  type: TYPE_NORMAL
- en: This test demonstrated the example application works successfully using JDK
    1.8\. Next, let's test the same application using JDK 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `java -version` command to show that we are using JDK 9 on
    this computer. The following screenshot shows that we successfully compiled the
    `.java` file to a `.class` file. When the application was run, it functioned as
    expected and provided the proper results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45ce0b95-2ac2-48f6-bd2c-879dbf413f7a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we clearly demonstrated that a pre-Java 9 application has the
    potential to successfully run on Java 9 without having to make any modifications.
    This is a simple case study and featured a very basic Java program. This is, of
    course, the best case scenario, and cannot be assumed. You will want to test your
    applications to ensure they run as expected on the Java 9 platform.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review some potential issues you might encounter
    when testing your pre-Java 9 applications using the new Java platform with JDK
    9.
  prefs: []
  type: TYPE_NORMAL
- en: Potential migration issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The potential migration issues featured in this section include direct access
    to the JRE, access to internal APIs, accessing internal JARs, JAR URL depreciation,
    the extension mechanism, and the JDK's modularization. Let's look at each of these
    potential migration issues.
  prefs: []
  type: TYPE_NORMAL
- en: The JRE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating the Java 9''s modular system resulted in some simplification in respect
    to the number and location of development and utility tools. One such example
    is the JDK''s consumption of the JRE. In all pre-Java 9 versions, the Java platform
    included the JDK and JRE as two separate components. In Java 9, these components
    have been combined. This is a significant change and one that developers should
    be keenly aware of. If you have an application that specifically points to the
    JRE directory, you will need to make changes to avoid problems. The JRE contents
    are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3777984-93a8-40e6-8b2b-f30cdef4c8aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Access to internal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java 9 platform has encapsulated internal APIs to increase security of the
    platform and applications written in Java. Applications that you program in Java
    9 will not have default access to the JDK's internal APIs, unlike with previous
    versions of the Java platform. Oracle has identified some internal APIs as critical;
    those APIs remain accessible via the `jdk.unsupported` JDK module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned critical APIs (internal to the JDK) are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sun.misc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.misc.Unsafe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.reflect.Reflection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.reflect.ReflectionFactory.newConstrutorForSerialization`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have pre-Java 9 applications that implement any `sun.*` or `com.sun.*`
    package, you will likely run into problems migrating your applications to Java
    9\. In order to address this issue, you should review your class files for use
    of `sun.*` and `com.sun.*` packages. Alternatively, you can use the Java dependency
    analysis tool, `jdeps`, to help determine if your Java program has any dependencies
    on JDK internal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The `jdeps` tool is the Java dependency analysis tool, that can be used to help
    determine if your Java program has any dependencies on JDK internal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing internal JARs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 9 does not permit access to internal JARs such as `lib/ant-javax.jar`,
    `lib/dt.jar`, and others listed in the `lib` directory shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6eaf16e-597f-46c8-a855-be49e3df00e1.png)'
  prefs: []
  type: TYPE_IMG
- en: The key thing to note here is that if you have Java applications that are dependent
    on one of these tools residing in the `lib` folder, you will need to modify your
    code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you test your IDE once you start using Java 9 to ensure
    the IDE is updated and officially supports Java 9\. If you use more than one IDE
    for Java development, test each one to avoid surprises.
  prefs: []
  type: TYPE_NORMAL
- en: JAR URL depreciation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JAR file URLs were, prior to Java 9, used by some APIs to identify specific
    files in the runtime image. These URLs contain a `jar:file:` prefix with two paths;
    one to the `jar` and one to the specific resource file within the `jar`. Here
    is the syntax for the pre-Java 9 JAR URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With the advent of Java 9''s modular system, containers will house resource
    files instead of individual JARs. The new syntax for accessing resource files
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A new URL schema, `jrt`, is now in place for naming resources within a runtime
    image. These resources include classes and modules. The new schema allows for
    the identification of a resource without introducing a security risk to the runtime
    image. This increased security ensures that the runtime image''s form and structure
    remain concealed. Here is the new schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, a `jrt` URL''s structure determines its meaning, suggesting
    that the structure can take one of several forms. Here are three examples of different
    `jrt` URL structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jrt:/$MODULE/$PATH`: This structure provides access to the resource file,
    identified with the `$PATH` parameter, within the module specified with the `$MODULE`
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jrt:/$MODULE`: This structure provides reference to all resource files within
    the module specified with the `$MODULE` parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jrt:/`: This structure provides reference to all resource files in the runtime
    image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have preexisting code that uses URL instances, returned by APIs, you
    should not have any problems. On the other hand, if your code is dependent on
    the `jar` URL structure, you will have problems.
  prefs: []
  type: TYPE_NORMAL
- en: Extension mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java platform previously had an extension mechanism that gave developers
    the ability to make custom APIs available to all applications. As you can see
    in the following illustration, extensions are plugins of sorts, or add-ons to
    the Java platform. The APIs and classes in each extension are, by default, automatically
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab617175-aee5-44af-9913-b458652c65a7.png)'
  prefs: []
  type: TYPE_IMG
- en: As the illustration suggests, Java applications have access both to the Java
    platform and extensions without requiring classpaths. This feature was depreciated
    in Java 8 and no longer exists in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: The JDK's modularization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, you have a firm appreciation of Java 9''s modularization. The old adage
    in Java, and other object-oriented programming language, is *everything is a class*.
    Now, with Java 9, *everything is a module* is the new adage. There are three type
    of modules as explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Automatic | When a JAR is placed on a new module path, modules are automatically
    created |'
  prefs: []
  type: TYPE_TB
- en: '| Explicit/Named | These modules are manually defined by editing the `module-info.java`
    file |'
  prefs: []
  type: TYPE_TB
- en: '| Unnamed | When a JAR is placed on a classpath, unnamed modules are created
    |'
  prefs: []
  type: TYPE_TB
- en: When you migrate your applications to Java 9, your application and its libraries
    become unnamed modules. So, you will need to ensure all the modules are in the
    module path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to be aware of is that your runtime image will not contain the
    entire JDK. Instead, it will only contain the modules your application requires.
    It is worth reviewing how the JDK is modularized in Java 9\. The following table
    contains the API specification for the JDK in Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `jdk.accessibility` | `jdk.attach` | `jdk.charsets` | `jdk.compiler` |'
  prefs: []
  type: TYPE_TB
- en: '| `jdk.crypto.cryptoki` | `jdk.crypto.ec` | `jdk.dynalink` | `jdk.editpad`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jdk.hotspot.agent` | `jdk.httpserver` | `jdk.incubator.httpclient` | `jdk.jartool`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jdk.javadoc` | `jdk.jcmd` | `jdk.jconsole` | `jdk.jdeps` |'
  prefs: []
  type: TYPE_TB
- en: '| `jdk.jdi` | `jdk.jdwp.agent` | `jdk.jlink` | `jdk.jshell` |'
  prefs: []
  type: TYPE_TB
- en: '| `jdk.jsobject` | `jdk.jstatd` | `jdk.localedata` | `jdk.management` |'
  prefs: []
  type: TYPE_TB
- en: '| `jdk.management.agent` | `jdk.naming.dns` | `jdk.naming.rmi` | `jdk.net`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jdk.pack` | `jdk.packager.services` | `jdk.policytool` | `jdk.rmic` |'
  prefs: []
  type: TYPE_TB
- en: '| `jdk.scripting.nashorn` | `jdk.sctp` | `jdk.security.auth` | `jdk.security.jgss`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jdk.snmp` | `jdk.xml.dom` | `jdk.zipfs` |  |'
  prefs: []
  type: TYPE_TB
- en: 'The following table contains the API specification for Java SE in Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `java.activation` | `java.base` | `java.compiler` | `java.cobra` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.datatransfer` | `java.desktop` | `java.instrument` | `java.logging`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.management` | `java.management.rmi` | `java.naming` | `java.prefs`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.rmi` | `java.scripting` | `java.se` | `java.se.ee` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.security.jgss` | `java.security.sasi` | `java.sql` | `java.sql.rowset`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.transaction` | `java.xml` | `java.xml.bind` | `java.xml.crypto` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.xml.ws` | `java.xml.ws` | `java.xml.ws.annotation` |  |'
  prefs: []
  type: TYPE_TB
- en: Remember, all applications will have access to `java.base` as it is in the module
    path by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table contains the API specification for JavaFX in Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `javafx.base` | `javafx.controls` | `javafx.fxml` | `javafx.graphics` |'
  prefs: []
  type: TYPE_TB
- en: '| `javafx.media` | `javafx.swing` | `javafx.web` |  |'
  prefs: []
  type: TYPE_TB
- en: 'There are two additional modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.jnlp` defines the API for **JNLP** (**Java Network Launch Protocol**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.smartcardio` defines the API for the Java Smart Card Input/Output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For details on any of these modules, visit Oracle''s *JavaÂ® Platform, Standard
    Edition & Java Development Kit Version 9 API Specification* website: [http://download.java.net/java/jdk9/docs/api/overview-summary.html](http://download.java.net/java/jdk9/docs/api/overview-summary.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Advice from Oracle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle has done a great job in bringing us this major update, version 9, to
    the Java platform. Their insights into getting ready for Java 9 and how to migrate
    to the new JDK is worth reviewing. In this section, we will look at preparatory
    steps, breaking encapsulation, changes to the runtime image, components such as
    tools and APIs that have been removed, changes to garbage collection, and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparatory steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Oracle provides a five-step process to help developers migrate their Java applications
    to version 9\. These steps are listed as follows and then covered in subsequent
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the JDK 9 early access build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run your program before recompiling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update third-party libraries and tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `jdeps` on your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the JDK 9 early access build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are reading this book before Java 9 is officially released, then you
    can obtain a JDK 9 early access build from here--[http://jdk.java.net/9/](http://jdk.java.net/9/).
    Early release builds are available for Windows (32 and 64), macOS (64), Linux
    (32 and 64) and various Linux ARM, Solaris, and Alpine Linux versions.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the time to test your applications for Java 9 and get them migrated before
    Java 9 is officially released, helps ensure you will not experience any downtime
    for services that rely on your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Running your program before recompiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As indicated earlier in this chapter, there is a chance that your existing Java
    applications will run without modification on the Java 9 platform. So, before
    you make any changes, try running your current application on the Java 9 platform.
    If your application works fine on Java 9, that is great, but your work is not
    complete. Review the next three sections on updating third-party libraries and
    tools, compiling your application, and running `jdeps` on your code.
  prefs: []
  type: TYPE_NORMAL
- en: Updating third-party libraries and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Third-party libraries and tools can help extend our applications and shorten
    development time. For Java 9 compatibility, it is important to ensure that each
    third-party library and tool you use is compatible with and supports version 9
    of the JDK. Running your application on Java 9 will not provide you with the level
    of insight you need to ensure you do not have compatibility issues down the road.
    It is recommended that you review the official website for each library and tool
    to verify compatibility with and support of JDK 9.
  prefs: []
  type: TYPE_NORMAL
- en: If a library or tool that you use does have a version that supports JDK 9, download
    and install it. If you find one that does not yet support JDK 9, consider finding
    a replacement for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our context, tools includes **Integrated Development Environments** (**IDE**).
    NetBeans, Eclipse, and IntelliJ all have IDE versions that support JDK 9\. Links
    to those sites are provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NetBeans**: [http://bits.netbeans.org/download/trunk/nightly/latest/](http://bits.netbeans.org/download/trunk/nightly/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eclipse**: [https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php](https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IntelliJ**: [https://www.jetbrains.com/idea/nextversion/](https://www.jetbrains.com/idea/nextversion/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your next step is to compile your application using JDK 9's `javac`. This is
    important, even if your app works fine on JDK 9\. You might not receive compiler
    errors, but watch for warnings too. Here are the most common reasons your applications
    might not compile with JDK 9, assuming they compiled fine prior to Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: First, as indicated earlier in this chapter, most of the JDK 9 internal APIs
    are not accessible by default. Your indication will be an `IllegalAccessErrors`
    error at runtime or compile time. You will need to update your code so that you
    are using accessible APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second reason your pre-Java 9 applications might not compile with JDK 9 is
    if you use the underscore character as a single character identifier. According
    to Oracle, this practice generates a warning in Java 8 and an error in Java 9\.
    Let''s look at an example. The following Java class instantiates an Object named
    `_` and prints a singular message to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile this program with Java 8, we receive a warning that use of
    ''`_`'' as an identifier might not be supported in releases after Java SE 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/186dc2c5-1bf0-48fc-a3a8-f717c0a30117.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the following screenshot, that is just a warning and the
    application runs fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54bfa604-00e6-4f34-ae21-9b0d281ed85c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try compiling the same class using JDK 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48d8afd2-2a44-4906-adcf-36a7b8c45c16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, use of the underscore as a single character identifier still
    only resulted in a warning and not an error. The application ran successfully.
    This test was run when JDK 9 was still in early release. It is assumed that running
    this test once JDK 9 has been officially released will result in an error instead
    of just a warning. The error that would likely be thrown is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Even if this issue is not resolved with the formal release of JDK 9, use of
    an underscore as a single character identifier is not good programming practice,
    so you should steer away from using it.
  prefs: []
  type: TYPE_NORMAL
- en: A third potential reason for your pre-Java 9 programmed application not to compile
    with JDK 9 is if you are using the `-source` and `-target` compiler options. Let's
    take a look at the `-source` and `-target` compiler options pre-Java 9 and with
    Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-Java 9 -source and -target options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-source` option specifies the Java SE version and has the following acceptable
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1.3 | `javac` does not support features introduced after Java SE 1.3. |'
  prefs: []
  type: TYPE_TB
- en: '| 1.4 | `javac` accepts code with language features introduced in Java SE 1.4.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1.5 or 5 | `javac` accepts code with languages features introduced in Java
    SE 1.5. |'
  prefs: []
  type: TYPE_TB
- en: '| 1.6 or 6 | `javac` reports encoding errors as errors instead of warnings.
    Of note, no new language features were intruded with Java SE 1.6. |'
  prefs: []
  type: TYPE_TB
- en: '| 1.7 or 7 | `javac` accepts code with language features introduced in Java
    SE 1.7\. This is the default value if the `-source` option is not used. |'
  prefs: []
  type: TYPE_TB
- en: 'The `-target` option tells `javac` what version of the JVM to target. The acceptable
    values for the `-target` option are--`1.1`, `1.2`, `1.3`, `1.4`, `1.5` or `5`,
    `1.6` or `6` and `1.7` or `7`. If the `-target` option is not used, the default
    JVM target is dependent on the value used with the `-source` option. Here is a
    table of `-source` values with their associated `-target`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **-source value** | **default -target** |'
  prefs: []
  type: TYPE_TB
- en: '| unspecified | 1.7 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.2 | 1.4 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.3 | 1.4 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.4 | 1.4 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.5 or 5 | 1.7 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.6 or 6 | 1.7 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.7 | 1.7 |'
  prefs: []
  type: TYPE_TB
- en: Java 9 -source and -target options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java 9, the supported values are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Supported values** | **Remarks** |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | This is the default, should no value be specified |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Sets support to 1.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Sets support to 1.7 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Sets support to 1.6 and generates a warning (not an error) to indicate
    JDK 6 is depreciated |'
  prefs: []
  type: TYPE_TB
- en: Running jdeps on your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `jdeps` class dependency analysis tool is not new to Java 9, but perhaps
    has never been as important to developers with the advent of Java 9\. An important
    step to migrating your applications to Java 9 is to run the `jdeps` tool to determine
    the dependencies your applications and its libraries have. The `jdeps` tool does
    a great job of suggesting replacements if your code has dependencies on any internal
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the options available to you when using the
    `jdeps` analyzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b466a2c-1863-4887-b1e0-f5084237790f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at an example. Here is a simple Java class called `DependencyTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use `javac` to compile this class using Java 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e19fbeb0-d819-4916-941f-7ec2c2e68c2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, Java 8 successfully compiled the class and the application
    ran. The compiler did give us a `DependencyTest.java:6: warning: BASE64Encoder
    is internal proprietary API and may be removed in a future release` warning. Now,
    let''s see what happens when we try to compile this class using Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82447d64-8290-4dfb-bec6-2ca32da76141.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, with Java 9, the compiler gave us two warnings instead of one.
    The first warning is for the `import sun.misc.BASE64Encoder;` statement and the
    second for the `BASE64Encoder.class.newInstance();` method call. As you can see,
    these are just warnings and not errors, so the `DependencyTest.java` class file
    is successfully compiled. Next, let''s run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8eeaa15-c61c-48f2-9b06-651c9babb345.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can clearly see that Java 9 will not allow us to run the application.
    Next, let''s run a dependency test using the `jdeps` analyzer tool. We will use
    the following command line syntax--`jdeps DependencyTest.class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11dc7d02-3df6-48cf-a67f-a5b060e09c36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have three dependencies: `java.io`, `java.lang`, and `sun.misc`.
    Here we are given the suggestion to replace our `sun.misc` dependency with `rt.jar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java 9 platform is more secure than its predecessor versions due to, in
    part, the increased encapsulation that resulted from the modular reorganization.
    That being said, you might have a requirement to break through the modular system's
    encapsulation. Breaking through these access control boundaries is permitted by
    Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: As you read earlier in this chapter, most internal APIs are strongly encapsulated.
    As previously suggested, you might look for replacement APIs when updating your
    source code. Of course, that is not always feasible. There are three additional
    approaches you can take--using the `--add-opens` option at runtime; employing
    the `--add-exports` option; and `--permit-illegal-access` command-line option.
    Let's look at each of those options.
  prefs: []
  type: TYPE_NORMAL
- en: The --add-opens option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `--add-opens` runtime option to allow your code to access non-public
    members. This can be referred to as deep reflection. Libraries that do this deep
    reflection are able to access all members, private and public. To grant this type
    of access to your code, you use the `--add-opens` option. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This allows the given module to open the specified package. The compiler will
    not produce any errors or warnings when this is used.
  prefs: []
  type: TYPE_NORMAL
- en: The --add-exports option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use `--add-exports` to break encapsulation so that you can use an internal
    API whose default is to be inaccessible. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This command-line option gives code in the `<target-module>` access to types
    in the `<source-module>` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method of breaking encapsulation is with a JAR file''s manifest. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `--add-exports` command-line option should only be used if deemed absolutely
    necessary. It is not advisable to use this option except for short-term solutions.
    The danger of using it routinely is that any updates to referenced Internal APIs
    could result in your code not working properly.
  prefs: []
  type: TYPE_NORMAL
- en: The --permit-illegal-access option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A third option for breaking encapsulation is to use the `--permit-illegal-access`
    option. Of course, it is prudent to check with third-party library creators to
    see if they have an updated version. If that is not an option, you use `--permit-illegal-access`
    to gain illegal access to operations to be implemented on the classpath. Due to
    the significantly illegal operation here, you will receive warnings each time
    one of these operations occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime image changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 9 represents a major change to the JDK and the JRE. Much of these changes
    are related to modularity and have been covered in other chapters. There are still
    a few more things you should consider.
  prefs: []
  type: TYPE_NORMAL
- en: Java version schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Java 9, the way the Java platform''s version is displayed has changed.
    Here is an example of a pre-Java 9 version format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54f8b3ec-7246-42ea-90fc-624045f063da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at how Java 9 reports its version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d132fdc1-85d2-4ba6-8809-4b4cde084688.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, with Java 9, the version schema is now `$MAJOR.$MINOR.$SECURITY.$PATCH`.
    This is markedly different than with previous versions of Java. This will only
    impact your applications if you have code that parses the string returned by the
    `java -version` command and option.
  prefs: []
  type: TYPE_NORMAL
- en: JDK and JRE layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How files are organized in the JDK and the JRE have changed in the new version
    of Java. It is worth your time to familiarize yourself with the new filesystem
    layout. The following screenshot shows the file structure of the JDK''s `/bin`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc9d9d4e-6c5c-4874-b740-c09ce1d1091c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the layout of the `lib` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97375e98-a2ab-4a00-b8fd-2e6f1908f103.png)'
  prefs: []
  type: TYPE_IMG
- en: What has been removed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another area of change for the new version of the Java platform is that many
    platform components have been removed. The following sections represent the most
    significant components.
  prefs: []
  type: TYPE_NORMAL
- en: Notably, the `rt.jar` and `tools.jar` and `dt.jar` have been removed. These
    JAR files contained class and other resources files and all resided in the `/lib`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: The e*ndorsed standards override mechanism* has been removed. In Java 9, both
    `javac` and `java` will exit if they detect that mechanism. The mechanism was
    used for application servers to override some JDK components. In Java 9, you can
    use upgradeable modules to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: As previously covered in this chapter, the e*xtension mechanism* has also been
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listed APIs were previously depreciated and have been removed
    and are not accessible in Java 9\. Removal of these APIs is the result of the
    modularization of the Java platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apple.applescript`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.apple.concurrent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.sun.image.codec.jpeg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.awt.dnd.peer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.awt.peer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.rmi.server.disableHttp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.logging.LogManager.addPropertyChangeListener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.logging.LogManager.removePropertyChangeListener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.jar.Pack200.Packer.addPropertyChangeListener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.jar.Pack200.Packer.removePropertyChangeListener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.jar.Pack200.Unpacker.addPropertyChangeListener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.jar.Pack200.Unpacker.removePropertyChangeListener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.management.remote.rmi.RMIIIOPServerImpl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.misc.BASE64Encoder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.misc.BASE64Decoder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `sun.rmi.transport.proxy.connectTimeout` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.rmi.transport.proxy.eagerHttpFallback`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.rmi.transport.proxy.logLevel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.rmi.transport.tcp.proxy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following listed tools have been removed. In each case, the tool was previously
    depreciated or its functionality superseded by better alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hprof`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java-rmi.cgi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java-rmi.exe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JavaDB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jhat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`native2ascii`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two additional things that have been removed in Java 9 are:'
  prefs: []
  type: TYPE_NORMAL
- en: AppleScript engine. This engine was deemed as unusable and is dropped without
    replacement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 32-bit client virtual machine. JDK 9 does support a 32-bit server JVM,
    but not a 32-bit client VM. This change was made to focus on the increased performance
    of 64-bit systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Garbage collection has been one of Java''s great claims to fame. In Java 9,
    the **Garbage-First** (**G1**) garbage collector is now the default garbage collector
    on both 32- and 64-bit servers. In Java 8, the default garbage collector was the
    parallel garbage collector. Oracle reports that there are three garbage collection
    combinations that will prohibit your application from starting in Java 9\. Those
    combinations are:'
  prefs: []
  type: TYPE_NORMAL
- en: DefNew + CMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremental CMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ParNew + SerialOld
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take an in-depth look at Java 9 garbage collection in Chapter 7, *Leveraging
    the New Default G1 Garbage Collector*.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three issues that you should be aware of, in the context of migrating
    to Java 9, when you are deploying your applications. These issues are JRE version
    selection, serialized applets, and the update to the JNLP.
  prefs: []
  type: TYPE_NORMAL
- en: '**JNLP** is the acronym for **Java Network Launch Protocol** and is covered
    in a later section of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: JRE version selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to Java 9, developers could request a JRE version other than the version
    being launched when launching an application. This could be accomplished with
    a command-line option or with a proper JAR file manifest configuration. This feature
    has been removed in JDK 9 because of the way we typically deploy applications.
    Here are the three primary methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Active installers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Web Start** using JNLP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native OS packaging systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialized applets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 9 does not support the ability to deploy applets as serialized objects.
    In the past, applets were deployed as serialized objects to compensate for slow
    compression and JVM performance issues. With Java 9, compression techniques are
    advanced and the JVM has great performance.
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to deploy your applets as serialized objects, your object attributes
    and parameter tags will simply be ignored when your applet launches. Starting
    with Java 9, you can deploy your applets using standard deployment strategies.
  prefs: []
  type: TYPE_NORMAL
- en: JNLP update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JNLP is used for launching applications on a desktop client using resources
    located on a web server. JNLP clients include Java Web Start and Java Plug-in
    software because they are able to launch applets that are remotely hosted. This
    protocol is instrumental in launching RIAs.
  prefs: []
  type: TYPE_NORMAL
- en: '**RIAs** are **Rich Internet Applications** and when launched with JNLP have
    access to the various JNLP APIs that, with user permission, can access the user''s
    desktop.'
  prefs: []
  type: TYPE_NORMAL
- en: In Java 9, the JNLP specification has been updated. There are four specific
    updates as detailed in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Nested resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability to use component extensions with nest resources in Java or j2se
    elements was previously supported, but not documented in the specification. The
    specification has now been updated to reflect this support. The previous specification
    read:'
  prefs: []
  type: TYPE_NORMAL
- en: No java elements can be specified as part of the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated specification for Java 9 now reads:'
  prefs: []
  type: TYPE_NORMAL
- en: A java element in a component extension will not govern what version of java
    is used, but may be used containing nested resource elements, and then those resources
    may be used only when using a Java version that matches the given version as specified
    in section 4.6
  prefs: []
  type: TYPE_NORMAL
- en: This specific change ensures that extension JLP files must have `java` or `j2se`
    resources and those resources will not dictate what JRE is used. Nested resources
    are permitted when using the specified version.
  prefs: []
  type: TYPE_NORMAL
- en: FX XML extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using the JNLP, you create a JNLP file. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Two changes have been made to the `<application-desc>` element. First, the
    optional `type` attribute has been added so the type of application can be annotated.
    The default type is `Java`, so if your program is a Java app, you need not include
    the `type` attribute. Alternatively, you can specify `Java` as your type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can indicate other application types to include `JavaFX` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you indicate an application type that is not supported by the JNLP client,
    your application launch will fail. For more information about JNLP, you can consult
    the official documentation: [http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html](http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second change to the `<application-desc>` element in Java 9 is the addition
    of the `param` sub-element. This allows us to provide the name of parameters along
    with their value using the `value` attribute. Here is an example of how an `<application-desc>`
    element of a JNLP file looks with the `param` sub-element and the `value` attribute
    included. This example shows three sets of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If the application `type` is Java, then any `param` sub-elements you use will
    be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: JNLP file syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JNLP file syntax is now in complete compliance with XML specifications. Prior
    to Java 9, you could use `&` to create complex comparisons. That is not supported
    with standard XML. You can still create complex comparisons in JNLP files. Now
    you will use `&amp;` instead of `&`.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric version comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JNLP specification has been changed to reflect how numeric version elements
    were compared against non-numeric version elements. Previous to the change, version
    elements were compared lexicographically by ASCII value. With Java 9 and this
    JNLP specification change, elements are still compared lexicographically by ASCII
    value. The change is evident when the two strings have different lengths. In new
    comparisons, the shorter string will be padded with leading zeros to match the
    length of the longer string.
  prefs: []
  type: TYPE_NORMAL
- en: Lexicographical comparisons use a mathematical model that is based on alphabetical
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Useful tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you will need to do before migrating your applications to Java
    9 is to download JDK 9\. You can download the early access builds at this URL--[http://jdk.java.net/9/](http://jdk.java.net/9/).
    You will need to accept the license agreement and then select which build to download.
    As you can see in the following screenshot, there are several options based on
    your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad5ae026-64d1-4c22-a76d-19c56266be94.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have JDK 9 installed on your development computer, let's look at
    a couple of tools that can help facilitate migrating your applications to Java
    9.
  prefs: []
  type: TYPE_NORMAL
- en: Java environment - jEnv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you develop on a computer with Linux or macOS, you might consider using `jEnv`,
    an open source Java environment management tool. This is a command-line tool,
    so do not expect a GUI. You can download the tool at this URL--[https://github.com/gcuisinier/jenv](https://github.com/gcuisinier/jenv).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the installation command for Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To download using macOS with Homebrew, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also install on Linux or macOS using `Bash` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can install on Linux or macOS using `Zsh` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have `jEnv` installed, you will need to configure it on your system
    as shown here. You will need to modify the script to reflect your actual path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You will want to repeat the `jenv add` command for each version of the JDK
    on your system. With each `jenv add` command, you will receive confirmation that
    the specific JDK version was added to `jEnv` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can check to see what JDK versions you have added to your `jEnv` by using
    `$ jenv versions` at the Command Prompt. This will result in an output list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are three additional `jEnv` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jenv global <version>`: this sets the global version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jenv local <version>`: this sets the local version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jenv shell <version>`: this sets the instance version for the shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Maven is an open source tool that can be used for building and managing Java-based
    projects. It already supports Java 9 and is part of the *Apache Maven Project*.
    If you are not already using Maven and you do a lot of Java development you might
    be enticed by the following Maven objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Making the build process easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a uniform build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing quality project information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing guidelines for best practices development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing transparent migration to new features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more specifics about each of the Maven objectives at this site--[https://maven.apache.org/what-is-maven.html](https://maven.apache.org/what-is-maven.html).
    To download Maven, visit this site--[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).
    Installation instructions for Windows, macOS, Linux, and Solaris are available
    here--[https://maven.apache.org/install.html](https://maven.apache.org/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Maven can be integrated with Eclipse (M2Eclipse), JetBrains IntelliJ IDEA,
    and the Netbeans IDE. The M2Eclipse IDE, as an example, provides rich integration
    with Apache Maven and boasts the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: You can launch Maven builds from within Eclipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage your dependencies for the Eclipse build path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily resolve Maven dependencies (you can do this directly from Eclipse and
    not have to install a local Maven repository)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically download required dependencies (from remote Maven repositories)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use software wizards to create new Maven projects, create `pom.xml` files, and
    to enable Maven support for your plain Java projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rapid dependency search of Maven remote repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining the M2Eclipse IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To obtain the M2Eclipse IDE, you must first have Eclipse installed. Here are
    the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening your current Eclipse IDE. Next, select Preferences | Install/Update
    | Available Software Sites as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ba63e52-cdb6-41ec-a3ea-3f03c64989ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next task is to add the M2Eclipse repository site to your list of Available
    Software Sites. To accomplish this, click the Add button and enter values in the
    Name and Location text input boxes. For Name, enter something to help you remember
    that M2Eclipse is available at this site. For Location, enter the URL--`http://download.eclipse.org/technology/m2e/releases`.
    Then, click the OK button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/265485fa-f472-4fad-8b9a-aeb1a2074ef0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should now see the M2Eclipse site listed in your list of Available Software
    Sites as shown in the following screenshot. Your final step is to click the OK
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4d352e8-46d9-43f7-8cb2-5ed6810d3da3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, when you start a new project, you will see `Maven Project` as an option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/850c5e6f-e1a4-4c01-8892-93abd6f12262.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Maven is a proven tool for Java developers. You might consider obtaining additional
    information on Maven with one of the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Apache Maven Project*: [https://maven.apache.org/index.html](https://maven.apache.org/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apache Maven Cookbook*: [https://www.packtpub.com/application-development/apache-maven-cookbook](https://www.packtpub.com/application-development/apache-maven-cookbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apache Maven 3.o Cookbook*: [https://www.packtpub.com/application-development/apache-maven-3-cookbook](https://www.packtpub.com/application-development/apache-maven-3-cookbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Apache Maven [Video]*: [https://www.packtpub.com/application-development/getting-started-apache-maven-video](https://www.packtpub.com/application-development/getting-started-apache-maven-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored potential issues involved in migrating our existing
    applications to the Java 9 platform. We looked at both manual and semi-automated
    migration processes. This chapter provided you with insights and processes to
    get your Java 8 code working with Java 9\. Specifically, we conducted a quick
    review of Project Jigsaw, looked at how modules fit into the Java landscape, provided
    tips for migration planning, shared advice from Oracle regarding migration, and
    shared tools that you can use to help you as you get started with Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a close look at the Java shell and the JShell
    API. We demonstrate the JShell API and the JShell tool's ability to interactively
    evaluate declarations, statements, and expressions of the Java programming language.
    We will demonstrate features and use of this command-line tool.
  prefs: []
  type: TYPE_NORMAL
