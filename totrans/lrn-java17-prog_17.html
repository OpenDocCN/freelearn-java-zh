<html><head></head><body>
		<div id="_idContainer165">
			<h1 id="_idParaDest-297"><em class="italic"><a id="_idTextAnchor296"/>Chapter 14</em>: Java Standard Streams</h1>
			<p>In this chapter, we will talk about processing data streams, which are different from the I/O streams we reviewed in <a href="B18388_05_ePub.xhtml#_idTextAnchor121"><em class="italic">Chapter 5</em></a>, <em class="italic">Strings, Input/Output, and Files</em>. We will define what data streams are, how to process their elements using methods (operations) of the <strong class="source-inline">java.util.stream.Stream</strong> object, and how to chain (connect) stream operations in a pipeline. We will also discuss stream initialization and how to process streams in parallel.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Streams as a source of data and operations</li>
				<li>Stream initialization</li>
				<li>Operations (methods)</li>
				<li>Numeric stream interfaces</li>
				<li>Parallel streams</li>
				<li>Creating a standalone stream-processing application </li>
			</ul>
			<p>By the end of the chapter, you will be able to write code that processes streams of data as well as create a stream-processing application as a standalone project.</p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor297"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or code editor of your choice</li>
			</ul>
			<p>The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>. The files with the code examples for this chapter are available on the GitHub repository at <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch14_streams</strong> folder and the <strong class="source-inline">streams</strong> folder, which contains a standalone stream-processing application.</p>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor298"/>Streams as a source of data and operations</h1>
			<p>Lambda <a id="_idIndexMarker1530"/>expressions, described <a id="_idIndexMarker1531"/>and demonstrated in the previous chapter, together with functional interfaces add a powerful functional programming capability to Java. They allow passing behavior (functions) as parameters to libraries optimized for the performance of data processing. This way, an application programmer can concentrate on the business aspects of a developed system, leaving the performance aspects to the specialists – the authors of the library. One example of such a library is <strong class="source-inline">java.util.stream</strong>, which is going to be the focus of this chapter.</p>
			<p>In <a href="B18388_05_ePub.xhtml#_idTextAnchor121"><em class="italic">Chapter 5</em></a>, <em class="italic">Strings, Input/Output, and Files</em>, we talked about I/O streams as a source of data, but beyond that, they are not of much help for further processing of data. Also, they are byte- or character-based, not object-based. You can create a stream of objects only after objects have been programmatically created and serialized first. The I/O streams are just connections to external resources, mostly files, and not much else. However, sometimes it is possible to make a transition from an I/O stream to <strong class="source-inline">java.util.stream.Stream</strong>. For example, the <strong class="source-inline">BufferedReader</strong> class has the <strong class="source-inline">lines()</strong> method that converts the underlying character-based stream into a <strong class="source-inline">Stream&lt;String&gt;</strong> object.</p>
			<p>On the other hand, the streams of the <strong class="source-inline">java.util.stream</strong> package are oriented toward processing collections of objects. In <em class="italic">Chapter 2</em>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>, we described two methods of the <strong class="source-inline">Collection</strong> interface that allow you to read collection elements as elements of a stream: <strong class="source-inline">default Stream&lt;E&gt; stream()</strong> and <strong class="source-inline">default Stream&lt;E&gt; parallelStream()</strong>. We also mentioned the <strong class="source-inline">stream()</strong> method of <strong class="source-inline">java.util.Arrays</strong>. It has the following eight overloaded versions that convert an array or part of it into a stream of the corresponding data types:</p>
			<ul>
				<li><strong class="source-inline">static DoubleStream stream(double[] array)</strong></li>
				<li><strong class="source-inline">static DoubleStream stream(double[] array, int startInclusive, int endExclusive)</strong></li>
				<li><strong class="source-inline">static IntStream stream(int[] array)</strong></li>
				<li><strong class="source-inline">static IntStream stream(int[] array, int startInclusive, int endExclusive) </strong></li>
				<li><strong class="source-inline">static LongStream stream(long[] array) </strong></li>
				<li><strong class="source-inline">static LongStream stream(long[] array, int startInclusive, int endExclusive) </strong></li>
				<li><strong class="source-inline">static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) </strong></li>
				<li><strong class="source-inline">static &lt;T&gt; Stream&lt;T&gt; stream(T[] array, int startInclusive, int endExclusive) </strong></li>
			</ul>
			<p>Let’s now look closer at the streams of the <strong class="source-inline">java.util.stream</strong> package. The best way to understand what a stream is is to compare it with a collection. The latter is a data structure <a id="_idIndexMarker1532"/>stored in memory. Every collection element is <a id="_idIndexMarker1533"/>computed before being added to the collection. By contrast, an element emitted by a stream exists somewhere else, in the source, and is computed on demand. So, a collection can be a source for a stream.</p>
			<p>A <strong class="source-inline">Stream</strong> object is an implementation of the <strong class="source-inline">Stream</strong> interface, <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong>, or <strong class="source-inline">DoubleStream</strong>; the last three are called <strong class="bold">numeric streams</strong>. The <a id="_idIndexMarker1534"/>methods of the <strong class="source-inline">Stream</strong> interface are also available in numeric streams. Some of the numeric streams have a few extra methods, such as <strong class="source-inline">average()</strong> and <strong class="source-inline">sum()</strong>, which are specific numeric values. In this chapter, we are going to speak mostly about the <strong class="source-inline">Stream</strong> interface and its methods, but everything we will cover is equally applicable to numeric streams too.</p>
			<p>A stream <em class="italic">produces</em> (or <em class="italic">emits</em>) stream elements as soon as a previously emitted element has been processed. It allows declarative presentation of methods (operations) that can be applied to the emitted elements, also in parallel. Today, when the machine learning requirements of large dataset processing are becoming ubiquitous, this feature reinforces the position of Java as one of the few modern programming languages of choice.</p>
			<p>Will all that said, we will start with a stream initialization.</p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor299"/>Stream initialization</h1>
			<p>There are many<a id="_idIndexMarker1535"/> ways to create and initialize a stream – an object of type <strong class="source-inline">Stream</strong> or any of the numeric interfaces. We grouped them by classes and interfaces that have stream-creating methods. We did it for your convenience so that it would be easier for you to remember and find them if need be.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor300"/>Stream interface</h2>
			<p>This group of <strong class="source-inline">Stream</strong> factories <a id="_idIndexMarker1536"/>is composed of static methods that belong to the <strong class="source-inline">Stream</strong> interface.</p>
			<h3>empty()</h3>
			<p>The <strong class="source-inline">Stream&lt;T&gt; empty()</strong> method <a id="_idIndexMarker1537"/>creates an empty <a id="_idIndexMarker1538"/>stream that does not emit any element:</p>
			<pre class="source-code">Stream.empty().forEach(System.out::println);   //prints nothing</pre>
			<p>The <strong class="source-inline">forEach()</strong>  <strong class="source-inline">Stream</strong> method acts similarly to the <strong class="source-inline">forEach()</strong> <strong class="source-inline">Collection</strong> method and applies the passed-in function to each of the stream elements:</p>
			<pre class="source-code">new ArrayList().forEach(System.out::println);  //prints nothing</pre>
			<p>The result is the same as creating a stream from an empty collection:</p>
			<pre class="source-code">new ArrayList().stream().forEach(System.out::println);  </pre>
			<pre class="source-code">                                               //prints nothing</pre>
			<p>Without any element emitted, nothing happens. We will discuss the <strong class="source-inline">forEach()</strong> <strong class="source-inline">Stream</strong> method in the <em class="italic">Terminal operations</em> subsection.</p>
			<h3>of(T... values)</h3>
			<p>The <strong class="source-inline">of(T... values)</strong> method<a id="_idIndexMarker1539"/> accepts varargs and can<a id="_idIndexMarker1540"/> also create an empty stream:</p>
			<pre class="source-code">Stream.of().forEach(System.out::print);       //prints nothing</pre>
			<p>However, it is most often used for initializing a non-empty stream:</p>
			<pre class="source-code">Stream.of(1).forEach(System.out::print);           //prints: 1</pre>
			<pre class="source-code">Stream.of(1,2).forEach(System.out::print);         //prints: 12</pre>
			<pre class="source-code">Stream.of("1 ","2").forEach(System.out::print);   //prints: 1 2</pre>
			<p>Note the method reference used for the invocation of the <strong class="source-inline">println()</strong> and <strong class="source-inline">print()</strong> methods.</p>
			<p>Another way to use the <strong class="source-inline">of(T... values)</strong> method is as follows:</p>
			<pre class="source-code">String[] strings = {"1 ", "2"};</pre>
			<pre class="source-code">Stream.of(strings).forEach(System.out::print);    //prints: 1 2</pre>
			<p>If there is no type specified for the <strong class="source-inline">Stream</strong> object, the compiler does not complain if the array contains a mix of types:</p>
			<pre class="source-code">Stream.of("1 ", 2).forEach(System.out::print);    //prints: 1 2</pre>
			<p>Adding generics that declare the expected element type causes an exception when at least one of the listed elements has a different type:</p>
			<pre class="source-code">//Stream&lt;String&gt; stringStream = Stream.of("1 ", 2);   </pre>
			<pre class="source-code">                                                //compile error</pre>
			<p>Generics help a programmer to avoid many mistakes, so they should be added wherever possible.</p>
			<p>The <strong class="source-inline">of(T... values)</strong> method can also be used for the concatenation of multiple streams. Let’s assume, for example, that we have the following four streams that we would like to concatenate into one:</p>
			<pre class="source-code">Stream&lt;Integer&gt; stream1 = Stream.of(1, 2);</pre>
			<pre class="source-code">Stream&lt;Integer&gt; stream2 = Stream.of(2, 3);</pre>
			<pre class="source-code">Stream&lt;Integer&gt; stream3 = Stream.of(3, 4);</pre>
			<pre class="source-code">Stream&lt;Integer&gt; stream4 = Stream.of(4, 5);</pre>
			<p>We would like to concatenate them into a new stream that emits the <strong class="source-inline">1,2,2,3,3,4,4,5</strong> values. First, we try the following code:</p>
			<pre class="source-code">Stream.of(stream1, stream2, stream3, stream4)</pre>
			<pre class="source-code">   .forEach(System.out::print);</pre>
			<pre class="source-code">     //prints: java.util.stream.ReferencePipeline$Head@58ceff1j</pre>
			<p>It does not do what we hoped for. It treats each stream as an object of the <strong class="source-inline">java.util.stream.ReferencePipeline</strong> internal class that is used in the <strong class="source-inline">Stream</strong> interface implementation. So, we need to add the <strong class="source-inline">flatMap()</strong> operation to convert each stream element into a stream (which we will describe in the <em class="italic">Intermediate operations</em> subsection):</p>
			<pre class="source-code">Stream.of(stream1, stream2, stream3, stream4)</pre>
			<pre class="source-code"> .flatMap(e -&gt; e).forEach(System.out::print);   </pre>
			<pre class="source-code">                                             //prints: 12233445</pre>
			<p>The function we passed into <strong class="source-inline">flatMap()</strong> as a parameter (<strong class="source-inline">e -&gt; e</strong>) looks like it’s doing nothing, but that is because each element of the stream is a stream already, so there is no need <a id="_idIndexMarker1541"/>to<a id="_idIndexMarker1542"/> transform it. By returning an element as the result of the <strong class="source-inline">flatMap()</strong> operation, we tell the pipeline to treat the return value as a <strong class="source-inline">Stream</strong> object.</p>
			<h3>ofNullable(T t)</h3>
			<p>The <strong class="source-inline">ofNullable(T t)</strong> method<a id="_idIndexMarker1543"/> returns <strong class="source-inline">Stream&lt;T&gt;</strong>, emitting <a id="_idIndexMarker1544"/>a single element if the passed-in <strong class="source-inline">t</strong> parameter is not <strong class="source-inline">null</strong>; otherwise, it returns an empty <strong class="source-inline">Stream</strong>. To demonstrate the usage of the <strong class="source-inline">ofNullable(T t)</strong> method, we create the following method:</p>
			<pre class="source-code">void printList1(List&lt;String&gt; list){</pre>
			<pre class="source-code">    list.stream().forEach(System.out::print);</pre>
			<pre class="source-code">}</pre>
			<p>We execute this method twice – with the parameter list equal to <strong class="source-inline">null</strong> and a <strong class="source-inline">List</strong> object. Here are the results:</p>
			<pre class="source-code">//printList1(null);                      //NullPointerException</pre>
			<pre class="source-code">List&lt;String&gt; list = List.of("1 ", "2");</pre>
			<pre class="source-code">printList1(list);                          //prints: 1 2</pre>
			<p>Note how the first call to the <strong class="source-inline">printList1()</strong> method generates <strong class="source-inline">NullPointerException</strong>. To avoid the exception, we can implement the method as follows:</p>
			<pre class="source-code">void printList1(List&lt;String&gt; list){ </pre>
			<pre class="source-code">     (list == null ? Stream.empty() : list.stream()) </pre>
			<pre class="source-code">                           .forEach(System.out::print);</pre>
			<pre class="source-code">} </pre>
			<p>The same<a id="_idIndexMarker1545"/> result<a id="_idIndexMarker1546"/> can be achieved with the <strong class="source-inline">ofNullable(T t)</strong> method:</p>
			<pre class="source-code">void printList2(List&lt;String&gt; list){</pre>
			<pre class="source-code">    Stream.ofNullable(list).flatMap(l -&gt; l.stream())</pre>
			<pre class="source-code">                           .forEach(System.out::print);</pre>
			<pre class="source-code">}</pre>
			<p>Note how we have added <strong class="source-inline">flatMap()</strong> because, otherwise, the <strong class="source-inline">Stream</strong> element that flows into <strong class="source-inline">forEach()</strong> would be a <strong class="source-inline">List</strong> object. We will talk more about the <strong class="source-inline">flatMap()</strong> method in the <em class="italic">Intermediate operations</em> subsection. The function passed into the <strong class="source-inline">flatMap()</strong> operation in the preceding code can be expressed as a method reference too:</p>
			<pre class="source-code">void printList4(List&lt;String&gt; list){</pre>
			<pre class="source-code">    Stream.ofNullable(list).flatMap(Collection::stream)</pre>
			<pre class="source-code">                           .forEach(System.out::print);</pre>
			<pre class="source-code">}</pre>
			<h3>Iterate (Objectand UnaryOperator)</h3>
			<p>Two static <a id="_idIndexMarker1547"/>methods of the <strong class="source-inline">Stream</strong> interface <a id="_idIndexMarker1548"/>allow you to generate a stream of values using an iterative process similar to the traditional <strong class="source-inline">for</strong> loop, as follows:</p>
			<ul>
				<li><strong class="source-inline">Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; func)</strong>: This creates an infinite sequential stream based on the iterative application of the second parameter, the <strong class="source-inline">func</strong> function, to the first <strong class="source-inline">seed</strong> parameter, producing a stream of values: <strong class="source-inline">seed</strong>, <strong class="source-inline">f(seed)</strong>, <strong class="source-inline">f(f(seed))</strong>, and so on.</li>
				<li><strong class="source-inline">Stream&lt;T&gt; iterate(T seed, Predicate&lt;T&gt; hasNext, UnaryOperator&lt;T&gt; next)</strong>: This creates a finite sequential stream based on the iterative application of the third parameter, the <strong class="source-inline">next</strong> function, to the first <strong class="source-inline">seed</strong> parameter, producing a stream of values: <strong class="source-inline">seed</strong>, <strong class="source-inline">f(seed)</strong>, <strong class="source-inline">f(f(seed))</strong>, and so on, as long as the third parameter, the <strong class="source-inline">hasNext</strong> function, returns <strong class="source-inline">true</strong>.</li>
			</ul>
			<p>The following code demonstrates the usage of these methods, as follows:</p>
			<pre class="source-code">Stream.iterate(1, i -&gt; ++i).limit(9)</pre>
			<pre class="source-code">      .forEach(System.out::print);   //prints: 123456789</pre>
			<pre class="source-code">Stream.iterate(1, i -&gt; i &lt; 10, i -&gt; ++i)</pre>
			<pre class="source-code">      .forEach(System.out::print);   //prints: 123456789</pre>
			<p>Note that we were forced to add an intermediate operator, <strong class="source-inline">limit(int n)</strong>, to the first pipeline to avoid generating an infinite number of generated values. We will talk more about this method in the <em class="italic">Intermediate operations</em> subsection. </p>
			<h3>concat (stream a and stream b)</h3>
			<p>The <strong class="source-inline">Stream&lt;T&gt; concat(Stream&lt;&gt; a, Stream&lt;T&gt; b)</strong> static method of the <strong class="source-inline">Stream</strong> interface<a id="_idIndexMarker1549"/> creates a stream of values<a id="_idIndexMarker1550"/> based on two streams, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>, passed in as parameters. The newly created stream consists of all the elements of the first parameter, <strong class="source-inline">a</strong>, followed by all the elements of the second parameter, <strong class="source-inline">b</strong>. The following code demonstrates this method:</p>
			<pre class="source-code">Stream&lt;Integer&gt; stream1 = List.of(1, 2).stream();</pre>
			<pre class="source-code">Stream&lt;Integer&gt; stream2 = List.of(2, 3).stream();</pre>
			<pre class="source-code">Stream.concat(stream1, stream2)</pre>
			<pre class="source-code"> .forEach(System.out::print); //prints: 1223</pre>
			<p>Note that the <strong class="source-inline">2</strong> element is present in both original streams and consequently is emitted twice by the resulting stream.</p>
			<h3>generate (Supplier)</h3>
			<p>The <strong class="source-inline">Stream&lt;T&gt; generate(Supplier&lt;T&gt; supplier)</strong> static <a id="_idIndexMarker1551"/>method of the <strong class="source-inline">Stream</strong> interface <a id="_idIndexMarker1552"/>creates an infinite stream, where each element is generated by the provided <strong class="source-inline">Supplier&lt;T&gt;</strong> function. The following are two examples:</p>
			<pre class="source-code">Stream.generate(() -&gt; 1).limit(5)</pre>
			<pre class="source-code"> .forEach(System.out::print);    //prints: 11111</pre>
			<pre class="source-code">Stream.generate(() -&gt; new Random().nextDouble()).limit(5)</pre>
			<pre class="source-code">   .forEach(System.out::println);  //prints: 0.38575117472619247</pre>
			<pre class="source-code">                                   //        0.5055765386778835</pre>
			<pre class="source-code">                                   //        0.6528038976983277</pre>
			<pre class="source-code">                                   //        0.4422354489467244</pre>
			<pre class="source-code">                                   //        0.06770955839148762</pre>
			<p>If you run this code, you will probably get different results because of the random (pseudo-random) nature of the generated values.</p>
			<p>Since the created stream is infinite, we have added a <strong class="source-inline">limit(int n)</strong> operation that allows only the specified number of stream elements to flow through. We will talk more about this <a id="_idIndexMarker1553"/>method<a id="_idIndexMarker1554"/> in the <em class="italic">Intermediate operations</em> subsection. </p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor301"/>The Stream.Builder interface</h2>
			<p>The <strong class="source-inline">Stream.Builder&lt;T&gt; builder()</strong> static <a id="_idIndexMarker1555"/>method <a id="_idIndexMarker1556"/>returns an internal (located inside the <strong class="source-inline">Stream</strong> interface)  <strong class="source-inline">Builder</strong> interface that can be used to construct a <strong class="source-inline">Stream</strong> object. The interface <strong class="source-inline">Builder</strong> extends the <strong class="source-inline">Consumer</strong> interface and has the following methods:</p>
			<ul>
				<li><strong class="source-inline">default Stream.Builder&lt;T&gt; add(T t)</strong>: This calls the <strong class="source-inline">accept(T)</strong> method and returns the <strong class="source-inline">Builder</strong> object, thus allowing you to chain the <strong class="source-inline">add (T t)</strong> methods in a fluent dot-connected style.</li>
				<li><strong class="source-inline">void accept(T t)</strong>: This adds an element to the stream (this method comes from the <strong class="source-inline">Consumer</strong> interface).</li>
				<li><strong class="source-inline">Stream&lt;T&gt; build()</strong>: This transitions this builder from the constructing state to the <strong class="source-inline">built</strong> state. After this method is called, no new elements can be added to this stream.</li>
			</ul>
			<p>The usage of the <strong class="source-inline">add(T t)</strong> method is straightforward:</p>
			<pre class="source-code">Stream.&lt;String&gt;builder().add("cat").add(" dog").add(" bear")</pre>
			<pre class="source-code">   .build().forEach(System.out::print);  //prints: cat dog bear</pre>
			<p>Note how we have added the <strong class="source-inline">&lt;String&gt;</strong> generics in front of the <strong class="source-inline">builder()</strong> method. This way, we tell the builder that the stream we are creating will have <strong class="source-inline">String</strong>-type elements. Otherwise, it will add the elements as <strong class="source-inline">Object</strong> types and not make sure that the added elements are of the <strong class="source-inline">String</strong> type.</p>
			<p>The <strong class="source-inline">accept(T t)</strong> method is used when the builder is passed as a parameter of the <strong class="source-inline">Consumer&lt;T&gt;</strong> type or when you do not need to chain the methods that add the elements. The following is a code example:</p>
			<pre class="source-code">Stream.Builder&lt;String&gt; builder = Stream.builder();</pre>
			<pre class="source-code">List.of("1", "2", "3").stream().forEach(builder);   </pre>
			<pre class="source-code">builder.build().forEach(System.out::print);    //prints: 123</pre>
			<p>The <strong class="source-inline">forEach(Consumer&lt;T&gt; consumer)</strong> method accepts a <strong class="source-inline">Consumer</strong> function that has the <strong class="source-inline">accept(T t)</strong> method. Every time an element is emitted by the stream, the <strong class="source-inline">forEach()</strong> method receives it and passes it to the <strong class="source-inline">accept(T t)</strong> method of the <strong class="source-inline">Builder</strong> object. Then, when the <strong class="source-inline">build()</strong> method is called in the next line, the <strong class="source-inline">Stream</strong> object is created and starts emitting the elements added earlier by the <strong class="source-inline">accept(T t)</strong> method. The <a id="_idIndexMarker1557"/>emitted elements are <a id="_idIndexMarker1558"/>passed to the <strong class="source-inline">forEach()</strong> method, which then prints them one by one.</p>
			<p>Here is an example of an explicit usage of the <strong class="source-inline">accept(T t)</strong> method:</p>
			<pre class="source-code">List&lt;String&gt; values = List.of("cat", " dog", " bear");</pre>
			<pre class="source-code">Stream.Builder&lt;String&gt; builder = Stream.builder();</pre>
			<pre class="source-code">for(String s: values){</pre>
			<pre class="source-code">    if(s.contains("a")){</pre>
			<pre class="source-code">        builder.accept(s);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">builder.build().forEach(System.out::print);  //prints: cat bear</pre>
			<p>This time, we decided not to add all the list elements to the stream but only those that contain the <strong class="source-inline">a</strong> character. As expected, the created stream contains only the <strong class="source-inline">cat</strong> and <strong class="source-inline">bear</strong> elements. Also, note how we use <strong class="source-inline">&lt;String&gt;</strong> generics to make sure that all the stream<a id="_idIndexMarker1559"/> elements <a id="_idIndexMarker1560"/>are of the <strong class="source-inline">String</strong> type.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor302"/>Other classes and interfaces</h2>
			<p>In Java 8, two default <a id="_idIndexMarker1561"/>methods were added to the <strong class="source-inline">java.util.Collection</strong> interface, as follows:</p>
			<ul>
				<li><strong class="source-inline">Stream&lt;E&gt; stream()</strong>: This returns a stream of the elements of this collection.</li>
				<li><strong class="source-inline">Stream&lt;E&gt; parallelStream()</strong>: This returns (possibly) a parallel stream of the elements of this collection – we say <em class="italic">possibly</em>, because the JVM attempts to split the stream into several chunks and process them in parallel (if there are several CPUs) or virtually parallel (using CPU time-sharing). However, it is not always possible and depends, in part, on the nature of the requested processing.</li>
			</ul>
			<p>This means that all the collection interfaces that extend this interface, including <strong class="source-inline">Set</strong> and <strong class="source-inline">List</strong>, have these methods, as shown in this example: </p>
			<pre class="source-code">List.of("1", "2", "3").stream().forEach(builder);</pre>
			<pre class="source-code">List.of("1", "2", "3").parallelStream().forEach(builder);</pre>
			<p>We will talk about parallel streams in the <em class="italic">Parallel streams</em> section.</p>
			<p>We described eight static overloaded <strong class="source-inline">stream()</strong> methods of the <strong class="source-inline">java.util.Arrays</strong> class at the beginning of the <em class="italic">Streams as a source of data and operations</em> section. Here is an example of another way of creating a stream, using the subset of an array:</p>
			<pre class="source-code">int[] arr = {1, 2, 3, 4, 5}; </pre>
			<pre class="source-code">Arrays.stream(arr, 2, 4).forEach(System.out::print); </pre>
			<pre class="source-code">                                                   //prints: 34 </pre>
			<p>The <strong class="source-inline">java.util.Random</strong> class allows you to create numeric streams of pseudo-random values, as follows:</p>
			<ul>
				<li><strong class="source-inline">DoubleStream doubles()</strong>: Creates an unlimited stream of <strong class="source-inline">double</strong> values between <strong class="source-inline">0</strong> (inclusive) and <strong class="source-inline">1</strong> (exclusive)</li>
				<li><strong class="source-inline">IntStream ints()</strong> and <strong class="source-inline">LongStream longs()</strong>: Creates an unlimited stream of corresponding type values</li>
				<li><strong class="source-inline">DoubleStream doubles(long streamSize)</strong>: Creates a stream (of the specified size) of <strong class="source-inline">double</strong> values between <strong class="source-inline">0</strong> (inclusive) and <strong class="source-inline">1</strong> (exclusive)</li>
				<li><strong class="source-inline">IntStream ints(long streamSize)</strong> and <strong class="source-inline">LongStream longs(long streamSize)</strong>: Creates a stream of the specified size of the corresponding type values</li>
				<li><strong class="source-inline">IntStream ints(int randomNumberOrigin, int randomNumberBound)</strong>: Creates an<a id="_idIndexMarker1562"/> unlimited stream of <strong class="source-inline">int</strong> values between <strong class="source-inline">randomNumberOrigin</strong> (inclusive) and <strong class="source-inline">randomNumberBound</strong> (exclusive)</li>
				<li><strong class="source-inline">LongStream longs(long randomNumberOrigin, long randomNumberBound)</strong>: Creates an unlimited stream of <strong class="source-inline">long</strong> values between <strong class="source-inline">randomNumberOrigin</strong> (inclusive) and <strong class="source-inline">randomNumberBound</strong> (exclusive)</li>
				<li><strong class="source-inline">DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)</strong>: Creates a stream of the specified size of <strong class="source-inline">double</strong> values between <strong class="source-inline">randomNumberOrigin</strong> (inclusive) and <strong class="source-inline">randomNumberBound</strong> (exclusive)</li>
			</ul>
			<p>Here is an example of one of the preceding methods:</p>
			<pre class="source-code">new Random().ints(5, 8).limit(5) </pre>
			<pre class="source-code">            .forEach(System.out::print);    //prints: 56757 </pre>
			<p>Due to the use of <strong class="source-inline">random</strong>, every execution may (and probably will) generate a different result.</p>
			<p>The <strong class="source-inline">java.nio.file.Files</strong> class has six static methods creating streams of lines and paths, as follows:</p>
			<ul>
				<li><strong class="source-inline">Stream&lt;String&gt; lines(Path path)</strong>: Creates a stream of lines from the file specified by the provided path</li>
				<li><strong class="source-inline">Stream&lt;String&gt; lines(Path path, Charset cs)</strong>: Creates a stream of lines from the file specified by the provided path; bytes from the file are decoded into characters using the provided <strong class="source-inline">charset</strong></li>
				<li><strong class="source-inline">Stream&lt;Path&gt; list(Path dir)</strong>: Creates a stream of files and directories in the specified directory</li>
				<li><strong class="source-inline">Stream&lt;Path&gt; walk(Path start, FileVisitOption... options)</strong>: Creates a<a id="_idIndexMarker1563"/> stream of files and directories of the file tree that starts with <strong class="source-inline">Path start</strong></li>
				<li><strong class="source-inline">Stream&lt;Path&gt; walk(Path start, int maxDepth, FileVisitOption... options)</strong>: Creates a stream of files and directories of the file tree that starts with <strong class="source-inline">Path start</strong>, down to the specified <strong class="source-inline">maxDepth</strong> depth </li>
				<li><strong class="source-inline">Stream&lt;Path&gt; find(Path start, int maxDepth, BiPredicate&lt;Path, BasicFileAttributes&gt; matcher, FileVisitOption... options)</strong>: Creates a stream of files and directories (that match the provided predicate) of the file tree that starts with <strong class="source-inline">Path start</strong>, down to the specified depth, specified by the <strong class="source-inline">maxDepth</strong> value</li>
			</ul>
			<p>Other classes and methods that create streams include the following:</p>
			<ul>
				<li>The <strong class="source-inline">java.util.BitSet</strong> class has the <strong class="source-inline">IntStream stream()</strong> method, which creates a stream of indices, for which this <strong class="source-inline">BitSet</strong> contains a bit in the <strong class="source-inline">set</strong> state.</li>
				<li>The <strong class="source-inline">java.io.BufferedReader</strong> class has the <strong class="source-inline">Stream&lt;String&gt; lines()</strong> method, which creates a stream of lines from this <strong class="source-inline">BufferedReader</strong> object, typically from a file.</li>
				<li>The <strong class="source-inline">java.util.jar.JarFile</strong> class has the <strong class="source-inline">Stream&lt;JarEntry&gt; stream()</strong> method that creates a stream of ZIP file entries.</li>
				<li>The <strong class="source-inline">java.util.regex.Pattern</strong> class has the <strong class="source-inline">Stream&lt;String&gt; splitAsStream(CharSequence input)</strong> method, which creates a stream from the provided sequence around matches of this pattern.</li>
			</ul>
			<p>A <strong class="source-inline">java.lang.CharSequence</strong> interface has two methods, as follows:</p>
			<ul>
				<li><strong class="source-inline">default IntStream chars()</strong>: Creates a stream of <strong class="source-inline">int</strong>, zero-extending the <strong class="source-inline">char</strong> values</li>
				<li><strong class="source-inline">default IntStream codePoints()</strong>: Creates a stream of code point values from this sequence</li>
			</ul>
			<p>There is also a <strong class="source-inline">java.util.stream.StreamSupport</strong> class that contains static low-level utility<a id="_idIndexMarker1564"/> methods for library developers. However, we won’t be reviewing it, as this is outside the scope of this book.</p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor303"/>Operations (methods)</h1>
			<p>Many <a id="_idIndexMarker1565"/>methods <a id="_idIndexMarker1566"/>of the <strong class="source-inline">Stream</strong> interface, including those that have a functional interface type as a parameter, are called <strong class="bold">operations</strong> because they are not implemented as traditional methods. Their functionality is passed into a method as a function. The operations are just shells that call a method of the functional interface, assigned as the type of the <strong class="source-inline">parameter</strong> method.</p>
			<p>For example, let’s look at the <strong class="source-inline">Stream&lt;T&gt; filter (Predicate&lt;T&gt; predicate)</strong> method. Its implementation is based on the call to the <strong class="source-inline">test(T t)</strong> method Boolean of the <strong class="source-inline">Predicate&lt;T&gt;</strong> function. So, instead of saying, <em class="italic">we use the </em><strong class="source-inline">filter()</strong><em class="italic"> method of the </em><strong class="source-inline">Stream</strong><em class="italic"> object to select some of the stream elements and skip others,</em> programmers prefer to say, <em class="italic">we apply an operation filter that allows some of the stream elements to get through and skip others</em>. It describes the nature of the action (operation), not the particular algorithm, which is unknown until the method receives a particular function. There are two groups of operations in the <strong class="source-inline">Stream</strong> interface, as follows:</p>
			<ul>
				<li><strong class="bold">Intermediate operations</strong>: Instance methods that return a <strong class="source-inline">Stream</strong> object</li>
				<li><strong class="bold">Terminal operations</strong>: Instance methods that return some type other than <strong class="source-inline">Stream</strong></li>
			</ul>
			<p>Stream processing is organized typically as a pipeline, using a fluent (dot-connected) style. A <strong class="source-inline">Stream</strong>-creating method or another stream source starts such a pipeline. A terminal operation produces the final result or a side effect and eponymously ends the pipeline. An intermediate operation can be placed between the originating <strong class="source-inline">Stream</strong> object and the terminal operation.</p>
			<p>An intermediate operation processes stream elements (or not, in some cases) and returns the modified (or not) <strong class="source-inline">Stream</strong> object, so the next intermediate or terminal operation can <a id="_idIndexMarker1567"/>be <a id="_idIndexMarker1568"/>applied. Examples of intermediate operations are the following:</p>
			<ul>
				<li><strong class="source-inline">Stream&lt;T&gt; filter(Predicate&lt;T&gt; predicate)</strong>: Selects only elements matching a criterion.</li>
				<li><strong class="source-inline">Stream&lt;R&gt; map(Function&lt;T,R&gt; mapper)</strong>: Transforms elements according to the passed-in function. Note that the type of the returned <strong class="source-inline">Stream</strong> object may be quite different from the input type.</li>
				<li><strong class="source-inline">Stream&lt;T&gt; distinct()</strong>: Removes duplicates.</li>
				<li><strong class="source-inline">Stream&lt;T&gt; limit(long maxSize)</strong>: Limits a stream to the specified number of elements.</li>
				<li><strong class="source-inline">Stream&lt;T&gt; sorted()</strong>: Arranges the stream elements in a certain order.</li>
			</ul>
			<p>We will discuss some other intermediate operations in the <em class="italic">Intermediate operations</em> section.</p>
			<p>The processing of the stream elements actually begins only when a terminal operation starts executing. Then, all the intermediate operations (if present) start processing in sequence. As soon as the terminal operation has finished execution, the stream closes and cannot be reopened.</p>
			<p>Examples of terminal operations are <strong class="source-inline">forEach()</strong>, <strong class="source-inline">findFirst()</strong>, <strong class="source-inline">reduce()</strong>, <strong class="source-inline">collect()</strong>, <strong class="source-inline">sum()</strong>, <strong class="source-inline">max()</strong>, and other methods of the <strong class="source-inline">Stream</strong> interface that do not return the <strong class="source-inline">Stream</strong> object. We will discuss them in the <em class="italic">Terminal operations</em> subsection.</p>
			<p>All the <strong class="source-inline">Stream</strong> operations support parallel processing, which is especially helpful in the case of a large amount <a id="_idIndexMarker1569"/>of<a id="_idIndexMarker1570"/> data processed on a multi-core computer. We will discuss it in the <em class="italic">Parallel streams</em> subsection.</p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor304"/>Intermediate operations</h2>
			<p>As we mentioned<a id="_idIndexMarker1571"/> already, an intermediate<a id="_idIndexMarker1572"/> operation returns a <strong class="source-inline">Stream</strong> object that emits the same or modified values and may even be of a different type than the stream source.</p>
			<p>The intermediate operations can be grouped by their functionality into four categories of operations that perform <strong class="bold">filtering</strong>, <strong class="bold">mapping</strong>, <strong class="bold">sorting</strong>, or <strong class="bold">peeking</strong>.</p>
			<h3>Filtering</h3>
			<p>This group <a id="_idIndexMarker1573"/>includes operations that remove duplicates, skip some of the elements, limit the number of processed elements, and select for further processing only those that pass certain criteria, as follows:</p>
			<ul>
				<li><strong class="source-inline">Stream&lt;T&gt; distinct()</strong>: Compares stream elements using <strong class="source-inline">Object.equals(Object)</strong> method and skips duplicates</li>
				<li><strong class="source-inline">Stream&lt;T&gt; skip(long n)</strong>: Ignores the provided number of stream elements that are emitted first</li>
				<li><strong class="source-inline">Stream&lt;T&gt; limit(long maxSize)</strong>: Allows only the provided number of stream elements to be processed</li>
				<li><strong class="source-inline">Stream&lt;T&gt; filter(Predicate&lt;T&gt; predicate)</strong>: Allows only those elements to be processed that result in <strong class="source-inline">true</strong> when processed by the provided <strong class="source-inline">Predicate</strong> function</li>
				<li><strong class="source-inline">default Stream&lt;T&gt; dropWhile(Predicate&lt;T&gt; predicate)</strong>: Skips those first elements of the stream that result in <strong class="source-inline">true</strong> when processed by the provided <strong class="source-inline">Predicate</strong> function</li>
				<li><strong class="source-inline">default Stream&lt;T&gt; takeWhile(Predicate&lt;T&gt; predicate)</strong>: Allows only those first elements of the stream to be processed that result in <strong class="source-inline">true</strong> when processed by the provided <strong class="source-inline">Predicate</strong> function</li>
			</ul>
			<p>The following<a id="_idIndexMarker1574"/> is code that demonstrates how the operations just described work:</p>
			<pre class="source-code">Stream.of("3", "2", "3", "4", "2").distinct()</pre>
			<pre class="source-code">                  .forEach(System.out::print);    //prints: 324</pre>
			<pre class="source-code">List&lt;String&gt; list = List.of("1", "2", "3", "4", "5");</pre>
			<pre class="source-code">list.stream().skip(3).forEach(System.out::print);  //prints: 45</pre>
			<pre class="source-code">list.stream().limit(3).forEach(System.out::print); </pre>
			<pre class="source-code">                                                  //prints: 123</pre>
			<pre class="source-code">list.stream().filter(s -&gt; Objects.equals(s, "2"))</pre>
			<pre class="source-code">             .forEach(System.out::print);          //prints: 2</pre>
			<pre class="source-code">list.stream().dropWhile(s -&gt; Integer.valueOf(s) &lt; 3)</pre>
			<pre class="source-code">             .forEach(System.out::print);         //prints: 345</pre>
			<pre class="source-code">list.stream().takeWhile(s -&gt; Integer.valueOf(s) &lt; 3)</pre>
			<pre class="source-code">             .forEach(System.out::print);          //prints: 12</pre>
			<p>Note that we were able to<a id="_idIndexMarker1575"/> reuse the source <strong class="source-inline">List&lt;String&gt;</strong> object but could not reuse the <strong class="source-inline">Stream</strong> object. Once a <strong class="source-inline">Stream</strong> object is closed, it cannot be reopened.</p>
			<h3>Mapping</h3>
			<p>This group includes <a id="_idIndexMarker1576"/>arguably the most important intermediate operations. They are the only intermediate operations that modify the elements of the stream. They <strong class="bold">map</strong> (transform) the original stream element value to a new one, as follows:</p>
			<ul>
				<li><strong class="source-inline">Stream&lt;R&gt; map(Function&lt;T, R&gt; mapper)</strong>: Applies the provided function to each element of type <strong class="source-inline">T</strong> of the stream and produces a new element value of type <strong class="source-inline">R</strong></li>
				<li><strong class="source-inline">IntStream mapToInt(ToIntFunction&lt;T&gt; mapper)</strong>: Applies the provided function to each element of type <strong class="source-inline">T</strong> of the stream and produces a new element value of type <strong class="source-inline">int</strong></li>
				<li><strong class="source-inline">LongStream mapToLong(ToLongFunction&lt;T&gt; mapper)</strong>: Applies the provided function to each element of type <strong class="source-inline">T</strong> of the stream and produces a new element value of type <strong class="source-inline">long</strong></li>
				<li><strong class="source-inline">DoubleStream mapToDouble(ToDoubleFunction&lt;T&gt; mapper)</strong>: Applies the provided function to each element of type <strong class="source-inline">T</strong> of the stream and produces a new element value of type <strong class="source-inline">double</strong></li>
				<li><strong class="source-inline">Stream&lt;R&gt; flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper)</strong>: Applies the provided function to each element of type <strong class="source-inline">T</strong> of the stream and produces a <strong class="source-inline">Stream&lt;R&gt;</strong> object that emits elements of type <strong class="source-inline">R</strong></li>
				<li><strong class="source-inline">IntStream flatMapToInt(Function&lt;T, IntStream&gt; mapper)</strong>: Applies the provided function to each element of type <strong class="source-inline">T</strong> of the stream and produces a <strong class="source-inline">IntStream</strong> object that emits elements of type <strong class="source-inline">int</strong></li>
				<li><strong class="source-inline">LongStream flatMapToLong(Function&lt;T, LongStream&gt; mapper)</strong>: Applies the provided function to each element of type <strong class="source-inline">T</strong> of the stream and produces a <strong class="source-inline">LongStream</strong> object that emits elements of type <strong class="source-inline">long</strong></li>
				<li><strong class="source-inline">DoubleStream flatMapToDouble(Function&lt;T, DoubleStream&gt; mapper)</strong>: Applies the provided function to each element of type <strong class="source-inline">T</strong> of the stream and produces a <strong class="source-inline">DoubleStream</strong> object that emits elements of type <strong class="source-inline">double</strong></li>
			</ul>
			<p>The following are<a id="_idIndexMarker1577"/> examples of the usage of these operations, as follows:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("1", "2", "3", "4", "5");</pre>
			<pre class="source-code">list.stream().map(s -&gt; s + s)</pre>
			<pre class="source-code">             .forEach(System.out::print);  //prints: 1122334455</pre>
			<pre class="source-code">list.stream().mapToInt(Integer::valueOf)</pre>
			<pre class="source-code">             .forEach(System.out::print);  //prints: 12345</pre>
			<pre class="source-code">list.stream().mapToLong(Long::valueOf)</pre>
			<pre class="source-code">             .forEach(System.out::print);  //prints: 12345</pre>
			<pre class="source-code">list.stream().mapToDouble(Double::valueOf)</pre>
			<pre class="source-code">       .mapToObj(Double::toString)</pre>
			<pre class="source-code">       .map(s -&gt; s + " ")</pre>
			<pre class="source-code">       .forEach(System.out::print); </pre>
			<pre class="source-code">                                  //prints: 1.0 2.0 3.0 4.0 5.0</pre>
			<pre class="source-code">list.stream().mapToInt(Integer::valueOf)</pre>
			<pre class="source-code">    .flatMap(n -&gt; IntStream.iterate(1, I -&gt; i &lt; n, i -&gt; ++i))</pre>
			<pre class="source-code">    .forEach(System.out::print);         //prints: 1121231234</pre>
			<pre class="source-code">list.stream().map(Integer::valueOf)</pre>
			<pre class="source-code">    .flatMapToInt(n -&gt; IntStream.iterate(1, i-&gt;i&lt;n, i -&gt; ++i))</pre>
			<pre class="source-code">    .forEach(System.out::print);        //prints: 1121231234</pre>
			<pre class="source-code">list.stream().map(Integer::valueOf)</pre>
			<pre class="source-code">    .flatMapToLong(n -&gt; LongStream.iterate(1, i-&gt;i&lt;n,i -&gt; ++i))</pre>
			<pre class="source-code">    .forEach(System.out::print);        //prints: 1121231234</pre>
			<pre class="source-code">list.stream().map(Integer::valueOf)</pre>
			<pre class="source-code"> .flatMapToDouble(n -&gt; DoubleStream.iterate(1,i-&gt;i&lt;n,i -&gt; ++i))</pre>
			<pre class="source-code">    .mapToObj(Double::toString)</pre>
			<pre class="source-code">    .map(s -&gt; s +"""")</pre>
			<pre class="source-code">    .forEach(System.out::print);</pre>
			<pre class="source-code">              //prints: 1.0 1.0 2.0 1.0 2.0 3.0 1.0 2.0 3.0 4.0</pre>
			<p>In the last example, by converting the stream to <strong class="source-inline">DoubleStream</strong>, we transformed each numeric value to a <strong class="source-inline">String</strong> object and added white space, so the result can be printed with whitespace between the numbers. These examples are very simple – just conversion<a id="_idIndexMarker1578"/> with minimal processing. But in real life, each <strong class="source-inline">map()</strong> or <strong class="source-inline">flatMap()</strong> operation typically accepts a more complex function that does something more useful.</p>
			<h3>Sorting</h3>
			<p>The following two <a id="_idIndexMarker1579"/>intermediate operations sort the stream elements, as follows: </p>
			<ul>
				<li><strong class="source-inline">Stream&lt;T&gt; sorted()</strong>: Sorts stream elements in natural order (according to their <strong class="source-inline">Comparable</strong> interface implementation)</li>
				<li><strong class="source-inline">Stream&lt;T&gt; sorted(Comparator&lt;T&gt; comparator)</strong>: Sorts stream elements in order according to the provided <strong class="source-inline">Comparator&lt;T&gt;</strong> object</li>
			</ul>
			<p>Naturally, these operations cannot be finished until all the elements are emitted, so such processing creates a lot of overhead, slows down performance, and has to be used for small streams. </p>
			<p>Here is some demo code:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("2", "1", "5", "4", "3");</pre>
			<pre class="source-code">list.stream().sorted().forEach(System.out::print); </pre>
			<pre class="source-code">                                                //prints: 12345</pre>
			<pre class="source-code">list.stream().sorted(Comparator.reverseOrder())</pre>
			<pre class="source-code">             .forEach(System.out::print);       //prints: 54321</pre>
			<h3>Peeking</h3>
			<p>An<a id="_idIndexMarker1580"/> intermediate <strong class="source-inline">Stream&lt;T&gt; peek(Consumer&lt;T&gt; action)</strong> operation applies the provided <strong class="source-inline">Consumer&lt;T&gt;</strong> function to each stream element but does not change the stream values (<strong class="source-inline">Consumer&lt;T&gt;</strong> returns <strong class="source-inline">void</strong>). This operation is used for debugging. The following <a id="_idIndexMarker1581"/>code shows how it works:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("1", "2", "3", "4", "5");</pre>
			<pre class="source-code">list.stream()</pre>
			<pre class="source-code"> .peek(s -&gt; System.out.print("3".equals(s) ? 3 : 0))</pre>
			<pre class="source-code"> .forEach(System.out::print); //prints: 0102330405</pre>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor305"/>Terminal operations</h2>
			<p><strong class="bold">Terminal operations</strong> are the<a id="_idIndexMarker1582"/> most <a id="_idIndexMarker1583"/>important operations in a stream pipeline. It is possible to accomplish everything in them without using any other operations.</p>
			<p>We have already used the <strong class="source-inline">forEach(Consumer&lt;T&gt;)</strong> terminal operation to print each element. It does not return a value, thus it is used for its side effects. However, the <strong class="source-inline">Stream</strong> interface has many more powerful terminal operations that do return values.</p>
			<p>Chief among them is the <strong class="source-inline">collect()</strong> operation, which has two forms, as follows:</p>
			<ul>
				<li><strong class="source-inline">R collect(Collector&lt;T, A, R&gt; collector)</strong></li>
				<li><strong class="source-inline">R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</strong></li>
			</ul>
			<p>This allows you to compose practically any process that can be applied to a stream. The classic example is as follows:</p>
			<pre class="source-code">List&lt;String&gt; list = Stream.of("1", "2", "3", "4", "5")</pre>
			<pre class="source-code">                          .collect(ArrayList::new,</pre>
			<pre class="source-code">                                   ArrayList::add,</pre>
			<pre class="source-code">                                   ArrayList::addAll);</pre>
			<pre class="source-code">System.out.println(list);  //prints: [1, 2, 3, 4, 5]</pre>
			<p>This example is used in such a way as to be suitable for parallel processing. The first parameter of the <strong class="source-inline">collect()</strong> operation is a function that produces a value based on the stream element. The second parameter is the function that accumulates the result. The third parameter is the function that combines the accumulated results from all the threads that processed the stream.</p>
			<p>However, having only one such generic terminal operation will force programmers to write the same functions repeatedly. That is why the API authors added the <strong class="source-inline">Collectors</strong> class, which generates many specialized <strong class="source-inline">Collector</strong> objects without the need to create three functions for every <strong class="source-inline">collect()</strong> operation.</p>
			<p>In addition to that, the API authors added to the <strong class="source-inline">Stream</strong> interface various even more specialized terminal operations that are much simpler and easier to use. In this section, we will review all the terminal operations of the <strong class="source-inline">Stream</strong> interface and, in the <strong class="source-inline">Collect</strong> subsection, look at the plethora of <strong class="source-inline">Collector</strong> objects produced by the <strong class="source-inline">Collectors</strong> class. We will start with the most simple terminal operation that allows you to process each element of this stream one at a time.</p>
			<p>In our examples, we <a id="_idIndexMarker1584"/>are going to use <a id="_idIndexMarker1585"/>the following class, <strong class="source-inline">Person</strong>:</p>
			<pre class="source-code">public class Person {</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private String name;</pre>
			<pre class="source-code">    public Person(int age, String name) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.name = name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getAge() {return this.age; }</pre>
			<pre class="source-code">    public String getName() { return this.name; }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public String toString() {</pre>
			<pre class="source-code">        return "Person{" + "name='" + this.name + "'" +</pre>
			<pre class="source-code">                                       ", age=" + age + "}";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<h3>Processing each element</h3>
			<p>There are<a id="_idIndexMarker1586"/> two <a id="_idIndexMarker1587"/>terminal operations in this group, as follows:</p>
			<ul>
				<li><strong class="source-inline">void forEach(Consumer&lt;T&gt; action)</strong>: Applies the provided action for each element of this stream</li>
				<li><strong class="source-inline">void forEachOrdered(Consumer&lt;T&gt; action)</strong>: Applies the provided action for each element of this stream in the order defined by the source, regardless of whether the stream is sequential or parallel</li>
			</ul>
			<p>If the order in which you need the elements to be processed is important and has to be the order in which values are arranged at the source, use the second method, especially if you can foresee that it is possible your code is going to be executed on a computer with several CPUs. Otherwise, use the first one, as we did in all our examples.</p>
			<p>Let’s see an example of the <strong class="source-inline">forEach()</strong> operation in use for reading comma-separated values (age and name) from a file and creating <strong class="source-inline">Person</strong> objects. We have placed the following <strong class="source-inline">persons.csv</strong> file (<strong class="bold">csv</strong> stands<a id="_idIndexMarker1588"/> for <strong class="bold">comma-separated values</strong>) file in the <strong class="source-inline">resources</strong> folder:</p>
			<pre class="source-code">23 , Ji m</pre>
			<pre class="source-code">    2 5 , Bob</pre>
			<pre class="source-code">  15 , Jill</pre>
			<pre class="source-code">17 , Bi ll</pre>
			<p>We have added spaces inside and outside the values in order to take this opportunity to show you some simple but very useful tips for working with real-life data.</p>
			<p>First, we will just read the file and display its content line by line, but only those lines that contain the letter <strong class="source-inline">J</strong> (adjust the path value or set it to <strong class="source-inline">absolute</strong> if the code cannot find the <strong class="source-inline">persons.csv</strong> file):</p>
			<pre class="source-code">Path path = Paths.get("src/main/resources/persons.csv");</pre>
			<pre class="source-code">try (Stream&lt;String&gt; lines = Files.newBufferedReader(path).lines()) {</pre>
			<pre class="source-code">    lines.filter(s -&gt; s.contains("J"))</pre>
			<pre class="source-code">         .forEach(System.out::println);  </pre>
			<pre class="source-code">                                  //prints: 23 , Ji m 15 , Jill</pre>
			<pre class="source-code">} catch (IOException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>That is a typical way of using the <strong class="source-inline">forEach()</strong> operation – processing each element independently. This code also provides an example of a try-with-resources construct that closes the <strong class="source-inline">BufferedReader</strong> object automatically. </p>
			<p>The following is<a id="_idIndexMarker1589"/> how an inexperienced programmer might write code <a id="_idIndexMarker1590"/>that reads the stream elements from the <strong class="source-inline">Stream&lt;String&gt; lines</strong> object and creates a list of <strong class="source-inline">Person</strong> objects:</p>
			<pre class="source-code">List&lt;Person&gt; persons = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">lines.filter(s -&gt; s.contains("J")).forEach(s -&gt; {</pre>
			<pre class="source-code">    String[] arr = s.split(",");</pre>
			<pre class="source-code">    int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));</pre>
			<pre class="source-code">    persons.add(new Person(age, StringUtils.remove(arr[1], </pre>
			<pre class="source-code">                                                        ' ')));</pre>
			<pre class="source-code">});</pre>
			<p>You can see how the <strong class="source-inline">split()</strong> method is used to break each line by a comma that separates the values and how the <strong class="source-inline">org.apache.commons.lang3.StringUtils.remove()</strong> method removes spaces from each value. Although this code works well in small examples on a single-core computer, it might create unexpected results with a long stream and parallel processing.</p>
			<p>This is the reason that lambda expressions require all variables to be final or effectively final – so that the same function can be executed in a different context.</p>
			<p>The following is a correct implementation of the preceding code:</p>
			<pre class="source-code">List&lt;Person&gt; persons = lines.filter(s -&gt; s.contains("J"))</pre>
			<pre class="source-code">   .map(s -&gt; s.split(","))</pre>
			<pre class="source-code">   .map(arr -&gt; {</pre>
			<pre class="source-code">       int age = Integer.valueOf(StringUtils.remove(arr[0], </pre>
			<pre class="source-code">                                                         ' '));</pre>
			<pre class="source-code">       return new Person(age, StringUtils.remove(arr[1], ' '));</pre>
			<pre class="source-code">   }).collect(Collectors.toList());</pre>
			<p>To improve<a id="_idIndexMarker1591"/> readability, we can create a method that does the <a id="_idIndexMarker1592"/>job of mapping:</p>
			<pre class="source-code">private Person createPerson(String[] arr){</pre>
			<pre class="source-code">    int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));</pre>
			<pre class="source-code">    return new Person(age, StringUtils.remove(arr[1], ' '));</pre>
			<pre class="source-code">}</pre>
			<p>Now, we can use it as follows:</p>
			<pre class="source-code">List&lt;Person&gt; persons = lines.filter(s -&gt; s.contains("J"))</pre>
			<pre class="source-code">                            .map(s -&gt; s.split(","))</pre>
			<pre class="source-code">                            .map(this::createPerson)</pre>
			<pre class="source-code">                            .collect(Collectors.toList());</pre>
			<p>As you can see, we have used the <strong class="source-inline">collect()</strong> operator and the <strong class="source-inline">Collector</strong> function created by the <strong class="source-inline">Collectors.toList()</strong> method. We will see more functions created by the <strong class="source-inline">Collectors</strong> class <a id="_idIndexMarker1593"/>in the <em class="italic">Collect</em> subsection.</p>
			<h3>Counting all elements</h3>
			<p>The <strong class="source-inline">long count()</strong> terminal <a id="_idIndexMarker1594"/>operation of the <strong class="source-inline">Stream</strong> interface <a id="_idIndexMarker1595"/>looks straightforward and benign. It returns the number of elements in this stream. Those who are used to working with collections and arrays may use the <strong class="source-inline">count()</strong> operation without thinking twice. The following code snippet demonstrates a caveat:</p>
			<pre class="source-code">long count = Stream.of("1", "2", "3", "4", "5")</pre>
			<pre class="source-code">                   .peek(System.out::print)</pre>
			<pre class="source-code">                   .count();</pre>
			<pre class="source-code">System.out.print(count);          //prints: 5               </pre>
			<p>If we run the preceding code, the result will look as follows:</p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/B18388_Figure_14.1.jpg" alt=""/>
				</div>
			</div>
			<p>As you see, the code that implements the <strong class="source-inline">count()</strong> method was able to determine the stream size without executing all the pipelines. The <strong class="source-inline">peek()</strong> operation did not print anything, which proves that elements were not emitted. So, if you expected to see the values of the stream printed, you might be puzzled and expect that the code has some kind of defect. </p>
			<p>Another caveat is that it is not always possible to determine the stream size at the source. Besides, the stream may be infinite. So, you have to use <strong class="source-inline">count()</strong> with care.</p>
			<p>Another possible way to determine the stream size is by using the <strong class="source-inline">collect()</strong> operation:</p>
			<pre class="source-code">long count = Stream.of("1", "2", "3", "4", "5")</pre>
			<pre class="source-code">                   .peek(System.out::print)     //prints: 12345</pre>
			<pre class="source-code">                   .collect(Collectors.counting());</pre>
			<pre class="source-code">System.out.println(count);                         //prints: 5 </pre>
			<p>The following screenshot shows what happens after the preceding code example has been run:</p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/B18388_Figure_14.2.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, the <strong class="source-inline">collect()</strong> operation does not calculate the stream size at the source. That is because the <strong class="source-inline">collect()</strong> operation is not as specialized as the <strong class="source-inline">count()</strong> operation. It just applies the passed-in collector to the stream. The collector just counts<a id="_idIndexMarker1596"/> the elements provided to it<a id="_idIndexMarker1597"/> by the <strong class="source-inline">collect()</strong> operation.</p>
			<h3>Match all, any, or none</h3>
			<p>There are <a id="_idIndexMarker1598"/>three <a id="_idIndexMarker1599"/>seemingly <a id="_idIndexMarker1600"/>very similar terminal<a id="_idIndexMarker1601"/> operations <a id="_idIndexMarker1602"/>that<a id="_idIndexMarker1603"/> allow us to assess whether all, any, or none of the stream elements have a certain value, as follows:</p>
			<ul>
				<li><strong class="source-inline">boolean allMatch(Predicate&lt;T&gt; predicate)</strong>: Returns <strong class="source-inline">true</strong> when each of the stream elements returns <strong class="source-inline">true</strong> when used as a parameter of the provided <strong class="source-inline">Predicate&lt;T&gt;</strong> function</li>
				<li><strong class="source-inline">boolean anyMatch(Predicate&lt;T&gt; predicate)</strong>: Returns <strong class="source-inline">true</strong> when one of the stream elements returns <strong class="source-inline">true</strong> when used as a parameter of the provided <strong class="source-inline">Predicate&lt;T&gt;</strong> function</li>
				<li><strong class="source-inline">boolean noneMatch(Predicate&lt;T&gt; predicate)</strong>: Returns <strong class="source-inline">true</strong> when none of the stream elements return <strong class="source-inline">true</strong> when used as a parameter of the provided <strong class="source-inline">Predicate&lt;T&gt;</strong> function</li>
			</ul>
			<p>The following are examples of their usage:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("1", "2", "3", "4", "5");</pre>
			<pre class="source-code">boolean found = list.stream()</pre>
			<pre class="source-code">                    .peek(System.out::print)      //prints: 123</pre>
			<pre class="source-code">                    .anyMatch(e -&gt; "3".equals(e));</pre>
			<pre class="source-code">System.out.println(found);                       //prints: true</pre>
			<pre class="source-code">boolean noneMatches = list.stream()</pre>
			<pre class="source-code">                         .peek(System.out::print) //prints: 123</pre>
			<pre class="source-code">                         .noneMatch(e -&gt; "3".equals(e));</pre>
			<pre class="source-code">System.out.println(noneMatches);                //prints: false</pre>
			<pre class="source-code">boolean allMatch = list.stream()</pre>
			<pre class="source-code">                       .peek(System.out::print)    //prints: 1</pre>
			<pre class="source-code">                       .allMatch(e -&gt; "3".equals(e));</pre>
			<pre class="source-code">System.out.println(allMatch);                   //prints: false</pre>
			<p>Please note <a id="_idIndexMarker1604"/>that<a id="_idIndexMarker1605"/> all these <a id="_idIndexMarker1606"/>operations are optimized so as not to process all the stream elements if the result can be determined early.</p>
			<h3>Find any or first</h3>
			<p>The following <a id="_idIndexMarker1607"/>terminal <a id="_idIndexMarker1608"/>operations <a id="_idIndexMarker1609"/>allow <a id="_idIndexMarker1610"/>you to find any element or the first element of the stream correspondingly, as follows:</p>
			<ul>
				<li><strong class="source-inline">Optional&lt;T&gt; findAny()</strong>: Returns <strong class="source-inline">Optional</strong> with the value of any element of the stream, or an empty <strong class="source-inline">Optional</strong> if the stream is empty</li>
				<li><strong class="source-inline">Optional&lt;T&gt; findFirst()</strong>: Returns an <strong class="source-inline">Optional</strong> with the value of the first element of the stream, or an empty <strong class="source-inline">Optional</strong> if the stream is empty</li>
			</ul>
			<p>The<a id="_idIndexMarker1611"/> following <a id="_idIndexMarker1612"/>examples<a id="_idIndexMarker1613"/> illustrate<a id="_idIndexMarker1614"/> these operations:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("1", "2", "3", "4", "5");</pre>
			<pre class="source-code">Optional&lt;String&gt; result = list.stream().findAny();</pre>
			<pre class="source-code">System.out.println(result.isPresent());    //prints: true</pre>
			<pre class="source-code">System.out.println(result.get());          //prints: 1</pre>
			<pre class="source-code">result = list.stream()</pre>
			<pre class="source-code">             .filter(e -&gt; "42".equals(e))</pre>
			<pre class="source-code">             .findAny();</pre>
			<pre class="source-code">System.out.println(result.isPresent());   //prints: false</pre>
			<pre class="source-code">//System.out.println(result.get());    //NoSuchElementException</pre>
			<pre class="source-code">result = list.stream().findFirst();</pre>
			<pre class="source-code">System.out.println(result.isPresent());   //prints: true</pre>
			<pre class="source-code">System.out.println(result.get());         //prints: 1</pre>
			<p>In the first and third of the preceding examples, the <strong class="source-inline">findAny()</strong> and <strong class="source-inline">findFirst()</strong> operations produce the same result – they both find the first element of the stream. But in parallel processing, the result may be different.</p>
			<p>When the stream is broken into several parts for parallel processing, the <strong class="source-inline">findFirst()</strong> operation always returns the first element of the stream, while the <strong class="source-inline">findAny()</strong> operation returns the first element only in one of the processing threads.</p>
			<p>Now, let’s talk about <strong class="source-inline">class java.util.Optional</strong> in more detail.</p>
			<h3>Optional class</h3>
			<p>The object <a id="_idIndexMarker1615"/>of <strong class="source-inline">java.util.Optional</strong> is used to avoid<a id="_idIndexMarker1616"/> returning <strong class="source-inline">null</strong> (as it may cause <strong class="source-inline">NullPointerException</strong>). Instead, an <strong class="source-inline">Optional</strong> object provides methods that allow you to check for the presence of a value and substitute it with a predefined value if the return value is <strong class="source-inline">null</strong>, as shown in the following example:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("1", "2", "3", "4", "5");</pre>
			<pre class="source-code">String result = list.stream()</pre>
			<pre class="source-code">                    .filter(e -&gt; "42".equals(e))</pre>
			<pre class="source-code">                    .findAny()</pre>
			<pre class="source-code">                    .or(() -&gt; Optional.of("Not found"))</pre>
			<pre class="source-code">                    .get();</pre>
			<pre class="source-code">System.out.println(result);              //prints: Not found</pre>
			<pre class="source-code">result = list.stream()</pre>
			<pre class="source-code">             .filter(e -&gt; "42".equals(e))</pre>
			<pre class="source-code">             .findAny()</pre>
			<pre class="source-code">             .orElse("Not found");</pre>
			<pre class="source-code">System.out.println(result);              //prints: Not found</pre>
			<pre class="source-code">Supplier&lt;String&gt; trySomethingElse = () -&gt; {</pre>
			<pre class="source-code">    //Code that tries something else</pre>
			<pre class="source-code">    return "43";</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">result = list.stream()</pre>
			<pre class="source-code">             .filter(e -&gt; "42".equals(e))</pre>
			<pre class="source-code">             .findAny()</pre>
			<pre class="source-code">             .orElseGet(trySomethingElse);</pre>
			<pre class="source-code">System.out.println(result);              //prints: 43</pre>
			<pre class="source-code">list.stream()</pre>
			<pre class="source-code">    .filter(e -&gt; "42".equals(e))</pre>
			<pre class="source-code">    .findAny()</pre>
			<pre class="source-code">    .ifPresentOrElse(System.out::println,</pre>
			<pre class="source-code">       () -&gt; System.out.println("Not found")); </pre>
			<pre class="source-code">                                            //prints: Not found</pre>
			<p>As you can see, if the <strong class="source-inline">Optional</strong> object is empty, then the following applies, as follows:</p>
			<ul>
				<li>The <strong class="source-inline">or()</strong> method of the <strong class="source-inline">Optional</strong> class allows you to return an alternative <strong class="source-inline">Optional</strong> object.</li>
				<li>The <strong class="source-inline">orElse()</strong> method allows you to return an alternative value.</li>
				<li>The <strong class="source-inline">orElseGet()</strong> method allows you to provide the <strong class="source-inline">Supplier</strong> function, which returns an alternative value.</li>
				<li>The <strong class="source-inline">ifPresentOrElse()</strong> method allows you to provide two functions – one that <a id="_idIndexMarker1617"/>consumes <a id="_idIndexMarker1618"/>the value from the <strong class="source-inline">Optional</strong> object, and another one that does something else if the <strong class="source-inline">Optional</strong> object is empty.</li>
			</ul>
			<h3>Minimum and maximum</h3>
			<p>The following terminal operations <a id="_idIndexMarker1619"/>return the minimum or <a id="_idIndexMarker1620"/>maximum value of stream elements, if present, as follows:</p>
			<ul>
				<li><strong class="source-inline">Optional&lt;T&gt; min(Comparator&lt;T&gt; comparator)</strong>: Returns the minimum element of this stream using the provided <strong class="source-inline">Comparator</strong> object</li>
				<li><strong class="source-inline">Optional&lt;T&gt; max(Comparator&lt;T&gt; comparator)</strong>: Returns the maximum element of this stream using the provided <strong class="source-inline">Comparator</strong> object</li>
			</ul>
			<p>The following code demonstrates this:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("a", "b", "c", "c", "a");</pre>
			<pre class="source-code">String min = list.stream()</pre>
			<pre class="source-code">                 .min(Comparator.naturalOrder())</pre>
			<pre class="source-code">                 .orElse("0");</pre>
			<pre class="source-code">System.out.println(min);     //prints: a</pre>
			<pre class="source-code">String max = list.stream()</pre>
			<pre class="source-code"> .max(Comparator.naturalOrder())</pre>
			<pre class="source-code">                 .orElse("0");</pre>
			<pre class="source-code">System.out.println(max);     //prints: c</pre>
			<p>As you can <a id="_idIndexMarker1621"/>see, in <a id="_idIndexMarker1622"/>the case of non-numerical values, the minimum element is the one that is first when ordered from left to right, according to the provided comparator. The maximum, accordingly, is the last element. In the case of numeric values, the minimum and maximum are just that – the smallest and biggest numbers among the stream elements:</p>
			<pre class="source-code">int mn = Stream.of(42, 77, 33)</pre>
			<pre class="source-code">               .min(Comparator.naturalOrder())</pre>
			<pre class="source-code">               .orElse(0);</pre>
			<pre class="source-code">System.out.println(mn);    //prints: 33</pre>
			<pre class="source-code">int mx = Stream.of(42, 77, 33)</pre>
			<pre class="source-code">               .max(Comparator.naturalOrder())</pre>
			<pre class="source-code">               .orElse(0);</pre>
			<pre class="source-code">System.out.println(mx);    //prints: 77</pre>
			<p>Let’s look at another example, using the <strong class="source-inline">Person</strong> class. The task is to find the oldest person in the following list:</p>
			<pre class="source-code">List&lt;Person&gt; persons = List.of(new Person(23, "Bob"),</pre>
			<pre class="source-code"> new Person(33, "Jim"),</pre>
			<pre class="source-code"> new Person(28, "Jill"),</pre>
			<pre class="source-code"> new Person(27, "Bill"));</pre>
			<p>In order to do that, we can create the following <strong class="source-inline">Comparator&lt;Person&gt;</strong> that compares <strong class="source-inline">Person</strong> objects only by age:</p>
			<pre class="source-code">Comparator&lt;Person&gt; perComp = (p1, p2) -&gt; p1.getAge() - p2.getAge();</pre>
			<p>Then, using <a id="_idIndexMarker1623"/>this<a id="_idIndexMarker1624"/> comparator, we can find the oldest person:</p>
			<pre class="source-code">Person theOldest = persons.stream()</pre>
			<pre class="source-code">                          .max(perComp)</pre>
			<pre class="source-code">                          .orElse(null);</pre>
			<pre class="source-code">System.out.println(theOldest);</pre>
			<pre class="source-code">                          //prints: Person{name='Jim', age=33}</pre>
			<h3>To array</h3>
			<p>The following two<a id="_idIndexMarker1625"/> terminal operations generate an array<a id="_idIndexMarker1626"/> that contains stream elements, as follows:</p>
			<ul>
				<li><strong class="source-inline">Object[] toArray()</strong>: Creates an array of objects; each object is an element of the stream</li>
				<li><strong class="source-inline">A[] toArray(IntFunction&lt;A[]&gt; generator)</strong>: Creates an array of stream elements using the provided function</li>
			</ul>
			<p>Let’s look at some examples:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("a", "b", "c");</pre>
			<pre class="source-code">Object[] obj = list.stream().toArray();</pre>
			<pre class="source-code">Arrays.stream(obj).forEach(System.out::print);    //prints: abc</pre>
			<pre class="source-code">String[] str = list.stream().toArray(String[]::new);</pre>
			<pre class="source-code">Arrays.stream(str).forEach(System.out::print);    //prints: abc</pre>
			<p>The first example is straightforward. It converts elements to an array of the same type. As for the second example, the representation of <strong class="source-inline">IntFunction</strong> as <strong class="source-inline">String[]::new</strong> is probably not obvious, so let’s walk through it. <strong class="source-inline">String[]::new</strong> is a method reference that represents the <strong class="source-inline">i -&gt; new String[i]</strong> lambda expression because the <strong class="source-inline">toArray()</strong> operation receives from the stream not<a id="_idIndexMarker1627"/> the<a id="_idIndexMarker1628"/> elements but their count:</p>
			<pre class="source-code">String[] str = list.stream().toArray(i -&gt; new String[i]);</pre>
			<p>We can prove it by printing an <strong class="source-inline">i</strong> value:</p>
			<pre class="source-code">String[] str = list.stream()</pre>
			<pre class="source-code">                   .toArray(i -&gt; {</pre>
			<pre class="source-code">                          System.out.println(i);    //prints: 3</pre>
			<pre class="source-code">                          return  new String[i];</pre>
			<pre class="source-code">                   });</pre>
			<p>The <strong class="source-inline">i -&gt; new String[i]</strong> expression is <strong class="source-inline">IntFunction&lt;String[]&gt;</strong> that, according to its documentation, accepts an <strong class="source-inline">int</strong> parameter and returns the result of the specified type. It can be defined using an anonymous class, as follows:</p>
			<pre class="source-code">IntFunction&lt;String[]&gt; intFunction = new IntFunction&lt;String[]&gt;() { </pre>
			<pre class="source-code">         @Override </pre>
			<pre class="source-code">         public String[] apply(int i) { </pre>
			<pre class="source-code">              return new String[i]; </pre>
			<pre class="source-code">         } </pre>
			<pre class="source-code">}; </pre>
			<p>The <strong class="source-inline">java.util.Collection</strong> interface has a very similar method that converts a collection to an array:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("a", "b", "c");</pre>
			<pre class="source-code">String[] str = list.toArray(new String[lits.size()]);</pre>
			<pre class="source-code">Arrays.stream(str).forEach(System.out::print);    //prints: abc</pre>
			<p>The only<a id="_idIndexMarker1629"/> difference is that <strong class="source-inline">toArray()</strong> of the <strong class="source-inline">Stream</strong> interface <a id="_idIndexMarker1630"/>accepts a function, while the <strong class="source-inline">toArray()</strong> of the <strong class="source-inline">Collection</strong> interface takes an array.</p>
			<h3>Reduce</h3>
			<p>This terminal operation is <a id="_idIndexMarker1631"/>called <strong class="source-inline">reduce</strong> because it processes all the <a id="_idIndexMarker1632"/>stream elements and produces one value, thus reducing all the stream elements to one value. However, this is not the only operation that does it. The <strong class="source-inline">collect</strong> operation reduces all the values of the stream element to one result as well. In a way, all terminal operations are reductive. They produce one value after processing many elements.</p>
			<p>So, you can view <strong class="source-inline">reduce</strong> and <strong class="source-inline">collect</strong> as synonyms that help to add structure and classification to many operations available in the <strong class="source-inline">Stream</strong> interface. Also, operations in the <strong class="source-inline">reduce</strong> group can be viewed as specialized versions of the <strong class="source-inline">collect</strong> operation because <strong class="source-inline">collect()</strong> can be tailored to provide the same functionality as the <strong class="source-inline">reduce()</strong> operation.</p>
			<p>With all that said, let’s look at a group of <strong class="source-inline">reduce</strong> operations, as follows:</p>
			<ul>
				<li><strong class="source-inline">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</strong>: Reduces the elements of the stream using the provided associative function that aggregates the elements; returns an <strong class="source-inline">Optional</strong> with the reduced value if available</li>
				<li><strong class="source-inline">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</strong>: Provides the same functionality as the previous <strong class="source-inline">reduce()</strong> version but with the identity parameter used as the initial value for an accumulator or a default value if a stream is empty</li>
				<li><strong class="source-inline">U reduce(U identity, BiFunction&lt;U,T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</strong>: Provides the same functionality as the previous <strong class="source-inline">reduce()</strong> versions but, in addition, uses the <strong class="source-inline">combiner</strong> function to aggregate the results when this operation is applied to a parallel stream; if the stream is not parallel, the <strong class="source-inline">combiner</strong> function is not used</li>
			</ul>
			<p>To demonstrate the <strong class="source-inline">reduce()</strong> operation, we are going to use the same <strong class="source-inline">Person</strong> class we have used<a id="_idIndexMarker1633"/> before and the same list of <strong class="source-inline">Person</strong> objects <a id="_idIndexMarker1634"/>as the source for our stream examples:</p>
			<pre class="source-code">List&lt;Person&gt; persons = List.of(new Person(23, "Bob"),</pre>
			<pre class="source-code">                               new Person(33, "Jim"),</pre>
			<pre class="source-code">                               new Person(28, "Jill"),</pre>
			<pre class="source-code">                               new Person(27, "Bill"));</pre>
			<p>Let’s find the oldest person in this list using the <strong class="source-inline">reduce()</strong> operation:</p>
			<pre class="source-code">Person theOldest = list.stream()</pre>
			<pre class="source-code">       .reduce((p1, p2) -&gt; p1.getAge() &gt; p2.getAge() ? p1 : p2)</pre>
			<pre class="source-code">          .orElse(null);</pre>
			<pre class="source-code">System.out.println(theOldest); </pre>
			<pre class="source-code">                           //prints: Person{name='Jim', age=33}</pre>
			<p>The implementation is somewhat surprising, isn’t it? The <strong class="source-inline">reduce()</strong> operation takes an accumulator, but it seems it did not accumulate anything. Instead, it compares all stream elements. Well, the accumulator saves the result of the comparison and provides it as the first parameter for the next comparison (with the next element). You can say that the accumulator, in this case, accumulates the results of all previous comparisons. </p>
			<p>Let’s now accumulate something explicitly. Let’s assemble all the names from a list of persons in one comma-separated list:</p>
			<pre class="source-code">String allNames = list.stream()</pre>
			<pre class="source-code">                      .map(p -&gt; p.getName())</pre>
			<pre class="source-code">                      .reduce((n1, n2) -&gt; n1 + ", " + n2)</pre>
			<pre class="source-code">                      .orElse(null);</pre>
			<pre class="source-code">System.out.println(allNames);    //prints: Bob, Jim, Jill, Bill</pre>
			<p>The notion of accumulation, in this case, makes a bit more sense, doesn’t it?</p>
			<p>Now, let’s <a id="_idIndexMarker1635"/>use <a id="_idIndexMarker1636"/>the <strong class="source-inline">identity</strong> value to provide some initial value:</p>
			<pre class="source-code">String all = list.stream()</pre>
			<pre class="source-code">            .map(p -&gt; p.getName())</pre>
			<pre class="source-code">            .reduce("All names: ", (n1, n2) -&gt; n1 + ", " + n2);</pre>
			<pre class="source-code">System.out.println(all);</pre>
			<pre class="source-code">                    //prints: All names: , Bob, Jim, Jill, Bill</pre>
			<p>Note that this version of the <strong class="source-inline">reduce()</strong> operation returns <strong class="source-inline">value</strong>, not the <strong class="source-inline">Optional</strong> object. That is because, by providing the initial value, we guarantee that at least this value will be present in the result if the stream turns out to be empty. But the resulting string does not look as pretty as we hoped. Apparently, the provided initial value is treated as any other stream element, and a comma is added after it by the accumulator we have created. To make the result look pretty again, we can use the first version of the <strong class="source-inline">reduce()</strong> operation again and add the initial value this way:</p>
			<pre class="source-code">String all = "All names: " + list.stream()</pre>
			<pre class="source-code">                            .map(p -&gt; p.getName())</pre>
			<pre class="source-code">                            .reduce((n1, n2) -&gt; n1 + ", " + n2)</pre>
			<pre class="source-code">                            .orElse(null);</pre>
			<pre class="source-code">System.out.println(all); </pre>
			<pre class="source-code">                      //prints: All names: Bob, Jim, Jill, Bill</pre>
			<p>Alternatively, we can use a space as a separator instead of a comma:</p>
			<pre class="source-code">String all = list.stream()</pre>
			<pre class="source-code">             .map(p -&gt; p.getName())</pre>
			<pre class="source-code">             .reduce("All names:", (n1, n2) -&gt; n1 + " " + n2);</pre>
			<pre class="source-code">System.out.println(all);    </pre>
			<pre class="source-code">                         //prints: All names: Bob Jim Jill Bill</pre>
			<p>Now, the result looks better. While demonstrating the <strong class="source-inline">collect()</strong> operation in the next subsection, we will show a better way to create a comma-separated list of values with a prefix.</p>
			<p>Meanwhile, let’s<a id="_idIndexMarker1637"/> continue <a id="_idIndexMarker1638"/>to review the <strong class="source-inline">reduce()</strong> operation and look at its third form – the one with three parameters: <strong class="source-inline">identity</strong>, <strong class="source-inline">accumulator</strong>, and <strong class="source-inline">combiner</strong>. Adding combiner to the <strong class="source-inline">reduce()</strong> operation does not change the result:</p>
			<pre class="source-code">String all = list.stream()</pre>
			<pre class="source-code">               .map(p -&gt; p.getName())</pre>
			<pre class="source-code">               .reduce("All names:", (n1, n2) -&gt; n1 + " " + n2,</pre>
			<pre class="source-code">                                   (n1, n2) -&gt; n1 + " " + n2 );</pre>
			<pre class="source-code">System.out.println(all);   </pre>
			<pre class="source-code">                         //prints: All names: Bob Jim Jill Bill</pre>
			<pre class="source-code"> </pre>
			<p>This is because the stream is not parallel and the combiner is used only with a parallel stream. If we make the stream parallel, the result changes:</p>
			<pre class="source-code">String all = list.parallelStream()</pre>
			<pre class="source-code">                .map(p -&gt; p.getName())</pre>
			<pre class="source-code">                .reduce("All names:", (n1, n2) -&gt; n1 + " " + </pre>
			<pre class="source-code">n2, (n1, n2) -&gt; n1 + " " + n2 );</pre>
			<pre class="source-code">System.out.println(all); </pre>
			<pre class="source-code">                        //prints: All names: Bob All names: Jim </pre>
			<pre class="source-code">                              //All names: Jill All names: Bill</pre>
			<p>Apparently, for a parallel stream, the sequence of elements is broken into subsequences, each processed independently, and their results aggregated by the combiner. While doing that, the combiner adds the initial value (identity) to each of the results. Even if we remove the combiner, the result of the parallel stream processing remains the same because a default combiner behavior is provided:</p>
			<pre class="source-code">String all = list.parallelStream()</pre>
			<pre class="source-code">              .map(p -&gt; p.getName())</pre>
			<pre class="source-code">              .reduce("All names:", (n1, n2) -&gt; n1 + " " + n2);</pre>
			<pre class="source-code">System.out.println(all); </pre>
			<pre class="source-code">                        //prints: All names: Bob All names: Jim</pre>
			<pre class="source-code">                              //All names: Jill All names: Bill</pre>
			<p>In the <a id="_idIndexMarker1639"/>previous <a id="_idIndexMarker1640"/>two forms of the <strong class="source-inline">reduce()</strong> operations, the identity value was used by the accumulator. In the third form, the <strong class="source-inline">identity</strong> value is used by the combiner (note that the <strong class="source-inline">U</strong> type is the combiner type). To get rid of the repetitive <strong class="source-inline">identity</strong> value in the result, we have decided to remove it (and the trailing space) from the second parameter in the combiner:</p>
			<pre class="source-code">String all = list.parallelStream().map(p-&gt;p.getName())</pre>
			<pre class="source-code">               .reduce("All names:", (n1, n2) -&gt; n1 + " " + n2,</pre>
			<pre class="source-code"> (n1, n2) -&gt; n1 + " " + StringUtils.remove(n2, "All names: "));</pre>
			<pre class="source-code">System.out.println(all); //prints: All names: Bob Jim Jill Bill </pre>
			<p>The result is as expected.</p>
			<p>In our string-based examples so far, the identity has not just been an initial value. It also served as an identifier (a label) in the resulting string. However, when the elements of the stream are numeric, the <a id="_idIndexMarker1641"/>identity looks more like just an initial value. Let’s look at the following <a id="_idIndexMarker1642"/>example:</p>
			<pre class="source-code">List&lt;Integer&gt; ints = List.of(1, 2, 3);</pre>
			<pre class="source-code">int sum = ints.stream()</pre>
			<pre class="source-code">              .reduce((i1, i2) -&gt; i1 + i2)</pre>
			<pre class="source-code">              .orElse(0);</pre>
			<pre class="source-code">System.out.println(sum);                          //prints: 6</pre>
			<pre class="source-code">sum = ints.stream()</pre>
			<pre class="source-code">          .reduce(Integer::sum)</pre>
			<pre class="source-code">          .orElse(0);</pre>
			<pre class="source-code">System.out.println(sum);                          //prints: 6</pre>
			<pre class="source-code">sum = ints.stream()</pre>
			<pre class="source-code">          .reduce(10, Integer::sum);</pre>
			<pre class="source-code">System.out.println(sum);                         //prints: 16</pre>
			<pre class="source-code">sum = ints.stream()</pre>
			<pre class="source-code">          .reduce(10, Integer::sum, Integer::sum);</pre>
			<pre class="source-code">System.out.println(sum);                         //prints: 16</pre>
			<p>The first two of the pipelines are exactly the same, except that the second pipeline uses a method reference. The third and fourth pipelines have the same functionality too. They both use an initial value of <strong class="source-inline">10</strong>. Now, the first parameter makes more sense as the initial value than the identity, doesn’t it? In the fourth pipeline, we added a combiner, but it is not used because the stream is not parallel. Let’s make it parallel and see what happens:</p>
			<pre class="source-code">List&lt;Integer&gt; ints = List.of(1, 2, 3);</pre>
			<pre class="source-code">int sum = ints.<strong class="bold">parallelStream</strong>()</pre>
			<pre class="source-code">              .reduce(10, Integer::sum, Integer::sum);</pre>
			<pre class="source-code">System.out.println(sum);                        //prints: 36</pre>
			<p>The result is <strong class="source-inline">36</strong> because the initial value of <strong class="source-inline">10</strong> was added three times, with each partial result. Apparently, the stream was broken into three subsequences. However, it is not always the case, as the number of subsequences changes as the stream grows and the number of<a id="_idIndexMarker1643"/> CPUs<a id="_idIndexMarker1644"/> on the computer increases. This is why you cannot rely on a certain fixed number of subsequences, and it is better to not use a non-zero initial value with parallel streams:</p>
			<pre class="source-code">List&lt;Integer&gt; ints = List.of(1, 2, 3);</pre>
			<pre class="source-code">int sum = ints.<strong class="bold">parallelStream</strong>()</pre>
			<pre class="source-code">              .reduce(0, Integer::sum, Integer::sum);</pre>
			<pre class="source-code">System.out.println(sum);                            //prints: 6</pre>
			<pre class="source-code">sum = 10 + ints.<strong class="bold">parallelStream</strong>()</pre>
			<pre class="source-code">               .reduce(0, Integer::sum, Integer::sum);</pre>
			<pre class="source-code">System.out.println(sum);                           //prints: 16</pre>
			<pre class="source-code"> </pre>
			<p>As you can see, we have set the identity to <strong class="source-inline">0</strong>, so every subsequence will get it, but the total is not affected when the result from all the processing threads is assembled by the combinator.</p>
			<h3>Collect</h3>
			<p>Some of the <a id="_idIndexMarker1645"/>usages of the <strong class="source-inline">collect()</strong> operation are <a id="_idIndexMarker1646"/>very simple and can be easily mastered by any beginner, while other cases can be complex and not easy to understand, even for a seasoned programmer. Together with the operations discussed already, the most popular cases of <strong class="source-inline">collect()</strong> usage we present in this section are more than enough for all the needs a beginner may have and will cover most of the needs of a more experienced professional. Together with the operations of numeric streams (see the <em class="italic">Numeric stream interfaces</em> section), they cover all the needs a mainstream programmer will ever have.</p>
			<p>As we have mentioned already, the <strong class="source-inline">collect()</strong> operation is very flexible and allows us to customize stream processing. It has two forms, as follows:</p>
			<ul>
				<li><strong class="source-inline">R collect(Collector&lt;T, A, R&gt; collector)</strong>: Processes the stream elements of type <strong class="source-inline">T</strong> using the provided <strong class="source-inline">Collector</strong> and produces the result of type <strong class="source-inline">R</strong> via an intermediate accumulation of type <strong class="source-inline">A</strong></li>
				<li><strong class="source-inline">R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</strong>: Processes the stream elements of type <strong class="source-inline">T</strong> using the provided functions:<ul><li><strong class="source-inline">Supplier&lt;R&gt; supplier</strong>: Creates a new result container</li><li><strong class="source-inline">BiConsumer&lt;R, T&gt; accumulator</strong>: A stateless function that adds an element to the result container</li><li><strong class="source-inline">BiConsumer&lt;R, R&gt; combiner</strong>: A stateless function that merges two partial result containers – it adds the elements from the second result container to the first result container</li></ul></li>
			</ul>
			<p>Let’s look at the second form of the <strong class="source-inline">collect()</strong> operation first. It is very similar to the <strong class="source-inline">reduce()</strong> operation with the three parameters we have just demonstrated: <strong class="source-inline">supplier</strong>, <strong class="source-inline">accumulator</strong>, and <strong class="source-inline">combiner</strong>. The biggest difference is that the first parameter in the <strong class="source-inline">collect()</strong> operation is not an identity or the initial value but instead the container, an object, that is going to be passed between functions and which maintains the state of the processing.</p>
			<p>Let’s demonstrate how it works by selecting the oldest person from the list of <strong class="source-inline">Person</strong> objects. For the following example, we are going to use the familiar <strong class="source-inline">Person</strong> class as the container but add to it a constructor without parameters with two setters:</p>
			<pre class="source-code">public Person(){}</pre>
			<pre class="source-code">public void setAge(int age) { this.age = age;}</pre>
			<pre class="source-code">public void setName(String name) { this.name = name; }</pre>
			<p>Adding a constructor without parameters and setters is necessary because the <strong class="source-inline">Person</strong> object as a container should be creatable at any moment without any parameters and should be able to receive and keep the partial results: the <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong> of the person who is the oldest, so far. The <strong class="source-inline">collect()</strong> operation will use this container while processing each element and, after the last element is processed, contain the name and age of the oldest person.</p>
			<p>We will use <a id="_idIndexMarker1647"/>again<a id="_idIndexMarker1648"/> the same list of persons:</p>
			<pre class="source-code">List&lt;Person&gt; list = List.of(new Person(23, "Bob"),</pre>
			<pre class="source-code">                            new Person(33, "Jim"),</pre>
			<pre class="source-code">                            new Person(28, "Jill"),</pre>
			<pre class="source-code">                            new Person(27, "Bill"));</pre>
			<p>Here is the <strong class="source-inline">collect()</strong> operation that finds the oldest person in the list:</p>
			<pre class="source-code">BiConsumer&lt;Person, Person&gt; accumulator = (p1, p2) -&gt; {</pre>
			<pre class="source-code">    if(p1.getAge() &lt; p2.getAge()){</pre>
			<pre class="source-code">        p1.setAge(p2.getAge());</pre>
			<pre class="source-code">        p1.setName(p2.getName());</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">BiConsumer&lt;Person, Person&gt; combiner = (p1, p2) -&gt; {</pre>
			<pre class="source-code">    System.out.println("Combiner is called!");</pre>
			<pre class="source-code">    if(p1.getAge() &lt; p2.getAge()){</pre>
			<pre class="source-code">        p1.setAge(p2.getAge());</pre>
			<pre class="source-code">        p1.setName(p2.getName());</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">Person theOldest = list.stream()</pre>
			<pre class="source-code">                  .collect(Person::new, accumulator, combiner);</pre>
			<pre class="source-code">System.out.println(theOldest);</pre>
			<pre class="source-code">                           //prints: Person{name='Jim', age=33}</pre>
			<p>We tried to inline the functions in the operation call, but it looked a bit difficult to read, so we decided to create functions first and then use them in the <strong class="source-inline">collect()</strong> operation. The container, a <strong class="source-inline">Person</strong> object, is created only once before the first element is processed. In this sense, it is similar to the initial value of the <strong class="source-inline">reduce()</strong> operation. Then, it is passed to the accumulator, which compares it to the first element. The <strong class="source-inline">age</strong> field in the container was initialized to the default value of zero, and thus<a id="_idIndexMarker1649"/> the <strong class="source-inline">age</strong> and <strong class="source-inline">name</strong> of the first element were<a id="_idIndexMarker1650"/> set in the container as the parameters of the oldest person, so far. When the second stream element (the <strong class="source-inline">Person</strong> object) is emitted, its <strong class="source-inline">age</strong> value is compared to the <strong class="source-inline">age</strong> value currently stored in the container, and so on, until all elements of the stream are processed. The result is shown in the previous comments.</p>
			<p>When the stream is sequential, the combiner is never called. But when we make it parallel (<strong class="source-inline">list.parallelStream()</strong>), the <strong class="bold">Combiner is called!</strong> message is printed three times. As in the case of the <strong class="source-inline">reduce()</strong> operation, the number of partial results may vary, depending on the number of CPUs and the internal logic of the <strong class="source-inline">collect()</strong> operation implementation. So, the <strong class="bold">Combiner is called!</strong> message can be printed any number of times. </p>
			<p>Now, let’s look at the first form of the <strong class="source-inline">collect()</strong> operation. It requires an object of the class that implements the <strong class="source-inline">java.util.stream.Collector&lt;T,A,R&gt;</strong> interface, where <strong class="source-inline">T</strong> is the stream type, <strong class="source-inline">A</strong> is the container type, and <strong class="source-inline">R</strong> is the result type. You can use one of the following <strong class="source-inline">of()</strong> methods (from the <strong class="source-inline">Collector</strong> interface) to create the necessary <strong class="source-inline">Collector</strong> object:</p>
			<pre class="source-code">static Collector&lt;T,R,R&gt; of(Supplier&lt;R&gt; supplier, </pre>
			<pre class="source-code">                    BiConsumer&lt;R,T&gt; accumulator, </pre>
			<pre class="source-code">                    BinaryOperator&lt;R&gt; combiner, </pre>
			<pre class="source-code">                  Collector.Characteristics... characteristics)</pre>
			<p>Alternatively, you can use this:</p>
			<pre class="source-code">static Collector&lt;T,A,R&gt; of(Supplier&lt;A&gt; supplier, </pre>
			<pre class="source-code">                    BiConsumer&lt;A,T&gt; accumulator, </pre>
			<pre class="source-code">                    BinaryOperator&lt;A&gt; combiner, </pre>
			<pre class="source-code">                    Function&lt;A,R&gt; finisher, </pre>
			<pre class="source-code">                 Collector.Characteristics... characteristics).</pre>
			<p>The functions you have to pass to the preceding methods are similar to those we have demonstrated already. But we are not going to do this, for two reasons. First, it is more involved and pushes us beyond the scope of this book, and, second, before doing that, you have to look in the <strong class="source-inline">java.util.stream.Collectors</strong> class, which provides many ready-to-use collectors.</p>
			<p>As we have mentioned already, together with the operations discussed so far and the numeric streams<a id="_idIndexMarker1651"/> operations we are going to present in the next section, ready-to-use collectors<a id="_idIndexMarker1652"/> cover the vast majority of processing needs in mainstream programming, and there is a good chance you will never need to create a custom collector. </p>
			<h3>Collectors</h3>
			<p>The <strong class="source-inline">java.util.stream.Collectors</strong> class<a id="_idIndexMarker1653"/> provides <a id="_idIndexMarker1654"/>more than 40 methods that create <strong class="source-inline">Collector</strong> objects. We are going to demonstrate only the simplest and most popular ones, as follows:</p>
			<ul>
				<li><strong class="source-inline">Collector&lt;T,?,List&lt;T&gt;&gt; toList()</strong>: Creates a collector that generates a <strong class="source-inline">List</strong> object from stream elements</li>
				<li><strong class="source-inline">Collector&lt;T,?,Set&lt;T&gt;&gt; toSet()</strong>: Creates a collector that generates a <strong class="source-inline">Set</strong> object from stream elements</li>
				<li><strong class="source-inline">Collector&lt;T,?,Map&lt;K,U&gt;&gt; toMap (Function&lt;T,K&gt; keyMapper, Function&lt;T,U&gt; valueMapper)</strong>: Creates a collector that generates a <strong class="source-inline">Map</strong> object from stream elements</li>
				<li><strong class="source-inline">Collector&lt;T,?,C&gt; toCollection (Supplier&lt;C&gt; collectionFactory)</strong>: Creates a collector that generates a <strong class="source-inline">Collection</strong> object of the type provided by <strong class="source-inline">Supplier&lt;C&gt; collectionFactory</strong></li>
				<li><strong class="source-inline">Collector&lt;CharSequence,?,String&gt; joining()</strong>: Creates a collector that generates a <strong class="source-inline">String</strong> object by concatenating stream elements</li>
				<li><strong class="source-inline">Collector&lt;CharSequence,?,String&gt; joining (CharSequence delimiter)</strong>: Creates a<a id="_idIndexMarker1655"/> collector that generates a <a id="_idIndexMarker1656"/>delimiter-separated <strong class="source-inline">String</strong> object from stream elements</li>
				<li><strong class="source-inline">Collector&lt;CharSequence,?,String&gt; joining (CharSequence delimiter, CharSequence prefix, CharSequence suffix)</strong>: Creates a collector that generates a delimiter-separated <strong class="source-inline">String</strong> object from the stream elements and adds the specified <strong class="source-inline">prefix</strong> and <strong class="source-inline">suffix</strong></li>
				<li><strong class="source-inline">Collector&lt;T,?,Integer&gt; summingInt(ToIntFunction&lt;T&gt;)</strong>: Creates a collector that calculates the sum of the results generated by the provided function applied to each element; the same method exists for <strong class="source-inline">long</strong> and <strong class="source-inline">double</strong> types</li>
				<li><strong class="source-inline">Collector&lt;T,?,IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;T&gt;)</strong>: Creates a collector that calculates the sum, minimum, maximum, count, and average of the results generated by the provided function applied to each element; the same method exists for <strong class="source-inline">long</strong> and <strong class="source-inline">double</strong> types</li>
				<li><strong class="source-inline">Collector&lt;T,?,Map&lt;Boolean,List&lt;T&gt;&gt;&gt; partitioningBy (Predicate&lt;? super T&gt; predicate)</strong>: Creates a collector that separates the elements using the provided <strong class="source-inline">Predicate</strong> function</li>
				<li><strong class="source-inline">Collector&lt;T,?,Map&lt;K,List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;T,U&gt;)</strong>: Creates a collector that groups elements into <strong class="source-inline">Map</strong> with keys generated by the provided function</li>
			</ul>
			<p>The following demo code shows how to use the collectors created by the methods listed earlier. First, we<a id="_idIndexMarker1657"/> will<a id="_idIndexMarker1658"/> demonstrate usage of the <strong class="source-inline">toList()</strong>, <strong class="source-inline">toSet()</strong>, t<strong class="source-inline">oMap()</strong>, and <strong class="source-inline">toCollection()</strong> methods:</p>
			<pre class="source-code">List&lt;String&gt; ls = Stream.of("a", "b", "c")</pre>
			<pre class="source-code">                        .collect(Collectors.toList());</pre>
			<pre class="source-code">System.out.println(ls);                //prints: [a, b, c]</pre>
			<pre class="source-code">Set&lt;String&gt; set = Stream.of("a", "a", "c")</pre>
			<pre class="source-code">                        .collect(Collectors.toSet());</pre>
			<pre class="source-code">System.out.println(set);                //prints: [a, c]</pre>
			<pre class="source-code">List&lt;Person&gt; list = List.of(new Person(23, "Bob"),</pre>
			<pre class="source-code">                            new Person(33, "Jim"),</pre>
			<pre class="source-code">                            new Person(28, "Jill"),</pre>
			<pre class="source-code">                            new Person(27, "Bill"));</pre>
			<pre class="source-code">Map&lt;String, Person&gt; map = list.stream()</pre>
			<pre class="source-code">                              .collect(Collectors</pre>
			<pre class="source-code">                              .toMap(p -&gt; p.getName() + "-" + </pre>
			<pre class="source-code">                                          p.getAge(), p -&gt; p));</pre>
			<pre class="source-code">System.out.println(map);</pre>
			<pre class="source-code">               //prints: {Bob-23=Person{name='Bob', age:23},</pre>
			<pre class="source-code">               //         Bill-27=Person{name='Bill', age:27},</pre>
			<pre class="source-code">               //         Jill-28=Person{name='Jill', age:28},</pre>
			<pre class="source-code">               //         Jim-33=Person{name='Jim', age:33}}</pre>
			<pre class="source-code">Set&lt;Person&gt; personSet = list.stream()</pre>
			<pre class="source-code">                            .collect(Collectors</pre>
			<pre class="source-code">                            .toCollection(HashSet::new));</pre>
			<pre class="source-code">System.out.println(personSet);  </pre>
			<pre class="source-code">               //prints: [Person{name='Bill', age=27},</pre>
			<pre class="source-code">               //         Person{name='Jim', age=33},</pre>
			<pre class="source-code">               //         Person{name='Bob', age=23},</pre>
			<pre class="source-code">               //         Person{name='Jill', age=28}]</pre>
			<p>The <strong class="source-inline">joining()</strong> method <a id="_idIndexMarker1659"/>allows you to concatenate<a id="_idIndexMarker1660"/> the <strong class="source-inline">Character</strong> and <strong class="source-inline">String</strong> values in a delimited list with <strong class="source-inline">prefix</strong> and <strong class="source-inline">suffix</strong>:</p>
			<pre class="source-code">List&lt;String&gt; list1 = List.of("a", "b", "c", "d");</pre>
			<pre class="source-code">String result = list1.stream()</pre>
			<pre class="source-code">                     .collect(Collectors.joining());</pre>
			<pre class="source-code">System.out.println(result);                    //prints: abcd</pre>
			<pre class="source-code">result = list1.stream()</pre>
			<pre class="source-code">              .collect(Collectors.joining(", "));</pre>
			<pre class="source-code">System.out.println(result);                //prints: a, b, c, d</pre>
			<pre class="source-code">result = list1.stream()</pre>
			<pre class="source-code">        .collect(Collectors.joining(", ", "The result: ", ""));</pre>
			<pre class="source-code">System.out.println(result);    //prints: The result: a, b, c, d</pre>
			<pre class="source-code">result = list1.stream()</pre>
			<pre class="source-code">  .collect(Collectors.joining(", ", "The result: ", </pre>
			<pre class="source-code">                                                ". The End."));</pre>
			<pre class="source-code">System.out.println(result);</pre>
			<pre class="source-code">                     //prints: The result: a, b, c, d. The End.</pre>
			<p>Now, let’s turn to the <strong class="source-inline">summingInt()</strong> and <strong class="source-inline">summarizingInt()</strong> methods. They create collectors that calculate the sum and other statistics of the <strong class="source-inline">int</strong> values produced by the <a id="_idIndexMarker1661"/>provided <a id="_idIndexMarker1662"/>functions applied to each element:</p>
			<pre class="source-code">List&lt;Person&gt; list2 = List.of(new Person(23, "Bob"),</pre>
			<pre class="source-code">                             new Person(33, "Jim"),</pre>
			<pre class="source-code">                             new Person(28, "Jill"),</pre>
			<pre class="source-code">                             new Person(27, "Bill"));</pre>
			<pre class="source-code">int sum = list2.stream()</pre>
			<pre class="source-code">               .collect(Collectors.summingInt(Person::getAge));</pre>
			<pre class="source-code">System.out.println(sum);                 //prints: 111</pre>
			<pre class="source-code">IntSummaryStatistics stats = list2.stream()</pre>
			<pre class="source-code">           .collect(Collectors.summarizingInt(Person::getAge));</pre>
			<pre class="source-code">System.out.println(stats); //prints: IntSummaryStatistics{</pre>
			<pre class="source-code">         //count=4, sum=111, min=23, average=27.750000, max=33}</pre>
			<pre class="source-code">System.out.println(stats.getCount());    //prints: 4</pre>
			<pre class="source-code">System.out.println(stats.getSum());      //prints: 111</pre>
			<pre class="source-code">System.out.println(stats.getMin());      //prints: 23</pre>
			<pre class="source-code">System.out.println(stats.getAverage());  //prints: 27.750000</pre>
			<pre class="source-code">System.out.println(stats.getMax());      //prints: 33</pre>
			<p>There are also the <strong class="source-inline">summingLong()</strong>, <strong class="source-inline">summarizingLong()</strong>, <strong class="source-inline">summingDouble()</strong>, and <strong class="source-inline">summarizingDouble()</strong> methods.</p>
			<p>The <strong class="source-inline">partitioningBy()</strong> method creates a collector that groups the elements by the provided criteria <a id="_idIndexMarker1663"/>and<a id="_idIndexMarker1664"/> put the groups (lists) in a <strong class="source-inline">Map</strong> object, with a Boolean value as the key:</p>
			<pre class="source-code">Map&lt;Boolean, List&lt;Person&gt;&gt; map2 = list2.stream()</pre>
			<pre class="source-code">     .collect(Collectors.partitioningBy(p -&gt; p.getAge() &gt; 27));</pre>
			<pre class="source-code">System.out.println(map2); //prints: {false=[Person{name='Bob',</pre>
			<pre class="source-code">//age=23}, Person{name='Bill', age=27}, true=[Person{name='Jim',</pre>
			<pre class="source-code">//age=33}, Person{name='Jill', age=28}]}</pre>
			<p>As you can see, using the <strong class="source-inline">p.getAge() &gt; 27</strong> criteria, we were able to put all the persons in two groups: one is below or equal to <strong class="source-inline">27</strong> years of <strong class="source-inline">age</strong> (the key is <strong class="source-inline">false</strong>), and another is above <strong class="source-inline">27</strong> (the key is <strong class="source-inline">true</strong>).</p>
			<p>Finally, the <strong class="source-inline">groupingBy()</strong> method allows you to group elements by a value and put the groups (lists) in a <strong class="source-inline">Map</strong> object, with this value as a key:</p>
			<pre class="source-code">List&lt;Person&gt; list3 = List.of(new Person(23, "Bob"),</pre>
			<pre class="source-code">                             new Person(33, "Jim"),</pre>
			<pre class="source-code">                             new Person(23, "Jill"),</pre>
			<pre class="source-code">                             new Person(33, "Bill"));</pre>
			<pre class="source-code">Map&lt;Integer, List&lt;Person&gt;&gt; map3 = list3.stream()</pre>
			<pre class="source-code">               .collect(Collectors.groupingBy(Person::getAge));</pre>
			<pre class="source-code">System.out.println(map3);  </pre>
			<pre class="source-code">//prints: {33=[Person{name='Jim', age=33}, Person{name='Bill', //age=33}], 23=[Person{name='Bob', age=23}, Person{name='Jill', //age=23}]} </pre>
			<p>To be able to demonstrate this method, we changed our list of <strong class="source-inline">Person</strong> objects by setting <strong class="source-inline">age</strong> on each of them to either <strong class="source-inline">23</strong> or <strong class="source-inline">33</strong>. The result is two groups ordered by their <strong class="source-inline">age</strong>.</p>
			<p>There are also overloaded <strong class="source-inline">toMap()</strong>, <strong class="source-inline">groupingBy()</strong>, and <strong class="source-inline">partitioningBy()</strong> methods as well as the following, often overloaded, methods <a id="_idIndexMarker1665"/>that <a id="_idIndexMarker1666"/>create corresponding <strong class="source-inline">Collector</strong> objects, as follows:</p>
			<ul>
				<li><strong class="source-inline">counting()</strong></li>
				<li><strong class="source-inline">reducing()</strong></li>
				<li><strong class="source-inline">filtering()</strong></li>
				<li><strong class="source-inline">toConcurrentMap()</strong></li>
				<li><strong class="source-inline">collectingAndThen()</strong></li>
				<li><strong class="source-inline">maxBy()</strong>, <strong class="source-inline">minBy()</strong></li>
				<li><strong class="source-inline">mapping()</strong>, <strong class="source-inline">flatMapping()</strong></li>
				<li><strong class="source-inline">averagingInt()</strong>, <strong class="source-inline">averagingLong()</strong>, <strong class="source-inline">averagingDouble()</strong></li>
				<li><strong class="source-inline">toUnmodifiableList()</strong>, <strong class="source-inline">toUnmodifiableMap()</strong>, <strong class="source-inline">toUnmodifiableSet()</strong></li>
			</ul>
			<p>If you cannot find the operation you need among those discussed in this book, search the <strong class="source-inline">Collectors</strong> API first, before <a id="_idIndexMarker1667"/>building your<a id="_idIndexMarker1668"/> own <strong class="source-inline">Collector</strong> object.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor306"/>Numeric stream interfaces</h1>
			<p>As we have<a id="_idIndexMarker1669"/> mentioned already, all three numeric interfaces, <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong>, and <strong class="source-inline">DoubleStream</strong>, have methods similar to the methods in the <strong class="source-inline">Stream</strong> interface, including the methods of the <strong class="source-inline">Stream.Builder</strong> interface. This means that everything we have discussed so far in this chapter equally applies to any numeric stream interfaces. That is why, in this section, we will only talk about those methods that are not present in the <strong class="source-inline">Stream</strong> interface, as follows:</p>
			<ul>
				<li>The <strong class="source-inline">range(lower,upper)</strong> and <strong class="source-inline">rangeClosed(lower,upper)</strong> methods in the <strong class="source-inline">IntStream</strong> and <strong class="source-inline">LongStream</strong> interfaces allow you to create a stream from the values in the specified range.</li>
				<li>The <strong class="source-inline">boxed()</strong> and <strong class="source-inline">mapToObj()</strong> intermediate operations convert a numeric stream to <strong class="source-inline">Stream</strong></li>
				<li>The <strong class="source-inline">mapToInt()</strong>, <strong class="source-inline">mapToLong()</strong>, and <strong class="source-inline">mapToDouble()</strong> intermediate operations convert a numeric stream of one type to a numeric stream of another type.</li>
				<li>The <strong class="source-inline">flatMapToInt()</strong>, <strong class="source-inline">flatMapToLong()</strong>, and <strong class="source-inline">flatMapToDouble()</strong> intermediate operations convert a stream to a numeric stream.</li>
				<li>The <strong class="source-inline">sum()</strong> and <strong class="source-inline">average()</strong> terminal operations calculate the sum and average of numeric stream elements.</li>
			</ul>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor307"/>Creating a stream</h2>
			<p>In addition to <a id="_idIndexMarker1670"/>the methods of the <strong class="source-inline">Stream</strong> interface that create streams, the <strong class="source-inline">IntStream</strong> and <strong class="source-inline">LongStream</strong> interfaces allow you to create a stream from the values in the specified range.</p>
			<h3>range() and rangeClosed()</h3>
			<p>The <strong class="source-inline">range(lower, upper)</strong> method <a id="_idIndexMarker1671"/>generates all <a id="_idIndexMarker1672"/>values sequentially, starting <a id="_idIndexMarker1673"/>from<a id="_idIndexMarker1674"/> the <strong class="source-inline">lower</strong> value and ending with the value just before <strong class="source-inline">upper</strong>:</p>
			<pre class="source-code">IntStream.range(1, 3).forEach(System.out::print);  //prints: 12</pre>
			<pre class="source-code">LongStream.range(1, 3).forEach(System.out::print); //prints: 12</pre>
			<p>The <strong class="source-inline">rangeClosed(lower, upper)</strong> method generates all the values sequentially, starting from the <strong class="source-inline">lower</strong> value and ending with the <strong class="source-inline">upper</strong> value:</p>
			<pre class="source-code">IntStream.rangeClosed(1, 3).forEach(System.out::print); </pre>
			<pre class="source-code">                                                  //prints: 123</pre>
			<pre class="source-code">LongStream.rangeClosed(1, 3).forEach(System.out::print);  </pre>
			<pre class="source-code">                                                  //prints: 123</pre>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor308"/>Intermediate operations</h2>
			<p>In addition <a id="_idIndexMarker1675"/>to<a id="_idIndexMarker1676"/> the intermediate operations of the <strong class="source-inline">Stream</strong> interface, the <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong>, and <strong class="source-inline">DoubleStream</strong> interfaces also have number-specific intermediate operations: <strong class="source-inline">boxed()</strong>, <strong class="source-inline">mapToObj()</strong>, <strong class="source-inline">mapToInt()</strong>, <strong class="source-inline">mapToLong()</strong>, <strong class="source-inline">mapToDouble()</strong>, <strong class="source-inline">flatMapToInt()</strong>, <strong class="source-inline">flatMapToLong()</strong>, and <strong class="source-inline">flatMapToDouble()</strong>.</p>
			<h3>boxed() and mapToObj()</h3>
			<p>The <strong class="source-inline">boxed()</strong> intermediate <a id="_idIndexMarker1677"/>operation <a id="_idIndexMarker1678"/>converts (boxes) elements<a id="_idIndexMarker1679"/> of the primitive <a id="_idIndexMarker1680"/>numeric type to the corresponding wrapper type:</p>
			<pre class="source-code">    //IntStream.range(1, 3).map(Integer::shortValue) </pre>
			<pre class="source-code">                                                   //comp error </pre>
			<pre class="source-code">    //               .forEach(System.out::print);   </pre>
			<pre class="source-code">    IntStream.range(1, 3)</pre>
			<pre class="source-code">             .boxed()</pre>
			<pre class="source-code">             .map(Integer::shortValue)</pre>
			<pre class="source-code">             .forEach(System.out::print);          //prints: 12</pre>
			<pre class="source-code">    //LongStream.range(1, 3).map(Long::shortValue) </pre>
			<pre class="source-code">                                                //compile error </pre>
			<pre class="source-code">    //                .forEach(System.out::print); </pre>
			<pre class="source-code">    LongStream.range(1, 3)</pre>
			<pre class="source-code">              .boxed()</pre>
			<pre class="source-code">              .map(Long::shortValue)</pre>
			<pre class="source-code">              .forEach(System.out::print);         //prints: 12</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    //DoubleStream.of(1).map(Double::shortValue) </pre>
			<pre class="source-code">                                                //compile error</pre>
			<pre class="source-code">    //              .forEach(System.out::print);</pre>
			<pre class="source-code">    DoubleStream.of(1)</pre>
			<pre class="source-code">                .boxed()</pre>
			<pre class="source-code">                .map(Double::shortValue)</pre>
			<pre class="source-code">                .forEach(System.out::print);        //prints: 1</pre>
			<p>In the preceding code, we have commented out the lines that generate compilation errors because the elements generated by the <strong class="source-inline">range()</strong> method are primitive types. The <strong class="source-inline">boxed()</strong> operation converts a primitive value to the corresponding wrapping type, so it can be processed as a reference type. The <strong class="source-inline">mapToObj()</strong> intermediate operation does a similar transformation, but it is not as specialized as the <strong class="source-inline">boxed()</strong> operation <a id="_idIndexMarker1681"/>and allows you to use an element<a id="_idIndexMarker1682"/> of<a id="_idIndexMarker1683"/> primitive<a id="_idIndexMarker1684"/> type to produce an object of any type:</p>
			<pre class="source-code">IntStream.range(1, 3)</pre>
			<pre class="source-code">         .mapToObj(Integer::valueOf)</pre>
			<pre class="source-code">         .map(Integer::shortValue)</pre>
			<pre class="source-code">         .forEach(System.out::print);           //prints: 12</pre>
			<pre class="source-code">IntStream.range(42, 43)</pre>
			<pre class="source-code"> .mapToObj(i -&gt; new Person(i, "John"))</pre>
			<pre class="source-code"> .forEach(System.out::print); </pre>
			<pre class="source-code">                          //prints: Person{name='John', age=42}</pre>
			<pre class="source-code">LongStream.range(1, 3)</pre>
			<pre class="source-code">          .mapToObj(Long::valueOf)</pre>
			<pre class="source-code">          .map(Long::shortValue)</pre>
			<pre class="source-code">          .forEach(System.out::print);          //prints: 12</pre>
			<pre class="source-code">DoubleStream.of(1)</pre>
			<pre class="source-code">            .mapToObj(Double::valueOf)</pre>
			<pre class="source-code">            .map(Double::shortValue)</pre>
			<pre class="source-code">            .forEach(System.out::print);        //prints: 1</pre>
			<p>In the preceding code, we have added the <strong class="source-inline">map()</strong> operation just to prove that the <strong class="source-inline">mapToObj()</strong> operation does the job and creates an object of the wrapping type, as expected. Also, by adding the pipeline that produces <strong class="source-inline">Person</strong> objects, we have demonstrated<a id="_idIndexMarker1685"/> how the <strong class="source-inline">mapToObj()</strong> operation<a id="_idIndexMarker1686"/> can<a id="_idIndexMarker1687"/> be used to <a id="_idIndexMarker1688"/>create an object of any type. </p>
			<h3>mapToInt(), mapToLong(), and mapToDouble()</h3>
			<p>The <strong class="source-inline">mapToInt()</strong>, <strong class="source-inline">mapToLong()</strong>, and <strong class="source-inline">mapToDouble()</strong> intermediate<a id="_idIndexMarker1689"/> operations <a id="_idIndexMarker1690"/>allow<a id="_idIndexMarker1691"/> you to convert<a id="_idIndexMarker1692"/> a <a id="_idIndexMarker1693"/>numeric stream of one type to a numeric stream of another type. For the sake of example, we will convert a list of <strong class="source-inline">String</strong> values to a numeric stream of different types by mapping each <strong class="source-inline">String</strong> value to its length:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("one", "two", "three");</pre>
			<pre class="source-code">list.stream()</pre>
			<pre class="source-code">    .mapToInt(String::length)</pre>
			<pre class="source-code">    .forEach(System.out::print);               //prints: 335</pre>
			<pre class="source-code">list.stream()</pre>
			<pre class="source-code">    .mapToLong(String::length)</pre>
			<pre class="source-code">    .forEach(System.out::print);               //prints: 335</pre>
			<pre class="source-code">list.stream()</pre>
			<pre class="source-code">  .mapToDouble(String::length)</pre>
			<pre class="source-code">  .forEach(d -&gt; System.out.print(d + " ")); </pre>
			<pre class="source-code">                                          //prints: 3.0 3.0 5.0</pre>
			<pre class="source-code">list.stream()</pre>
			<pre class="source-code">    .map(String::length)</pre>
			<pre class="source-code">    .map(Integer::shortValue)</pre>
			<pre class="source-code">    .forEach(System.out::print);             //prints: 335</pre>
			<p>The elements of the created numeric streams are of the primitive type:</p>
			<pre class="source-code">//list.stream().mapToInt(String::length)</pre>
			<pre class="source-code">//             .map(Integer::shortValue) //compile error</pre>
			<pre class="source-code">//             .forEach(System.out::print);</pre>
			<p>As <a id="_idIndexMarker1694"/>we <a id="_idIndexMarker1695"/>are <a id="_idIndexMarker1696"/>on this<a id="_idIndexMarker1697"/> topic, if you would like to convert elements to a numeric wrapping type, the intermediate <strong class="source-inline">map()</strong> operation is the way to do it (instead of <strong class="source-inline">mapToInt()</strong>):</p>
			<pre class="source-code">list.stream().map(String::length)</pre>
			<pre class="source-code">        .map(Integer::shortValue)</pre>
			<pre class="source-code">        .forEach(System.out::print);      //prints: 335</pre>
			<h3>flatMapToInt(), flatMapToLong(), and flatMapToDouble()</h3>
			<p>The <strong class="source-inline">flatMapToInt()</strong>, <strong class="source-inline">flatMapToLong()</strong>, and <strong class="source-inline">flatMapToDouble()</strong> intermediate<a id="_idIndexMarker1698"/> operations<a id="_idIndexMarker1699"/> produce <a id="_idIndexMarker1700"/>a <a id="_idIndexMarker1701"/>numeric<a id="_idIndexMarker1702"/> stream<a id="_idIndexMarker1703"/> of the following corresponding type:</p>
			<pre class="source-code">List&lt;Integer&gt; list = List.of(1, 2, 3);</pre>
			<pre class="source-code">list.stream()</pre>
			<pre class="source-code">    .flatMapToInt(i -&gt; IntStream.rangeClosed(1, i))</pre>
			<pre class="source-code">    .forEach(System.out::print);               //prints: 112123</pre>
			<pre class="source-code">list.stream()</pre>
			<pre class="source-code">    .flatMapToLong(i -&gt; LongStream.rangeClosed(1, i))</pre>
			<pre class="source-code">    .forEach(System.out::print);               //prints: 112123</pre>
			<pre class="source-code">list.stream()</pre>
			<pre class="source-code">    .flatMapToDouble(DoubleStream::of)</pre>
			<pre class="source-code">    .forEach(d -&gt; System.out.print(d + " "));  </pre>
			<pre class="source-code">                                          //prints: 1.0 2.0 3.0</pre>
			<p>As <a id="_idIndexMarker1704"/>you<a id="_idIndexMarker1705"/> can <a id="_idIndexMarker1706"/>see in the <a id="_idIndexMarker1707"/>preceding <a id="_idIndexMarker1708"/>code, we<a id="_idIndexMarker1709"/> have used <strong class="source-inline">int</strong> values in the original stream, but it can be a stream of any type:</p>
			<pre class="source-code">List.of("one", "two", "three")</pre>
			<pre class="source-code">    .stream()</pre>
			<pre class="source-code">    .flatMapToInt(s -&gt; IntStream.rangeClosed(1, s.length()))</pre>
			<pre class="source-code">    .forEach(System.out::print);          //prints: 12312312345</pre>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor309"/>Terminal operations</h2>
			<p>Numeric-specific<a id="_idIndexMarker1710"/> terminal <a id="_idIndexMarker1711"/>operations are pretty straightforward. There are two of them, as follows:</p>
			<ul>
				<li><strong class="source-inline">sum()</strong>: Calculates the sum of numeric stream elements</li>
				<li><strong class="source-inline">average()</strong>: Calculates the average of numeric stream elements</li>
			</ul>
			<h3>sum() and average()</h3>
			<p>If you need<a id="_idIndexMarker1712"/> to<a id="_idIndexMarker1713"/> calculate a<a id="_idIndexMarker1714"/> sum or<a id="_idIndexMarker1715"/> an average of the values of numeric stream elements, the only requirement for the stream is that it should not be infinite. Otherwise, the calculation never finishes. The following are examples of these operational usages:</p>
			<pre class="source-code">int sum = IntStream.empty().sum();</pre>
			<pre class="source-code">System.out.println(sum);    //prints: 0</pre>
			<pre class="source-code">sum = IntStream.range(1, 3).sum();</pre>
			<pre class="source-code">System.out.println(sum);    //prints: 3</pre>
			<pre class="source-code">double av = IntStream.empty().average().orElse(0);</pre>
			<pre class="source-code">System.out.println(av);     //prints: 0.0</pre>
			<pre class="source-code">av = IntStream.range(1, 3).average().orElse(0);</pre>
			<pre class="source-code">System.out.println(av);     //prints: 1.5</pre>
			<pre class="source-code">long suml = LongStream.range(1, 3).sum();</pre>
			<pre class="source-code">System.out.println(suml);   //prints: 3</pre>
			<pre class="source-code">double avl = LongStream.range(1, 3).average().orElse(0);</pre>
			<pre class="source-code">System.out.println(avl);    //prints: 1.5</pre>
			<pre class="source-code">double sumd = DoubleStream.of(1, 2).sum();</pre>
			<pre class="source-code">System.out.println(sumd);   //prints: 3.0</pre>
			<pre class="source-code">double avd = DoubleStream.of(1, 2).average().orElse(0);</pre>
			<pre class="source-code">System.out.println(avd);    //prints: 1.5</pre>
			<p>As you<a id="_idIndexMarker1716"/> can <a id="_idIndexMarker1717"/>see, using<a id="_idIndexMarker1718"/> these<a id="_idIndexMarker1719"/> operations on an empty stream is not a problem.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor310"/>Parallel streams</h1>
			<p>We have <a id="_idIndexMarker1720"/>seen that changing from a sequential stream to a parallel stream can lead to incorrect results if code was not written and tested to process a parallel stream. The following are a few more considerations related to parallel streams.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor311"/>Stateless and stateful operations</h2>
			<p>There<a id="_idIndexMarker1721"/> are <strong class="bold">stateless operations</strong>, such as <strong class="source-inline">filter()</strong>, <strong class="source-inline">map()</strong>, and <strong class="source-inline">flatMap()</strong>, which<a id="_idIndexMarker1722"/> do not<a id="_idIndexMarker1723"/> keep<a id="_idIndexMarker1724"/> data around (do not maintain state) while moving processing from one stream element to the next. Also, there are stateful operations, such as <strong class="source-inline">distinct()</strong>, <strong class="source-inline">limit()</strong>, <strong class="source-inline">sorted()</strong>, <strong class="source-inline">reduce()</strong>, and <strong class="source-inline">collect()</strong>, that can pass a state from previously processed elements to the processing of the next element.</p>
			<p>Stateless operations usually do not pose a problem while switching from a sequential stream to a parallel one. Each element is processed independently, and the stream can be broken into any number of substreams for independent processing. With stateful operations, the situation is different. To start with, using them for an infinite stream may never finish processing. Also, while discussing the <strong class="source-inline">reduce()</strong> and <strong class="source-inline">collect()</strong> stateful operations, we have demonstrated how switching to a parallel stream can produce a different result if the initial value (or identity) is set without parallel processing in mind.</p>
			<p>There are performance considerations too. Stateful operations often require you to process all the stream elements in several passes, using buffering. For large streams, it may tax JVM resources and slow down, if not completely shut down, an application.</p>
			<p>This is why a programmer should not take switching from sequential to parallel streams lightly. If <a id="_idIndexMarker1725"/>stateful <a id="_idIndexMarker1726"/>operations are involved, code <a id="_idIndexMarker1727"/>has to be<a id="_idIndexMarker1728"/> designed and tested to be able to perform parallel stream processing without negative effects.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor312"/>Sequential or parallel processing?</h2>
			<p>As we <a id="_idIndexMarker1729"/>indicated<a id="_idIndexMarker1730"/> in the<a id="_idIndexMarker1731"/> previous section, parallel <a id="_idIndexMarker1732"/>processing may or may not produce better performance. You have to test every use case before deciding on using parallel streams. Parallelism can yield better performance, but code has to be designed and possibly optimized to do it. Also, each assumption has to be tested in an environment that is as close to production as possible.</p>
			<p>However, there are a few considerations you can take into account while deciding between sequential and parallel processing, as follows:</p>
			<ul>
				<li>Small streams are typically processed faster sequentially (although, what is <em class="italic">small</em> for your environment should be determined through testing and by measuring performance).</li>
				<li>If stateful operations cannot be replaced with stateless ones, carefully design your code for parallel processing or just avoid it.</li>
			</ul>
			<p>Consider parallel processing for procedures that require extensive calculations, but think about bringing the partial results together for the final result. Look in the <strong class="source-inline">streams</strong> folder. It contains a standalone stream-processing application. To simulate a stream of data, we created an <strong class="source-inline">input.csv</strong> file that contains a header and 14 lines, each line representing data of one person: first name, last name, age, street address, city, state, and zip code.</p>
			<p>The application reads this file as a stream of lines, skips the first line (header), and processes the rest of the lines by converting each of them to a <strong class="source-inline">Person</strong> class object:  </p>
			<pre class="source-code">List&lt;Person&gt; getInputPersonList(File file) throws IOException {</pre>
			<pre class="source-code">  return Files.lines(file.toPath())</pre>
			<pre class="source-code">              .skip(1)</pre>
			<pre class="source-code">              .parallel()</pre>
			<pre class="source-code">              .map(Main::validLine)</pre>
			<pre class="source-code">              .map(l -&gt; {</pre>
			<pre class="source-code">                    Person person = </pre>
			<pre class="source-code">                       new Person(Integer.parseInt(l.get(2)), </pre>
			<pre class="source-code">                                          l.get(0), l.get(1));</pre>
			<pre class="source-code">                    person.setAddress(l.get(3), l.get(4), </pre>
			<pre class="source-code">                        l.get(5), Integer.parseInt(l.get(6)));</pre>
			<pre class="source-code">                    return person;</pre>
			<pre class="source-code">              }).toList();</pre>
			<pre class="source-code">}</pre>
			<p>Since the<a id="_idIndexMarker1733"/> sequence <a id="_idIndexMarker1734"/>of <a id="_idIndexMarker1735"/>processing the lines does not affect the<a id="_idIndexMarker1736"/> result, we can process the stream of lines in parallel. Also, note that we stop processing (by throwing an exception) if a line does not have enough data or some data does not match the expected format:</p>
			<pre class="source-code">List&lt;String&gt; validLine(String line){</pre>
			<pre class="source-code">   String[] arr = line.split(",");</pre>
			<pre class="source-code">   if(arr.length != 7){</pre>
			<pre class="source-code">     throw new RuntimeException(EXPECTED + " 7 column: " + </pre>
			<pre class="source-code">                                                         line);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   List&lt;String&gt; values = Arrays.stream(arr)</pre>
			<pre class="source-code">     .parallel()</pre>
			<pre class="source-code">     .map(s -&gt; {</pre>
			<pre class="source-code">          String val = s.trim();</pre>
			<pre class="source-code">          if(val.isEmpty()){</pre>
			<pre class="source-code">            throw new RuntimeException(EXPECTED + </pre>
			<pre class="source-code">                            " only non-empty values: " + line);</pre>
			<pre class="source-code">          }</pre>
			<pre class="source-code">          return val;</pre>
			<pre class="source-code">   }).toList();</pre>
			<pre class="source-code">   </pre>
			<pre class="source-code">   try {</pre>
			<pre class="source-code">         Integer.valueOf(values.get(2));</pre>
			<pre class="source-code">         Integer.valueOf(values.get(6));</pre>
			<pre class="source-code">   } catch (Exception e) {</pre>
			<pre class="source-code">     throw new RuntimeException(EXPECTED + </pre>
			<pre class="source-code">                       " numbers in columns 3 and 7: " + line);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   if(values.get(6).length() != 5){</pre>
			<pre class="source-code">     throw new RuntimeException(EXPECTED + </pre>
			<pre class="source-code">                           " zip code 5 digits only: " + line);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return values;</pre>
			<pre class="source-code">}</pre>
			<p>Then, we <a id="_idIndexMarker1737"/>process<a id="_idIndexMarker1738"/> the<a id="_idIndexMarker1739"/> resulting <a id="_idIndexMarker1740"/>list of <strong class="source-inline">Person</strong> class objects as follows:</p>
			<pre class="source-code">   Set&lt;String&gt; cities = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">   Set&lt;String&gt; states = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">   Set&lt;Integer&gt; zips = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">   Map&lt;Integer, Integer&gt; oldestByZip = new HashMap&lt;&gt;();</pre>
			<pre class="source-code">   Map&lt;Integer, String&gt; oldestNameByZip = new HashMap&lt;&gt;();</pre>
			<pre class="source-code">   URL url = Main.class.getClassLoader().getResource(</pre>
			<pre class="source-code">                                                  "input.csv");</pre>
			<pre class="source-code">   File file = new File(url.toURI());</pre>
			<pre class="source-code">   List&lt;Person&gt; list = getInputPersonList(file);</pre>
			<pre class="source-code">   list.stream()</pre>
			<pre class="source-code">       .forEach(p -&gt; {</pre>
			<pre class="source-code">            cities.add(p.getCity());</pre>
			<pre class="source-code">            states.add(p.getState());</pre>
			<pre class="source-code">            zips.add(p.getZip());</pre>
			<pre class="source-code">            int age = oldestByZip.getOrDefault(p.getZip(), 0);</pre>
			<pre class="source-code">            if(p.getAge() &gt; age){</pre>
			<pre class="source-code">              oldestByZip.put(p.getZip(), p.getAge());</pre>
			<pre class="source-code">              oldestNameByZip.put(p.getZip(), </pre>
			<pre class="source-code">                             p.getAge() + ": " + p.getName());</pre>
			<pre class="source-code">            } else if (p.getAge() == age){</pre>
			<pre class="source-code">              oldestNameByZip.put(p.getZip(), </pre>
			<pre class="source-code">                    oldestNameByZip.get(p.getZip()) + </pre>
			<pre class="source-code">                                          ", " + p.getName());</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">   });</pre>
			<p>In the<a id="_idIndexMarker1741"/> preceding <a id="_idIndexMarker1742"/>code, we<a id="_idIndexMarker1743"/> create the <strong class="source-inline">Set</strong> and <strong class="source-inline">Map</strong> objects that <a id="_idIndexMarker1744"/>contain results that we print later, as follows:</p>
			<pre class="source-code">System.out.println("cities: " +</pre>
			<pre class="source-code">  cities.stream().sorted().collect(Collectors.joining(", ")));</pre>
			<pre class="source-code">System.out.println("states: " +</pre>
			<pre class="source-code">  states.stream().sorted().collect(Collectors.joining(", ")));</pre>
			<pre class="source-code">System.out.println("zips: " + zips.stream().sorted()</pre>
			<pre class="source-code">                              .map(i -&gt; String.valueOf(i))</pre>
			<pre class="source-code">                          .collect(Collectors.joining(", ")));</pre>
			<pre class="source-code">System.out.println("Oldest in each zip: " +</pre>
			<pre class="source-code">            oldestNameByZip.keySet().stream().sorted()</pre>
			<pre class="source-code">              .map(i -&gt; i + "=&gt;" + oldestNameByZip.get(i))</pre>
			<pre class="source-code">                          .collect(Collectors.joining("; ")));</pre>
			<p>The output is demonstrated in the following screenshot:</p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="image/B18388_Figure_14.3.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, it shows in alphabetical order all the cities, all the states, and all the zip codes listed in the <strong class="source-inline">input.csv</strong> file, as well as the oldest person for each zip code.</p>
			<p>The same result can be achieved by using a <strong class="source-inline">for-</strong>loop instead of each stream in this application, so using Java standard streams is more a matter of style than necessity. We prefer using streams because it allows for more compact code. In <a href="B18388_15_ePub.xhtml#_idTextAnchor315"><em class="italic">Chapter 15</em></a>, <em class="italic">Reactive Programming</em>, we will present and discuss another type of stream (called a <em class="italic">reactive stream</em>) that cannot be replaced by <strong class="source-inline">for-</strong>loops, at least not easily. Reactive <a id="_idIndexMarker1745"/>streams <a id="_idIndexMarker1746"/>are<a id="_idIndexMarker1747"/> used primarily for asynchronous <a id="_idIndexMarker1748"/>processing, which will also be explored in the next chapter.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor313"/>Summary</h1>
			<p>In this chapter, we have talked about data-stream processing, which is different from processing the I/O streams we reviewed in <a href="B18388_05_ePub.xhtml#_idTextAnchor121"><em class="italic">Chapter 5</em></a>, <em class="italic">Strings, Input/Output, and Files</em>. We defined what data streams are, how to process their elements using stream operations, and how to chain (connect) stream operations in a pipeline. We also discussed stream initialization and how to process streams in parallel. </p>
			<p>Now, you know how to write code that processes streams of data, as well as create a stream-processing application as a standalone project.</p>
			<p>In the next chapter, you will be introduced to the <strong class="bold">Reactive Manifesto</strong>, its purpose, and examples of its implementations. We will discuss the difference between reactive and responsive systems and what <strong class="bold">asynchronous</strong> and <strong class="bold">non-blocking</strong> processing are. We will also talk about <strong class="bold">Reactive Streams</strong> and <strong class="bold">RxJava</strong>.</p>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor314"/>Quiz</h1>
			<ol>
				<li>What is the difference between I/O streams and <strong class="source-inline">java.util.stream.Stream</strong>? Select all that apply:<ol><li>I/O streams are oriented toward data delivery, while <strong class="source-inline">Stream</strong> is oriented toward data processing.</li><li>Some I/O streams can be transformed into <strong class="source-inline">Stream</strong>.</li><li>I/O streams can read from a file, while <strong class="source-inline">Stream</strong> cannot.</li><li>I/O streams can write to a file, while <strong class="source-inline">Stream</strong> cannot.</li></ol></li>
				<li>What do the <strong class="source-inline">empty()</strong> and <strong class="source-inline">of(T... values)</strong> <strong class="source-inline">Stream</strong> methods have in common?</li>
				<li>What type are the elements emitted by the <strong class="source-inline">Stream.ofNullable(Set.of(1,2,3 )</strong> stream?</li>
				<li>What does the following code print?<p class="source-code">Stream.iterate(1, i -&gt; i + 2)</p><p class="source-code">      .limit(3)</p><p class="source-code">      .forEach(System.out::print);</p></li>
				<li>What does the following code print?<p class="source-code">Stream.concat(Set.of(42).stream(), </p><p class="source-code">             List.of(42).stream()).limit(1)</p><p class="source-code">                             .forEach(System.out::print);</p></li>
				<li>What does the following code print?<p class="source-code">Stream.generate(() -&gt; 42 / 2)</p><p class="source-code">      .limit(2)</p><p class="source-code">      .forEach(System.out::print);</p></li>
				<li>Is <strong class="source-inline">Stream.Builder</strong> a functional interface?</li>
				<li>How many elements does the following stream emit?<p class="source-code">new Random().doubles(42).filter(d -&gt; d &gt;= 1)</p></li>
				<li>What does the following code print? <p class="source-code">Stream.of(1,2,3,4)</p><p class="source-code">        .skip(2)</p><p class="source-code">        .takeWhile(i -&gt; i &lt; 4)</p><p class="source-code">        .forEach(System.out::print);</p></li>
				<li>What is the value of <strong class="source-inline">d</strong> in the following code? <p class="source-code">double d = Stream.of(1, 2)</p><p class="source-code">                 .mapToDouble(Double::valueOf)</p><p class="source-code">                 .map(e -&gt; e / 2)</p><p class="source-code">                 .sum();</p></li>
				<li>What is the value of the <strong class="source-inline">s</strong> string in the following code?<p class="source-code">String s = Stream.of("a","X","42").sorted()</p><p class="source-code"> .collect(Collectors.joining(","));</p></li>
				<li>What is the result of the following code?<p class="source-code">List.of(1,2,3).stream()</p><p class="source-code">              .peek(i -&gt; i &gt; 2 )</p><p class="source-code">              .forEach(System.out::print);</p></li>
				<li>How many stream elements does the <strong class="source-inline">peek()</strong> operation print in the following code?<p class="source-code">List.of(1,2,3).stream()</p><p class="source-code">              .peek(System.out::println)</p><p class="source-code">              .noneMatch(e -&gt; e == 2);</p></li>
				<li>What does the <strong class="source-inline">or()</strong> method return when the <strong class="source-inline">Optional</strong> object is empty?</li>
				<li>What is the value of the <strong class="source-inline">s</strong> string in the following code?<p class="source-code">String s = Stream.of("a","X","42")</p><p class="source-code"> .max(Comparator.naturalOrder())</p><p class="source-code"> .orElse("12");</p></li>
				<li>How many elements does the <strong class="source-inline">IntStream.rangeClosed(42, 42)</strong> stream emit?</li>
				<li>Name two stateless operations.</li>
				<li>Name two stateful operations.</li>
			</ol>
		</div>
	</body></html>