<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project 2 - Building Microservices with Lagom</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="section">
<div class="layoutArea">
<div class="column">
<p><span>The final part of this book goes into the details of the Lagom framework by discussing its philosophy, the way Lagom applications are structured, and available APIs and how to use them.</span></p>
<p><span>In this chapter, we will build, once again, our bakery project, this time structured as a number of microservices.</span></p>
</div>
</div>
</div>
</div>
<p><span>After reading this chapter, you will be able to do the following:</span></p>
<ul>
<li><span>Understand the advantages of using Lagom</span></li>
<li><span>Set up Lagom and use it to create projects</span></li>
<li><span>Structure an application as required by the framework</span></li>
<li><span>Efficiently use provided APIs</span></li>
<li><span>Unit test Lagom services</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Before we begin, make sure you have the following installed:</p>
<ul>
<li>JDK 8+</li>
<li>SBT 1.2+</li>
</ul>
<p><span>The code for this chapter is available at GitHub: <a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15</a>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Why Lagom?</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we discussed the benefits and downsides of a microservices-based approach. We named the main architectural properties of microservices such as autonomy, isolation, and data ownership. We also noted that, compared to the traditional monolithic approach, microservices reduce the complexity of a single service but the complexity of the system as a whole does not disappear. In a sense, it just moves from the internals of a single microservice into the space between them. We looked at the implementation of the shop as a RESTful microservice, and we admitted that we would avoid this additional complexity by focusing on a single service.</p>
<p>As we worked through the Akka-based solution, we also chose the proper database to store events as well as defining and applying migrations to have a proper database schema. The choice of the configuration mechanism was predetermined by Akka but we still had to read and verify the configuration manually. We also needed to decide how to pass dependencies as we constructed runnable applications and <span>properly </span>implemented this passing.</p>
<p>The Lagom framework builds on top of a few existing technologies and utilizes the "convention over configuration" approach to reduce the burden of these repetitive mechanical tasks and to deliver some additional functionality specific to the microservice systems. It does so by providing a kind of "template" for projects.</p>
<p>The preconfigured features include the following:</p>
<ul>
<li>Use of event sourcing as a mechanism for distributed persistence. The recommended database is Apache Cassandra because of its exceptional scalability and natural support for the read side of the CQRS principle.</li>
<li>Support for asynchronous communications by making use of reactive streams with Akka Streams as an implementation and message-passing style with Apache Kafka as a broker.</li>
<li>Transparent support for different communication protocols, which allows you to abstract complex API calls behind simple method calls.</li>
<li>Expressive-service-description DSL, which allows you to define APIs in a flexible and concise way.</li>
<li>Dynamic scalability with Akka Cluster.</li>
<li>A choice of dependency injection frameworks to wire the application at compile or runtime.</li>
<li>Development mode with hot code reload and an ability to start all services and required infrastructure components, including a special development service registry and a service gateway with a single command.</li>
<li>Default configuration for the infrastructure and preconfigured logging.</li>
</ul>
<p class="mce-root">Let's see how these features will help us to re-implement our bakery project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project overview and setup</h1>
                </header>
            
            <article>
                
<p>We already implemented our bakery project three times using different technologies in <a href="87c2e446-3730-49ae-b86b-fc8269678399.xhtml">Chapter 11</a>, <em>An Introduction to the Akka and Actor Models,</em> to <a href="8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml">Chapter 13</a>, <em>Basics of Akka Streams</em>. Let's recap what this is about for the readers who aren't familiar with the third section of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The bakery project</h1>
                </header>
            
            <article>
                
<p>The bakery contains a few employees working together to produce delicious cookies. The structure of their communication is represented in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7494c8d3-8fed-453e-ba0c-fb322b2db773.png" style="width:36.08em;height:14.00em;" width="722" height="280"/></p>
<p>Each of the employees is skilled in a specific area:</p>
<ul>
<li>The <strong>Manager</strong> drives the process by taking the results of the work of each of the participants and giving them to the next step in the flow. They also create initial shopping lists.</li>
<li>The <strong>Boy</strong>, if given a shopping list, will run to the grocery store and return with groceries.</li>
<li>The <strong>Chef</strong>, if given groceries, will make dough. They do so by creating a couple of <strong>Mixers</strong> of limited capacity so that bigger amounts of groceries can be processed in parallel.</li>
<li>The <strong>Cook</strong>, if given dough, makes some raw cookies.</li>
<li>The <strong>Baker</strong>, if given raw cookies, will bake them for some time using the <strong>Oven</strong>, hence producing delicious cookies.</li>
</ul>
<p>This time we're going to model each worker as a microservice. The <strong>Mixers</strong> and the <strong>Oven</strong> will become implementation details of the owning service. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project setup</h1>
                </header>
            
            <article>
                
<p>It goes without saying that we'll implement our microservices using the Lagom framework. Lagom supports both Maven and SBT as build tools but SBT provides a much better user experience so we will ignore Maven as it is less relevant for Scala projects. </p>
<div class="mce-root packt_infobox">Further, in this section we're going to create a Lagom project from scratch. We could utilize a slightly different approach by creating an example project with Giter8 and then modifying and extending it as needed. The command is similar to the one we mentioned in <a href="87c2e446-3730-49ae-b86b-fc8269678399.xhtml">Chapter 11</a><span>, </span><em>An Introduction to the Akka and Actor Models</em>: <kbd>sbt new lagom/lagom-scala.g8</kbd>.</div>
<p>As before, our SBT setup will contain a number of files describing different aspects of the project. For the following, assume we've created a project folder and navigated to it in the Terminal:</p>
<pre><strong>slasch@void:~$ mkdir bakery</strong><br/><strong>slasch@void:~$ cd bakery</strong><br/><strong>slasch@void:~$ echo 'addSbtPlugin("com.lightbend.lagom" % "lagom-sbt-plugin" % "1.4.7")' &gt; plugins.sbt</strong><br/><strong>slasch@void:~$ echo 'sbt.version=1.1.5' &gt; build.properties</strong><br/><strong>slasch@void:~$ cd ..</strong><br/><strong>slasch@void:~$ echo '-J-Xms1024M</strong><br/><strong>&gt; -J-Xmx4096M</strong><br/><strong>&gt; -J-Xss2M</strong><br/><strong>&gt; -J-XX:MaxMetaspaceSize=1024M' &gt; .sbtopts</strong></pre>
<p>Here, we define that our project requires a Lagom SBT plugin, the version of SBT to be used, as well as few SBT options in the <kbd>.sbtopts</kbd> file. The first two lines define the initial and maximum amount of memory SBT is allowed to consume. We're going to start quite a lot of microservices and supporting infrastructure components so it is necessary to have enough memory available. The <span><kbd>-Xss</kbd> parameter defines a stack size of <kbd>2M</kbd> per thread. It is generally useful in Scala projects to prevent non-tail-recursive functions from overflowing the stack too soon. The last parameter, <kbd>-XX:MaxMetaspaceSize</kbd>, defines the size of the metaspace that is used (starting from the JVM 8) to store class metadata. Because of the Lagom's hot reloading, we're going to create and load many classes during development so we need to have a metaspace of significant size.</span></p>
<p><kbd>build.sbt</kbd> will contain a number of submodules so it is easier to create with a text editor. This is what the (partial) final result looks like:</p>
<pre>organization in ThisBuild := "packt"<br/>version in ThisBuild := "1.0-SNAPSHOT"<br/><br/>scalaVersion in ThisBuild := "2.12.6"<br/><br/>val macwire = "com.softwaremill.macwire" %% "macros" % "2.3.0" % Provided<br/>val scalaTest = "org.scalatest" %% "scalatest" % "3.0.5" % Test<br/>val defaultDependencies = Seq(lagomScaladslTestKit, macwire, scalaTest)<br/><br/>lazy val `shared-model` = (project in file("shared-model"))<br/>  .settings(libraryDependencies += lagomScaladslApi)<br/><br/>lazy val bakery = (project in file("."))<br/>  .aggregate(<br/>    `boy-api`, `boy-impl`, <br/>    `chef-api`, `chef-impl`, <br/>    `cook-api`, `cook-impl`, <br/>    `baker-api`, `baker-impl`, <br/>    `manager-api`, `manager-impl`)<br/><br/>lazy val `boy-api` = (project in file("boy-api"))<br/>  .settings(libraryDependencies += lagomScaladslApi)<br/><br/>// other APIs defined the same way<br/><br/>lazy val `boy-impl` = (project in file("boy-impl"))<br/>  .enablePlugins(LagomScala)<br/>  .settings(libraryDependencies ++= defaultDependencies)<br/>  .dependsOn(`boy-api`)<br/><br/>// other implementations defined the same way<br/><br/>lazy val `chef-impl` = (project in file("chef-impl"))<br/>  .enablePlugins(LagomScala)<br/>  .settings(<br/>    libraryDependencies ++= Seq(<br/>      lagomScaladslPersistenceCassandra,<br/>      lagomScaladslKafkaBroker,<br/>      lagomScaladslTestKit,<br/>      lagomScaladslPubSub,<br/>      macwire<br/>    )<br/>  )<br/>  .settings(lagomForkedTestSettings: _*)<br/>  .dependsOn(`chef-api`)<br/><br/>lazy val `manager-impl` = (project in file("manager-impl"))<br/>  .enablePlugins(LagomScala)<br/>  .settings(libraryDependencies ++= defaultDependencies)<br/>  .dependsOn(`manager-api`, `boy-api`, `chef-api`, `cook-api`, `baker-api`)</pre>
<p>We've cut the repetitive definitions so please refer to the GitHub repository (<a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15</a>) for the full source code. Here, we define general properties of the project, a shared model, and five microservices.</p>
<p>Each microservice consists of two modules, an API definition, and an implementation. Most of the API definitions in our case require just a single <kbd>lagomScaladslApi</kbd> dependency and the implementation—just <kbd>macwire</kbd> in the main scope. We've defined <kbd>defaultDependencies</kbd> including the test scope to keep further definitions concise.</p>
<p>For <kbd>chef-impl</kbd>, we include three other compile-time dependencies:</p>
<ul>
<li><kbd>lagomScaladslPersistenceCassandra</kbd></li>
<li><kbd>lagomScaladslPubSub</kbd> </li>
<li><kbd>lagomScaladslKafkaBroker</kbd></li>
</ul>
<p>The Chef will take some time to mix the dough and because of this we aim to implement communication with the Manager via a message broker to decouple both from each other.</p>
<p>Another deviation is the definition of <kbd>manager-impl</kbd>. The Manager will communicate with each of the other services, so it needs to know the API definitions of other workers. We also created a folder for each of the defined microservices in the filesystem. This is what our file structure with multiple modules looks like in the end:</p>
<pre><strong>slasch@void:~/ch15 [ch15-lagom]$ tree --dirsfirst</strong><br/><strong>.</strong><br/><strong>├── baker-api</strong><br/><strong>├── baker-impl</strong><br/><strong>├── boy-api</strong><br/><strong>├── boy-impl</strong><br/><strong>├── chef-api</strong><br/><strong>├── chef-impl</strong><br/><strong>├── cook-api</strong><br/><strong>├── cook-impl</strong><br/><strong>├── manager-api</strong><br/><strong>├── manager-impl</strong><br/><strong>├── project</strong><br/><strong>│   ├── build.properties</strong><br/><strong>│   └── plugins.sbt</strong><br/><strong>└── build.sbt</strong></pre>
<p>As we go on with the implementation, we'll define a project structure as required by SBT <span>for each of the modules:</span></p>
<pre><strong>slasch@void:~/ch15/cook-api [ch15-lagom]$ tree</strong><br/><strong>.</strong><br/><strong>└── src</strong><br/><strong>    ├── main</strong><br/><strong>    │   ├── resources</strong><br/><strong>    │   └── scala</strong><br/><strong>    └── test</strong><br/><strong>        ├── resources</strong><br/><strong>        └── scala</strong></pre>
<p><span>By having this structure, we're done with the preparation of the project infrastructure and can move on to implementing the services. </span></p>
<p>The next diagram outlines the communication flow between modules:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4a64ca8a-8335-4bb2-9b30-d29998a4b34a.png" width="1070" height="491"/></p>
<p><span>In order to simplify our example a bit, we will violate the rule that each microservice should own the definition of its model. We'll define a module containing definitions of all of the case classes used by the services we're going to build. We will add this module as a dependency to every other module we've defined before.</span></p>
<p>The module itself will contain definitions already known to us from previous chapters:</p>
<pre><span>package </span>ch15<br/><br/><span>object </span>model {<br/>  <span>final case class </span>ShoppingList(eggs: Int, flour: Int, sugar: Int, chocolate: Int)<br/>  <span>final case class </span>Groceries(eggs: Int, flour: Int, sugar: Int, chocolate: Int)<br/>  <span>final case class </span>Dough(weight: Int)<br/>  <span>final case class </span>RawCookies(count: Int)<br/>  <span>final case class </span>ReadyCookies(count: Int)<br/>}</pre>
<p>Our objects will be sent in serialized form between services. This means we also need to define serialization rules for them. We'll do this by relying on Play's macros, similar to Circe, which we used in the <kbd>http4s</kbd> example project:</p>
<pre><span>import </span>play.api.libs.json._<br/><br/><span>implicit val </span><span>dough</span>: Format[Dough] = Json.<span>format<br/></span><span>implicit val </span><span>rawCookies</span>: Format[RawCookies] = Json.<span>format<br/></span><span>implicit val </span><span>readyCookies</span>: Format[ReadyCookies] = Json.<span>format<br/></span><span>implicit val </span><span>groceries</span>: Format[Groceries] = Json.<span>format<br/></span><span>implicit val </span><span>shoppingList</span>: Format[ShoppingList] = Json.<span>format<br/></span></pre>
<p>These formats go into the same <kbd>object model</kbd> instance along the case classes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lagom's APIs</h1>
                </header>
            
            <article>
                
<p>As before, we will start with an implementation of the simplest of our workers, which just performs basic mathematical operations in order to do its work with <kbd>Cook</kbd>, which makes <kbd>RawCookies</kbd> out of <kbd>Dough</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Service API</h1>
                </header>
            
            <article>
                
<p>In order to define our Cook as a service we need to implement a special interface called a service descriptor. The service descriptor defines two aspects of a Lagom service:</p>
<ul>
<li>The service signature: How the service should be called and its return type</li>
<li>The service meta data: How the service call is mapped to the transport layer, for example to the REST call</li>
</ul>
<p>The service descriptor extends Lagom's <kbd>Service</kbd> trait and in its simplest form just needs to override the <kbd>descriptor</kbd> method. This is what it looks like in our <kbd>Cook</kbd> definition, which we place into the <kbd>cook-api</kbd> module:</p>
<pre><span>import </span>com.lightbend.lagom.scaladsl.api._<br/>import ch15.model._<br/><br/><span>trait </span>CookService <span>extends </span>Service {<br/>  <span>def </span>cook: ServiceCall[Dough, RawCookies]<br/><br/>  <span>override def </span>descriptor: Descriptor = {<br/>    <span>import </span>Service._<br/>    <span>named</span>(<span>"CookService"</span>).withCalls(<span>call</span>(cook))<br/>  }<br/>}</pre>
<p>Here we define a descriptor that connects the single call of the service, the <kbd>cook</kbd> method, to the service identifier <kbd>"CookService"</kbd> which will be needed for the routing later. For the call, we use the simplest identifier which just takes the name of the method. The configuration will result in the call mapped to the <kbd>/cook</kbd> REST URL.</p>
<p>The call itself is defined to be of the <kbd>ServiceCall[Dough, RawCookies]</kbd> type. Let's take a look at <kbd>ServiceCall</kbd> in more detail. The definition in the Lagom's source code looks like this:</p>
<pre><span>trait </span>ServiceCall[<span>Request</span>, <span>Response</span>] {<br/><span>  </span><span>def </span>invoke(request: <span>Request</span>): Future[<span>Response</span>]<br/>}</pre>
<p><kbd>ServiceCall</kbd> is typed by the request and response and can be invoked at the moment the request is issued by the client producing a response <span>asynchronously</span>.</p>
<p>The request and response types in Lagom can be strict or streamed. There are four possible combinations ranging from both sides being strict to both sides being streamed. Strict means that the request or response is fully buffered in the memory at the method boundary. The combination of both the strict request and response results in the synchronous semantics of the call. A streamed request or response is of the <kbd>Source</kbd> type, which is known to us from <a href="8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml">Chapter 13</a>,<span> </span><em><span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label">Basics of Akka Streams</span></span></em> where we looked at Akka streams. For the streaming calls, Lagom will try its best to choose the appropriate semantics. Typically, this will be WebSockets, and we will see how it works later in this chapter.</p>
<p>Our <kbd>Cook</kbd> instance is very quick so it is appropriate to define the service in synchronous terms.</p>
<p>The implementation of <kbd>Cook</kbd> goes in another module, <kbd>cook-impl</kbd>. This separation is essential in order to give microservices a possibility to refer to the definitions of each other without having any knowledge about implementation details.</p>
<p>The implementation is somewhat more involving, but not because of the service definition itself. The code should be very familiar by now:</p>
<pre><span>package </span>ch15<br/><br/><span>import </span>ch15.model._<br/><span>import </span>com.lightbend.lagom.scaladsl.api._<br/><br/><span>import </span>scala.concurrent.Future<br/><br/><span>class </span>CookServiceImpl <span>extends </span>CookService {<br/>  <span>override def </span>cook = <span>ServiceCall </span>{ dough =&gt;<br/>    Future.<span>successful</span>(<span>RawCookies</span>(makeCookies(dough.weight)))<br/>  }<br/>  <span>private val </span><span>cookieWeight </span>= <span>60<br/></span><span>  </span><span>private def </span>makeCookies(weight: Int): Int = weight / <span>cookieWeight<br/></span>}</pre>
<p>The only new part here is the definition of the service call wrapper. It is done by using the constructor defined in the <kbd>ServiceCall</kbd> companion object:</p>
<pre> def apply[Request, Response](call: Request =&gt; Future[Response]): ServiceCall[Request, Response]</pre>
<p>We provide a function that converts <kbd>Dough</kbd> (request) into <kbd>Future[RawCookies]</kbd> (response) and the constructor builds a proper <kbd>ServiceCall</kbd> from it.</p>
<p>The previously mentioned complexity is related to the fact that we also need to wire together and start our service. For those who read <a href="be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml">Chapter 14</a>, <em>Project 1 - Building Microservices with Scala, </em>the approach will look very much like a combination of both approaches we looked at there: mixing traits and providing concrete implementations for abstract members and passing dependencies as constructor parameters. But this time, we'll get the Lagom's help for this task. First, we define <kbd>LagomApplication</kbd>:</p>
<pre><span>abstract class </span>CookApplication(context: LagomApplicationContext)<br/>  <span>extends </span>LagomApplication(context) {<br/>  <span>override lazy val </span><span>lagomServer</span>: LagomServer = serverFor[CookService](<span>wire</span>[CookServiceImpl])<br/>}</pre>
<p>The application extends <kbd>LagomApplication</kbd> and needs <kbd>LagomApplicationContext</kbd>, which is just passed over via a constructor. No doubt you recognize the thin-cake pattern we used to connect together the components of our <kbd>Akka-HTTP</kbd> example. <kbd>lagomServer</kbd> is an overridden method, which is used by Lagom to provide correct wiring for the service calls. Another wiring happening here is the binding of <kbd>CookServiceImpl</kbd> to <kbd>CookService</kbd> with the help of Macwire.</p>
<div class="packt_infobox">Macwire (<a href="https://github.com/adamw/macwire">https://github.com/adamw/macwire</a>) is a dependency injection framework that implements constructor-based DI. It does so by generating calls to the class constructors with appropriate parameters found in scope. In a sense, it provides proper constructor calls behind the scenes the same way Circe or Play provide proper mapping to JSON structures. It would be very useful in projects of significant size.</div>
<p>Now our application can be used in the application loader, which does the real work of starting the service in a development or production environment:</p>
<pre><span>class </span>CookLoader <span>extends </span>LagomApplicationLoader {<br/><br/>  <span>override def </span>load(context: LagomApplicationContext) =<br/>    <span>new </span>CookApplication(context) <span>with </span>AhcWSComponents {<br/>      <span>override def </span>serviceLocator: ServiceLocator = NoServiceLocator<br/>    }<br/><br/>  <span>override def </span>loadDevMode(context: LagomApplicationContext) =<br/>    <span>new </span>CookApplication(context) <span>with </span>AhcWSComponents <span>with </span>LagomDevModeComponents<br/>}</pre>
<p><kbd>CookLoader</kbd> can be started by Lagom as needed. It overrides two <kbd>load</kbd> methods for respective environments. Please note how we extended <kbd>CookApplication</kbd> with <kbd>AhcWSComponents</kbd>. The latter is needed in order to provide <kbd>wsClient</kbd>, which in turn is required by <kbd>LagomApplication</kbd> we defined as a base class for our <kbd>CookApplication</kbd>. For the development mode, we also mix in <kbd>LagomDevModeComponents</kbd>, which gives us a development mode service locator. </p>
<p>Now we need to configure the application loader by providing a corresponding play setting in the well-known by now <kbd>application.conf</kbd>:</p>
<pre>play.application.loader = ch15.CookLoader</pre>
<p>And that is it—now we are ready to start our application. The easiest way to do this is by using Lagom's <kbd>runAll</kbd> command in the SBT console. It will try to start all of the services we've defined so far as well as the components of the underlying infrastructure—the development mode service locator, Cassandra database, and Kafka message broker:</p>
<pre><strong>sbt:bakery&gt; runAll</strong><br/><strong>[info] Starting Kafka</strong><br/><strong>[info] Starting Cassandra</strong><br/><strong>[info] Cassandra server running at 127.0.0.1:4000</strong><br/><strong>[info] Service locator is running at http://localhost:9008</strong><br/><strong>[info] Service gateway is running at http://localhost:9000</strong><br/><strong>[info] Service cook-impl listening for HTTP on localhost:57733</strong><br/><strong>[info] Service baker-impl listening for HTTP on localhost:50764</strong><br/><strong>[info] Service manager-impl listening for HTTP on localhost:63552</strong><br/><strong>[info] Service chef-impl listening for HTTP on localhost:56263</strong><br/><strong>[info] Service boy-impl listening for HTTP on localhost:64127</strong></pre>
<p>The logs witness that the logging is working alongside other infrastructure components.</p>
<div class="packt_infobox">At this stage, the log will contain a lots of stacktraces (not shown here) because of missing loader configurations for all but the <kbd>boy-impl</kbd> modules. We will fix this during this chapter, as we will implement the services one after another.</div>
<p>We can also see that our service is running on port <kbd>57733</kbd> and can try to communicate with it:</p>
<pre class="p1"><strong>slasch@void:~$ curl -X POST http://localhost:57733/cook -d '{ "weight": 100 }'</strong><br/><strong>{"count":1}</strong></pre>
<p>Congratulations, we just talked to our first <span>Lagom </span>microservice!</p>
<div class="packt_tip packt_infobox">We communicated to the service directly without using a service registry and service locator. It is safe to put the port number into the code listing for reference because despite their random appearance, ports are assigned to the services by Lagom in a deterministic manner (basically by using a hash of a project name). Hence, the services are assigned the same port numbers (<span>with respect to port conflicts) </span>in any environment.</div>
<p>Now we can move on to the implementation of the <kbd>Boy</kbd> service, which is similarly simple in its functionality. It is expected to forward incoming shopping lists to external services and forward groceries it will get in return to the initial caller.</p>
<p>The definition of the service should look familiar, except that we're using the <kbd>namedCall</kbd> method to map the <kbd>shop</kbd> call to the <kbd>go-shopping</kbd> name in order to have a nicer URL:</p>
<pre><span>trait </span>BoyService <span>extends </span>Service {<br/>  def shop: ServiceCall[ShoppingList, Groceries]<br/><br/>  <span>override def </span>descriptor: Descriptor =<br/>    <span>named</span>(<span>"BoyService"</span>).withCalls(<span>namedCall</span>(<span>"go-shopping"</span>, shop))<br/>}</pre>
<p>The implementation is a bit more complex then the <kbd>Cook</kbd> service because the <kbd>Boy</kbd> service needs to call an external HTTP service to make an order. The following template should not raise any questions:</p>
<pre><span>class </span>BoyServiceImpl <span>extends </span>BoyService {<br/>  <span>override def </span>shop = <span>ServiceCall</span>(callExternalApi)<br/>  <span>private val callExternalApi</span>: ShoppingList =&gt; Future[Groceries] = <span>???<br/></span>}</pre>
<p>How do we call the external API though? We could, of course, use an HTTP client library and do the call the same way as before, issuing the HTTP request, getting the <span>HTTP </span>response, and handling marshalling and unmarshalling. But this would lower the abstraction level of our solution and hard-wire the implementation to the external service's location.</p>
<p>We will do the following instead. First, we will register our externally running service with the service locator by adding the service's URL to <kbd>build.sbt</kbd>:</p>
<pre><span>lagomUnmanagedServices </span>in ThisBuild := <span>Map</span>(<span>"GroceryShop" </span>-&gt; <span>"http://localhost:8080"</span>)</pre>
<p>Then, we will define an API for the grocery store as if we were about to implement it:</p>
<pre><span>trait </span>ShopService <span>extends </span>Service {<br/>  <span>def </span>order: ServiceCall[Order, Purchase]<br/>  <span>override def </span>descriptor: Descriptor = {<br/>    <span>named</span>(<span>"GroceryShop"</span>).withCalls(<span>restCall</span>(Method.<span>POST</span>, <span>"/purchase"</span>, order))<br/>  }<br/>}</pre>
<p>Here, we specify a service descriptor for the service with the same name as we just registered with the service locator. The API call is registered with a <kbd>restCall</kbd> descriptor to be sure that both the HTTP method and the path are correctly mapped to the existing service. We also need to wrap and unwrap <kbd>ShoppingList</kbd> and <kbd>Groceries</kbd> into proper <kbd>Order</kbd> and <kbd>Purchase</kbd> as expected with the existing shop service. Luckily, the <span>JSON representation of our </span>case classes is the same as for <kbd>Map[String, Int]</kbd> so we can safely just reuse the existing model along with serializers and add the wrappers on top of it:</p>
<pre><span>object </span>ShopService {<br/>  <span>final case class </span>Order(order: ShoppingList)<br/>  <span>final case class </span>Purchase(order: Groceries)<br/>  <span>implicit val </span><span>purchase</span>: Format[Purchase] = Json.<span>format<br/></span><span>  </span><span>implicit val </span><span>order</span>: Format[Order] = Json.<span>format<br/></span>}</pre>
<p>We don't need to provide an implementation for <kbd>ShopService</kbd>; we just want Lagom to apply all existing machinery to represent an existing <kbd>REST</kbd> service as if it were one made with Lagom.</p>
<p>The shop service is ready to use with <kbd>Boy</kbd> now:</p>
<pre><span>class </span>BoyServiceImpl(shopService: ShopService)                    <br/>               (<span>implicit </span>ec: ExecutionContext) <span>extends </span>BoyService {<br/>  <span>override def </span>shop: ServiceCall[ShoppingList, Groceries] = <span>ServiceCall</span>(<span>callExtApi</span>)<br/><br/>  <span>private val </span><span>callExtApi</span>: ShoppingList =&gt; Future[Groceries] = list =&gt;<br/>    shopService.order.invoke(<span>Order</span>(list)).map(_.order).recover {<br/>      <span>case </span>_ =&gt; <span>Groceries</span>(<span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>)<br/>    }<br/>}</pre>
<p>Note that we provide the <kbd>shopService</kbd> client and an execution context. The latter will be used to transform the future result we'll get from the service invocation. The <kbd>callExtApi</kbd> function shows how this is done: we refer to the <kbd>order</kbd> method from the <kbd>ShopService</kbd> definition, which returns <kbd>ServiceCall</kbd>, which we happily invoke with <kbd>Order</kbd> we created from the shopping list. The result is <kbd>Future[Purchase]</kbd> so we unwrap an order out of it. Finally, we define that, if anything wrong happens with the external service, for example, the service is not available or there is insufficient inventory to fulfill the order, the Boy should just return back with empty hands.</p>
<p>Now <kbd>Boy</kbd> is able to communicate with <kbd>ShopService</kbd> we built in <a href="be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml">Chapter 14</a>, <em>Project 1 - Building Microservices with Scala</em> using <kbd>Akka-HTTP</kbd>.</p>
<div class="packt_infobox">The shop service must be running and must have sufficient inventory in order for further examples from this chapter to work properly.</div>
<p>Our <kbd>Boy</kbd> and <kbd>Cook</kbd> services are stateless. The <kbd>Cook</kbd> service just returns the result immediately so there is no point having any state in it. <kbd>Boy</kbd> is unsophisticated and just comes back for instructions if anything unexpected happens. But <kbd>Chef</kbd> and <kbd>Baker</kbd> are different because they are supposed to represent processes taking some time. For this reason we can't implement them in a synchronous manner.</p>
<p>The Baker has <kbd>m:n</kbd> semantics in the sense that it can respond with zero, one, or many response messages to a single incoming message. Let's use Lagom's possibility to define asynchronous services to implement it. This will allow us to reuse the flow definition for <kbd>Baker</kbd> we constructed in <a href="8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml">Chapter 13</a>, <em>Basics of Akka Streams</em>.</p>
<p>We first need to define the service as we already did, but this time with asynchronous semantics:</p>
<pre><span>import </span>akka.NotUsed<br/><span>import </span>akka.stream.scaladsl.Source<br/><br/><span>trait </span>BakerService <span>extends </span>Service {<br/>  <span>def </span>bake: ServiceCall[Source[RawCookies, NotUsed],<br/>                        Source[ReadyCookies, NotUsed]]<br/><br/>  <span>override def </span>descriptor: Descriptor = <span>named</span>(<span>"BakerService"</span>).withCalls(<span>call</span>(bake))<br/>}</pre>
<p>Here, we define <kbd>BakerService</kbd> to have a request of the <kbd>Source[RawCookies, NotUsed]</kbd> type and the response of the <kbd>Future[Source[ReadyCookies, NotUsed]]</kbd><span> type</span>. This should allow us to just write <kbd>RawCookies</kbd> at the moment they are available and get <kbd>ReadyCookies</kbd> back after they are baked.</p>
<p>The implementation is straightforward because it is literally wrapping the flow taken from <a href="8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml">Chapter 13</a><span>, </span><em>Basics of Akka Streams</em>:</p>
<pre><span>import </span>play.api.Logger<br/><br/><span>class </span>BakerServiceImpl <span>extends </span>BakerService {<br/><br/>  <span>private val </span><span>logger </span>= <span>Logger</span>(<span>"Baker"</span>)<br/><br/>  <span>override def </span>bake: ServiceCall[Source[RawCookies, NotUsed],<br/>                     Source[ReadyCookies, NotUsed]] = <br/><span>      ServiceCall </span>{ dough =&gt;<br/>         <span>logger</span>.info(<span>s"Baking: </span><span>$</span>dough<span>"</span>)<br/>         Future.<span>successful</span>(dough.via(<span>bakerFlow</span>))<br/>      }<br/><br/>  <span>private val </span><span>bakerFlow</span>: Flow[RawCookies, ReadyCookies, NotUsed] =<br/>    Baker.<span>bakeFlow</span>.join(Oven.<span>bakeFlow</span>)<br/>}</pre>
<p>We reuse the definition of the <kbd>Baker</kbd> and <kbd>Oven</kbd> flows and return the combined flow as the result of the call. In this snippet, we also demonstrate the use of <kbd>Logger</kbd> available from the underlying Play framework.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Persistence API</h1>
                </header>
            
            <article>
                
<p><kbd>Chef</kbd> in our scenario takes some time to complete the mix process. Because of this, we would like to store the work in progress so that, in case the service is restarted, it does not get lost and the process just continues from where it was interrupted after recovery.</p>
<p>We will use persistence facilities provided by the framework in order to implement this. The recommended way to persist data in Lagom is by utilizing an event sourcing approach, which we already used to implement an example project in <a href="be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml">Chapter 14</a>,<em> Project 1 - Building Microservices with Scala</em>. Lagom automates data schema creation with Cassandra and also provides a Cassandra instance for development purposes. Therefore, we can start directly with the definition of the data model. As in the previous chapter, we need to provide a set of commands and events and also have an internal representation of the state. The following few snippets show one of the possible ways to represent these parts. As this model is just an implementation detail of <kbd>Chef</kbd>, it goes into the <kbd>chef-impl</kbd> module.</p>
<p>First, we need to have a bunch of imports in scope:</p>
<pre><span>import ch15.model._<br/>import java.util.UUID<br/>import </span>akka.Done<br/><span>import </span>com.lightbend.lagom.scaladsl.persistence._<br/><span>import </span>PersistentEntity.ReplyType<br/><span>import </span>com.lightbend.lagom.scaladsl.playjson.JsonSerializer<br/>import play.api.libs.json._</pre>
<p>Having these, we can define our commands:</p>
<pre><span>sealed trait </span>ChefCommand<br/><span>final case class </span>MixCommand(groceries: Groceries) <span>extends </span>ChefCommand <span>with </span>ReplyType[Done]<br/><span>final case class </span>DoneCommand(id: UUID) <span>extends </span>ChefCommand <span>with </span>ReplyType[Done]</pre>
<p><kbd>MixCommand</kbd> represents an incoming request to mix some groceries. Commands in Lagom define the expected response type and we are using Akka's <kbd>Done</kbd> for the response. The reason for this is that we'll always accept <kbd>MixCommand</kbd> (because there is no reason not to), but at the moment the command is accepted it is not possible to predict which effect it will have.</p>
<p><kbd>DoneCommand</kbd> represents a state transition from "mixing in progress" to "mixing done". It will be an internal command sent by <kbd>Chef</kbd> to itself. Technically we don't need a response type here but we have to use <kbd>Done</kbd> again in order to make the compiler happy. <kbd>id</kbd> represents the unique identifier of the mixing job. Where does it come from? It is generated at the moment we're creating an event from the command:</p>
<pre><span>sealed trait </span>ChefEvent<br/><span>final case class </span>Mixing(id: UUID, groceries: Groceries) <span>extends </span>ChefEvent<br/><span>final case class </span>MixingDone(id: UUID, dough: Dough) <span>extends <br/></span>  ChefEvent <span>with </span>AggregateEvent[MixingDone] {<br/>    <span>override def </span>aggregateTag: AggregateEventTag[MixingDone] = ChefModel.<span>EventTag<br/></span>  }</pre>
<p>The <kbd>Mixing</kbd> event is created in response to the <kbd>MixCommand</kbd> and the <kbd>MixingDone</kbd> event—in response to the <kbd>DoneCommand</kbd>. Both events relate to each other via the <kbd>id</kbd> property. At the recovery time both events with same <kbd>id</kbd> will annihilate: presence of both events means that in the past a mixing job was started and then finished. In contrast, if there is only single event we can conclude that the job was not finished. Having unbalanced <kbd>Mixing</kbd> events after the recovery will mean we need to restart the mixing processes for them. Having unbalanced <kbd>MixingDone</kbd> events can only mean programming errors.</p>
<p>To provide this functionality, we'll define the state as follows:</p>
<pre>sealed trait ChefState {<br/>  def batches: List[Mixing]<br/>}<br/>final case class MixingState(batches: List[Mixing]) extends ChefState</pre>
<p>We'll take a look at how it is used in the service implementation in a moment, after discussing the final bit of the model definition:</p>
<pre><span>object </span>ChefModel {<br/>  <span>import </span>play.api.libs.json._<br/>  <span>implicit val </span><span>mixingFormat</span> = Json.<span>format</span>[Mixing]<br/><br/>  <span>val </span><span>serializers </span>= <span>List</span>(<br/>    <span>JsonSerializer</span>(<span>mixingFormat</span>),<br/>    <span>JsonSerializer</span>(Json.<span>format</span>[MixingDone]),<br/>    <span>JsonSerializer</span>(Json.<span>format</span>[MixingState]))<br/><br/>  val EventTag: AggregateEventTag[MixingDone] = AggregateEventTag[MixingDone]("MixingDone")<br/>}</pre>
<p>Here, we provide serializers for our events and commands the same way we did in the previous chapter. The Lagom's recommended serialization format is JSON so we're utilizing the same approach we already used for the shared model definition.</p>
<p>We also define <kbd>EventTag</kbd> which we'll need to implement the read-side of the event journal in order to notify <kbd>Manager</kbd> about the completed mixing jobs.</p>
<p>The final piece of configuration we need is a definition of Cassandra's key space for <kbd>Chef</kbd>. This is done in the usual way in <kbd>application.conf</kbd>:</p>
<pre>user.cassandra.keyspace = chefprogress<br/><br/>cassandra-journal.keyspace = <span>$</span>{<span>user</span>.<span>cassandra</span>.<span>keyspace</span>}<br/>cassandra-snapshot-store.keyspace = <span>$</span>{<span>user</span>.<span>cassandra</span>.<span>keyspace</span>}<br/>lagom.persistence.read-side.cassandra.keyspace =<br/> <span>$</span>{<span>user</span>.<span>cassandra</span>.<span>keyspace</span>}</pre>
<p>The definition of the service reflects the fact that the communication is synchronous on the request side and message based on the response side:</p>
<pre><span>trait </span>ChefService <span>extends </span>Service {<br/>  <span>def </span>mix: ServiceCall[Groceries, Done]<br/><br/>  <span>def </span>resultsTopic: Topic[Dough]<br/><br/>  <span>override def </span>descriptor: Descriptor = {<br/>    <span>named</span>(<span>"ChefService"</span>)<br/>      .withCalls(<span>call</span>(mix))<br/>      .withTopics(<span>topic</span>(ChefService.<span>ResultsTopic</span>, resultsTopic))<br/>      .withAutoAcl(<span>true</span>)<br/>  }<br/>}<br/><span>object </span>ChefService {<br/>  <span>val </span><span>ResultsTopic </span>= <span>"MixedResults"<br/></span>}</pre>
<p>The <kbd>mix</kbd> call accepts <kbd>Groceries</kbd> and returns <kbd>Done</kbd> (compare this with the return type of the commands we've just defined). The implementation of the service is also reasonably concise because it delegates state management to <kbd>ChefPersistentEntity</kbd>:</p>
<pre><span>class </span>ChefServiceImpl(persistentEntities: PersistentEntityRegistry,<br/>                      as: ActorSystem) <span>extends </span>ChefService {<br/><br/>  <span>private lazy val </span><span>entity </span>= <span>wire</span>[ChefPersistentEntity]<br/>  persistentEntities.register(<span>entity</span>)<br/><br/>  <span>override def </span>mix: ServiceCall[Groceries, Done] = <span>ServiceCall </span>{ groceries =&gt;<br/>      <span>val </span>ref = persistentEntities.refFor[ChefPersistentEntity](<span>"Chef"</span>)<br/>      ref.ask(<span>MixCommand</span>(groceries))<br/>  }<br/><br/>  <span>override def </span>resultsTopic: Topic[Dough] = ???<br/>}</pre>
<p>First, we need to pass two dependencies, <kbd>PersistentEntityRegistry</kbd> and <kbd>ActorSystem</kbd>. We pass the actor system, <kbd>as</kbd>, to <kbd>ChefPersistentEntity</kbd> at the moment of wiring and use the persistent entity registry to register our, well, persistent entity as required by Lagom. The <kbd>mix</kbd> call then just uses the registry to look up a reference to the entity and uses an <kbd>ask</kbd> pattern to send it an incoming command and get a response the same way we did with actors.</p>
<p>We're omitting the implementation of <kbd>resultsTopic</kbd> for now to focus on the persistence aspect of the service.</p>
<p><kbd>ChefPersistentEntity</kbd> is a bit longer, so let's take a look at it in smaller chunks. We start with overriding Lagom's <kbd>PersistentEntity</kbd>:</p>
<pre><span>final class </span>ChefPersistentEntity(<br/>    persistentEntities: PersistentEntityRegistry, as: ActorSystem<br/>  ) <span>extends </span>PersistentEntity { ... }</pre>
<p>The persistent entity can be accessed from anywhere in the cluster. Because of this, using persistence<span> in Lagom </span>automatically means using clustering (which is definitely a good idea). The persistent entity needs to override a few fields:</p>
<pre><span>override type </span><span>Command </span>= ChefCommand<br/><span>override type </span><span>Event </span>= ChefEvent<br/><span>override type </span><span>State </span>= ChefState<br/><span>override def </span>initialState: ChefState = <span>MixingState</span>(<span>Nil</span>)</pre>
<p>The <kbd>Command</kbd>, <kbd>Event</kbd>, and <kbd>State</kbd> types refer to those we defined earlier. We also define an initial state to be empty <kbd>MixingState</kbd>.</p>
<p>For simplicity, we won't implement the mixing behavior in its full complexity as we already did this three times in previous chapters. Instead, we'll mock it:</p>
<pre><span>private def </span>dough(g: Groceries) = {<br/>  <span>import </span>g._<br/>  <span>Dough</span>(eggs * <span>50 </span>+ flour + sugar + chocolate)<br/>}</pre>
<p>Now we can finally define the behavior of our entity which will accept commands, persist events, and modify states. Again, this is done similarly to how we did in the previous chapter, but Lagom adds its five cents by providing an <kbd>Actions</kbd> constructor, which allows us to define command and event handlers in a builder-like manner:</p>
<pre><span>Actions</span>()<br/>  .onCommand[MixCommand, Done] {<br/>    <span>case </span>(<span>MixCommand</span>(groceries), ctx, _) <span>if </span>groceries.eggs &lt;= <span>0 </span>=&gt;<br/>      ctx.invalidCommand(<span>s"Need at least one egg but got: </span><span>$</span>groceries<span>"</span>)<br/>      ctx.done<br/><br/>    <span>case </span>(<span>MixCommand</span>(groceries), ctx, _) =&gt;<br/>      <span>val </span>id = UUID.<span>randomUUID</span>()<br/>      ctx.thenPersist(<span>Mixing</span>(id, groceries)) { evt =&gt;<br/>        as.scheduler.scheduleOnce(<span>mixingTime</span>)(<br/>          <span>thisEntity</span>.ask(<span>DoneCommand</span>(id)))<br/>        ctx.reply(Done)<br/>      }<br/>  }</pre>
<p>The command handler must return a <kbd>Persist</kbd> directive, which describes what should be persisted with an optional callback for side-effecting code, which should be executed after an event was successfully written to the storage.</p>
<p>In the preceding snippet, we're handling two commands. <kbd>MixCommand</kbd> with a negative amount of <kbd>Dough</kbd> is marked as invalid (which is modelled by sending <kbd>InvalidCommandException</kbd> to the caller), and calling <kbd>ctx.done</kbd> returns <kbd>PersistNone</kbd> with the meaning that nothing needs to be persisted.</p>
<p>The second handler is for valid commands. With it, we first generate random <kbd>id</kbd> for the event we're going to persist, then we construct the event and return <kbd>PersistOne</kbd> with the event and a callback. The callback schedules send a command to the persistent entity itself meaning the mixing is done and sends <kbd>Done</kbd> back to the caller.</p>
<p>In order to be able to dereference an entity, we need to use a registry as we did in the service earlier:</p>
<pre>lazy val thisEntity = persistentEntities.refFor[ChefPersistentEntity](this.entityId)</pre>
<p>Please note that our persistence callbacks are only executing side effects and not modifying the state. For the state modifications, another constructor, <kbd>onEvent</kbd>, should be used. This separation is done in order to gain the possibility to reconstruct the state during the recovery as many times as required, but to have side effects executed only once after the actual event had happened and was persisted:</p>
<pre><span>Actions</span>()<br/>  .onCommand[MixCommand, Done] { ... }<br/>  .onEvent {<br/>    <span>case </span>(m: Mixing, state) =&gt;<br/>      <span>MixingState</span>(state.batches :+ m)<br/><br/>    <span>case </span>(<span>MixingDone</span>(id, _), state) =&gt;<br/>      <span>MixingState</span>(state.batches.filterNot(_.id == id))<br/>  }</pre>
<p>Here, we've just put new mixing jobs into the queue and we remove them from the queue after they are complete. Now we have to define how to react to the <kbd>DoneCommand</kbd> our entity sends to itself:</p>
<pre><span>Actions</span>()<br/>  .onCommand[MixCommand, Done] { ... }<br/>  .onEvent { ... }<br/>  .onCommand[DoneCommand, Done] {<br/>    <span>case </span>(<span>DoneCommand</span>(id), ctx, state) =&gt;<br/>      state.batches<br/>        .find(_.id == id)<br/>        .map { g =&gt;<br/>          ctx.thenPersist(<span>MixingDone</span>(id, dough(g.groceries))) { <br/>             _ =&gt; ctx.reply(Done)<br/>          }<br/>        }<br/>        .getOrElse(ctx.done)<br/>  }<br/><br/></pre>
<p>We're looking in the current state for <kbd>MixingCommand</kbd>, which we created before by using <kbd>id</kbd> as an equality criteria, just to have a reference to <kbd>groceries</kbd>. The groceries will be required later; at the moment we will read the event on the read side. Then we construct and persist an event and return <kbd>Done</kbd> to make the compiler happy. You probably noticed that we haven't defined any side-effects for the <kbd>MixingDone</kbd> event. We don't need to because these events will be streamed to <kbd>resultsTopic</kbd> we specified earlier.</p>
<p>To conclude the implementation of <kbd>Chef</kbd>, we need to wire all components together. <kbd>ChefLoader</kbd> is not any different from other loaders we've defined so far. In contrast, <kbd>ChefApplication</kbd> deviates a bit:</p>
<pre><span>abstract class </span>ChefApplication(context: LagomApplicationContext)<br/>  <span>extends </span>LagomApplication(context) <span>with </span>CassandraPersistenceComponents <span>with </span>LagomKafkaComponents {<br/>  <span>override lazy val </span><span>lagomServer</span>: LagomServer = serverFor[ChefService](<span>wire</span>[ChefServiceImpl])<br/>  <span>override lazy val </span><span>jsonSerializerRegistry </span>= <span>new </span>JsonSerializerRegistry {<br/>      <span>override def </span>serializers = ChefModel.<span>serializers<br/></span><span>  </span>}<br/>}</pre>
<p>We need to provide an implementation of <kbd>JsonSerializerRegistry</kbd> for Lagom to be able to pick up our serializers. Our application also needs to extend <kbd>CassandraPersistenceComponents</kbd> as we're using persistence and also <kbd>LagomKafkaComponents</kbd>—by publishing our events we're effectively using messaging as well. Unfortunately, currently Lagom can't check at compile time whether messaging is used by the application, so it is easy to forget to extend Kafka components, which will lead to runtime errors at the moment the application is started. </p>
<p class="mce-root">We have defined the persistent side of the <kbd>Chef</kbd> service' <kbd>MixingDone</kbd> events, so let's turn to the messaging side.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Message Broker API</h1>
                </header>
            
            <article>
                
<p class="mce-root">When we implemented persistence in <kbd>Chef</kbd> we skipped the definition of <kbd>resultsTopic</kbd> we provided in the API definition. Let's take a look at the definition of <kbd><span>resultsTopic</span></kbd> now:</p>
<pre><span>class </span>ChefServiceImpl(...) <span>extends </span>ChefService {<br/><br/>  ...<br/><br/>  <span>override def </span>resultsTopic: Topic[Dough] =<br/>    TopicProducer.<span>singleStreamWithOffset </span>{ fromOffset =&gt;<br/>      persistentEntities<br/>        .eventStream(ChefModel.<span>EventTag</span>, fromOffset)<br/>        .map { ev =&gt; (convertEvent(ev), ev.offset) }<br/>    }<br/><br/>  <span>private def </span>convertEvent(chefEvent: EventStreamElement[ChefEvent]): Dough = {<br/>    chefEvent.event <span>match </span>{<br/>      <span>case </span><span>MixingDone</span>(_, dough) =&gt; dough<br/>    }<br/>  }<br/>}</pre>
<p class="mce-root">We're using the <kbd>singleStreamWithOffset</kbd> constructor of the <kbd>TopicProducer</kbd> factory to construct a topic to which all of the events marked with <kbd>ChefModel.EventTag</kbd> will get published. Before publishing happens, we convert <kbd>ChefEvent</kbd> into <kbd>Dough</kbd> as expected by the downstream services. This is done in the <kbd>convertEvent</kbd> method.</p>
<p>The receiving side is <kbd>Manager</kbd>. Lagom provides all of the infrastructure so that the consumption of the events boils down to the following one-liner:</p>
<pre><span>val </span><span>sub</span>: Future[Done] = chefService.resultsTopic.subscribe.atLeastOnce(cook<span>ChefFlow</span>)</pre>
<p>Here, we're using <kbd>chefService</kbd> <kbd>resultsTopic</kbd> to subscribe to the events. We provide <kbd>cookChefFlow</kbd> as a callback which will be called at least once for each of the published events. The <kbd>atLeastOnce</kbd> method expects <kbd>akka.stream.scaladsl.Flow[Payload, Done, _]</kbd> as a parameter with Payload referring to the type of the message. We'll define our flow of the <span><kbd>Flow[Dough, Done, _]</kbd> type in a moment.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Service API from the client side</h1>
                </header>
            
            <article>
                
<p><span>We have defined all of our worker services so let's take a look at <kbd>Manager</kbd> and how it drives the baking process by calling other services in the right order. Let's start with the service definition:</span></p>
<pre><span>trait </span>ManagerService <span>extends </span>Service {<br/>  <span>def </span>bake(count: Int): ServiceCall[NotUsed, Done]<br/>  <span>def </span>sell(count: Int): ServiceCall[NotUsed, Int]<br/>  <span>def </span>report: ServiceCall[NotUsed, Int]<br/><br/>  <span>override def </span>descriptor: Descriptor = {<br/>    <span>import </span>Service._<br/>    <span>named</span>(<span>"Bakery"</span>).withCalls(<br/>      <span>restCall</span>(Method.<span>POST</span>, <span>"/bake/:count"</span>, bake _),<br/>      <span>restCall</span>(Method.<span>POST</span>, <span>"/sell?count"</span>, sell _),<br/>      <span>pathCall</span>(<span>"/report"</span>, report)<br/>    )<br/>  }<br/>}</pre>
<p>We define three methods:</p>
<ul>
<li><kbd>bake</kbd>, for initiating a baking process for a number of cookies</li>
<li><kbd>sell</kbd>, for selling cookies if there is enough stock</li>
<li><kbd>report</kbd>, for checking the number of cookies currently in stock</li>
</ul>
<p>We map them to two rest calls and a path call. We're using one path and one query parameter just to demonstrate the possibilities offered by the Lagom's descriptor DSL.</p>
<p>Let's get on with the service implementation:</p>
<pre><span>class </span>ManagerServiceImpl(boyService: BoyService,<br/>                         chefService: ChefService,<br/>                         cookService: CookService,<br/>                         bakerService: BakerService,<br/>                         as: ActorSystem)<br/>    <span>extends </span>ManagerService {<br/><br/>  <span>private val </span><span>count</span>: AtomicInteger = <span>new </span>AtomicInteger(<span>0</span>)<br/><br/>  <span>private val </span><span>logger </span>= <span>Logger</span>(<span>"Manager"</span>)<br/><br/>  ...<br/>}</pre>
<p>We have to provide all of the services we're about to call as constructor parameters so that we can wire them together later in the definition of the application. We also define <kbd>logger</kbd> and <kbd>count</kbd>, which will hold the current number of cookies. In a real project, we would implement an event-sourced approach to the internal state of the Manager, but here we're just keeping it in memory for simplicity.</p>
<p>The <kbd>report</kbd> and <kbd>sell</kbd> methods are implemented by checking the internal state and modifying it if appropriate:</p>
<pre><span>override def </span>sell(cnt: Int): ServiceCall[NotUsed, Int] =<br/>  <span>ServiceCall </span>{ _ =&gt;<br/>   <span>if </span>(cnt &gt; <span>count</span>.get()) {<br/>     Future.<span>failed</span>(<span>new </span>IllegalStateException(<span>s"Only </span><span>$</span><span>count</span><span> cookies on sale"</span>))<br/>  } <span>else </span>{<br/>    <span>count</span>.addAndGet(-<span>1 </span>* cnt)<br/>    Future.<span>successful</span>(cnt)<br/>  }<br/>}<br/><br/><span>override def </span>report: ServiceCall[NotUsed, Int] = <span>ServiceCall </span>{ _ =&gt;<br/>  Future.<span>successful</span>(<span>count</span>.get())<br/>}</pre>
<p>The <kbd>bake</kbd> method is implemented by actually calling other services:</p>
<pre><span>override def </span>bake(count: Int): ServiceCall[NotUsed, Done] = <span>ServiceCall </span>{ _ =&gt;<br/>  <span>val </span>sl = shoppingList(count)<br/>  <span>logger</span>.info(<span>s"Shopping list: </span><span>$</span>sl<span>"</span>)<br/>  <span>for </span>{<br/>    groceries &lt;- boyService.shop.invoke(sl)<br/>    done &lt;- chefService.mix.invoke(groceries)<br/>  } <span>yield </span>{<br/>    <span>logger</span>.info(<span>s"Sent </span><span>$</span>groceries<span> to Chef"</span>)<br/>    done<br/>  }<br/>}</pre>
<p>Here, we generate a shopping list based on the number of cookies we requested to be baked. Then, in a for-comprehension, we're calling <kbd>boyService</kbd> and <kbd>chefService</kbd>. With the call of the chef service, we need to return because it is going to take some time for the chef to make the dough.</p>
<p>We already defined the listener for <kbd>Dough</kbd>, which is sent back by <kbd>Chef</kbd> via the message topic, so we just need to define the flow to handle the incoming messages:</p>
<pre><span>private lazy val </span><span>chefFlow</span>: Flow[Dough, Done, NotUsed] = <span>Flow</span>[Dough]<br/>  .map { dough: Dough =&gt;<br/>    <span>val </span>fut = cookService.cook.invoke(dough)<br/>    <span>val </span>src = Source.<span>fromFuture</span>(fut)<br/>    <span>val </span>ready: Future[Source[ReadyCookies, NotUsed]] =<br/>      bakerService.bake.invoke(src)<br/><span>    </span>Source.<span>fromFutureSource</span>(ready)<br/>  }<br/>  .flatMapConcat(<span>identity</span>)<br/>  .map(count.addAndGet(cookies.count))<br/>  .map(_ =&gt; Done)</pre>
<p>Here again, we're representing the possible one-liner as a couple of statements so that it is easy to spot what is going on: we define <kbd>Flow</kbd>, which transforms dough into <kbd>Future[RawCookies]</kbd> by calling <kbd>cookService</kbd>. <kbd>bakerService</kbd> is a streaming one so it expects <kbd>Source[RawCookies, _]</kbd> and we create it from <kbd>Future</kbd>. The invocation of <kbd>bakerService</kbd> returns <kbd>Future[Source[Ready<span>Cookies, _</span>]]</kbd> so we convert <kbd>Future</kbd> into <kbd>Source</kbd> again and then flatten <kbd>Source[Source[<span>Ready</span><span>Cookies, _</span>]]</kbd> with <kbd>flatMapConcat</kbd>. Finally, we change the service's internal state and return <kbd>Done</kbd> as expected by the subscription method.</p>
<p>It's time to build <kbd>ManagerApplication</kbd> together! We need to provide references to all of the services we've used in <kbd>ManagerImpl</kbd>. Of course, we'll use <kbd>serviceClient</kbd> for this:</p>
<pre><span>abstract class </span>ManagerApplication(context: LagomApplicationContext)<br/>    <span>extends </span>LagomApplication(context) <span>with </span>LagomKafkaClientComponents {<br/>  <span>lazy val </span><span>boyService</span>: BoyService = serviceClient.<span>implement</span>[BoyService]<br/>  <span>lazy val </span><span>chefService</span>: ChefService = serviceClient.<span>implement</span>[ChefService]<br/>  <span>lazy val </span><span>cookService</span>: CookService = serviceClient.<span>implement</span>[CookService]<br/>  <span>lazy val </span><span>bakerService</span>: BakerService = serviceClient.<span>implement</span>[BakerService]<br/>  <span>override lazy val </span><span>lagomServer</span>: LagomServer =<br/>    serverFor[ManagerService](<span>wire</span>[ManagerServiceImpl])<br/>}</pre>
<p><kbd>ManagerServiceImpl</kbd> itself is constructed using the Macwire as before.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Now, we have all of our services built together and can run the project as a whole using the <kbd>runAll</kbd> command as before. We also need to have an <kbd>Akka-HTTP</kbd> example from the previous chapter running and have enough inventory so that the boy can get some groceries from it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0ef0fdde-c76b-4aca-bef1-fc8d76476ad8.png" width="2550" height="818"/></p>
<p class="mce-root"/>
<p>The previous screenshot shows two Terminal windows: on the right the Akka HTTP shop from Chapter 14 is running and on the left the <kbd>runAll</kbd> command is ready to be executed. The <kbd>runAll</kbd> command takes some time to start all of the subsystems and produces a lot of output in the console.</p>
<div class="packt_infobox">At the moment of this writing the processing pipeline stopped just before returning baked cookies to the manager. We reported this issue as a Lagom bug (<a href="https://github.com/lagom/lagom/issues/1616">https://github.com/lagom/lagom/issues/1616</a>) but unfortunately got no feedback from Lagom team yet. We left the example as it is with the hope that the issue will be fixed in upcoming version of the framework. In the unlikely case if this is not a but we will update the example immediately after getting corresponding reaction to the bug report.</div>
<p><span>After everything settles down</span>, we can call our <kbd>Manager</kbd> service with an <kbd>http</kbd> client from another window:</p>
<pre>curl -X "POST" "http://localhost:58866/bake/10"</pre>
<p>This should produce output similar to the following in the Lagom Terminal:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a345a2a0-7eb0-4bce-9f76-fce0df3f02e3.png" width="1262" height="166"/></p>
<p>Looks like it is time to enjoy the cookies! Well, not quite yet!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>As before, we would like to conclude our journey by testing the implementation we came up with. Luckily, Lightbend follows the same approach to testing as it did with other libraries. There is a test kit that allows us to test services and persistent entities easily. We'll demonstrate how to test services in this section and leave testing persistent entities as an exercise for the reader.</p>
<p>It makes sense to start by testing the simplest service we defined—<kbd>CookService</kbd>. Here is a test for it, placed in the test scope of the <kbd>cook-impl</kbd> module:</p>
<pre><span>import </span>ch15.model.Dough<br/><span>import </span>com.lightbend.lagom.scaladsl.server.LocalServiceLocator<br/><span>import </span>com.lightbend.lagom.scaladsl.testkit.ServiceTest<br/><span>import </span>org.scalatest.{AsyncWordSpec, Matchers}<br/><span>import </span>play.api.libs.ws.ahc.AhcWSComponents<br/><br/><span>class </span>CookServiceSpec <span>extends </span>AsyncWordSpec <span>with </span>Matchers {<br/><br/>  <span>"The CookService" </span>should {<br/>    <span>"make cookies from Dough" </span>in ServiceTest.<span>withServer</span>(ServiceTest.<span>defaultSetup</span>) { ctx =&gt;<br/>      <span>new </span>CookApplication(ctx) <span>with </span>LocalServiceLocator <span>with </span>AhcWSComponents<br/>    } { server =&gt;<br/>      <span>val </span>client = server.serviceClient.implement[CookService]<br/>      client.cook.invoke(<span>Dough</span>(<span>200</span>)).map { cookies =&gt;<br/>        cookies.count should ===(<span>3</span>)<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p>Lagom provides a <kbd>ServiceTest</kbd> object whose purpose is to support testing of a single service. Its <kbd>withServer</kbd> constructor takes two parameters: an application constructor and a block of test code. It looks similar to the approach we used while testing the <kbd>Akka-HTTP</kbd> implementation in the previous chapter, but it behaves differently. <kbd>ServiceTest</kbd> actually starts the real server with the service. In our example, we mix it with <kbd>LocalServiceLocator</kbd>, so that we can get a service implementation from it in the test block. Here, we can invoke the service and verify that it works as expected. </p>
<p>Our specification extends <kbd>AsyncWordSpec</kbd>, which gives us the freedom to formulate our expectations by mapping over <kbd>Future</kbd> returned by the service.</p>
<p>Testing a synchronous service such as <kbd>CookService</kbd> is very easy. But how about testing the asynchronous (streaming) service? We've built an example using <kbd>BakerService</kbd>. Here is one possible implementation of the unit test for it:</p>
<pre><span>class </span>BakerServiceSpec <span>extends </span>AsyncWordSpec <span>with </span>Matchers {<br/><br/>  <span>"The BakerService" </span>should {<br/>    <span>"bake cookies" </span>in ServiceTest.<span>withServer</span>(ServiceTest.<span>defaultSetup</span>) { ctx =&gt;<br/>      <span>new </span>BakerApplication(ctx) <span>with </span>LocalServiceLocator<br/>    } { server =&gt;<br/>      val client = server.serviceClient.implement[BakerService]<br/>      <span>implicit val </span>as: Materializer = server.materializer<br/>      <span>val </span>input: Source[RawCookies, NotUsed] =<br/>        <span>Source</span>(<span>List</span>(<span>RawCookies</span>(<span>10</span>), <span>RawCookies</span>(<span>10</span>), <span>RawCookies</span>(<span>10</span>)))<br/>          .concat(Source.<span>maybe</span>)<br/><br/>      client.bake.invoke(input).map { output =&gt;<br/>        <span>val </span>probe = output.runWith(TestSink.<span>probe</span>(server.actorSystem))<br/>        probe.request(<span>10</span>)<br/>        probe.expectNext(<span>ReadyCookies</span>(<span>12</span>))<br/>        probe.expectNext(<span>ReadyCookies</span>(<span>12</span>))<br/>        <span>// because the oven is not full for the 6 other<br/></span><span>        </span>probe.cancel<br/>        <span>succeed<br/></span><span>      </span>}<br/>    }<br/>  }<br/>}</pre>
<p>The definition of the test, the test server, and the client is the same as before. The only difference is that, instead of our normal domain types we need to provide <kbd>Source</kbd> and get <kbd>Source</kbd> back. So we reach out for the Akka-Streams test kit and use our knowledge gained in <a href="8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml">Chapter 13</a>, <em><span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label">Basics of Akka Streams</span></span></em> to formulate the expectations against the streams. We create an input <kbd>Source</kbd> from <kbd>List</kbd> and use <kbd>TestSink</kbd> to confirm that the output of the service meets our expectations.</p>
<p>Now it's the time to enjoy the cookies!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">Lagom framework is a Lightbend's solution aiming to streamline and simplify building microservices with Scala and Java. It is build on top of existing libraries and frameworks such as SBT, Akka, and Play and provides additional functionalities such as a rich development environment with hot code reload, a service registry and service locator, an embedded database, and a message broker.</p>
<p class="p1">Lagom has three useful APIs:</p>
<ul>
<li>Service APIs, which allow you to represent remote service calls as local function calls</li>
<li>Persistence API, which provides additional structure and some useful defaults for <kbd>Akka-Persistence</kbd></li>
<li>Message broker API, which makes public/subscribe communication and working with the read-side of the journal a breeze</li>
</ul>
<p class="p1">Lagom comes with a test kit that helps to test services or persistent entities in isolation. Combining Lagom's test kit with the <kbd>Akka-Streams</kbd> test kit and <kbd>AsyncWordSpec</kbd> from <kbd>ScalaTest</kbd> makes it possible to write concise and expressive test expectations.</p>
<p>In this chapter, we just touched briefly upon possibilities provided by Lagom for development of microservice-based systems. This area of software engineering is still quite immature and Lagom is one of the first attempts to address the new challenges.</p>
<p class="mce-root">We hope with our example project we could spark your interest in Lagom and highly recommend you look at the official Lagom documentation at <a href="https://www.lagomframework.com/documentation/1.4.x/scala/Home.html">https://www.lagomframework.com/documentation/1.4.x/scala/Home.html</a> for further inspiration.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How do you map an endpoint with a query parameter to a REST call?</li>
<li>What is the recommended serialization format for persistent entities?</li>
<li>Can you explain why clustering is required in order to use persistence in Lagom?</li>
<li>Describe one possible data model which could be used to make the Manager a persistent entity.</li>
<li>Outline an alternative way to implement the Baker service.</li>
<li>Can you identify a design bug in current implementation of the Chef?</li>
<li>The Manager implementation stores a number of cookies in memory and this number will be lost at the moment the service restarts. Can you name another reason why it is a bad idea to hold the number of cookies in a local variable?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Rambabu Posa, <em>Scala Reactive Programming: Build fault-tolerant, robust, and distributed applications in Scala</em></span></li>
<li><span>Jatin Puri and Selvam Palanimalai, <em>Scala Microservices: Design, build, and run Microservices using Scala elegantly</em></span></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>