- en: Writing Custom Spring Boot Starters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义 Spring Boot 启动器
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding Spring Boot autoconfiguration
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Spring Boot 自动配置
- en: Creating a custom Spring Boot autoconfiguration starter
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义 Spring Boot 自动配置启动器
- en: Configuring custom conditional bean instantiations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自定义条件性 Bean 实例化
- en: Using custom @Enable annotations to toggle configurations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义 @Enable 注解切换配置
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, we did a lot of configuration, and even more autoconfiguration,
    while developing our Spring Boot application. Now, it is time to take a look behind
    the scenes to find out the magic behind Spring Boot autoconfiguration and write
    some starters of our own as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们在开发 Spring Boot 应用程序时做了很多配置，甚至更多的自动配置。现在，是时候揭开 Spring Boot 自动配置背后的魔法，并编写一些我们自己的启动器了。
- en: This is a very useful capability to possess, especially for large software enterprises
    where the presence of a proprietary code is inevitable. It is very helpful to
    be able to create internal custom starters that would automatically add some of
    the configuration or functionalities to the applications. Some likely candidates
    would be custom configuration systems, libraries, and configurations that deal
    with connecting to databases, using custom connection pools, HTTP clients, servers,
    and more. We will go through the internals of Spring Boot autoconfiguration, take
    a look at how new starters are created, explore conditional initialization and
    wiring of beans based on various rules, and see that annotations can be a powerful
    tool, providing the consumers of the starters with more control over dictating
    what configurations should be used and where.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常实用的能力，尤其是在拥有专有代码的大型软件企业中，专有代码的存在是不可避免的。能够创建内部自定义启动器，自动添加一些配置或功能到应用程序中，非常有帮助。一些可能的候选包括自定义配置系统、库以及处理连接数据库、使用自定义连接池、HTTP
    客户端、服务器等配置。我们将深入了解 Spring Boot 自动配置的内部机制，查看新启动器的创建方式，探索基于各种规则的 Bean 条件初始化和连接，并看到注解可以是一个强大的工具，为启动器的消费者提供更多控制权，以决定应该使用哪些配置以及在哪里使用。
- en: Understanding Spring Boot autoconfiguration
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Spring Boot 自动配置
- en: Spring Boot has a lot of power when it comes to bootstrapping an application
    and configuring it with exactly the things that are needed, all without much of
    the glue code that is required of us, the developers. The secret behind this power
    actually comes from Spring itself, or rather from the Java Configuration functionality
    that it provides. As we add more starters as dependencies, more and more classes
    will appear in our classpath. Spring Boot detects the presence or absence of specific
    classes and based on this information, makes some decisions, which are fairly
    complicated at times, and automatically creates and wires the necessary beans
    to the application context.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到启动应用程序并配置它以精确地包含所需的所有内容时，Spring Boot 具有强大的功能，而无需我们开发者编写大量的粘合代码。这种力量的秘密实际上来自于
    Spring 本身，或者更确切地说，来自于它提供的 Java 配置功能。随着我们添加更多的启动器作为依赖项，我们的类路径中将会出现越来越多的类。Spring
    Boot 会检测特定类的存在或不存在，并根据这些信息做出一些决策，有时这些决策相当复杂，并自动创建和连接必要的 Bean 到应用程序上下文中。
- en: Sounds simple, right?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单，对吧？
- en: In the previous recipes, we added a number of Spring Boot starters such as `spring-boot-starter-data-jpa`,
    `spring-boot-starter-web`, `spring-boot-starter-data-test`, and so on. We will
    use the same code that we finished in the previous chapter, in order to see what
    actually happens during the application startup and the decisions that Spring
    Boot will make while wiring our application together.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们添加了多个 Spring Boot 启动器，例如 `spring-boot-starter-data-jpa`、`spring-boot-starter-web`、`spring-boot-starter-data-test`
    等。我们将使用上一章完成相同的代码，以便查看应用程序启动过程中实际发生的情况以及 Spring Boot 在连接我们的应用程序时所做的决策。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Conveniently, Spring Boot provides us with an ability to get the `CONDITIONS
    EVALUATION REPORT` by simply starting the application with the `debug` flag. This
    can be passed to the application either as an environment variable, `DEBUG`, as
    a system property, `-Ddebug`, or as an application property, `--debug`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 便利的是，Spring Boot 提供了一种通过简单地以 `debug` 标志启动应用程序来获取 `CONDITIONS EVALUATION REPORT`
    的能力。这可以通过环境变量 `DEBUG`、系统属性 `-Ddebug` 或应用程序属性 `--debug` 传递给应用程序。
- en: Start the application by running `DEBUG=true ./gradlew clean bootRun`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `DEBUG=true ./gradlew clean bootRun` 来启动应用程序。
- en: 'Now, if you look at the console logs, you will see a lot more information printed
    there that is marked with the `DEBUG` level log. At the end of the startup log
    sequence, we will see the `CONDITIONS EVALUATION REPORT` as follows:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您查看控制台日志，您将看到那里打印了更多标记为`DEBUG`级别的信息。在启动日志序列的末尾，我们将看到如下所示的`CONDITIONS EVALUATION
    REPORT`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, the amount of information that is printed in the debug mode
    can be somewhat overwhelming, so I've selected only one example of positive and
    negative matches each.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在调试模式下打印的信息量可能有些令人不知所措，所以我只选择了一个正匹配和一个负匹配的例子。
- en: 'For each line of the report, Spring Boot tells us why certain configurations
    have been selected to be included, what they have been positively matched on,
    or, for the negative matches, what was missing that prevented a particular configuration
    being included in the mix. Let''s look at the positive match for `DataSourceAutoConfiguration`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于报告中的每一行，Spring Boot都会告诉我们为什么某些配置被选中包含在内，它们在哪些方面进行了正匹配，或者对于负匹配，是什么缺失的阻止了特定配置被包含在组合中。让我们看看`DataSourceAutoConfiguration`的正匹配：
- en: 'The `@ConditionalOnClass` classes found tells us that Spring Boot has detected
    the presence of a particular class, specifically two classes in our case: `javax.sql.DataSource`
    and `org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到的`@ConditionalOnClass`类告诉我们Spring Boot已经检测到特定类的存在，在我们的例子中是两个类：`javax.sql.DataSource`和`org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType`。
- en: The `OnClassCondition` indicates the kind of matching that was used. This is
    supported by the `@ConditionalOnClass` and `@ConditionalOnMissingClass` annotations.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnClassCondition`指示使用了哪种匹配方式。这由`@ConditionalOnClass`和`@ConditionalOnMissingClass`注解支持。'
- en: While `OnClassCondition` is the most common kind of detection, Spring Boot also
    uses many other conditions. For example, `OnBeanCondition` is used to check the
    presence or absence of specific bean instances, `OnPropertyCondition` is used
    to check the presence, absence, or specific value of a property, as well as any
    number of the custom conditions that can be defined using the `@Conditional` annotation
    and `Condition` interface implementations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`OnClassCondition`是最常见的检测类型，但Spring Boot还使用了许多其他条件。例如，`OnBeanCondition`用于检查特定bean实例的存在或不存在，`OnPropertyCondition`用于检查属性的存在、不存在或特定值，以及可以使用`@Conditional`注解和`Condition`接口实现定义的任何数量的自定义条件。
- en: The negative matches show us a list of configurations that Spring Boot has evaluated,
    which means that they do exist in the classpath and were scanned by Spring Boot
    but didn't pass the conditions required for their inclusion. `GsonAutoConfiguration`,
    while available in the classpath as it is a part of the imported `spring-boot-autoconfigure`
    artifact, was not included because the required `com.google.gson.Gson` class was
    not detected as present in the classpath, thus failing the `OnClassCondition`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 负匹配显示Spring Boot评估过的配置列表，这意味着它们确实存在于类路径中，并被Spring Boot扫描，但未通过包含所需的条件。`GsonAutoConfiguration`虽然作为导入的`spring-boot-autoconfigure`工件的一部分存在于类路径中，但由于所需的`com.google.gson.Gson`类未检测到存在于类路径中，因此未能通过`OnClassCondition`。
- en: 'The implementation of the `GsonAutoConfiguration` file looks as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`GsonAutoConfiguration`文件的实现如下所示：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After looking at the code, it is very easy to make the connection between the
    conditional annotations and report information that is provided by Spring Boot
    at the start time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码后，很容易将条件注解与Spring Boot在启动时提供的信息之间的联系联系起来。
- en: Creating a custom Spring Boot autoconfiguration starter
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义Spring Boot自动配置启动器
- en: We have a high-level idea of the process by which Spring Boot decides which
    configurations to include in the formation of the application context. Now, let's
    take a stab at creating our own Spring Boot starter artifact, which we can include
    as an autoconfigurable dependency in our build.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Spring Boot决定将哪些配置包含在应用程序上下文形成过程中的过程有一个高级的了解。现在，让我们尝试创建我们自己的Spring Boot启动器工件，我们可以将其作为可自动配置的依赖项包含在我们的构建中。
- en: In [Chapter 2](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml), *Configuring Web
    Applications*, you learned how to create database `Repository` objects. So, let's
    build a simple starter that will create another `CommandLineRunner` that will
    take the collection of all the `Repository` instances and print out the count
    of the total entries for each.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml)，*配置 Web 应用程序*，你学习了如何创建数据库
    `Repository` 对象。所以，让我们构建一个简单的起始作品，它将创建另一个 `CommandLineRunner`，该 `CommandLineRunner`
    将获取所有 `Repository` 实例的集合并打印出每个的总条目数。
- en: We will start by adding a child Gradle project to our existing project that
    will house the codebase for the starter artifact. We will call it `db-count-starter`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向现有项目添加一个子 Gradle 项目，该项目将包含起始作品的代码库。我们将称之为 `db-count-starter`。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will start by creating a new directory named `db-count-starter` in the root
    of our project.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在项目根目录下创建一个名为 `db-count-starter` 的新目录。
- en: 'As our project has now become what is known as a `multiproject` build, we will
    need to create a `settings.gradle` configuration file in the root of our project
    with the following content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的项目现在已成为所谓的 `multiproject` 构建，我们需要在项目根目录中创建一个 `settings.gradle` 配置文件，其内容如下：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We should also create a separate `build.gradle` configuration file for our
    subproject in the `db-count-starter` directory in the root of our project, with
    the following content:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该在项目根目录下的 `db-count-starter` 目录中为我们的子项目创建一个单独的 `build.gradle` 配置文件，其内容如下：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we are ready to start coding. So, the first thing is to create the directory
    structure, `src/main/java/com/example/bookpubstarter/dbcount`, in the `db-count-starter`
    directory in the root of our project.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始编码了。所以，第一步是创建目录结构，`src/main/java/com/example/bookpubstarter/dbcount`，在项目根目录下的
    `db-count-starter` 目录中。
- en: 'In the newly created directory, let''s add our implementation of the `CommandLineRunner`
    file named `DbCountRunner.java` with the following content:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的目录中，让我们添加名为 `DbCountRunner.java` 的 `CommandLineRunner` 文件实现，其内容如下：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the actual implementation of `DbCountRunner` in place, we will now need
    to create the configuration object that will declaratively create an instance
    during the configuration phase. So, let''s create a new class file called `DbCountAutoConfiguration.java`
    with the following content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DbCountRunner` 的实际实现到位后，我们现在需要创建一个配置对象，该对象将在配置阶段声明性地创建一个实例。所以，让我们创建一个名为 `DbCountAutoConfiguration.java`
    的新类文件，其内容如下：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will also need to tell Spring Boot that our newly created JAR artifact contains
    the autoconfiguration classes. For this, we will need to create a `resources/META-INF`
    directory in the `db-count-starter/src/main` directory in the root of our project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要告诉 Spring Boot，我们新创建的 JAR 软件包包含自动配置类。为此，我们需要在项目根目录下的 `db-count-starter/src/main`
    目录中创建一个 `resources/META-INF` 目录。
- en: 'In this newly created directory, we will place the file named `spring.factories`
    with the following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新创建的目录中，我们将放置名为 `spring.factories` 的文件，其内容如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the purpose of our demo, we will add the dependency to our starter artifact
    in the main project''s `build.gradle` by adding the following entry in the dependencies
    section:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示的目的，我们将在主项目的 `build.gradle` 文件中添加对起始作品的依赖项，通过在依赖项部分添加以下条目：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Start the application by running `./gradlew clean bootRun`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean bootRun` 启动应用程序。
- en: 'Once the application is compiled and has started, we should see the following
    in the console logs:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序编译并启动，我们应该在控制台日志中看到以下内容：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Congratulations! You have now built your very own Spring Boot autoconfiguration
    starter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经构建了自己的 Spring Boot 自动配置起始作品。
- en: First, let's quickly walk through the changes that we made to our Gradle build
    configuration and then we will examine the starter setup in detail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速浏览一下我们对 Gradle 构建配置所做的更改，然后我们将详细检查起始设置。
- en: 'As the Spring Boot starter is a separate, independent artifact, just adding
    more classes to our existing project source tree would not really demonstrate
    much. To make this separate artifact, we have a couple of choices: making a separate
    Gradle configuration in our existing project, or creating a completely separate
    project altogether. The most ideal solution, however, was to just convert our
    build to Gradle Multi-Project Build by adding a nested project directory and subproject
    dependency to the `build.gradle` file of the root project. By doing this, Gradle
    actually creates a separate JAR artifact for us but we don''t have to publish
    it anywhere, only include it as a compile `project('':db-count-starter'')` dependency.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring Boot启动器是一个独立的、独立的工件，仅仅将更多类添加到我们现有的项目源树中并不能真正展示出很多。为了使这个独立的工件，我们有几种选择：在我们的现有项目中创建一个单独的Gradle配置，或者完全创建一个全新的项目。然而，最理想的解决方案是将我们的构建转换为Gradle多项目构建，通过在根项目的`build.gradle`文件中添加嵌套项目目录和子项目依赖来实现。通过这样做，Gradle实际上为我们创建了一个独立的JAR工件，但我们不需要将其发布到任何地方，只需将其作为编译`project(':db-count-starter')`依赖项包含即可。
- en: For more information about Gradle multi-project builds, you can check out the
    manual at [http://gradle.org/docs/current/userguide/multi_project_builds.html](http://gradle.org/docs/current/userguide/multi_project_builds.html).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Gradle多项目构建的更多信息，您可以查看[http://gradle.org/docs/current/userguide/multi_project_builds.html](http://gradle.org/docs/current/userguide/multi_project_builds.html)的手册。
- en: The Spring Boot Auto-Configuration starter is nothing more than a regular Spring
    Java Configuration class annotated with the `@Configuration` annotation and the
    presence of `spring.factories` in the classpath in the `META-INF` directory with
    the appropriate configuration entries.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot自动配置启动器不过是一个带有`@Configuration`注解的常规Spring Java配置类，并且类路径中的`META-INF`目录下存在`spring.factories`文件，其中包含适当的配置条目。
- en: 'During the application startup, Spring Boot uses `SpringFactoriesLoader`, which
    is a part of Spring Core, in order to get a list of the Spring Java Configurations
    that are configured for the `org.springframework.boot.autoconfigure.EnableAutoConfiguration`
    property key. Under the hood, this call collects all the `spring.factories` files
    located in the `META-INF` directory from all the jars or other entries in the
    classpath, and builds a composite list to be added as application context configurations.
    In addition to the `EnableAutoConfiguration` key, we can declare the following
    automatically initializable startup implementations in a similar fashion:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动期间，Spring Boot使用`SpringFactoriesLoader`（它是Spring Core的一部分），以获取为`org.springframework.boot.autoconfigure.EnableAutoConfiguration`属性键配置的Spring
    Java配置列表。在底层，这个调用收集了类路径中所有jar或其他条目在`META-INF`目录下的所有`spring.factories`文件，并构建一个复合列表作为应用程序上下文配置添加。除了`EnableAutoConfiguration`键之外，我们还可以以类似的方式声明以下自动初始化的启动实现：
- en: '`org.springframework.context.ApplicationContextInitializer`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.context.ApplicationContextInitializer`'
- en: '`org.springframework.context.ApplicationListener`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.context.ApplicationListener`'
- en: '`org.springframework.boot.autoconfigure.AutoConfigurationImportListener`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot.autoconfigure.AutoConfigurationImportListener`'
- en: '`org.springframework.boot.autoconfigure.AutoConfigurationImportFilter`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot.autoconfigure.AutoConfigurationImportFilter`'
- en: '`` `org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider`
    ``'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider`
    ``'
- en: '`org.springframework.boot.SpringBootExceptionReporter`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot.SpringBootExceptionReporter`'
- en: '`org.springframework.boot.SpringApplicationRunListener`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot.SpringApplicationRunListener`'
- en: '`org.springframework.boot.env.PropertySourceLoader`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot.env.PropertySourceLoader`'
- en: '`org.springframework.boot.env.EnvironmentPostProcessor`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot.env.EnvironmentPostProcessor`'
- en: '`org.springframework.boot.diagnostics.FailureAnalyzer`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot.diagnostics.FailureAnalyzer`'
- en: '`org.springframework.boot.diagnostics.FailureAnalysisReporter`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot.diagnostics.FailureAnalysisReporter`'
- en: '`org.springframework.test.contex.TestExecutionListener`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.test.contex.TestExecutionListener`'
- en: Ironically enough, a Spring Boot Starter does not need to depend on the Spring
    Boot library as its compile time dependency. If we look at the list of class imports
    in the `DbCountAutoConfiguration` class, we will not see anything from the `org.springframework.boot`
    package. The only reason that we have a dependency declared on Spring Boot is
    because our implementation of `DbCountRunner` implements the `org.springframework.boot.CommandLineRunner`
    interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 充满讽刺意味的是，Spring Boot Starter不需要依赖Spring Boot库作为其编译时依赖项。如果我们查看`DbCountAutoConfiguration`类中的类导入列表，我们将不会看到来自`org.springframework.boot`包的任何内容。我们声明对Spring
    Boot的依赖的唯一原因是因为我们的`DbCountRunner`实现实现了`org.springframework.boot.CommandLineRunner`接口。
- en: Configuring custom conditional bean instantiations
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置自定义条件bean实例化
- en: In the previous example, you learned how to get the basic Spring Boot Starter
    going. On the inclusion of the jar in the application classpath, the `DbCountRunner`
    bean will be created automatically and added to the application context. In the
    very first recipe of this chapter, we have also seen that Spring Boot has an ability
    to do conditional configurations depending on a few conditions, such as the presence
    of specific classes in the classpath, existence of a bean, and others.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你学习了如何启动基本的Spring Boot Starter。在将jar包包含在应用程序类路径中时，`DbCountRunner` bean将被自动创建并添加到应用程序上下文中。在本章的第一个菜谱中，我们也看到了Spring
    Boot具有根据一些条件进行条件配置的能力，例如类路径中存在特定类、bean的存在以及其他一些条件。
- en: For this recipe, we will enhance our starter with a conditional check. This
    will create the instance of `DbCountRunner` only if no other bean instance of
    this class has already been created and added to the application context.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将通过条件检查来增强我们的启动器。这将在没有其他此类bean实例已被创建并添加到应用程序上下文的情况下，创建`DbCountRunner`的实例。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the `DbCountAutoConfiguration` class, we will add an `@ConditionalOnMissingBean`
    annotation to the `dbCountRunner(...)` method, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DbCountAutoConfiguration`类中，我们将向`dbCountRunner(...)`方法添加一个`@ConditionalOnMissingBean`注解，如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will also need to add a dependency on the `spring-boot-autoconfigure` artifact
    to the dependencies section of the `db-count-starter/build.gradle` file:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将`spring-boot-autoconfigure`组件的依赖项添加到`db-count-starter/build.gradle`文件的依赖项部分：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's start the application by running `./gradlew clean bootRun` in order
    to verify that we will still see the same output in the console logs as we did
    in the previous recipe
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过在终端中运行`./gradlew clean bootRun`来启动应用程序，以验证我们将在控制台日志中看到与之前菜谱中相同的输出。
- en: 'If we start the application with the `DEBUG` switch so as to see the Auto-Configuration
    Report, which we already learned in the first recipe of this chapter, we will
    see that our autoconfiguration is in the Positive Matches group, as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用`DEBUG`开关启动应用程序以查看自动配置报告，正如我们在本章第一道菜谱中学到的，我们将看到我们的自动配置位于Positive Matches组中，如下所示：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s explicitly/manually create an instance of `DbCountRunner` in our main
    `BookPubApplication` configuration class, and we will also override its `run(...)`
    method, just so we can see the difference in the logs:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在主`BookPubApplication`配置类中显式/手动创建一个`DbCountRunner`的实例，并且我们还将覆盖其`run(...)`方法，这样我们就可以在日志中看到差异：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Start the application by running `DEBUG=true ./gradlew clean bootRun`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`DEBUG=true ./gradlew clean bootRun`来启动应用程序。
- en: 'If we look at the console logs, we will see two things: the Auto-Configuration
    Report will print our autoconfiguration in the Negative Matches group and, instead
    of the count output for each repository, we will see `Manually Declared DbCountRunner` text
    to appear:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看控制台日志，我们将看到两件事：自动配置报告将在Negative Matches组中打印我们的自动配置，并且，而不是每个存储库的计数输出，我们将看到`Manually
    Declared DbCountRunner`文本出现：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we learned from the previous recipe, Spring Boot will automatically process
    all the configuration class entries from `spring.factories` during the application
    context creation. Without any extra guidance, everything that is annotated with
    an `@Bean` annotation will be used to create a Spring Bean. This functionality
    is actually a part of the plain old Spring Framework Java Configuration. What
    Spring Boot adds on top is the ability to conditionally control the rules for
    when certain `@Configuration` or `@Bean` annotations should be executed and when
    it is best to ignore them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从之前的配方中学到的，Spring Boot将在应用程序上下文创建期间自动处理所有来自`spring.factories`的配置类条目。在没有额外指导的情况下，所有使用`@Bean`注解注解的内容都将用于创建Spring
    Bean。这个功能实际上是Java配置的Spring Framework的一部分。Spring Boot在此基础上增加的是能够条件性地控制某些`@Configuration`或`@Bean`注解何时执行以及何时最好忽略它们的能力。
- en: In our case, we used the `@ConditionalOnMissingBean` annotation to instruct
    Spring Boot to create our `DbCountRunner` bean only if there was no other bean
    matching either the class type or bean name already declared elsewhere. As we
    explicitly created an `@Bean` entry for `DbCountRunner` in the `BookPubApplication`
    configuration, this took precedence and caused `OnBeanCondition` to detect the
    existence of the bean; thus instructing Spring Boot not to use `DbCountAutoConfiguration`
    during the application context setup.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们使用了`@ConditionalOnMissingBean`注解来指示Spring Boot仅在没有任何其他匹配类类型或已声明的bean名称的bean时创建我们的`DbCountRunner`
    bean。由于我们在`BookPubApplication`配置中明确创建了一个`@Bean`条目用于`DbCountRunner`，这具有优先权，导致`OnBeanCondition`检测到bean的存在；从而指示Spring
    Boot在应用程序上下文设置期间不使用`DbCountAutoConfiguration`。
- en: Using custom @Enable annotations to toggle configuration
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义的`@Enable`注解切换配置
- en: Allowing Spring Boot to automatically evaluate the classpath and detected configurations
    that are found there makes it very quick and easy to get a simple application
    going. However, there are times when we want to provide the configuration classes
    but require consumers of the starter library to explicitly enable such a configuration,
    rather than relying on Spring Boot to decide automatically if it should be included
    or not.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 允许Spring Boot自动评估类路径和检测到的配置，这使得启动一个简单应用程序变得非常快速和简单。然而，有时我们希望提供配置类，但要求启动库的消费者明确启用此类配置，而不是依赖Spring
    Boot自动决定是否包含它。
- en: We will modify our previous recipe to make the starter be enabled via a meta-annotation
    rather than using the `spring.factories` route.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改之前的配方，使启动器通过元注解启用，而不是使用`spring.factories`路由。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we will comment out the content of the `spring.factories` file located
    in `db-count-starter/src/main/resources` in the root of our project, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将注释掉位于项目根目录`db-count-starter/src/main/resources`中的`spring.factories`文件的内容，如下所示：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we will need to create the meta-annotation. We will create a new file
    named `EnableDbCounting.java` in the `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory in the root of our project with the following content:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建元注解。我们将在项目根目录下的`db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`目录中创建一个名为`EnableDbCounting.java`的新文件，其内容如下：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will now add the `@EnableDbCounting` annotation to our `BookPubApplication`
    class and also remove the `dbCountRunner(...)` method from it, as shown in the
    following snippet:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将向我们的`BookPubApplication`类添加`@EnableDbCounting`注解，并从其中删除`dbCountRunner(...)`方法，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Start the application by running `./gradlew clean bootRun`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootRun`来启动应用程序。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After running the application, the first thing that you might have noticed
    is that the printed counts all showed `0`, even though `StartupRunner` had printed
    `Number of books: 1` to the console, as shown in the following output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '运行应用程序后，你可能会首先注意到打印的计数全部显示为`0`，尽管`StartupRunner`已经在控制台打印了`Number of books:
    1`，如下所示：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is because Spring Boot is randomly executing `CommandLineRunners` and,
    as we changed the configuration to use the `@EnableDbCounting` annotation, it
    gets processed before the configuration in the `BookPubApplication` class itself.
    As the database population is done by us in the `StartupRunner.run(...)` method
    and the execution of `DbCountRunner.run(...)` happens before this, the database
    tables have no data and so report the `0` count.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Spring Boot 正在随机执行 `CommandLineRunners`，并且由于我们更改了配置以使用 `@EnableDbCounting`
    注解，它会在 `BookPubApplication` 类本身的配置之前被处理。由于数据库填充是由我们在 `StartupRunner.run(...)`
    方法中完成的，而 `DbCountRunner.run(...)` 的执行发生在之前，因此数据库表没有数据，所以报告了 `0` 个计数。
- en: If we want to enforce the order, Spring provides us with this ability using
    the `@Order` annotation. Let's annotate the `StartupRunner` class with `@Order(Ordered.LOWEST_PRECEDENCE
    - 15)`. As `LOWEST_PRECEDENCE` is the default order that is assigned, we will
    ensure that `StartupRunner` will be executed after `DbCountRunner` by slightly
    reducing the order number. Let's run the app again and now we will see that the
    counts are properly displayed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要强制执行顺序，Spring 通过 `@Order` 注解提供了这种能力。让我们用 `@Order(Ordered.LOWEST_PRECEDENCE
    - 15)` 注解 `StartupRunner` 类。由于 `LOWEST_PRECEDENCE` 是默认分配的顺序，我们将通过稍微降低顺序号来确保 `StartupRunner`
    将在 `DbCountRunner` 之后执行。让我们再次运行应用程序，现在我们将看到计数被正确显示。
- en: Now that this little ordering issue is behind us, let's examine what we did
    with the `@EnableDbCounting` annotation in a bit more detail.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了这个小排序问题，让我们更详细地检查我们用 `@EnableDbCounting` 注解做了什么。
- en: Without `spring.factories` containing the configuration, Spring Boot does not
    really know that the `DbCountAutoConfiguration` class should be included during
    the application context creation. By default, the configuration component scan
    will look only from the `BookPubApplication` package and below. As the packages
    are different—`com.example.bookpub` versus `com.example.bookpubstarter.dbcount`—the
    scanner won't pick it up.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有包含配置的 `spring.factories`，Spring Boot 并不知道在应用程序上下文创建过程中应该包含 `DbCountAutoConfiguration`
    类。默认情况下，配置组件扫描只会从 `BookPubApplication` 包及其以下部分开始。由于包不同——`com.example.bookpub`
    与 `com.example.bookpubstarter.dbcount`——扫描器不会找到它。
- en: This is where our newly created meta-annotation comes into play. In the `@EnableDbCounting`
    annotation, there is a key-nested annotation, `@Import(DbCountAutoConfiguration.class)`,
    which makes things happen. This is an annotation that is provided by Spring, which
    can be used to annotate other annotations with declarations of which configuration
    classes should be imported in the process. By annotating our `BookPubApplication`
    class with `@EnableDbCounting`, we transitively tell Spring that it should include
    `DbCountAutoConfiguration` as a part of the application context as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的新创建的元注解发挥作用的地方。在 `@EnableDbCounting` 注解中，有一个键嵌套注解 `@Import(DbCountAutoConfiguration.class)`，这使得事情发生。这是一个由
    Spring 提供的注解，可以用来注解其他注解，声明在过程中应该导入哪些配置类。通过用 `@EnableDbCounting` 注解我们的 `BookPubApplication`
    类，我们递归地告诉 Spring 应该将 `DbCountAutoConfiguration` 作为应用程序上下文的一部分包含进来。
- en: Using the convenience meta-annotations, `spring.factories`, and conditional
    bean annotations, we can now create sophisticated and elaborate custom autoconfiguration
    Spring Boot starters in order to solve the needs of our enterprises.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用便利的元注解、`spring.factories` 和条件 Bean 注解，我们现在可以创建复杂且详尽的定制自动配置 Spring Boot 启动器，以满足我们企业的需求。
