<html><head></head><body>
<div class="book" title="Chapter&#xA0;7.&#xA0;Concepts of Tree" id="19UOO1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Concepts of Tree</h1></div></div></div><p class="calibre8">We have already seen data structures such as linked list and array. They represent data stored in a linear fashion. In this chapter, we will discuss a new kind of data structure, called a tree. A tree<a id="id298" class="calibre1"/> is a generalization of a linked list. While a linked list node has one reference to the next node, a tree node has references to possibly more than one next node. These next nodes are called children of the node, and the node holding the references to the children is <a id="id299" class="calibre1"/>called a parent node. In this chapter, we will <a id="id300" class="calibre1"/>explore the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Concept of a tree as a data structure</li><li class="listitem">Concept of a tree as an ADT</li><li class="listitem">Binary trees</li><li class="listitem">Different kinds of tree traversals</li><li class="listitem">Tree search algorithms</li></ul></div><p class="calibre8">So, let's jump into it right away.</p></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Concepts of Tree" id="19UOO1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="A tree data structure"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec37" class="calibre1"/>A tree data structure</h1></div></div></div><p class="calibre8">A tree data structure looks very much like a real tree, the kind you can see in a garden or by the <a id="id301" class="calibre1"/>roadside. If we look at a tree, we will see that it has a root that makes the stem outside of the ground. The stem splits into branches, and at the end of the branches, we find leaves. In our tree data structure, we start from the root. The root is the node that does not have any parent. The children can be thought of as being attached to the stem by lines just like the branches of a real tree. At the end, we find some nodes that have no children and hence are called leaves. The following figure shows an example of a tree:</p><div class="mediaobject"><img src="../images/00042.jpeg" alt="A tree data structure" class="calibre9"/><div class="caption"><p class="calibre15">An example tree</p></div></div><p class="calibre10"> </p><p class="calibre8">Note that the tree is<a id="id302" class="calibre1"/> drawn upside down. The root is at the top and the leaves are below. This is just a convention that most people prefer. Think of this as the reflection of a tree on water.</p><p class="calibre8">A tree can be represented in many ways, but we will get started with the idea of generalization<a id="id303" class="calibre1"/> of a <span class="strong"><strong class="calibre2">linked </strong></span>list. In the case of a linked list, a node stores a single reference that points to the next node. In a tree, a node needs to store the references to all its children. Multiple children could be stored in an array, but since we have access to our own class <code class="email">LinkedList</code>, we will use that. We will use our non-functional version of the linked list because our first tree will be non-functional and will allow modification.</p><p class="calibre8">We start with the following class:</p><div class="informalexample"><pre class="programlisting">public class Tree&lt;E&gt; {
    public static class Node&lt;E&gt;{
        private E value;
        private LinkedList&lt;Node&lt;E&gt;&gt; children;
        private Tree&lt;E&gt; hostTree;
        private Node&lt;E&gt; parent;

        public LinkedList&lt;Node&lt;E&gt;&gt; getChildren() {
            return children;
        }

        public E getValue() {
            return value;
        }

        private Node(LinkedList&lt;Node&lt;E&gt;&gt; children, Tree&lt;E&gt; hostTree, 
        E value, Node&lt;E&gt; parent) {
            this.children = children;
            this.hostTree = hostTree;
            this.value = value;
            this.parent = parent;
        }
    }

...
}</pre></div><p class="calibre8">We have defined our <code class="email">Node</code> class as an inner class. Apart from remembering the value it stores inside and the list of children, it also stores the parent and the tree that it is a member<a id="id304" class="calibre1"/> of. Once we create an instance of a tree, we must be able to store a node in it. The node that does not have a parent is called the root of the tree. So, we add an <code class="email">addRoot</code> method to add a root to the tree. The tree, itself, only has to store the reference of the root node as all the other nodes can be reached from this node by traversing the references:</p><div class="informalexample"><pre class="programlisting">    private Node&lt;E&gt; root;



    public void addRoot(E value){
        if(root == null){
            root = new Node&lt;&gt;(new LinkedList&lt;&gt;(), this, value, null );
        }else{
            throw new IllegalStateException(
                "Trying to add new node to a non empty tree");
        }
    }</pre></div><p class="calibre8">Note that we test whether the tree already has a root node, in which case, we throw an exception.</p><p class="calibre8">Okay, now that we have a way of adding a root node, we need to have a method for adding nodes as we like. The method takes a parent node and a value in order to add a new node. This method will return the newly added node so that we keep adding more nodes as its children:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; addNode(Node&lt;E&gt; parent, E value){
        if(parent==null){
            throw new NullPointerException("Cannot add child to null parent");
        }else if(parent.hostTree != this){
            throw new IllegalArgumentException(
                "Parent node not a part of this tree");
        }else{
            Node&lt;E&gt; newNode = new Node&lt;&gt;(new LinkedList&lt;&gt;(), this, value, parent);
            parent.getChildren().appendLast(newNode);
            return newNode;
        }
    }</pre></div><p class="calibre8">In the preceding code, we first check whether the parent is null or whether the parent is the node<a id="id305" class="calibre1"/> of a different tree instance. In either case, an exception must be thrown. Otherwise, we just add a new node as the child of the parent node passed as an argument.</p><p class="calibre8">But wait a second! How would we ever be able to pass a parent node if we do not have a reference to the root node in the calling code? So, we add a method, <code class="email">getRoot</code>, to access the root node of the Tree:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; getRoot() {
        return root;
    }</pre></div><p class="calibre8">Okay, now let's create a <code class="email">Tree</code> instance:</p><div class="informalexample"><pre class="programlisting">    public static void main(String [] args){
        Tree&lt;Integer&gt; tree = new Tree&lt;&gt;();
        tree.addRoot(1);
        Node&lt;Integer&gt; node1 = tree.getRoot();
        Node&lt;Integer&gt; node2 = tree.addNode(node1, 5);
        Node&lt;Integer&gt; node3 = tree.addNode(node1, 1);
        Node&lt;Integer&gt; node4 = tree.addNode(node2, 2);
        Node&lt;Integer&gt; node5 = tree.addNode(node2, 5);
        Node&lt;Integer&gt; node6 = tree.addNode(node2, 9);
        Node&lt;Integer&gt; node7 = tree.addNode(node3, 6);
        Node&lt;Integer&gt; node8 = tree.addNode(node3, 2);
        Node&lt;Integer&gt; node9 = tree.addNode(node5, 5);
        Node&lt;Integer&gt; node10 = tree.addNode(node6, 9);
        Node&lt;Integer&gt; node11 = tree.addNode(node6, 6);
    }</pre></div><p class="calibre8">The code is <a id="id306" class="calibre1"/>self-explanatory. We just create a tree by adding the nodes one by one. But how do we see what the tree looks like? For that, we will have to learn about the traversal of a tree. The preceding code will create the tree shown in the following figure:</p><div class="mediaobject"><img src="../images/00043.jpeg" alt="A tree data structure" class="calibre9"/><div class="caption"><p class="calibre15">Example tree</p></div></div><p class="calibre10"> </p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Concepts of Tree" id="19UOO1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="A tree data structure">
<div class="book" title="The traversal of a tree"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec47" class="calibre1"/>The traversal of a tree</h2></div></div></div><p class="calibre8">Tree traversal is <a id="id307" class="calibre1"/>an algorithm to visit or to process all nodes<a id="id308" class="calibre1"/> of a tree exactly once. This obviously involves recursively looking into the children of the nodes. The order in which the children are processed depends on the particular algorithm we use. The simplest algorithm for traversing a tree is the depth-first traversal.</p><div class="book" title="The depth-first traversal"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec16" class="calibre1"/>The depth-first traversal</h3></div></div></div><p class="calibre8">In the depth-first traversal, we process every child of a node recursively and wait for it to finish with<a id="id309" class="calibre1"/> all its descendants before proceeding to the <a id="id310" class="calibre1"/>next child. To understand the depth-first search, we have to understand what a subtree is. A subtree is a node with all its descendants up to the leaves. The following figure shows some examples of subtrees.</p><div class="mediaobject"><img src="../images/00044.jpeg" alt="The depth-first traversal" class="calibre9"/><div class="caption"><p class="calibre15">Examplesubtrees</p></div></div><p class="calibre10"> </p><p class="calibre8">Now, if you think about it, each node not only stores references to the children, but also sort of holds references to entire subtrees rooted at the child nodes. So, the depth-first traversal algorithm is nothing but the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Process the value in the current node.</li><li class="listitem" value="2">For each child node of the current node, recursively traverse the entire subtree rooted at the child node.</li></ol><div class="calibre13"/></div><p class="calibre8">The following method does exactly this:</p><div class="informalexample"><pre class="programlisting">protected void traverseDepthFirst(OneArgumentStatement&lt;E&gt; processor, Node&lt;E&gt; current){
    processor.doSomething(current.value);
    current.children.forEach((n)-&gt; traverseDepthFirst(processor, n));
}</pre></div><p class="calibre8">The method takes a lambda and a node to traverse. All this method does is first run the lambda on the current value and then call itself recursively on each of the subtrees. Now, we can write a wrapper method without the parent node argument:</p><div class="informalexample"><pre class="programlisting">public void traverseDepthFirst(OneArgumentStatement&lt;E&gt; processor){
    traverseDepthFirst(processor, getRoot());
}</pre></div><p class="calibre8">It is still not<a id="id311" class="calibre1"/> clear, though, why this way of traversing is called a <a id="id312" class="calibre1"/>depth-first traversal. If you think about the order in which the nodes are processed, you can see that since the complete subtree root at any child node must be entirely processed before the next child is processed, the depth of the tree will be covered before the breadth.</p><p class="calibre8">We have used a recursive function to do our depth-first search. Alternatively, we can use a stack to do the trick:</p><div class="informalexample"><pre class="programlisting">public void traverseDepthFirstUsingStack(
    OneArgumentStatement&lt;E&gt; processor){

    Stack&lt;Node&lt;E&gt;&gt; stack = new StackImplLinkedList&lt;&gt;();
    stack.push(getRoot());
    while(stack.peek()!=null){
        Node&lt;E&gt; current = stack.pop();
        processor.doSomething(current.value);
        current.children.forEach((n)-&gt;stack.push(n));
    }
}</pre></div><p class="calibre8">Let's see what is happening in the preceding piece of code. We first push the root into the stack and go in a loop that continues until all the stack elements have been cleared. Every time we pop a node, we process it and push all its children into the stack. Now, since the stack is <span class="strong"><strong class="calibre2">last in first out</strong></span> (<span class="strong"><strong class="calibre2">LIFO</strong></span>), all these children will be popped and processed before any <a id="id313" class="calibre1"/>other node can be processed. However, the moment the first of these children is popped, its children will be pushed into the stack and would be processed before anything else is processed. This will go on until we hit the leaf nodes, which would not have any more children. This, in effect, is almost the same as the recursive version.</p><p class="calibre8">There is a slight difference between the outputs of this code and the recursive version, although both are indeed depth-first. However, please note that in the case of the recursive version, the child that is near the head of the linked list is processed first. In the case of the stack version, we push the children in the same order, but since the stack is LIFO, we pop the children in the reverse order. To reverse this order, we can store the list of children in the opposite order in a temporary list before pushing them into the stack, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void traverseDepthFirstUsingStack(
    OneArgumentStatement&lt;E&gt; processor){

    Stack&lt;Node&lt;E&gt;&gt; stack = new StackImplLinkedList&lt;&gt;();
    stack.push(getRoot());
    while(stack.peek()!=null){
        Node&lt;E&gt; current = stack.pop();
        processor.doSomething(current.value);
<span class="strong"><strong class="calibre2">        LinkedList&lt;Node&lt;E&gt;&gt; reverseList = new LinkedList&lt;&gt;();</strong></span>
<span class="strong"><strong class="calibre2">        current.children.forEach((n)-&gt;reverseList.appendFirst(n));</strong></span>
<span class="strong"><strong class="calibre2">        reverseList.forEach((n)-&gt;stack.push(n));</strong></span>
    }
}</pre></div><p class="calibre8">The list is<a id="id314" class="calibre1"/> reversed by storing in a temporary list, called <code class="email">reverseList</code>, by appending the elements to its beginning. Then, the elements are pushed<a id="id315" class="calibre1"/> into the stack from <code class="email">reverseList</code>.</p></div><div class="book" title="The breadth-first traversal"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec17" class="calibre1"/>The breadth-first traversal</h3></div></div></div><p class="calibre8">Breadth-first traversal is the opposite of the depth-first traversal, in the sense that depth-first traversal<a id="id316" class="calibre1"/> processes children before siblings and<a id="id317" class="calibre1"/> breadth-first traversal processes the nodes of the same level before it processes any node of the succeeding level. In other words, in a breadth-first traversal, the nodes are processed level by level. This is simply achieved by taking the stack version of the depth-first traversal and replacing the stack with a queue. That is all that is needed for it:</p><div class="informalexample"><pre class="programlisting">public void traverseBreadthFirst(OneArgumentStatement&lt;E&gt; processor){
    Queue&lt;Node&lt;E&gt;&gt; queue = new QueueImplLinkedList&lt;&gt;();
    queue.enqueue(getRoot());
    while(queue.peek()!=null){
        Node&lt;E&gt; current = queue.dequeue();
        processor.doSomething(current.value);
        current.children.forEach((n)-&gt;queue.enqueue(n));
    }
}</pre></div><p class="calibre8">Note that everything else remains exactly the same as that of the depth-first traversal. We still take one element from the queue, process its value and then enqueue the children.</p><p class="calibre8"> To understand why the use of a queue lets us process nodes level by level, we need the following analysis:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Root is pushed in the beginning, so root is dequeued first and processed.</li><li class="listitem">When the root is processed, the children of root, that is the nodes in level 1, get enqueued. This means the level 1 nodes would be dequeued before any further levels are dequeued.</li><li class="listitem">When any node in level 1 is dequeued next, its children, which are the nodes of level 2, will all get enqueued. However, since all the nodes in level 1 are enqueued in the previous step, the nodes of level 2 will not be dequeued before the nodes of level 1 are dequeued. When all the nodes of level 1 are dequeued and processed, all the level 2 nodes would be enqueued because they are all children of level 1 nodes.</li><li class="listitem">This means<a id="id318" class="calibre1"/> all the level 2 nodes would be dequeued and processed before any nodes of higher levels are processed. When all the level 2 nodes are already processed, all the level 3 nodes<a id="id319" class="calibre1"/> would be enqueued.</li><li class="listitem">In a similar manner, in all further levels, all the nodes in a particular level will be processed before all the nodes of the next level are processed. In other words, the nodes will be process level by level.</li></ul></div></div></div></div></div>
<div class="book" title="The tree abstract data type" id="1AT9A1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec38" class="calibre1"/>The tree abstract data type</h1></div></div></div><p class="calibre8">Now that we <a id="id320" class="calibre1"/>have some idea of the tree, we can define the tree ADT. A tree ADT can be defined in multiple ways. We will check out two. In an imperative setting, that is, when trees are mutable, we can define a tree ADT as having the following operations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Get the root node</li><li class="listitem">Given a node, get its children</li></ul></div><p class="calibre8">This is all that is required to have a model for a tree. We may also include some appropriate mutation methods.</p><p class="calibre8">The recursive definition for the tree ADT can be as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A tree is an ordered pair containing the following:<div class="book"><ul class="itemizedlist1"><li class="listitem">a value</li><li class="listitem">a list of other trees, which are meant to be it's subtrees</li></ul></div></li></ul></div><p class="calibre8">We can develop a tree implementation in exactly the same way as it is defined in the functional tree ADT:</p><div class="informalexample"><pre class="programlisting">public class FunctionalTree&lt;E&gt; {
    private E value;
    private LinkedList&lt;FunctionalTree&lt;E&gt;&gt; children;</pre></div><p class="calibre8">As defined in the<a id="id321" class="calibre1"/> ADT, the tree is an ordered pair of a value and a list of other trees, as follows:</p><div class="informalexample"><pre class="programlisting">    public FunctionalTree(E value, LinkedList&lt;FunctionalTree&lt;E&gt;&gt; children) {
        this.children = children;
        this.value = value;
    }

    public  LinkedList&lt;FunctionalTree&lt;E&gt;&gt; getChildren() {
        return children;
    }

    public E getValue() {
        return value;
    }

    public void traverseDepthFirst(OneArgumentStatement&lt;E&gt; processor){
        processor.doSomething(value);
        children.forEach((n)-&gt; n.traverseDepthFirst(processor));
    }

}</pre></div><p class="calibre8">The implementation is quite simple. The depth-first traversal can be achieved using recursive calls to the children, which are indeed subtrees. A tree without any children needs to have an empty list of children. With this, we can create the functional version of the same tree that we had created for an imperative version:</p><div class="informalexample"><pre class="programlisting">public static void main(String [] args){
    LinkedList&lt;FunctionalTree&lt;Integer&gt;&gt; emptyList = LinkedList.emptyList();

    FunctionalTree&lt;Integer&gt; t1 = new FunctionalTree&lt;&gt;(5, emptyList);
    FunctionalTree&lt;Integer&gt; t2 = new FunctionalTree&lt;&gt;(9, emptyList);
    FunctionalTree&lt;Integer&gt; t3 = new FunctionalTree&lt;&gt;(6, emptyList);

    FunctionalTree&lt;Integer&gt; t4 = new FunctionalTree&lt;&gt;(2, emptyList);
    FunctionalTree&lt;Integer&gt; t5 = new FunctionalTree&lt;&gt;(5, emptyList.add(t1));
    FunctionalTree&lt;Integer&gt; t6 = new FunctionalTree&lt;&gt;(9, 
         emptyList.add(t3).add(t2));
    FunctionalTree&lt;Integer&gt; t7 = new FunctionalTree&lt;&gt;(6, emptyList);
    FunctionalTree&lt;Integer&gt; t8 = new FunctionalTree&lt;&gt;(2, emptyList);

    FunctionalTree&lt;Integer&gt; t9 = new FunctionalTree&lt;&gt;(5,
         emptyList.add(t6).add(t5).add(t4));
    FunctionalTree&lt;Integer&gt; t10 = new FunctionalTree&lt;&gt;(1,
         emptyList.add(t8).add(t7));

    FunctionalTree&lt;Integer&gt; tree = new FunctionalTree&lt;&gt;(1,
         emptyList.add(t10).add(t9));</pre></div><p class="calibre8">At the end, we can <a id="id322" class="calibre1"/>do a depth-first traversal to see if it outputs the same tree as before:</p><div class="informalexample"><pre class="programlisting">    tree.traverseDepthFirst(System.out::print);
}</pre></div></div>

<div class="book" title="Binary tree"><div class="book" id="1BRPS2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec39" class="calibre1"/>Binary tree</h1></div></div></div><p class="calibre8">A binary tree is a tree that has a maximum of two children per node. The two children can be <a id="id323" class="calibre1"/>called the left and the right child of a node. The following figure shows an example of a binary tree:</p><div class="mediaobject"><img src="../images/00045.jpeg" alt="Binary tree" class="calibre9"/><div class="caption"><p class="calibre15">Example binary tree</p></div></div><p class="calibre10"> </p><p class="calibre8">This particular tree is <a id="id324" class="calibre1"/>important mostly because of its simplicity. We can create a <code class="email">BinaryTree</code> class by inheriting the general tree class. However, it will be difficult to stop someone from adding more than two nodes and will take a lot of code just to perform the checks. So, instead, we will create a <code class="email">BinaryTree</code> class from scratch:</p><div class="informalexample"><pre class="programlisting">public class BinaryTree&lt;E&gt;  {</pre></div><p class="calibre8">The <code class="email">Node</code> has a very obvious implementation just like the generic tree:</p><div class="informalexample"><pre class="programlisting">    public static class Node&lt;E&gt;{
        private E value;
        private Node&lt;E&gt; left;
        private Node&lt;E&gt; right;
        private Node&lt;E&gt; parent;
        private BinaryTree&lt;E&gt; containerTree;

        protected Node(Node&lt;E&gt; parent,
        BinaryTree&lt;E&gt; containerTree, E value) {
            this.value = value;
            this.parent = parent;
            this.containerTree = containerTree;
        }

        public E getValue(){
            return value;
        }
    }</pre></div><p class="calibre8">Adding the root is exactly the same as that for a generic tree, except for the fact that we don't check for the <a id="id325" class="calibre1"/>existence of the root. This is just to save space; you can implement as required:</p><div class="informalexample"><pre class="programlisting">    private Node&lt;E&gt; root;

    public void addRoot(E value){
        root = new Node&lt;&gt;(null, this,  value);
    }

    public Node&lt;E&gt; getRoot(){
        return root;
    }</pre></div><p class="calibre8">The following method lets us add a child. It takes a Boolean parameter that is <code class="email">true</code> when the child to be added is the left child and <code class="email">false</code> otherwise:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; addChild(Node&lt;E&gt; parent, E value, boolean left){
        if(parent == null){
            throw new NullPointerException("Cannot add node to null parent");
        }else if(parent.containerTree != this){
            throw new IllegalArgumentException
                   ("Parent does not belong to this tree");
        }else {
            Node&lt;E&gt; child = new Node&lt;E&gt;(parent, this, value);
            if(left){
                parent.left = child;
            }else{
                parent.right = child;
            }
            return child;
        }
    }</pre></div><p class="calibre8">We now create two wrapper methods for specifically adding either the left or the right child:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; addChildLeft(Node&lt;E&gt; parent, E value){
        return addChild(parent, value, true);
    }

    public Node&lt;E&gt; addChildRight(Node&lt;E&gt; parent, E value){
        return addChild(parent, value, false);
    }

}</pre></div><p class="calibre8">Of course, the <a id="id326" class="calibre1"/>traversal algorithms for a generic tree would also work for this special case. However, for a binary tree, the depth-first traversal can be of three different types.</p></div>

<div class="book" title="Binary tree">
<div class="book" title="Types of depth-first traversals"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec48" class="calibre1"/>Types of depth-first traversals</h2></div></div></div><p class="calibre8">The depth-first traversal of a binary tree can be of three types according to when the parent node<a id="id327" class="calibre1"/> is processed with respect to when the <a id="id328" class="calibre1"/>child subtrees are processed. The orders can be summarized as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Pre-order traversal:<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Process<a id="id329" class="calibre1"/> the parent.</li><li class="listitem" value="2">Process the left subtree.</li><li class="listitem" value="3">Process the right subtree.</li></ol><div class="calibre13"/></div></li><li class="listitem">In-order traversal:<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Process the<a id="id330" class="calibre1"/> left subtree.</li><li class="listitem" value="2">Process the parent.</li><li class="listitem" value="3">Process the right subtree.</li></ol><div class="calibre13"/></div></li><li class="listitem">Post-order traversal:<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Process <a id="id331" class="calibre1"/>the left subtree.</li><li class="listitem" value="2">Process the right subtree.</li><li class="listitem" value="3">Process the parent.</li></ol><div class="calibre13"/></div></li></ul></div><p class="calibre8">These different traversal types will produce a slightly different ordering when traversing: </p><div class="informalexample"><pre class="programlisting">public static enum DepthFirstTraversalType{
    PREORDER, INORDER, POSTORDER
}

public void traverseDepthFirst(OneArgumentStatement&lt;E&gt; processor,
                      Node&lt;E&gt; current, DepthFirstTraversalType tOrder){
    if(current==null){
        return;
    }
    if(tOrder == DepthFirstTraversalType.PREORDER){
        processor.doSomething(current.value);
    }
    traverseDepthFirst(processor, current.left, tOrder);
    if(tOrder == DepthFirstTraversalType.INORDER){
        processor.doSomething(current.value);
    }
    traverseDepthFirst(processor, current.right, tOrder);
    if(tOrder == DepthFirstTraversalType.POSTORDER){
        processor.doSomething(current.value);
    }
}</pre></div><p class="calibre8">We have created an <code class="email">enum</code> <code class="email">DepthFirstTraversalType</code> to pass to the <code class="email">traverseDepthFirst</code> method. We process the current node according to its value. Note that the only thing that changes is when the processor is called to process a node. Let's create a <a id="id332" class="calibre1"/>binary tree and see how the results differ in the <a id="id333" class="calibre1"/>case of each ordering:</p><div class="informalexample"><pre class="programlisting">public static void main(String [] args){
    BinaryTree&lt;Integer&gt; tree = new BinaryTree&lt;&gt;();
    tree.addRoot(1);
    Node&lt;Integer&gt; n1 = tree.getRoot();
    Node&lt;Integer&gt; n2 = tree.addChild(n1, 2, true);
    Node&lt;Integer&gt; n3 = tree.addChild(n1, 3, false);
    Node&lt;Integer&gt; n4 = tree.addChild(n2, 4, true);
    Node&lt;Integer&gt; n5 = tree.addChild(n2, 5, false);
    Node&lt;Integer&gt; n6 = tree.addChild(n3, 6, true);
    Node&lt;Integer&gt; n7 = tree.addChild(n3, 7, false);
    Node&lt;Integer&gt; n8 = tree.addChild(n4, 8, true);
    Node&lt;Integer&gt; n9 = tree.addChild(n4, 9, false);
    Node&lt;Integer&gt; n10 = tree.addChild(n5, 10, true);

    tree.traverseDepthFirst(System.out::print, tree.getRoot(),
     DepthFirstTraversalType.PREORDER);
    System.out.println();

    tree.traverseDepthFirst(System.out::print, tree.getRoot(),
     DepthFirstTraversalType.INORDER);
    System.out.println();

    tree.traverseDepthFirst(System.out::print, tree.getRoot(),
     DepthFirstTraversalType.POSTORDER);
    System.out.println();
} </pre></div><p class="calibre8">We have <a id="id334" class="calibre1"/>created the same binary tree as shown in the <a id="id335" class="calibre1"/>previous figure. The following is the output of the program. Try to relate how the positions are getting affected:</p><div class="informalexample"><pre class="programlisting">1 2 4 8 9 5 10 3 6 7
8 4 9 2 10 5 1 6 3 7
8 9 4 10 5 2 6 7 3 1</pre></div><p class="calibre8">You can take a note of the following points while matching the program output:</p><div class="book"><ul class="itemizedlist"><li class="listitem">In the case of a pre-order traversal, in any path starting from the root to any leaf, a parent node will always be printed before any of the children.</li><li class="listitem">In the case of an in-order traversal, if we look at any path from the root to a particular leaf, whenever we move from the parent to the left child, the parent's processing is postponed. But whenever we move from the parent to the right child, the parent is immediately processed.</li><li class="listitem">In the case of a post-order traversal, all the children are processed before any parent is processed.</li></ul></div></div></div>

<div class="book" title="Binary tree">
<div class="book" title="Non-recursive depth-first search"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec49" class="calibre1"/>Non-recursive depth-first search</h2></div></div></div><p class="calibre8">The<a id="id336" class="calibre1"/> depth-first search we have seen for the <a id="id337" class="calibre1"/>general tree is pre-order in the sense that the parent node is processed before any of the children are processed. So, we can use the same implementation for the pre-order traversal of a binary tree:</p><div class="informalexample"><pre class="programlisting">public void traversePreOrderNonRecursive(
    OneArgumentStatement&lt;E&gt; processor) {
    Stack&lt;Node&lt;E&gt;&gt; stack = new StackImplLinkedList&lt;&gt;();
    stack.push(getRoot());
    while (stack.peek()!=null){
        Node&lt;E&gt; current = stack.pop();
        processor.doSomething(current.value);
        if(current.right!=null)
            stack.push(current.right);
        if(current.left!=null)
            stack.push(current.left);
    }
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8">We have to check whether the children are null. This is because the absence of children is expressed as null references instead of an empty list, as in the case of a generic tree.</p></div><p class="calibre8">Implementation <a id="id338" class="calibre1"/>of the in-order and post-order traversals is a bit tricky. We need to suspend processing of the parent node even when the <a id="id339" class="calibre1"/>children are expanded and pushed to the stack. We can achieve this by pushing each node twice. Once, we push it when it is first discovered due to its parent being expanded, and the next time we do it when its own children are expanded. So, we must remember which of these pushes caused it to be in the stack when it's popped. This is achieved using an additional flag, which is then wrapped up in a class called <code class="email">StackFrame</code>. The in-order algorithm is as follows:</p><div class="informalexample"><pre class="programlisting">public void traverseInOrderNonRecursive(
  OneArgumentStatement&lt;E&gt; processor) {
    class StackFame{
        Node&lt;E&gt; node;
        boolean childrenPushed = false;

        public StackFame(Node&lt;E&gt; node, boolean childrenPushed) {
            this.node = node;
            this.childrenPushed = childrenPushed;
        }
    }
    Stack&lt;StackFame&gt; stack = new StackImplLinkedList&lt;&gt;();
    stack.push(new StackFame(getRoot(), false));
    while (stack.peek()!=null){
       StackFame current = stack.pop();
        if(current.childrenPushed){
            processor.doSomething(current.node.value);
        }else{
            if(current.node.right!=null)
                stack.push(new StackFame(current.node.right, false));
            stack.push(new StackFame(current.node, true));
            if(current.node.left!=null)
                stack.push(new StackFame(current.node.left, false));
        }
    }
}</pre></div><p class="calibre8">Note that<a id="id340" class="calibre1"/> the stack is LIFO, so the thing that needs <a id="id341" class="calibre1"/>
<a id="id342" class="calibre1"/>to be popped later must be pushed earlier. The post-order version is extremely similar:</p><div class="informalexample"><pre class="programlisting">public void traversePostOrderNonRecursive(OneArgumentStatement&lt;E&gt; processor) {
    class StackFame{
        Node&lt;E&gt; node;
        boolean childrenPushed = false;

        public StackFame(Node&lt;E&gt; node, boolean childrenPushed) {
            this.node = node;
            this.childrenPushed = childrenPushed;
        }
    }
    Stack&lt;StackFame&gt; stack = new StackImplLinkedList&lt;&gt;();
    stack.push(new StackFame(getRoot(), false));
    while (stack.peek()!=null){
        StackFame current = stack.pop();
        if(current.childrenPushed){
            processor.doSomething(current.node.value);
        }else{
<span class="strong"><strong class="calibre2">            stack.push(new StackFame(current.node, true));</strong></span>
<span class="strong"><strong class="calibre2">            if(current.node.right!=null)</strong></span>
<span class="strong"><strong class="calibre2">                stack.push(new StackFame(current.node.right, false));</strong></span>

            if(current.node.left!=null)
                stack.push(new StackFame(current.node.left, false));
            }
    }
}</pre></div><p class="calibre8">Note that the only thing that has changed is the order of pushing the children and the parent. Now we write the following code to test these out:</p><div class="informalexample"><pre class="programlisting">public static void main(String [] args){
    BinaryTree&lt;Integer&gt; tree = new BinaryTree&lt;&gt;();
    tree.addRoot(1);
    Node&lt;Integer&gt; n1 = tree.getRoot();
    Node&lt;Integer&gt; n2 = tree.addChild(n1, 2, true);
    Node&lt;Integer&gt; n3 = tree.addChild(n1, 3, false);
    Node&lt;Integer&gt; n4 = tree.addChild(n2, 4, true);
    Node&lt;Integer&gt; n5 = tree.addChild(n2, 5, false);
    Node&lt;Integer&gt; n6 = tree.addChild(n3, 6, true);
    Node&lt;Integer&gt; n7 = tree.addChild(n3, 7, false);
    Node&lt;Integer&gt; n8 = tree.addChild(n4, 8, true);
    Node&lt;Integer&gt; n9 = tree.addChild(n4, 9, false);
    Node&lt;Integer&gt; n10 = tree.addChild(n5, 10, true);

    tree.traverseDepthFirst((x)-&gt;System.out.print(""+x), tree.getRoot(), DepthFirstTraversalType.PREORDER);
    System.out.println();
    tree.traverseDepthFirst((x)-&gt;System.out.print(""+x), tree.getRoot(), DepthFirstTraversalType.INORDER);
    System.out.println();
    tree.traverseDepthFirst((x)-&gt;System.out.print(""+x), tree.getRoot(), DepthFirstTraversalType.POSTORDER);
    System.out.println();

    System.out.println();
<span class="strong"><strong class="calibre2">    tree.traversePreOrderNonRecursive((x)-&gt;System.out.print(""+x));</strong></span>
<span class="strong"><strong class="calibre2">    System.out.println();</strong></span>
<span class="strong"><strong class="calibre2">    tree.traverseInOrderNonRecursive((x)-&gt;System.out.print(""+x));</strong></span>
<span class="strong"><strong class="calibre2">    System.out.println();</strong></span>
<span class="strong"><strong class="calibre2">    tree.traversePostOrderNonRecursive((x)-&gt;System.out.print(""+x));</strong></span>
<span class="strong"><strong class="calibre2">    System.out.println();</strong></span>

}</pre></div><p class="calibre8">We preserved<a id="id343" class="calibre1"/> the recursive versions as well so that <a id="id344" class="calibre1"/>we can compare the output, which is as follows:</p><div class="informalexample"><pre class="programlisting">1 2 4 8 9 5 10 3 6 7
8 4 9 2 10 5 1 6 3 7
8 9 4 10 5 2 6 7 3 1

1 2 4 8 9 5 10 3 6 7
8 4 9 2 10 5 1 6 3 7
8 9 4 10 5 2 6 7 3 1</pre></div><p class="calibre8">The first<a id="id345" class="calibre1"/> three lines are the same as the last <a id="id346" class="calibre1"/>three, showing that they produce the same result.</p></div></div>
<div class="book" title="Summary" id="1CQAE1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec40" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, you learned what a tree is. We started out with an actual implementation and then designed an ADT out of it. You also learned about a binary tree, which is just a tree with a maximum of two children per node. We also saw different traversal algorithms for a generic tree. They are depth-first and breadth-first traversals. In the case of a binary tree, a depth-first traversal can be done in three different ways: pre-order, in-order, and post-order. Even in the case of a generic tree, we can find equivalents of the pre-order and post-order traversals for a depth-first traversal. However, it is difficult to point to any particular equivalent of an in-order traversal as it is possible to have more than two children.</p><p class="calibre8">In the next chapter, we will see the use of a binary tree in searching, and we will see some other ways of searching as well.</p></div></body></html>