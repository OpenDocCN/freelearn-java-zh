<html><head></head><body>
		<div id="_idContainer084">
			<h1 class="chapter-number" id="_idParaDest-183"><a id="_idTextAnchor203"/>5</h1>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor204"/>Data Persistence and Relational Database Integration with Spring Data</h1>
			<p>Most applications handle their data in some way, necessitating the use of a database engine. This chapter discusses Relational Databases, the most widely used database technology. Relational databases remain a flexible and dependable option for a variety of application scenarios. Their organized, tabular data storage format with a defined schema suits many purposes. Additionally, relational databases offer essential benefits like enforcing data<a id="_idIndexMarker473"/> integrity, supporting complex queries, and adhering to <strong class="bold">ACID</strong> principles (<strong class="bold">Atomicity, Consistency, Isolation, Durability</strong>). They prove to be a suitable choice for applications ranging from simple to <span class="No-Break">mission-critical ones.</span></p>
			<p>Spring Data is a component of the Spring Framework, designed to streamline data access in Java applications. It offers a consistent programming model and an abstraction layer for interacting with various data stores, including relational databases and other types <span class="No-Break">of databases.</span></p>
			<p>There are two modules in Spring Data for relational databases: Spring Data JPA and Spring <span class="No-Break">Data JDBC.</span></p>
			<ul>
				<li>Spring Data JPA. This module provides integration with <strong class="bold">Java Persistence API</strong> (<strong class="bold">JPA</strong>), allowing developers to work<a id="_idIndexMarker474"/> with relational databases using <strong class="bold">Object-Relational Mapping</strong> principles (<strong class="bold">ORM</strong>). One of the benefits<a id="_idIndexMarker475"/> is that most of the code is database independent, not for the purpose of creating an application totally independent of the database, but to reuse the learnings regardless the underlaying database. In complex applications, taking advantage of vendor-specific features can be determinant for a successful project, so I recommend using all features available from a database engine. Trying to make an application that can be deployed in any database causes that your application will use only the minimum common set available in <span class="No-Break">all databases.</span></li>
				<li>Spring Data JDBC. This module offers more direct approach to database access, focusing on the use of plain SQL queries and direct mapping of data between Java objects and <span class="No-Break">database tables.</span></li>
			</ul>
			<p>We will use Spring Data JPA for the most common data access scenarios. From basic data operations such as Create, Read, Update, Delete (CRUD) to more advanced tasks such as complex queries, transactions, and database schema initialization and <span class="No-Break">schema upgrade.</span></p>
			<p>We will use PostgreSQL as a database engine, as it is Open Source, widely adopted, multiplatform and has a vibrant community around it. But as mentioned above, we could use the same principles to create an application using another relational database engine, such as MySQL, SQL Server <span class="No-Break">or Oracle.</span></p>
			<p>In this chapter we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Connecting your application <span class="No-Break">to Postgresql</span></li>
				<li>Creating and updating the <span class="No-Break">database schema</span></li>
				<li>Creating a <span class="No-Break">CRUD repository.</span></li>
				<li><span class="No-Break">Using JPQL.</span></li>
				<li>Using <span class="No-Break">Native queries.</span></li>
				<li><span class="No-Break">Updating operations</span></li>
				<li><span class="No-Break">Dynamic Queries</span></li>
				<li><span class="No-Break">Using Transactions</span></li>
				<li>Using Spring <span class="No-Break">Data JDBC.</span></li>
			</ul>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor205"/>Technical requirements</h1>
			<p>For this chapter, you will need a PostgreSQL server. The easiest way to deploy it in your local environment is by using Docker. You can get Docker from the product <span class="No-Break">page: </span><a href="https://www.docker.com/products/docker-desktop/"><span class="No-Break">https://www.docker.com/products/docker-desktop/</span></a></p>
			<p>If you prefer to install PostgreSQL in your computer, you can download it from the project <span class="No-Break">page: </span><a href="https://www.postgresql.org/download/"><span class="No-Break">https://www.postgresql.org/download/</span></a></p>
			<p>I also recommend installing PgAdmin to access the database. You can use it to observe the changes performed by your application in the database. You can download it from the project <span class="No-Break">page: </span><a href="https://www.pgadmin.org/download/"><span class="No-Break">https://www.pgadmin.org/download/</span></a></p>
			<p>You can use other tools, such as plugins for Visual Studio Code <span class="No-Break">or IntelliJ.</span></p>
			<p>You will need a code editor and OpenJDK as explained in the <span class="No-Break">previous chapter.</span></p>
			<p>All the recipes that will be demonstrated in this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor206"/>Connecting your application to PostgreSQL</h1>
			<p>You want to create a RESTful API<a id="_idIndexMarker476"/> to server Football data<a id="_idIndexMarker477"/> to your end users. To manage this data, we decided to use a relatational database, as we are interested in prodiving data consistency and advanced <span class="No-Break">query capabilities.</span></p>
			<p>In this recipe, we will connect an application, a RESTful API, to a PostgreSQL database. To do that, the first thing we’ll do is deploy a PostgreSQL database <span class="No-Break">in Docker.</span></p>
			<p>In this recipe you will learn how to create a basic application that connects to a PostgreSQL database and perform basic SQL queries <span class="No-Break">with JdbcTemplate.</span></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor207"/>Getting ready</h2>
			<p>For this recipe, you will need a PostgreSQL database. If you have already one server available, you can use it. Otherwise, you can use Docker to deploy a PostgreSQL in your computer. For that, you can execute the following command in your terminal to download and execute a <span class="No-Break">PostgreSQL instance:</span></p>
			<pre class="source-code">
docker run -itd -e POSTGRES_USER=packt -e POSTGRES_PASSWORD=packt -p 5432:5432 --name postgresql postgres</pre>			<p>You will have a PostgreSQL server available listening on port 5432, with username and password <em class="italic">packt</em>. If you want to change these parameters, you can modify the <span class="No-Break">command above.</span></p>
			<p>You will need a tool to perform some actions on PostgreSQL. I will use the command line tool psql. In Ubuntu you can install it using <em class="italic">apt,</em> the default <span class="No-Break">package manager:</span></p>
			<pre class="source-code">
sudo apt install postgresql-client</pre>			<p>Alternativelly to psql, you can use PgAdmin to connect to the database with a nice UI. I’ll explain the samples just with the command line using psql, but you can use PgAdmin to execute the database scripts if you want. Follow the instruction<a id="_idIndexMarker478"/> from the official page at <a href="https://www.pgadmin.org/download/">https://www.pgadmin.org/download/</a> to install it in <span class="No-Break">your computer.</span></p>
			<p>You will find the sql scripts in the book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span></a><span class="No-Break">.</span></p>
			<p>As usual, we will use Spring Initializr tool to create our projects, or the integrated tool in your favorite IDE or editor if <span class="No-Break">you prefer.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor208"/>How to do it...</h2>
			<p>Once we have our PostgreSQL server<a id="_idIndexMarker479"/> ready as explained in <em class="italic">Getting Ready</em>, we will create<a id="_idIndexMarker480"/> a database. After this, we will create a Spring Boot application that will connect to the database to perform a <span class="No-Break">simple query.</span></p>
			<ol>
				<li>First, download the postgresql scripts available in the GitHub repository. They are located in <strong class="source-inline">chapter5/recipe5-1/start/sql</strong>. There are two <span class="No-Break">script files:</span><ul><li><strong class="source-inline">db-creation.sql</strong>. This script creates a database named <strong class="source-inline">football</strong>, with two tables: <strong class="source-inline">teams</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">players</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">insert-data.sql</strong>. This script inserts sample data in the <strong class="source-inline">teams</strong> and <span class="No-Break"><strong class="source-inline">players</strong></span><span class="No-Break"> tables.</span></li></ul></li>
				<li>Next, we’ll execute the scripts in the database to execute the scripts. For that, open a terminal and execute the following commands to execute the scripts in PostgreSQL using the <span class="No-Break"><em class="italic">psql</em></span><span class="No-Break"> tool.</span><pre class="source-code">
psql -h localhost -U packt -f db-creation.sql
psql -h localhost -U packt -f insert-data.sql</pre><p class="list-inset">It will request the password. Introduce <em class="italic">packt</em> as configured in the <em class="italic">Getting Ready</em> section. If you used different parameters in the <em class="italic">Getting Ready</em> section, use <span class="No-Break">it accordingly.</span></p><p class="list-inset">Alternatively, you can use <em class="italic">PgAdmin</em> tool instead of <span class="No-Break"><em class="italic">psql</em></span><span class="No-Break"> tool.</span></p></li>				<li>The database schema we just created looks <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer079">
					<img alt="Figure 5.1: Database schema. Exported with PgAdmin tool." src="image/B21646_05_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: Database schema. Exported with PgAdmin tool.</p>
			<ol>
				<li value="4">Let’s create a new Spring Boot <a id="_idIndexMarker481"/>application connecting<a id="_idIndexMarker482"/> to the database using <em class="italic">Spring Initializr</em> tool. We’ll use the same parameters as in <em class="italic">Creating a RESTful API</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, except changing the <span class="No-Break">following options:</span><ul><li><span class="No-Break"><strong class="bold">Artifact</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">footballpg</strong></span></li><li><strong class="bold">Dependencies</strong>: <strong class="bold">Spring Web</strong>, <strong class="bold">Spring Data JPA</strong>, <span class="No-Break"><strong class="bold">PostgreSQL Driver</strong></span></li></ul></li>
				<li>Next, we’ll configure the application to connect to the PostgreSQL database. For that, create an <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder and set the <span class="No-Break">following content:</span><pre class="source-code">
spring:
    datasource:
        url: jdbc:postgresql://localhost:5432/football
        username: packt
        password: packt</pre></li>				<li>Now, create a new service class named <strong class="source-inline">TeamsService</strong>. This class will use JdbcTemplate to perform the queries against the database. For that, it’s necessary to inject <span class="No-Break">a JdbcTemplate.</span><pre class="source-code">
@Service
public class TeamsService {
    private JdbcTemplate jdbcTemplate;
    public TeamsService(<strong class="bold">JdbcTemplate jdbcTemplate</strong>) {
        this.jdbcTemplate = jdbcTemplate;
    }
}</pre></li>				<li>We’ll create a method<a id="_idIndexMarker483"/> in the <em class="italic">TeamsService</em> that gets the total number <a id="_idIndexMarker484"/>of teams. You can name the <span class="No-Break">method </span><span class="No-Break"><strong class="source-inline">getTeamCount</strong></span><span class="No-Break">:</span><pre class="source-code">
public int getTeamCount() {
    return <strong class="bold">jdbcTemplate.queryForObject</strong>("SELECT COUNT(*) FROM teams", Integer.class);
}</pre><p class="list-inset">We used the jdbcTemplate method queryForObject to perform an SQL query to get a <span class="No-Break">single value.</span></p></li>				<li>You can now create a RestController using this service. I made a sample controller that uses the <strong class="source-inline">TeamsService</strong>. You can find it in the book’s repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span></a><span class="No-Break">.</span></li>
			</ol>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor209"/>How it works...</h2>
			<p>In our configuration<a id="_idIndexMarker485"/> file <strong class="source-inline">application.yml</strong>, we have defined<a id="_idIndexMarker486"/> a data source. Within the data source, we have used a URL, a username, and a password. However, it is also possible to define additional properties. Alternatively, we can use only the URL. The URL contains important information such as the type of the database (in our case, PostgreSQL), the host, the port, and the database name. Although it’s possible to pass the username and password in the URL, we used specific fields to <span class="No-Break">enhance clarity.</span></p>
			<p>Since we specified PostgreSQL as the database, it is essential to have a driver registered in the class path. We achieved that by adding the dependency to the <span class="No-Break">PostgreSQL driver.</span></p>
			<p>A data source object is registered in the dependency container by defining a data source in the configuration file. Spring Data JPA uses that data source to create JdbcTemplates when needed, for instance, it creates a JdbcTemplate instance and injects it into the <span class="No-Break"><strong class="source-inline">TeamsService</strong></span><span class="No-Break"> class.</span></p>
			<p>JdbcTemplate handles the creation and release of resources and converts <strong class="source-inline">SQLExceptions</strong> into Spring’s <strong class="source-inline">DataAccessExceptions</strong>. In this example, we used a very simple query that does not require any parameter and returns an Integer. Still, JdbcTemplate allows passing parameters to your query and mapping the results to complex classes. We won’t extend much on these capabilities in this book; rather, we’ll go deeper into JPA and Hibernate capabilities to map complex entities and relations to classes. We’ll see that in from <em class="italic">Using Hibernate</em> <span class="No-Break">recipe onwards.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor210"/>There’s more...</h2>
			<p>JdbcTemplate can be used to retrieve results<a id="_idIndexMarker487"/> that are not limited to scalar values. For instance, assuming that we have a <strong class="source-inline">Team</strong> class, we can define the following method that uses the <strong class="source-inline">query</strong> method to retrieve <span class="No-Break">all teams:</span></p>
			<pre class="source-code">
public List&lt;Team&gt; getTeams() {
  return jdbcTemplate.<strong class="bold">query</strong>("SELECT * FROM teams", (rs, rowNum) -&gt; {
    Team team = new Team();
    team.setId(rs.getInt("id"));
    team.setName(rs.getString("name"));
    return team;
 });
}</pre>			<p>In this example, we use an anonymous <strong class="source-inline">RowMapper</strong> that transforms each row into <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Team</strong></span><span class="No-Break">.</span></p>
			<p>You can also pass arguments to your query. For instance, let’s retrieve a <span class="No-Break">specific team:</span></p>
			<pre class="source-code">
public Team getTeam(int <strong class="bold">id</strong>) {
    return jdbcTemplate.queryForObject(
       "SELECT * FROM teams WHERE <strong class="bold">id = ?</strong>",
       new BeanPropertyRowMapper&lt;&gt;(Team.class),
       <strong class="bold">id</strong>);
}</pre>			<p>This time, we used a <strong class="source-inline">BeanPropertyRowMapper</strong> to map the resulting row to Team. This class infers the target properties to map the columns of the <span class="No-Break">resulting rows.</span></p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor211"/>Using JdbcClient to access the database</h1>
			<p>In the previous recipe, we used<a id="_idIndexMarker488"/> JdbcTemplate to access<a id="_idIndexMarker489"/> the database. The JdbcClient is an enhanced JDBC client that provides a Fluent interaction mode. JdbcClient has been introduced in Spring Framework 6.1, and it’s available since Spring <span class="No-Break">Boot 3.2.</span></p>
			<p>In this recipe, we’ll learn how to use JdbcClient by performing some simple queries to <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor212"/>Getting ready</h2>
			<p>In this recipe, we’ll need a PostgreSQL database. You can reuse the same database created in the previous recipe, <em class="italic">Connecting your application to PostgreSQL</em>. You can reuse the project from the same recipe as well, as the dependencies are the same. I prepared a working version that you can use as a starting point for this recipe. You can find it in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in <span class="No-Break"><strong class="source-inline">chapter5/recipe5-2/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor213"/>How to do it...</h2>
			<p>Let’s prepare some queries<a id="_idIndexMarker490"/> using JdbcClient instead<a id="_idIndexMarker491"/> <span class="No-Break">of JdbcTemplate.</span></p>
			<ol>
				<li>Let’s start by creating a new service class named <strong class="source-inline">PlayersService</strong> and inject a JdbcClient in <span class="No-Break">the constructor:</span><pre class="source-code">
@Service
public class PlayersService {
    <strong class="bold">private JdbcClient jdbcClient;</strong>
    public PlayersService(JdbcClient jdbcClient) {
        this.jdbcClient = jdbcClient;
    }
}</pre></li>				<li>Create a class named <strong class="source-inline">Player</strong>. This class should have the same fields as the table <strong class="source-inline">players</strong> created in the <em class="italic">Connecting your application to PostgreSQL</em> recipe. You can find an implementation of this class in the book’s repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span></a><span class="No-Break">.</span></li>
				<li>Now, we can create methods in the <strong class="source-inline">PlayersService</strong> to interact with <span class="No-Break">the database:</span><ul><li>Let’s create a method named <strong class="source-inline">getPlayers</strong> to retrieve <span class="No-Break">all players:</span><pre class="source-code">
public List&lt;Player&gt; getPlayers() {
    return jdbcClient.sql("SELECT * FROM players")
            .query(Player.class)
            .list();
}</pre></li><li>We can create a method<a id="_idIndexMarker492"/> named <strong class="source-inline">getPlayer</strong> to retrieve<a id="_idIndexMarker493"/> a single <strong class="source-inline">Player</strong>. We can use a parameter in the <span class="No-Break">SQL query.</span><pre class="source-code">Public Player getPlayer(int id) {
    return jdbcClient.sql("SELECT * FROM players WHERE id = :id")
            .param("id", id)
            .query(Player.class)
            .single();
}</pre></li><li>Let’s do a method to create a new <strong class="source-inline">Player</strong>. Name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">createPlayer</strong></span><span class="No-Break">:</span><pre class="source-code">public Player createPlayer(Player player) {
    GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
   jdbcClient.sql("""
     INSERT INTO players (jersey_number, name, position, date_of_birth, team_id)
     VALUES (:jersey_number, :name, :position, :date_of_birth, :team_id)
                  """)
           .param("name", player.getName())
           .param("jersey_number", player.getJerseyNumber())
           .param("position", player.getPosition())
           .param("date_of_birth", player.getDateOfBirth())
           .param("team_id", player.getTeamId())
           .update(keyHolder, "id");
    player.setId(keyHolder.getKey().intValue());
    return player;
}</pre></li></ul></li>				<li>You can create a controller that uses the <strong class="source-inline">PlayerService</strong>. I prepared a working version that you can find in the book’s GitHub repository <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span></a><span class="No-Break">.</span></li>
			</ol>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor214"/>How it works...</h2>
			<p>The mechanism used by the JdbcClient to create a connection to the database is like the JdbcTemplate. Spring Data JPA uses the data source configured in the application and injects it in <span class="No-Break">the JdbcClient.</span></p>
			<p>The JdbcClient provides a Fluent<a id="_idIndexMarker494"/> way to interact with the database, making<a id="_idIndexMarker495"/> the development more intuitive and reducing the boilerplate code. It allows using named parameters very easily, as we saw in the methods <strong class="source-inline">getPlayer</strong> and <strong class="source-inline">createPlayer</strong>. It also provides automatic mapping, with no need to define a <strong class="source-inline">RowMapper</strong> to process <span class="No-Break">each row.</span></p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor215"/>Using an ORM to access the database</h1>
			<p>Accessing a database performing<a id="_idIndexMarker496"/> SQL requests can be performant<a id="_idIndexMarker497"/> and can work for simple applications. However, when the application becomes more complex and the database schema grows, it can be interesting using an <strong class="bold">Object-Relational Mapping</strong> (<strong class="bold">ORM</strong>) framework to access the database using an <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) layer. Probably, the most<a id="_idIndexMarker498"/> popular ORM <a id="_idIndexMarker499"/>framework in Java is <strong class="bold">Hibernate</strong>, and Spring Data JPA<a id="_idIndexMarker500"/> uses Hibernate as its default <strong class="bold">Java Persistence API</strong> (<span class="No-Break"><strong class="bold">JPA</strong></span><span class="No-Break">) implementation.</span></p>
			<p>In this recipe, we will create entity classes that can be mapped to the database schema, and we’ll interact with the database without writing a single line <span class="No-Break">of SQL.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor216"/>Getting ready</h2>
			<p>You will need a PostgreSQL<a id="_idIndexMarker501"/> database for this recipe. You can reuse<a id="_idIndexMarker502"/> the database created in the <em class="italic">Connecting your application to PostgreSQL</em> recipe. If you haven’t completed that recipe yet, you can complete the first two steps of that recipe to create <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor217"/>How to do it...</h2>
			<p>Once we have our PostgreSQL server ready, as explained in <em class="italic">Getting Ready</em>, we will create a database, and we will fill it with some data. After this, we will create a RESTfull project to connect to the database to retrieve <span class="No-Break">the data.</span></p>
			<ol>
				<li>Let’s create a project connected to this database. We will use Spring Initialzr tool by opening https://start.spring.io in <span class="No-Break">your browser.</span><p class="list-inset">We will use the usual parameters as in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, with the following <span class="No-Break">specific parameters:</span></p><ul><li><span class="No-Break"><strong class="bold">Artifact</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">footballpg</strong></span></li><li><strong class="bold">Dependencies</strong>: <strong class="bold">Spring Web</strong>, <strong class="bold">Spring Data JPA</strong>, <span class="No-Break"><strong class="bold">PostgreSQL Driver</strong></span></li></ul></li>
				<li>In this project, create the entity classes to map with the <span class="No-Break">database tables.</span><ul><li>Create a file named <strong class="source-inline">TeamEntity.java</strong> containing a class to map with <span class="No-Break">table </span><span class="No-Break"><strong class="source-inline">teams</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">@Table(name = "teams")</strong>
<strong class="bold">@Entity</strong>
public class TeamEntity {
    <strong class="bold">@Id</strong>
    private Integer id;
    private String name;
    <strong class="bold">@OneToMany(cascade = CascadeType.ALL, mappedBy = "team")</strong>
    private List&lt;PlayerEntity&gt; players;
}</pre></li><li>Create a file named <strong class="source-inline">PlayerEntity.java</strong> containing<a id="_idIndexMarker503"/> the class to map<a id="_idIndexMarker504"/> with <span class="No-Break">table </span><span class="No-Break"><strong class="source-inline">players</strong></span><span class="No-Break">.</span><pre class="source-code"><strong class="bold">@Table(name = "players")</strong>
<strong class="bold">@Entity</strong>
public class PlayerEntity {
    <strong class="bold">@Id</strong>
    private Integer id;
    private Integer jerseyNumber;
    private String name;
    private String position;
    private LocalDate dateOfBirth;
    <strong class="bold">@ManyToOne(fetch = FetchType.LAZY)</strong>
<strong class="bold">    @JoinColumn(name = "team_id")</strong>
    private TeamEntity team;
}</pre></li></ul></li>				<li>Create two repository interfaces to access the database using the entities we created in the <span class="No-Break">previous step.</span><ul><li>Create a file named <strong class="source-inline">TeamRepository.java</strong> with the <span class="No-Break">following interface:</span><pre class="source-code">
public interface TeamRepository extends CrudRepository&lt;TeamEntity, Integer&gt;{
}</pre></li><li>Create a file named <strong class="source-inline">PlayerRepository.java</strong> containing the <span class="No-Break">following interface:</span><pre class="source-code">public interface PlayerRepository extends JpaRepository&lt;PlayerEntity, Integer&gt;{
    List&lt;PlayerEntity&gt; findByDateOfBirth(LocalDate dateOfBirth);
    List&lt;PlayerEntity&gt; findByNameContaining(String name);
}</pre></li></ul></li>				<li>Create a service<a id="_idIndexMarker505"/> class named <strong class="source-inline">FootballService</strong> using<a id="_idIndexMarker506"/> <span class="No-Break">both repositories:</span><pre class="source-code">
@Service
public class FootballService {
    private PlayerRepository playerRepository;
    private TeamRepository teamRepository;
    public FootballService(PlayerRepository playerRepository, TeamRepository teamRepository) {
        this.playerRepository = playerRepository;
        this.teamRepository = teamRepository;
    }
}</pre></li>				<li>Create two classes representing the <span class="No-Break">data exposed:</span><ul><li><span class="No-Break"><strong class="source-inline">Team</strong></span><span class="No-Break">:</span><pre class="source-code">
public record Team(Integer id, String name, List&lt;Player&gt; players) {
}</pre></li><li><span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break">:</span><pre class="source-code">public record Player(String name, Integer jerseyNumber, String position, LocalDate dateOfBirth) {
}</pre></li></ul></li>				<li>Add a couple of methods<a id="_idIndexMarker507"/> to find players<a id="_idIndexMarker508"/> using <span class="No-Break">different criteria:</span><ul><li>Search players that contain a given string in <span class="No-Break">the name:</span><pre class="source-code">
public List&lt;Player&gt; searchPlayers(String name) {
        return playerRepository.findByNameContaining(name)
                .stream()
                .map(player -&gt; new Player(player.getName(), player.getJerseyNumber(), player.getPosition(), player.getDateOfBirth()))
                .toList();
    }</pre></li><li>Search players by <span class="No-Break">birth date:</span><pre class="source-code">public List&lt;Player&gt; searchPlayersByBirthDate(LocalDate date) {
        return playerRepository.findByDateOfBirth(date)
                .stream()
                .map(player -&gt; new Player(player.getName(), player.getJerseyNumber(), player.getPosition(), player.getDateOfBirth()))
                .toList();
    }</pre></li></ul></li>				<li>Add a method<a id="_idIndexMarker509"/> to return a <strong class="source-inline">Team</strong>, including<a id="_idIndexMarker510"/> <span class="No-Break">its players:</span><pre class="source-code">
@Transactional(readOnly=true)
public Team getTeam(Integer id) {
    TeamEntity team = teamRepository.findById(id).orElse(null);
   if (team == null) {
       return null;
   } else {
       return new Team(team.getId(),
               team.getName(),
               team.getPlayers()
               .stream()
               .map(player -&gt; new Player(player.getName(), player.getJerseyNumber(), player.getPosition(),
                                    player.getDateOfBirth()))
               .toList());
   }
}</pre></li>				<li>Create a <span class="No-Break">new team:</span><pre class="source-code">
public Team createTeam(String name) {
   Random random = new Random();
   TeamEntity team = new TeamEntity();
   Integer randomId = random.nextInt();
   if (randomId &lt; 0) {
         randomId = random.nextInt();
   }
   team.setId(randomId);
   team.setName(name);
   team = teamRepository.save(team);
   return new Team(team.getId(), team.getName(), List.of());
}</pre></li>				<li>Update the<a id="_idIndexMarker511"/> position<a id="_idIndexMarker512"/> of <span class="No-Break">a player:</span><pre class="source-code">
public Player updatePlayerPosition(Integer id, String position) {
    PlayerEntity player = playerRepository.findById(id).orElse(null);
   if (player == null) {
       return null;
   } else {
       player.setPosition(position);
       player = playerRepository.save(player);
       return new Player(player.getName(), player.getJerseyNumber(), player.getPosition(),
                    player.getDateOfBirth());
   }
}</pre></li>				<li>Now, you can create a controller using the service to expose the application’s logic. You can find a complete example in the book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span></a><span class="No-Break">.</span></li>
				<li>Now configure the application<a id="_idIndexMarker513"/> to connect to PostgreSQL<a id="_idIndexMarker514"/> database. Under <strong class="source-inline">resources</strong> folder, create a file named <strong class="source-inline">application.yml</strong>. Set the <span class="No-Break">following configuration:</span><pre class="source-code">
spring:
    jpa:
        database-platform: org.hibernate.dialect.PostgreSQLDialect
        open-in-view: false
    datasource:
        url: jdbc:postgresql://localhost:5432/football
        username: packtd
        password: packtd</pre></li>				<li>Now you can execute and test the application. You can use the instructions from <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> to test the application using curl. I also provided a script that you can find in the repository with curl requests for this application. It is located <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">chapter2/recipe2-1/end/scripts/requests.sh</strong></span></li>
			</ol>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor218"/>How it works...</h2>
			<p>Hibernate is an <strong class="bold">Object-Relational Mapping</strong> (<strong class="bold">ORM</strong>) framework. Its primary goal is to bridge the gap between the Java programming language and relational databases. Using annotations such as @Entity, @Table, @Id, @OneToMany, @ManyToOne, and others not used in this recipe, Hibernate maps the classes to database tables. These <a id="_idIndexMarker515"/>mapped classes are known as <em class="italic">Entities</em>. Hibernate also provides other features, such as transaction management, query capabilities, caching, and <span class="No-Break">lazy loading.</span></p>
			<p>Hibernate is the default JPA<a id="_idIndexMarker516"/> provider for Spring<a id="_idIndexMarker517"/> Data JPA. Spring Data JPA allows you to define Repository interfaces to interact with your data model. Just by extending the <strong class="source-inline">CrudRepository</strong> interface, it automatically generates the necessary JPA operations to provide Create, Read, Update, and Delete operations for your Entities. When using <strong class="source-inline">JpaRepository</strong>, Spring Data JPA generates the necessary JPA queries based on <span class="No-Break">method names.</span></p>
			<p>For instance, we used <strong class="source-inline">findByDateOfBirth</strong> to create a method that returns all players by their date of birth and <strong class="source-inline">findByNameContaining</strong> to return all players whose names contain a given string. All this without writing a single line <span class="No-Break">of SQL!</span></p>
			<p>If you are unfamiliar with the naming <a id="_idIndexMarker518"/>convention, I strongly recommend checking the project documentation. <span class="No-Break">See </span><a href="https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords"><span class="No-Break">https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords</span></a><span class="No-Break">.</span></p>
			<p>In addition to the operations to read data, <strong class="source-inline">CrudRepository</strong> and <strong class="source-inline">JpaRepository</strong> have a method named <strong class="source-inline">save</strong>. This method allows you to update existing entities or create new ones if they don’t already exist. They also have some methods to delete entities, such as <strong class="source-inline">delete</strong>, <strong class="source-inline">deleteById</strong> and <span class="No-Break">other methods.</span></p>
			<p>Even with the abstraction offered by Spring Data JPA, it’s crucial to understand some of the inner workings of Spring Data. In this recipe, I used a middle tier component named <strong class="source-inline">FootballService</strong> between the controller and the repositories. You could also call a repository directly from your controller, however there are some caveats with this approach. To better understand it, lets deep dive on the operation to return a team and <span class="No-Break">its players.</span></p>
			<p>Hibernate has two ways of loading the entities with related entities: <strong class="bold">Lazy</strong> and <strong class="bold">Eager</strong>. Lazy means that Hibernate<a id="_idIndexMarker519"/> will retrieve a related entity just when the member mapping the related entity is used. Eager, the other<a id="_idIndexMarker520"/> way, will retrieve the related data at the same time than the main entity is retrieved. Let’s see this behavior with an example. The <strong class="source-inline">TeamEntity</strong> has a member annotated with @OneToMany to manage its Player Entities. When your application uses the method <strong class="source-inline">getPlayers</strong> of the class <strong class="source-inline">TeamEntity</strong>, Hibernate tries to load the players by performing a request to the database. By default, @OneToMany relations are loaded in Lazy mode, while @ManyToOne are loaded in Eager mode. In summary, Lazy means, that if you don’t use the relation, the request to the database won’t happen. If you use the repository to retrieve the team<a id="_idIndexMarker521"/> in the controller<a id="_idIndexMarker522"/> and you try to return the <strong class="source-inline">TeamEntity</strong>, it will serialize the entity into a Json object, traversing all properties, including the players. At that stage of the request execution, there is no session open to access the database and you will receive an exception. There are several ways to fix <span class="No-Break">this issue:</span></p>
			<ul>
				<li>By retrieving the players at the same time as the team by using the Eager mode. It can be valid in certain scenarios, but it could cause unnecessary requests to <span class="No-Break">the database.</span></li>
				<li>By allowing opening connections in view. This can be done using <strong class="source-inline">spring.jpa.open-in-view=true</strong>. This is an antipattern and I strongly recommend not <span class="No-Break">using it.</span><p class="list-inset">I had a bad experience related to this antipattern working on a project. I had an issue related to bad performance and availability of the application, but the system had resources and any component seemed under stress. Finally, I realized there were connection leaks in the application due to this <strong class="source-inline">open-in-view</strong> option. Finding the root cause and resolving this bug was one of the most challenging tasks I’ve encountered, as figuring out the root cause was <span class="No-Break">not obvius.</span></p><p class="list-inset">By the way, <strong class="source-inline">spring.jpa.open-in-view=true</strong> is the default value in Spring Boot, so keep this in mind and configure as false unless you have a good reason that I <span class="No-Break">cannot imagine.</span></p></li>
				<li>By creating a session or a transaction while you are retrieving the data, including the lazy relations. This is the approach followed in this recipe. When mapping from <strong class="source-inline">TeamEntity</strong> to <strong class="source-inline">Team</strong>, we used the method <strong class="source-inline">getPlayers</strong>, and hence retrieved the data from the database. As the method <strong class="source-inline">getTeam</strong> in the <strong class="source-inline">FootballService</strong> is marked as <strong class="source-inline">@Transactional</strong>, all requests happen in the same transaction/session. As this is a read operation, you can set <strong class="source-inline">@Transactional(readOnly = true)</strong>, for having a less costly isolation mode for <span class="No-Break">your transaction.</span></li>
				<li>By performing a <strong class="source-inline">Join</strong> query to retrieve both the team and its players in a single database request. This is the most efficient way to implement this scenario. We will see how to do it in another recipe of <span class="No-Break">this chapter.</span></li>
			</ul>
			<p>That is the reason<a id="_idIndexMarker523"/> to create a <strong class="source-inline">Service</strong> class<a id="_idIndexMarker524"/> and not return Entities directly in the <span class="No-Break">RESTful API.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor219"/>There’s more...</h2>
			<p>In this exercise, we used an existing database, and we manually created the entities and repositories to interact with the database. There is another approach that we will tackle in further recipes of this chapter, that defines the entities first and then generates the database automatically. For both scenarios there are tools that assist you in this task that can be very mechanical. For instance, you can use<a id="_idIndexMarker525"/> JPA Buddy plugin for IntelliJ, <a href="https://plugins.jetbrains.com/plugin/15075-jpa-buddy">https://plugins.jetbrains.com/plugin/15075-jpa-buddy</a>. It has a basic free version that is enough for simple scenarios, and a paid one with <span class="No-Break">advanced features.</span></p>
			<p>In this recipe, we created some code to transform Entities<a id="_idIndexMarker526"/> into other objects, also known as <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>). It could add a lot of boilerplate code in your project. There are libraries that automate mapping between Java Beans that can fit well in this scenario. For<a id="_idIndexMarker527"/> example Mapstruct (https://mapstruct.org/). Spring Data JPA supports using Mapstruct to convert Entities to DTO and viceversa. For learning purposes, I don’t use it in <span class="No-Break">the recipes.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor220"/>See also</h2>
			<p>If you want<a id="_idIndexMarker528"/> to learn more about <strong class="bold">Open Session In View</strong> (<strong class="bold">OSIV</strong>) antipattern, I recommend<a id="_idIndexMarker529"/> you to read this article <a href="https://vladmihalcea.com/the-open-session-in-view-anti-pattern/">https://vladmihalcea.com/the-open-session-in-view-anti-pattern/</a> to understand <span class="No-Break">the details.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor221"/>Creating the database schema from our code</h1>
			<p>Creating a database schema<a id="_idIndexMarker530"/> and its corresponding Entities<a id="_idIndexMarker531"/> in our application, as seen in the previous recipe, requires a lot of repetitive work. Instead, we can create our Entities and we can generate the database schema automatically. In this recipe, we will use Spring Data JPA to generate the database schema based on the entity model of <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor222"/>Getting ready</h2>
			<p>For this recipe, you will need the same tools as in the previous recipe, namely a PostgreSQL server that you can run in a Docker container or on <span class="No-Break">your computer.</span></p>
			<p>We will use the same code generated in the previous recipe. If you didn’t complete it, you can find a completed recipe in the book’s GitHub <span class="No-Break">repository </span><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor223"/>How to do it...</h2>
			<p>We will use the previous example about football teams and players. Still, in this recipe, instead of using an existing database and creating the mapping entities, we will go in the opposite direction. We will use and tune the Entities already created to generate the Database schema. <span class="No-Break">Let’s begin:</span></p>
			<ol>
				<li>Create a new database <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">football2</strong></span><span class="No-Break">.</span><ul><li>Open psql in <span class="No-Break">your terminal.</span><pre class="source-code">
psql -h localhost -U packtd</pre></li><li>Execute the following SQL command to create <span class="No-Break">the database:</span><pre class="source-code">CREATE DATABASE football2;</pre></li></ul></li>				<li>Instead of manually generating the identifiers of our entities we will rely on the automatic identifier generators of the database. For that<a id="_idIndexMarker532"/> purpose, we will modify<a id="_idIndexMarker533"/> the annotation <strong class="source-inline">@Id</strong> of <span class="No-Break">our entities.</span><ul><li>Open <strong class="source-inline">TeamEntity</strong> and modify the member id <span class="No-Break">as follows:</span><pre class="source-code">
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Integer id;</pre></li><li>Do the same <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">PlayerEntity</strong></span><span class="No-Break">.</span></li></ul></li>				<li>Open <strong class="source-inline">application.yml</strong> file and add the <strong class="source-inline">spring.jpa.generate-ddl=true</strong> and <strong class="source-inline">spring.sql.init.mode=always</strong> properties. The file should look <span class="No-Break">like this:</span><pre class="source-code">
spring:
    jpa:
        database-platform: org.hibernate.dialect.PostgreSQLDialect
        open-in-view: false
        <strong class="bold">generate-ddl: true</strong>
    sql:
        init:
            mode: always
    datasource:
        url: jdbc:postgresql://localhost:5432/football2
        username: packtd
        password: packtd</pre><p class="list-inset">If you run the application, the database schema will be <span class="No-Break">created automatically.</span></p></li>				<li>Modify the <strong class="source-inline">createTeam</strong> method in <span class="No-Break">class </span><span class="No-Break"><strong class="source-inline">FootballService</strong></span><span class="No-Break">:</span><pre class="source-code">
public Team createTeam(String name) {
    TeamEntity team = new TeamEntity();
    team.setName(name);
    team = teamRepository.save(team);
    return new Team(team.getId(), team.getName(), List.of());
}</pre><p class="list-inset">Here, we removed the generation of the team identifier, instead it will be <span class="No-Break">automatically generated.</span></p></li>				<li>Copy the file located in the GitHub<a id="_idIndexMarker534"/> repository, in <strong class="source-inline">chapter5/recipe5-4/start/data.sql</strong>, to the resources<a id="_idIndexMarker535"/> folder. This folder is located <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">src/main/resources</strong></span><span class="No-Break">.</span></li>
				<li>Execute <span class="No-Break">the application.</span></li>
				<li>Test the application by performing requests to the application as explained in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. I also provided a script that you can find in the repository with curl requests for this application. It is located <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">chapter5/recipe5-4/end/scripts/requests.sh</strong></span><span class="No-Break">.</span><p class="list-inset">You will see that the database schema is initialized, and it already <span class="No-Break">has data.</span></p></li>
			</ol>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor224"/>How it works...</h2>
			<p>By configuring the application with <em class="italic">spring.jpa.generate-ddl=true</em>, Spring Data will automatically generate the data schema from the entities defined in the project. It will use the annotations to generate the schema according to the target database. For instance, we used <strong class="source-inline">@GeneratedValue</strong> for id field in both <strong class="source-inline">PlayerEntity</strong> and <strong class="source-inline">TableEntity</strong>. It is translated into a PostgreSQL sequences. Taking the <strong class="source-inline">TeamEntity</strong> as an example, this is the result <span class="No-Break">in PostgreSQL:</span></p>
			<pre class="source-code">
CREATE TABLE IF NOT EXISTS public.teams
(
    id integer NOT NULL DEFAULT nextval('teams_id_seq'::regclass),
    name character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT teams_pkey PRIMARY KEY (id)
)
CREATE SEQUENCE IF NOT EXISTS public.teams_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1
    OWNED BY teams.id;</pre>			<p>Spring Boot is able to create the schema and initialize data. It loads schema scripts from <strong class="source-inline">optional:classpath*:schema.sql</strong> and data scripts from <strong class="source-inline">optional:classpath*:data.sql</strong>. We only provided data scripts explicitly, and we did let Spring Boot generate the schema with <strong class="source-inline">generate-ddl </strong>setting. In addition to the data scripts, you can also provide the schema scripts instead of letting Spring Boot generate them for you. For complex applications, probably you will require specific <span class="No-Break">database settings..</span></p>
			<p>As mentioned, in this recipe<a id="_idIndexMarker536"/> we let Spring Boot performing the database<a id="_idIndexMarker537"/> initialization. By default, Spring Boot only performs the initialization if it considers that the database is an In-Memory embedded database, such as H2. To force the initialization for PostgreSQL, we used the <span class="No-Break">parameter </span><span class="No-Break"><strong class="source-inline">spring.sql.init.mode=always</strong></span><span class="No-Break">.</span></p>
			<p>The approach followed in this recipe is intended for development environments. In a production environment, we could have multiple instances of the same application and it can cause issues having more than one instance trying to initialize the database. Even with mechanisms in place to ensure that only one instance of the application is updating the database, this process can take time and will slow down the application initialization. It is important to note, that some of those scripts should be executed only once. For instance, in this recipe we used a <strong class="source-inline">data.sql</strong> that insert records in both tables using explicit id values. If you try to execute it twice will produce a unique constraint validation error. For initialization you most probably want to execute the process before all the application instances start. For instance, in Kubernetes<a id="_idIndexMarker538"/> you can achieve this by using Init Containers, <span class="No-Break">see </span><span class="No-Break">https://kubernetes.io/docs/concepts/workloads/pods/init-containers/</span><span class="No-Break">.</span></p>
			<p>For production environments, other tools such as Flyway and Liquibase exist, and they are supported by Spring Boot. Those tools provide more control on the database creation, providing versioning and migrations. In the next recipe, we’ll use Flyway to create <a id="_idIndexMarker539"/>and migrate the schema<a id="_idIndexMarker540"/> of <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor225"/>There’s more...</h2>
			<p>In this recipe, we used few options among all possibilities to customize our entities, but almost any aspect of database schema definition can be controlled. Just to give <span class="No-Break">some examples:</span></p>
			<ul>
				<li><strong class="source-inline">@Entity</strong>: Annotating a class with <strong class="source-inline">@Entity</strong> indicates<a id="_idIndexMarker541"/> that it is a JPA entity and should be mapped to a database table. Each entity class corresponds to a table in the database, and each field in the class corresponds to a column in <span class="No-Break">the table.</span></li>
				<li><strong class="source-inline">@Table</strong>: It is used to specify the details<a id="_idIndexMarker542"/> of the database table to which an entity should be mapped. You can use it to set the table name, schema, and <span class="No-Break">other attributes.</span></li>
				<li><strong class="source-inline">@Column</strong>: It allows you to configure<a id="_idIndexMarker543"/> the mapping of an entity field to a database column. You can specify attributes like column name, length, nullable, and <span class="No-Break">unique constraints.</span></li>
				<li><strong class="source-inline">@JoinColumn</strong>: It is used to specify the column<a id="_idIndexMarker544"/> that represents a foreign key in a relationship. It is often used in conjunction with <strong class="source-inline">@ManyToOne</strong> or <strong class="source-inline">@OneToOne</strong> to specify the join column’s name and <span class="No-Break">other attributes.</span></li>
				<li><strong class="source-inline">@Transient</strong>: Fields marked with <strong class="source-inline">@Transient</strong> are not mapped<a id="_idIndexMarker545"/> to database columns. This annotation is used for fields that should be excluded from <span class="No-Break">database persistence.</span></li>
				<li><strong class="source-inline">@Embedded</strong> and <strong class="source-inline">@Embeddable</strong>: These annotations are used<a id="_idIndexMarker546"/> for creating embedded objects within entities. <strong class="source-inline">@Embeddable</strong> is applied to a class, and <strong class="source-inline">@Embedded</strong> is used in an entity to indicate<a id="_idIndexMarker547"/> that an instance of the embedded class should be persisted as part of <span class="No-Break">the entity.</span></li>
				<li><strong class="source-inline">@Version</strong>: It is used to specify a version<a id="_idIndexMarker548"/> property for optimistic locking. It is typically applied to a numeric or timestamp field and is used to prevent concurrent updates to the <span class="No-Break">same record.</span></li>
			</ul>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor226"/>See also</h2>
			<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization"><span class="No-Break">https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization</span></a></p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor227"/>PostgreSQL integration tests with Testcontainers</h1>
			<p>When developing tests<a id="_idIndexMarker549"/> for a component, one of the biggest challenges<a id="_idIndexMarker550"/> is managing dependent services like databases. While creating mocks or using an in-memory database like H2 can be a solution, these approaches may hide potential issues in our application. <strong class="bold">Testcontainers</strong> is an open-source framework that offers temporary instances of popular databases and other services that can be run on Docker containers. This provides a more reliable way to <span class="No-Break">test applications.</span></p>
			<p>In this recipe, you will learn how to create an integration test that depends on PostgreSQL <span class="No-Break">using Testcontainers.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor228"/>Getting ready</h2>
			<p>In this recipe, we’ll create some tests for the application created in the previous recipe, <em class="italic">Creating the database schema from our code</em>. I prepared a working version as a starting point for this recipe in case you haven’t completed the previous recipe yet. You can find it in the book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span></a><span class="No-Break">.</span></p>
			<p>Testcontainers requires Docker installed in <span class="No-Break">your computer.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor229"/>How to do it...</h2>
			<p>Let’s enhance the reliability<a id="_idIndexMarker551"/> of our application by creating<a id="_idIndexMarker552"/> tests that utilize a real <span class="No-Break">PostgreSQL database.</span></p>
			<ol>
				<li>First, we’ll need to include the Testcontainers starter and the PostgreSQL Testcontainer dependency. You can do it by adding the following dependencies in the project <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></li>				<li>Next, create a test class, you can name it <strong class="source-inline">FootballServiceTest</strong>. Let’s setup the class for TestContainers. For that <span class="No-Break">we’ll need:</span><ul><li>Annotate the class <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@SpringBootTest</strong></span><span class="No-Break">.</span></li><li>Annotate the class <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@TestContainers</strong></span><span class="No-Break">.</span></li><li>Configure a context initializer that configures the application context using the PostgreSQL container that we’ll create during the test. To set the initializer we can annotate the class <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@ContextConfiguration</strong></span><span class="No-Break">.</span></li></ul><p class="list-inset">The class definition will look <span class="No-Break">like this:</span></p><pre class="source-code">
@SpringBootTest
<strong class="bold">@Testcontainers</strong>
@ContextConfiguration(initializers = <strong class="bold">FootballServiceTest.Initializer.class</strong>)
public class FootballServiceTest</pre><p class="list-inset">As you can see, there is a reference to <strong class="source-inline">FootballServiceTest.Initializer</strong> class that we haven’t described yet. It’s explained in the <span class="No-Break">following steps.</span></p></li>				<li>Now, we’ll define<a id="_idIndexMarker553"/> a static field with the <span class="No-Break">PostgreSQL </span><span class="No-Break"><a id="_idIndexMarker554"/></span><span class="No-Break">container:</span><pre class="source-code">
static PostgreSQLContainer&lt;?&gt; postgreSQLContainer = new PostgreSQLContainer&lt;&gt;("postgres:latest")
        .withDatabaseName("football")
        .withUsername("football")
        .withPassword("football");</pre></li>				<li>Let’s use the container we just created to configure the application. It’s now when we’ll create the <strong class="source-inline">FootballServiceTest.Initializer</strong> class. Inside the FootballServiceTest create a class <span class="No-Break">named Initializer:</span><pre class="source-code">
static class Initializer
            implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {
    public void initialize(ConfigurableApplicationContext configurableApplicationContext) {
        <strong class="bold">TestPropertyValues.of(</strong>
<strong class="bold">                    "spring.datasource.url=" + postgreSQLContainer.getJdbcUrl(),</strong>
<strong class="bold">                    "spring.datasource.username=" + postgreSQLContainer.getUsername(),</strong>
<strong class="bold">                    "spring.datasource.password=" + postgreSQLContainer.getPassword())</strong>
<strong class="bold">    .applyTo(configurableApplicationContext.getEnvironment())</strong>;
     }
}</pre><p class="list-inset">The initializer overrides the data source configuration using the <span class="No-Break">PostgreSQLContainer settings.</span></p></li>				<li>The final step in configuring<a id="_idIndexMarker555"/> Testcontainers is to start the container, which<a id="_idIndexMarker556"/> can be done before all tests begin using <strong class="source-inline">@BeforeAll</strong> annotation. Let’s create a method that starts <span class="No-Break">the container:</span><pre class="source-code">
<strong class="bold">@BeforeAll</strong>
public static void startContainer() {
    <strong class="bold">postgreSQLContainer.start();</strong>
}</pre></li>				<li>Now, we can create the tests normally. For example, let’s make a test that creates <span class="No-Break">a team:</span><pre class="source-code">
@Autowired
FootballService footballService;
<strong class="bold">@Test</strong>
public void createTeamTest() {
    Team team = footballService.createTeam("Jamaica");
    assertThat(team, notNullValue());
    Team team2 = footballService.getTeam(team.id());
    assertThat(team2, notNullValue());
    assertThat(team2, is(team));
}</pre></li>			</ol>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor230"/>How it works...</h2>
			<p>The <strong class="source-inline">@Testcontainers</strong> annotation searches for all fields tagged with @Container and triggers their container lifecycle methods. Containers declared as static fields, like in this recipe, are shared between test methods. This means that the container is started only once, before any test method is executed, and stopped after the last test method has executed. If the container were declared as an instance field, it would be started and stopped for each <span class="No-Break">test method.</span></p>
			<p>The PostgreSQLContainer is a specialized Testcontainer module that exposes the attributes of the database to facilitate the connection in our tests. We used the JdbcUrl, the username and the password to override <span class="No-Break">the configuration.</span></p>
			<p>As you can see, we didn’t require mocking<a id="_idIndexMarker557"/> any repository to create tests<a id="_idIndexMarker558"/> for the FootballService class. Another great advantage is that the database is recreated for every test execution cycle, so the tests are repeatable <span class="No-Break">and predictable.</span></p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor231"/>Versioning and upgrading database schema</h1>
			<p>As our applications<a id="_idIndexMarker559"/> evolve, we’ll need<a id="_idIndexMarker560"/> to keep the database in sync with our Java entities. That could be a complex and error prone task. To address this scenario, there are tools to manage database schemas and database migrations. A couple of examples of such tools are Flyway and Liquibase, both supported by <span class="No-Break">Spring Boot.</span></p>
			<p>In addition to the database migration feature itself, Flyway provides the <span class="No-Break">following features:</span></p>
			<ul>
				<li>Version control to keep<a id="_idIndexMarker561"/> track of the migrations applied to a database and the ones which <span class="No-Break">are pending.</span></li>
				<li>It can be integrated into development environments and build automation tools, such as Maven <span class="No-Break">or Gradle.</span></li>
				<li>Repeatable migrations. Every time Flyway runs, repeatable migrations are executed ensuring that the database remains in the <span class="No-Break">desired state.</span></li>
				<li>Rollback and undo operations. Flyway can automatically generate SQL scripts to undo a specific migration, allowing rollbacks in case <span class="No-Break">of issues.</span></li>
				<li>It can execute the migration during the initialization of <span class="No-Break">your project.</span></li>
				<li>It provides standalone tools that can be used out of your <span class="No-Break">Java project.</span></li>
			</ul>
			<p>When used in your project, it requires<a id="_idIndexMarker562"/> different configurations to perform<a id="_idIndexMarker563"/> the migration, for instance registering specific beans. Spring Boot facilitates that integration, minimizing the necessary configuration to just some application settings unless you need more <span class="No-Break">advanced actions.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor232"/>Getting ready</h2>
			<p>You can use the exercise completed in the previous recipe as starting point for this recipe. If you haven’t completed yet, you can find a complete version in the book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/. You will need the same tools, PostgreSQL <span class="No-Break">and Docker.</span></p>
			<p>Flyway is a solution maintained by Redgate, with free edition for individual and non-commercial projects and paid supported editions. For this recipe, we can use the libraries but keep in mind that using Flyway in a production<a id="_idIndexMarker564"/> environment may require a Redgate license. See https://documentation.red-gate.com/fd/licensing-164167730.html <span class="No-Break">for details.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor233"/>How to do it...</h2>
			<p>In this recipe, we’ll use Flyway<a id="_idIndexMarker565"/> to create an initial<a id="_idIndexMarker566"/> version of the database, and then we’ll apply changes. We’ll learn how it can be easily used with <span class="No-Break">Spring Boot.</span></p>
			<ol>
				<li>Create a new database <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">football3</strong></span><span class="No-Break">.</span><ul><li>Open psql in <span class="No-Break">your terminal.</span><pre class="source-code">
psql -h localhost -U packtd</pre></li><li>Execute the following SQL command to create <span class="No-Break">the database:</span><pre class="source-code">CREATE DATABASE football3;</pre></li></ul></li>				<li>Add Flyway dependency. In your <strong class="source-inline">pom.xml</strong> file add the <span class="No-Break">dependency </span><span class="No-Break"><strong class="source-inline">org.flywaydb:flywaycore</strong></span><span class="No-Break">.</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li>				<li>Create the database creation script. The default location for flyway scripts is under <strong class="source-inline">src/main/resources/db</strong>. Name the file <strong class="source-inline">V1_InitialDatabase.sql</strong> and add the following content to create the <strong class="source-inline">teams</strong> and <span class="No-Break"><strong class="source-inline">players</strong></span><span class="No-Break"> tables:</span><pre class="source-code">
CREATE TABLE teams (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255)
);
CREATE TABLE players (
    id SERIAL PRIMARY KEY,
    jersey_number INT,
    name VARCHAR(255),
    position VARCHAR(255),
    date_of_birth DATE,
    team_id INT REFERENCES teams(id)
);</pre><p class="list-inset">You can also use this script to fill the database with data, for instance adding <strong class="source-inline">teams</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">players</strong></span><span class="No-Break">.</span></p><pre class="source-code">INSERT INTO teams(id, name) VALUES (1884881, 'Argentina');
INSERT INTO players(id, jersey_number, name, "position", date_of_birth, team_id)
VALUES
(357669, 2, 'Adriana SACHS', 'Defender', '1993-12-25', 1884881)</pre><p class="list-inset">In the book’s GitHub<a id="_idIndexMarker567"/> repository, you can find more data<a id="_idIndexMarker568"/> for this script, you can copy and paste in your project if <span class="No-Break">you wish.</span></p></li>			</ol>
			<p class="callout-heading">Migration files naming convention</p>
			<p class="callout">Migration files should follow<a id="_idIndexMarker569"/> the naming convention: <strong class="source-inline">V&lt;version&gt;__&lt;name&gt;.sql</strong>, version can be <strong class="source-inline">&lt;major version&gt;_&lt;minor version&gt;</strong>, but it is optional. Pay attention that between <strong class="source-inline">&lt;version&gt;</strong> and <strong class="source-inline">&lt;name&gt;</strong> there are two <span class="No-Break">underscore signs.</span></p>
			<ol>
				<li value="4">Launch <span class="No-Break">the application.</span><p class="list-inset">If you look at the output logs, you will see a message similar <span class="No-Break">to this:</span></p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer080">
					<img alt="Figure 5.2﻿: Application logs showing migration execution." src="image/B21646_05_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: Application logs showing migration execution.</p>
			<p class="list-inset">Flyway created a new table<a id="_idIndexMarker570"/> to manage the schema history<a id="_idIndexMarker571"/> named <strong class="source-inline">flyway_schema_history</strong> and executed the script we create above. You can get the list of tables in PostgreSQL using <span class="No-Break">command </span><span class="No-Break"><em class="italic">\dt</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer081">
					<img alt="Figure 5.3﻿: List of tables in recently in the database created by Flyway." src="image/B21646_05_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: List of tables in recently in the database created by Flyway.</p>
			<p class="list-inset">The database now has the tables necessary to manage <span class="No-Break">our application.</span></p>
			<ol>
				<li value="5">Let’s create a migration for our application now. We need to manage football matches in our application, and we need to know the height and weight of <span class="No-Break">the players.</span><ul><li>The matches will be managed in a new Entity named <strong class="source-inline">MatchEntity</strong>. It will have two fields referencing the teams playing the match, the match date, and the goals scored by each team. It should look <span class="No-Break">like this:</span><pre class="source-code">
@Entity
@Table(name = "matches")
public class MatchEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private LocalDate matchDate;
    @ManyToOne
    @JoinColumn(name = "team1_id", nullable = false)
    private TeamEntity team1;
    @ManyToOne
    @JoinColumn(name = "team2_id", nullable = false)
    private TeamEntity team2;
    @Column(name = "team1_goals", columnDefinition = "integer default 0")
    private Integer team1Goals;
    @Column(name = "team2_goals", columnDefinition = "integer default 0")
    private Integer team2Goals;
}</pre></li><li>The existing entity <strong class="source-inline">PlayerEntity</strong> should have two<a id="_idIndexMarker572"/> new properties to manage the height<a id="_idIndexMarker573"/> and weight of <span class="No-Break">the player.</span><pre class="source-code">private Integer height;
private Integer weight;</pre></li><li>We need to create the SQL scripts for the database now. In <strong class="source-inline">src/main/resources/db</strong> create a new sql file named <strong class="source-inline">V2__AddMatches.sql</strong>. Add the required changes on the database to support <span class="No-Break">the application.</span></li><li>Create the <span class="No-Break">table </span><span class="No-Break"><strong class="source-inline">matches</strong></span><pre class="source-code">CREATE TABLE matches(
    id SERIAL PRIMARY KEY,
    match_date DATE,
    team1_id INT NOT NULL REFERENCES teams(id),
    team2_id INT NOT NULL REFERENCES teams(id),
    team1_goals INT default 0,
    team2_goals INT default 0
);</pre></li><li>Modify the table players<a id="_idIndexMarker574"/> to add the two columns for the height<a id="_idIndexMarker575"/> <span class="No-Break">and weight.</span><pre class="source-code">ALTER TABLE players ADD COLUMN height INT;
ALTER TABLE players ADD COLUMN weight INT;</pre></li><li>We can also set values for the existing players, for simplicity, we can set the same values for <span class="No-Break">all players:</span><pre class="source-code">UPDATE players SET height = 175, weight = 70;</pre></li></ul></li>				<li>Execute <span class="No-Break">the application.</span><p class="list-inset">If you check the logs, you will see the schema migration applied <span class="No-Break">by Flyway.</span></p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer082">
					<img alt="Figure 5.4﻿: Application logs showing the new schema migration." src="image/B21646_05_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4: Application logs showing the new schema migration.</p>
			<ol>
				<li value="7">During the startup of the application, the database is initialized. In order to ensure that the migration is working as expected, you can use Testcontainers to validate it. You can check if certain data exists in the database using this approach. There are some tests available in the book’s GitHub repository that assume the existence of certain values in <span class="No-Break">the database.</span></li>
			</ol>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor234"/>How it works...</h2>
			<p>On adding the Flyway dependency<a id="_idIndexMarker576"/> to your project, it will check for migration scripts<a id="_idIndexMarker577"/> during the application startup. If there are migration scripts, it will connect to the database and check for migrations that have been already applied by looking at the table <strong class="source-inline">flyway_schema_history</strong>. If that table doesn’t exist yet, it will create it. Then it will start executing all migrations that have not been applied yet in order. For instance, in our sample, if you start the application pointing to an empty database, it will apply <strong class="source-inline">V1__InitialDatabase.sql</strong> first and <span class="No-Break">then </span><span class="No-Break"><strong class="source-inline">V2__AddMatches.sql</strong></span><span class="No-Break">.</span></p>
			<p>Flyway also uses <strong class="source-inline">flyway_schema_history</strong> table to control the concurrency while applying migrations. If you have more than one instance of your application, all of them will try to perform the <span class="No-Break">same procedure:</span></p>
			<ol>
				<li>The first application instance checks if the expected version is the same than the version deployed by looking at the <span class="No-Break"><strong class="source-inline">flyway_schema_history</strong></span><span class="No-Break"> table.</span></li>
				<li>If the version deployed is the expected, they will continue the <span class="No-Break">application normally.</span></li>
				<li>If the version is different, it will lock the <strong class="source-inline">flyway_schema_history</strong> table, and will apply <span class="No-Break">the migration.</span></li>
				<li>The rest of application instances wait until the <strong class="source-inline">flyway_schema_history</strong> table <span class="No-Break">is released.</span></li>
				<li>When the migration finishes, the first application instance will update the version in <strong class="source-inline">flyway_schema_history</strong> table and will <span class="No-Break">release it.</span></li>
				<li>Then, the rest of application instances will check the version as in step 1. As it is already deployed, they will continue normally without applying the <span class="No-Break">migration again.</span></li>
			</ol>
			<p>Another validation performed by flyway is checking if a migration file has been modified. The way it does it is by generating a checksum of the content and saving in the <strong class="source-inline">flyway_schema_history</strong>. A checksum is a kind of signature generated from the content that can be used to verify that content has not been modified. The purpose of this validation is to ensure the consistency and repeatability of <span class="No-Break">the process.</span></p>
			<p class="callout-heading">Important</p>
			<p class="callout">Once applied a migration, don’t modify the script file. If you need to fix a migration, create a new one performing <span class="No-Break">the fix.</span></p>
			<p>Keep in mind that large migrations, for instance<a id="_idIndexMarker578"/> those requiring data<a id="_idIndexMarker579"/> transformation, may produce locks on the database and potential downtimes in your application, as the application won’t complete the initialization until the <span class="No-Break">migration completes.</span></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor235"/>There’s more...</h2>
			<p>Flyway provides a powerful mechanism to perform consistent migrations and keep your code in sync with the database schema. It provides robust mechanisms for versioning and rollback/undo operations as well as <span class="No-Break">repeatable migrations.</span></p>
			<p>If your application has complex requirements related to other components and not only your application, Flyway provides a mechanism named <em class="italic">Callback</em> to invoke additional actions related to the migrations, such as recompiling stored procedures, recalculating materialized view or flushing a cache, etc. If you have that kind of requirements, I recommend <a id="_idIndexMarker580"/>you to take a look at this <span class="No-Break">documentation: </span><a href="https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept"><span class="No-Break">https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept</span></a><span class="No-Break">.</span></p>
			<p>One drawback of using Flyway is that it may slow down the application boot process, even if there is no migration to apply. For that reason, Flyway also provides standalone tools to manage migrations, such as a Desktop UI and a command line tool. These tools aid in the process of allowing the migrations and related actions without adding any dependency to your project and performing the migration <span class="No-Break">process independently.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor236"/>See also</h2>
			<p>In this exercise, I focused on Flyway as a tool to manage database versioning, but Spring Boot also offers support for Liquibase. Just as Flyway, Liquibase can perform migrations during application startup and using independent tools such as the CLI. It has free and paid versions. I recommend you evaluate both tools and use the one that better meets <span class="No-Break">your requirements.</span></p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor237"/>Using JPQL</h1>
			<p><strong class="bold">JPQL</strong> stands for <strong class="bold">Java Persistence Query Language</strong>. It is a platform-independent<a id="_idIndexMarker581"/> query language that is used to query and manipulate data<a id="_idIndexMarker582"/> stored in relational databases using the <strong class="bold">Java Persistence </strong><span class="No-Break"><strong class="bold">API</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JPA</strong></span><span class="No-Break">).</span></p>
			<p>JPQL is similar in syntax to SQL, but it operates at the object level, allowing developers to write queries in terms of Java objects and their relationships rather than database tables and columns. This makes JPQL a more natural choice for developers working with Java-based applications and object-relational mapping frameworks <span class="No-Break">like Hibernate.</span></p>
			<p>Some key features and concepts of <span class="No-Break">JPQL include:</span></p>
			<ul>
				<li><strong class="bold">Entity Classes</strong>: JPQL queries<a id="_idIndexMarker583"/> are written against Java entity classes, which are Java objects that represent <span class="No-Break">database tables.</span></li>
				<li><strong class="bold">Object-Oriented Queries</strong>: JPQL allows you to query and manipulate data in an object-oriented way, using the names of Java classes and <span class="No-Break">their attributes.</span></li>
				<li><strong class="bold">Relationships</strong>: JPQL supports querying data based on the relationships between entities, such as one-to-one, one-to-many, and <span class="No-Break">many-to-many associations.</span></li>
				<li><strong class="bold">Portability</strong>: JPQL queries are written in a way that is independent of the underlying database system, making it possible to switch databases without changing <span class="No-Break">the queries.</span></li>
				<li><strong class="bold">Type Safety</strong>: JPQL queries are type-checked <a id="_idIndexMarker584"/>at compile-time, reducing the risk of <span class="No-Break">runtime errors.</span></li>
			</ul>
			<p>JPQL is a powerful tool for working with data in Java-based applications. It allows developers to express database queries in a way that is more aligned with the object-oriented nature of <span class="No-Break">Java programming.</span></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor238"/>Getting ready</h2>
			<p>For this recipe, we don’t need additional tools compared to previous recipes. As a starting point of this exercise, we will use the completed version of previous recipe. If you didn’t complete it, you can find it in the book’s repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor239"/>How to do it...</h2>
			<p>In this recipe, we will enhance<a id="_idIndexMarker585"/> the Repositories created in the previous recipe with some advanced queries using JPQL. We will add two more entities, <strong class="source-inline">AlbumEntity</strong> and <strong class="source-inline">CardEntity</strong> to emulate a card trading game. The data model will look <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer083">
					<img alt="Figure 5.5﻿: PostgreSQL Data model" src="image/B21646_05_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5: PostgreSQL Data model</p>
			<p><span class="No-Break">Let’s begin:</span></p>
			<ol>
				<li>Add the new Entities and a new repository. We will need to create a <span class="No-Break">new migration.</span><ul><li><span class="No-Break">AlbumEntity:</span><pre class="source-code">
@Table(name = "albums")
@Entity
public class AlbumEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String title;
    private LocalDate expireDate;
    @OneToMany
    private List&lt;CardEntity&gt; cards;
}</pre></li><li><span class="No-Break">CardsEntity:</span><pre class="source-code">@Table(name = "cards")
@Entity
public class CardEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    @ManyToOne
    @JoinColumn(name = "album_id")
    private AlbumEntity album;
    @ManyToOne
    @JoinColumn(name = "player_id")
    private PlayerEntity player;
}</pre></li><li><span class="No-Break">AlbumRepository:</span><pre class="source-code">public interface AlbumRepository extends JpaRepository&lt;AlbumEntity, Integer&gt; {
}</pre></li></ul><p class="list-inset">Now create a new Flyway<a id="_idIndexMarker586"/> migration to create the tables. To do that, create a file named <strong class="source-inline">V3__AddAlbums.sql</strong> and create <span class="No-Break">the tables.</span></p><pre class="source-code">CREATE TABLE albums (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255),
    expire_date DATE
);
CREATE TABLE cards (
    id SERIAL PRIMARY KEY,
    album_id INTEGER REFERENCES albums(id),
    player_id INTEGER REFERENCES players(id)
);</pre><p class="list-inset">This script is available in the book repository, including some <span class="No-Break">sample data.</span></p></li>				<li>In our trading card game, the <strong class="source-inline">CardEntitity</strong> entity represents the cards that the user has. We will create a method to get the players we have of a certain team. To do that, in the <strong class="source-inline">AlbumRepository</strong> add the <span class="No-Break">following method:</span><pre class="source-code">
@Query("SELECT p FROM PlayerEntity p JOIN p.cards c WHERE c.album.id = :id AND p.team.id = :teamId")
public List&lt;PlayerEntity&gt; findByIdAndTeam(Integer id, Integer teamId);</pre></li>				<li>We want to know what players<a id="_idIndexMarker587"/> we don’t have yet. To find out, add the following method in <span class="No-Break">the AlbumsRepository:</span><pre class="source-code">
@Query("SELECT p FROM PlayerEntity p WHERE p NOT IN (SELECT c.player FROM CardEntity c WHERE c.album.id=:id)")
public List&lt;PlayerEntity&gt; findByIdMissingPlayers(Integer id);</pre></li>				<li>Let’s find which are the players of a certain match, from both teams. In the <strong class="source-inline">MatchRepository</strong> add the <span class="No-Break">following method:</span><pre class="source-code">
@Query("SELECT p1 FROM MatchEntity m JOIN m.team1 t1 JOIN t1.players p1 WHERE m.id = ?1 UNION SELECT p2 FROM MatchEntity m JOIN m.team2 t2 JOIN t2.players p2 WHERE m.id = ?1")
public List&lt;PlayerEntity&gt; findPlayersByMatchId(Integer matchId);</pre></li>				<li>Get a team and its players. To do that, in the <strong class="source-inline">TeamRepository</strong> add the <span class="No-Break">following method:</span><pre class="source-code">
@Query("SELECT t FROM TeamEntity t JOIN FETCH t.players WHERE t.id = ?1")
public Optional&lt;TeamEntity&gt; findByIdWithPlayers(Integer id);</pre><p class="list-inset">This method can be used now in <strong class="source-inline">FootballService</strong> to get the teams. If you remember from the recipe <em class="italic">Connect your application to Postgresql</em>, we implemented a mechanism to avoid the Open Session In View antipattern by adding a <strong class="source-inline">@Transactional</strong> annotation in the method <strong class="source-inline">getTeam</strong>. With this new <strong class="source-inline">TeamRepository</strong> method, it retrieves both the team and its players in the same session, then it is not <span class="No-Break">necessary </span><span class="No-Break"><strong class="source-inline">@Transactional</strong></span><span class="No-Break">.</span></p><pre class="source-code">public Team getTeam(Integer id) {
    TeamEntity team = teamRepository.findByIdWithPlayers(id).orElse(null);
    if (team == null) {
        return null;
    } else {
    return new Team(team.getId(),
                    team.getName(),
                    team.getPlayers()
                            .stream()
                            .map(player -&gt; new Player(player.getName(), player.getJerseyNumber(), player.getPosition(),
                                    player.getDateOfBirth()))
                            .toList());
    }
 }</pre></li>				<li>Find a list<a id="_idIndexMarker588"/> of players. Modify <strong class="source-inline">PlayerRepository</strong> by adding the <span class="No-Break">following method:</span><pre class="source-code">
@Query("SELECT p FROM PlayerEntity p WHERE p.id IN (?1)")
List&lt;PlayerEntity&gt; findListOfPlayers(List&lt;Integer&gt; players);</pre><p class="list-inset">This method could be also implemented just by using naming convention with no need for <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Query</strong></span><span class="No-Break"> annotation.</span></p><pre class="source-code">List&lt;PlayerEntity&gt; findByIdInList(List&lt;Integer&gt; players);</pre></li>				<li>Find a list of players whose names contain a certain string. Modify the <strong class="source-inline">PlayerRepository</strong> and add the <span class="No-Break">following method:</span><pre class="source-code">
List&lt;PlayerEntity&gt; findByNameLike(String name);</pre></li>				<li>Find a list of players whose name starts with a string. Modify the <strong class="source-inline">PlayerRepository</strong> and add the <span class="No-Break">following method:</span><pre class="source-code">
List&lt;PlayerEntity&gt; findByNameStartingWith(String name);</pre></li>				<li>Sort the players of a team in ascending order. Modify the <strong class="source-inline">PlayerRepository</strong> and add the <span class="No-Break">following repository.</span><pre class="source-code">
List&lt;PlayerEntity&gt; findByTeamId(Integer teamId, Sort sort);</pre><p class="list-inset">You can use this method <span class="No-Break">as follows:</span></p><pre class="source-code">playerRepository.findByTeamId(id, Sort.by("name").ascending())</pre><p class="list-inset">You can decide how to sort <span class="No-Break">the results.</span></p></li>				<li>We have the option<a id="_idIndexMarker589"/> to paginate the results. This means that if the result set is extensive, we can divide it into pages and retrieve. The <strong class="source-inline">JpaRepository</strong> already provides method overloads to page the results. For instance, the method <strong class="source-inline">findAll</strong> can receive a pageable parameter to control how the results should <span class="No-Break">be paged.</span><pre class="source-code">
Page&lt;PlayerEntity&gt; page = playerRepository.findAll(Pageable.ofSize(size).withPage(pageNumber));</pre><p class="list-inset">You can add this as parameter in any of the methods using a custom query. For instance, we can create the following method <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">AlbumsRepository</strong></span><span class="No-Break">:</span></p><pre class="source-code">@Query("SELECT p FROM PlayerEntity p JOIN p.cards c WHERE c.album.id = :id")
public List&lt;PlayerEntity&gt; findByIdPlayers(Integer id, Pageable page);</pre></li>				<li>We can also use JPQL<a id="_idIndexMarker590"/> to return aggregated results. For instance, let’s create a query to get the number of players in a given position, <span class="No-Break">per team.</span><pre class="source-code">
@Query("SELECT p.team.name as name, count(p.id) as playersCount FROM PlayerEntity p WHERE p.position = ?1 GROUP BY p.team ORDER BY playersCount DESC")
public List&lt;TeamPlayers&gt; getNumberOfPlayersByPosition(String position);</pre><p class="list-inset">As you can see, the result is not an entity, but just the name of the team and the number of players in the position. To return this result we used a custom result, implemented as <span class="No-Break">an Interface.</span></p><pre class="source-code">public interface TeamPlayers {
    String getName();
    Integer getPlayersCount();
}</pre><p class="list-inset">The interface should have getter methods matching the projected <span class="No-Break">query result.</span></p></li>				<li>Create a RESTful controller and a service to use the methods generated. In the book’s GitHub repository there is a RESTful API using the repositories created in <span class="No-Break">this recipe.</span><p class="list-inset">In the repository you<a id="_idIndexMarker591"/> can also find a script to call the RESTful API methods created in <span class="No-Break">this recipe.</span></p></li>
			</ol>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor240"/>How it works...</h2>
			<p>When an application using Spring Data JPA starts, it performs several important actions to make <span class="No-Break">it work.</span></p>
			<ul>
				<li>Spring Application Context initialization. It sets up the environment for managing Spring components, including <span class="No-Break">the repositories.</span></li>
				<li>Spring Boot scans component and detect repositories. It checks classes annotated with <strong class="source-inline">@Repository</strong> and interfaces <span class="No-Break">extending </span><span class="No-Break"><strong class="source-inline">JpaRepository</strong></span><span class="No-Break">.</span></li>
				<li>For each repository interface, Spring Data JPA generates a concrete implementation during runtime. In our scenario, it means that it takes each method defined in the repositories and generates the specific queries. At this step it validates if it can generate the implementation by using the naming convention, or by using the <strong class="source-inline">@Query</strong> annotation. At this step it also validates the queries, so if we write an invalid query or it is not capable of generating the implementation from the naming convention, it <span class="No-Break">will fail.</span></li>
				<li>After generating the implementation, it registers them as beans in the application context and are now available for the rest of components of <span class="No-Break">our application.</span></li>
			</ul>
			<p>One important advantage of JPA and JPQL is that the queries reference the Entities we defined in our code, so it can detect a query/entity mapping mismatch early. This cannot be achieved when using <span class="No-Break">native queries.</span></p>
			<p>Another advantage is that it abstracts<a id="_idIndexMarker592"/> the underlaying database. As a developer, this is an interesting feature, as it makes the onboarding to a new <span class="No-Break">database faster.</span></p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor241"/>There’s more...</h2>
			<p>You can activate the SQL logging by using <strong class="source-inline">spring.jpa.show-sql</strong> configuration variable. It is interesting to check and debug the native queries being generated. Keep in mind that it can slow down your application and generate large logs. I recommend using this setting only <span class="No-Break">in development.</span></p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor242"/>Using Native Queries</h1>
			<p>JPQL is a very powerful mechanism<a id="_idIndexMarker593"/> to access relational databases with an abstraction of the underlying database. Native Queries refers to executing SQL statements directly against the database. Depending on your requirements you might consider<a id="_idIndexMarker594"/> using Native queries, for <span class="No-Break">instances like:</span></p>
			<ul>
				<li>Executing complex SQL operations that are not easily expressible in JPQL, for instance, queries that involve subqueries or <span class="No-Break">database-specific functions.</span></li>
				<li>When you need to fine-tune the performance of a query, leveraging database-specific optimizations, indexes, and hints to improve the query <span class="No-Break">execution time.</span></li>
				<li>Database-specific features, for instance, the databases that can manage JSON structures, may have different ways of <span class="No-Break">doing it.</span></li>
				<li>Bulk Operations: Native queries are often more efficient for executing bulk insert, update, or delete operations on a large number of records, as they bypass the overhead of entity management and caching that comes <span class="No-Break">with JPQL.</span></li>
			</ul>
			<p>Keep in mind that using Native Queries comes with some trade-offs compared <span class="No-Break">to JPQL.</span></p>
			<ul>
				<li><strong class="bold">Type Safety</strong>: As we saw in the previous <a id="_idIndexMarker595"/>recipe, JPQL provides type safety, which means that query results are returned as strongly typed objects and queries are validated during application startup. With native queries, you typically work with untyped result sets, which can introduce runtime errors if not handled properly and that will come up just when the native query <span class="No-Break">is used.</span><p class="list-inset">Native queries can be harder to maintain and refactor because they involve SQL strings embedded in your Java code. JPQL queries are more self-contained and easier <span class="No-Break">to manage</span></p></li>
				<li><strong class="bold">Portability</strong>: Native queries are not portable<a id="_idIndexMarker596"/> across different database systems. If your application needs to support multiple databases, you may need to write database-specific queries for each one, and you will need to learn the specific differences of each database <span class="No-Break">SQL dialect.</span></li>
			</ul>
			<p>In this recipe, we’ll introduce a new feature, match timelines, to our Football application. The timeline are all the events that happen during a football match; as we don’t want to constrain the content that can be managed as an event, we will save part of the information as JSON. PostgreSQL has excellent support for JSON, but for most of the scenarios, it is necessary to write <span class="No-Break">native queries.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor243"/>Getting ready</h2>
			<p>For this recipe, we don’t need additional tools compared to previous recipes. As starting point of this exercise, we will use the completed version of previous recipe. If you didn’t complete it, you can find it in the book’s repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/. I also prepared some scripts to create some sample data for the database. It will be explained as part of the <span class="No-Break">recipe steps.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor244"/>How to do it...</h2>
			<p>In this recipe, we will create<a id="_idIndexMarker597"/> a new table managing the match events. That table will have a column containing <span class="No-Break">JSON documents.</span></p>
			<ol>
				<li>To create the new table, we will create a new Flyway migration. In folder <strong class="source-inline">src/main/resources/db/migration</strong> create a file named <strong class="source-inline">V4__AddMatchEvents.sql</strong> with the <span class="No-Break">following content.</span><pre class="source-code">
CREATE TABLE match_events (
    id BIGSERIAL PRIMARY KEY,
    match_id INTEGER NOT NULL,
    event_time TIMESTAMP NOT NULL,
    details JSONB,
    FOREIGN KEY (match_id) REFERENCES matches (id)
);
CREATE PROCEDURE FIND_PLAYERS_WITH_MORE_THAN_N_MATCHES(IN num_matches INT, OUT count_out INT)
LANGUAGE plpgsql
AS $$
BEGIN
    WITH PLAYERS_WITH_MATCHES AS
        (SELECT p.id, count(m.id) AS match_count FROM players p, matches m WHERE p.team_id = m.team1_id OR p.team_id = m.team2_id
        GROUP BY p.id HAVING count(m.id) &gt; num_matches)
    SELECT COUNT(1) INTO count_out FROM PLAYERS_WITH_MATCHES;
END;
$$;</pre><p class="list-inset">Additionally, I prepared<a id="_idIndexMarker598"/> another migration that you can find in https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/ named <strong class="source-inline">V4_1__CreateSampleEvents.sql</strong>. This migration inserts events in the <strong class="source-inline">match_events</strong> table, so you will be able to play around it. Here you can see an example of match <span class="No-Break">event detail:</span></p><pre class="source-code">{
   "type": 24,
   "description": "Throw In",
   "players": [
     467653,
     338971
   ],
   "mediaFiles": [
     "/media/93050144.mp4",
     "/media/6013333.mp4",
     "/media/56559214.mp4"
    ]
}</pre></li>				<li>Create a new entity to manage this table. Create a class <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">MatchEventEntity</strong></span><span class="No-Break">:</span><pre class="source-code">
@Table(name = "match_events")
@Entity
public class MatchEventEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(name = "event_time")
    private LocalDateTime time;
    @JdbcTypeCode(SqlTypes.JSON)
    private MatchEventDetails details;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private MatchEntity match;
}</pre></li>				<li>We will map the JSON <a id="_idIndexMarker599"/>content in another class named <strong class="source-inline">MatchEventDetails</strong>. You can use other more flexible data structures, such as <span class="No-Break">a Map.</span><pre class="source-code">
public class MatchEventDetails {
    private Integer type;
    private String description;
    private List&lt;Integer&gt; players;
    private List&lt;String&gt; mediaFiles;
}</pre></li>				<li>Create a new <strong class="source-inline">JpaRepository</strong> and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">MatchEventRepository</strong></span><span class="No-Break">:</span><pre class="source-code">
public interface MatchEventRepository extends JpaRepository&lt;MatchEventEntity, Long&gt; {
}</pre></li>				<li>We will create a new method<a id="_idIndexMarker600"/> in the repository to retrieve all events in a match of a given type. The type of event is just an attribute of the JSON content. To perform this query, we need to use PostgreSQL specific syntax to query using the JSON content. To use Native Queries, we just need to specify in <strong class="source-inline">@Query</strong> annotation the attribute <strong class="source-inline">nativeQuery = </strong><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span><pre class="source-code">
@Query(nativeQuery = true, value = "SELECT me.* FROM match_events me  WHERE me.match_id = ?1 AND CAST(me.details -&gt; 'type' as INT) = ?2")
public List&lt;MatchEventEntity&gt; findByIdIncludeEventsOfType(Integer matchId, Integer eventType);</pre></li>				<li>We will implement a repository method to retrieve the events associated with a particular football match in which a specified <span class="No-Break">player participated.</span><pre class="source-code">
@Query(nativeQuery = true,
  value = "SELECT me.id, me.match_id, me.event_time, " + me.details FROM match_events me CROSS JOIN LATERAL " + jsonb_array_elements(me.details-&gt;'players') AS player_id " +
"WHERE me.match_id = ?1 AND CAST(player_id as INT) = ?2")
List&lt;MatchEventEntity&gt; findByMatchIdAndPlayer(Integer matchId, Integer playerId);</pre></li>				<li>In <strong class="source-inline">PlayerRepository</strong> we will create a method a new method to map the <span class="No-Break">stored procedure.</span><pre class="source-code">
@Procedure("FIND_PLAYERS_WITH_MORE_THAN_N_MATCHES")
int getTotalPlayersWithMoreThanNMatches(int num_matches);</pre><p class="list-inset">Now you can create a service and a controller using these repositories. In the GitHub repository, I extended the existing controller to call the new repository methods. You can also find a script calling the new <span class="No-Break">controller methods.</span></p></li>			</ol>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor245"/>How it works...</h2>
			<p>In this example, we used JSON<a id="_idIndexMarker601"/> because it is very useful to store data that can be flexible, extensible and it is not required to be as structured as a table, with known columns and types. PostgreSQL has a good support for JSON, however JPQL support for this kind of scenario is more limited. That is why, you need to use <span class="No-Break">Native Queries.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Even if PostgreSQL has very good support for JSON, it is not as optimized as it is for regular columns. If there is information in the document that is frequently used, it is better to move it to regular columns. PostgreSQL supports indexes over JSON properties, you will need to evaluate which is the best approach for your <span class="No-Break">specific scenario.</span></p>
			<p>We used <strong class="bold">Plain Old Java Objects</strong> (<strong class="bold">POJO</strong>) to represent the JSON <a id="_idIndexMarker602"/>column. <strong class="source-inline">MatchEventDetail</strong> is just a class, not an Entity. In any case, this also requires knowing the schema of the JSON data in advance to avoid serialization errors. If you need a more flexible approach, you can use just a Map or a String to map <span class="No-Break">that column.</span></p>
			<p>JSON support is just an example of a native feature in this case of PostgreSQL, but there are other scenarios that you might require using native queries. For instance, complex queries that are difficult or not possible to express using JPQL, such as subqueries and <span class="No-Break">bulk operations.</span></p>
			<p>When a Native Query is executed, the SQL command itself is not checked by Spring Data JPA nor Hibernate, however the resulting execution should be mapped to the resulting Entities. Keep that in mind when you write the SQL statements. For instance, if in this recipe, <span class="No-Break">we wrote:</span></p>
			<pre class="source-code">
SELECT me.id, me.match_id, me.event_time, me.details FROM match_events me CROSS JOIN LATERAL  jsonb_array_elements(me.details-&gt;'players') AS player_id
WHERE me.match_id = ?1 AND CAST(player_id as INT) = ?2)</pre>			<p>That should match a <strong class="source-inline">List&lt;MatchEventEntity&gt;</strong>. According to our definition of <strong class="source-inline">MatchEventEntity</strong>, it expects that the result of the query contains the columns <em class="italic">id</em>, <em class="italic">event_time</em>, <em class="italic">details</em> and <em class="italic">match_id</em>. So be aware of this fact when using alias in your queries. As an example, look at the following query, it will result in an error <span class="No-Break">in runtime:</span></p>
			<pre class="source-code">
SELECT me.id <strong class="bold">as event_id</strong>, me.match_id, me.event_time, me.details FROM match_events.</pre>			<p>In this recipe, we also used a stored procedure. In this case, the mapping is simpler and more direct. Just by using <strong class="source-inline">@Procedure</strong> annotation, Spring Data JPA and Hibernate can invoke the stored procedure. As it happens with Native Queries, you are responsible to make sure that the incoming parameters and results match with the method invocation. If you change any of them, it can cause<a id="_idIndexMarker603"/> errors <span class="No-Break">in runtime.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor246"/>There’s more...</h2>
			<p>An important difference seen in Native queries compared to JPQL queries is that the queries cannot be validated against your entities, hence you need to be careful as it can fail at runtime. I recommend checking all queries first in tools such as <strong class="source-inline">PgAdmin</strong> for PostgreSQL, or a similar tool for the database you choose. I also recommend preparing a good set of tests using the native queries. In the book’s GitHub repository I created some tests to validate the queries used in <span class="No-Break">this recipe.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor247"/>See also</h2>
			<p>If your solution is more dependent on JSON documents, with schema flexibility, rather than well-defined schemas with complex relationships and transactional integrity needs that PostgreSQL and other relational databases can offer, then you may want to consider other database technologies, such as Document databases. There are many solutions in the market, like MongoDB, Azure CosmosDB, AWS DocumentDb. We will cover MongoDB in the <span class="No-Break">following chapter.</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor248"/>Updating Operations</h1>
			<p>In previous recipes, we just performed<a id="_idIndexMarker604"/> queries against the database. In this recipe, we will use Spring Data JPA to modify the data of <span class="No-Break">our database.</span></p>
			<p>We will continue with our football sample. In this recipe, we will create operations to manage the trading card albums. A user may have albums, an album has cards, and the card references a player. To complete an album, the user needs to have cards with all players. So, they need to know what cards are missing. Users can buy albums and cards, but they cannot choose the cards. They can have repeated players. Users can trade cards. So, they can exchange all unused cards with <span class="No-Break">another user.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor249"/>Getting ready</h2>
			<p>For this recipe, we don’t need additional tools compared to previous recipes. As a starting point of this exercise, we will use the completed version of the previous recipe. If you didn’t complete it, you can find it in the book’s repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor250"/>How to do it...</h2>
			<p>To complete this recipe, we will add<a id="_idIndexMarker605"/> a new Entity to manage the users. We will modify Albums and Cards as they have an owner now. Later we will create some operations that involve data modification to manage the cards and <span class="No-Break">trading operations.</span></p>
			<ol>
				<li>We will first create a new database migration using Flyway. To do that, create a file named <strong class="source-inline">V5__AddUsers.sql </strong><span class="No-Break"><strong class="source-inline">in src/main/resources/db/migration</strong></span><span class="No-Break">.</span><p class="list-inset">Then, we will create a table for users, and we’ll update the cards and albums to reference <span class="No-Break">the user.</span></p><pre class="source-code">
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255)
);
ALTER TABLE albums ADD COLUMN owner_id INTEGER REFERENCES users(id);
ALTER TABLE cards ADD COLUMN owner_id INTEGER REFERENCES users(id);
ALTER TABLE cards ADD CONSTRAINT cards_album_player_key UNIQUE (album_id, player_id);</pre><p class="list-inset">Note the constraint<a id="_idIndexMarker606"/> in the table cards to avoid repeating players in the <span class="No-Break">same album.</span></p></li>				<li>Add a new entity named <strong class="source-inline">UserEntity</strong> to map with the <span class="No-Break">new table:</span><pre class="source-code">
@Table(name = "users")
@Entity
public class UserEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String username;
    @OneToMany(mappedBy = "owner")
    private List&lt;CardEntity&gt; ownedCards;
    @OneToMany(mappedBy = "owner")
    private Set&lt;AlbumEntity&gt; ownedAlbums;
}</pre></li>				<li>Modify <strong class="source-inline">CardEntity</strong> and <strong class="source-inline">AlbumEntity</strong> to reference an <span class="No-Break">owner user.</span><pre class="source-code">
@ManyToOne
@JoinColumn(name = "owner_id")
private UserEntity owner;</pre></li>				<li><strong class="source-inline">CardEntity</strong> can be modified<a id="_idIndexMarker607"/> to reflect the unique constraint that a player can be only once in <span class="No-Break">an album:</span><pre class="source-code">
@Table(name = "cards", uniqueConstraints = { @UniqueConstraint(columnNames = { "album_id", "player_id" }) })
@Entity
public class CardEntity {
}</pre></li>				<li>Let’s start managing the data. We will start with just using the methods already provided <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">JpaRepository</strong></span><span class="No-Break">.</span><p class="list-inset">Let’s create <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">UserRepository</strong></span><span class="No-Break">:</span></p><pre class="source-code">
public interface UserRepository extends JpaRepository&lt;UserEntity, Integer&gt; {
}</pre><p class="list-inset"><strong class="source-inline">JpaRepository</strong> provides a method named <strong class="source-inline">save</strong>. This method creates or updates the entity provided. We can use it in <span class="No-Break">this way:</span></p><pre class="source-code">private UserRepository usersRepository;
public User createUser(String name) {
    UserEntity user = new UserEntity();
    user.setUsername(name);
    user = usersRepository.save(user);
    return new User(user.getId(), user.getUsername());
}</pre><p class="list-inset">In the same way, we can create an album that references <span class="No-Break">a user:</span></p><pre class="source-code">public Album buyAlbum(Integer userId, String title) {
    AlbumEntity album = new AlbumEntity();
    album.setTitle(title);
    album.setExpireDate(LocalDate.now().plusYears(1));
    album.setOwner(usersRepository.findById(userId).orElseThrow());
    album = albumsRepository.save(album);
    return new Album(album.getId(), album.getTitle(), album.getOwner().getId());
}</pre><p class="list-inset">We can also save multiple<a id="_idIndexMarker608"/> entities at the same time by calling the method <strong class="source-inline">saveAll</strong>. As an example, let’s define a method to <span class="No-Break">buy cards:</span></p><pre class="source-code">public List&lt;Card&gt; buyCards(Integer userId, Integer count) {
    Random rnd = new Random();
    List&lt;PlayerEntity&gt; players = getAvailablePlayers();
    UserEntity owner = usersRepository.findById(userId).orElseThrow();
    List&lt;CardEntity&gt; cards = Stream.generate(() -&gt; {
       CardEntity card = new CardEntity();
       card.setOwner(owner);
       card.setPlayer(players.get(rnd.nextInt(players.size())));
       return card;
    }).limit(count).toList();
    return cardsRepository.saveAll(cards)
                .stream()
                .map(card -&gt; new Card(card.getId(), card.getOwner().getId(), Optional.empty(),
                        new Player(card.getPlayer().getName(), card.getPlayer().getJerseyNumber(),
                                card.getPlayer().getPosition(), card.getPlayer().getDateOfBirth())))
                .collect(Collectors.toList());
}</pre><p class="list-inset">Our users will buy batches of cards. We need to generate the cards; we will generate the cards selecting a random player for each card, then we’ll save them in a single <span class="No-Break"><strong class="source-inline">saveAll</strong></span><span class="No-Break"> operation.</span></p></li>				<li>Once we have the cards, we want<a id="_idIndexMarker609"/> to use them in our albums. Using them constitutes assigning them to an album. If we want to use just the method provided by JpaRepository, we should perform the <span class="No-Break">following steps:</span><ol><li class="upper-roman">Get all the available cards, that is the ones that have not been assigned to <span class="No-Break">an album.</span></li><li class="upper-roman">Get all missing players. That is all players that are not in the cards assigned to <span class="No-Break">an album.</span></li><li class="upper-roman">Take all available cards that are in the missing players. These are the cards to be assigned <span class="No-Break">to albums.</span></li><li class="upper-roman">Verify that you only use a player in an <span class="No-Break">album once.</span></li><li class="upper-roman">Save <span class="No-Break">the cards.</span></li></ol><p class="list-inset">All these steps involve requests to <span class="No-Break">the database.</span></p><p class="list-inset">Or we can obtain the same result<a id="_idIndexMarker610"/> with just one request to the database by using an <strong class="source-inline">UPDATE </strong><span class="No-Break"><strong class="source-inline">SQL</strong></span><span class="No-Break"> command:</span></p><pre class="source-code">
UPDATE cards
SET album_id = r.album_id
FROM
(SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1 AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id
FROM
(SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) available) as r
WHERE cards.id = r.card_id</pre><p class="list-inset">We can use this command in <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">CardRepository</strong></span><span class="No-Break">:</span></p><pre class="source-code">@Modifying
@Query(nativeQuery = true, value = "UPDATE cards " +
  "SET album_id = r.album_id  " + //
  "FROM " + //
  "(SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1 AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id " + //
  "FROM " + //
  "(SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) available) as r " +
  "WHERE cards.id = r.card_id " +
  "RETURNING cards.*")
 List&lt;CardEntity&gt; assignCardsToUserAlbums(Integer userId);</pre><p class="list-inset">Remember to include <strong class="source-inline">@Modifying</strong> annotation. As this is a PostgreSQL command, it requires <strong class="source-inline">nativeQuery=true</strong> in the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Query</strong></span><span class="No-Break"> annotation.</span></p></li>				<li>We can transfer a card<a id="_idIndexMarker611"/> to another user. If the card was used in an album, it should be unlinked. This can be done in different ways, we will implement the same using a <span class="No-Break">JPQL Query:</span><pre class="source-code">
@Modifying
@Query(value = "UPDATE CardEntity " +
" SET album = null, " +
" owner= (SELECT u FROM UserEntity u WHERE u.id=?2) " +
"WHERE id = ?1 ")
Integer transferCard(Integer cardId, Integer userId);</pre><p class="list-inset">In this case, we need to ensure that this method is executed in the context of a transaction. We can do it decorating the calling method with a <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Transactional</strong></span><span class="No-Break"> annotation:</span></p><pre class="source-code"><strong class="bold">@Transactional</strong>
public Optional&lt;Card&gt; transferCard(Integer cardId, Integer userId) {
    Integer count = cardsRepository.transferCard(cardId, userId);
   if (count == 0) {
       return Optional.empty();
   } else {
       …
   }
}</pre></li>				<li>Next, we’ll learn how to exchange cards from user to another. Again, we can do it in our business logic using the methods provided by <strong class="source-inline">JpaRepository</strong> by performing the <span class="No-Break">following actions:</span><ol><li class="upper-roman">Get the available cards<a id="_idIndexMarker612"/> from one user, these are the ones not assigned to an album usually because they are <span class="No-Break">repeated players.</span></li><li class="upper-roman">Get the missing players on the albums of the <span class="No-Break">other user.</span></li><li class="upper-roman">Change the owner of the cards of the first user that are in the list of the missing players of the <span class="No-Break">other user.</span></li></ol><p class="list-inset">Or we can do it in a single <strong class="source-inline">SQL </strong><span class="No-Break"><strong class="source-inline">UPDATE</strong></span><span class="No-Break"> statement:</span></p><pre class="source-code">
@Modifying
@Query(nativeQuery = true, value = "UPDATE cards " +
"SET owner_id=?2 " +
" FROM (select c1.id from cards c1 where c1.owner_id=?1 and c1.album_id IS NULL AND c1.player_id IN (select p2.id from players p2 where p2.id NOT IN (SELECT c2.player_id FROM cards c2 WHERE c2.owner_id=?2)) LIMIT ?3) cards_from_user1_for_user2 " +
"WHERE cards.id = cards_from_user1_for_user2.id " +
"RETURNING cards.*")
List&lt;CardEntity&gt; tradeCardsBetweenUsers(Integer userId1, Integer userId2, Integer count);</pre></li>			</ol>
			<p>I created a service class and a dedicated RESTful controller to perform all the operations above. The code, including a script to call the RESTful controller, is in the <span class="No-Break">GitHub repository.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor251"/>How it works...</h2>
			<p>In JPA, there is the concept<a id="_idIndexMarker613"/> of <em class="italic">Persistence</em> <em class="italic">Context</em> or just <em class="italic">Persistence Context</em>. The Context is mostly managed by <em class="italic">EntityManager</em>, which is responsible for managing the lifecycle of the JPA entities. It covers the <span class="No-Break">following aspects:</span></p>
			<ul>
				<li><strong class="bold">Entity Management</strong>: The persistence context<a id="_idIndexMarker614"/> is responsible for managing the entities. When you retrieve data from the database using Spring Data JPA, the resulting entities are managed by the persistence context. This means that changes to these entities are tracked, and you can use the persistence context to synchronize these changes with <span class="No-Break">the database.</span></li>
				<li><strong class="bold">Identity Management</strong>: The persistence context ensures that there is a single in-memory representation of an entity for a given database row. If you load the same entity multiple times, you will get the same Java object instance, ensuring consistency and avoiding <span class="No-Break">duplicate data.</span></li>
				<li><strong class="bold">Automatic Dirty Checking</strong>: The persistence context automatically tracks changes made to managed entities. When you modify an entity’s state, these changes are detected, and the associated database records are updated when the persistence context is flushed. You can flush explicitly using the <strong class="source-inline">flush</strong> method of <strong class="source-inline">JpaRepository</strong>, or implicitly, for instance at the end of <span class="No-Break">a transaction.</span></li>
				<li><strong class="bold">Caching</strong>: The persistence context provides a first-level cache. It stores managed entities in memory, which can improve application performance by reducing the number of database queries required for entity retrieval during <span class="No-Break">a transaction.</span></li>
				<li><strong class="bold">Lazy Loading</strong>: The persistence context can enable lazy loading of related entities. When you access a property representing a related entity, Spring Data JPA can automatically fetch that related entity from the database, if it’s not already in the <span class="No-Break">persistence context.</span></li>
				<li><strong class="bold">Transaction Synchronization</strong>: The persistence context is typically bound to the scope of a transaction. This ensures<a id="_idIndexMarker615"/> that changes to entities are persisted to the database when the transaction is committed. If the transaction is rolled back, the changes <span class="No-Break">are discarded.</span></li>
			</ul>
			<p>In Spring Data JPA, the <strong class="source-inline">EntityManager</strong> is the central component for managing the persistence context. It provides methods for persisting, retrieving, and <span class="No-Break">managing entities.</span></p>
			<p>In addition to the methods<a id="_idIndexMarker616"/> already provided by the <strong class="source-inline">JpaRepository</strong> like <strong class="source-inline">save</strong> and <strong class="source-inline">saveAll</strong>, you can use <strong class="source-inline">@Modifying</strong> annotation. In Spring Data JPA, the <strong class="source-inline">@Modifying</strong> annotation is used to indicate that a method in a Spring Data JPA repository interface is a modifying query method. Modifying query methods are used to perform data modification operations like INSERT, UPDATE, or DELETE in <span class="No-Break">the database.</span></p>
			<p>When you mark a method in a Spring Data JPA repository with the <strong class="source-inline">@Modifying</strong> annotation, it changes<a id="_idIndexMarker617"/> the behavior of that method in the <span class="No-Break">following ways:</span></p>
			<ul>
				<li><strong class="bold">Non-SELECT Query Execution</strong>: The <strong class="source-inline">@Modifying</strong> annotation indicates that the method is intended to execute a non-select query, such as an <strong class="source-inline">UPDATE</strong> or <span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break"> statement.</span></li>
				<li><strong class="bold">No Automatic Result Type Inference</strong>: With normal query methods in Spring Data JPA, the framework automatically infers the return type based on the method name. When you use the <strong class="source-inline">@Modifying</strong> annotation, the return type is not inferred automatically. Instead, you should explicitly specify the return type. Typically, the return type is <strong class="source-inline">int</strong> or <strong class="source-inline">void</strong>. For example, in the example above, <strong class="source-inline">transferCard</strong> returns an Integer. That number represents the number of rows affected. With Native Queries it is possible to return data, as shown in method <strong class="source-inline">tradeCardsBetweenUsers</strong>. PostgreSQL can return the rows impacted using the keyword <strong class="source-inline">RETURNING</strong> in the <strong class="source-inline">UPDATE</strong> command. This behavior can change depending on the <span class="No-Break">Database engine.</span></li>
				<li><strong class="bold">Flush Behavior</strong>: By default, Spring Data JPA does not automatically flush the persistence context to the database after executing a query method. However, when you use <strong class="source-inline">@Modifying</strong>, it will trigger a flush of the persistence context to synchronize the changes with <span class="No-Break">the database.</span></li>
				<li><strong class="bold">Transaction Requirement</strong>: Modifying query methods should be executed within a transaction context. If the method is called without an active transaction, it will typically result in an exception when using JPQL queries. For Native Queries, this behavior does not apply. We will cover in more detail transaction management in another recipe of <span class="No-Break">this chapter.</span></li>
			</ul>
			<p>In this recipe, we used JPQL queries and native queries. As mentioned in previous recipes, JPQL has the primary advantage of using your Entities, being able to make a type-safety check, and abstracting the complexities of accessing the <span class="No-Break">underlying database.</span></p>
			<p>Native Queries can be necessary<a id="_idIndexMarker618"/> when you need to fine tune your queries and optimize the access to the database. Taking the example of <strong class="source-inline">assignCardsToUserAlbums</strong>, the same operation using just JPQL and business logic in your Java application will require several calls to the database, transferring data from the database and to the database. This communication overhead is not a negligible cost for large-scale applications. In the implementation of <strong class="source-inline">assignCardsToUserAlbums</strong>, it is just one single call to PostgreSQL that performs all the updates and returns just the cards updated to be returned to the <span class="No-Break">caller component.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor252"/>See also</h2>
			<p>Check the <em class="italic">Using Dynamic Queries</em> and <em class="italic">Using Transactions</em> recipes to deeper dive into <strong class="source-inline">EntityManager</strong> and transactions management in Spring <span class="No-Break">Data JPA.</span></p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor253"/>Using Dynamic Queries</h1>
			<p>In Spring Data JPA, a dynamic query <a id="_idIndexMarker619"/>refers to a type of query that is constructed at runtime based on various conditions or parameters. Dynamic queries are particularly useful when you need to build and execute queries that can vary based on user input or changing criteria. Instead of writing a static query with fixed criteria, you create a query that adapts to <span class="No-Break">different scenarios.</span></p>
			<p>Dynamic queries can be constructed using the Criteria API, or by creating the query statement dynamically using JPQL or Native SQL. The Criteria API provides a programmatic and type-safe way to define queries to <span class="No-Break">the database.</span></p>
			<p>In previous recipes, we used the naming convention of the <strong class="source-inline">JpaRepositories</strong> when creating the repository methods. Spring Data JPA generates the queries dynamically using the same mechanism we will explain in <span class="No-Break">this recipe.</span></p>
			<p>In this recipe, we will implement the <span class="No-Break">following functionalities:</span></p>
			<ul>
				<li>Search players using different criteria, for instance by name, height, <span class="No-Break">or weight.</span></li>
				<li>Search match events in a <span class="No-Break">time range.</span></li>
				<li>Delete match events in a <span class="No-Break">time range.</span></li>
				<li>Search the missing players that a user of the card trading game does not <span class="No-Break">have yet.</span></li>
			</ul>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor254"/>Getting ready</h2>
			<p>For this recipe, we don’t need additional tools compared to previous recipes. As the starting point of this exercise, we will use the completed version of <em class="italic">Updating Operations</em> recipe. If you didn’t complete it, you can find it in the book repository <span class="No-Break">at </span><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor255"/>How to do it...</h2>
			<p>For this recipe, we will create a new service component to perform all <span class="No-Break">dynamic queries.</span></p>
			<ol>
				<li>To do that, first create a new <strong class="source-inline">Service</strong> named <strong class="source-inline">DynamicQueriesService</strong>. The service requires an <strong class="source-inline">EntityManager</strong>. For that reason, we need to declare a parameter in the constructor to ensure that the IoC container <span class="No-Break">injects it.</span><pre class="source-code">
@Service
public class DynamicQueriesService {
}</pre></li>				<li>In this service, we can create<a id="_idIndexMarker620"/> a method to search players using different criteria. Each criteria are optional, so we need to construct the query dynamically depending on the parameters provided. We will use the <strong class="source-inline">CriteriaBuilder</strong> class for <span class="No-Break">that purpose.</span><pre class="source-code">
Public List&lt;PlayerEntity&gt; searchTeamPlayers(Integer teamId, Optional&lt;String&gt; name, Optional&lt;Integer&gt; minHeight,
            Optional&lt;Integer&gt; maxHeight,
            Optional&lt;Integer&gt; minWeight, Optional&lt;Integer&gt; maxWeight) {
    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery&lt;PlayerEntity&gt; cq = cb.createQuery(PlayerEntity.class);
    Root&lt;PlayerEntity&gt; player = cq.from(PlayerEntity.class);
    List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();
    predicates.add(cb.equal(player.get("team").get("id"), teamId));
    if (name.isPresent()) {
        predicates.add(cb.like(player.get("name"), name.get()));
    }
    if (minHeight.isPresent()) {
        predicates.add(cb.ge(player.get("height"), minHeight.get()));
    }
    if (maxHeight.isPresent()) {
        predicates.add(cb.le(player.get("height"), maxHeight.get()));
    }
    if (minWeight.isPresent()) {
        predicates.add(cb.ge(player.get("weight"), minWeight.get()));
    }
    if (maxWeight.isPresent()) {
        predicates.add(cb.le(player.get("weight"), maxWeight.get()));
    }
    cq.where(predicates.toArray(new Predicate[0]));
    TypedQuery&lt;PlayerEntity&gt; query = em.createQuery(cq);
    return query.getResultList();
}</pre><p class="list-inset">In this example, we used the criteria<a id="_idIndexMarker621"/> query as a parameter for the <strong class="source-inline">EntityManager</strong> method <strong class="source-inline">createQuery</strong>, then we used the query to retrieve <span class="No-Break">the results.</span></p></li>				<li>Let’s implement another example, this time using JPQL statements. We will search events of a match in a <span class="No-Break">time range:</span><pre class="source-code">
public List&lt;MatchEventEntity&gt; searchMatchEventsRange(Integer matchId, Optional&lt;LocalDateTime&gt; minTime, Optional&lt;LocalDateTime&gt; maxTime) {
    String command = "SELECT e FROM MatchEventEntity e WHERE e.match.id=:matchId ";
    if (minTime.isPresent() &amp;&amp; maxTime.isPresent()) {
        command += " AND e.time BETWEEN :minTime AND :maxTime";
    } else if (minTime.isPresent()) {
        command += " AND e.time &gt;= :minTime";
    } else if (maxTime.isPresent()) {
        command += " AND e.time &lt;= :maxTime";
    }
    TypedQuery&lt;MatchEventEntity&gt; query = em.createQuery(command, MatchEventEntity.class);
    query.setParameter("matchId", matchId);
    if (minTime.isPresent()) {
        query.setParameter("minTime", minTime.get());
    }
    if (maxTime.isPresent()) {
        query.setParameter("maxTime", maxTime.get());
    }
    return query.getResultList();
}</pre><p class="list-inset">Now the query is created<a id="_idIndexMarker622"/> using a String that is passed again to the <strong class="source-inline">createQuery</strong> method of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">EntityManager</strong></span><span class="No-Break">.</span></p><p class="list-inset">As you can see, the command contains named parameters that must be passed to <span class="No-Break">the query.</span></p></li>				<li>We can use Native SQL commands as well. Let’s search for the players that a user doesn’t have yet for his or <span class="No-Break">her album.</span><pre class="source-code">
public List&lt;PlayerEntity&gt; searchUserMissingPlayers(Integer userId) {
    Query query = em.createNativeQuery(
    "SELECT p1.* FROM players p1 WHERE p1.id NOT IN (SELECT c1.player_id FROM cards c1 WHERE c1.owner_id=?1)",
    PlayerEntity.class);
    query.setParameter(1, userId);
    return query.getResultList();
}</pre><p class="list-inset">To execute the native<a id="_idIndexMarker623"/> query, we now pass the String containing the native SQL command to the <span class="No-Break"><strong class="source-inline">createNativeQuery</strong></span><span class="No-Break"> method.</span></p></li>				<li>Now we will create a method to perform a delete operation. We will delete the events of a match in a certain time range. We will use JPQL to perform <span class="No-Break">this functionality.</span><pre class="source-code">
public void deleteEventRange(Integer matchId, LocalDateTime start, LocalDateTime end) {
    em.getTransaction().begin();
    Query query = em.createQuery("DELETE FROM MatchEventEntity e WHERE e.match.id=:matchId AND e.time BETWEEN :start AND :end");
    query.setParameter("matchId", matchId);
    query.setParameter("start", start);
    query.setParameter("end", end);
    query.executeUpdate();
    em.getTransaction().commit();
}</pre><p class="list-inset">To perform an update, we need to call the <strong class="source-inline">executeUpdate</strong> method. Note that this type of modifying operation requires an <span class="No-Break">active transaction.</span></p></li>			</ol>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor256"/>How it works...</h2>
			<p>As explained in the previous<a id="_idIndexMarker624"/> recipe, in Spring Data JPA, the <strong class="source-inline">EntityManager</strong> is the central component for managing the persistence context. It provides methods for persisting, retrieving, and <span class="No-Break">managing entities.</span></p>
			<p>When using JPQL, the <strong class="source-inline">EntityManager</strong> compiles the query, not only to validate the syntax but also to check the consistency with the Entities of our project, then translates the query to native SQL and binds the parameters. After executing the query, <strong class="source-inline">EntityManager</strong> maps the results into the managed entities. The resulting entities are tracked by the <strong class="source-inline">EntityManager</strong> for any change or further <span class="No-Break">persistence operation.</span></p>
			<p>If you have a query that will be executed multiple times, you can use a Named Query, as it is precompiled and cached for better performance. For that, you can call the <span class="No-Break"><strong class="source-inline">createNamedQuery</strong></span><span class="No-Break"> method.</span></p>
			<p>For Native queries, it is a bit simpler as it doesn’t compile nor validates the consistency, and it directly executes the query, mapping the results to the Entity specified. As discussed in previous recipes, it has advantages and trade-offs that you will need to evaluate depending on the needs of <span class="No-Break">your application.</span></p>
			<p>In the examples, we used Criteria Query and just a String containing the command. In general, I prefer Criteria Query because using it helps you avoid typos while building your query. In addition, Criteria Query is protected against SQL Injection attacks. If you build your query just concatenating Strings, be sure that you don’t use parameters provided by the user directly as it will make your query vulnerable to SQL Injection attacks. When using parameters provided by the user, be sure that they are always passed as query parameters and never directly concatenated to the command string. See for example the method <strong class="source-inline">searchMatchEventsRange</strong>. In it, the parameters influence the SQL command generated, but they are always passed as <span class="No-Break">query parameters.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor257"/>There’s more...</h2>
			<p>I created a controller to use the methods created in this recipe. You can find it in the book’s GitHub repository. In that project I enabled swagger UI, so you can use it to test <span class="No-Break">the methods.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor258"/>See also</h2>
			<p>There is a lot of literature<a id="_idIndexMarker625"/> about SQL Injection. If you are not familiar with it, you can check the Wikipedia <span class="No-Break">page: </span><a href="https://en.wikipedia.org/wiki/SQL_injection"><span class="No-Break">https://en.wikipedia.org/wiki/SQL_injection</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor259"/>Using Transactions</h1>
			<p>Transactions play a crucial role<a id="_idIndexMarker626"/> when working with databases to ensure data consistency and integrity. In Spring Data JPA, you can manage transactions using the Spring Framework’s transaction <span class="No-Break">management capabilities.</span></p>
			<p>In previous recipes, we implicitly used transactions, as some features require its usage; for instance, using <strong class="source-inline">@Modifiying</strong> annotation creates a transaction behind the scenes. In this recipe, we will learn more about transactions and how to use them in Spring <span class="No-Break">Boot applications.</span></p>
			<p>As an example of using transactions in Spring Boot applications, we will use them to manage the trading card operations between users. In a high-concurrency scenario, we want to ensure that users can exchange their cards with consistency <span class="No-Break">and integrity.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor260"/>Getting ready</h2>
			<p>For this recipe, we don’t need additional tools compared to previous recipes. As a starting point of this exercise, you can use a project that I prepared with the previous recipes in this chapter. You can find it in the book’s repository <span class="No-Break">at </span><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor261"/>How to do it...</h2>
			<p>To implement the card trading scenario, we will enhance the <strong class="source-inline">AlbumsService</strong> to manage the card exchange between <span class="No-Break">users consistently.</span></p>
			<ol>
				<li>Open the service <strong class="source-inline">AlbumsService</strong> and find the method <strong class="source-inline">tradeAllCards</strong>. The functionality we want to achieve with this method is <span class="No-Break">the following:</span><ul><li>Users can have <span class="No-Break">repeated cards.</span></li><li>They can exchange cards <span class="No-Break">between them.</span></li><li>They want to exchange the cards necessary to complete <span class="No-Break">the albums.</span></li><li>A trading operation involves the same number of cards from each user. If Sara gives three cards to Paul, Paul should give three cards to Sara <span class="No-Break">in return.</span></li></ul><p class="list-inset">To implement this functionality, first we need<a id="_idIndexMarker627"/> to know how many cards two users <span class="No-Break">can exchange:</span></p><pre class="source-code">
Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1, userId2);
Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2, userId1);
Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);</pre><p class="list-inset">If both users have cards that can be exchanged, then they exchange a number of cards from one user to another, and then the same in the other direction. To avoid the same cards being exchanged in both directions, once a user receives the cards, they are used. Therefore these cards are not available <span class="No-Break">for exchange.</span></p><pre class="source-code">ArrayList&lt;CardEntity&gt; result = new ArrayList&lt;&gt;(
                    cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
useAllCardAvailable(userId2);
result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
useAllCardAvailable(userId1);</pre></li>				<li>We want to perform all actions described in step 1consistently, and in case of an error, we want users to have the same cards they had before starting the trading operation. For this, we only need<a id="_idIndexMarker628"/> to annotate the method with <strong class="source-inline">@Transactional</strong>. The full method should look <span class="No-Break">like this:</span><pre class="source-code">
@Transactional
public List&lt;Card&gt; tradeAllCards(Integer userId1, Integer userId2) {
    Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1, userId2);
    Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2, userId1);
    Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
    if (count &gt; 0) {
     ArrayList&lt;CardEntity&gt; result = new ArrayList&lt;&gt;(
                    cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
     useAllCardAvailable(userId2);
     result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
     useAllCardAvailable(userId1);
}</pre><p class="list-inset">There is some boilerplate code used to return data to be consumed by the RESTful API. It has been omitted for brevity, but you can find the full method in the <span class="No-Break">GitHub repository.</span></p><p class="list-inset">If there is an exception during the execution of this method, the transaction will be automatically rolled-back, keeping the state as it was before starting the transaction. Let’s modify<a id="_idIndexMarker629"/> this method to add <span class="No-Break">some validations.</span></p><p class="list-inset">We will check that the number of cards traded are the same. For that, change the invocation to <strong class="source-inline">tradeCardsBetweenUsers </strong><span class="No-Break">as follows:</span></p><pre class="source-code">ArrayList&lt;CardEntity&gt; result1 = new ArrayList&lt;&gt;(
    cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
useAllCardAvailable(userId2);
ArrayList&lt;CardEntity&gt; result2 = new ArrayList&lt;&gt;(
    cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
useAllCardAvailable(userId1);
if (result1.size() != result2.size()) {
    throw new RuntimeException("Users have different number of cards");
}</pre></li>				<li>We can achieve a similar functionality by controlling the isolation of the transaction. You can do it by changing <strong class="source-inline">@Transactional</strong> annotation properties. If you set the transaction isolation level to <strong class="source-inline">Serializable</strong>, you ensure that the data used in your transaction is not read by any <span class="No-Break">other transaction.</span><pre class="source-code">
<strong class="bold">@Transactional(isolation = Isolation.SERIALIZABLE)</strong>
public List&lt;Card&gt; tradeAllCards(Integer userId1, Integer userId2) {
    Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1, userId2);
    Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2, userId1);
    Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
    if (count &gt; 0) {
        ArrayList&lt;CardEntity&gt; result1 = new ArrayList&lt;&gt;(
                    cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
        useAllCardAvailable(userId2);
        ArrayList&lt;CardEntity&gt; result2 = new ArrayList&lt;&gt;(
                    cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
        useAllCardAvailable(userId1);
        …
    }
}</pre><p class="list-inset">This solution may seem more convenient as it simplifies the code and ensures consistency. However, in most scenarios, it can be an overkill. This kind of isolation is very costly for the database engine and can cause database locks and contention, degrading the performance of our application. It is a powerful mechanism but should be used<a id="_idIndexMarker630"/> wisely. We will explain in more detail in <em class="italic">How it </em><span class="No-Break"><em class="italic">works</em></span><span class="No-Break"> section.</span></p></li>			</ol>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor262"/>How it works...</h2>
			<p>When we use the <strong class="source-inline">@Transactional</strong> annotation in a method, Spring Data JPA creates a transaction when the method is invoked. If the method completes without errors, it commits the transaction and changes are confirmed. If an exception is thrown, Spring Data JPA rollbacks the transaction, setting the data to its <span class="No-Break">previous state.</span></p>
			<p>The <strong class="source-inline">@Transactional</strong> annotation can be applied at the class level. Then, Spring Data JPA applies the same behavior to all methods in <span class="No-Break">that class.</span></p>
			<p>An important concept to understand is transaction isolation. Why do we need to care about it? The key concept is concurrency. In concurrent systems, such as web applications, there are multiple operations simultaneously. Taking our card trading example, let’s figure something out. During special events, there can be thousands or millions of users exchanging their cards. What happens if, for example, while trading between Sara and Paul, it turns out that Paul has already exchanged his cards with Joanna? If we don’t control this scenario, it can happen that Sara gives her cards to Paul and Paul gives nothing to Sara. As we saw in the exercise, we can use some business logic to control this situation, or we can use higher isolation levels in the transaction. I recommend using higher isolation levels only when strictly required, as it hurts performance in high <span class="No-Break">concurrent</span><span class="No-Break"><a id="_idIndexMarker631"/></span><span class="No-Break"> transactions.</span></p>
			<p>In the example above we used <strong class="source-inline">Serializable</strong> isolation, which is the highest level of isolation. There are more in Spring <span class="No-Break">Data JPA:</span></p>
			<ul>
				<li><strong class="source-inline">Isolation.DEFAULT</strong>: The default isolation level is determined by the <span class="No-Break">underlying database.</span></li>
				<li><strong class="source-inline">Isolation.READ_UNCOMMITTED</strong>: Allows dirty reads, non-repeatable reads, and <span class="No-Break">phantom reads.</span></li>
				<li><strong class="source-inline">Isolation.READ_COMMITTED</strong>: Prevents dirty reads but allows non-repeatable reads and <span class="No-Break">phantom reads.</span></li>
				<li><strong class="source-inline">Isolation.REPEATABLE_READ</strong>: Prevents dirty reads and non-repeatable reads but allows <span class="No-Break">phantom reads.</span></li>
				<li><strong class="source-inline">Isolation.SERIALIZABLE</strong>: Provides the highest level of isolation, preventing dirty reads, non-repeatable reads, and <span class="No-Break">phantom reads.</span></li>
			</ul>
			<p>Keep in mind that the implementation of the isolation level relies on the underlying database engine, and there are some levels that may not <span class="No-Break">be supported.</span></p>
			<p>To define the Isolation levels, I used some terms that is worth explaining <span class="No-Break">in detail:</span></p>
			<ul>
				<li><strong class="bold">Dirty Reads</strong>: A dirty read occurs when<a id="_idIndexMarker632"/> one transaction reads data that has been modified by another transaction but not yet committed. In our example, it could be cards that were available for one user, that are no longer available once they have <span class="No-Break">been exchanged.</span></li>
				<li><strong class="bold">Non-Repeatable Reads</strong> (Uncommitted Data): Non-repeatable<a id="_idIndexMarker633"/> reads (or uncommitted data) occur when a transaction reads the same data multiple times during its execution, but the data changes between reads due<a id="_idIndexMarker634"/> to updates by <span class="No-Break">other transactions.</span></li>
				<li><strong class="bold">Phantom Reads</strong>: Phantom reads occur when a transaction<a id="_idIndexMarker635"/> reads a set of records that satisfy a certain condition, and then, in a subsequent read of the same records, additional records match the condition due to inserts by <span class="No-Break">other transactions.</span></li>
			</ul>
			<p>There is another concept<a id="_idIndexMarker636"/> that we haven’t used in the example but is a core part of the Spring Data JPA. It is transaction propagation. What happens if a method annotated as <strong class="source-inline">@Transactional</strong> calls another <strong class="source-inline">@Transactional</strong> method? Are they executed in the same transaction or different ones? This behavior can be configured using the propagation attribute of <strong class="source-inline">@Transactional</strong> annotation. <span class="No-Break">For instance:</span></p>
			<pre class="source-code">
@Transactional(propagation = Propagation.REQUIRES_NEW)</pre>			<p>These are propagation <span class="No-Break">possible values:</span></p>
			<ul>
				<li>REQUIRED (Default): If an existing transaction doesn’t exist, a new transaction is started. If an existing transaction does exist, the method participates in <span class="No-Break">that transaction.</span></li>
				<li>REQUIRES_NEW: A new transaction is always started, suspending any existing transactions. The method always runs in a new transaction, even if there was an ongoing <span class="No-Break">transaction before.</span></li>
				<li>NESTED: Creates a “nested” transaction within the existing transaction, allowing for savepoints. If the nested transaction fails, it can roll back to the savepoint without affecting the <span class="No-Break">outer transaction.</span></li>
				<li>NOT_SUPPORTED: The method runs without a transaction context. If an existing transaction exists, it’s suspended while the <span class="No-Break">method runs.</span></li>
				<li>MANDATORY: Requires an existing transaction to be present. If no transaction exists, an exception <span class="No-Break">is thrown.</span></li>
				<li>NEVER: The method must not be run within a transaction context. If a transaction exists, an exception <span class="No-Break">is thrown.</span></li>
			</ul>
			<p>With propagation options, you can decide if you want to commit or rollback all changes, or you want to allow that some parts of the changes can be committed or <span class="No-Break">rolled-back independently.</span></p>
			<p>As you can see there many options related to transactions. I tend to use the default behavior and keep everything<a id="_idIndexMarker637"/> as simple as possible and use the available options when they <span class="No-Break">are necessary.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor263"/>There’s more...</h2>
			<p>Here, we have used a declarative approach to implement transactions, but you can execute transactions with <strong class="source-inline">EntityManager</strong>, for instance when using <span class="No-Break">Dynamic Queries.</span></p>
			<pre class="source-code">
em.getTransaction().begin();
// do your changes
em.getTransaction().commit();</pre>			<p>Keep in mind that this way is more manual, so you need to properly manage the exceptions to rollback the transaction when needed. Usually, you will begin and commit your transaction inside a <strong class="source-inline">try</strong> block and you will rollback the transaction when an exception happens. That will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
try {
    em.getTransaction().begin();
    …
    em.getTransaction().commit();
} catch (Exception e) {
    em.getTransaction().rollback();
}</pre>			<p>It is important to close the transactions as soon as possible, as depending on the level of isolation, they can lock data in the database and cause <span class="No-Break">unwanted contention.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor264"/>See also</h2>
			<p>It is possible to create distributed transactions involving more than one microservice, but doing so can be complex and comes with challenges. Distributed transactions that span multiple microservices require careful design and consideration of the distributed nature of microservices architectures. Traditional <strong class="bold">two-phase commit</strong> (<strong class="bold">2PC</strong>) is one way to achieve <a id="_idIndexMarker638"/>distributed transactions, but it’s often avoided due to its complexity and p<a id="_idTextAnchor265"/>otential for blocking and performance issues. Instead, many microservices architectures favor patterns like the Saga pattern or <span class="No-Break">compensation-based transactions.</span></p>
			<p>Here are some approaches for handling distributed transactions across <span class="No-Break">multiple microservices:</span></p>
			<ul>
				<li><strong class="bold">Saga Pattern</strong>: It is a way to maintain data consistency<a id="_idIndexMarker639"/> in a microservices architecture without relying on distributed transactions. In a saga, each microservice performs its part of the transaction and publishes events to inform other services about their actions. If an error occurs, compensating transactions are executed to revert previous actions. This pattern allows for eventual consistency and is often preferred <span class="No-Break">in microservices.</span></li>
				<li><strong class="bold">Asynchronous Messaging</strong>: Instead of tightly coupling<a id="_idIndexMarker640"/> microservices in a distributed transaction, you can use asynchronous messaging (e.g., with message queues) to communicate between services. Microservices can publish events when they complete their part of the work, and other services can consume these events and <span class="No-Break">act accordingly.</span></li>
				<li><strong class="bold">Compensating Transactions</strong>: In cases where something goes wrong, compensating transactions<a id="_idIndexMarker641"/> can be used to undo the changes made by a microservice. This is part of the Saga pattern and can help maintain <span class="No-Break">data consistency.</span></li>
				<li><strong class="bold">API Gateway</strong>: An API gateway can be used<a id="_idIndexMarker642"/> to orchestrate requests to multiple microservices as part of a single transaction. It can provide an API endpoint that aggregates multiple requests and enforces <span class="No-Break">transactional semantics.</span></li>
				<li><strong class="bold">Distributed Transaction Coordinator</strong> (<strong class="bold">DTC</strong>): While not commonly used in microservices<a id="_idIndexMarker643"/> architectures, you can implement a DTC that spans multiple microservices. However, this approach can introduce complexity and potential <span class="No-Break">performance bottlenecks.</span></li>
			</ul>
		</div>
	</body></html>