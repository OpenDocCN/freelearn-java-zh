- en: Overview of GOF Design Patterns - Core Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll be given an overview of GOF Design Patterns, including
    some best practices for making an application design. You'll also get an overview
    of common problem--solving with design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will explain the design patterns that are commonly used by the Spring Framework
    for better design and architecture. We are all in a global world, which means
    that if we have services in the market, they can be accessed across the Globe.
    Simply put, now is the age of the distributed computing system. So first, what
    is a distributed system? It''s an application that is divided into smaller parts
    that run simultaneously on different computers and the smaller parts communicate
    over the network, generally using protocols. These smaller parts are called **tiers**.
    So if we want to create a distributed application, *n*-tier architecture is a
    better choice for that type of application. But developing an *n*-tier distributed
    application is a complex and challenging job. Distributing the processing into
    separate tiers leads to better resource utilization. It also support the allocation
    of tasks to experts who are best suited to work and develop a particular tier.
    Many challenges exist in developing distributed applications, some of which are
    detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Integration between the tiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency handling of enterprise data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security of the application and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So my focus in this book is on simplifying Java EE application design and development
    by applying patterns and best practices with the Spring Framework. In this book,
    I will cover some common GOF Design Patterns, and how Spring adopted these for
    providing the best solutions to the aforementioned listed problems of enterprise
    application because the design of distributed objects is an immensely complicated
    task, even for experienced professionals. You need to consider critical issues,
    such as scalability, performance, transactions, and so on, before drafting a final
    solution. That solution is described as a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will understand how design patterns provide
    the best solution to address any design-related and development-related issues,
    and how to start development with the best practices. Here, you will get more
    ideas about GOF Design Patterns, with real-life examples. You will get information
    about how the Spring Framework implements these design patterns internally to
    provide the best enterprise solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the power of design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common GOF Design Patterns overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core design patterns
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creational design patterns
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural design patterns
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral design patterns
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: J2EE design patterns
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns at presentation layer
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns at business layer
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns at integration layer
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some best practices for Spring application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the power of design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what is a design pattern? Actually, the phrase design pattern is not associated
    with any programming language, and also it doesn't provide language-specific solutions
    to problems. A design pattern is associated with the solution to repetitive problems.
    For example, if any problem occurs frequently, a solution to that problem has
    been used effectively. Any non-reusable solution to a problem can't be considered
    a pattern, but the problem must occur frequently in order to have a reusable solution,
    and to be considered as a pattern. So a design pattern is a software engineering
    concept describing recurring solutions to common problems in software design.
    Design patterns also represent the best practices used by experienced object-oriented
    software developers.
  prefs: []
  type: TYPE_NORMAL
- en: When you make a design for an application, you should consider all the solutions
    to common problems, and these solutions are called **design patterns**. The understanding
    of design patterns must be good across the developer team so that the staff can
    communicate with each other effectively. In fact, you may be familiar with some
    design patterns; however, you may not have used well-known names to describe them.
    This book will take you through a step-by-step approach and show you examples
    that use Java while you learn design pattern concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A design pattern has three main characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: A Design pattern is *specific to a particular scenario* rather than a specific
    platform. So its context is the surrounding condition under which the problem
    exists. The context must be documented within the pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns have been *evolved to provide the best solutions* to certain
    problems faced during software development. So this should be limited by the context
    in which it is being considered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns are *the remedy for the problems under consideration*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if a developer is referring to the GOF Singleton design pattern
    and signifies the use of a single object, then all developers involved should
    understand that you need to design an object that will only have a single instance
    in the application. So the Singleton design pattern will be composed of a single
    object and the developers can tell each other that the program is following a
    Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Common GoF Design Pattern overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The authors Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides are
    often referred to as the GoF, or Gang of Four. They published a book titled *Design
    Patterns: Elements of Reusable Object-Oriented Software*, which initiated the
    concept of design patterns in software development.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn what GOF patterns are and how they help solve
    common problems encountered in object-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Gang of Four** (**GoF**) patterns are 23 classic software design patterns
    providing recurring solutions to common problems in software design. The patterns
    are defined in the book *Design Patterns: Elements of Reusable Object-Oriented
    Software*. These patterns are categorized into two main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Core Design Patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: J2EE Design Patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, **Core Design Patterns** are also subdivided into three main categories
    of design pattern, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational Design Pattern**: Patterns under this category provide a way to
    construct objects when constructors will not serve your purpose. The creation
    logic of objects is hidden. The programs based on these patterns are more flexible
    in deciding object creation according to your demands and your use cases for the
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural Design Pattern**: Patterns under this category deal with the composition
    of classes or objects. In the enterprise application, there are two commonly used
    techniques for reusing functionality in object-oriented systems: one is class
    Inheritance and the other is the Object Composition Concept of inheritance. The
    Object Composition Concept of inheritance is used to compose interfaces and define
    ways to compose objects to obtain new functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral Design Pattern**: Patterns under this category, characterize the
    ways in which classes or objects interact and distribute responsibility. These
    design patterns are specifically concerned with communication between objects.
    The behavioral design pattern is used to control and reduce complicated application
    flow in the enterprise application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s look at the other category, the **JEE Design patterns**. This is
    the other main category of design patterns. Application design can be immensely
    simplified by applying Java EE design patterns. Java EE design patterns have been
    documented in Sun''s Java Blueprints. These Java EE Design patterns provide time-tested
    solution guidelines and best practices for object interaction in the different
    layers of a Java EE application. These design patterns are specifically concerned
    with the following listed layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Design pattern at the presentation layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design pattern at the business layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design pattern at the integration layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore creational design patterns in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the underlying design patterns of this category and how Spring
    Framework adopts them to provide loose coupling between components and create
    and manage the lifecycle of Spring components. Creational design patterns are
    associated with the method of object creation. The creation logic of the object
    is hidden to the caller of this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are all aware of how to create an object using the `new` keyword in Java,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But this way is not suitable for some cases, because it is a hardcoded way of
    creating an object. It is also not a best practice to create an object because
    the object might be changed according to the nature of the program. Here, the
    creational design pattern provides the flexibility to create an object according
    to the nature of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the different design patterns under this category.
  prefs: []
  type: TYPE_NORMAL
- en: Factory design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Define an interface for creating an object, but let subclasses decide which
    class to instantiate. Factory Method lets a class defer instantiation to subclasses.*'
  prefs: []
  type: TYPE_NORMAL
- en: '- GOF Design Pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The Factory design pattern is a creational design pattern. The Factory design
    pattern is also known as the Factory method design pattern. According to this
    design pattern, you get an object of a class without exposing the underlying logic
    to the client. It assigns a new object to the caller by using a common interface
    or abstract class. This means that the design pattern hides the actual logic of
    the implementation of an object, how to create it, and which class to instantiate
    it in. So the client shouldn't worry about creating, managing, and destroying
    an object-the Factory pattern takes responsibility for these tasks. The Factory
    pattern is one of the most-used design patterns in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the benefits of the Factory pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The Factory pattern promotes loose coupling between collaborating components
    or classes by using interfaces rather than binding application-specific classes
    into the application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using this pattern, you can get an implementation of an object of classes that
    implement an interface, at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object life cycle is managed by the factory implemented by this pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s discuss some common problems where you should apply the Factory
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern removes the burden on the developer to create and manage the objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern removes the tight coupling between collaboration components because
    a component doesn't know what subclasses it will be required to create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid hard code to create an object of the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Factory design pattern in Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Framework transparently uses this Factory design pattern to implement
    Spring containers using `BeanFactory` and `ApplicationContext` interfaces. Spring's
    container works based on the Factory pattern to create spring beans for the Spring
    application and also manages the life cycle of every Spring bean. `BeanFactory`
    and `ApplicationContext` are factory interfaces, and Spring has lots of implementing
    classes. The `getBean()`method is the factory method that gives you Spring beans
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a sample implementation of the Factory design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sample implementation of the Factory design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two classes `SavingAccount` and `CurrentAccount` implementing an
    interface `Account`. So, you can create a `Factory` class with a method that takes
    one or more arguments and its return type is `Account`. This method is known as
    the Factory method because it creates the instances of either `CurrentAccount`
    or `SavingAccount`. The `Account` interface is used for loose coupling. So, according
    to the passed arguments in the factory method, it chooses which subclass to instantiate.
    This factory method will have the superclass as its return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c60c9cd5-b79a-4a6b-9966-6afe4a68c056.png)'
  prefs: []
  type: TYPE_IMG
- en: UML Diagram for the Factory design pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this design pattern in the following example. Here, I am going
    to create an `Account` interface and some concrete classes that implement the
    `Account` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create `SavingAccount.java`, which will implement the `Account`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Same with `CurrentAccount.java`, it will also implement the `Account` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A Factory class `AccountFactory` is now going to be defined. `AccountFactory`
    generates an object of the concrete class, either `SavingAccount` or `CurrentAccount,`
    based on the account type given as an argument to the Factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AccountFactory.java` is a Factory to produce the `Account` type object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`FactoryPatternMain` is the main calling class of `AccountFactory` to get an
    `Account` object. It will pass an argument to the factory method that contains
    information of the account type, such as `SAVING` and `CURRENT`. `AccountFactory`
    returns the object of the type that you passed to the factory method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a demo class `FactoryPatterMain.java` to test the factory method
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test this file and see the output on the console, which should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52068e84-43ce-438a-ba1d-83ed3ed69890.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've seen the Factory design pattern, let's turn to a different variant
    of it-the Abstract factory design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Provide an interface for creating families of related or dependent objects
    without specifying their concrete cla*sses. - GOF Design Patterns'
  prefs: []
  type: TYPE_NORMAL
- en: The Abstract Factory pattern comes under the creational design pattern. It is
    a high-level design pattern compared to the factory method design pattern. According
    to this design pattern, you just define an interface or abstract class to create
    a related dependent object without specifying its concrete subclass. So here,
    the abstract factory returns a factory of classes. Let me simplify it for you.
    You have a set of factory method design patterns, and you just put these factories
    under a factory using the factory design pattern, which means that it is simply
    a factory of factories. And there is no need to take the knowledge about all of
    the factories into the factory--you can make your program using a top-level factory.
  prefs: []
  type: TYPE_NORMAL
- en: In the Abstract Factory pattern, an interface is responsible for creating a
    factory of related objects without explicitly specifying their classes. Each generated
    factory can give the objects as per the Factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of the Abstract Factory pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Abstract Factory Design provides loose coupling between the component families.
    It also isolates the client code from concrete classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This design pattern is a higher-level design than the Factory pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern provides better consistency at construction time of objects across
    the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern easily swaps component families.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common problems where you should apply the Abstract factory design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you design a Factory pattern for object creation in your application, there
    are times when you want a particular set of related objects to be created with
    certain constraints and apply the desired logic across the related objects in
    your application. You can achieve this design by creating another factory inside
    the factory for a set of related objects and apply the required constraints. You
    can also program the logic to a set of related objects.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to customize the instantiation logic of related objects, then
    you could use this design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Abstract factory design pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Spring Framework, the `FactoryBean` interface is based on the Abstract
    Factory design pattern. Spring provides a lot of implementation of this interface,
    such as `ProxyFactoryBean`, `JndiFactoryBean`, `LocalSessionFactoryBean`, `LocalContainerEntityManagerFactoryBean`,
    and so on. A `FactoryBean` is also useful to help Spring construct objects that
    it couldn't easily construct itself. Often this is used to construct complex objects
    that have many dependencies. It might also be used when the construction logic
    itself is highly volatile and depends on the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Spring Framework, one of the `FactoryBean` implementations is
    `LocalSessionFactoryBean`, which is used to get a reference of a bean that was
    associated with the hibernate configuration. It is a specific configuration concerning
    the data source. It should be applied before you get an object of `SessionFactory`.
    You can use the `LocalSessionFactoryBean` to apply the specific data source configuration
    in a consistent way. You may inject the result of a FactoryBean's `getObject()`
    method into any other property.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a sample implementation of the Abstract Factory design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sample implementation of the Abstract Factory design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am going to create a `Bank` and `Account` interface and some concrete classes
    implementing these interfaces. Here, I also create an abstract factory class,
    `AbstractFactory`. I have some factory classes, `BankFactory` and `AccountFactory;`
    these classes extend the `AbstractFactory` class. I will also create a `FactoryProducer`
    class to create the factories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this design pattern in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8d85280-efd6-4c84-8214-3744f7296304.png)'
  prefs: []
  type: TYPE_IMG
- en: UML diagram for the Abstract Factory design pattern
  prefs: []
  type: TYPE_NORMAL
- en: Create a demo class, `AbstractFactoryPatternMain`; it uses `FactoryProducer`
    to get an `AbstractFactory` object. Here, I pass information such as `ICICI`,
    `YES` to `AbstractFactory` to get an object of `Bank`, and I also pass information
    such as `SAVING`, `CURRENT` to `AbstractFactory` to get an `Account` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `Bank.java`, which is an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create `ICICIBank.java`, which implements the `Bank` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another `YesBank.java`, an implementing `Bank` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I am using the same interface and implementing classes of `Account`
    as I used in the Factory pattern example in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractFactory.java` is an abstract class that is used to get factories for
    `Bank` and `Account` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`BankFactory.java` is a factory class extending `AbstractFactory` to generate
    an object of the concrete class based on the given information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`AccountFactory.java` is a factory class that extends `AbstractFactory.java`
    to generate an object of the concrete class based on the given information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`FactoryProducer.java` is a class that creates a Factory generator class to
    get factories by passing a piece of information, such as `Bank` or `Account`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`FactoryPatterMain.java` is a demo class for the Abstract Factory design pattern.
    `FactoryProducer` is a class to get `AbstractFactory` in order to get the factories
    of concrete classes by passing a piece of information, such as the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test this file and see the output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56f08c15-3ef2-4bd2-9384-e04bfe2e1058.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've seen the abstract Factory design pattern, let's turn to a different
    variant of it-the singleton design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Ensure a class has only one instance and provide a global point of access
    to it - GOF Design Patterns*'
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern is a creational design pattern, it is one of the simplest
    design patterns in Java. According to the singleton design pattern, the class
    provides the same single object for each call--that is, it is restricting the
    instantiation of a class to one object and provides a global point of access to
    that class. So the class is responsible for creating an object and also ensures
    that only a single object should be created for each client call for this object.
    This class doesn't allow a direct instantiation of an object of this class. It
    allows you to get an object instance only by an exposed static method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is useful when exactly one object is needed to coordinate actions across
    the system. You can create a single pattern using two forms, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early instantiation**: Creation of instance at load time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy instantiation**: Creation of instance when required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benefits of the Singleton pattern:**'
  prefs: []
  type: TYPE_NORMAL
- en: It provides controller access to crucial (usually heavy object) classes, such
    as the connection class for DB and the `SessionFactory` class in hibernate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It saves heaps of memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a very efficient design for multithreaded environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is more flexible because the class controls the instantiation process, and
    the class has the flexibility to change the instantiation process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has low latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common problems where you should apply Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern solves only one problem--if you have a resource that can
    only have a single instance, and you need to manage that single instance, then
    you need a singleton. Normally, if you want to create a database connection with
    the given configuration in the distributed and multithread environment, it might
    be the case that every thread can create a new database connection with a different
    configuration object, if you don't follow the singleton design. With the Singleton
    pattern, each thread gets the same database connection object with the same configuration
    object across the system. It is mostly used in multithreaded and database applications.
    It is used in logging, caching, thread pools, configuration settings, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton design pattern implementation in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Framework provides a Singleton scoped bean as a singleton pattern.
    It is similar to the singleton pattern, but it's not exactly the same as the Singleton
    pattern in Java. According to the Singleton pattern, a scoped bean in the Spring
    Framework means a single bean instance per container and per bean. If you define
    one bean for a particular class in a single Spring container, then the Spring
    container creates one and only one instance of the class defined by that bean
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a sample application of the singleton design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sample implementation of the Singleton design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following code example, I will be creating a class with a method to create
    an instance of this class if one does not exist. If the instance is already present,
    then it will simply return the reference of that object. I have also taken thread
    safety into consideration, and so I have used a synchronized block here before
    creating the object of that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the UML diagram for the Singleton design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to be noted in the preceding code is that I have written a private
    constructor of the `SingletonClass` class to make sure that there is no way to
    create the object of that class. This example is based on lazy initialization,
    which means that the program creates an instance on demand the first time. So
    you could also eagerly instantiate the object to improve the runtime performance
    of your application. Let''s see the same `SingletonClass` with eager initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've seen the singleton design pattern, let's turn to a different
    variant of it--the Prototype design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Specify the kind of objects to create using a prototypical instance, and create
    new objects by copying this prototype.* - GOF Design Patterns'
  prefs: []
  type: TYPE_NORMAL
- en: The Prototype pattern comes under the creational design pattern family of GOF
    patterns in software development. This pattern is used to create the objects by
    using a clone method of objects. It is determined by a prototypical instance.
    In the enterprise application, object creation is costly in terms of creating
    and initializing the initial properties of objects. If such a type of object is
    already in your hand, then you go for the prototype pattern; you just copy an
    existing similar object instead of creating it, which is time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern involves implementing a prototype interface, it creates a clone
    of the current object. This pattern is used when the direct creation of the object
    is costly. For example, say that an object is to be created after a costly database
    operation. We can cache the object, returns its clone on the next request, and
    update the database as and when it is needed, thus reducing database calls.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of the Prototype design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following list shows the benefits of using the Prototype pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduces the time to create the time-consuming objects by using the prototype
    pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern reduces subclassing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern adds and removes objects at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern configures the application with classes dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see the UML class structure of the Prototype design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: UML class structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following UML diagram shows all the components of the Prototype design
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d707f1e-6cb1-491f-9ac8-aa3b634fb6ad.png)'
  prefs: []
  type: TYPE_IMG
- en: UML diagram for Prototype design pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see these components as listed in following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prototype**: The Prototype is an interface. It is uses the clone method to
    create instances of this interface type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcretePrototype**: This is a concrete class of the Prototype interface
    to implement an operation to clone itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: This is a `caller` class to create a new object of a Prototype
    interface by calling a `clone` method of the prototype interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see a sample implementation of the prototype design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sample implementation of the Prototype design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am going to create an abstract `Account` class and concrete classes extending
    the `Account` class. An `AccountCache` class is defined as a next step, which
    stores account objects in a `HashMap` and returns their clone when requested.
    Create an abstract class implementing the `Clonable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create concrete classes extending the preceding class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `CurrentAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how `SavingAccount.java` should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a class to get concrete classes in the `AccountCache.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`PrototypePatternMain.java` is a demo class that we will use to test the design
    pattern `AccountCache` to get the `Account` object by passing a piece of information,
    such as the type, and then call the `clone()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've covered this so far and it's good. Now let's look at the next design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Builder design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Separate the construction of a complex object from its representation so that
    the same construction process can create different representations.* - GOF Design
    Patterns'
  prefs: []
  type: TYPE_NORMAL
- en: The Builder design pattern is used to construct a complex object step by step,
    and finally it will return the complete object. The logic and process of object
    creation should be generic so that you can use it to create different concrete
    implementations of the same object type. This pattern simplifies the construction
    of complex objects and it hides the details of the object's construction from
    the client caller code. When you are using this pattern, remember you have to
    build it one step at a time, which means you have to break the object construction
    login into multiple phases, unlike other patterns, such as the abstract factory
    and the factory method pattern, which the object in a single step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits of the Builder pattern:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern provides you with complete isolation between the construction and
    representation of an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern allows you to construct the object in multiple phases, so you have
    greater control over the construction process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern provides the flexibility to vary an object's internal representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UML class structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following UML diagram shows all the components of the Builder design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a88351cd-892f-4c63-911c-940c09fe227e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'UML diagram for the Builder design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Builder** (AccountBuilder): This is an abstract class or interface for creating
    the details of an Account object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteBuilder**: This is an implementation to construct and assemble details
    of the account by implementing the Builder interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Director**: This constructs an object using the Builder interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product** (Account): This represents the complex object under construction.
    `AccountBuilder` builds the account''s internal representation and defines the
    process by which it''s assembled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Builder pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Framework implements the Builder design pattern transparently in
    some functionalities. The following classes are based on the Builder design pattern
    in the Spring Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EmbeddedDatabaseBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthenticationManagerBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UriComponentsBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeanDefinitionBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockMvcWebClientBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common problems where you should apply Builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an enterprise application, you can apply the Builder pattern where the object
    creation has been done by using multiple steps. In each step, you do a portion
    of the process. In this process, you set some required parameters and some optional
    parameters, and after the final step, you will get a complex object.
  prefs: []
  type: TYPE_NORMAL
- en: The Builder pattern is an object creation software design pattern. The intention
    is to abstract the steps of construction so that different implementations of
    these steps can construct different representations of objects. Often, the Builder
    pattern is used to build products in accordance with the composite pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sample implementation of the Builder design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code example, I am going to create an `Account` class that
    has `AccountBuilder` as an inner class. The `AccountBuilder` class has a method
    to create an instance of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`AccountBuilderTest.java` is a demo class that we will use to test the design
    pattern. Let''s look at how to build an `Account` object by passing the initial
    information to the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test this file and see the output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68c90b98-5bfc-4f6e-bacd-6a7f75a4e268.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we've seen the Builder design pattern. In the upcoming [Chapter 3](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml),
    *Consideration of Structural and Behavioural* *Patterns,* I will explore another
    part of the GOF Design Patterns family.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, the reader should now have a good idea about the
    overview of GOF creational design patterns and its best practices. I highlighted
    the problems that come from not using design patterns in enterprise application
    development, and how Spring solves these problems by using the creational design
    patterns and good practices in the application. In this chapter, I have mentioned
    only one of the Creational Design pattern categories out of the three main categories
    of the GOF Design Patterns. The Creational design pattern is used for the creation
    of object instances, and also applies constraints at the creation time in the
    enterprise application in a specific manner using the Factory, Abstract Factory,
    Builder, Prototype, and Singleton patterns. In the next chapter, we will look
    at the other categories of the GOF Design Patterns-the structural design pattern
    and the behavioral design pattern. The structural design pattern is used to design
    the structure of an enterprise application by dealing with the composition of
    classes or objects so that it reduces the application's complexity and improves
    the reusability and performance of the application. The Adapter Pattern, Bridge
    Pattern, Composite Pattern, Decorator Pattern, Facade Pattern, and Flyweight Pattern
    come under this category of the pattern. The Behavioral design pattern characterizes
    the ways in which classes or objects interact and distribute responsibility. The
    patterns that come under this category are specifically concerned with communication
    between objects. Let's move to complete the remaining GOF patterns in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
