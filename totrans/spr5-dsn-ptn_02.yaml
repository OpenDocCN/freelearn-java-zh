- en: Overview of GOF Design Patterns - Core Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GOF设计模式概述 - 核心设计模式
- en: In this chapter, you'll be given an overview of GOF Design Patterns, including
    some best practices for making an application design. You'll also get an overview
    of common problem--solving with design patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将获得GOF设计模式的概述，包括一些制作应用程序设计的最佳实践。您还将了解使用设计模式进行常见问题解决的方法。
- en: 'I will explain the design patterns that are commonly used by the Spring Framework
    for better design and architecture. We are all in a global world, which means
    that if we have services in the market, they can be accessed across the Globe.
    Simply put, now is the age of the distributed computing system. So first, what
    is a distributed system? It''s an application that is divided into smaller parts
    that run simultaneously on different computers and the smaller parts communicate
    over the network, generally using protocols. These smaller parts are called **tiers**.
    So if we want to create a distributed application, *n*-tier architecture is a
    better choice for that type of application. But developing an *n*-tier distributed
    application is a complex and challenging job. Distributing the processing into
    separate tiers leads to better resource utilization. It also support the allocation
    of tasks to experts who are best suited to work and develop a particular tier.
    Many challenges exist in developing distributed applications, some of which are
    detailed here:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我将解释Spring框架常用的设计模式，以实现更好的设计和架构。我们都在一个全球化的世界中，这意味着如果我们有市场上的服务，它们可以在全球范围内访问。简单来说，现在是分布式计算系统的时代。所以首先，什么是分布式系统？它是一个被分成更小部分的应用程序，这些部分在不同的计算机上同时运行，并且这些小部分通过网络进行通信，通常使用协议。这些小部分被称为**层**。所以如果我们想创建一个分布式应用程序，*n*-层架构是那种类型应用程序的更好选择。但是开发*n*-层分布式应用程序是一项复杂且具有挑战性的工作。将处理分配到单独的层可以导致更好的资源利用。它还支持将任务分配给最适合在该层工作和开发的专业人士。在开发分布式应用程序中存在许多挑战，其中一些在此详细说明：
- en: Integration between the tiers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层之间的集成
- en: Transaction management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务管理
- en: Concurrency handling of enterprise data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业数据并发处理
- en: Security of the application and so on
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的安全性等
- en: So my focus in this book is on simplifying Java EE application design and development
    by applying patterns and best practices with the Spring Framework. In this book,
    I will cover some common GOF Design Patterns, and how Spring adopted these for
    providing the best solutions to the aforementioned listed problems of enterprise
    application because the design of distributed objects is an immensely complicated
    task, even for experienced professionals. You need to consider critical issues,
    such as scalability, performance, transactions, and so on, before drafting a final
    solution. That solution is described as a pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我在这本书中的重点是通过对Spring框架应用模式和最佳实践来简化Java EE应用程序的设计和开发。在这本书中，我将涵盖一些常见的GOF设计模式，以及Spring如何采用这些模式为上述企业应用程序问题提供最佳解决方案，因为分布式对象的设计对于经验丰富的专业人士来说也是一个极其复杂的工作。在制定最终解决方案之前，您需要考虑关键问题，如可伸缩性、性能、事务等。该解决方案被描述为一种模式。
- en: At the end of this chapter, you will understand how design patterns provide
    the best solution to address any design-related and development-related issues,
    and how to start development with the best practices. Here, you will get more
    ideas about GOF Design Patterns, with real-life examples. You will get information
    about how the Spring Framework implements these design patterns internally to
    provide the best enterprise solution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将了解设计模式如何提供最佳解决方案来解决任何与设计相关和开发相关的问题，以及如何以最佳实践开始开发。在这里，您将获得更多关于GOF设计模式的想法，以及实际生活中的例子。您将了解Spring框架如何内部实现这些设计模式以提供最佳的企业解决方案。
- en: 'This chapter will cover the following points:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下要点：
- en: Introducing the power of design patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍设计模式的力量
- en: Common GOF Design Patterns overview
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见GOF设计模式概述
- en: Core design patterns
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心设计模式
- en: Creational design patterns
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: Structural design patterns
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化设计模式
- en: Behavioral design patterns
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: J2EE design patterns
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: J2EE设计模式
- en: Design patterns at presentation layer
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示层的设计模式
- en: Design patterns at business layer
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务层的设计模式
- en: Design patterns at integration layer
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成层的设计模式
- en: Some best practices for Spring application development
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring应用程序开发的最佳实践
- en: Introducing the power of design patterns
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍设计模式的力量
- en: So what is a design pattern? Actually, the phrase design pattern is not associated
    with any programming language, and also it doesn't provide language-specific solutions
    to problems. A design pattern is associated with the solution to repetitive problems.
    For example, if any problem occurs frequently, a solution to that problem has
    been used effectively. Any non-reusable solution to a problem can't be considered
    a pattern, but the problem must occur frequently in order to have a reusable solution,
    and to be considered as a pattern. So a design pattern is a software engineering
    concept describing recurring solutions to common problems in software design.
    Design patterns also represent the best practices used by experienced object-oriented
    software developers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是设计模式呢？实际上，设计模式这个短语与任何编程语言都没有关联，它也不提供针对特定语言的解决方案。设计模式与重复性问题的解决方案相关。例如，如果任何问题频繁发生，那么针对该问题的解决方案已经被有效地使用过。任何不可重用的解决方案都不能被视为模式，但问题必须频繁发生，才能有可重用的解决方案，才能被视为模式。因此，设计模式是描述软件设计中常见问题重复解决方案的软件工程概念。设计模式还代表了经验丰富的面向对象软件开发者所使用的最佳实践。
- en: When you make a design for an application, you should consider all the solutions
    to common problems, and these solutions are called **design patterns**. The understanding
    of design patterns must be good across the developer team so that the staff can
    communicate with each other effectively. In fact, you may be familiar with some
    design patterns; however, you may not have used well-known names to describe them.
    This book will take you through a step-by-step approach and show you examples
    that use Java while you learn design pattern concepts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为应用程序进行设计时，你应该考虑所有常见问题的解决方案，这些解决方案被称为**设计模式**。设计模式的理解必须在开发团队中良好，以便员工能够有效地进行沟通。实际上，你可能熟悉一些设计模式；然而，你可能没有使用众所周知的名称来描述它们。这本书将带你通过逐步的方法，并在学习设计模式概念的同时，展示使用Java的示例。
- en: 'A design pattern has three main characteristics:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式有三个主要特征：
- en: A Design pattern is *specific to a particular scenario* rather than a specific
    platform. So its context is the surrounding condition under which the problem
    exists. The context must be documented within the pattern.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式是**特定于特定场景**的，而不是特定于某个平台。因此，其上下文是问题存在的周围条件。上下文必须在模式中予以记录。
- en: Design patterns have been *evolved to provide the best solutions* to certain
    problems faced during software development. So this should be limited by the context
    in which it is being considered.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式已经发展成提供针对软件开发过程中遇到的一些问题的**最佳解决方案**。因此，这应该限制在考虑的上下文中。
- en: Design patterns are *the remedy for the problems under consideration*.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式是**针对考虑中的问题的解决方案**。
- en: For example, if a developer is referring to the GOF Singleton design pattern
    and signifies the use of a single object, then all developers involved should
    understand that you need to design an object that will only have a single instance
    in the application. So the Singleton design pattern will be composed of a single
    object and the developers can tell each other that the program is following a
    Singleton pattern.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个开发者正在引用GOF单例设计模式并表明使用单个对象，那么所有涉及的开发者都应该理解你需要设计一个在应用程序中只会有一个实例的对象。因此，单例设计模式将由一个对象组成，开发者可以相互告知程序正在遵循单例模式。
- en: Common GoF Design Pattern overview
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见GoF设计模式概述
- en: 'The authors Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides are
    often referred to as the GoF, or Gang of Four. They published a book titled *Design
    Patterns: Elements of Reusable Object-Oriented Software*, which initiated the
    concept of design patterns in software development.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作者Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides通常被称为GoF，或四人帮。他们出版了一本名为《设计模式：可复用面向对象软件元素》的书，这标志着软件开发中设计模式概念的诞生。
- en: In this chapter, you will learn what GOF patterns are and how they help solve
    common problems encountered in object-oriented design.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习什么是GOF模式以及它们如何帮助解决面向对象设计中遇到的常见问题。
- en: 'The **Gang of Four** (**GoF**) patterns are 23 classic software design patterns
    providing recurring solutions to common problems in software design. The patterns
    are defined in the book *Design Patterns: Elements of Reusable Object-Oriented
    Software*. These patterns are categorized into two main categories:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**四人帮**（**GoF**）模式是23个经典的软件设计模式，为软件设计中的常见问题提供重复的解决方案。这些模式在书籍《设计模式：可复用面向对象软件元素》中定义。这些模式分为两大类：'
- en: Core Design Patterns
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心设计模式
- en: J2EE Design Patterns
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: J2EE设计模式
- en: 'Furthermore, **Core Design Patterns** are also subdivided into three main categories
    of design pattern, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**核心设计模式**也被细分为三个主要的设计模式类别，如下所示：
- en: '**Creational Design Pattern**: Patterns under this category provide a way to
    construct objects when constructors will not serve your purpose. The creation
    logic of objects is hidden. The programs based on these patterns are more flexible
    in deciding object creation according to your demands and your use cases for the
    application.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型设计模式**：这个类别下的模式提供了一种在构造函数无法满足需求时构建对象的方法。对象的创建逻辑是隐藏的。基于这些模式的程序在根据您的需求和应用程序的使用案例决定对象创建方面更加灵活。'
- en: '**Structural Design Pattern**: Patterns under this category deal with the composition
    of classes or objects. In the enterprise application, there are two commonly used
    techniques for reusing functionality in object-oriented systems: one is class
    Inheritance and the other is the Object Composition Concept of inheritance. The
    Object Composition Concept of inheritance is used to compose interfaces and define
    ways to compose objects to obtain new functionalities.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型设计模式**：这个类别下的模式处理类或对象的组合。在企业应用中，有两种常用的技术在面向对象系统中重用功能：一种是类继承，另一种是继承的对象组合概念。继承的对象组合概念用于组合接口，并定义组合对象以获得新功能的方法。'
- en: '**Behavioral Design Pattern**: Patterns under this category, characterize the
    ways in which classes or objects interact and distribute responsibility. These
    design patterns are specifically concerned with communication between objects.
    The behavioral design pattern is used to control and reduce complicated application
    flow in the enterprise application.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为设计模式**：这个类别下的模式描述了类或对象之间交互和分配责任的方式。这些设计模式特别关注对象之间的通信。行为设计模式用于控制并简化企业应用中的复杂应用流程。'
- en: 'Now, let''s look at the other category, the **JEE Design patterns**. This is
    the other main category of design patterns. Application design can be immensely
    simplified by applying Java EE design patterns. Java EE design patterns have been
    documented in Sun''s Java Blueprints. These Java EE Design patterns provide time-tested
    solution guidelines and best practices for object interaction in the different
    layers of a Java EE application. These design patterns are specifically concerned
    with the following listed layers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个类别，即**JEE设计模式**。这是设计模式的另一个主要类别。通过应用Java EE设计模式，可以极大地简化应用设计。Java EE设计模式已在Sun的Java
    Blueprints中进行了记录。这些Java EE设计模式提供了经过时间考验的解决方案指南和最佳实践，用于Java EE应用程序不同层中的对象交互。这些设计模式特别关注以下列出的层：
- en: Design pattern at the presentation layer
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呈现层的设计模式
- en: Design pattern at the business layer
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务层的设计模式
- en: Design pattern at the integration layer
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成层的设计模式
- en: Let's explore creational design patterns in the upcoming section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中探索创建型设计模式。
- en: Creational design patterns
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: Let's look at the underlying design patterns of this category and how Spring
    Framework adopts them to provide loose coupling between components and create
    and manage the lifecycle of Spring components. Creational design patterns are
    associated with the method of object creation. The creation logic of the object
    is hidden to the caller of this object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个类别背后的设计模式，以及Spring框架如何采用它们来提供组件之间的松耦合，并创建和管理Spring组件的生命周期。创建型设计模式与对象创建的方法相关联。对象的创建逻辑对调用者来说是隐藏的。
- en: 'We are all aware of how to create an object using the `new` keyword in Java,
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道如何在Java中使用`new`关键字创建对象，如下所示：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But this way is not suitable for some cases, because it is a hardcoded way of
    creating an object. It is also not a best practice to create an object because
    the object might be changed according to the nature of the program. Here, the
    creational design pattern provides the flexibility to create an object according
    to the nature of the program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法在某些情况下并不适用，因为它是一种硬编码创建对象的方式。根据程序的性质，创建对象也不是最佳实践。在这里，创建型设计模式提供了根据程序性质创建对象的灵活性。
- en: Now let's look at the different design patterns under this category.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个类别下的不同设计模式。
- en: Factory design pattern
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂设计模式
- en: '*Define an interface for creating an object, but let subclasses decide which
    class to instantiate. Factory Method lets a class defer instantiation to subclasses.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*定义一个用于创建对象的接口，但让子类决定要实例化的类。工厂方法允许一个类将实例化推迟到子类。*'
- en: '- GOF Design Pattern'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '- GOF 设计模式'
- en: The Factory design pattern is a creational design pattern. The Factory design
    pattern is also known as the Factory method design pattern. According to this
    design pattern, you get an object of a class without exposing the underlying logic
    to the client. It assigns a new object to the caller by using a common interface
    or abstract class. This means that the design pattern hides the actual logic of
    the implementation of an object, how to create it, and which class to instantiate
    it in. So the client shouldn't worry about creating, managing, and destroying
    an object-the Factory pattern takes responsibility for these tasks. The Factory
    pattern is one of the most-used design patterns in Java.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂设计模式是一种创建型设计模式。工厂设计模式也被称为工厂方法设计模式。根据这种设计模式，你得到一个类的对象，而不向客户端暴露底层逻辑。它通过使用公共接口或抽象类为新调用者分配一个新对象。这意味着设计模式隐藏了对象实现的实际逻辑，如何创建它，以及在哪里实例化它。因此，客户端不需要担心创建、管理和销毁对象——工厂模式负责这些任务。工厂模式是
    Java 中最常用的设计模式之一。
- en: 'Let''s look at the benefits of the Factory pattern:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看工厂模式的优点：
- en: The Factory pattern promotes loose coupling between collaborating components
    or classes by using interfaces rather than binding application-specific classes
    into the application code
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式通过使用接口而不是将特定于应用程序的类绑定到应用程序代码中，促进了协作组件或类之间的松耦合。
- en: Using this pattern, you can get an implementation of an object of classes that
    implement an interface, at runtime
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种模式，你可以在运行时获取实现接口的类的对象。
- en: The object life cycle is managed by the factory implemented by this pattern
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的生命周期由该模式实现的工厂管理。
- en: 'Now let''s discuss some common problems where you should apply the Factory
    design pattern:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一些应该应用工厂设计模式的常见问题：
- en: This pattern removes the burden on the developer to create and manage the objects
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式减轻了开发者创建和管理对象的负担。
- en: This pattern removes the tight coupling between collaboration components because
    a component doesn't know what subclasses it will be required to create
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式消除了协作组件之间的紧密耦合，因为一个组件不知道它将需要创建哪些子类。
- en: Avoid hard code to create an object of the class
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免硬编码创建类的对象。
- en: Implementing the Factory design pattern in Spring Framework
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Spring 框架中实现工厂设计模式
- en: Spring Framework transparently uses this Factory design pattern to implement
    Spring containers using `BeanFactory` and `ApplicationContext` interfaces. Spring's
    container works based on the Factory pattern to create spring beans for the Spring
    application and also manages the life cycle of every Spring bean. `BeanFactory`
    and `ApplicationContext` are factory interfaces, and Spring has lots of implementing
    classes. The `getBean()`method is the factory method that gives you Spring beans
    accordingly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架透明地使用这种工厂设计模式，通过 `BeanFactory` 和 `ApplicationContext` 接口来实现 Spring
    容器。Spring 的容器基于工厂模式创建 Spring 应用程序中的 Spring bean，并管理每个 Spring bean 的生命周期。`BeanFactory`
    和 `ApplicationContext` 是工厂接口，Spring 有很多实现类。`getBean()` 方法是工厂方法，它根据需要提供 Spring
    bean。
- en: Let's see a sample implementation of the Factory design pattern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看工厂设计模式的示例实现。
- en: Sample implementation of the Factory design pattern
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂设计模式的示例实现
- en: 'There are two classes `SavingAccount` and `CurrentAccount` implementing an
    interface `Account`. So, you can create a `Factory` class with a method that takes
    one or more arguments and its return type is `Account`. This method is known as
    the Factory method because it creates the instances of either `CurrentAccount`
    or `SavingAccount`. The `Account` interface is used for loose coupling. So, according
    to the passed arguments in the factory method, it chooses which subclass to instantiate.
    This factory method will have the superclass as its return type:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个类 `SavingAccount` 和 `CurrentAccount` 实现了一个 `Account` 接口。因此，您可以创建一个 `Factory`
    类，该类有一个方法，该方法接受一个或多个参数，其返回类型是 `Account`。这个方法被称为工厂方法，因为它创建了 `CurrentAccount` 或
    `SavingAccount` 的实例。`Account` 接口用于松耦合。因此，根据工厂方法中传递的参数，它选择实例化哪个子类。这个工厂方法将具有其超类作为其返回类型：
- en: '![](img/c60c9cd5-b79a-4a6b-9966-6afe4a68c056.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c60c9cd5-b79a-4a6b-9966-6afe4a68c056.png)'
- en: UML Diagram for the Factory design pattern
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂设计模式的 UML 图
- en: 'Let''s look at this design pattern in the following example. Here, I am going
    to create an `Account` interface and some concrete classes that implement the
    `Account` interface:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来查看这个设计模式。在这里，我将创建一个 `Account` 接口和一些实现 `Account` 接口的具体类：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s create `SavingAccount.java`, which will implement the `Account`
    interface:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建 `SavingAccount.java`，它将实现 `Account` 接口：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Same with `CurrentAccount.java`, it will also implement the `Account` interface:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `CurrentAccount.java` 相同，它也将实现 `Account` 接口：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A Factory class `AccountFactory` is now going to be defined. `AccountFactory`
    generates an object of the concrete class, either `SavingAccount` or `CurrentAccount,`
    based on the account type given as an argument to the Factory method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将定义一个 `AccountFactory` 工厂类。`AccountFactory` 根据作为工厂方法参数给出的账户类型生成具体类的对象，无论是
    `SavingAccount` 还是 `CurrentAccount`：
- en: '`AccountFactory.java` is a Factory to produce the `Account` type object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountFactory.java` 是一个用于生产 `Account` 类型对象的工厂：'
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`FactoryPatternMain` is the main calling class of `AccountFactory` to get an
    `Account` object. It will pass an argument to the factory method that contains
    information of the account type, such as `SAVING` and `CURRENT`. `AccountFactory`
    returns the object of the type that you passed to the factory method.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactoryPatternMain` 是 `AccountFactory` 的主调用类，用于获取 `Account` 对象。它将传递一个参数给工厂方法，该参数包含账户类型的信息，例如
    `SAVING` 和 `CURRENT`。`AccountFactory` 返回您传递给工厂方法的类型对象。'
- en: 'Let''s create a demo class `FactoryPatterMain.java` to test the factory method
    design pattern:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个演示类 `FactoryPatterMain.java` 来测试工厂方法设计模式：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can test this file and see the output on the console, which should look
    like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以测试此文件，并在控制台上查看输出，它应该看起来像这样：
- en: '![](img/52068e84-43ce-438a-ba1d-83ed3ed69890.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52068e84-43ce-438a-ba1d-83ed3ed69890.png)'
- en: Now that we've seen the Factory design pattern, let's turn to a different variant
    of it-the Abstract factory design pattern.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了工厂设计模式，让我们转向它的一个不同变体——抽象工厂设计模式。
- en: Abstract factory design pattern
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式
- en: '*Provide an interface for creating families of related or dependent objects
    without specifying their concrete cla*sses. - GOF Design Patterns'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*提供一个接口，用于创建相关或依赖对象家族，而不指定它们的具体类* - GOF 设计模式'
- en: The Abstract Factory pattern comes under the creational design pattern. It is
    a high-level design pattern compared to the factory method design pattern. According
    to this design pattern, you just define an interface or abstract class to create
    a related dependent object without specifying its concrete subclass. So here,
    the abstract factory returns a factory of classes. Let me simplify it for you.
    You have a set of factory method design patterns, and you just put these factories
    under a factory using the factory design pattern, which means that it is simply
    a factory of factories. And there is no need to take the knowledge about all of
    the factories into the factory--you can make your program using a top-level factory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式属于创建型设计模式。与工厂方法设计模式相比，这是一个高级设计模式。根据这个设计模式，您只需定义一个接口或抽象类来创建一个相关依赖对象，而不指定其具体子类。因此，在这里，抽象工厂返回一个类工厂。让我为您简化一下。您有一组工厂方法设计模式，您只需将这些工厂通过工厂设计模式放在一个工厂下，这意味着它只是一个工厂的工厂。而且没有必要将所有工厂的知识带入工厂中——您可以使用顶级工厂来编写程序。
- en: In the Abstract Factory pattern, an interface is responsible for creating a
    factory of related objects without explicitly specifying their classes. Each generated
    factory can give the objects as per the Factory pattern.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象工厂模式中，一个接口负责创建相关对象的工厂，而不明确指定它们的类。每个生成的工厂都可以按照工厂模式提供对象。
- en: 'The benefits of the Abstract Factory pattern are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的优点如下：
- en: The Abstract Factory Design provides loose coupling between the component families.
    It also isolates the client code from concrete classes.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式提供了组件家族之间的松耦合。它还隔离了客户端代码与具体类。
- en: This design pattern is a higher-level design than the Factory pattern.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种设计模式比工厂模式（Factory pattern）更高级。
- en: This pattern provides better consistency at construction time of objects across
    the application.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式在对象构建时间上提供了更好的跨应用程序一致性。
- en: This pattern easily swaps component families.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式可以轻松地交换组件家族。
- en: Common problems where you should apply the Abstract factory design pattern
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应该应用抽象工厂设计模式的常见问题
- en: When you design a Factory pattern for object creation in your application, there
    are times when you want a particular set of related objects to be created with
    certain constraints and apply the desired logic across the related objects in
    your application. You can achieve this design by creating another factory inside
    the factory for a set of related objects and apply the required constraints. You
    can also program the logic to a set of related objects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在应用程序中设计用于对象创建的工厂模式时，有时你希望一组相关的对象以特定的约束条件被创建，并在应用程序中跨相关对象应用所需的逻辑。你可以通过在工厂内部为相关对象集创建另一个工厂来实现这种设计，并应用所需的约束。你也可以将逻辑编程到一组相关对象中。
- en: When you want to customize the instantiation logic of related objects, then
    you could use this design pattern.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想定制相关对象的实例化逻辑时，可以使用这种设计模式。
- en: Implementing the Abstract factory design pattern in the Spring Framework
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring框架中实现抽象工厂设计模式
- en: In the Spring Framework, the `FactoryBean` interface is based on the Abstract
    Factory design pattern. Spring provides a lot of implementation of this interface,
    such as `ProxyFactoryBean`, `JndiFactoryBean`, `LocalSessionFactoryBean`, `LocalContainerEntityManagerFactoryBean`,
    and so on. A `FactoryBean` is also useful to help Spring construct objects that
    it couldn't easily construct itself. Often this is used to construct complex objects
    that have many dependencies. It might also be used when the construction logic
    itself is highly volatile and depends on the configuration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，`FactoryBean`接口基于抽象工厂设计模式。Spring提供了大量的该接口实现，例如`ProxyFactoryBean`、`JndiFactoryBean`、`LocalSessionFactoryBean`、`LocalContainerEntityManagerFactoryBean`等。`FactoryBean`也有助于Spring构建它自己难以构建的对象。通常这用于构建具有许多依赖关系的复杂对象。当构建逻辑本身高度动态且依赖于配置时，也可能被使用。
- en: For example, in Spring Framework, one of the `FactoryBean` implementations is
    `LocalSessionFactoryBean`, which is used to get a reference of a bean that was
    associated with the hibernate configuration. It is a specific configuration concerning
    the data source. It should be applied before you get an object of `SessionFactory`.
    You can use the `LocalSessionFactoryBean` to apply the specific data source configuration
    in a consistent way. You may inject the result of a FactoryBean's `getObject()`
    method into any other property.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Spring框架中，`FactoryBean`的一个实现是`LocalSessionFactoryBean`，它用于获取与hibernate配置关联的bean的引用。这是一个关于数据源的具体配置。在获取`SessionFactory`对象之前应该应用它。你可以使用`LocalSessionFactoryBean`以一致的方式应用特定的数据源配置。你还可以将FactoryBean的`getObject()`方法的结果注入到任何其他属性中。
- en: Let's create a sample implementation of the Abstract Factory design pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个抽象工厂设计模式的示例实现。
- en: Sample implementation of the Abstract Factory design pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式的示例实现
- en: I am going to create a `Bank` and `Account` interface and some concrete classes
    implementing these interfaces. Here, I also create an abstract factory class,
    `AbstractFactory`. I have some factory classes, `BankFactory` and `AccountFactory;`
    these classes extend the `AbstractFactory` class. I will also create a `FactoryProducer`
    class to create the factories.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个`Bank`和`Account`接口以及实现这些接口的一些具体类。在这里，我还创建了一个抽象工厂类`AbstractFactory`。我有一些工厂类，`BankFactory`和`AccountFactory`；这些类扩展了`AbstractFactory`类。我还会创建一个`FactoryProducer`类来创建工厂。
- en: 'Let''s see this design pattern in the following image:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图像看看这个设计模式：
- en: '![](img/d8d85280-efd6-4c84-8214-3744f7296304.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8d85280-efd6-4c84-8214-3744f7296304.png)'
- en: UML diagram for the Abstract Factory design pattern
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式的 UML 图
- en: Create a demo class, `AbstractFactoryPatternMain`; it uses `FactoryProducer`
    to get an `AbstractFactory` object. Here, I pass information such as `ICICI`,
    `YES` to `AbstractFactory` to get an object of `Bank`, and I also pass information
    such as `SAVING`, `CURRENT` to `AbstractFactory` to get an `Account` type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个演示类 `AbstractFactoryPatternMain`；它使用 `FactoryProducer` 来获取 `AbstractFactory`
    对象。在这里，我传递了 `ICICI`、`YES` 等信息给 `AbstractFactory` 以获取 `Bank` 对象，我还传递了 `SAVING`、`CURRENT`
    等信息给 `AbstractFactory` 以获取 `Account` 类型。
- en: 'Here is the code for `Bank.java`, which is an interface:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Bank.java` 的代码，它是一个接口：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let''s create `ICICIBank.java`, which implements the `Bank` interface:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建 `ICICIBank.java`，它实现了 `Bank` 接口：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s create another `YesBank.java`, an implementing `Bank` interface:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个 `YesBank.java`，一个实现 `Bank` 接口的类：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, I am using the same interface and implementing classes of `Account`
    as I used in the Factory pattern example in this book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了与本书中工厂模式示例相同的 `Account` 接口和实现类。
- en: '`AbstractFactory.java` is an abstract class that is used to get factories for
    `Bank` and `Account` objects:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractFactory.java` 是一个抽象类，用于获取 `Bank` 和 `Account` 对象的工厂：'
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`BankFactory.java` is a factory class extending `AbstractFactory` to generate
    an object of the concrete class based on the given information:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`BankFactory.java` 是一个工厂类，它扩展了 `AbstractFactory`，根据给定信息生成具体类的对象：'
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`AccountFactory.java` is a factory class that extends `AbstractFactory.java`
    to generate an object of the concrete class based on the given information:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountFactory.java` 是一个工厂类，它扩展了 `AbstractFactory.java`，根据给定信息生成具体类的对象：'
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`FactoryProducer.java` is a class that creates a Factory generator class to
    get factories by passing a piece of information, such as `Bank` or `Account`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactoryProducer.java` 是一个类，它创建一个工厂生成器类，通过传递一些信息（如 `Bank` 或 `Account`）来获取工厂：'
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`FactoryPatterMain.java` is a demo class for the Abstract Factory design pattern.
    `FactoryProducer` is a class to get `AbstractFactory` in order to get the factories
    of concrete classes by passing a piece of information, such as the type:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactoryPatterMain.java` 是抽象工厂设计模式的一个演示类。`FactoryProducer` 是一个类，用于获取 `AbstractFactory`，以便通过传递一些信息（如类型）来获取具体类的工厂：'
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can test this file and see the output on the console:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过测试这个文件并在控制台上查看输出来测试这个文件：
- en: '![](img/56f08c15-3ef2-4bd2-9384-e04bfe2e1058.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56f08c15-3ef2-4bd2-9384-e04bfe2e1058.png)'
- en: Now that we've seen the abstract Factory design pattern, let's turn to a different
    variant of it-the singleton design pattern.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了抽象工厂设计模式，让我们转向它的一个不同变体--单例设计模式。
- en: Singleton design pattern
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例设计模式
- en: '*Ensure a class has only one instance and provide a global point of access
    to it - GOF Design Patterns*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保一个类只有一个实例，并提供一个全局访问点 - GOF 设计模式*'
- en: The Singleton pattern is a creational design pattern, it is one of the simplest
    design patterns in Java. According to the singleton design pattern, the class
    provides the same single object for each call--that is, it is restricting the
    instantiation of a class to one object and provides a global point of access to
    that class. So the class is responsible for creating an object and also ensures
    that only a single object should be created for each client call for this object.
    This class doesn't allow a direct instantiation of an object of this class. It
    allows you to get an object instance only by an exposed static method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是一个创建型设计模式，它是 Java 中最简单的模式之一。根据单例设计模式，类为每个调用提供相同的单个对象--也就是说，它限制了一个类的实例化只能有一个对象，并为该类提供了一个全局访问点。因此，该类负责创建对象，并确保对于每个客户端对该对象的调用，只创建一个对象。这个类不允许直接实例化这个类的对象。它允许你只能通过一个公开的静态方法来获取对象实例。
- en: 'This is useful when exactly one object is needed to coordinate actions across
    the system. You can create a single pattern using two forms, as listed here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统需要精确地一个对象来协调操作时，这很有用。你可以使用两种形式创建一个单例模式，如下所示：
- en: '**Early instantiation**: Creation of instance at load time'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早期实例化**：在加载时创建实例'
- en: '**Lazy instantiation**: Creation of instance when required'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟实例化**：在需要时创建实例'
- en: '**Benefits of the Singleton pattern:**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**单例模式的优点：**'
- en: It provides controller access to crucial (usually heavy object) classes, such
    as the connection class for DB and the `SessionFactory` class in hibernate
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了对关键（通常是重量级对象）类的控制器访问，例如数据库的连接类和 Hibernate 中的 `SessionFactory` 类
- en: It saves heaps of memory
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它节省了大量内存
- en: It is a very efficient design for multithreaded environments
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是多线程环境中的一个非常高效的设计
- en: It is more flexible because the class controls the instantiation process, and
    the class has the flexibility to change the instantiation process
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更加灵活，因为类控制了实例化过程，并且类有改变实例化过程的灵活性
- en: It has low latency
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有低延迟
- en: Common problems where you should apply Singleton pattern
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应该应用单例模式的常见问题
- en: The Singleton pattern solves only one problem--if you have a resource that can
    only have a single instance, and you need to manage that single instance, then
    you need a singleton. Normally, if you want to create a database connection with
    the given configuration in the distributed and multithread environment, it might
    be the case that every thread can create a new database connection with a different
    configuration object, if you don't follow the singleton design. With the Singleton
    pattern, each thread gets the same database connection object with the same configuration
    object across the system. It is mostly used in multithreaded and database applications.
    It is used in logging, caching, thread pools, configuration settings, and so on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式只解决一个问题——如果你有一个只能有一个实例的资源，并且你需要管理这个单例，那么你需要一个单例。通常，如果你想在分布式和多线程环境中使用给定配置创建数据库连接，如果不遵循单例设计，那么每个线程可能会创建一个具有不同配置对象的新的数据库连接。使用单例模式，系统中的每个线程都将获得具有相同配置对象的相同数据库连接对象。它主要用于多线程和数据库应用程序。它用于日志记录、缓存、线程池、配置设置等。
- en: Singleton design pattern implementation in the Spring Framework
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架中的单例设计模式实现
- en: The Spring Framework provides a Singleton scoped bean as a singleton pattern.
    It is similar to the singleton pattern, but it's not exactly the same as the Singleton
    pattern in Java. According to the Singleton pattern, a scoped bean in the Spring
    Framework means a single bean instance per container and per bean. If you define
    one bean for a particular class in a single Spring container, then the Spring
    container creates one and only one instance of the class defined by that bean
    definition.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架提供了一个单例作用域的 bean 作为单例模式。它与单例模式类似，但并不完全等同于 Java 中的单例模式。根据单例模式，Spring
    框架中的作用域 bean 表示每个容器和每个 bean 的单个 bean 实例。如果你在单个 Spring 容器中为特定类定义了一个 bean，那么 Spring
    容器将创建一个由该 bean 定义指定的类的单个实例。
- en: Let's create a sample application of the singleton design pattern.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个单例设计模式的示例应用程序。
- en: Sample implementation of the Singleton design pattern
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例设计模式的示例实现
- en: In the following code example, I will be creating a class with a method to create
    an instance of this class if one does not exist. If the instance is already present,
    then it will simply return the reference of that object. I have also taken thread
    safety into consideration, and so I have used a synchronized block here before
    creating the object of that class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我将创建一个带有创建该类实例（如果不存在）的方法的类。如果实例已经存在，它将简单地返回该对象的引用。我还考虑了线程安全性，因此在创建该类的对象之前，我使用了同步块。
- en: 'Let''s check out the UML diagram for the Singleton design pattern:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看单例设计模式的 UML 图：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'One thing to be noted in the preceding code is that I have written a private
    constructor of the `SingletonClass` class to make sure that there is no way to
    create the object of that class. This example is based on lazy initialization,
    which means that the program creates an instance on demand the first time. So
    you could also eagerly instantiate the object to improve the runtime performance
    of your application. Let''s see the same `SingletonClass` with eager initialization:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中需要注意的一点是，我编写了一个 `SingletonClass` 类的私有构造函数，以确保无法创建该类的对象。这个例子基于懒加载初始化，这意味着程序在第一次需要时才创建实例。因此，你也可以通过立即实例化对象来提高应用程序的运行时性能。让我们看看具有立即初始化的相同
    `SingletonClass`：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we've seen the singleton design pattern, let's turn to a different
    variant of it--the Prototype design pattern.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单例设计模式，让我们转向它的一个不同变体——原型设计模式。
- en: Prototype design pattern
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型设计模式
- en: '*Specify the kind of objects to create using a prototypical instance, and create
    new objects by copying this prototype.* - GOF Design Patterns'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用原型实例指定要创建的对象类型，并通过复制此原型来创建新对象* - GOF 设计模式'
- en: The Prototype pattern comes under the creational design pattern family of GOF
    patterns in software development. This pattern is used to create the objects by
    using a clone method of objects. It is determined by a prototypical instance.
    In the enterprise application, object creation is costly in terms of creating
    and initializing the initial properties of objects. If such a type of object is
    already in your hand, then you go for the prototype pattern; you just copy an
    existing similar object instead of creating it, which is time-consuming.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式属于 GOF 模式在软件开发中的创建型设计模式家族。此模式通过使用对象的克隆方法来创建对象。它由一个原型实例确定。在企业应用程序中，对象的创建在创建和初始化对象的初始属性方面代价高昂。如果这种类型的对象已经在你的手中，那么你可以选择原型模式；你只需复制一个现有的类似对象，而不是创建它，这样可以节省时间。
- en: This pattern involves implementing a prototype interface, it creates a clone
    of the current object. This pattern is used when the direct creation of the object
    is costly. For example, say that an object is to be created after a costly database
    operation. We can cache the object, returns its clone on the next request, and
    update the database as and when it is needed, thus reducing database calls.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式涉及实现一个原型接口，它创建当前对象的克隆。当直接创建对象代价高昂时，使用此模式。例如，假设对象是在代价高昂的数据库操作之后创建的。我们可以缓存对象，在下一个请求时返回其克隆，并在需要时更新数据库，从而减少数据库调用。
- en: Benefits of the Prototype design pattern
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型设计模式的优点
- en: 'The following list shows the benefits of using the Prototype pattern:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用原型模式的好处：
- en: Reduces the time to create the time-consuming objects by using the prototype
    pattern
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型模式可以减少创建耗时对象的时间
- en: This pattern reduces subclassing
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式减少了子类的数量
- en: This pattern adds and removes objects at runtime
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式在运行时添加和删除对象
- en: This pattern configures the application with classes dynamically
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式动态配置应用程序的类
- en: Let's see the UML class structure of the Prototype design pattern.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看原型设计模式的 UML 类结构。
- en: UML class structure
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UML类结构
- en: 'The following UML diagram shows all the components of the Prototype design
    pattern:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 UML 图展示了原型设计模式的所有组件：
- en: '![](img/7d707f1e-6cb1-491f-9ac8-aa3b634fb6ad.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d707f1e-6cb1-491f-9ac8-aa3b634fb6ad.png)'
- en: UML diagram for Prototype design pattern
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式的 UML 图
- en: 'Let''s see these components as listed in following points:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下要点列出这些组件：
- en: '**Prototype**: The Prototype is an interface. It is uses the clone method to
    create instances of this interface type.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型**：原型是一个接口。它使用克隆方法来创建此接口类型的实例。'
- en: '**ConcretePrototype**: This is a concrete class of the Prototype interface
    to implement an operation to clone itself.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体原型**：这是实现克隆自身操作的 Prototype 接口的具体类。'
- en: '**Client**: This is a `caller` class to create a new object of a Prototype
    interface by calling a `clone` method of the prototype interface.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这是一个 `调用者` 类，通过调用原型接口的 `clone` 方法来创建一个原型接口的新对象。'
- en: Let's see a sample implementation of the prototype design pattern.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看原型设计模式的示例实现。
- en: Sample implementation of the Prototype design pattern
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型设计模式的示例实现
- en: I am going to create an abstract `Account` class and concrete classes extending
    the `Account` class. An `AccountCache` class is defined as a next step, which
    stores account objects in a `HashMap` and returns their clone when requested.
    Create an abstract class implementing the `Clonable` interface.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个抽象的 `Account` 类和扩展 `Account` 类的具体类。定义 `AccountCache` 类作为下一步，它将账户对象存储在
    `HashMap` 中，并在请求时返回它们的克隆。创建一个实现 `Clonable` 接口的抽象类。
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let''s create concrete classes extending the preceding class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建扩展前面类的具体类：
- en: 'Here''s the `CurrentAccount.java` file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `CurrentAccount.java` 文件：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s how `SavingAccount.java` should look:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `SavingAccount.java` 应该看起来像的：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s create a class to get concrete classes in the `AccountCache.java` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `AccountCache.java` 文件中创建一个类来获取具体类：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`PrototypePatternMain.java` is a demo class that we will use to test the design
    pattern `AccountCache` to get the `Account` object by passing a piece of information,
    such as the type, and then call the `clone()` method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrototypePatternMain.java` 是一个演示类，我们将使用它来测试设计模式 `AccountCache`，通过传递一些信息，如类型，来获取
    `Account` 对象，然后调用 `clone()` 方法：'
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've covered this so far and it's good. Now let's look at the next design pattern.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论到这里，做得很好。现在让我们看看下一个设计模式。
- en: Builder design pattern
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Builder 设计模式
- en: '*Separate the construction of a complex object from its representation so that
    the same construction process can create different representations.* - GOF Design
    Patterns'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*将复杂对象的构建与其表示分离，以便相同的构建过程可以创建不同的表示。- GOF 设计模式*'
- en: The Builder design pattern is used to construct a complex object step by step,
    and finally it will return the complete object. The logic and process of object
    creation should be generic so that you can use it to create different concrete
    implementations of the same object type. This pattern simplifies the construction
    of complex objects and it hides the details of the object's construction from
    the client caller code. When you are using this pattern, remember you have to
    build it one step at a time, which means you have to break the object construction
    login into multiple phases, unlike other patterns, such as the abstract factory
    and the factory method pattern, which the object in a single step.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Builder 设计模式用于逐步构建一个复杂对象，最终返回完整的对象。对象的创建逻辑和过程应该是通用的，这样你就可以用它来创建同一对象类型的不同具体实现。这个模式简化了复杂对象的构建，并隐藏了对象构建的细节，从而保护客户端调用代码。当你使用这个模式时，请记住你必须一步一步地构建它，这意味着你必须将对象构建过程分解成多个阶段，与像抽象工厂和工厂方法模式这样的其他模式不同，这些模式可以在一个步骤中完成对象的构建。
- en: 'Benefits of the Builder pattern:'
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Builder 模式的优点：
- en: This pattern provides you with complete isolation between the construction and
    representation of an object
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个模式为你提供了构建和表示对象之间的完全隔离
- en: This pattern allows you to construct the object in multiple phases, so you have
    greater control over the construction process
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个模式允许你在多个阶段构建对象，因此你对构建过程有更大的控制权
- en: This pattern provides the flexibility to vary an object's internal representation
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个模式提供了改变对象内部表示的灵活性
- en: UML class structure
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UML 类结构
- en: 'The following UML diagram shows all the components of the Builder design pattern:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 UML 图显示了 Builder 设计模式的所有组件：
- en: '![](img/a88351cd-892f-4c63-911c-940c09fe227e.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a88351cd-892f-4c63-911c-940c09fe227e.png)'
- en: 'UML diagram for the Builder design pattern:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Builder 设计模式的 UML 图：
- en: '**Builder** (AccountBuilder): This is an abstract class or interface for creating
    the details of an Account object.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建器（Builder）**（AccountBuilder）：这是一个用于创建 Account 对象细节的抽象类或接口。'
- en: '**ConcreteBuilder**: This is an implementation to construct and assemble details
    of the account by implementing the Builder interface.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体构建器（ConcreteBuilder）**：这是一个实现，通过实现 Builder 接口来构建和组装账户的细节。'
- en: '**Director**: This constructs an object using the Builder interface.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导演（Director）**：这是使用 Builder 接口构建对象。'
- en: '**Product** (Account): This represents the complex object under construction.
    `AccountBuilder` builds the account''s internal representation and defines the
    process by which it''s assembled.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品（Account）**：这代表正在构建的复杂对象。`AccountBuilder` 构建账户的内部表示，并定义了组装的过程。'
- en: Implementing the Builder pattern in the Spring Framework
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Spring 框架中实现 Builder 模式
- en: 'The Spring Framework implements the Builder design pattern transparently in
    some functionalities. The following classes are based on the Builder design pattern
    in the Spring Framework:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架在一些功能中透明地实现了 Builder 设计模式。以下类基于 Spring 框架中的 Builder 设计模式：
- en: '`EmbeddedDatabaseBuilder`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`嵌入式数据库构建器（EmbeddedDatabaseBuilder）`'
- en: '`AuthenticationManagerBuilder`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticationManagerBuilder`'
- en: '`UriComponentsBuilder`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UriComponentsBuilder`'
- en: '`BeanDefinitionBuilder`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeanDefinitionBuilder`'
- en: '`MockMvcWebClientBuilder`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockMvcWebClientBuilder`'
- en: Common problems where you should apply Builder pattern
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应该应用 Builder 模式的常见问题
- en: In an enterprise application, you can apply the Builder pattern where the object
    creation has been done by using multiple steps. In each step, you do a portion
    of the process. In this process, you set some required parameters and some optional
    parameters, and after the final step, you will get a complex object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，你可以应用 Builder 模式，其中对象创建是通过多个步骤完成的。在每一步中，你完成一部分过程。在这个过程中，你设置一些必需的参数和一些可选的参数，在最终步骤之后，你将得到一个复杂对象。
- en: The Builder pattern is an object creation software design pattern. The intention
    is to abstract the steps of construction so that different implementations of
    these steps can construct different representations of objects. Often, the Builder
    pattern is used to build products in accordance with the composite pattern.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式是一种对象创建的软件设计模式。其目的是抽象构建步骤，以便不同的步骤实现可以构建不同表示的对象。通常，建造者模式用于根据组合模式构建产品。
- en: Sample implementation of the Builder design pattern
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Builder 设计模式的示例实现
- en: 'In the following code example, I am going to create an `Account` class that
    has `AccountBuilder` as an inner class. The `AccountBuilder` class has a method
    to create an instance of this class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我将创建一个包含 `AccountBuilder` 作为内部类的 `Account` 类。`AccountBuilder` 类有一个创建此类实例的方法：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`AccountBuilderTest.java` is a demo class that we will use to test the design
    pattern. Let''s look at how to build an `Account` object by passing the initial
    information to the object:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountBuilderTest.java` 是一个演示类，我们将用它来测试设计模式。让我们看看如何通过向对象传递初始信息来构建一个 `Account`
    对象：'
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can test this file and see the output on the console:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以测试这个文件，并在控制台上查看输出：
- en: '![](img/68c90b98-5bfc-4f6e-bacd-6a7f75a4e268.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68c90b98-5bfc-4f6e-bacd-6a7f75a4e268.png)'
- en: Now, we've seen the Builder design pattern. In the upcoming [Chapter 3](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml),
    *Consideration of Structural and Behavioural* *Patterns,* I will explore another
    part of the GOF Design Patterns family.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到了 Builder 设计模式。在即将到来的 [第 3 章](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml)，*考虑结构和行为模式*，我将探索
    GOF 设计模式家族的另一个部分。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, the reader should now have a good idea about the
    overview of GOF creational design patterns and its best practices. I highlighted
    the problems that come from not using design patterns in enterprise application
    development, and how Spring solves these problems by using the creational design
    patterns and good practices in the application. In this chapter, I have mentioned
    only one of the Creational Design pattern categories out of the three main categories
    of the GOF Design Patterns. The Creational design pattern is used for the creation
    of object instances, and also applies constraints at the creation time in the
    enterprise application in a specific manner using the Factory, Abstract Factory,
    Builder, Prototype, and Singleton patterns. In the next chapter, we will look
    at the other categories of the GOF Design Patterns-the structural design pattern
    and the behavioral design pattern. The structural design pattern is used to design
    the structure of an enterprise application by dealing with the composition of
    classes or objects so that it reduces the application's complexity and improves
    the reusability and performance of the application. The Adapter Pattern, Bridge
    Pattern, Composite Pattern, Decorator Pattern, Facade Pattern, and Flyweight Pattern
    come under this category of the pattern. The Behavioral design pattern characterizes
    the ways in which classes or objects interact and distribute responsibility. The
    patterns that come under this category are specifically concerned with communication
    between objects. Let's move to complete the remaining GOF patterns in the next
    chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，读者现在应该对 GOF 创建型设计模式的概述及其最佳实践有一个很好的了解。我强调了不使用设计模式在企业级应用开发中产生的问题，以及 Spring
    如何通过使用创建型设计模式和应用程序中的良好实践来解决这些问题。在本章中，我只提到了 GOF 设计模式的三个主要类别之一——创建型设计模式类别。创建型设计模式用于创建对象实例，并在企业应用中通过工厂、抽象工厂、建造者、原型和单例模式以特定方式在创建时间施加约束。在下一章中，我们将探讨
    GOF 设计模式的另外两个类别——结构型设计模式和行为型设计模式。结构型设计模式通过处理类或对象的组合来设计企业应用的结构，从而降低应用复杂性，提高应用的复用性和性能。适配器模式、桥接模式、组合模式、装饰器模式、外观模式和享元模式都属于这个模式类别。行为型设计模式描述了类或对象之间交互和分配责任的方式。属于这个类别的模式特别关注对象之间的通信。让我们在下一章中继续完成剩余的
    GOF 模式。
