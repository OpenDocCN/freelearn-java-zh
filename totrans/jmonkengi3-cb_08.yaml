- en: Chapter 8. Physics with Bullet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pushable door
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a rocket engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ballistic projectiles and arrows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple gravity sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-balancing using RotationalLimitMotors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principles of a bridge-building game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networked physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using physics in games has become very common and accessible, thanks to open
    source physics engines, such as Bullet. jMonkeyEngine supports both the Java-based
    jBullet and native Bullet in a seamless manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jBullet is a Java-based library with JNI bindings to the original Bullet based
    on C++. jMonkeyEngine is supplied with both of these, and they can be used interchangeably
    by replacing the libraries in the classpath. No coding change is required. Use
    `jme3-libraries-physics` for the implementation of jBullet and `jme3-libraries-physics-native`
    for Bullet. In general, Bullet is considered to be faster and is full featured.
  prefs: []
  type: TYPE_NORMAL
- en: Physics can be used for almost anything in games, from tin cans that can be
    kicked around to character animation systems. In this chapter, we'll try to reflect
    the diversity of these implementations.
  prefs: []
  type: TYPE_NORMAL
- en: All the recipes in this chapter will require you to have a `BulletAppState`
    class in the application. To avoid repetition, the process of doing this is described
    in the *Adding Bullet physics to the application* section in [Appendix](apa.html
    "Appendix A. Information Fragments"), *Information Fragments*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pushable door
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doors are useful in games. Visually, it is more appealing to not have holes
    in the walls but doors for the players to pass through. Doors can be used to obscure
    the view and hide what's behind them for a surprise later. In extension, they
    can also be used to dynamically hide geometries and increase the performance.
    There is also a gameplay aspect where doors are used to open new areas to the
    player and give a sense of progression.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a door that can be opened by pushing it, using
    a `HingeJoint` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This door consists of the following three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Door object**: This is a visible object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attachment**: This is the fixed end of the joint around which the hinge swings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hinge**: This defines how the door should move'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply following the steps in this recipe won't give us anything testable. Since
    the camera has no physics, the door will just sit there and we will have no way
    to push it. If you have made any of the recipes that use the `BetterCharacterControl`
    class, many of them in [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"),
    *Cameras and Game Controls*, we will already have a suitable test bed for the
    door. If not, jMonkeyEngine's `TestBetterCharacter` example can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe consists of two sections. The first will deal with the actual creation
    of the door and the functionality to open it. This will be made in the following
    six steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RigidBodyControl` object called `attachment` with a small `BoxCollisionShape`.
    The `CollisionShape` should normally be placed inside the wall where the player
    can't run into it. It should have a mass of 0, to prevent it from being affected
    by gravity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We move it some distance away and add it to the `physicsSpace` instance, as
    shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a `Geometry` class called `doorGeometry` with a `Box` shape with
    dimensions that are suitable for a door, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, create a `RigidBodyControl` instance with the same dimensions, that
    is, `1` in `mass`; add it as a control to the `doorGeometry` class first and then
    add it to `physicsSpace` of `bulletAppState`. The following code snippet shows
    you how to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''re going to connect the two with `HingeJoint`. Create a new `HingeJoint`
    instance called `joint`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set the limit for the rotation of the door and add it to `physicsSpace`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have a door that can be opened by walking into it. It is primitive
    but effective. Normally, you want doors in games to close after a while. However,
    here, once it is opened, it remains opened. In order to implement an automatic
    closing mechanism, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `DoorCloseControl` extending `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `HingeJoint` field called `joint` along with a setter for it and a float
    variable called `timeOpen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `controlUpdate` method, we get `hingeAngle` from `HingeJoint` and store
    it in a float variable called `angle`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the angle deviates a bit more from zero, we should increase `timeOpen` using
    `tpf`. Otherwise, `timeOpen` should be reset to `0`, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `timeOpen` is more than `5`, we begin by checking whether the door is still
    open. If it is, we define a speed to be the inverse of the angle and enable the
    door''s motor to make it move in the opposite direction of its angle, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `timeOpen` is less than `5`, we should set the speed of the motor to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create a new `DoorCloseControl` instance in the main class, attach
    it to the `doorGeometry` class, and give it the same joint we used previously
    in the recipe, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attachment `RigidBodyControl` has no mass and will thus not be affected
    by external forces such as gravity. This means it will stick to its place in the
    world. The door, however, has mass and would fall to the ground if the attachment
    didn't keep it up with it.
  prefs: []
  type: TYPE_NORMAL
- en: The `HingeJoint` class connects the two and defines how they should move in
    relation to each other. Using `Vector3f.UNIT_Y` means the rotation will be around
    the *y* axis. We set the limit of the joint to be a little more than half PI in
    each direction. This means it will open almost 100 degrees to either side, allowing
    the player to step through.
  prefs: []
  type: TYPE_NORMAL
- en: When we try this out, there may be some flickering as the camera passes through
    the door. To get around this, there are some tweaks that can be applied. We can
    change the collision shape of the player. Making the collision shape bigger will
    result in the player hitting the wall before the camera gets close enough to clip
    through. This has to be done considering other constraints in the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: You can consider changing the near clip distance of the camera. Decreasing it
    will allow things to get closer to the camera before they are clipped through.
    This might have implications on the camera's projection.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that will not work is making the door thicker, since the triangles
    on the side closest to the player are the ones that are clipped through. Making
    the door thicker will move them even closer to the player.
  prefs: []
  type: TYPE_NORMAL
- en: In `DoorCloseControl`, we consider the door to be open if `hingeAngle` deviates
    a bit more from 0\. We don't use 0 because we can't control the exact rotation
    of the joint. Instead we use a rotational force to move it. This is what we do
    with `joint.enableMotor`. Once the door is open for more than five seconds, we
    tell it to move in the opposite direction. When it's close to 0, we set the desired
    movement speed to 0\. Simply turning off the motor, in this case, will cause the
    door to keep moving until it is stopped by an external force.
  prefs: []
  type: TYPE_NORMAL
- en: Once we enable the motor, we also need to call `activate()` on `RigidBodyControl`
    or it will not move.
  prefs: []
  type: TYPE_NORMAL
- en: Building a rocket engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A rocket engine is crucial for most space-based games and many 2D games as
    well. In this recipe, we''ll cover the minimum that is required to create a thruster
    that can be used in many different contexts. The following figure shows a thruster
    with `ParticleEmitter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a rocket engine](img/6478OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to make sure that we see the debug shapes of physics.
    To do this, we need to call the `bulletAppState.setDebugEnabled(true);` statement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will begin by setting up some things that are not strictly needed for the
    rocket engine but will aid the testing. Perform the following steps to build a
    rocket engine:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all we add a floor mesh. For this, we create a new `Node` class called
    `ground`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, we add `RigidBodyControl` with `PlaneCollisionShape`. The plane
    should face upwards like floors normally do, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then attach them both to `rootNode` of the application and `physicsSpace`
    of `bulletAppState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to add a key to control the booster. For this, we implement
    an `AnalogListener` interface in our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add the application to `inputManager` along with a mapping object called
    boost that is bound to the Space bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most of this recipe will be implemented in a class that extends `SimpleApplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We begin by defining a `Node` class called `spaceShip` that will be our spaceship's
    representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then create a `RigidBodyControl` instance with `BoxCollisionShape` and add
    it to the `spaceShip` node as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create another `Node`, which will be our thruster. Give it the name
    `Thruster` to be able to identify it more easily later, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set `localTranslation` of this so that it will end up at the bottom of the
    spaceship, as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we attach it to the `spaceShip` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have to attach the `spaceShip` node to both the `rootNode` and `physicsSpace`
    of `bulletAppState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To control the thruster and make it more reusable, we will create a class called
    `ThrusterControl`, extending `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It'll have one field, a `Spatial` field called `thruster`, that will store the
    `thruster` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will override the `setSpatial` method and set it by calling `getChild("Thruster")`
    on the supplied spatial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we define a new method called `fireBooster()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this, we subtract the thruster''s location from the spaceship''s location
    and store it in a new `Vector3f` field called `direction` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we find the `RigidBodyControl` class in the spatial and call `applyImpulse`
    with the direction vector. We use the inverted direction as the relative position
    that the impulse should originate from. This can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the application class, we have to make it call the `fireBooster` method.
    We do this in the `onAnalog` method that was added when we implemented the `AnalogListener`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The graphics in this recipe are very minimalistic and mostly rely on the debug
    mode of `BulletAppState` to draw them. The physics shapes don't normally have
    a visual representation since they're not part of the scene graph. Using the debug
    mode can be very useful during early prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: The `RigidBodyControl` instance of the spaceship makes sure it's affected by
    gravity and other forces.
  prefs: []
  type: TYPE_NORMAL
- en: The sole purpose of a thruster is to be able to easily retrieve the position
    that is relative to the spaceship from where the boosting force needs to be applied.
    This is why we place it at the bottom of the spaceship. The benefit of using the
    `Control` pattern to control a `Thruster` is that we can apply it to other geometries
    easily (and even use it in `SceneComposer`).
  prefs: []
  type: TYPE_NORMAL
- en: The `fireBooster` method of `ThrusterControl` takes the position of `spaceShip`
    and subtracts the position of the thruster node to get the direction of the force
    to apply. The relative position of the force is the direct opposite of this direction.
  prefs: []
  type: TYPE_NORMAL
- en: Ballistic projectiles and arrows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applying physics to arrows can greatly improve the appearance and gameplay
    of a medieval or fantasy game. Setting up arrows that are affected by gravity
    is fairly simple; this recipe, however, will also set the arrows up in a way that
    they always face the direction they''re traveling in, making them more realistic.
    The following figure shows one of the arrows in flight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ballistic projectiles and arrows](img/6478OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to make sure that we see the debug shapes of physics.
    To do this, we need to call the `bulletAppState.setDebugEnabled(true);` statement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create three classes. Let''s begin by looking at the
    `Arrow` class, which contains most of the new functionalities. This will be done
    in the following eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `Arrow`, extending `Node`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Its constructor takes two `Vector3f` variables as parameters. One of these
    is for the starting location of the arrow and one for the initial velocity, as
    shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the constructor, we define a `Geometry` instance for the body of the
    arrow with a `box` mesh as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set `localTranslation` of `Geometry` so that one of its ends touches
    the center point of the node as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We set `localTranslation` of this `Arrow` as the supplied location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we create `CollisionShape`. This will represent the head of the arrow
    and can be `SphereCollisionShape`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define `RigidBodyControl` based on `CollisionShape`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set `LinearVelocity` of `RigidBodyControl` to be the supplied velocity and
    add it as a Control to Arrow, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This would be enough for the arrow to follow the laws of physics; however,
    it will always face the forward direction. By adding another control, we can make
    it face the direction of the velocity. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create another class called `ArrowFacingControl`, extending `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `Vector3f` field called `direction`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `controlUpdate` method, we get `linearVelocity` from `RigidBodyControl`
    of the spatial and normalize it. We then store it in `direction` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, call the spatial and tell it to rotate to the supplied `direction` vector
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the constructor of the `Arrow` class, we add an instance of this control,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last section handles the firing of the arrow from `SimpleApplication`.
    This can be done with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to implement `ActionListener` in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `ActionListener` class to `inputManager` as a listener, together with
    a key for firing arrows, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onAction` method, call a new method called `fireArrow` when the `fire`
    button is released. This can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `fireArrow` method should begin by instancing a new `Arrow` instance and
    applying a (preloaded) material to it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We attach it to `rootNode` as well as to `physicsSpace`, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Arrow` object has two major components. One is `Geometry`, which is a simple
    elongated box. The other is `CollisionShape` for the head of the arrow, which
    is the only thing that will look for collisions. The geometry is conveniently
    moved so that its tip will be at the (0,0,0) position of the `Arrow` node. It
    is convenient since it means we don't have to do any conversions in `ArrowFacingControl`
    but can use `rotateUpTo` with the actual velocity (direction) of the arrow.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple gravity sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some games require handling gravity from multiple variable sources. In this
    recipe, we'll handle this and create a simple miniature solar system to demonstrate
    it using `ThrusterControl` from the *Building a rocket engine* recipe. To (greatly)
    simplify the relation between the planets, they won't affect each other with their
    gravity, but only the ship. It will also be made in a 2D-asteroids-like fashion,
    although the gravity would still apply for a 3D game.
  prefs: []
  type: TYPE_NORMAL
- en: We'll add some basic controls to rotate the ship to the left and right, and
    you can use the thruster to make the ship move forward.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from `ThrusterControl`, we''ll create two more small classes and an application
    class that joins everything together. Let''s start with a class that represents
    the player''s ship. This will consist of the following six steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `SpaceShip`, which has a `Node` field called `shipNode`
    in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, we set up the physics for it by creating a new `RigidBodyControl`
    instance with `BoxCollisionShape`. To create it in a way that it is affected by
    gravity, we also give it a mass of `1` that will be supplied in the constructor
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a `Node` instance called `thruster`. We also set the name of
    `Node` to `Thruster` for the control to find it automatically, as shown in the
    following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set `localTranslation` to be at one of the sides of the spaceship and attach
    it to `shipNode`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we rotate the ship''s spatial so that it''s facing sideways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we add a new `ThrusterControl` instance to the spaceship's spatial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s it for the `SpaceShip` class. Now, we create a class for our planets,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by defining a class called `StellarBody`, which extends `AbstractControl`.
    The `StellarBody` class has four float fields: `size`, `speed`, `orbit`, and `cycle`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The constructor takes three of these (`size`, `speed`, and `orbit`) as the
    input, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We override the `setSpatial` method and add `RigidBodyControl` to the supplied
    spatial with `SphereCollisionShape`, using `size` as the radius and `0` for mass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `controlUpdate` method, we make it move along its orbit by increasing
    the speed of the cycle by multiplying it by `tpf`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set the actual position of the planet along the orbit using the `sin`
    and `cos` methods of the `FastMath` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We multiply the result by the orbit and set `localTranslation` of the spatial
    to the new location as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we also need to set `physicsLocation` of `RigidBodyControl` to the same
    location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a new method, `getGravity`, that will take the position of the ship
    as an input `Vector3f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The method begins by subtracting the input position by `worldTranslation`,
    to get the position of the ship relative to the `StellarBody` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is normalized and then modified by a formula to get a suitable gravity.
    This value is returned to the calling method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test all of this, we need to add a few things to `SimpleApplication`. To
    do this, perform the following set of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we implement `AnalogListener`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add an `ArrayList<StellarBody>` list called `gravitationalBodies`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `simpleInitApp` method, we should begin by initializing `bulletAppState`
    and set up some controls for the spaceship. We add actions to rotate the spaceship
    to the left and right as well as fire the ship''s thruster, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since it''s a 2D representation, we move the camera some distance up and make
    it look as if it is at the center of the world. This can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create an instance called `ship` of `SpaceShip` and attach its geometry to
    `rootNode` and `physicsSpace` of `bulletAppState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can create a number of `StellarBody` instances using the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each instance, we should create a `Geometry` class with a `Sphere` shape
    that will have the same radius as the size we will supply to the `StellarBody`
    control.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Geometry` class should both be attached to `rootNode` and `physicsSpace`
    of `bulletAppState`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We add `StellarBody` as a control to the `Geometry` class and the `gravitationalBodies`
    list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `update` method, we have to take into account the gravity of the
    `StellarBody` instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we define a new `Vector3f` instance called `combinedGravity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we loop through our `gravitationalBodies` list and apply the following
    line of code to apply the gravity to `combinedGravity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we call the `ship.setGravity(combinedGravity);` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the extreme difficulty in creating a stable solar system with more than
    three bodies, `StellarBody` controls the need to have a static orbit around the
    center of the system. Using `0` as mass ensures that they aren't affected by gravity.
    The orbit field represents the orbit's distance from the center of the system,
    and it will rotate around the center using speed as a factor. The cycle field
    stores information on how far along its orbit it has come, and will reset once
    it reaches two PI (a full circle).
  prefs: []
  type: TYPE_NORMAL
- en: The `getGravity` method returns the gravity relative to the position that is
    supplied, which in this case is the location of the ship. It first determines
    the direction and then applies the gravity based on the distance between the two.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `gravitationalBodies` list, we have a dynamic way to simply add
    up all the gravitational forces in the system to a single `Vector3f` object, which
    we then apply to the spaceship in the `update` method of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Self-balancing using RotationalLimitMotors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many games today use a blend of animations and physics to create realistic movement.
    For animated characters, this revolves around balance. It could take the shape
    of a runner who leans inwards through a curve to counter the centrifugal force.
    Creating a system like this is not easy and requires a lot of tweaking. In this
    recipe, we'll look into some of the fundamentals of this, and we'll create a new
    `Control` class that will try to balance itself using the rotational motors of
    `SixDofJoint`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Six Degrees of Freedom** (**SixDof**) relates to the six ways the joint can
    rotate: +x, -x, +y, -y, +z, and -z. One way it differs from a `point2point` joint
    is that in addition, it also has motors for each axis, which makes it possible
    for it to also apply force.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simulate balancing, we will begin by creating the upper body of a stickman-shape
    figure with a torso and two rigid arms. To do this, perform the following set
    of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we should set up an application with `BulletAppState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `simpleInitApp` method, we create a small square `Box Geometry` to be
    the waist of the character. It can be `0.25f` in all the axes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add `RigidBodyControl` to it with `0` in mass since it shouldn't move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we create an oblong box to be the torso and place it above the waist.
    It should have `RigidBodyControl` with `1` in mass and `BoxCollisionShape` should
    be of the same size as the geometry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create `SixDofJoint` between the waist and torso and afterwards add
    it to `physicsSpace` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should limit the joint so that it can''t rotate on any axes other than the
    *x* axis, and it shouldn''t be able to rotate too much. We can use the following
    `setAngularLowerLimit` and `setAngularUpperLimit` methods for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we create one of the arms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create one of the arms by placing it at the same location as that of the
    torso and giving it a size of `Vector3f(0.25f, 0.25f, 2f)`, making it stretch
    out sideways, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create another `SixDofJoint` for it using the pivot points of `Vector3f(0,
    2.5f, 0.25f)` and `Vector3f(0, 0, -2.5f)`, offsetting it some distance to the
    side of the torso's spatial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we set the angular limits of the joint to `Vector3f(0, 0, 0)` and `Vector3f(FastMath.QUARTER_PI,
    0, 0)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We repeat the previous three steps to create the opposite arm, but we'll reverse
    the offset values to make the arm protrude in the opposite direction of the torso.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now have the basics done for our recipe. Running it should show the character
    slumping to one side with the arms stretched out to the sides. Now, we can begin
    with balancing by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `BalanceControl`, extending `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should have a `SixDofJoint` field called `joint` and a `RotationalLimitMotor`
    field called `motorX`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `setJoint` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this method, after setting the joint, we also populate `motorX` with
    one of the `RotationalLimitMotor` instances, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `controlUpdate` method, we get `bodyA` from the joint and store
    it in `PhysicsRigidBody`. This is the torso:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get the current rotation of `bodyA` to see how much it pivots. We then convert
    the rotation to angles and store them as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then store `angles[0]` in a float variable called `x`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If `x` is more than 0.01f or less than -0.01, we should start `motorX` and
    rotate it to compensate for the pivot, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, we turn off the motor as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running the result, we should see the stickman desperately trying to stay upright
    while flailing his arms up and down. The reason is that getting the forces right
    when balancing can be very difficult. With values that are too high, the stickman
    will constantly overshoot the target and instead rotate in the other direction.
    With values that are too low, it won't have the strength to get upright. With
    some further tweaking to `targetVelocity` and `maxMotorForce`, we might be able
    make him stable.
  prefs: []
  type: TYPE_NORMAL
- en: We started by creating the basic shape of a figure that would try to keep the
    balance. The waist was made to not be affected by the physics, so it could be
    a solid point. We then added a torso and two arms, resulting in a center of mass
    somewhere in the upper part of the torso. By placing each of the body parts at
    some distance from each other with the joints, we give them more freedom of movement.
  prefs: []
  type: TYPE_NORMAL
- en: The `BalanceControl` class we created has one simple strategy. It looks for
    the torso (bodyA)'s rotation along the *x* axis, and tries to keep it as close
    to 0 as possible. If it notices that it's anything but near 0, it will try to
    move the arms, shifting the center of the mass to the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the low number of components, getting it all to balance out is really
    difficult! Having more components, such as a whole human skeleton, requires a
    much more advanced strategy, with body parts moving in a synchronized fashion,
    rather than they trying to do so individually.
  prefs: []
  type: TYPE_NORMAL
- en: The principles of a bridge-building game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variants of bridge-building games have been around for a long time. The classical
    *Bridge Builder* is a 2D physics game where the player is required connect beams
    to create a bridge strong enough for a train (or some other moving object) to
    pass.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will describe most of the core functionalities needed to create
    such a game, including making the objects stay 2D and not wander off on the *z*
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll have some basic controls for the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Left-click will select a previously built node in the bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-click will add a new node or connect two previously built ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Space bar will turn on the physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows a bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The principles of a bridge-building game](img/6478OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin with more physics-related functions, we should set up the basic
    application.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we create a new class that extends `SimpleApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on, we''re going to use the following two lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need some strings as input mappings: `LEFT_CLICK`, `RIGHT_CLICK`, and
    `TOGGLE_PHYSICS`.'
  prefs: []
  type: TYPE_NORMAL
- en: We add a `RigidBodyControl` field called `selectedSegment` that will contain
    the last selected segment in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re strictly making a 2D game, we should change the camera to be orthographic.
    This can be done by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable `flyCam`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out the aspect ratio by dividing the `cam` width by its height and storing
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `cam.parallelProjection` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, change `frustrum` of the camera to suit and orthographic view as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We move it some way along the *z* axis and rotate it back towards the center,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can initialize `bulletAppState` as we usually do. Turn on the debug
    mode, and most importantly, set `speed` to `0`. We don't want any physics on while
    we build the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The world needs a gap to be bridged. So, for this, we''ll use `RigidBodyControl`
    to represent two cliffs, one on either side, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create one `RigidBodyControl` instance for each side and give it `BoxCollisionShape`
    with a size of `Vector3f(75f, 50f, 5f)` and `0` mass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place one of them at `Vector3f(-100f, -50f, 0)` and the other one at `Vector3f(100f,
    -50f, 0)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, add them to `physicsSpace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to start by creating two methods that will help us add new bridge
    segments to the game:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a method called `createSegment` that takes a `Vector3f` parameter
    called `location` as the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we do is set the `z` value of `location` to `0`. This is because
    we're making a 2D game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we create a new `RigidBodyControl` instance called `newSegment`. We add
    `SphereCollisionShape` to it and then add `newSegment` to `physicsSpace`. It''s
    important that it has some mass. This can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we create a `Geometry` instance based on a `Sphere` shape with the same
    radius as `RigidBodyControl`. We will use this as a target for mouse clicks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Geometry` object needs `modelBound` for which we'll use `BoundingSphere`.
    The radius may be bigger than `RigidBodyControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `RigidBodyControl` object is added to `Geometry` as a control and we use
    the `setPhysicsLocation` method to move it to the to the supplied location, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Geometry` object is then added to the segments list we defined earlier
    and then it is attached to `rootNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If `selectedSegment` is not null, we will call a method we will define next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, in the `createJoint` method, we set `selectedSegment` to be `newSegment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can define the `createJoint` method. It takes two `RigidBodyControl`
    parameters as the input, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we find out the location that should be the pivot point of `body2`.
    This is the same as `physicsLocation` of `body2` subtracted from `physicsLocation`
    of `body1`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define `Point2PointJoint` by joining the two segments. The vectors
    supplied mean that `body2` will pivot in a way that is relative to `body1`; we
    do this using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then add the newly created joint to the `joints` list and to `physicsSpace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re now getting to the controls of the application and need another method
    to help us. The method will check whether a mouse click has hit any segment and
    return it. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a new method called `checkSelection`, which returns `RigidBodyControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this method, we create a new `Ray` instance, which will have the current
    mouse cursor''s location as the origin; the following code tells you how to do
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the view is orthographic, we let the direction be `Vector3f(0, 0, -1f)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we define a new `CollisionResults` instance to store any segments that
    `Ray` collides with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing we do is parse through the segment's list and check whether the
    ray hits any of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it does, we're done, and then return `RigidBodyControl` of segment to the
    calling method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We defined a couple of input mappings earlier. Now, we can all implement the
    functionality for them in the `onAction` method by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the left mouse button is clicked, we should call `checkSelection`. If the
    returned value is not null, we should set `selectedSegment` to that value, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the right mouse button is clicked, we should also call `checkSelection`.
    If the returned value is not null and it''s not `selectedSegment`, we call `createJoint`
    with `selectedSegment` and the value of `checkSelection` to create a link between
    `selectedSegment` and the segment returned from the method, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, if we didn''t hit anything, we call `createSegment` with the position
    of the mouse cursor to create a new segment at that location as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the Space bar has been pressed, all we need to do is set the speed of `bulletAppState`
    to `1` to start the physics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re almost done with our simulation now, but we need to do a few more things.
    This last section will handle the `update` method and what happens when the physics
    is running and the bridge is being tested:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` method, we parse through all the items in the segment list
    and set the `z` value of `linearVelocity` to `0`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we parse through all the items in the joint''s list. For each,
    we should check whether the joint''s `appliedImpulse` value is higher than a value,
    let''s say `10`. If it is, the joint should be removed from the list as well as
    from `physicsSpace`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `createSegment` method creates a new bridge segment that is sphere shaped,
    both in `physicsSpace` and the visible world. This is the part that has a mass
    and can be selected by clicking on it, since `Ray` only collides with spatials.
  prefs: []
  type: TYPE_NORMAL
- en: The `createJoint` method creates the visible connection between the newly created
    segment, and the currently selected one. It does this using `Point2PointJoin`t.
    This is different from, for example, `HingeJoint`, since it's not fixed in space,
    when several `Point2Pointjoints` are connected and you have something that resembles
    a bridge.
  prefs: []
  type: TYPE_NORMAL
- en: The mouse selection is covered more in depth in other chapters, but it works
    by shooting `Ray` from the mouse's position on the screen, inwards into the game
    world. Once `Ray` hits `Geometry` (which has `BoundingSphere` that is slightly
    larger than the visible mesh for increased selectability), the corresponding `RigidBodyControl`
    will be selected.
  prefs: []
  type: TYPE_NORMAL
- en: There's no challenge in a bridge-building game if the segments don't have a
    maximum force they can handle before they break. This is what we take care of
    in the `update` method where we check `appliedImpulse` on each segment. If it
    goes above a certain threshold, it can be considered to be overloaded and removed,
    often with disastrous results. We also set `linearVelocity` along the *z* axis
    on each segment to `0` since it's a 2D game and we don't want anything to move
    to the depth layer.
  prefs: []
  type: TYPE_NORMAL
- en: We start the game with the physics simulation off by setting the speed of `bulletAppState`
    to `0`. Without doing so, building the game will get tricky pretty fast as everything
    will fall down. Pressing the Space bar will start the physics, and let the player
    know whether their engineering skills are up to par.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of things missing from the recipe to make it a full-blown
    bridge builder. First of all, there is usually a limit to the length the segments
    can have. There might also be a grid structure along which they have to be placed.
  prefs: []
  type: TYPE_NORMAL
- en: It's also quite easy since the bridge currently only has to support its own
    weight. In a full game, the difficulty is usually increased by adding a heavier
    object that needs to pass the bridge to complete the level.
  prefs: []
  type: TYPE_NORMAL
- en: Add some monetary constraints to this or a varied terrain and you have a challenging
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Networked physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will go into something of a final frontier in game development.
    The topic is extremely application-dependent, and it is difficult to get right.
    Hopefully, after going through this recipe, you will have a basic framework in
    place that can be adapted to specific projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is for those who have a fundamental understanding of both [Chapter
    7](ch07.html "Chapter 7. Networking with SpiderMonkey"), *Networking with SpiderMonkey*,
    and [Chapter 8](ch08.html "Chapter 8. Physics with Bullet"), *Physics with Bullet*.
    This recipe will describe how to implement networked physics in the networked
    fps that was discussed previously in the book. Since this is built on top of the
    existing framework, an `AppState` pattern has been chosen to isolate as much of
    the physics code as possible. There will be some overlapping, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Physics can be expensive as it is and has its own problems and requirements.
    Sending translations and rotations for objects over the network with every tick
    will seriously affect the bandwidth load. The ground rule is this: send only what
    you must.'
  prefs: []
  type: TYPE_NORMAL
- en: Divide physics objects into those that you're interested in sharing and those
    that you don't. In most games, this means separating those that affect the gameplay
    and those that don't.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a meter-sized crate that can be climbed upon will definitely affect
    the gameplay. It has to be networked.
  prefs: []
  type: TYPE_NORMAL
- en: A bucket that can be kicked or small debris from an explosion do not affect
    the gameplay and should only have local physics. It doesn't matter if they show
    up in different places for different players.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the rule is this: send only when you must. There''s no point
    in sending an update for an object that is not moving.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on the first rule, we''ll start by defining a new `Control` class for
    our networked physics objects:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `PhysicsObjectControl` that extends `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It should have two fields: a Boolean field called `serverControlled` and an
    integer field called `id`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now define a network message to handle updates to objects with physics:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's call it `PhysicsObjectMessage` and have it extend `AbstractMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three mandatory fields for it; they are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first is an integer field called `objectId`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It also needs a `Vector3f` field called `translation`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add a `Quaternion` field called `rotation`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't forget to add the `@Serializable` annotation, and add it to the list of
    messages in the `GameUtil` class!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last common implementation we do is for the `Game` class where we add a
    list of `Spatials` called `physicsObjects`; the following code tells us how to
    do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can dig into the server-side implementation by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We contain most of the code in a new `AppState` class called `ServerPhysicsAppState`.
    This `AppState` class will contain the reference to the `BulletAppState` class,
    and it will handle the initialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside its `initialize` method, it should add the loaded level to `physicsSpace`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A strategy is needed to collect all the objects that should be affected by
    server physics and assign them to `PhysicsObjectControl` (unless this has been
    done in **SceneComposer** already). Objects that should have server physics should
    also have `serverControlled` set to `true` and a unique ID, which is known by
    both the client and the server. The resulting spatials should be stored in the
    `physicsObject` class map, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `update` method of `ServerPhysicsAppState`, we parse through the values
    of the `physicsObject` map. If any of the item in `physicsObjects` has `PhysicsObjectControl`
    that `isServerControlled()` and their `isActive()` is `true`, a new `PhysicsObjectMessage`
    should be created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It should have the ID of `PhysicsObjectControl` as `objectId` and `physicsLocation`
    and `physicsRotation` of `RigidBodyControl`; refer to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The message is then broadcasted to the clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll revisit the server code in a bit, but first let's look at what is needed
    for the client to receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the client has to have `BulletAppState` set up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it needs to have knowledge of the objects to be handled by the server
    physics. If the objects are gathered from the scene, a strategy is needed to make
    sure the IDs are the same, or they're read in the same order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They should then be stored in the `Game` class as on the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second thing is a change to `ClientMessageHandler`. If the message is an
    instance of `PhysicsObjectMessage`, it should get the `physicsObject` `Map` from
    the `Game` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A spatial should then be selected based on the `objectId` in the message as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rotation and translation should be applied as `physicsLocation` and `physicsRotation`
    respectively on the spatial''s `RigidBodyControl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the pipeline for transmitting physics updates from the server to the clients
    should work. If we run it, not much is happening. This is because the players
    in the implementation in [Chapter 7](ch07.html "Chapter 7. Networking with SpiderMonkey"),
    *Networking with SpiderMonkey*, weren't using physics. They were simply coded
    to stick to the surface of the terrain. We can change the player's representation
    to handle this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `ServerPlayerControl`, we add a `BetterCharacterControl` field called `physicsCharacter`
    and a Boolean field called `usePhysics`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we override the `setSpatial` method, and perform a check to see whether
    the spatial supplied has `BetterCharacterControl`. If it does, `usePhysics` should
    be set to `true` and the local `physicsCharacter` field should be set to `spatial`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in the `controlUpdate` method, we check whether `usePhysics` is `true`.
    If it is, rather than updating the spatial like we normally do in the method,
    we should instead set `walkDirection` of `physicsCharacter` to the local one and
    set `viewDirection` to the forward vector of its rotation as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our server''s main class, inside the `addPlayer` method, we should now add
    `BetterCharacterControl` to the player''s spatial before we add `ServerPlayerControl`,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There also needs to be some logic to add and remove `BetterCharacterControl`
    from `physicsSpace` as it joins and leaves the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we did in the recipe was to lay some ground work by defining
    a new control called `PhysicsObjectControl` to be applied to the objects that
    should be handled by bullet physics. This control can either be added at runtime;
    alternatively, if **Scene Composer** is used to lay out levels and scenes, it
    can be added to the objects beforehand. It's recommended that you define which
    ones should be handled by the server by setting `serverControlled` on the relevant
    objects before they're being added to the scenes. The ID should then be set in
    a deterministic way on both the client and the server when they parse the scene
    for the objects.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture to handle the physics might very well look different in another
    implementation, but here, the `AppState` pattern was used so that it could be
    easily added as an extension to the existing framework from [Chapter 7](ch07.html
    "Chapter 7. Networking with SpiderMonkey"), *Networking with SpiderMonkey*. In
    this chapter, we didn't use any physics for the players but simply checked the
    height of the terrain to find out where the ground was. Hence, we added an optional
    `BetterCharacterControl` instance to the player—again, a change that would still
    make it compatible with the previous implementation. However, this was only added
    on the server side. For client-side physics, a similar change would have to be
    made there.
  prefs: []
  type: TYPE_NORMAL
- en: The server will check every update and see whether any of the objects with `serverControlled`
    enabled is active and will send any updates to the clients. Actually, you could
    leave out the physics all together on the client and simply update the spatial's
    rotation and translation, if you wanted. This would lower the requirements on
    the client's hardware, but this will only work if all of the physics are handled
    by the server of course.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an opportunity here to introduce a third state on `PhysicsObjectControl`;
    a state in which the object is affected but not controlled by the server. This
    could be used for objects that are important in their initial state; however,
    once they've been moved, it's no longer important that all the clients have the
    same information, for example, a door that at some points get blown off its hinges.
    In this case, a new message type can be introduced that will apply an impulse
    or force to an object from the server side. Once the object has been activated,
    the client can take care of the calculations, lowering the network load.
  prefs: []
  type: TYPE_NORMAL
