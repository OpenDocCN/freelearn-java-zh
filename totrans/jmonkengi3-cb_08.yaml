- en: Chapter 8. Physics with Bullet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pushable door
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a rocket engine
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ballistic projectiles and arrows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple gravity sources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-balancing using RotationalLimitMotors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principles of a bridge-building game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networked physics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using physics in games has become very common and accessible, thanks to open
    source physics engines, such as Bullet. jMonkeyEngine supports both the Java-based
    jBullet and native Bullet in a seamless manner.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jBullet is a Java-based library with JNI bindings to the original Bullet based
    on C++. jMonkeyEngine is supplied with both of these, and they can be used interchangeably
    by replacing the libraries in the classpath. No coding change is required. Use
    `jme3-libraries-physics` for the implementation of jBullet and `jme3-libraries-physics-native`
    for Bullet. In general, Bullet is considered to be faster and is full featured.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Physics can be used for almost anything in games, from tin cans that can be
    kicked around to character animation systems. In this chapter, we'll try to reflect
    the diversity of these implementations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: All the recipes in this chapter will require you to have a `BulletAppState`
    class in the application. To avoid repetition, the process of doing this is described
    in the *Adding Bullet physics to the application* section in [Appendix](apa.html
    "Appendix A. Information Fragments"), *Information Fragments*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pushable door
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doors are useful in games. Visually, it is more appealing to not have holes
    in the walls but doors for the players to pass through. Doors can be used to obscure
    the view and hide what's behind them for a surprise later. In extension, they
    can also be used to dynamically hide geometries and increase the performance.
    There is also a gameplay aspect where doors are used to open new areas to the
    player and give a sense of progression.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a door that can be opened by pushing it, using
    a `HingeJoint` class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'This door consists of the following three elements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Door object**: This is a visible object'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attachment**: This is the fixed end of the joint around which the hinge swings'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hinge**: This defines how the door should move'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply following the steps in this recipe won't give us anything testable. Since
    the camera has no physics, the door will just sit there and we will have no way
    to push it. If you have made any of the recipes that use the `BetterCharacterControl`
    class, many of them in [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"),
    *Cameras and Game Controls*, we will already have a suitable test bed for the
    door. If not, jMonkeyEngine's `TestBetterCharacter` example can also be used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe consists of two sections. The first will deal with the actual creation
    of the door and the functionality to open it. This will be made in the following
    six steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RigidBodyControl` object called `attachment` with a small `BoxCollisionShape`.
    The `CollisionShape` should normally be placed inside the wall where the player
    can't run into it. It should have a mass of 0, to prevent it from being affected
    by gravity.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We move it some distance away and add it to the `physicsSpace` instance, as
    shown in the following code snippet:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, create a `Geometry` class called `doorGeometry` with a `Box` shape with
    dimensions that are suitable for a door, as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, create a `RigidBodyControl` instance with the same dimensions, that
    is, `1` in `mass`; add it as a control to the `doorGeometry` class first and then
    add it to `physicsSpace` of `bulletAppState`. The following code snippet shows
    you how to do this:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we''re going to connect the two with `HingeJoint`. Create a new `HingeJoint`
    instance called `joint`, as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we set the limit for the rotation of the door and add it to `physicsSpace`
    as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we have a door that can be opened by walking into it. It is primitive
    but effective. Normally, you want doors in games to close after a while. However,
    here, once it is opened, it remains opened. In order to implement an automatic
    closing mechanism, perform the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `DoorCloseControl` extending `AbstractControl`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `HingeJoint` field called `joint` along with a setter for it and a float
    variable called `timeOpen`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `controlUpdate` method, we get `hingeAngle` from `HingeJoint` and store
    it in a float variable called `angle`, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the angle deviates a bit more from zero, we should increase `timeOpen` using
    `tpf`. Otherwise, `timeOpen` should be reset to `0`, as shown in the following
    code snippet:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If `timeOpen` is more than `5`, we begin by checking whether the door is still
    open. If it is, we define a speed to be the inverse of the angle and enable the
    door''s motor to make it move in the opposite direction of its angle, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If `timeOpen` is less than `5`, we should set the speed of the motor to `0`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can create a new `DoorCloseControl` instance in the main class, attach
    it to the `doorGeometry` class, and give it the same joint we used previously
    in the recipe, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attachment `RigidBodyControl` has no mass and will thus not be affected
    by external forces such as gravity. This means it will stick to its place in the
    world. The door, however, has mass and would fall to the ground if the attachment
    didn't keep it up with it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The `HingeJoint` class connects the two and defines how they should move in
    relation to each other. Using `Vector3f.UNIT_Y` means the rotation will be around
    the *y* axis. We set the limit of the joint to be a little more than half PI in
    each direction. This means it will open almost 100 degrees to either side, allowing
    the player to step through.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: When we try this out, there may be some flickering as the camera passes through
    the door. To get around this, there are some tweaks that can be applied. We can
    change the collision shape of the player. Making the collision shape bigger will
    result in the player hitting the wall before the camera gets close enough to clip
    through. This has to be done considering other constraints in the physics world.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: You can consider changing the near clip distance of the camera. Decreasing it
    will allow things to get closer to the camera before they are clipped through.
    This might have implications on the camera's projection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: One thing that will not work is making the door thicker, since the triangles
    on the side closest to the player are the ones that are clipped through. Making
    the door thicker will move them even closer to the player.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In `DoorCloseControl`, we consider the door to be open if `hingeAngle` deviates
    a bit more from 0\. We don't use 0 because we can't control the exact rotation
    of the joint. Instead we use a rotational force to move it. This is what we do
    with `joint.enableMotor`. Once the door is open for more than five seconds, we
    tell it to move in the opposite direction. When it's close to 0, we set the desired
    movement speed to 0\. Simply turning off the motor, in this case, will cause the
    door to keep moving until it is stopped by an external force.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Once we enable the motor, we also need to call `activate()` on `RigidBodyControl`
    or it will not move.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Building a rocket engine
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A rocket engine is crucial for most space-based games and many 2D games as
    well. In this recipe, we''ll cover the minimum that is required to create a thruster
    that can be used in many different contexts. The following figure shows a thruster
    with `ParticleEmitter`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a rocket engine](img/6478OS_08_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to make sure that we see the debug shapes of physics.
    To do this, we need to call the `bulletAppState.setDebugEnabled(true);` statement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will begin by setting up some things that are not strictly needed for the
    rocket engine but will aid the testing. Perform the following steps to build a
    rocket engine:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: First of all we add a floor mesh. For this, we create a new `Node` class called
    `ground`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, we add `RigidBodyControl` with `PlaneCollisionShape`. The plane
    should face upwards like floors normally do, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We then attach them both to `rootNode` of the application and `physicsSpace`
    of `bulletAppState`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to add a key to control the booster. For this, we implement
    an `AnalogListener` interface in our application.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add the application to `inputManager` along with a mapping object called
    boost that is bound to the Space bar:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Most of this recipe will be implemented in a class that extends `SimpleApplication`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We begin by defining a `Node` class called `spaceShip` that will be our spaceship's
    representation.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then create a `RigidBodyControl` instance with `BoxCollisionShape` and add
    it to the `spaceShip` node as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we create another `Node`, which will be our thruster. Give it the name
    `Thruster` to be able to identify it more easily later, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We set `localTranslation` of this so that it will end up at the bottom of the
    spaceship, as shown in the following line of code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, we attach it to the `spaceShip` node.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have to attach the `spaceShip` node to both the `rootNode` and `physicsSpace`
    of `bulletAppState`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To control the thruster and make it more reusable, we will create a class called
    `ThrusterControl`, extending `AbstractControl`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It'll have one field, a `Spatial` field called `thruster`, that will store the
    `thruster` node.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will override the `setSpatial` method and set it by calling `getChild("Thruster")`
    on the supplied spatial.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we define a new method called `fireBooster()`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this, we subtract the thruster''s location from the spaceship''s location
    and store it in a new `Vector3f` field called `direction` as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we find the `RigidBodyControl` class in the spatial and call `applyImpulse`
    with the direction vector. We use the inverted direction as the relative position
    that the impulse should originate from. This can be implemented as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the application class, we have to make it call the `fireBooster` method.
    We do this in the `onAnalog` method that was added when we implemented the `AnalogListener`
    interface:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The graphics in this recipe are very minimalistic and mostly rely on the debug
    mode of `BulletAppState` to draw them. The physics shapes don't normally have
    a visual representation since they're not part of the scene graph. Using the debug
    mode can be very useful during early prototypes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The `RigidBodyControl` instance of the spaceship makes sure it's affected by
    gravity and other forces.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The sole purpose of a thruster is to be able to easily retrieve the position
    that is relative to the spaceship from where the boosting force needs to be applied.
    This is why we place it at the bottom of the spaceship. The benefit of using the
    `Control` pattern to control a `Thruster` is that we can apply it to other geometries
    easily (and even use it in `SceneComposer`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The `fireBooster` method of `ThrusterControl` takes the position of `spaceShip`
    and subtracts the position of the thruster node to get the direction of the force
    to apply. The relative position of the force is the direct opposite of this direction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Ballistic projectiles and arrows
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applying physics to arrows can greatly improve the appearance and gameplay
    of a medieval or fantasy game. Setting up arrows that are affected by gravity
    is fairly simple; this recipe, however, will also set the arrows up in a way that
    they always face the direction they''re traveling in, making them more realistic.
    The following figure shows one of the arrows in flight:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Ballistic projectiles and arrows](img/6478OS_08_01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to make sure that we see the debug shapes of physics.
    To do this, we need to call the `bulletAppState.setDebugEnabled(true);` statement.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create three classes. Let''s begin by looking at the
    `Arrow` class, which contains most of the new functionalities. This will be done
    in the following eight steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `Arrow`, extending `Node`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Its constructor takes two `Vector3f` variables as parameters. One of these
    is for the starting location of the arrow and one for the initial velocity, as
    shown in the following line of code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the constructor, we define a `Geometry` instance for the body of the
    arrow with a `box` mesh as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we set `localTranslation` of `Geometry` so that one of its ends touches
    the center point of the node as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We set `localTranslation` of this `Arrow` as the supplied location.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we create `CollisionShape`. This will represent the head of the arrow
    and can be `SphereCollisionShape`, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we define `RigidBodyControl` based on `CollisionShape`, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We set `LinearVelocity` of `RigidBodyControl` to be the supplied velocity and
    add it as a Control to Arrow, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This would be enough for the arrow to follow the laws of physics; however,
    it will always face the forward direction. By adding another control, we can make
    it face the direction of the velocity. To do this, perform the following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Create another class called `ArrowFacingControl`, extending `AbstractControl`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `Vector3f` field called `direction`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `controlUpdate` method, we get `linearVelocity` from `RigidBodyControl`
    of the spatial and normalize it. We then store it in `direction` as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, call the spatial and tell it to rotate to the supplied `direction` vector
    as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the constructor of the `Arrow` class, we add an instance of this control,
    as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last section handles the firing of the arrow from `SimpleApplication`.
    This can be done with the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to implement `ActionListener` in the application.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `ActionListener` class to `inputManager` as a listener, together with
    a key for firing arrows, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `onAction` method, call a new method called `fireArrow` when the `fire`
    button is released. This can be implemented as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `fireArrow` method should begin by instancing a new `Arrow` instance and
    applying a (preloaded) material to it, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We attach it to `rootNode` as well as to `physicsSpace`, as shown in the following
    code snippet:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Arrow` object has two major components. One is `Geometry`, which is a simple
    elongated box. The other is `CollisionShape` for the head of the arrow, which
    is the only thing that will look for collisions. The geometry is conveniently
    moved so that its tip will be at the (0,0,0) position of the `Arrow` node. It
    is convenient since it means we don't have to do any conversions in `ArrowFacingControl`
    but can use `rotateUpTo` with the actual velocity (direction) of the arrow.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple gravity sources
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some games require handling gravity from multiple variable sources. In this
    recipe, we'll handle this and create a simple miniature solar system to demonstrate
    it using `ThrusterControl` from the *Building a rocket engine* recipe. To (greatly)
    simplify the relation between the planets, they won't affect each other with their
    gravity, but only the ship. It will also be made in a 2D-asteroids-like fashion,
    although the gravity would still apply for a 3D game.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We'll add some basic controls to rotate the ship to the left and right, and
    you can use the thruster to make the ship move forward.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from `ThrusterControl`, we''ll create two more small classes and an application
    class that joins everything together. Let''s start with a class that represents
    the player''s ship. This will consist of the following six steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `SpaceShip`, which has a `Node` field called `shipNode`
    in it.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, we set up the physics for it by creating a new `RigidBodyControl`
    instance with `BoxCollisionShape`. To create it in a way that it is affected by
    gravity, we also give it a mass of `1` that will be supplied in the constructor
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we create a `Node` instance called `thruster`. We also set the name of
    `Node` to `Thruster` for the control to find it automatically, as shown in the
    following line of code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We set `localTranslation` to be at one of the sides of the spaceship and attach
    it to `shipNode`, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we rotate the ship''s spatial so that it''s facing sideways:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, we add a new `ThrusterControl` instance to the spaceship's spatial.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s it for the `SpaceShip` class. Now, we create a class for our planets,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by defining a class called `StellarBody`, which extends `AbstractControl`.
    The `StellarBody` class has four float fields: `size`, `speed`, `orbit`, and `cycle`.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The constructor takes three of these (`size`, `speed`, and `orbit`) as the
    input, as shown in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We override the `setSpatial` method and add `RigidBodyControl` to the supplied
    spatial with `SphereCollisionShape`, using `size` as the radius and `0` for mass:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `controlUpdate` method, we make it move along its orbit by increasing
    the speed of the cycle by multiplying it by `tpf`, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we set the actual position of the planet along the orbit using the `sin`
    and `cos` methods of the `FastMath` class:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We multiply the result by the orbit and set `localTranslation` of the spatial
    to the new location as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将结果乘以轨道，并将空间体的`localTranslation`设置为新的位置，如下所示：
- en: '[PRE39]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, we also need to set `physicsLocation` of `RigidBodyControl` to the same
    location.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们还需要将`RigidBodyControl`的`physicsLocation`设置为相同的位置。
- en: We need a new method, `getGravity`, that will take the position of the ship
    as an input `Vector3f`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个名为`getGravity`的新方法，它将船的位置作为输入`Vector3f`。
- en: 'The method begins by subtracting the input position by `worldTranslation`,
    to get the position of the ship relative to the `StellarBody` class, as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法首先从输入位置减去`worldTranslation`，以获得相对于`StellarBody`类的船的位置，如下所示：
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The result is normalized and then modified by a formula to get a suitable gravity.
    This value is returned to the calling method, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果经过归一化，然后通过一个公式进行修改以获得合适的重力。这个值随后返回给调用方法，如下所示：
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To test all of this, we need to add a few things to `SimpleApplication`. To
    do this, perform the following set of steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试所有这些，我们需要向`SimpleApplication`添加一些内容。为此，执行以下步骤：
- en: First of all, we implement `AnalogListener`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们实现`AnalogListener`。
- en: We add an `ArrayList<StellarBody>` list called `gravitationalBodies`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个名为`gravitationalBodies`的`ArrayList<StellarBody>`列表。
- en: 'In the `simpleInitApp` method, we should begin by initializing `bulletAppState`
    and set up some controls for the spaceship. We add actions to rotate the spaceship
    to the left and right as well as fire the ship''s thruster, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`simpleInitApp`方法中，我们应该首先初始化`bulletAppState`并为飞船设置一些控制。我们添加了使飞船向左和向右旋转以及发射飞船推进器的动作，如下所示：
- en: '[PRE42]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since it''s a 2D representation, we move the camera some distance up and make
    it look as if it is at the center of the world. This can be implemented as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个二维表示，我们将摄像机向上移动一段距离，使其看起来像是位于世界的中心。这可以通过以下方式实现：
- en: '[PRE43]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We create an instance called `ship` of `SpaceShip` and attach its geometry to
    `rootNode` and `physicsSpace` of `bulletAppState`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个名为`ship`的`SpaceShip`实例，并将其几何形状附加到`rootNode`和`bulletAppState`的`physicsSpace`。
- en: 'Now we can create a number of `StellarBody` instances using the following steps:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下步骤创建多个`StellarBody`实例：
- en: For each instance, we should create a `Geometry` class with a `Sphere` shape
    that will have the same radius as the size we will supply to the `StellarBody`
    control.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个实例，我们应该创建一个具有`Sphere`形状的`Geometry`类，其半径将与提供给`StellarBody`控制的大小相同。
- en: The `Geometry` class should both be attached to `rootNode` and `physicsSpace`
    of `bulletAppState`.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Geometry`类应该同时附加到`bulletAppState`的`rootNode`和`physicsSpace`。'
- en: We add `StellarBody` as a control to the `Geometry` class and the `gravitationalBodies`
    list.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`StellarBody`作为控制添加到`Geometry`类和`gravitationalBodies`列表中。
- en: Inside the `update` method, we have to take into account the gravity of the
    `StellarBody` instances.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法内部，我们必须考虑到`StellarBody`实例的重力。
- en: First, we define a new `Vector3f` instance called `combinedGravity`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个新的`Vector3f`实例，称为`combinedGravity`。
- en: 'Then, we loop through our `gravitationalBodies` list and apply the following
    line of code to apply the gravity to `combinedGravity`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历我们的`gravitationalBodies`列表，并将以下代码行应用于将重力应用于`combinedGravity`：
- en: '[PRE44]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, we call the `ship.setGravity(combinedGravity);` statement.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`ship.setGravity(combinedGravity);`语句。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Due to the extreme difficulty in creating a stable solar system with more than
    three bodies, `StellarBody` controls the need to have a static orbit around the
    center of the system. Using `0` as mass ensures that they aren't affected by gravity.
    The orbit field represents the orbit's distance from the center of the system,
    and it will rotate around the center using speed as a factor. The cycle field
    stores information on how far along its orbit it has come, and will reset once
    it reaches two PI (a full circle).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建包含三个以上实体的稳定太阳系极端困难，`StellarBody`控制需要围绕系统中心有一个静态轨道。使用`0`作为质量确保它们不受重力影响。轨道字段表示轨道距离系统中心的距离，它将使用速度作为因素围绕中心旋转。周期字段存储有关其轨道进度的信息，并在达到两PI（一个完整圆周）时重置。
- en: The `getGravity` method returns the gravity relative to the position that is
    supplied, which in this case is the location of the ship. It first determines
    the direction and then applies the gravity based on the distance between the two.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGravity`方法返回相对于提供的位置的引力，在这种情况下是船的位置。它首先确定方向，然后根据两个位置之间的距离应用重力。'
- en: By using the `gravitationalBodies` list, we have a dynamic way to simply add
    up all the gravitational forces in the system to a single `Vector3f` object, which
    we then apply to the spaceship in the `update` method of the application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Self-balancing using RotationalLimitMotors
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many games today use a blend of animations and physics to create realistic movement.
    For animated characters, this revolves around balance. It could take the shape
    of a runner who leans inwards through a curve to counter the centrifugal force.
    Creating a system like this is not easy and requires a lot of tweaking. In this
    recipe, we'll look into some of the fundamentals of this, and we'll create a new
    `Control` class that will try to balance itself using the rotational motors of
    `SixDofJoint`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Six Degrees of Freedom** (**SixDof**) relates to the six ways the joint can
    rotate: +x, -x, +y, -y, +z, and -z. One way it differs from a `point2point` joint
    is that in addition, it also has motors for each axis, which makes it possible
    for it to also apply force.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simulate balancing, we will begin by creating the upper body of a stickman-shape
    figure with a torso and two rigid arms. To do this, perform the following set
    of steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we should set up an application with `BulletAppState`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `simpleInitApp` method, we create a small square `Box Geometry` to be
    the waist of the character. It can be `0.25f` in all the axes.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add `RigidBodyControl` to it with `0` in mass since it shouldn't move.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we create an oblong box to be the torso and place it above the waist.
    It should have `RigidBodyControl` with `1` in mass and `BoxCollisionShape` should
    be of the same size as the geometry:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we create `SixDofJoint` between the waist and torso and afterwards add
    it to `physicsSpace` as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We should limit the joint so that it can''t rotate on any axes other than the
    *x* axis, and it shouldn''t be able to rotate too much. We can use the following
    `setAngularLowerLimit` and `setAngularUpperLimit` methods for this:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, we create one of the arms.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create one of the arms by placing it at the same location as that of the
    torso and giving it a size of `Vector3f(0.25f, 0.25f, 2f)`, making it stretch
    out sideways, as shown in the following code snippet:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We create another `SixDofJoint` for it using the pivot points of `Vector3f(0,
    2.5f, 0.25f)` and `Vector3f(0, 0, -2.5f)`, offsetting it some distance to the
    side of the torso's spatial.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we set the angular limits of the joint to `Vector3f(0, 0, 0)` and `Vector3f(FastMath.QUARTER_PI,
    0, 0)`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We repeat the previous three steps to create the opposite arm, but we'll reverse
    the offset values to make the arm protrude in the opposite direction of the torso.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now have the basics done for our recipe. Running it should show the character
    slumping to one side with the arms stretched out to the sides. Now, we can begin
    with balancing by performing the following steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `BalanceControl`, extending `AbstractControl`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should have a `SixDofJoint` field called `joint` and a `RotationalLimitMotor`
    field called `motorX`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `setJoint` method.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this method, after setting the joint, we also populate `motorX` with
    one of the `RotationalLimitMotor` instances, as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inside the `controlUpdate` method, we get `bodyA` from the joint and store
    it in `PhysicsRigidBody`. This is the torso:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We get the current rotation of `bodyA` to see how much it pivots. We then convert
    the rotation to angles and store them as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We then store `angles[0]` in a float variable called `x`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If `x` is more than 0.01f or less than -0.01, we should start `motorX` and
    rotate it to compensate for the pivot, as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Otherwise, we turn off the motor as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running the result, we should see the stickman desperately trying to stay upright
    while flailing his arms up and down. The reason is that getting the forces right
    when balancing can be very difficult. With values that are too high, the stickman
    will constantly overshoot the target and instead rotate in the other direction.
    With values that are too low, it won't have the strength to get upright. With
    some further tweaking to `targetVelocity` and `maxMotorForce`, we might be able
    make him stable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We started by creating the basic shape of a figure that would try to keep the
    balance. The waist was made to not be affected by the physics, so it could be
    a solid point. We then added a torso and two arms, resulting in a center of mass
    somewhere in the upper part of the torso. By placing each of the body parts at
    some distance from each other with the joints, we give them more freedom of movement.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The `BalanceControl` class we created has one simple strategy. It looks for
    the torso (bodyA)'s rotation along the *x* axis, and tries to keep it as close
    to 0 as possible. If it notices that it's anything but near 0, it will try to
    move the arms, shifting the center of the mass to the opposite direction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Despite the low number of components, getting it all to balance out is really
    difficult! Having more components, such as a whole human skeleton, requires a
    much more advanced strategy, with body parts moving in a synchronized fashion,
    rather than they trying to do so individually.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The principles of a bridge-building game
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variants of bridge-building games have been around for a long time. The classical
    *Bridge Builder* is a 2D physics game where the player is required connect beams
    to create a bridge strong enough for a train (or some other moving object) to
    pass.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will describe most of the core functionalities needed to create
    such a game, including making the objects stay 2D and not wander off on the *z*
    axis.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll have some basic controls for the game:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Left-click will select a previously built node in the bridge
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-click will add a new node or connect two previously built ones
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Space bar will turn on the physics
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows a bridge:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![The principles of a bridge-building game](img/6478OS_08_02.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin with more physics-related functions, we should set up the basic
    application.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we create a new class that extends `SimpleApplication`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on, we''re going to use the following two lists:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We also need some strings as input mappings: `LEFT_CLICK`, `RIGHT_CLICK`, and
    `TOGGLE_PHYSICS`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: We add a `RigidBodyControl` field called `selectedSegment` that will contain
    the last selected segment in the game.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re strictly making a 2D game, we should change the camera to be orthographic.
    This can be done by performing the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Disable `flyCam`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out the aspect ratio by dividing the `cam` width by its height and storing
    it.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `cam.parallelProjection` to `true`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, change `frustrum` of the camera to suit and orthographic view as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We move it some way along the *z* axis and rotate it back towards the center,
    as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, we can initialize `bulletAppState` as we usually do. Turn on the debug
    mode, and most importantly, set `speed` to `0`. We don't want any physics on while
    we build the bridge.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The world needs a gap to be bridged. So, for this, we''ll use `RigidBodyControl`
    to represent two cliffs, one on either side, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Create one `RigidBodyControl` instance for each side and give it `BoxCollisionShape`
    with a size of `Vector3f(75f, 50f, 5f)` and `0` mass.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place one of them at `Vector3f(-100f, -50f, 0)` and the other one at `Vector3f(100f,
    -50f, 0)`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, add them to `physicsSpace`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to start by creating two methods that will help us add new bridge
    segments to the game:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We define a method called `createSegment` that takes a `Vector3f` parameter
    called `location` as the input.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we do is set the `z` value of `location` to `0`. This is because
    we're making a 2D game.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we create a new `RigidBodyControl` instance called `newSegment`. We add
    `SphereCollisionShape` to it and then add `newSegment` to `physicsSpace`. It''s
    important that it has some mass. This can be implemented as follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, we create a `Geometry` instance based on a `Sphere` shape with the same
    radius as `RigidBodyControl`. We will use this as a target for mouse clicks.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Geometry` object needs `modelBound` for which we'll use `BoundingSphere`.
    The radius may be bigger than `RigidBodyControl`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `RigidBodyControl` object is added to `Geometry` as a control and we use
    the `setPhysicsLocation` method to move it to the to the supplied location, as
    follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `Geometry` object is then added to the segments list we defined earlier
    and then it is attached to `rootNode`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If `selectedSegment` is not null, we will call a method we will define next:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Lastly, in the `createJoint` method, we set `selectedSegment` to be `newSegment`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can define the `createJoint` method. It takes two `RigidBodyControl`
    parameters as the input, as shown in the following code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'First, we find out the location that should be the pivot point of `body2`.
    This is the same as `physicsLocation` of `body2` subtracted from `physicsLocation`
    of `body1`, as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we define `Point2PointJoint` by joining the two segments. The vectors
    supplied mean that `body2` will pivot in a way that is relative to `body1`; we
    do this using the following code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We then add the newly created joint to the `joints` list and to `physicsSpace`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re now getting to the controls of the application and need another method
    to help us. The method will check whether a mouse click has hit any segment and
    return it. To do this, perform the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: We define a new method called `checkSelection`, which returns `RigidBodyControl`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this method, we create a new `Ray` instance, which will have the current
    mouse cursor''s location as the origin; the following code tells you how to do
    this:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Since the view is orthographic, we let the direction be `Vector3f(0, 0, -1f)`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we define a new `CollisionResults` instance to store any segments that
    `Ray` collides with.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing we do is parse through the segment's list and check whether the
    ray hits any of them.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it does, we're done, and then return `RigidBodyControl` of segment to the
    calling method.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We defined a couple of input mappings earlier. Now, we can all implement the
    functionality for them in the `onAction` method by performing the following steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'If the left mouse button is clicked, we should call `checkSelection`. If the
    returned value is not null, we should set `selectedSegment` to that value, as
    follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If the right mouse button is clicked, we should also call `checkSelection`.
    If the returned value is not null and it''s not `selectedSegment`, we call `createJoint`
    with `selectedSegment` and the value of `checkSelection` to create a link between
    `selectedSegment` and the segment returned from the method, as shown in the following
    code snippet:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Otherwise, if we didn''t hit anything, we call `createSegment` with the position
    of the mouse cursor to create a new segment at that location as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the Space bar has been pressed, all we need to do is set the speed of `bulletAppState`
    to `1` to start the physics.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re almost done with our simulation now, but we need to do a few more things.
    This last section will handle the `update` method and what happens when the physics
    is running and the bridge is being tested:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` method, we parse through all the items in the segment list
    and set the `z` value of `linearVelocity` to `0`, as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After this, we parse through all the items in the joint''s list. For each,
    we should check whether the joint''s `appliedImpulse` value is higher than a value,
    let''s say `10`. If it is, the joint should be removed from the list as well as
    from `physicsSpace`, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `createSegment` method creates a new bridge segment that is sphere shaped,
    both in `physicsSpace` and the visible world. This is the part that has a mass
    and can be selected by clicking on it, since `Ray` only collides with spatials.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The `createJoint` method creates the visible connection between the newly created
    segment, and the currently selected one. It does this using `Point2PointJoin`t.
    This is different from, for example, `HingeJoint`, since it's not fixed in space,
    when several `Point2Pointjoints` are connected and you have something that resembles
    a bridge.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The mouse selection is covered more in depth in other chapters, but it works
    by shooting `Ray` from the mouse's position on the screen, inwards into the game
    world. Once `Ray` hits `Geometry` (which has `BoundingSphere` that is slightly
    larger than the visible mesh for increased selectability), the corresponding `RigidBodyControl`
    will be selected.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: There's no challenge in a bridge-building game if the segments don't have a
    maximum force they can handle before they break. This is what we take care of
    in the `update` method where we check `appliedImpulse` on each segment. If it
    goes above a certain threshold, it can be considered to be overloaded and removed,
    often with disastrous results. We also set `linearVelocity` along the *z* axis
    on each segment to `0` since it's a 2D game and we don't want anything to move
    to the depth layer.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: We start the game with the physics simulation off by setting the speed of `bulletAppState`
    to `0`. Without doing so, building the game will get tricky pretty fast as everything
    will fall down. Pressing the Space bar will start the physics, and let the player
    know whether their engineering skills are up to par.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of things missing from the recipe to make it a full-blown
    bridge builder. First of all, there is usually a limit to the length the segments
    can have. There might also be a grid structure along which they have to be placed.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: It's also quite easy since the bridge currently only has to support its own
    weight. In a full game, the difficulty is usually increased by adding a heavier
    object that needs to pass the bridge to complete the level.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Add some monetary constraints to this or a varied terrain and you have a challenging
    game.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Networked physics
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will go into something of a final frontier in game development.
    The topic is extremely application-dependent, and it is difficult to get right.
    Hopefully, after going through this recipe, you will have a basic framework in
    place that can be adapted to specific projects.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is for those who have a fundamental understanding of both [Chapter
    7](ch07.html "Chapter 7. Networking with SpiderMonkey"), *Networking with SpiderMonkey*,
    and [Chapter 8](ch08.html "Chapter 8. Physics with Bullet"), *Physics with Bullet*.
    This recipe will describe how to implement networked physics in the networked
    fps that was discussed previously in the book. Since this is built on top of the
    existing framework, an `AppState` pattern has been chosen to isolate as much of
    the physics code as possible. There will be some overlapping, though.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Physics can be expensive as it is and has its own problems and requirements.
    Sending translations and rotations for objects over the network with every tick
    will seriously affect the bandwidth load. The ground rule is this: send only what
    you must.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Divide physics objects into those that you're interested in sharing and those
    that you don't. In most games, this means separating those that affect the gameplay
    and those that don't.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: For example, a meter-sized crate that can be climbed upon will definitely affect
    the gameplay. It has to be networked.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: A bucket that can be kicked or small debris from an explosion do not affect
    the gameplay and should only have local physics. It doesn't matter if they show
    up in different places for different players.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the rule is this: send only when you must. There''s no point
    in sending an update for an object that is not moving.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on the first rule, we''ll start by defining a new `Control` class for
    our networked physics objects:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `PhysicsObjectControl` that extends `AbstractControl`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It should have two fields: a Boolean field called `serverControlled` and an
    integer field called `id`.'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now define a network message to handle updates to objects with physics:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Let's call it `PhysicsObjectMessage` and have it extend `AbstractMessage`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three mandatory fields for it; they are as follows:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first is an integer field called `objectId`
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It also needs a `Vector3f` field called `translation`
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add a `Quaternion` field called `rotation`
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't forget to add the `@Serializable` annotation, and add it to the list of
    messages in the `GameUtil` class!
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last common implementation we do is for the `Game` class where we add a
    list of `Spatials` called `physicsObjects`; the following code tells us how to
    do this:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can dig into the server-side implementation by performing the following
    steps:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: We contain most of the code in a new `AppState` class called `ServerPhysicsAppState`.
    This `AppState` class will contain the reference to the `BulletAppState` class,
    and it will handle the initialization.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside its `initialize` method, it should add the loaded level to `physicsSpace`
    as follows:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A strategy is needed to collect all the objects that should be affected by
    server physics and assign them to `PhysicsObjectControl` (unless this has been
    done in **SceneComposer** already). Objects that should have server physics should
    also have `serverControlled` set to `true` and a unique ID, which is known by
    both the client and the server. The resulting spatials should be stored in the
    `physicsObject` class map, as follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the `update` method of `ServerPhysicsAppState`, we parse through the values
    of the `physicsObject` map. If any of the item in `physicsObjects` has `PhysicsObjectControl`
    that `isServerControlled()` and their `isActive()` is `true`, a new `PhysicsObjectMessage`
    should be created as follows:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'It should have the ID of `PhysicsObjectControl` as `objectId` and `physicsLocation`
    and `physicsRotation` of `RigidBodyControl`; refer to the following code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The message is then broadcasted to the clients.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll revisit the server code in a bit, but first let's look at what is needed
    for the client to receive messages.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the client has to have `BulletAppState` set up.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it needs to have knowledge of the objects to be handled by the server
    physics. If the objects are gathered from the scene, a strategy is needed to make
    sure the IDs are the same, or they're read in the same order.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They should then be stored in the `Game` class as on the server.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second thing is a change to `ClientMessageHandler`. If the message is an
    instance of `PhysicsObjectMessage`, it should get the `physicsObject` `Map` from
    the `Game` class as follows:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'A spatial should then be selected based on the `objectId` in the message as
    follows:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The rotation and translation should be applied as `physicsLocation` and `physicsRotation`
    respectively on the spatial''s `RigidBodyControl`:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, the pipeline for transmitting physics updates from the server to the clients
    should work. If we run it, not much is happening. This is because the players
    in the implementation in [Chapter 7](ch07.html "Chapter 7. Networking with SpiderMonkey"),
    *Networking with SpiderMonkey*, weren't using physics. They were simply coded
    to stick to the surface of the terrain. We can change the player's representation
    to handle this.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `ServerPlayerControl`, we add a `BetterCharacterControl` field called `physicsCharacter`
    and a Boolean field called `usePhysics`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we override the `setSpatial` method, and perform a check to see whether
    the spatial supplied has `BetterCharacterControl`. If it does, `usePhysics` should
    be set to `true` and the local `physicsCharacter` field should be set to `spatial`
    as follows:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, in the `controlUpdate` method, we check whether `usePhysics` is `true`.
    If it is, rather than updating the spatial like we normally do in the method,
    we should instead set `walkDirection` of `physicsCharacter` to the local one and
    set `viewDirection` to the forward vector of its rotation as follows:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In our server''s main class, inside the `addPlayer` method, we should now add
    `BetterCharacterControl` to the player''s spatial before we add `ServerPlayerControl`,
    as shown in the following code snippet:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: There also needs to be some logic to add and remove `BetterCharacterControl`
    from `physicsSpace` as it joins and leaves the game.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we did in the recipe was to lay some ground work by defining
    a new control called `PhysicsObjectControl` to be applied to the objects that
    should be handled by bullet physics. This control can either be added at runtime;
    alternatively, if **Scene Composer** is used to lay out levels and scenes, it
    can be added to the objects beforehand. It's recommended that you define which
    ones should be handled by the server by setting `serverControlled` on the relevant
    objects before they're being added to the scenes. The ID should then be set in
    a deterministic way on both the client and the server when they parse the scene
    for the objects.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The architecture to handle the physics might very well look different in another
    implementation, but here, the `AppState` pattern was used so that it could be
    easily added as an extension to the existing framework from [Chapter 7](ch07.html
    "Chapter 7. Networking with SpiderMonkey"), *Networking with SpiderMonkey*. In
    this chapter, we didn't use any physics for the players but simply checked the
    height of the terrain to find out where the ground was. Hence, we added an optional
    `BetterCharacterControl` instance to the player—again, a change that would still
    make it compatible with the previous implementation. However, this was only added
    on the server side. For client-side physics, a similar change would have to be
    made there.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The server will check every update and see whether any of the objects with `serverControlled`
    enabled is active and will send any updates to the clients. Actually, you could
    leave out the physics all together on the client and simply update the spatial's
    rotation and translation, if you wanted. This would lower the requirements on
    the client's hardware, but this will only work if all of the physics are handled
    by the server of course.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an opportunity here to introduce a third state on `PhysicsObjectControl`;
    a state in which the object is affected but not controlled by the server. This
    could be used for objects that are important in their initial state; however,
    once they've been moved, it's no longer important that all the clients have the
    same information, for example, a door that at some points get blown off its hinges.
    In this case, a new message type can be introduced that will apply an impulse
    or force to an object from the server side. Once the object has been activated,
    the client can take care of the calculations, lowering the network load.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
