- en: Chapter 2. Basic Language Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned the various aspects of setting up the development
    environment wherein we covered the structure of a Scala project and identified
    the use of `sbt` for building and running projects. We covered REPL, which is
    a command-line interface for running Scala code, and how to develop and run code
    over the IDEA IDE. Finally, we implemented interactions with our simple `chatbot`
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the so-called 'OO' part of Scala, which allows
    us to build constructions similar to analogs in any mainstream language, such
    as Java or C++. The object-oriented part of Scala will cover classes and objects,
    traits, pattern matching, case class, and so on. Finally, we will implement the
    object-oriented concepts that we learn to our chatbot application.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the history of programming paradigms, we will notice that the first
    generation of high-level programming languages (Fortran, C, Pascal) were procedure
    oriented, without OO or FP facilities. Then, OO become a hot topic in programming
    languages in the 1980s.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the structure of non-trivial Scala programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Identify how to use main object-oriented facilities: objects, classes, and
    traits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize the details of function call syntax and parameter-passing modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects, Classes, and Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala is a multiparadigm language, which unites functional and OO programming.
    Now, we will explore Scala''s traditional object-oriented programming facilities:
    object, classes, and traits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These facilities are similar in the sense that each one contains some sets
    of data and methods, but they are different regarding life cycle and instance
    management:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects are used when we need a type with one instance (such as singletons)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are used when we need to have many instances, which can be created with
    the help of the new operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits are used for mix-ins into other classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that it is not worth navigating through code, as this is exposed in examples.
  prefs: []
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen an object in the previous chapter. Let''s scroll through our codebase
    and open the file named `Main` in `Lesson 2/3-project`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s just a set of definitions, grouped into one object, which is available
    statically. That is, the implementation of a singleton pattern: we only have one
    instance of an object of a given type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the definition of the value ( `val effects`) and main functions.
    The syntax is more-or-less visible. One non-obvious thing is that the `val` and
    `var` definitions that are represented are not plain field, but internal field
    and pairs of functions: the `getter` and `setter` functions for `var-s`. This
    allows overriding `def-s` by `val-s`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the name in the object definition is a name of an object, not a name
    of the type. The type of the object, `Chatbot3`, can be accessed as `Chatb` `ot3.type.`
  prefs: []
  type: TYPE_NORMAL
- en: Let's define the object and call a method. We will also try to assign the object
    to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should have `project-3` opened in IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the project structure and find the `com.packt.courseware.l3` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and select `create class` in the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `ExampleObject` in the name field and choose `object` in the kind field
    of the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IDEA will generate the file in the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following in the object definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Classes form the next step in abstractions. Here is an example of a class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here is a class with parameters ( `phi`, `radius`) specified in the class definition.
    Statements outside the class methods (such as require statements) constitute the
    body of a primary constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The next definition is a secondary constructor, which must call the primary
    constructor at the first statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an object instance using the `new` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By default, member access modifiers are `public`, so once we have created an
    object, we can use its methods. Of course, it is possible to define the method
    as `protected` or `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want to have constructor parameters available in the role of
    class members. A special syntax for this exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we write `val` as a modifier of the constructor argument ( `phi`), then `phi`
    becomes a member of the class and will be available as a field.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you browse the source code of a typical Scala project, you will notice that
    an object with the same name as a class is often defined along with the class
    definition. Such objects are called `companion` objects of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a typical place for utility functions, which in the Java world are usually
    represented by `static` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Method names also exist, which allow you to use special syntax sugar on the
    call side. We will tell you about all of these methods a bit later. We will talk
    about the `apply` method now.
  prefs: []
  type: TYPE_NORMAL
- en: When a method is named `apply`, it can be called via functional call braces
    (for example, `x(y)` is the same as `x.apply(y),` if `apply` is defined in `x`).
  prefs: []
  type: TYPE_NORMAL
- en: Conventionally, the `apply` method in the companion object is often used for
    instance creation to allow the syntax without the `new` operator. So, in our example,
    `PolarPoint(3.0,5.0)` will be demangled to `PolarPoint.apply(3.0,5.0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's define a case class, CartesianPoint, with the method length.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the `Lesson 2/4-project` project is open in IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Scala class with the name `CartesianPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should be something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Equality and Case Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, two flavors of equality exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensional**, where two objects are equal when all external properties are
    equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In JVM, a user can override equals and `hashCode` methods of an object to achieve
    such a behavior.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In a Scala expression, `x == y` is a shortcut of `x.equals(y)` if `x` is a reference
    type (for example, a class or object).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intentional** (or reference), where two objects with the same properties
    can be different because they had been created in a different time and context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In JVM, this is the comparison of references; `(x == y)` in Java and `(x eq
    y)` in Scala.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at our `PolarPoint`, it looks as though if we want `PolarPoint(0,1)`
    to be equal `PolarPoint(0,1)`, then we must override `equals` and `hashCode`.
  prefs: []
  type: TYPE_NORMAL
- en: The Scala language provides a flavor of classes, which will do this work (and
    some others) automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the `case` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we mark a class as a case class, the Scala compiler will generate the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`equals` and `hashCode` methods, which will compare classes by components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A toString` method which will output components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A copy` method, which will allow you to create a copy of the class, with some
    of the fields changed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All parameter constructors will become class values (therefore, we do not need
    to write `val`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The companion object of a class with the apply method (for constructor shortcuts)
    and `unapply` method (for deconstruction in case patterns)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we'll look at illustrating the differences between value and reference
    equality.
  prefs: []
  type: TYPE_NORMAL
- en: In `test/com.packt.courseware.l4`, create a worksheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a worksheet, navigate to package, and right-click and choose create
    a Scala worksheet from the drop-down menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a non-case class with fields in this file after import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the results are `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the case class with the same fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a similar test. Note the differences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pattern Matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pattern matching** is a construction that was first introduced into the ML
    language family near 1972 (another similar technique can also be viewed as a pattern-matching
    predecessor, and this was in REFAL language in 1968). After Scala, most new mainstream
    programming languages (such as Rust and Swift) also started to include pattern-matching
    constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at pattern-matching usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: On the second line, we see a match/case expression; we match `p` against the
    sequence of case-e clauses. Each case clause contains a pattern and body, which
    is evaluated if the matched expression satisfies the appropriative pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the first case pattern will match any point with a radius of
    `0`, that is, `_` match any.
  prefs: []
  type: TYPE_NORMAL
- en: Second–This will satisfy any `PolarPoint` with a radius of one, as specified
    in the optional pattern condition. Note that the new value ( `x`) is introduced
    into the body context.
  prefs: []
  type: TYPE_NORMAL
- en: Third – This will match any point; bind `x` and `y` to `phi` and the `radius`
    accordingly, and `v` to the pattern ( `v` is the same as the original matched
    pattern, but with the correct type).
  prefs: []
  type: TYPE_NORMAL
- en: The final case expression is a `default` case, which matches any value of `p`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the patterns can be nested.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, case classes can participate in case expression and provide a
    method for pushing matched values into the body's content (which is deconstructed).
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to use match/case statements.
  prefs: []
  type: TYPE_NORMAL
- en: Create a class file in the test sources of the current project with the name
    `Person`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a case class called `Person` with the members `firstName` and `lastName:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a companion object and add a method which accepts `person` and returns
    `String:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `case` statement, which will print:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"`A`" if the person''s first name is "`Joe`"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"`B`" if the person does not satisfy other cases'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"`C`" if the `lastName` starts in lowercase'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a test-case for this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traits are used for grouping methods and values which can be used in other classes.
    The functionality of traits is mixed into other traits and classes, which in other
    languages are appropriative constructions called `mixins`. In Java 8, interfaces
    are something similar to traits, since it is possible to define default implementations.
    This isn't entirely accurate, though, because Java's default method can't fully
    participate in inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a trait, which can be extended by the `PolarPoint` class, or with the
    `CartesianPoint` with the next definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Instances of traits cannot be created, but it is possible to create anonymous
    classes extending the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of a trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the conflicting method must be overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet one puzzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The result of `D1.g` will be `g.B`, and `D2.g` will be `g.C`. This is because
    traits are linearized into sequence, where each trait overrides methods from the
    previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try to represent the diamond in a trait hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Component` – A `base` class with the `description()` method, which outputs
    the description of a component.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Transmitter` – A component which generates a signal and has a method called
    `generateParams`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Receiver` – A component which accepts a signal and has a method called `receiveParams`.'
  prefs: []
  type: TYPE_NORMAL
- en: Radio – A `Transmitter` and `Receiver`. Write a set of traits, where `A` is
    modelled as inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to this should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Self-Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Scale-trait, you can sometimes see the self-types annotation, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the `identifier => {typeName}` prefix, which is usually a self-type
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: If the type is specified, that trait can only be mixed-in to this type. For
    example, `VanillaTrait` can only be mixed in with Drink. If we try to mix this
    with another object, we will receive an error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `Flavor` is not extended from `Drink`, but has access to `Drink` methods
    such as looks, as in `Flavor,` we situate it inside Drink.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, self-annotation can be used without specifying a type. This can be useful
    for nested traits when we want to call "this" of an enclosing trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, we can see the organization of some big classes as a set of traits,
    grouped around one 'base'. We can visualize this as 'Cake', which consists of
    the 'Pieces:' self-annotated trait. We can change one piece to another by changing
    the mix-in traits. Such an organization of code is named the 'Cake pattern'. Note
    that using the Cake pattern is often controversial, because it's relative easy
    to create a 'God object'. Also note that the refactor class hierarchy with the
    cake-pattern inside is harder to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an instance of Drink with Tee with `VanillaFlavour` which refers to
    `description`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to override the description in the `Tee` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Uncomment `Tee`: `def description = plain tee` in the `Drinks` file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check if any error message arises.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the third object, derived from `Drink` with `Tee` and `VanillaFlavour`
    with an overloaded description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also note that special syntax for methods exists, which must be ''mixed'' after
    the overriding method, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that the methods marked as `abstract override` can call `super`
    methods, which are actually defined in traits, not in this base class. This is
    a relatively rare technique.
  prefs: []
  type: TYPE_NORMAL
- en: Special Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few classes with special syntax, which play a significant role
    in the Scala type system. We will cover this in detail later, but now let''s just
    enumerate some:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions**: In Scala, this can be coded as `A => B`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuples**: In Scala, this can be coded as `(A,B), (A,B,C)` … and so on, which
    is a syntax sugar for `Tuple2[A,B]`, `Tuple3[A,B,C],` and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OO in Our Chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know the theoretical basics, let's look at these facilities and
    how they are used in our program. Let's open `Lesson 2/3-project` in our IDE and
    extend our chatbot, which was developed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling Logic and Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, we must decouple the environment and logic, and integrate only one
    in the `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the `EffectsProvider` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we encapsulate all of the effects into our traits, which can have different
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s look at `UserOutput`:'
  prefs: []
  type: TYPE_NORMAL
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the trait and object, which implement the current trait. This
    way, when we need to accept commands that are not from standard input, but from
    the chatbot API or from Twitter, we only need to change the implementation of
    the `UserOutput`/ `ConsoleOutput` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to implement `ConsoleOutput` and `DefaultTimeProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: Replace `???` in main with the appropriative constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps for implementing `ConsoleOutput` and `DefaultTimeProvider` are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that `Lesson 2/3-project` is open in IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `UserOutput` file, find the `ConsoleOutput` file and change `???` to
    the body of the `write` method. The resulting method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `TimeProvider` file, add the `DefaultTimeProvide` object which extends
    from `TimeProvider` and implements the `currentTime` and `currentDate` functions.
    The resulting code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sealed Traits and Algebraic Datatypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s deal with the second issue—let''s encapsulate the logic of chatbot modes
    into the trait, which will only deal with logic and nothing else. Look at the
    following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, let''s ignore `or` and `otherwise` combinators and look at the `process`
    method. It accepts input messages and effects and returns the processing result,
    which can be a failure or message sent to a user with the next state of the mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see a new modifier: `sealed`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a trait (or class) is sealed, it can only be extended in the same file,
    where it is defined. Due to this, you can be sure that, in your family of classes,
    nobody will be able to add a new class to somewhere in your project. If you do
    use case analysis with the help of the match/case expression, a compiler can do
    exhaustive checking: all of the variants are present.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructions from a family of case classes/objects, extended from a `sealed`
    trait, is often named an Algebraic Data Type (ADT).
  prefs: []
  type: TYPE_NORMAL
- en: 'This term comes to us from the HOPE language (1972, Edinburg University), where
    all types can be created from an initial set of types with the help of algebraic
    operations: among them was a named `product` (which looks like a case class in
    Scala) and `distinct union` (modeled by the sealed trait with subtyping).'
  prefs: []
  type: TYPE_NORMAL
- en: Using ADT in domain modeling is rewarding because we can do evident case analysis
    for the domain model and have no weak abstraction; we can implement various designs
    which can be added to our model in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our `ChatbotMode`.
  prefs: []
  type: TYPE_NORMAL
- en: On `bye`, we must exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is easy—just define the appropriative object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll look at creating the same modes for the `CurrentTime` query.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for this exercise can be found in `Lesson 2/3-project`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in the `CurrentTime` modes package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one to the chain of modes in `Main` (for example, the Modify definition
    of `createInitMode`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that `test`, which checks the time functionality, is passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to make a bigger mode from a few simpler modes. Let''s look
    at the mode, which extends two modes and can select a mode which is able to process
    incoming messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, if `frs` can process a message, then the result of processing this is
    returned. It will contain an answer. `NextMode` (which will accept the next sequence)
    is the same `or` with `nextMode` from `frs,` processing the result and `snd`.
  prefs: []
  type: TYPE_NORMAL
- en: If `frs` can't answer this, then we try `snd`. If `snd's` processing is successful,
    then, in the next dialog step, the first message processor will be a `nextStep`,
    received from `snd`. This allows modes to form their own context of the dialog,
    like a person who understands your language. This will be the first thing you
    will ask next time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can chain simple modes into complex ones with the help of such combinators.
    Scala allows us to use fancy syntax for chains: any method with one parameter
    can be used as a binary operator. So, if we define the `or` method in `ChatbotMode`,
    we will be able to combine our modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And later in `main`, we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`Otherwise` looks very similar, with one difference: the second mode must always
    be second.'
  prefs: []
  type: TYPE_NORMAL
- en: When we write one, it looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make this a little better: let''s move first the interaction (where
    the program asks the user for their name) to mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll move the frst interaction to mode.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will make `mode`, which remembers your name and can make one for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new object, which implements the `chatbot` trait and when running
    the first words, `my name is`, accepts a name and answers `hi`, and then tells
    you your name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add this object to the sequence of nodes in `main:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a test with this functionality to testcase. Notice the usage of custom
    effects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Function Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll look at how function calls are implemented in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax Goodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scala provides flexible syntax and it is worth dedicating a few minutes to this
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: Named Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a function, `f(a:Int, b:Int)`. We can call this function using
    the named parameter syntax: `f(a = 5, b=10)`. If we swap the parameters but leave
    the correct names, the method will still be correct.'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to combine positional and named function calls—the first few
    arguments can be positional.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Default Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When specifying a function, we can set default parameters. Then, later, when
    we call this function, we can omit parameters and the compiler will substitute
    defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to create a comfortable API with the help of the combination
    of named and default arguments. For example, for case classes with N components,
    the compiler generates a copy method with N arguments; all of them have defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's transform code in the `Or` and `Otherwise` combinators to use the
    `copy` method instead of the `Processed` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Change the case expression to type, checking `(processed:Processed)` or adding
    the `bind` variable to the case class pattern (`processed@Processed(… )`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case body, use the `copy` method instead of the `Processed` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting code should be as per the following cases:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the student uses type check in the case expression:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'If the student uses bind variable:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Do the same transformation for the second match statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The full code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Currying Forms (Multiple Argument Lists)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currying is a term used for describing the transformation of a function with
    multiple arguments into a function with one argument. We will describe this process
    in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is vital for syntax that we can use multiple argument lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, `f2` is in its curried form. It has the same semantics as `f1`, but can
    be called with a different syntax. This is useful when you need visually separate
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Special Magic Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table shows the various magic methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| x.apply(y,z) | x(y,z) |   |'
  prefs: []
  type: TYPE_TB
- en: '| x.update(y,z) | x(y)=z |   |'
  prefs: []
  type: TYPE_TB
- en: '| x.y_=(z) | x.y=z | Method y must be also defined. |'
  prefs: []
  type: TYPE_TB
- en: '| x.unary- | -x | The same for +, ~, ! |'
  prefs: []
  type: TYPE_TB
- en: '| x = x + y | x += y | The same for -,*,/,&#124;,& |'
  prefs: []
  type: TYPE_TB
- en: Implementing + in CartesianPoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the previous project from `Lesson2` and implement `+` in `CartesianPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: In your IDE, open the previous project (4-project, named `coordinates`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `CartesianPoint.scala` file, add the `+` method with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Parameter-Passing Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will learn the types of parameters which are in passing
    mode: `by value`, `by name,` and `by need`.'
  prefs: []
  type: TYPE_NORMAL
- en: By Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In previous chapters, we used default the parameters of passing mode: `by value`,
    which is the default in most programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this model, the function call expression is evaluated in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: First, all arguments are evaluated from left to right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the function is called, and parameters are referred to as evaluated arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sometimes, we hear about Java parameter mode, where values are passed `by value`,
    and references are `by reference` (for example, if we pass `reference` to an object
    as a `value`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By Name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The essence of the `by name` parameter passing mode is that arguments are not
    evaluated before the function call, but every time the name of the parameter is
    used in the target function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The name term comes to us from Algol68: passing parameters by name was described
    as a substitution of name by the parameter body. This was a challenge for compiler
    writers for many years.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By name parameters can be used for defining control-flow expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that constructor parameters can also be passed by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: By Need
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`By` `need` evaluates the parameter once, only if it is necessary. This can
    be emulated with the by name call and lazy val:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We see the lazy modifier for val. A lazy value is evaluated at the time of the
    first usage and then stored in memory as a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lazy values can be components of traits, classes, and objects: this is this
    usual way to define lazy initialization.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Runnable Construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a runnable construction, with the same syntax as `Scalatest FunSuite`,
    and `executor`, which will return `true`, if the code inside the `test` argument
    was evaluated without exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the parent class with variables where the code will be captured. One
    possible example is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function with the name and by-name parameter, which will fill this
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define `executor` method, which uses named parameter inside try/catch block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Printing the log Argument to the Console and File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a `log` statement, which prints arguments to the console and to
    file, but only if the parameter with the name enabled in the logger constructor
    is set to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `logger` with the parameter and class. The signature must be something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the method with the by-need parameter, which is only used when the logger
    is enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's make `mode` command, which understands the `store name` definition and
    `remind` definition.
  prefs: []
  type: TYPE_NORMAL
- en: Define a new object which implements the `ChatbotMode` trait and has a data
    structure (a sealed trait which forms a linked list) as a state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the processing `store,` modify the state and answer `ok.` On processing,
    `remind` – answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add test to `testcase.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now reached the end of this chapter. In this chapter, we covered the
    object-oriented aspects of Scala such as classes, objects, pattern matching, self-types,
    case classes, and so on. We also implemented object-oriented concepts that we
    learned in our chatbot application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover functional programming with Scala and how
    object-oriented and functional approaches complete each other. We will also cover
    generic classes, which are often used with pattern matching. We will also cover
    how to create user-defined pattern matching and why is it useful.
  prefs: []
  type: TYPE_NORMAL
