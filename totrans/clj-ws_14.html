<html><head></head><body>
		<div>
			<div id="_idContainer277" class="Content">
			</div>
		</div>
		<div id="_idContainer278" class="Content">
			<h1 id="_idParaDest-312"><a id="_idTextAnchor411"/>14. HTTP with Ring</h1>
		</div>
		<div id="_idContainer300" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will process requests and generate responses, route incoming requests and manipulate requests via middleware. We will also serve up responses using various content types including <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) and <strong class="bold">Extensible Data Notation</strong> (<strong class="bold">EDN</strong>), create a web application using Ring and Compojure, and serve static resources via HTTP. </p>
			<p class="callout">By the end of this chapter, you will be able to expose CRUD operations via HTTP.</p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor412"/>Introduction</h1>
			<p>In the last chapter, we built our application layer and interacted with it via the REPL. This works sufficiently well for a single user performing ad hoc interactions, but it does not scale. Indeed, we could imagine a scenario where a third party or even another of our own services wants to make use of the data stored in our database, perform calculations, and persist updates. This interaction would be programmatic and would, therefore, benefit from being exposed over <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) or similar.</p>
			<p>We can achieve this by exposing our application layer via a web service. A web service allows interaction with our application layer over a network (most typically the internet, although it could be over an intranet for private applications).</p>
			<p>To build our web service, we'll need a web application library to build our API, a web server to serve it up over HTTP, and a routing library to route incoming requests to the appropriate handler. Clojure has numerous implementations of each; however, for this chapter, we'll focus on using <strong class="bold">Ring</strong> to build our application, <strong class="source-inline">Compojure</strong> for routing, and Jetty to serve it all up.</p>
			<p>An extension to this chapter could involve you taking the examples and exercises provided and implementing them using an alternative web app library, such as <strong class="source-inline">Pedestal</strong>.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor413"/>HTTP, Web Servers, and REST</h1>
			<p>Before we dive into building a web service, let's cover the basics. HTTP is one of the primary protocols for communicating across the internet, particularly when working in a web browser. This protocol provides a contract for a client (typically a web browser) to communicate with a (web) server. In this example, the browser will construct a request containing a Uniform Resource Identifier (URI), which it will use to communicate to the server. The server will interpret the request, using the URI string to determine which resource the client is interested in retrieving/manipulating, then constructing a response containing information indicating that the request has completed, or containing a payload in the form of the response body.</p>
			<p>Typically, when building a web service, we want to conform to the <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) architecture. This architecture prescribes a set of operations we can choose to perform against a resource, allowing us to transition that resource through a number of valid states.</p>
			<p>For example, let's assume we're interacting with our profile on our favorite online retailer's website. First, we'll retrieve our profile, then perhaps we'll retrieve our current address. We'll make a change to this address, then save our changes. In terms of REST interactions over HTTP, this may look as follows:</p>
			<ul>
				<li>GET <a href="https://packt.live/30NL9hm">https://packt.live/30NL9hm</a></li>
				<li>GET <a href="https://packt.live/2U026Ur">https://packt.live/2U026Ur</a></li>
				<li>PUT <a href="https://packt.live/2U026Ur">https://packt.live/2U026Ur</a></li>
			</ul>
			<p><strong class="source-inline">123</strong> in the preceding example is our unique user ID.</p>
			<p>The GET/PUT method preceding the URI is known as the HTTP method. GET indicates that we wish to read the content associated with the resource in the URI provided. The PUT method has an associated body containing the updated address; we're instructing the server to create/update the address resource with that provided.</p>
			<p>An important distinction to make between PUT and POST is that PUT should be used when updating an existing resource or when we happen to know the unique ID of the entity we're creating. POST is used solely for the creation of resources and does not require us to know its unique ID. Instead, this ID will be allocated by the web service itself and communicated back to the client via the response headers.</p>
			<p>The full set of supported methods are GET, POST, PUT, DELETE, HEAD, PATCH, CONNECT, OPTIONS, and TRACE. The first four of which are most typically encountered.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor414"/>Request and Response</h2>
			<p>For those completely new to building web services, we will be covering a number of new concepts. These are not necessarily complex subjects, but sufficient detail to understand each of the building blocks will be given. As mentioned previously, we will use Ring (Clojure's most widely used web application library) to build our web service. A Ring application consists of only four components: requests, handlers, responses, and middleware.</p>
			<p>We understand the concept of a request and response; we'll now cover them in detail, including how to parse the former and how to construct the latter, as well as the form that each typically takes.</p>
			<p>In the most simple terms, the function of our web service should be to take an incoming request represented as a map, perform some operations based on the content of that map (for example, fetch a user's profile or update their address), and produce an appropriate response map ready to be rendered by a browser or interpreted by the client more generally. In Ring, the function that performs this conversion of a request to a response is referred to as a handler.</p>
			<p>The most basic operation would follow this process:</p>
			<div>
				<div id="_idContainer279" class="IMG---Figure">
					<img src="image/B14502_14_01.jpg" alt="Figure 14.1: Representation of the request-response process&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1: Representation of the request-response process</p>
			<p>A Ring handler is, therefore, a single-arity function, accepting a <strong class="source-inline">request</strong> map, and returning a <strong class="source-inline">response</strong> map:</p>
			<p class="source-code">(defn handler [request]</p>
			<p class="source-code">  ..</p>
			<p class="source-code">&lt;response-map&gt;)</p>
			<p>What does a <strong class="source-inline">request</strong> map look like? At a minimum, a <strong class="source-inline">request</strong> map will contain the following top-level keys (sample values included):</p>
			<p class="source-code">{:remote-addr "0:0:0:0:0:0:0:1",</p>
			<p class="source-code"> :headers {"user-agent" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36",</p>
			<p class="source-code">           "cookie" "phaseInterval=120000; previewCols=url%20status%20size%20timeline; stats=true",</p>
			<p class="source-code">           "connection" "keep-alive",</p>
			<p class="source-code">           "accept" "text/html,application/xhtml+xml"},</p>
			<p class="source-code"> :server-port 8080,</p>
			<p class="source-code"> :uri "/request-demo",</p>
			<p class="source-code"> :server-name "localhost",</p>
			<p class="source-code"> :query-string nil,</p>
			<p class="source-code"> :body #object[org.eclipse.jetty.server.HttpInputOverHTTP 0x4a7d22dd "HttpInputOverHTTP@4a7d22dd[c=0,q=0,[0]=null,s=STREAM]"],</p>
			<p class="source-code"> :scheme :http,</p>
			<p class="source-code"> :request-method :get}</p>
			<p>Here's the meaning of each attribute:</p>
			<ul>
				<li><strong class="source-inline">:remote-addr</strong>: The calling client's IP address</li>
				<li><strong class="source-inline">:headers</strong>: Additional information sent along with the request, relating to security, content negotiation, cookies, and so on</li>
				<li><strong class="source-inline">:server-port</strong>: The port of the server servicing the request</li>
				<li><strong class="source-inline">:uri</strong>: The URI pointing to the resource the client wishes to interact with (used in routing)</li>
				<li><strong class="source-inline">:query-string</strong>: A string that can be used to filter the resource content returned</li>
				<li><strong class="source-inline">:body</strong>: A stream containing an optional payload (can only be read once!)</li>
				<li><strong class="source-inline">:request-method</strong>: An HTTP request method (used in routing)</li>
			</ul>
			<p>An important point worth highlighting is that this list is <em class="italic">not exhaustive</em>. Third-party and custom middleware can often add their own keys with their own special meaning and uses.</p>
			<p>At the point at which our handler is invoked, the <strong class="source-inline">request</strong> map contains only a couple of keys of interest: the <strong class="source-inline">query-string</strong> and the <strong class="source-inline">body</strong>. The remaining keys have already been inspected and used to route the request to the appropriate handler, for example.</p>
			<p><strong class="source-inline">Response</strong> maps are much simpler and will consist of only three keys: status, headers, and body. The <strong class="source-inline">status</strong> key is a three-digit number indicating the outcome of the request. There are a large number of these, grouped into five different categories:</p>
			<ul>
				<li>1xx: Informational</li>
				<li>2xx: Success</li>
				<li>3xx: Redirect</li>
				<li>4xx: Client Error</li>
				<li>5xx: Server Error</li>
			</ul>
			<p>Generally, we'll encounter a <strong class="source-inline">200</strong> status indicating <strong class="source-inline">OK</strong>, or perhaps a <strong class="source-inline">404</strong> "<strong class="source-inline">Not Found</strong>" or <strong class="source-inline">500</strong> "<strong class="source-inline">Internal Server Error</strong>" error message.</p>
			<p>The headers provide additional information about the generated response – most commonly, how to interpret the body. The body (sometimes called the payload) will contain any data retrieved or generated that will be of interest to the client.</p>
			<p>We can easily construct this response map manually, as we'll see in <em class="italic">Exercise 14.01</em>, <em class="italic">Creating a Hello World Web Application.</em></p>
			<p>We've now encountered three of the four Ring components (with middleware being more complex and covered separately).</p>
			<p>Jetty is the web server that will serve up our Ring application. It is software that allows interaction with our application over a network, in the same way your favorite websites are made available over the internet.</p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor415"/>Exercise 14.01: Creating a Hello World Web Application</h2>
			<p>This exercise will see us make use of Ring and Jetty, where we'll create a trivial web application with a static <strong class="source-inline">Hello World</strong> response:</p>
			<ol>
				<li>Begin with the following dependencies in <strong class="source-inline">deps.edn</strong> or similar:<p class="source-code">{:deps {ring/ring-core {:mvn/version "1.7.1"}</p><p class="source-code">        ring/ring-jetty-adapter {:mvn/version "1.7.1"}}}</p></li>
				<li>Now define our Ring handler, remembering it's a single-arity function accepting a <strong class="source-inline">request</strong> map and returning a <strong class="source-inline">response</strong> map. Our <strong class="source-inline">response</strong> map contains an <strong class="source-inline">ok</strong> <strong class="source-inline">200</strong> status code and a string response in the <strong class="source-inline">body</strong>:<p class="source-code">user=&gt; (defn handler [request]</p><p class="source-code">  {:status 200</p><p class="source-code">   :body "Hello World"})</p><p class="source-code">=&gt;#'user/handler</p></li>
				<li>Now we'll start a Jetty web server, passing our handler and a couple of options:<p class="source-code">user=&gt; (require '[ring.adapter.jetty :refer [run-jetty]])</p><p class="source-code">=&gt; nil</p><p class="source-code">user=&gt; (def app (run-jetty handler {:port 8080</p><p class="source-code">                      :join? false}))</p><p class="source-code">=&gt;#'user/app</p><p>By default, Jetty will spin up on port 80; we've overridden that to use <strong class="source-inline">8080</strong>. Notice that we've also passed :join? false. This ensures that our web server will not block the current thread that the REPL is running on, meaning we can interact with it and perform other REPL-based operations in the meantime. We now have a web server running, exposing our single handler over HTTP.</p><p class="callout-heading">Note</p><p class="callout">We can stop the currently running server using Java interop:</p><p class="callout"><strong class="source-inline">user=&gt; (.stop app)</strong></p><p class="callout"><strong class="source-inline">=&gt; nil</strong></p><p class="callout">If, at any point, an error such as <strong class="source-inline">Address already in use</strong> is encountered, be sure to stop your existing app before starting a new one.</p><p>This will prove useful going forward as we make changes to our application and test them out in the browser. If you have stopped the app, be sure to restart it by rerunning <em class="italic">Step 3</em> before proceeding.</p></li>
				<li>Navigate to localhost:8080 in a browser:<div id="_idContainer280" class="IMG---Figure"><img src="image/B14502_14_02.jpg" alt="Figure 14.2: Printing Hello Word in a browser&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.2: Printing Hello Word in a browser</p>
			<p>Success! We have created our first handler and our web server is up and running with only a few lines of code. Be sure to stop our running app. </p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor416"/>Request Routing</h2>
			<p>In the previous example, notice that run-jetty only accepts a single handler. We'll more than likely want our service to provide the ability to store, view, and otherwise manipulate numerous resources. For this, we'll need to support an arbitrary number of handlers to cater to each of our resources, plus a means of finding the correct handler to service our request. This is where request routing comes in.</p>
			<p>Revisiting the request object, we find that it contains (among other things) the following keys:</p>
			<ul>
				<li>URI</li>
				<li>Request-method</li>
			</ul>
			<p>We could enhance our handler to inspect the incoming request, extract the content of those keys, then determine the appropriate function to call to satisfy the request and generate a response. We'd probably call this handler our dispatcher or router. As we consider this approach, we should recall the chapter introduction where we mentioned Compojure, which bills itself as a small routing library for Ring that allows web applications to be composed of small, independent parts. </p>
			<p>That's exactly what we're looking for. We'll now learn how to make use of <strong class="source-inline">Compojure</strong> to perform request routing and expand our application a little further.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor417"/>Using Compojure</h2>
			<p>If routing requests manually sounded fairly tedious, breathe a sigh of relief as Compojure takes all the strain out of request routing. We define pairs of HTTP methods and resource paths we want to match and Compojure takes care of the rest.</p>
			<p>A trivial route method is defined as follows, using the GET macro from the compojure.core namespace:</p>
			<p class="source-code">(def route </p>
			<p class="source-code">  (GET "/hello" request "Hello World"))</p>
			<p>GET (and all other HTTP method macros) expect a path representing the resource we want to match against. In the preceding example, we match the hello path at the root of the web service. Compojure gives us a great deal of control over the path, allowing us to expect path parameters or match using a regular expression if we need to.</p>
			<p>The next argument to the macro actually binds the incoming request map (or parts thereof) to the local symbol(s) we specify. In the preceding example, the entire incoming request map has been bound to the <strong class="source-inline">request</strong> symbol. We can choose to destructure elements of the map if we so wish.</p>
			<p>The final argument to the macro is the body of our route. Here, we can add any logic we require, with the final expression being returned as the response. In this case, we simply return the string Hello world. Compojure will interpret a plain string as an implicit 200 response (that is, success) meaning we don't need to construct a map with an explicit :status key as we did in <em class="italic">Exercise 14.01</em>, <em class="italic">Creating a Hello World Web Application</em>.</p>
			<p>Now we're likely to have more than a single route in our application, but Jetty only accepts a single handler. We can now reach for the <strong class="source-inline">routes</strong> function or the defroutes macro provided by Compojure; either of these can be used to combine one or more routes into a single handler. Using the macro, we bring our routes together, binding them to the <strong class="source-inline">routes</strong> variable, which we can then pass to Jetty:</p>
			<p class="source-code">(defroutes routes</p>
			<p class="source-code">           &lt;route-1&gt;</p>
			<p class="source-code">           &lt;route-2&gt;</p>
			<p class="source-code">           ..)</p>
			<p>What if a user navigates to a route that we have not defined? When we define the routes and their unique paths, we're asking the routing library to inspect the incoming request and attempt to match it to each of our routes in turn. If this list of routes is exhausted before finding a match, an exception is thrown. In a browser, we'll receive the following (not particularly useful!) error message:</p>
			<div>
				<div id="_idContainer281" class="IMG---Figure">
					<img src="image/B14502_14_03.jpg" alt="Figure 14.3: Page not working error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3: Page not working error</p>
			<p>We can avoid this by providing a catch-all, ensuring this is the <em class="italic">last</em> route defined. Compojure offers us a not-found route, which we can incorporate into our routes definition. It allows us to gracefully handle a request for a resource we cannot find a match for. The inclusion of this <strong class="source-inline">not-found</strong> route would look as follows:</p>
			<p class="source-code">(require '[compojure.route :as route])</p>
			<p class="source-code">(defroutes routes</p>
			<p class="source-code">           &lt;route-1&gt;</p>
			<p class="source-code">           &lt;route-2&gt;</p>
			<p class="source-code">            (route/not-found "Not the route you are looking for"))</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor418"/>Exercise 14.02: Introducing Routing with Compojure</h2>
			<p>Let's begin by tweaking our <strong class="source-inline">Hello World</strong> application by replacing the handler with a Compojure route definition:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">compojure</strong> dependency:<p class="source-code">{:deps {compojure {:mvn/version "1.6.1"}</p><p class="source-code">        ring/ring-core {:mvn/version "1.7.1"}</p><p class="source-code">        ring/ring-jetty-adapter {:mvn/version "1.7.1"}}</p></li>
				<li>Taking our original hello world handler, we'll convert this to the <strong class="source-inline">compojure</strong> route definition format using the <strong class="source-inline">GET</strong> macro from <strong class="source-inline">compojure.core</strong>:<p class="source-code">(defn handler [request]</p><p class="source-code">  {:status 200</p><p class="source-code">   :body "Hello World"})</p><p>This will look as follows if we use Compojure:</p><p class="source-code">(require '[compojure.core :refer [GET]])</p><p class="source-code">(def route </p><p class="source-code">  (GET "/" request "Hello World"))</p></li>
				<li>Replace <strong class="source-inline">handler</strong> with <strong class="source-inline">route</strong> in our call to <strong class="source-inline">run-jetty</strong>, start the app (stopping any existing apps first!), and point your browser to <strong class="source-inline">localhost:8080</strong> once again:<p class="source-code">(require '[ring.adapter.jetty :refer [run-jetty]])</p><p class="source-code">(defn run</p><p class="source-code">  []</p><p class="source-code">  (run-jetty route</p><p class="source-code">             {:port  8080</p><p class="source-code">              :join? false}))</p><p class="source-code">(.stop app)</p><p class="source-code">(def app (run))</p><p>The output is as follows:</p><div id="_idContainer282" class="IMG---Figure"><img src="image/B14502_14_04.jpg" alt="Figure 14.4: Printing the output to the browser&#13;&#10;"/></div><p class="figure-caption">Figure 14.4: Printing the output to the browser</p><p>There will be no material change; however, we have paved the way for rolling out Compojure and supporting an arbitrary number of routes in our application.</p></li>
				<li>Let's define multiple routes, combining them under a single handler to exercise Compojure's routing ability:<p class="source-code">(require '[compojure.core :refer [defroutes]])</p><p class="source-code">(defroutes routes</p><p class="source-code">           (GET "/route-1" request "Hello from route-1")</p><p class="source-code">           (GET "/route-2" request "Hello from route-2"))</p></li>
				<li>Pass these routes to our <strong class="source-inline">run-jetty</strong> call:<p class="source-code">(defn run</p><p class="source-code">  []</p><p class="source-code">  (run-jetty routes {:port  8080</p><p class="source-code">                  :join? false}))</p><p class="source-code">(.stop app)</p><p class="source-code">(def app (run))</p><p>We can now navigate to each of our routes in turn via the browser. Browse to our first route, <strong class="source-inline">http://localhost:8080/route-1</strong>:</p><div id="_idContainer283" class="IMG---Figure"><img src="image/B14502_14_05.jpg" alt="Figure 14.5: Browsing to the first route&#13;&#10;"/></div><p class="figure-caption">Figure 14.5: Browsing to the first route</p><p>Browse to our second route, <strong class="source-inline">http://localhost:8080/route-2</strong>:</p><p>  </p><div id="_idContainer284" class="IMG---Figure"><img src="image/B14502_14_06.jpg" alt="Figure 14.6: Browsing to the second route&#13;&#10;"/></div><p class="figure-caption">Figure 14.6: Browsing to the second route</p></li>
				<li>While we're here, let's attempt to navigate to a non-existent route, <strong class="source-inline">localhost:8080/nothing-to-see-here</strong>. Your browser should inform you of localhost's inability to service this request, possibly indicating a <strong class="source-inline">500</strong> error:<div id="_idContainer285" class="IMG---Figure"><img src="image/B14502_14_07.jpg" alt="Figure: 14.7: Browsing to a non-existent route&#13;&#10;"/></div><p class="figure-caption">Figure: 14.7: Browsing to a non-existent route</p></li>
				<li>Recalling our discussion of Compojure's <strong class="source-inline">not-found</strong> route definition, let's introduce that as a fallback for cases where no other route matches our request:<p class="source-code">user=&gt; (require '[compojure.route :as route])</p><p class="source-code">nil</p><p class="source-code">user=&gt; (defroutes routes</p><p class="source-code">           (GET "/route-1" request "Hello from route-1")</p><p class="source-code">           (GET "/route-2" request "Hello from route-2")</p><p class="source-code">           (route/not-found "Not the route you are looking for"))</p><p class="source-code">=&gt; #'user/routes</p></li>
				<li>Restarting our web server and again browsing to <strong class="source-inline">http://localhost:8080/nothing-to-see-here</strong>, we now receive a much friendlier message:<div id="_idContainer286" class="IMG---Figure"><img src="image/B14502_14_08.jpg" alt="Figure 14.8: Navigating to nothing-to-see-here again&#13;&#10;"/></div><p class="figure-caption">Figure 14.8: Navigating to nothing-to-see-here again</p></li>
				<li>Finally, let's (temporarily) move our <strong class="source-inline">not-found</strong> route to the beginning of our routes definition, restart the app, and browse to <strong class="source-inline">http://localhost:8080/route-1</strong>:<p class="source-code">(defroutes routes</p><p class="source-code">           (route/not-found "Not the route you are looking for")</p><p class="source-code">           (GET "/route-1" request "Hello from route-1")</p><p class="source-code">           (GET "/route-2" request "Hello from route-2"))</p><p>The output is as follows:</p><div id="_idContainer287" class="IMG---Figure"><img src="image/B14502_14_09.jpg" alt="Figure 14.9: Navigating to route-1&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.9: Navigating to route-1</p>
			<p>This demonstrates the care required when defining and combining multiple routes. The web server will serve up the response for the <em class="italic">first</em> matching route it encounters. We can think of this as a simple order of precedence, with routes earlier in the definition being preferred over those following.</p>
			<p>Excellent – we now understand how to define a route using Compojure, combine it with other Compojure route definitions, and provide a sensible not-found message in the event that someone navigates to a non-existent resource.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor419"/>Response Formats and Middleware</h2>
			<p>The preceding trivial route definitions have all returned a string as the response body, which is perfectly acceptable for a human interacting with our service via a web browser. When we start to have other web services or a frontend interacting with our service, we may well have to serve up alternative response formats. A JavaScript frontend is likely to want a JSON response, whereas a ClojureScript frontend would likely prefer EDN. EDN is a data format favored in the Clojure ecosystem; indeed, Clojure itself is written in this format, meaning you will already be familiar with it by this stage!</p>
			<p>The client can indicate which formats it accepts by providing an accept header as part of the request. The <strong class="source-inline">accept</strong> header takes the form of a string describing the <strong class="bold">Multipurpose Internet Mail Extensions</strong> (<strong class="bold">MIME</strong>) type, which the client is interested in receiving. A couple of examples of MIME types that we'll use are <strong class="source-inline">application/json</strong> and <strong class="source-inline">application/edn</strong>. The server can inspect this header and render the response in accordance with the formats accepted by the client. The server will assist the client by returning a <strong class="source-inline">content-type</strong> header in the response indicating which format it has selected.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The client is in no way obligated to return data in the format requested but should do so if it is able.</p>
			<p>Intuitively, we may be tempted to inspect the accept header manually within each of our routes and encode the response before we return it. While this would work, it would introduce a great deal of duplicative code into our application and distract from the core work of the route itself.  For example, we may have a <strong class="source-inline">render-response</strong> function that determines which format to render based on the <strong class="source-inline">accept</strong> header. We would be obligated to include this call in every one of our routes. Much more preferable would be the ability to define this once and have it applied across all of our routes.</p>
			<p>This is where the concept of middleware comes in. In simple terms, middleware is a function that wraps our route, allowing us to execute code before and/or after generating our response.</p>
			<p>A middleware function for a synchronous response (that is, where the client will wait for the response using the same connection) typically takes the following format:</p>
			<p class="source-code">(defn custom-middleware</p>
			<p class="source-code">  [handler]</p>
			<p class="source-code">  (fn [request]</p>
			<p class="source-code">    (-&gt;&gt; request</p>
			<p class="source-code">         ;; manipulate request before</p>
			<p class="source-code">         handler</p>
			<p class="source-code">         ;; manipulate response after</p>
			<p class="source-code">         )))</p>
			<p>In essence, it is a function that accepts a handler, then returns a new function that calls the original handler. Besides that requirement, it is free to manipulate the request before passing it to the handler call, or it could manipulate the response generated by calling the handler, or both.</p>
			<p>It should now be obvious that we could define a piece of middleware to handle the response rendering. Before we do that, let's take a look at <strong class="source-inline">muuntaja</strong>, which has been written specifically with this task in mind. Indeed, it supports JSON and EDN out of the box simply by wrapping our handler in a call to <strong class="source-inline">muuntaja.middleware/wrap-format</strong>. For example, the following tweak to our <strong class="source-inline">run</strong> function would automatically negotiate the incoming request body and outgoing response body formatting:</p>
			<p class="source-code">(require '[muuntaja.middleware :as middleware])</p>
			<p class="source-code">(defn run</p>
			<p class="source-code">  []</p>
			<p class="source-code">  (run-jetty</p>
			<p class="source-code">    (middleware/wrap-format routes)</p>
			<p class="source-code">    {:port  8080</p>
			<p class="source-code">     :join? false}))</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor420"/>Exercise 14.03: Response Rendering with Muuntaja</h2>
			<p>In this exercise, we'll cover middleware and how it can be used to render a response by taking the <strong class="source-inline">accept</strong> header into consideration. Our goal is to respect the <strong class="source-inline">accept</strong> header provided by the caller such that we can return JSON, EDN, or a plain string as required. We'll also look at how to interact with our route using <strong class="source-inline">curl</strong>, a popular tool used to make calls to web services.</p>
			<p>By leveraging <strong class="source-inline">muuntaja middleware</strong>, our route code can remain completely agnostic of the response format requested by the client:</p>
			<ol>
				<li value="1">We'll begin by introducing the muuntaja dependency and requiring it:<p class="source-code">{:deps {compojure {:mvn/version "1.6.1"}</p><p class="source-code">metosin/muuntaja {:mvn/version "0.6.4"}</p><p class="source-code">        ring/ring-core {:mvn/version "1.7.1"}</p><p class="source-code">        ring/ring-j<a id="_idTextAnchor421"/>etty-adapter {:mvn/version "1.7.1"}}</p><p class="source-code">user=&gt; <strong class="bold">(require '[muuntaja.middleware :as middleware])</strong></p><p class="source-code">=&gt;nil</p></li>
				<li>Now let's define a new set of routes, one of which returns a string, and another returning a nested data structure that can vary depending on the value of the <strong class="source-inline">accept</strong> header passed by the client:<p class="source-code">(defroutes routes</p><p class="source-code">           (GET "/string" request "a simple string response")</p><p class="source-code">           (GET "/data-structure" request</p><p class="source-code">             {:body {:a 1</p><p class="source-code">                     :b #{2 3 4}</p><p class="source-code">                     :c "nested data structure"}})</p><p class="source-code">           (route/not-found "Not found"))</p><p class="callout-heading">Note</p><p class="callout">Out of the box, Compojure does not know how to render a map, regardless of whether an accept header is specified.</p><p>Of interest will be how the middleware handles the keywords and sets depending on the response format we're interested in.</p></li>
				<li>Recall that middleware wraps a handler; therefore, introducing <strong class="source-inline">wrap-format</strong> middleware of muuntaja is as simple as altering our <strong class="source-inline">run</strong> function like so:<p class="source-code">(defn run</p><p class="source-code">  []</p><p class="source-code">  (run-jetty</p><p class="source-code">    (middleware/wrap-format routes)</p><p class="source-code">    {:port 8080</p><p class="source-code">     :join? false}))</p></li>
				<li>Now restart our app and request our <strong class="source-inline">string</strong> resource by expressing no preference for the response format, then stipulating we'd prefer <strong class="source-inline">application/edn</strong>. We're using <strong class="source-inline">curl</strong> here via Terminal or Command Prompt depending on your operating system:<p class="source-code">$ curl -i http://localhost:8080/string</p><p>The output is as follows:</p><div id="_idContainer288" class="IMG---Figure"><img src="image/B14502_14_10.jpg" alt="Figure 14.10: Printing the output of the curl command&#13;&#10;"/></div><p class="figure-caption">Figure 14.10: Printing the output of the curl command</p><p>Now, try the following:</p><p class="source-code">$ curl -i -H "accept: application/edn" http://localhost:8080/string</p><p>The output is as follows:</p><div id="_idContainer289" class="IMG---Figure"><img src="image/B14502_14_11.jpg" alt="Figure 14.11: Printing the output of the curl command&#13;&#10;"/></div><p class="figure-caption">Figure 14.11: Printing the output of the curl command</p><p>Notice the response format is identical in both cases, which can be confirmed by checking the preceding <strong class="source-inline">content-type</strong> header. This shows that our server is unable to render the response as <strong class="source-inline">EDN</strong> and has chosen to ignore the <strong class="source-inline">accept</strong> header directive.</p></li>
				<li>Our <strong class="source-inline">data-structure</strong> route is a little more interesting. Let's submit three different requests and compare them. Here's the first request:<p class="source-code">curl -i http://localhost:8080/data-structure</p><p>The output is as follows:</p><div id="_idContainer290" class="IMG---Figure"><img src="image/B14502_14_12.jpg" alt="Figure 14.12: Output of the first request&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.12: Output of the first request</p>
			<p>Here's the second request:</p>
			<p class="source-code">curl -i -H "accept: application/json" http://localhost:8080/data-structure</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer291" class="IMG---Figure">
					<img src="image/B14502_14_13.jpg" alt="Figure 14.13: Output of the second request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.13: Output of the second request</p>
			<p>Here's the third request:</p>
			<p class="source-code">curl -i -H "accept: application/edn" http://localhost:8080/data-structure</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer292" class="IMG---Figure">
					<img src="image/B14502_14_14.jpg" alt="Figure 14.14: Output of the third request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.14: Output of the third request</p>
			<p>In this case, omitting the <strong class="source-inline">accept</strong> header gives us a JSON response by default. Requests for JSON and EDN are respected.</p>
			<p>This demonstrates how remarkably simple (and powerful) content negotiation can be using middleware.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor422"/>Handling a Request Body</h2>
			<p>So far, we have implemented a number of straightforward <strong class="source-inline">GET</strong> operations serving up static responses. Thinking back to our <strong class="bold">Create Read Update Delete</strong> (<strong class="bold">CRUD</strong>) tennis and fitness applications in <em class="italic">Chapter 13</em>, <em class="italic">Database Interaction and the Application Layer</em>, the <strong class="source-inline">GET</strong> method is how we read data. When creating (<strong class="source-inline">PUT</strong>/<strong class="source-inline">POST</strong>) or updating (<strong class="source-inline">PUT</strong>), we should provide a body along with our request. This body is the entity we wish to create or update.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">A <strong class="source-inline">body</strong> can be provided along with a <strong class="source-inline">GET</strong> request; however, this is uncommon and the content of the body should <em class="italic">not</em> have any material impact on the value returned.</p>
			<p>The body, particularly when storing an entity, will often take the form of a map. The map could, therefore, be provided as JSON or EDN and should be parsed accordingly. The code we write as part of our route is again agnostic of the incoming format since the middleware will handle the formatting for us and provide an EDN representation for us to work with.</p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor423"/>Exercise 14.04: Working with a request Body</h2>
			<p>In this exercise, we'll learn how the <strong class="source-inline">wrap-formats</strong> middleware is applied to the incoming request body, not just the outgoing response body. We'll also learn which part of the request will contain the content of the body, how to implement a quick in-memory database, and how to interact with a route via <strong class="source-inline">clj-http</strong> (a Clojure HTTP client library) rather than <strong class="source-inline">curl</strong>. We'll use this knowledge to perform basic CRUD operations on our in-memory database:</p>
			<ol>
				<li value="1">Let's introduce <strong class="source-inline">clj-http</strong> as a dependency, to demonstrate a native Clojure means of interacting with our web server. We'll also need a means of constructing a JSON payload, hence the inclusion of <strong class="source-inline">clojure.data.json</strong>:<p class="source-code">{:deps {clj-http {:mvn/version "3.10.0"}</p><p class="source-code">        compojure {:mvn/version "1.6.1"}</p><p class="source-code">        metosin/muuntaja {:mvn/version "0.6.4"}</p><p class="source-code">        org.clojure/data.json {:mvn/version "0.2.6"}</p><p class="source-code">        ring/ring-core {:mvn/version "1.7.1"}</p><p class="source-code">        ring/ring-jetty-adapter {:mvn/version "1.7.1"}}</p></li>
				<li>We'll define an atom to act as a cheap in-memory database for our server. Our <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> routes will then use it as storage to demonstrate working with a <strong class="source-inline">request</strong> body:<p class="source-code">(require '[compojure.core :refer [defroutes DELETE GET PUT]]</p><p class="source-code">              '[compojure.route :as route])</p><p class="source-code">(def db (atom {}))</p><p class="source-code">(defroutes routes</p><p class="source-code">          (GET "/data-structure" request</p><p class="source-code">             (when-let [data-structure (@db :data)]</p><p class="source-code">               {:body data-structure}))</p><p class="source-code">           (PUT "/data-structure" request</p><p class="source-code">             (swap! db assoc :data (:body-params request))</p><p class="source-code">             {:status 201})</p><p class="source-code">           (DELETE "/data-structure" request</p><p class="source-code">             (swap! db dissoc :data))</p><p class="source-code">           (route/not-found "Not found"))</p><p>Our <strong class="source-inline">GET</strong> method will read the value associated with the <strong class="source-inline">:data</strong> key; our <strong class="source-inline">PUT</strong> method will store the content of the <strong class="source-inline">:body-params</strong> key in our incoming request under the <strong class="source-inline">:data</strong> key in our atom, allowing us to roundtrip the data structure. Finally, our <strong class="source-inline">DELETE</strong> will remove the structure we have stored.</p></li>
				<li>Our <strong class="source-inline">run</strong> function remains unchanged since <strong class="source-inline">muuntaja</strong> <strong class="source-inline">wrap-format</strong> works for both the incoming request body and the outgoing response body:<p class="source-code">(defn run</p><p class="source-code">  []</p><p class="source-code">  (run-jetty</p><p class="source-code">    (middleware/wrap-format routes)</p><p class="source-code">    {:port  8080</p><p class="source-code">     :join? false}))</p></li>
				<li>After restarting our server, use <strong class="source-inline">clj-http</strong> to persist a JSON data structure:<p class="source-code">(require '[clj-http.client :as http]</p><p class="source-code">         '[clojure.data.json :as json]</p><p class="source-code">         '[clojure.edn :as edn])</p><p class="source-code">(-&gt; (http/put "http://localhost:8080/data-structure"</p><p class="source-code">              {:content-type :application/json</p><p class="source-code">               :body         (json/write-str {:a 1</p><p class="source-code">                                              :b #{2 3 4}})})</p><p class="source-code">    :status)</p><p class="source-code">=&gt; 201</p><p class="callout-heading">Note</p><p class="callout">The request body <em class="italic">must</em> be a string, hence our <strong class="source-inline">json/write-str</strong> call against our Clojure data structure. We must also provide a <strong class="source-inline">content-type</strong> header to aid our web service in formatting the incoming data correctly.</p></li>
				<li>Now retrieve the persisted data in EDN format:<p class="source-code">user=&gt; (-&gt; (http/get "http://localhost:8080/data-structure"</p><p class="source-code">              {:accept :application/edn})</p><p class="source-code">    :body</p><p class="source-code">    edn/read-string)</p><p class="source-code">=&gt; {:b [4 3 2], :a 1}</p><p>Notice that we attempted to persist a set as part of our payload; however, it has been returned as a vector. This is an important point to note: JSON to EDN conversion leads to a loss of data. This is due to EDN having more built-in type support than JSON (for example, sets and keywords).</p><p>This is particularly dangerous if we have several clients interacting with our service; one that persists/consumes JSON and another that persists/consumes EDN. There is a workaround where we can define a schema and coerce the incoming request body.</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">wrap-format</strong> <em class="italic">does</em> coerce string keys to keywords as we saw in the preceding steps.</p></li>
				<li>Now, let's confirm our EDN persistence and the retrieval behaves as expected:<p class="source-code">(-&gt; (http/put "http://localhost:8080/data-structure"</p><p class="source-code">              {:content-type :application/edn</p><p class="source-code">              :body         (pr-str {:a 1</p><p class="source-code">                                      :b #{2 3 4}})})</p><p class="source-code">    :status)</p><p class="source-code">=&gt; 201</p><p class="source-code">(-&gt; (http/get "http://localhost:8080/data-structure"</p><p class="source-code">              {:accept :application/edn})</p><p class="source-code">    :body</p><p class="source-code">    edn/read-string)</p><p class="source-code">=&gt; {:a 1, :b #{4 3 2}}</p></li>
				<li> We're now done with our <strong class="source-inline">data-structure</strong> resource; let's delete it from the server:<p class="source-code">(-&gt; (http/delete "http://localhost:8080/data-structure")</p><p class="source-code">    :status)</p><p class="source-code">=&gt; 200</p></li>
				<li>The preceding <strong class="source-inline">200</strong> status indicates that the deletion was successful; we can confirm this by attempting one more retrieval:<p class="source-code">(http/get "http://localhost:8080/data-structure"</p><p class="source-code">          {:accept :application/edn})</p><p class="source-code">Execution error (ExceptionInfo) at slingshot.support/stack-trace (support.clj:201).</p><p class="source-code">clj-http: status 404</p><p>We receive a <strong class="source-inline">404</strong> exception, since the resource is <strong class="source-inline">not found</strong>, as we expected.</p></li>
			</ol>
			<p>Great – we have learned that the <strong class="source-inline">wrap-format</strong> middleware will assist us in formatting JSON and EDN request bodies as well as response bodies as we noted earlier. We know that the request body will be consumed by the <strong class="source-inline">wrap-format</strong> middleware and the EDN-formatted result placed in the <strong class="source-inline">body-params</strong> of the incoming request. We have also picked up a few tips on interacting with a Clojure service using <strong class="source-inline">clj-http</strong>.</p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor424"/>Static Files</h1>
			<p>In the early days of the internet, web servers were used to serve up static HTML pages and images. Although technology has progressed a great deal since then, serving up static resources is still very much a requirement of today's web servers.</p>
			<p>Thinking back to our CSV file of tennis matches from <em class="italic">Chapter 5</em>, <em class="italic">Many to One: Reducing</em>, we may wish to make this available to download via our web service.</p>
			<p><strong class="source-inline">compojure.route</strong>, which we previously used to provide a <strong class="source-inline">not-found</strong> route, also provides a means of easily serving static files from a custom location on disk. <strong class="source-inline">compojure.route/files</strong> accepts a path where the files will be exposed as well as an options map where we can override the directory that our files are served from.</p>
			<p>The following code would allow us to access any files located under the <strong class="source-inline">/home/&lt;user&gt;/packt-http/resources/</strong> directory by browsing to our web server's <strong class="source-inline">/files/&lt;filename&gt;</strong> route:</p>
			<p class="source-code">(route/files "/files/" {:root "/home/&lt;user&gt;/packt-http/resources/"}) </p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor425"/>Exercise 14.05: Serving Static Files</h2>
			<p>In this exercise, we'll make several files available via our web service, observing how the file-type determines the response of the web browser. We'll create a text file with the <strong class="source-inline">.txt</strong> file extension and see the contents displayed in our browser. We'll then see how requesting a CSV file results in the file being downloaded to our local machine:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">resources</strong> subdirectory containing a text file named <strong class="source-inline">sample.txt</strong> with the content <strong class="source-inline">This is only a sample</strong>, along with the <strong class="source-inline">match_scores_1991-2016_unindexed_csv.csv</strong> file we are familiar with from <a href="https://packt.live/2NT96hM">https://packt.live/2NT96hM</a><span class="ListLabel-62">.</span></li>
				<li>Now we'll use the <strong class="source-inline">compojure.route/files</strong> function to serve these up behind a <strong class="source-inline">files</strong> route:<p class="source-code">(defroutes routes</p><p class="source-code">           (route/files "/files/" {:root "./resources/"})</p><p class="source-code">           (route/not-found "Not found"))</p><p>Restart the web server, then browse to <strong class="source-inline">http://localhost:8080/files/sample.txt</strong>, expecting an output similar to the following:</p><div id="_idContainer293" class="IMG---Figure"><img src="image/B14502_14_15.jpg" alt="Figure 14.15: Output of the sample.txt file&#13;&#10;"/></div><p class="figure-caption">Figure 14.15: Output of the sample.txt file</p></li>
				<li>Now browse to <strong class="source-inline">http://localhost:8080/files/match_scores_1991-2016_unindexed_csv.csv</strong>, expecting the file to be downloaded as follows:<div id="_idContainer294" class="IMG---Figure"><img src="image/B14502_14_16.jpg" alt="Figure 14.16: Downloading the CSV file&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.16: Downloading the CSV file</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The browser has inspected the <strong class="source-inline">content-type</strong> header in the response headers; in the <strong class="source-inline">sample.txt</strong> case, it is reported as <strong class="source-inline">text/plain</strong> and is rendered in the browser. In the CSV case, the <strong class="source-inline">content-type</strong> header is reported as <strong class="source-inline">text/csv</strong>, which generally is not rendered and is instead downloaded to disk. It may, however, be opened by spreadsheet software depending on your default application launch settings in your browser.</p>
			<p>Excellent! We have seen how straightforward it is to expose local files via our web service for display or download. </p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor426"/>Integrating with an Application Layer</h2>
			<p>Recall the Activity Tracker database from <em class="italic">Activity 13.01</em>, <em class="italic">Persisting Historic Tennis Results and ELO Calculations</em>, of <em class="italic">Chapter 13</em>, <em class="italic">Database Interaction and the Application Layer</em>, and how it was mentioned that we could envisage a web service sitting on top of the application layer. Our public functions in each of our namespaces were candidates for exposing over HTTP.</p>
			<p>Recall that what we're exposing over REST is access to read or manipulate a given resource. Considering our <strong class="source-inline">users</strong> and <strong class="source-inline">activities</strong> as resources, we may want to retrieve all of our <strong class="source-inline">users</strong> resources, all of our <strong class="source-inline">activities</strong> resources, a single user by ID, or all activities for a given user. We start by constructing the paths that we would navigate to reach each intended resource.</p>
			<p>Let's consider the <strong class="source-inline">users</strong> resource. This is the collection of all users in the system and is sensibly located at the <strong class="source-inline">/users</strong> path. In terms of the route we'd create, our starting point would be the following:</p>
			<p class="source-code">(def route</p>
			<p class="source-code">  (GET "/users" [] (query/all-users db)))</p>
			<p>Now, to access a single user within that collection, we'd require some means of keying into the <strong class="source-inline">users</strong> resource. Since we have defined an <strong class="source-inline">ID</strong> field associated with our <strong class="source-inline">users</strong> resource, we can uniquely identify a given user by their ID. </p>
			<p>As such, we could envisage our <strong class="source-inline">user-by-id</strong> route looking very similar to the preceding route, with an additional parameter being passed. Our options for parameters are path parameters or query parameters. The distinction between the two being that <strong class="source-inline">path</strong> parameters are used when they uniquely identify a resource within a collection; <strong class="source-inline">query</strong> parameters are used to filter a resource by a property. As examples, we could have the following:</p>
			<p class="source-code">"/users/123"</p>
			<p class="source-code">"/users?first-name=David"</p>
			<p>In the first instance, we're requesting a single user having ID 123. In the latter, we're filtering our <strong class="source-inline">users</strong> collection down to those whose first name is <strong class="source-inline">David</strong>.</p>
			<p>With this knowledge in mind, we can take our public API and map each function to a <strong class="source-inline">path</strong> parameter where we'll expose it in our web service:</p>
			<p class="source-code">ingest/user                      POST /users</p>
			<p class="source-code">ingest/activity                  POST /activities</p>
			<p class="source-code">query/all-users                  GET /users</p>
			<p class="source-code">query/user                       GET /users/:id</p>
			<p class="source-code">query/activities-by-user         GET /users/:id/activities</p>
			<p class="source-code">query/all-activities             GET /activities</p>
			<p class="source-code">query/activity                   GET /activities/:id</p>
			<p class="source-code">query/most-active-user           GET /reports?report-type=most-active-user</p>
			<p class="source-code">query/monthly-activity-by-user   GET /reports?report-type=monthly-activity-by-user</p>
			<p>Now that we've described each of the paths, we can see a natural grouping of <strong class="source-inline">users</strong>, <strong class="source-inline">activities</strong>, and <strong class="source-inline">reports</strong>. Compojure offers us a means of reflecting this grouping when we define our routes by using the <strong class="source-inline">compojure.core/context</strong> macro. For example, to group the <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> <strong class="source-inline">/users</strong> routes, we can do the following:</p>
			<p class="source-code">(context "/users" []</p>
			<p class="source-code">  (GET "/" []</p>
			<p class="source-code">    ..</p>
			<p class="source-code">  (POST "/" request</p>
			<p class="source-code">    ..)</p>
			<p>Not only have we created a shared path prefix for both routes, we also have the ability to destructure the request at the context level as well as the route level. If we had a shared query parameter, we could destructure it when we define the context, then make reference to it from any route within that context.</p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor427"/>Accessing path and query Parameters in Compojure</h2>
			<p>A request map is structured such that the <strong class="source-inline">path</strong> and <strong class="source-inline">query </strong>parameters are available via the :params key. We can, therefore, destructure the parameters we're interested in as follows:</p>
			<p class="source-code">(def route</p>
			<p class="source-code">  (GET "/users/:id/activity" {:keys [id] :params} (query/all-users db))</p>
			<p>However, Compojure offers some enhanced destructuring ability since parameters are some of the most common items to access within an incoming request. Using Compojure's destructuring, we could rewrite the preceding route as follows:</p>
			<p class="source-code">(def route</p>
			<p class="source-code">  (GET "/users/:id/activity" [id] (query/all-users db))</p>
			<p>Notice that we've simply provided a vector containing the <strong class="source-inline">id</strong> symbol. Compojure then looks for an <strong class="source-inline">id</strong> key inside the <strong class="source-inline">params</strong> key of the incoming request map and makes the value available to us. Anything within the vector is automatically extracted from the value associated with the <strong class="source-inline">:params</strong> key and bound for use within the body of the route.</p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor428"/>Exercise 14.06: Integrating with an Application Layer</h2>
			<p>In this exercise, we'll take the <strong class="source-inline">packt-clj.fitness</strong> backend along with the fitness database from the previous chapter and expand it such that we can ingest and query users and activities via a REST web service. We'll be reading data from an incoming body that is represented as an input stream. <strong class="source-inline">slurp</strong> is ideal in this case as it will open a reader on the stream and return the stream contents as a string. <strong class="source-inline">slurp</strong> also works on files, URIs, and URLs. </p>
			<ol>
				<li value="1">Add the following dependencies to <strong class="source-inline">packt-clj.fitness</strong> in the <strong class="source-inline">deps.edn</strong> file:<p class="source-code">{:deps {..</p><p class="source-code">        clj-http {:mvn/version "3.10.0"}</p><p class="source-code">        compojure {:mvn/version "1.6.1"}</p><p class="source-code">        metosin/muuntaja {:mvn/version "0.6.4"}</p><p class="source-code">        org.clojure/data.json {:mvn/version "0.2.6"}</p><p class="source-code">        ring/ring-core {:mvn/version "1.7.1"}</p><p class="source-code">        ring/ring-jetty-adapter {:mvn/version "1.7.1"}}</p></li>
				<li>Create a new namespace, <strong class="source-inline">packt-clj.fitness.api</strong>, with the following <strong class="source-inline">requires</strong> route:<p class="source-code">(ns packt-clj.fitness.api</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.edn :as edn]</p><p class="source-code">    [compojure.core :refer [context defroutes DELETE GET PUT POST]]</p><p class="source-code">    [compojure.route :as route]</p><p class="source-code">    [muuntaja.middleware :as middleware]</p><p class="source-code">    [packt-clj.fitness.ingest :as ingest]</p><p class="source-code">    [packt-clj.fitness.query :as query]</p><p class="source-code">    [packt-clj.fitness.schema :as schema]</p><p class="source-code">    [ring.adapter.jetty :refer [run-jetty]]</p><p class="source-code">    [ring.middleware.params :as params]))</p></li>
				<li>Define our four routes for querying and persisting users, recalling that we can use a <strong class="source-inline">context</strong> to group routes that share a path prefix and/or reference the same <strong class="source-inline">query</strong> parameters:<p class="source-code">(defroutes routes</p><p class="source-code">           (context "/users" []</p><p class="source-code">             (GET "/" []</p><p class="source-code">               {:body (query/all-users schema/db)})</p><p class="source-code">             (POST "/" req</p><p class="source-code">               (let [ingest-result (ingest/user schema/db (edn/read-string (slurp (:body req))))]</p><p class="source-code">                 {:status  201</p><p class="source-code">                  :headers {"Link" (str "/users/" (:1 ingest-result))}}))</p><p class="source-code">             (GET "/:id" [id]</p><p class="source-code">               (when-first [user (query/user schema/db id)]</p><p class="source-code">                 {:body user}))</p><p class="source-code">             (GET "/:id/activities" [id]</p><p class="source-code">               {:body (query/activities-by-user schema/db id)})))</p></li>
				<li>Define the three activity-related routes within the preceding <strong class="source-inline">defroutes</strong> definition:<p class="source-code">(defroutes routes</p><p class="source-code">          ..</p><p class="source-code">          (context "/activities" []</p><p class="source-code">             (GET "/" []</p><p class="source-code">               {:body (query/all-activities schema/db)})</p><p class="source-code">             (POST "/" req</p><p class="source-code">               (let [ingest-result (ingest/activity schema/db (edn/read-string (slurp (:body req))))]</p><p class="source-code">                 {:status  201</p><p class="source-code">                  :headers {"Link" (str "/activities/" (:1 ingest-result))}}))</p><p class="source-code">             (GET "/:id" [id]</p><p class="source-code">               (when-first [activity (query/activity schema/db id)]</p><p class="source-code">                 {:body activity})))</p><p class="callout-heading">Note</p><p class="callout">It is important to remember that our <strong class="source-inline">body</strong> is represented as a stream, meaning that it can only be read once. Any subsequent attempts to read from it will find it is already exhausted. Particular care should be taken when debugging not to read the body before it is actually utilized by the route. The same consideration should be made when writing middleware that interacts with the body.</p></li>
				<li>Now add our reporting route along with our catch-all <strong class="source-inline">not-found</strong> route:<p class="source-code">(defroutes routes</p><p class="source-code">          ..</p><p class="source-code">          (context "/reports" [report-type id]</p><p class="source-code">             (GET "/" []</p><p class="source-code">               {:body (case report-type</p><p class="source-code">                        "most-active-user" (query/most-active-user schema/db)</p><p class="source-code">                        "monthly-activity-by-user" (query/monthly-activity-by-user schema/db id)</p><p class="source-code">                        nil)}))</p><p class="source-code">           (route/not-found "Not found")</p></li>
				<li>Create our <strong class="source-inline">run</strong> function, which will start our Jetty server, serving up the routes we've defined:<p class="source-code">(defn run</p><p class="source-code">  []</p><p class="source-code">  (run-jetty</p><p class="source-code">    (-&gt; routes</p><p class="source-code">        middleware/wrap-format</p><p class="source-code">        params/wrap-params)</p><p class="source-code">    {:port 8080</p><p class="source-code">     :join? false}))</p></li>
				<li>Now let's start the server and explore some of the endpoints we've created. Retrieve all users, then verify that we can retrieve a single user resource:<p class="source-code">(require '[packt-clj.fitness.api :as api])</p><p class="source-code">(def app (api/run))</p><p>The output is as follows:</p><div id="_idContainer295" class="IMG---Figure"><img src="image/B14502_14_17.jpg" alt="Figure 14.17: Retrieving all the users&#13;&#10;"/></div><p class="figure-caption">Figure 14.17: Retrieving all the users</p><p>Here is the output for retrieving a single user:</p><div id="_idContainer296" class="IMG---Figure"><img src="image/B14502_14_18.jpg" alt="Figure 14.18: Retrieving a single user&#13;&#10;"/></div><p class="figure-caption">Figure 14.18: Retrieving a single user</p></li>
				<li>Add a new user, an associated activity, then retrieve the list of activities that the user has taken part in:<p class="source-code">(require '[clj-http.client :as http])</p><p class="source-code">(-&gt; (http/post "http://localhost:8080/users"</p><p class="source-code">               {:body (pr-str {:first_name "Boris"</p><p class="source-code">                               :surname    "Becker"</p><p class="source-code">                               :height     191</p><p class="source-code">                               :weight     85})})</p><p class="source-code">    :headers</p><p class="source-code">    (get "Link"))</p><p class="source-code">user=&gt; "/users/4"</p><p class="source-code">(-&gt; (http/post "http://localhost:8080/activities"</p><p class="source-code">               {:body (pr-str {:user_id       4</p><p class="source-code">                               :activity_type "run"</p><p class="source-code">                               :activity_date "2019-03-25"</p><p class="source-code">                               :distance      4970</p><p class="source-code">                               :duration      1200})})</p><p class="source-code">    :headers</p><p class="source-code">    (get "Link"))</p><p class="source-code">user=&gt; "/activities/61"</p><p>Browsing to <strong class="source-inline">http://localhost:8080/users/4/activities</strong>, the output is as follows:</p><div id="_idContainer297" class="IMG---Figure"><img src="image/B14502_14_19.jpg" alt="Figure 14.19: Printing the final output&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.19: Printing the final output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding user and activity IDs (<strong class="source-inline">4</strong> and <strong class="source-inline">61</strong>) are autogenerated and <em class="italic">will</em> vary if you have persisted any additional data before writing the two preceding records.</p>
			<p>Excellent. We've successfully taken our existing application layer and, with a small amount of code, made it accessible via a web browser or any other web client.</p>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor429"/>Activity 14.01: Exposing Historic Tennis Results and ELO Calculations via REST</h2>
			<p>The application layer delivered as part of <strong class="source-inline">packt-clj.tennis</strong> from <em class="italic">Chapter 13</em>, <em class="italic">Database Interaction and the Application Layer</em>, has been well received. You have now been asked to make this more widely available via a REST web service. Of most interest is the ability to browse player data, tennis matches, and ELO changes over time. The ability to persist new tennis matches and recalculate the ELO has also been requested. The historic data should be assumed to be already available in our database.</p>
			<p>Consider the public API of your application layer, determine the resources that you'd like to expose, then build your web service to expose those resources via a web client (either a browser or another HTTP client). Additional application layer functions will be required to support the routes we'll create.</p>
			<p>These steps will help you to perform the activity:</p>
			<ol>
				<li value="1">Add the required dependencies to your <strong class="source-inline">deps.edn</strong> file or equivalent.</li>
				<li>Create the namespace, <strong class="source-inline">packt-clj.tennis.api</strong>.</li>
				<li>Define our <strong class="source-inline">routes</strong> parameters, adding a <strong class="source-inline">players</strong> context containing routes that expose all our player resources, an individual player using their unique ID, and all of the tennis matches that the player took part in. Wire these routes up to appropriate functions in the <strong class="source-inline">query</strong> namespace.</li>
				<li>Create a <strong class="source-inline">run</strong> function that will start up a Jetty server on port <strong class="source-inline">8080</strong>, exposing our <strong class="source-inline">routes</strong> parameter, ensuring we use middleware to help us with content negotiation and rationalizing the location of parameters within our request map.</li>
				<li>Within our <strong class="source-inline">players</strong> context, add a route for returning the ELO of an individual player. Again, construct the appropriate <strong class="source-inline">query</strong> function to support this extraction.</li>
				<li>Now add a <strong class="source-inline">tennis-matches</strong> context containing a route that exposes all matches, as well as individual matches by their unique ID.</li>
				<li>Retrieve the current ELO of <strong class="source-inline">Pete Sampras</strong> (ID: <strong class="source-inline">s402</strong>) and <strong class="source-inline">Novak Djokovic</strong> (ID: <strong class="source-inline">d643</strong>).</li>
				<li>Within the <strong class="source-inline">tennis-matches</strong> context, add a route to create a new match using existing players. The persistence of the new match should recalculate the ELO of the players involved.</li>
				<li>Construct and persist a fictitious match between <strong class="source-inline">Sampras</strong> and <strong class="source-inline">Djokovic</strong> where <strong class="source-inline">Djokovic</strong> takes the win:<p class="source-code">{:id "2019-1-d643-s402-5"</p><p class="source-code">:tournament_year  2019,</p><p class="source-code">:tournament       "umag",</p><p class="source-code">:tournament_order 1,</p><p class="source-code">:round_order      5,</p><p class="source-code">:match_order      1,</p><p class="source-code">:winner_id        "d643",</p><p class="source-code">:loser_id         "s402"}</p></li>
				<li>Retrieve the updated ELO of <strong class="source-inline">Sampras</strong> (<strong class="source-inline">s402</strong>) and <strong class="source-inline">Djokovic</strong> (<strong class="source-inline">d643</strong>), expecting ELO of <strong class="source-inline">Sampras</strong> to decrease, while Djokovic's will have increased.<p>Here is the expected output:</p></li>
			</ol>
			<div>
				<div id="_idContainer298" class="IMG---Figure">
					<img src="image/B14502_14_20.jpg" alt="Figure 14.20: Printing Sampras' rating&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.20: Printing Sampras' rating</p>
			<div>
				<div id="_idContainer299" class="IMG---Figure">
					<img src="image/B14502_14_21.jpg" alt="Figure 14.21: Printing Djokovic's rating&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.21: Printing Djokovic's rating</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 753.</p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor430"/>Summary</h1>
			<p>This chapter introduced us to HTTP, web servers, and the request-response interaction between a web server and a client. Multiple clients were introduced, including the most typical (the web browser) as well as <strong class="source-inline">curl</strong> and <strong class="source-inline">clj-http</strong>. We learned how a web server takes an incoming request and routes it according to key elements of the incoming request map, before constructing a response map, which is then presented to the requesting client.</p>
			<p>We learned about middleware and how it intercepts our request and/or response map. We then used <strong class="source-inline">muuntaja</strong> to format the content we generated for the client, as well as to format incoming data from the client as JSON or EDN.</p>
			<p>After considering the content of our database in the context of groups of related resources, we learned how to construct appropriate paths to address them using a REST architecture. This paved the way for integrating our existing application layers with a web service that would allow any web client to interact with them over HTTP.</p>
			<p>We can now imagine a frontend (user interface) pulling resources from our web service, formatting them, and presenting them to a user who is then capable of manipulating those resources. In this case, the IDs (which are not particularly user-friendly) could be tracked by the UI and kept hidden from the users.</p>
			<p>We'll explore how to interact with our new service via ClojureScript in the next chapter.</p>
		</div>
		<div>
			<div id="_idContainer301" class="Basic-Text-Frame">
			</div>
		</div>
	</body></html>