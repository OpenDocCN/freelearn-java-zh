<html><head></head><body>
		<div id="_idContainer083">
			<h1 id="_idParaDest-206"><em class="italic"><a id="_idTextAnchor205"/>Chapter 9</em>: JVM Structure and Garbage Collection</h1>
			<p>This chapter will provide you with an overview of the structure and behavior of a <strong class="bold">Java virtual machine</strong> (<strong class="bold">JVM</strong>), which are more complex than you may expect.</p>
			<p>A JVM executes instructions according to the coded logic. It also finds and loads the <strong class="source-inline">.class</strong> files that are requested by the application into memory, verifies them, interprets the bytecode (that is, it translates them into platform-specific binary code), and passes the resulting binary code to the central processor (or processors) for execution. It uses several service threads in addition to the application threads. One of the service threads, called <strong class="bold">garbage collection</strong> (<strong class="bold">GC</strong>), performs the important step of releasing the memory from unused objects. </p>
			<p>By completing this chapter, you will understand what constitutes Java application execution, the Java processes inside the JVM and GC, and how the JVM works in general.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Java application execution</li>
				<li>Java processes</li>
				<li>JVM’s structure</li>
				<li>Garbage collection</li>
			</ul>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Technical requirements</h1>
			<p>To execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with Microsoft Windows, Apple macOS, or the Linux operating system</li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or code editor of your choice</li>
			</ul>
			<p>The instructions on how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>. The files that contain the code examples for this chapter are available on GitHub in the <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> repository, in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch09_jvm</strong> folder. </p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/>Java application execution</h1>
			<p>Before we <a id="_idIndexMarker1058"/>learn how the JVM works, let’s review how to run an application, bearing in mind that the following statements are used as synonyms:</p>
			<ul>
				<li>Run/execute/start the main class.</li>
				<li>Run/execute/start the main method.</li>
				<li>Run/execute/start/launch an application.</li>
				<li>Run/execute/start/launch the JVM or a Java process.</li>
			</ul>
			<p>There are also several ways to do this. In <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>, we showed you how to run the <strong class="source-inline">main(String[])</strong> method using IntelliJ IDEA. In this chapter, we will just repeat some of what has been said already and add other variations that might be helpful for you.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>Using an IDE</h2>
			<p>Any IDE <a id="_idIndexMarker1059"/>allows you to run the <strong class="source-inline">main()</strong> method. In <a id="_idIndexMarker1060"/>IntelliJ IDEA, it can be done in three ways:</p>
			<ol>
				<li>Click the green triangle next to the <strong class="source-inline">main()</strong> method's name:</li>
			</ol>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B18388_Figure_9.1.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="2">Once you have executed the <strong class="source-inline">main()</strong> method using the green triangle at least once, the name <a id="_idIndexMarker1061"/>of the class will be added <a id="_idIndexMarker1062"/>to the drop-down menu (on the top line, to the left of the green triangle): <div id="_idContainer075" class="IMG---Figure"><img src="image/B18388_Figure_9.2.jpg" alt=""/></div></li>
			</ol>
			<ol>
				<li value="3">Open the <strong class="bold">Run</strong> menu and select the name of the class. There are several options you can select:</li>
			</ol>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B18388_Figure_9.3.jpg" alt=""/>
				</div>
			</div>
			<p>In the previous <a id="_idIndexMarker1063"/>screenshot, you can also see the<a id="_idIndexMarker1064"/> <strong class="bold">Edit Configurations... option</strong>. This can be used to set all <strong class="bold">program arguments</strong> that are passed to the <strong class="source-inline">main()</strong> method at the start, plus some other options:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B18388_Figure_9.4.jpg" alt=""/>
				</div>
			</div>
			<p>The <strong class="bold">Program arguments</strong> field allows for setting a parameter in the java command. For example, let’s set one two three in this field:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B18388_Figure_9.5.jpg" alt=""/>
				</div>
			</div>
			<p>This setting will result in the following java command:</p>
			<pre class="source-code">java -DsomeParameter=42 -cp . \</pre>
			<pre class="source-code">       com.packt.learnjava.ch09_jvm.MyApplication one two three</pre>
			<p>We can read these parameters in the main() method:</p>
			<pre class="source-code">public static void main(String... args){</pre>
			<pre class="source-code">    System.out.println("Hello, world!"); </pre>
			<pre class="source-code">                              //prints: Hello, world!</pre>
			<pre class="source-code">    for(String arg: args){</pre>
			<pre class="source-code">        System.out.print(arg + " ");     </pre>
			<pre class="source-code">                              //prints: one two three</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    String p = System.getProperty("someParameter");</pre>
			<pre class="source-code">    System.out.println("\n" + p);        //prints: 42</pre>
			<pre class="source-code">}</pre>
			<p>Another possible setting on the <strong class="bold">Edit Configurations</strong> screen is in the <strong class="bold">Environment variables</strong> field. The environment variables that can be accessed from the application using System.getenv(). For example, let’s set the environment variables x and y , as follows:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B18388_Figure_9.6.jpg" alt=""/>
				</div>
			</div>
			<p>If done as shown in the preceding screenshot, the values of x and y can be read not only in the main() method, but anywhere in the application using the System.getenv(“varName”) method. In our case, the values of x and y can be retrieved as follows:</p>
			<pre class="source-code">String p = System.getenv("x");</pre>
			<pre class="source-code">System.out.println(p);            //prints: 42</pre>
			<pre class="source-code">p = System.getenv("y");</pre>
			<pre class="source-code">System.out.println(p);            //prints: 43</pre>
			<p>The <strong class="bold">VM options</strong> field allows you to set <strong class="source-inline">java</strong> command options. For example, if you input <strong class="source-inline">-Xlog:gc</strong>, the IDE will form the following <strong class="source-inline">java</strong> command:</p>
			<pre class="source-code">java -Xlog:gc -cp . com.packt.learnjava.ch09_jvm.MyApplication</pre>
			<p>The <strong class="source-inline">-Xlog:gc</strong> option requires the GC log to be displayed. We will use this option in the next section to demonstrate how GC works. The <strong class="source-inline">-cp .</strong> option (<strong class="bold">cp</strong> stands for <strong class="bold">classpath</strong>) indicates <a id="_idIndexMarker1065"/>that the class is located in a folder on the file tree that starts from the current directory (the one where the command is entered). In our case, the <strong class="source-inline">.class</strong> file is located in the <strong class="source-inline">com/packt/learnjava/ch09_jvm</strong> folder, where <strong class="source-inline">com</strong> is the subfolder of the current directory. The classpath can include many locations where the JVM has to look for the <strong class="source-inline">.class</strong> files that are necessary for the application’s execution.</p>
			<p>Use <strong class="bold">Modify options</strong> link to show <strong class="bold">VM options</strong> as follows:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B18388_Figure_9.7.jpg" alt=""/>
				</div>
			</div>
			<p>For this demonstration, let’s set <a id="_idIndexMarker1066"/>the value <strong class="source-inline">-DsomeParameter=42 </strong> in the  <strong class="bold">VM options</strong> field as shown in <a id="_idIndexMarker1067"/>the following screenshot:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B18388_Figure_9.8.jpg" alt=""/>
				</div>
			</div>
			<p>Now the value of someParameter can be read not only in the <strong class="source-inline">main()</strong> method, but anywhere in the application code as follows:</p>
			<pre class="source-code">String p = System.getProperty("someParameter");</pre>
			<pre class="source-code">System.out.println("\n" + p);    </pre>
			<pre class="source-code">                     //prints someParameter set as VM option -D</pre>
			<p>There are other parameters of the java command that can be set on the <strong class="bold">Edit Configurations</strong> screen, too. We encourage you to spend some time on that screen and view the possible options.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>Using the command line with classes</h2>
			<p>Now, let’s <a id="_idIndexMarker1068"/>run <strong class="source-inline">MyApplication</strong> from <a id="_idIndexMarker1069"/>the command line. To remind you, the main class looks as follows:</p>
			<pre class="source-code">package com.packt.learnjava.ch09_jvm;</pre>
			<pre class="source-code">public class MyApplication {</pre>
			<pre class="source-code">   public static void main(String... args){</pre>
			<pre class="source-code">      System.out.println("Hello, world!");</pre>
			<pre class="source-code">                                //prints: Hello, world!</pre>
			<pre class="source-code">      for(String arg: args){</pre>
			<pre class="source-code">         System.out.print(arg + " ");</pre>
			<pre class="source-code">                                //prints all arguments</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      String p = System.getProperty("someParameter");</pre>
			<pre class="source-code">      System.out.println("\n" + p); </pre>
			<pre class="source-code">                     //prints someParameter set as VM option -D</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>First, it must be compiled using the <strong class="source-inline">javac</strong> command. The command line looks as follows on Linux-type platforms (provided you open the Terminal window in the root of the project, in the folder where <strong class="source-inline">pom.xml</strong> resides):</p>
			<p class="source-code">javac src/main/java/com/packt/learnjava/ch09_jvm/MyApplication.java</p>
			<p>On Windows, the command looks similar:</p>
			<p class="source-code">javac src\main\java\com\packt\learnjava\ch09_jvm\MyApplication.java</p>
			<p>The compiled <strong class="source-inline">MyApplication.class</strong> file is placed in the same folder as <strong class="source-inline">MyApplication.java</strong>. Now, we can execute the compiled class with the <strong class="source-inline">java</strong> command:</p>
			<p class="source-code">java -DsomeParameter=42 -cp src/main/java \</p>
			<p class="source-code">  com.packt.learnjava.ch09_jvm.MyApplication one two three</p>
			<p>Notice that <strong class="source-inline">-cp</strong> points to the <strong class="source-inline">src/main/java</strong> folder (the path is relative to the current folder), where the package of the main class starts. The result is as follows:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B18388_Figure_9.9.jpg" alt=""/>
				</div>
			</div>
			<p>We can also put both compiled classes in a <strong class="source-inline">.jar</strong> file and run them from there.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>Using the command line with JAR files</h2>
			<p>Keeping the compiled files in a folder as <strong class="source-inline">.class</strong> files is not always convenient, especially <a id="_idIndexMarker1070"/>when many <a id="_idIndexMarker1071"/>compiled files of the same framework belong to different packages and are distributed as a single library. In such cases, the compiled <strong class="source-inline">.class</strong> files are usually archived together in a <strong class="source-inline">.jar</strong> file. The format of such an archive is the same as the format of a <strong class="source-inline">.zip</strong> file. The only difference is that a <strong class="source-inline">.jar</strong> file also includes a manifest file that contains metadata describing the archive (we will talk more about the manifest in the next section).</p>
			<p>To demonstrate how to use it, let’s create a <strong class="source-inline">.jar</strong> file with the <strong class="source-inline">ExampleClass.class</strong> file and another <strong class="source-inline">.jar</strong> file with <strong class="source-inline">MyApplication.class</strong> in it, using the following commands:</p>
			<p class="source-code">cd src/main/java</p>
			<p class="source-code">jar -cf myapp.jar </p>
			<p class="source-code">               com/packt/learnjava/ch09_jvm/MyApplication.class</p>
			<p class="source-code">jar -cf example.jar \</p>
			<p class="source-code">        com/packt/learnjava/ch09_jvm/example/ExampleClass.class</p>
			<p>Notice that we need to run the <strong class="source-inline">jar</strong> command in the folder where the package of the <strong class="source-inline">.class</strong> file begins. </p>
			<p>Now, we can run the application, as follows:</p>
			<pre class="source-code">java -cp myapp.jar:example.jar \</pre>
			<pre class="source-code">                     com.packt.learnjava.ch09_jvm.MyApplication</pre>
			<p>The <strong class="source-inline">.jar</strong> files are in the current folder. If we would like to execute the application from another folder (let’s go back to the root directory, <strong class="source-inline">cd ../../..</strong>), the command should look like this:</p>
			<pre class="source-code">java -cp </pre>
			<pre class="source-code">src/main/java/myapp.jar:src/main/java/example.jar\</pre>
			<pre class="source-code">            com.packt.learnjava.ch09_jvm.MyApplication</pre>
			<p>Notice that every <strong class="source-inline">.jar</strong> file must be listed on the classpath individually. To specify just a folder where all the <strong class="source-inline">.jar</strong> files reside (as is the case with the <strong class="source-inline">.class</strong> files) is not good enough. You must add an asterisk (the wildcard symbol, <strong class="source-inline">*</strong>) too, as follows:</p>
			<pre class="source-code">java -cp "src/main/java/*" \</pre>
			<pre class="source-code">           com.packt.learnjava.ch09_jvm.MyApplication</pre>
			<p>Note <a id="_idIndexMarker1072"/>the quotes around <a id="_idIndexMarker1073"/>the path to the folder containing the <strong class="source-inline">.jar</strong> files. Without quotes, this will not work.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/>Using the command line with an executable JAR file</h2>
			<p>It is <a id="_idIndexMarker1074"/>possible to avoid specifying the main class in the command line. Instead, we can create an <a id="_idIndexMarker1075"/>executable <strong class="source-inline">.jar</strong> file. This can be accomplished by placing the name of the main class – the one you need to run and that contains the <strong class="source-inline">main()</strong> method – into the manifest file. Here are the steps:</p>
			<ol>
				<li value="1">Create a text file called <strong class="source-inline">manifest.txt</strong> (the name doesn't matter, but this name makes the intent clear) that contains the following line:<p class="source-code">Main-Class: com.packt.learnjava.ch09_jvm.MyApplication </p></li>
			</ol>
			<p>There must be a space after the colon (<strong class="source-inline">:</strong>), and there must be an invisible newline symbol at the end, so make sure you have pressed the <em class="italic">Enter</em> key and your cursor has jumped to the beginning of the next line.</p>
			<ol>
				<li value="2">Execute the following command:<p class="source-code"><strong class="bold">cd src/main/java </strong></p><p class="source-code"><strong class="bold">jar -cfm myapp.jar manifest.txt \</strong></p><p class="source-code"><strong class="bold">         com/packt/learnjava/ch09_jvm/*.class \</strong></p><p class="source-code"><strong class="bold">         com/packt/learnjava/ch09_jvm/example/*.class</strong></p></li>
			</ol>
			<p>Notice the sequence of <strong class="source-inline">jar</strong> command options (<strong class="source-inline">fm</strong>) and the sequence of the <strong class="source-inline">myapp.jar manifest.txt</strong> files. They must be the same because <strong class="source-inline">f</strong> stands for the file that the <strong class="source-inline">jar</strong> command is going to create, while <strong class="source-inline">m</strong> stands for the manifest source. If you include options with <strong class="source-inline">mf</strong>, then the files must be listed as <strong class="source-inline">manifest.txt myapp.jar</strong>.</p>
			<ol>
				<li value="3">Now, we can run the application using the following command:<p class="source-code">     java -jar myapp.jar </p></li>
			</ol>
			<p>The <a id="_idIndexMarker1076"/>other way to create an executable <strong class="source-inline">.jar</strong> file is much easier:</p>
			<p class="source-code">jar cfe myjar.jar </p>
			<p class="source-code">com.packt.learnjava.ch09_jvm.MyApplication \</p>
			<p class="source-code">             com/packt/learnjava/ch09_jvm/*.class\</p>
			<p class="source-code">             com/packt/learnjava/ch09_jvm/example/*.class</p>
			<p>The <a id="_idIndexMarker1077"/>preceding command generates a manifest with the specified main class name automatically: the <strong class="source-inline">c</strong> option stands for <strong class="bold">create a new archive</strong>, the <strong class="source-inline">f</strong> option stands for <strong class="bold">archive filename</strong>, and the <strong class="source-inline">e</strong> option indicates an <strong class="bold">application entry point</strong>.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor212"/>Java processes </h1>
			<p>As you may have already guessed, JVM does not know anything about the Java language and source code. It only knows <a id="_idIndexMarker1078"/>how to read bytecode. It reads the bytecode and other information from <strong class="source-inline">.class</strong> files, transforms (interprets) the bytecode into a sequence of binary code instructions that are specific to the current platform (where JVM is running), and passes the resulting binary code to the microprocessor that executes it. When talking about this transformation, programmers often refer to it as a <strong class="bold">Java process</strong> or just <strong class="bold">process</strong>.</p>
			<p>The JVM is often <a id="_idIndexMarker1079"/>referred to as a <strong class="bold">JVM instance</strong>. This is because every time a <strong class="source-inline">java</strong> command is executed, a new instance of JVM is launched that’s dedicated to running the particular application as a separate process with its own allocated memory (the size of the memory is set as a default value or passed in as a command option). Inside this Java process, multiple threads are running, each with its own allocated memory. Some are service threads that are created by the JVM; others are application threads that are created and controlled by the application.</p>
			<p>That is the big picture of the JVM executing the compiled code. But if you look closer and read the JVM specification, you will discover that the word <em class="italic">process</em>, concerning the JVM, is used to describe the JVM internal processes too. The JVM specification identifies several other processes running inside the JVM that are usually not mentioned by programmers, except <a id="_idIndexMarker1080"/>maybe the <strong class="bold">class loading process</strong>.</p>
			<p>This is because most of the time, we can successfully write and execute Java programs without knowing anything about the internal JVM processes. But once in a while, some general understanding <a id="_idIndexMarker1081"/>of the JVM’s internal workings helps us identify the root cause of certain issues. That is why in this section, we will provide a short overview of all the processes that happen inside the JVM. Then, in the following sections, we will discuss the JVM’s memory structure and other aspects of its functionality that may be useful to a programmer.</p>
			<p>Two subsystems run the JVM’s internal processes:</p>
			<ul>
				<li><strong class="bold">The classloader</strong>: This <a id="_idIndexMarker1082"/>reads the <strong class="source-inline">.class</strong> file and populates a method area in JVM’s memory with the class-related data:<ul><li>Static fields</li><li>Method bytecode</li><li>Class metadata that describes the class</li></ul></li>
				<li><strong class="bold">The execution engine</strong>: This <a id="_idIndexMarker1083"/>executes the bytecode using the following properties:<ul><li>A heap area for object instantiation</li><li>Java and native method stacks for keeping track of the methods that have been called</li><li>A GC process that reclaims memory</li></ul></li>
			</ul>
			<p>Some of the processes that run inside the main JVM process are as follows:</p>
			<ul>
				<li>Processes that are performed by the classloader, such as the following:<ul><li>Classloading</li><li>Class linking</li><li>Class initialization</li></ul></li>
			</ul>
			<p>Processes that are performed by the execution engine, such as the following:</p>
			<ul>
				<li>Class instantiation</li>
				<li>Method execution</li>
				<li>GC</li>
				<li>Application termination<p class="callout-heading">The JVM Architecture</p><p class="callout">The JVM architecture <a id="_idIndexMarker1084"/>can be described as having two subsystems – the <strong class="bold">classloader</strong> and the <strong class="bold">execution engine</strong> – that run the service processes <a id="_idIndexMarker1085"/>and application <a id="_idIndexMarker1086"/>threads using runtime data memory areas such as the method area, heap, and application thread stacks. <strong class="bold">Threads</strong> are lightweight <a id="_idIndexMarker1087"/>processes that require less resource allocation than the JVM execution process.</p></li>
			</ul>
			<p>This list may give you the impression that these processes are executed sequentially. To some degree, this is true, if we’re talking about one class only. It is not possible to do anything with a <a id="_idIndexMarker1088"/>class before loading it. We can only execute a method after all the previous processes have been completed. However, GC, for example, does not happen immediately once an object has stopped being used (see the <em class="italic">Garbage collection</em> section). Also, an application can exit any time when an unhandled exception or some other error occurs.</p>
			<p>Only the classloader processes are regulated by the JVM specification. The execution engine’s implementation is largely at the discretion of each vendor. It is based on the language semantics and the performance goals that have been set by the implementation authors.</p>
			<p>The processes of the execution engine are in a realm that’s not regulated by the JVM specification. There is common sense, tradition, known and proven solutions, and a Java language specification that can guide a JVM vendor’s implementation decision. But there is no single regulatory document. The good news is that the most popular JVMs use similar solutions – or at least that’s how it looks at a high level. </p>
			<p>With this in mind, let’s discuss each of the seven processes listed previously in more detail.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>Classloading</h2>
			<p>According to the JVM specification, the loading phase includes finding the <strong class="source-inline">.class</strong> file by its name (in the locations listed on a classpath) and creating its representation in memory.</p>
			<p>The first class to <a id="_idIndexMarker1089"/>be loaded is the one that’s passed in the command line, with the <strong class="source-inline">main(String[])</strong> method in it. The classloader reads the <strong class="source-inline">.class</strong> file, parses it, and populates the method area with static fields and method bytecode. It also <a id="_idIndexMarker1090"/>creates an instance of <strong class="source-inline">java.lang.Class</strong> that describes the class. Then, the classloader links the class (see the <em class="italic">Class linking</em> section), initializes it (see the <em class="italic">Class initialization</em> section), and then passes it to the execution engine to run its bytecode.</p>
			<p>The <strong class="source-inline">main(String[])</strong> method is an entrance door into the application. If it calls a method of another class, that class has to be found on the classpath, loaded, and initialized; only then can its method be executed too. If this – just loaded – method calls a method of another class, that class has to be found, loaded, and initialized too, and so on. That is how a Java application starts and gets going.</p>
			<p class="callout-heading">The main(String[]) Method</p>
			<p class="callout">Every class <a id="_idIndexMarker1091"/>can have a <strong class="source-inline">main(String[])</strong> method and often does. Such a method is used to run the class independently as a standalone application for testing or demonstration purposes. The presence of such a method does not make the class <strong class="source-inline">main</strong>. The class only becomes <strong class="source-inline">main</strong> if it's been identified as such in a <strong class="source-inline">java</strong> command line or a <strong class="source-inline">.jar</strong> file manifest.</p>
			<p>That being said, let’s continue discussing the loading process.</p>
			<p>If you look in the API of <strong class="source-inline">java.lang.Class</strong>, you will not see a public constructor there. The classloader creates its instance automatically. This is the same instance that is returned by the <strong class="source-inline">getClass()</strong> method, which you can invoke on any Java object.</p>
			<p>It does not carry the class’s static data (which is maintained in the method area), nor state values (they are in an object that’s created during the execution). It does not contain method bytecode either (this is stored in the method area too). Instead, the <strong class="source-inline">Class</strong> instance provides metadata that describes the class – its name, package, fields, constructors, method signatures, and so on. This metadata is useful not only for the JVM but also for the application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the data that's created by the classloader in memory and maintained by the execution <a id="_idIndexMarker1092"/>engine is called a <strong class="bold">binary representation of the type</strong>.</p>
			<p>If the <strong class="source-inline">.class</strong> file contains errors or does not adhere to a certain format, the process is terminated. This <a id="_idIndexMarker1093"/>means that the loaded class format and its bytecode have been validated by the loading process already. More verification follows at the beginning of the next process, called <strong class="bold">class linking</strong>.</p>
			<p>Here is a high-level description of the loading process. It performs three tasks:</p>
			<ol>
				<li value="1">Finds and reads the <strong class="source-inline">.class</strong> file</li>
				<li>Parses it according to the internal data structure in the method area</li>
				<li>Creates an instance of <strong class="source-inline">java.lang.Class</strong> with the class metadata</li>
			</ol>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/>Class linking</h2>
			<p>According to <a id="_idIndexMarker1094"/>the JVM specification, class linking resolves the references <a id="_idIndexMarker1095"/>of the loaded class so that the methods of the class can be executed.</p>
			<p>Here is a <a id="_idIndexMarker1096"/>high-level description of the linking process. It performs three tasks:</p>
			<ul>
				<li><strong class="bold">Verifies the binary representation of a class or an interface</strong>: Although the JVM can reasonably expect that the <strong class="source-inline">.class</strong> file was produced by the Java compiler and all the instructions satisfy the constraints and requirements of the language, there is no guarantee that the loaded file was produced by the known compiler implementation or a compiler at all. That’s why the first step of the linking process is verification. This makes sure that the binary representation of the class is structurally correct, which means the following:<ul><li>The arguments of each method's invocation are compatible with the method descriptor.</li><li>The return instruction matches the return type of its method.</li><li>Some other checks and verification processes, which vary depending on the JVM vendor.</li></ul></li>
				<li><strong class="bold">Prepares the static fields in the method area</strong>: Once verification has been completed, the interface or class (static) variables are created in the method area and <a id="_idIndexMarker1097"/>initialized to the default values of their types. The other kinds of initialization, such as the explicit assignments that are specified by a programmer and static initialization blocks, are deferred to the process called <strong class="bold">class initialization</strong> (see the <em class="italic">Class initialization</em> section).</li>
				<li><strong class="bold">Resolves symbolic references into concrete references that point to the method area</strong>: If the loaded bytecode refers to other methods, interfaces, or classes, the symbolic references are resolved into concrete references that point to the method area, which is done by the resolution process. If the referred interfaces and classes haven’t been loaded yet, the classloader finds and loads them as needed.</li>
			</ul>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/>Class initialization</h2>
			<p>According to <a id="_idIndexMarker1098"/>the JVM specification, initialization is accomplished by executing the class initialization methods. This happens when the programmer-defined initialization (in static blocks and static assignments) is performed, unless the <a id="_idIndexMarker1099"/>class was already initialized at the request of another class.</p>
			<p>The last part of this statement is important because the class may be requested several times by different (already loaded) methods, and also because JVM processes are executed by different threads and may access the same class concurrently. So, <strong class="bold">coordination</strong> (also <a id="_idIndexMarker1100"/>called <strong class="bold">synchronization</strong>) between different threads is required, which substantially complicates the JVM implementation.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>Class instantiation</h2>
			<p>This step <a id="_idIndexMarker1101"/>may never happen. Technically, an instantiation process, triggered by the <strong class="source-inline">new</strong> operator, is the first step of the execution process. If the <strong class="source-inline">main(String[])</strong> method (which is static) uses only the static methods <a id="_idIndexMarker1102"/>of other classes, this instantiation never happens. That’s why it is reasonable to identify this process as separate from the execution.</p>
			<p>This activity <a id="_idIndexMarker1103"/>has very specific tasks:</p>
			<ul>
				<li>Allocating memory for the object (its state) in the heap area</li>
				<li>Initializing the instance fields to the default values</li>
				<li>Creating thread stacks for Java and native methods</li>
			</ul>
			<p>Execution starts when the first method (not a constructor) is ready to be executed. For every application thread, a dedicated runtime stack is created, where every method call is captured in a stack frame. For example, if an exception occurs, we get data from the current stack frames when we call the <strong class="source-inline">printStackTrace()</strong> method.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/>Method execution</h2>
			<p>The first application thread (called the <strong class="bold">main thread</strong>) is created when the <strong class="source-inline">main(String[])</strong> method <a id="_idIndexMarker1104"/>starts executing. It can create other application threads.</p>
			<p>The execution <a id="_idIndexMarker1105"/>engine reads the bytecode, interprets it, and sends the binary code to the microprocessor for execution. It also maintains a count <a id="_idIndexMarker1106"/>of how many times and how often each method was called. If the count exceeds a certain threshold, the execution engine uses a compiler, called the <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>) compiler, which <a id="_idIndexMarker1107"/>compiles the method bytecode into native code. This way, the next time the method is called, it will be ready without needing an interpretation. This substantially improves code performance.</p>
			<p>The instruction that’s currently being executed and the address of the next instruction are <a id="_idIndexMarker1108"/>maintained in the <strong class="bold">program counter</strong> (<strong class="bold">PC</strong>) registers. Each thread has dedicated PC registers. It also improves performance and keeps track of the execution.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor218"/>Garbage collection</h2>
			<p>The garbage collector identifies <a id="_idIndexMarker1109"/>the objects that are not referenced anymore and can be removed from the memory.</p>
			<p>There is <a id="_idIndexMarker1110"/>a Java static method, <strong class="source-inline">System.gc()</strong>, that can be used programmatically to trigger the GC, but its immediate execution is not guaranteed. Every GC cycle affects the application’s performance, so the JVM must maintain a balance between memory availability and the ability to execute the bytecode quickly enough.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor219"/>Application termination</h2>
			<p>There are <a id="_idIndexMarker1111"/>several ways an application can be terminated (and <a id="_idIndexMarker1112"/>the JVM stopped or exited) programmatically:</p>
			<ul>
				<li>Normal termination, without an error status code</li>
				<li>Abnormal termination, because of an unhandled exception</li>
				<li>Forced programmatic exit, with or without an error status code</li>
			</ul>
			<p>If there are no exceptions and infinite loops, the <strong class="source-inline">main(String[])</strong> method completes with a return statement or after its last statement is executed. As soon as this happens, the main application thread passes the control flow to the JVM and the JVM stops executing too. That is the happy ending, and many applications enjoy it in real life. Most of our examples, except those when we have demonstrated exceptions or infinite loops, have exited successfully too.</p>
			<p>However, there are other ways a Java application can exit, some of them quite graceful too – others not so much. If the main application thread created child threads or, in other words, a programmer has written code that generates other threads, even a graceful exit may not be easy. It all depends on the kind of child threads that have been created.</p>
			<p>If any of them is a user thread (the default), then the JVM instance continues to run even after the main thread exits. Only after all the user threads have been completed does the JVM instance stop. The main thread can request the child user thread to complete. But until it exits, the JVM continues running. And this means that the application is still running too.</p>
			<p>But if all the child threads are daemon threads, or no child threads are running, the JVM instance stops running as soon as the main application thread exits.</p>
			<p>How the application exits in the case of an exception depends on the code design. We touched on this in <a href="B18388_04_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a>, <em class="italic">Exception Handling</em>, while discussing the best practices of exception handling. If the thread captures all the exceptions in a try-catch block in <strong class="source-inline">main(String[])</strong> or a similarly high-level method, then it is up to the application (and the programmer who wrote the code) to decide how best to proceed – to try to change the <a id="_idIndexMarker1113"/>input data and repeat the block of <a id="_idIndexMarker1114"/>code that generated the exception, to log the error and continue, or to exit. If, on the other hand, the exception remains unhandled and propagates into the JVM code, the thread (where the exception occurred) stops executing and exits. What happens next depends on the type of thread and some other conditions. The following <a id="_idIndexMarker1115"/>are four possible options:</p>
			<ul>
				<li>If there are no other threads, the JVM stops executing and returns an error code and the stack trace.</li>
				<li>If the thread with an unhandled exception was not the main one, other threads (if present) continue running.</li>
				<li>If the main thread has thrown an unhandled exception and the child threads (if present) are daemons, they exit too.</li>
				<li>If there is at least one user child thread, the JVM continues running until all the user threads exit.</li>
			</ul>
			<p>There are also ways to programmatically force the application to stop:</p>
			<ul>
				<li><strong class="source-inline">System.exit(0);</strong></li>
				<li><strong class="source-inline">Runtime.getRuntime().exit(0);</strong></li>
				<li><strong class="source-inline">Runtime.getRuntime().halt(0);</strong></li>
			</ul>
			<p>All these methods force the JVM to stop executing any thread and exit with a status code passed in as the parameter (<strong class="source-inline">0</strong>, in our examples):</p>
			<ul>
				<li>Zero indicates normal termination</li>
				<li>A nonzero value indicates an abnormal termination</li>
			</ul>
			<p>If the Java command was launched by some script or another system, the value of the status code can be used to automate the decision-making regarding the next step. But that is already outside the application and Java code.</p>
			<p>The first <a id="_idIndexMarker1116"/>two methods have identical functionality <a id="_idIndexMarker1117"/>because this is how <strong class="source-inline">System.exit()</strong> is implemented:</p>
			<pre class="source-code">public static void exit(int status) { </pre>
			<pre class="source-code">    Runtime.getRuntime().exit(status); </pre>
			<pre class="source-code">}</pre>
			<p>To see the source code in the IDE, just click on the method.</p>
			<p>The JVM exits when some thread invokes the <strong class="source-inline">exit()</strong> method of the <strong class="source-inline">Runtime</strong> or <strong class="source-inline">System</strong> classes, or the <strong class="source-inline">halt()</strong> method of the <strong class="source-inline">Runtime</strong> class, and the exit or halt operation is permitted by the security manager. The difference between <strong class="source-inline">exit()</strong> and <strong class="source-inline">halt()</strong> is that <strong class="source-inline">halt()</strong> forces the JVM to exit immediately, while <strong class="source-inline">exit()</strong> performs additional actions that can be set using the <strong class="source-inline">Runtime.addShutdownHook()</strong> method. But these options are rarely used by mainstream programmers.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor220"/>JVM’s structure</h1>
			<p>The structure <a id="_idIndexMarker1118"/>of the JVM can be described in terms of its runtime data structure in memory and the two subsystems that use the runtime data – the classloader and the execution engine.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>Runtime data areas</h2>
			<p>Each of the <a id="_idIndexMarker1119"/>runtime data areas of JVM memory belongs to <a id="_idIndexMarker1120"/>one of two categories:</p>
			<ul>
				<li><strong class="bold">Shared areas</strong>, which <a id="_idIndexMarker1121"/>include the following:<ul><li><strong class="bold">Method area</strong>: Class metadata, static fields, and method bytecode</li><li><strong class="bold">Heap area</strong>: Objects (states)</li></ul></li>
				<li><strong class="bold">Unshared areas</strong> that are <a id="_idIndexMarker1122"/>dedicated to a particular application thread, which include the following:<ul><li><strong class="bold">Java stack</strong>: Current and caller frames, with each frame keeping the state of Java (non-native) method invocation:<ol><li value="1">Values of local variables</li><li>Method parameter values</li><li>Values of operands for intermediate calculations (operand stack)</li><li>Method return value (if any)</li></ol></li></ul></li>
				<li><strong class="bold">PC register</strong>: The next instruction to execute</li>
				<li><strong class="bold">Native method stack</strong>: The state of the native method invocations</li>
			</ul>
			<p>We have <a id="_idIndexMarker1123"/>already discussed that a programmer must be careful <a id="_idIndexMarker1124"/>when using reference types and not modify the object itself unless it needs to be done. In a multi-threaded application, if a reference to an object can be passed between threads, we must be extra careful because of the possibility of the same data being modified concurrently. On the bright side, though, such a shared area can be – and often is – used as the method of communication between threads. </p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Classloaders</h2>
			<p>The <a id="_idIndexMarker1125"/>classloader <a id="_idIndexMarker1126"/>performs the following three <a id="_idIndexMarker1127"/>functions:</p>
			<ul>
				<li>Reads a <strong class="source-inline">.class</strong> file</li>
				<li>Populates the method area</li>
				<li>Initializes static fields that haven’t been initialized by a programmer</li>
			</ul>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>Execution engine</h2>
			<p>The <a id="_idIndexMarker1128"/>execution engine does <a id="_idIndexMarker1129"/>the following:</p>
			<ul>
				<li>Instantiates objects in the heap area</li>
				<li>Initializes static and instance fields using initializers written by the programmer</li>
				<li>Adds/removes frames to/from the Java stack</li>
				<li>Updates the PC register with the next instruction to execute</li>
				<li>Maintains the native method stack</li>
				<li>Keeps count of method calls and compiles popular ones</li>
				<li>Finalizes objects</li>
				<li>Runs GC</li>
				<li>Terminates the application</li>
			</ul>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor224"/>Garbage collection</h1>
			<p>Automatic memory management is an important aspect of the JVM that relieves the programmer <a id="_idIndexMarker1130"/>from the need to do so programmatically. In Java, the process that cleans up memory and allows it to be reused is called <strong class="bold">GC</strong>.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor225"/>Responsiveness, throughput, and stop-the-world</h2>
			<p>The <a id="_idIndexMarker1131"/>effectiveness of GC affects two major application <a id="_idIndexMarker1132"/>characteristics – <strong class="bold">responsiveness</strong> and <strong class="bold">throughput</strong>:</p>
			<ul>
				<li><strong class="bold">Responsiveness</strong>: This is <a id="_idIndexMarker1133"/>measured by how quickly an application responds (brings the necessary data) to the request; for example, how quickly a website returns a page, or how quickly a desktop application responds to an event. The smaller the response time, the better the user experience.</li>
				<li><strong class="bold">Throughput</strong>: This indicates <a id="_idIndexMarker1134"/>the amount of work an application can do in a unit of time; for example, how many requests a web application can serve, or how many transactions the database can support. The bigger the number, the more value the application can potentially generate and the more user requests it can support.</li>
			</ul>
			<p>Meanwhile, GC needs to move data around, which is impossible to accomplish while allowing data processing to occur because the references are going to change. That’s why GC needs to stop application thread execution once in a while for a while. This is called <strong class="bold">stop-the-world</strong>. The longer <a id="_idIndexMarker1135"/>these periods are, the quicker GC does its job and the longer an application freeze lasts, which can eventually grow big enough to affect both the application’s responsiveness and throughput.</p>
			<p>Fortunately, it is possible to tune the GC’s behavior using Java command options, but that is outside the scope of this book. Instead, we will provide a high-level view of the main activity of GC – inspecting objects in the heap and removing those that don’t have references in any thread stack.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/>Object age and generation</h2>
			<p>The basic <a id="_idIndexMarker1136"/>GC algorithm determines <em class="italic">how old</em> each object is. The term <strong class="bold">age</strong> refers to the number of collection cycles the object has survived.</p>
			<p>When the JVM starts, the heap is empty and is divided into three sections:</p>
			<ul>
				<li>The young generation</li>
				<li>The old or tenured generation</li>
				<li>Humongous regions for holding objects that are 50% the size of a standard region or larger</li>
			</ul>
			<p>The young generation has three areas:</p>
			<ul>
				<li>An Eden space</li>
				<li>Survivor 0 (S0)</li>
				<li>Survivor 1 (S1)</li>
			</ul>
			<p>The newly created objects are placed in Eden. When it is filling up, a minor GC process starts. It removes the unreferred and circular referred objects and moves the others to the S1 area. During the next minor collection, S0 and S1 switch roles. The referenced objects are moved from Eden and S1 to S0.</p>
			<p>During each <a id="_idIndexMarker1137"/>of the minor collections, the objects that have reached a certain age are moved to the old generation. As a result of this algorithm, the old generation contains objects that are older than a certain age. This area is bigger than the young generation and, because of that, the GC process is more expensive and happens not as often as in the young generation. But it is checked eventually (after several minor collections). The unreferenced objects are removed and the memory is defragmented. Cleaning up the old generation is considered a major collection.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>When stop-the-world is unavoidable</h2>
			<p>Some <a id="_idIndexMarker1138"/>objects are collected in the old generation concurrently, while some are collected using stop-the-world pauses. The steps are as follows:</p>
			<ol>
				<li value="1"><strong class="bold">Initial marking</strong>: This marks the survivor regions (root regions) that may have references to objects in the old generation. This is done using a stop-the-world pause.</li>
				<li><strong class="bold">Scanning</strong>: This searches survivor regions for references to the old generation. This is done concurrently while the application continues to run.</li>
				<li><strong class="bold">Concurrent marking</strong>: This marks live objects over the entire heap and is done concurrently while the application continues to run.</li>
				<li><strong class="bold">Remark</strong>: At this stage, the live objects have been marked, which is done using a stop-the-world pause.</li>
				<li><strong class="bold">Cleanup</strong>: This calculates the age of live objects, frees regions (using stop-the-world), and returns them to the free list. This is done concurrently.</li>
			</ol>
			<p>To help <a id="_idIndexMarker1139"/>with GC tuning, the JVM provides platform-dependent default selections for the garbage collector, heap size, and runtime compiler. But fortunately, the JVM vendors improve and tune the GC process all the time, so most of the applications work just fine with the default GC behavior.</p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/>Summary</h1>
			<p>In this chapter, you learned how a Java application can be executed using an IDE or the command line. Now, you can write applications and launch them in a manner that’s appropriate for the given environment. Knowledge about the JVM structure and its processes – classloading, linking, initialization, execution, GC, and application termination – provided you with better control over the application’s execution and transparency regarding the performance and current state of the JVM.</p>
			<p>In the next chapter, we will discuss and demonstrate how to manage – insert, read, update, and delete – data in a database from a Java application. We will also provide a short introduction to the SQL language and its basic database operations, including how to connect to a database, how to create the database’s structure, how to write database expressions using SQL, and how to execute them.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor229"/>Quiz</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">Select all of the correct statements:<ol><li> An IDE executes Java code without compiling it.</li><li>An IDE uses installed Java to execute the code.</li><li>An IDE checks the code without using the Java installation.</li><li>An IDE uses the compiler of the Java installation.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>All the classes that are used by the application must be listed on the classpath.</li><li>The locations of all the classes that are used by the application must be listed on the classpath.</li><li>The compiler can find a class if it is in the folder that’s listed on the classpath.</li><li>The classes of the main package do not need to be listed on the classpath.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>All the <strong class="source-inline">.jar</strong> files that are used by the application must be listed on the classpath.</li><li>The locations of all the <strong class="source-inline">.jar</strong> files that are used by the application must be listed on the classpath. </li><li>The JVM can only find a class if it is in the <strong class="source-inline">.jar</strong> file that’s listed on the classpath.</li><li>Every class can contain the <strong class="source-inline">main()</strong> method.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>Every <strong class="source-inline">.jar</strong> file that contains a manifest is executable. </li><li>If the <strong class="source-inline">-jar</strong> option is used by the <strong class="source-inline">java</strong> command, the classpath option is ignored.</li><li>Every <strong class="source-inline">.jar</strong> file has a manifest.</li><li>An executable <strong class="source-inline">.jar</strong> is a ZIP file with a manifest.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>Classloading and linking can work in parallel on different classes.</li><li>Classloading moves the class to the execution area.</li><li>Class linking connects two classes.</li><li>Class linking uses memory references.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>Class initialization assigns values to instance properties.</li><li>Class initialization happens every time the class is referred to by another class.</li><li>Class initialization assigns values to static properties.</li><li>Class initialization provides data to the instance of <strong class="source-inline">java.lang.Class</strong>.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>Class instantiation may never happen.</li><li>Class instantiation includes object property initialization.</li><li>Class instantiation includes memory allocation on a heap.</li><li>Class instantiation includes executing constructor code.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>Method execution includes binary code generation.</li><li>Method execution includes source code compilation.</li><li>Method execution includes reusing the binary code that’s produced by the JIT compiler.</li><li>Method execution counts how many times every method was called.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>Garbage collection starts immediately after the <strong class="source-inline">System.gc()</strong> method is called.</li><li>The application can be terminated with or without an error code.</li><li>The application exits as soon as an exception is thrown.</li><li>The main thread is a user thread.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>The JVM has memory areas shared across all threads.</li><li>The JVM has memory areas not shared across threads.</li><li>Class metadata is shared across all threads.</li><li>Method parameter values are not shared across threads.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>The classloader populates the method area.</li><li>The classloader allocates memory on a heap.</li><li>The classloader writes to the <strong class="source-inline">.class</strong> file.</li><li>The classloader resolves method references.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>The execution engine allocates memory on a heap.</li><li>The execution engine terminates the application.</li><li>The execution engine runs garbage collection.</li><li>The execution engine initializes static fields that haven’t been initialized by a programmer.</li></ol></li>
				<li>Select all of the correct statements: <ol><li>The number of transactions per second that a database can support is a throughput measure.</li><li>When the garbage collector pauses the application, it is called stop-all-things.</li><li>How slowly the website returns data is a responsiveness measure.</li><li>The garbage collector clears the CPU queue of jobs. </li></ol></li>
				<li>Select all of the correct statements: <ol><li>Object age is measured by the number of seconds since the object was created.</li><li>The older the object, the more probable it is going to be removed from memory.</li><li>Cleaning the old generation is a major collection.</li><li>Moving an object from one area of the young generation to another area of the young generation is a minor collection.</li></ol></li>
				<li>Select all of the correct statements:<ol><li>The garbage collector can be tuned by setting the parameters of the <strong class="source-inline">javac</strong> command.</li><li>The garbage collector can be tuned by setting the parameters of the <strong class="source-inline">java</strong> command.</li><li>The garbage collector works with its logic and cannot change its behavior based on the set parameters.</li><li>Cleaning the old generation area requires a stop-the-world pause.</li></ol></li>
			</ol>
		</div>
	</body></html>