- en: Message Enrichment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fully understand this chapter, it is necessary to have read the previous
    chapter that focused on how to validate events. This chapter is focused on how
    to enrich events.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will continue using the systems of Monedero, our fictitious
    company that is dedicated to the exchange of cryptocurrencies. If we remember
    in the previous chapter, the messages of Monedero were validated; in this chapter,
    we will continue with the same flow, but we will add one more step of enrichment.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, we understand enrichment as adding extra data that was not
    in the original message. In this chapter, we will see how to enrich a message
    with geographic location using the MaxMind database and how to extract the current
    value of the exchange rate using the Open Exchange data. If we remember the events
    that we modeled for Monedero, each one included the IP address of the customer's
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the MaxMind free database that provides us with
    an API that contains a mapping of IP addresses to their geographic location.
  prefs: []
  type: TYPE_NORMAL
- en: Our system in Monedero searches for the IP address of our customer in the MaxMind
    database to determine where the customer is located when the request to our system
    was made. The use of data from external sources to add them to our events is what
    we call message enrichment.
  prefs: []
  type: TYPE_NORMAL
- en: In the cryptocurrencies world, there is something called Bit License, in which
    some geographic areas are limited by law to carry out activities with cryptocurrencies.
    We currently have an event validation service for Monedero.
  prefs: []
  type: TYPE_NORMAL
- en: However, the legal department has asked us to have a validation filter to know
    the geographic location of our customers and thus be able to comply with the Bit
    License. The Bit License has operated in the New York area since July 2014 and
    applies to residents. Under the terms of the law, those considered resident are
    all of the people who reside, are located, have a place of business, or conduct
    business in the state of New York.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How extraction works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How enrichment works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the location given an IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the currency price given a currency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the weather data given a location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enriching messages with the geographic location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enriching messages with a currency price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a processing engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the geographic location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `build.gradle` file on the Monedero project created in [Chapter 2](0f0c3c87-3860-4247-97b7-3ce070640dc3.xhtml),
    *Message Validation*, and add the lines highlighted in *Listing 3.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 3.1*, the Monedero `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.1: build.gradle'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the first change is the switch from version 0.1.0 to version 0.2.0
    .
  prefs: []
  type: TYPE_NORMAL
- en: The second change is to add the MaxMind's GeoIP version 1.3.1 to our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the project root directory, run the following command to rebuild the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To download a copy of the MaxMind GeoIP free database, execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to decompress the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Move the `GeoLiteCity.dat` file in a route accessible to our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a file called `GeoIPService.java` in the `src/main/java/monedero/extractors`
    directory containing the content of *Listing 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.2: GeoIPService.java'
  prefs: []
  type: TYPE_NORMAL
- en: The `GeoIPService` has a public method `getLocation` that receives a string
    representing the IP address and looks for this IP address in the GeoIP location
    database. This method returns an object of class location with the geographic
    location of that specific IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are sometimes demanding customers who ask to have the most updated version
    of the database. In this case, downloading the database continuously is not an
    option. For this type of case, MaxMind exposes its services through an API. To
    read more about it, visit the following URL: [https://dev.maxmind.com/](https://dev.maxmind.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To read more about Bit License regulations, visit the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.dfs.ny.gov/legal/regulations/bitlicense_reg_framework.html](http://www.dfs.ny.gov/legal/regulations/bitlicense_reg_framework.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Enriching the messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will recap the steps of our processing engine for Monedero. The customer
    consults the ETH price in the client's browser and is sent to Kafka through some
    HTTP event collector.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in our flow is the event correctness validation; remember from
    the previous chapter that the messages with defects are derived from bad data
    and that is why they are filtered. The second step now is to enrich our message
    with geographic location information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the architecture steps for the Monedero processing engine:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the individual events from a Kafka topic called **input-messages**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the message, sending any defective event to a dedicated Kafka topic
    called **invalid-messages**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enrich the message with the geographic location data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the enriched messages in a Kafka topic called **valid-messages**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of these steps of the second version of the stream processing engine are
    detailed in *Figure 3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b129c45-0cc2-4454-ab78-56f2fb37b947.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The processing engine reads the events from the input-messages
    topic, validates the messages, sends the errors to invalid-messages topic, enriches
    the messages with geographic location, and then writes them to the valid-messages
    topic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a file called `Enricher.java` in the `src/main/java/monedero/`
    directory with the content of *Listing 3.**3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the `Enricher` class implements the producer interface; therefore
    the `Enricher` is a producer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's fill the code of the `process()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the customer message does not have an IP address, the message is automatically
    sent to `invalid-messages` topic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Enricher` class invokes the `getLocation` method of `GeoIPService` , as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The country and the city of the location are added to the customer message,
    as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The enriched message is written to the `valid-messages` queue, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the location object brings more interesting data; for this example,
    just the city and the country are extracted. For example, the MaxMind database
    can give us much more precision than the one exploited in this example. In effect,
    the online API can accurately show the exact location of an IP.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that here we have a very simple validation. In the next chapter, we
    will see how to validate the schema correctness. For the moment, think of other
    validations that are missing to have a system that meets the business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the currency price
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, Monedero has a service that validates the messages that are well
    formed. The service also enriches the messages with the customer's geographic
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the Monedero core business is the cryptocurrencies exchange. So
    now, the business asks us for a service that returns the requested currency price
    online at a specific time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we will use the exchange rate of open exchange rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://openexchangerates.org/](https://openexchangerates.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a free API key, you have to register in a free plan; the key is needed
    to access the free API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a file called `OpenExchangeService.java` in the `src/main/java/monedero/extractors`
    directory with the content of *Listing 3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Some lines of the `OpenExchangeService` class can be analyzed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, the value of the `API_KEY` is assigned when you registered in
    the open exchange rates page; the free plan gives you up to 1,000 requests per
    month.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In line `//2`, our class invokes the open exchange API URL, using your `API_KEY`.
    To check the prices at the moment, you can access the URL (counts as a request
    with your key): [https://openexchangerates.org/api/latest.json?app_id=YOUR_API_KEY](https://openexchangerates.org/api/latest.json?app_id=YOUR_API_KEY).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, the currency string passed as argument is searched in the JSON
    tree that returns the web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, the currency price (in US dollars) of the currency passed as
    an argument is returned as a double value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several ways to parse JSON, and whole books are devoted to this topic.
    For this example, we used Jackson to parse JSON. To find more information, go
    to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/FasterXML](https://github.com/FasterXML)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the MaxMind geographic localization service, open exchange rates also
    expose their services through an API. To read more about this, go to the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.openexchangerates.org/](https://docs.openexchangerates.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses the open exchange rates free plan; if a non-limited API is
    required, check their other plans in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://openexchangerates.org/signup](https://openexchangerates.org/signup)'
  prefs: []
  type: TYPE_NORMAL
- en: Enriching with currency price
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The customer consults the ETH price event, starts in the client's web browser,
    and is dispatched to Kafka through some HTTP event collector. The second step
    is to enrich the messages with the geographic location information from MaxMind
    database. The third step is to enrich the message with the currency price from
    open exchange rates service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, here are the architecture steps for the Monedero processing engine:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the individual events from a Kafka topic called **input-messages**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the message, sending any defective event to a specific Kafka topic
    called **invalid-messages**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enrich the message with the geographic location data from MaxMind database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enrich the message with the currency price from open exchange rates service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the enriched messages in a Kafka topic called **valid-messages**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final version of the stream processing engine is detailed in *Figure 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b4dd6ce-00f0-4d3c-8d7e-5fec1a08b290.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: The processing engine reads the messages from the input-messages
    topic, validates the messages, routes the defective ones to invalid-messages queue,
    enriches the messages with geographic location and price, and finally, writes
    them to valid-messages queue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the open exchange rates service to our engine, modify the `Enricher.java`
    file in the `src/main/java/monedero/` directory with the changes highlighted in
    *Listing 3.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, the `Enricher` class is a Kafka producer, so now let''s analyze
    the additions:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, we import `OpenExchangeService` built previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, to avoid later null pointer exceptions, if the message does not
    have a valid IP Address on customer, the message automatically is sent to the
    `invalid-messages` queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, generates an instance of the `OpenExchangeService` class that
    is an extractor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In line `//4`, the `getPrice()` method of the `OpenExchangeService` class is
    called, and this value is added to the message: the price of the currency is added
    to the currency node in the leaf price'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, the enriched message is written to the `valid-messages` queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the final version of the enricher engine for Monedero; as we can see,
    the pipeline architecture uses the extractors as input for the enricher. Next,
    we will see how to run our entire project.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the JSON response has a lot of more information, but for this example,
    only one currency price is used. There are several open data initiatives that
    are free and provide a lot of free repositories with online and historical data.
  prefs: []
  type: TYPE_NORMAL
- en: Running the engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the final version of the `Enricher` class is coded, we have to compile
    and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, the `ProcessingEngine` class contains the main method to coordinate
    the reader and writer classes. Now, let''s modify the `ProcessingEngine.java`
    file on the `src/main/java/monedero/` directory and replace `Validator` with `Enricher`
    as in the highlighted code in *Listing 3.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.6: ProcessingEngine.java'
  prefs: []
  type: TYPE_NORMAL
- en: 'The processing engine receives the following five arguments from the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`args[0]` `servers` indicates the host and port of the Kafka broker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[1]` `groupId` indicates that the consumer is part of this Kafka consumer
    group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[2]` `input topic` indicates the topic where the reader reads from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[3]` `validTopic` indicates the topic where valid messages are sent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[4]` `invalidTopic` indicates the topic where invalid messages are sent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To rebuild the project from the `monedero` directory, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is OK, the output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the project, we need four different command-line windows. *Figure 3.3*
    shows the command-line windows arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b86f2503-f885-4cf8-aa64-d54022cdd74d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: The four terminal windows to test the processing engine including:
    message producer, valid message consumer, invalid message consumer, and the processing
    engine itself'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first command-line terminal, go to the Kafka installation directory
    and generate the two necessary topics, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start a console producer to the `input-topic` topic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This window is where the input messages are produced (typed).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second command-line window, start a command-line consumer listening
    to the `valid-messages` topic, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the third command-line window, start a command-line consumer listening to
    `invalid-messages` topic, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the fourth command-line terminal, start up the processing engine. From the
    project root directory (where the `gradle jar` command were executed) run this
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'From the first command-line terminal (the console producer), send the following
    three messages (remember to type enter between messages and execute each one in
    just one line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As these are valid messages, the messages typed in the producer console should
    appear in the valid-messages consumer console window, as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Extracting the weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obtaining the geographic location from the IP address is a problem that has
    already been solved in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this last section, we will build another extractor that will be used in the
    following chapters. Now, suppose we want to know the current temperature of a
    given a geographic location at a specific time. To achieve this, we use the OpenWeatherService.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the Open Weather page: [https://openweathermap.org/](https://openweathermap.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a free API key register in a free plan; this key is needed to access
    the free API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a file called `OpenWeatherService.java` in the `src/main/java/monedero/extractors`
    directory with the content of *Listing 3.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.7: OpenWeatherService.java'
  prefs: []
  type: TYPE_NORMAL
- en: The public method, `getTemperature()`, in the `OpenWeatherService` class receives
    two string values—the geographic latitude and longitude—and returns the current
    temperature for these locations. If the metric system is specified, the result
    will be in degrees celsius.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, the file includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, to use the Open Weather API, a KEY is needed, registration is
    free, and gives 1,000 requests per month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In line `//2`, to check the current weather at a particular location, open
    the following URL: [http://api.openweathermap.org/data/2.5/weather? lat=LAT&lon=LON&units=metric&appid=YOUR_API_KEY](http://api.openweathermap.org/data/2.5/weather?%C2%A0lat=LAT&lon=LON&units=metric&appid=YOUR_API_KEY)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, the JSON returned by this URL is parsed looking for the temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open Weather also exposes their services through an API. To read how to use
    this API, go to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://openweathermap.org/api](https://openweathermap.org/api)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to make data extraction, how message enrichment
    works, and how to extract the geographic location given an IP Address. Also, we
    demonstrated an example of how to extract the currency price given a currency
    and running a processing engine.
  prefs: []
  type: TYPE_NORMAL
- en: The [Chapter 4](b444c6b4-4a8f-478c-9d3f-93a432d168b8.xhtml), *Serialization*,
    talks about the schema registry. The extractors built in this chapter are used
    in the following chapters.
  prefs: []
  type: TYPE_NORMAL
