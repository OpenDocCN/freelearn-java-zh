- en: Chapter 7. Publishing to an Ivy Repository
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：发布到Ivy仓库
- en: You learned in a previous chapter how we can publish our project artifacts to
    a Maven repository. In this chapter, we are going to use an Ivy repository to
    which we can publish.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，您学习了如何将我们的项目工件发布到Maven仓库。在本章中，我们将使用一个Ivy仓库进行发布。
- en: Just as with publishing to a Maven repository, we are going to use the new and
    incubating publishing feature in Gradle to publish to an Ivy repository.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像发布到Maven仓库一样，我们将使用Gradle中新的和孵化中的发布功能来发布到Ivy仓库。
- en: Defining publications
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义发布内容
- en: We must add the `ivy-publish` plugin to our project to be able to publish our
    artifacts to an Ivy repository. The plugin allows us to use the Ivy format to
    describe our artifacts that need to be published.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将`ivy-publish`插件添加到我们的项目中，以便能够将我们的工件发布到Ivy仓库。该插件允许我们使用Ivy格式来描述需要发布的工件。
- en: The `ivy-publish` plugin is based on the general `publishing` plugin. The `publishing`
    plugin adds a new `publishing` extension to our project. We can use a `publications`
    configuration block in our build script to configure the artifacts we want to
    publish and the repositories we want to deploy to. The `publications` extension
    has the `PublishingExtension` type in the `org.gradle.api.publish` package. The
    plugin also adds a general life cycle `publish` task to the project. Other tasks
    can be added as task dependencies to this task, so with a single `publish` task,
    all the project's publications can be published.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`ivy-publish`插件基于通用的`publishing`插件。`publishing`插件为我们项目添加了一个新的`publishing`扩展。我们可以在构建脚本中使用`publications`配置块来配置我们想要发布的工件和想要部署到的仓库。`publications`扩展在`org.gradle.api.publish`包中有`PublishingExtension`类型。该插件还向项目添加了一个通用的生命周期`publish`任务。可以将其他任务作为任务依赖添加到这个任务中，因此，通过单个`publish`任务，可以发布项目的所有发布内容。'
- en: The `ivy-publish` plugins also adds some extra task rules to the project. There
    is a task to generate an Ivy descriptor file to each publication in the project.
    The plugins also add a task rule based on a combination of the publication and
    the repository to publish a publication to the specified repository.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`ivy-publish`插件还为项目添加了一些额外的任务规则。有一个任务用于为项目中的每个发布内容生成Ivy描述符文件。插件还基于发布内容和仓库的组合添加了一个任务规则，用于将发布内容发布到指定的仓库。'
- en: 'Let''s create an example build file and apply the `ivy-publish` plugin to see
    the new task:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例构建文件，并将`ivy-publish`插件应用到项目中，以查看新任务：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will invoke the `tasks` task from the command line:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从命令行调用`tasks`任务：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the output, we see the `publish` task. The dynamic task rules to publish
    single publications to repositories are not shown.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们看到`publish`任务。用于将单个发布内容发布到仓库的动态任务规则没有显示。
- en: To configure our publications, we must first add a `publishing` configuration
    block. Inside the block, we will define the `publications` configuration block.
    In this block, we define a publication. A publication defines what needs to be
    published. The `ivy-publish` plugin expects that a publication of the `IvyPublication`
    type is found in the `org.gradle.api.publish.ivy` package. Besides the artifacts
    that need to be published, we can also define details for the generated Ivy descriptor
    file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的发布内容，我们首先需要添加一个`publishing`配置块。在该块内部，我们将定义`publications`配置块。在这个块中，我们定义一个发布内容。发布内容定义了需要发布的内容。`ivy-publish`插件期望在`org.gradle.api.publish.ivy`包中找到一个`IvyPublication`类型的发布内容。除了需要发布的工件之外，我们还可以定义生成的Ivy描述符文件的详细信息。
- en: Defining publication artifacts
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义发布工件
- en: A publication we define must have a unique name in our project. We can add multiple
    publications with their own name inside a `publications` configuration block.
    To add an artifact, we can use the `artifact` method in the publication definition.
    We can also use the `artifacts` property to directly set all artifacts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的发布内容必须在我们的项目中具有唯一名称。我们可以在`publications`配置块内部添加多个具有自己名称的发布内容。要添加工件，我们可以在发布内容定义中使用`artifact`方法。我们还可以使用`artifacts`属性直接设置所有工件。
- en: 'We can define the artifact with the `artifact` method in the ways described
    in the following table:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下表格中描述的方式，使用`artifact`方法定义工件：
- en: '| Type | Description |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AbstractArchiveTask` | The information for the artifact is extracted from
    the archive task. The artifact is an instance of `PublishArtifact` in the `org.gradle.api.artifacts`
    package. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `AbstractArchiveTask` | 工件信息是从归档任务中提取的。工件是`org.gradle.api.artifacts`包中的`PublishArtifact`实例。|'
- en: '| `File` | The information for the artifact is extracted from the filename.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `File` | 工件的信息是从文件名中提取的。|'
- en: '| `Map` | This is another way to define artifacts. The map must contain a `source`
    key referencing a file or archive task and other properties we can use, such as
    `classifier` and `extension`, to further configure the artifact. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | 这是一种定义工件的其他方式。该映射必须包含一个`source`键，它引用一个文件或归档任务，以及其他我们可以使用的属性，例如`classifier`和`extension`，以进一步配置工件。|'
- en: Using archive task artifacts
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用归档任务工件
- en: 'In the following example build file, we define a new publication with the `publishJar`
    name and we define the output of the `jar` archive task as an artifact:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们定义了一个名为`publishJar`的新出版物，并定义了`jar`归档任务的输出作为工件：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we run the `tasks` task, and in the output, we see new generated tasks
    to publish this publication:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行`tasks`任务，并在输出中我们看到为发布此出版物生成的新任务：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the extra task, `generateDescriptorFileForPublishJarPublication`. The
    name of the `publishJar` publication is used for this task. Gradle uses the following
    pattern for a task to generate an Ivy descriptor XML file for a `generateDescriptorFileFor<publicationName>Publication`
    publication. We cannot yet invoke the task because we also need to set the `group`
    and `version` project properties, but we will see this in the section about generating
    an Ivy descriptor file. We will now focus on defining the artifacts for a publication
    in this section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意额外的任务，`generateDescriptorFileForPublishJarPublication`。这个任务的名称用于`publishJar`出版物。Gradle使用以下模式为`generateDescriptorFileFor<publicationName>Publication`出版物生成一个任务以生成Ivy描述符XML文件。我们目前还不能调用这个任务，因为我们还需要设置`group`和`version`项目属性，但我们将在这部分关于生成Ivy描述符文件的章节中看到这一点。现在，我们将专注于在本节中定义出版物的工件。
- en: We are not restricted to one artifact for a publication; we can add more by
    invoking the `artifact` method multiple times. We can even use the `artifacts`
    property to assign multiple artifacts. It is important that each artifact has
    unique `classifier` and `extension` property values for a single publication.
    Gradle will check this before we can invoke any tasks, so we immediately get an
    error message when the artifacts don't have a unique combination of `classifier`
    and `extensions` property values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不局限于为出版物使用一个工件；我们可以通过多次调用`artifact`方法来添加更多。我们甚至可以使用`artifacts`属性来分配多个工件。对于单个出版物，每个工件都必须具有唯一的`classifier`和`extension`属性值。在我们可以调用任何任务之前，Gradle会检查这一点，所以当工件没有唯一的`classifier`和`extensions`属性值的组合时，我们会立即收到错误信息。
- en: 'In the following example build file, we add two extra artifacts to our publication
    with the `artifact` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们使用`artifact`方法向我们的出版物添加了两个额外的工件：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of using the `artifact` method, we can also use the `artifacts` property
    and assign multiple artifacts. Each of the artifacts we assign must have a unique
    combination of `classifier` and `extension` property values. In the next example
    build file, we will use the same artifacts as in the previous example, but this
    time, we will assign them to the `artifacts` property:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`artifact`方法之外，我们还可以使用`artifacts`属性并分配多个工件。我们分配的每个工件都必须具有唯一的`classifier`和`extension`属性值的组合。在下一个示例构建文件中，我们将使用与上一个示例相同的工件，但这次我们将它们分配给`artifacts`属性：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using file artifacts
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件工件
- en: Instead of an archive task, we can also use a file as an artifact. Gradle tries
    to extract the `extension` and `classifier` properties from the filename. We can
    also configure these properties ourselves when we add the file as a publication
    artifact.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了归档任务之外，我们还可以使用文件作为工件。Gradle会尝试从文件名中提取`extension`和`classifier`属性。当我们添加文件作为发布工件时，我们也可以自己配置这些属性。
- en: 'In the following example build file, we use the `src/files/README` and `src/files/COPYRIGHT`
    files as a publication artifact:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们使用`src/files/README`和`src/files/COPYRIGHT`文件作为发布工件：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using software components
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用软件组件
- en: Besides the `artifact` method and the `artifacts` property, we can also use
    the `from` method inside a `publications` configuration block. We specify a Gradle
    `SoftwareComponent` object as an argument to the `from` method. The `java` plugin
    adds a `SoftwareComponent` object with the name `java`, and it includes the `jar`
    artifact and all runtime dependencies. The `war` plugin adds the `war` artifact
    as a `SoftwareComponent` object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`artifact`方法和`artifacts`属性外，我们还可以在`publications`配置块中使用`from`方法。我们指定一个Gradle
    `SoftwareComponent`对象作为`from`方法的参数。`java`插件添加了一个名为`java`的`SoftwareComponent`对象，它包括`jar`归档任务和所有运行时依赖项。`war`插件添加了`war`归档任务作为`SoftwareComponent`对象。
- en: 'In the next example build file, we will apply the `war` plugin to our project.
    The `war` plugin extends the `java` plugin, so we will also implicitly apply the
    `java` plugin to our project. We will also define two publications, with each
    using the `SoftwareComponent` object from both plugins:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将`war`插件应用到我们的项目中。`war`插件扩展了`java`插件，因此我们也将隐式地应用到我们的项目中`java`插件。我们还将定义两个发布，每个都使用来自两个插件的`SoftwareComponent`对象：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Generating Ivy descriptor files
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成Ivy描述符文件
- en: An important part of an Ivy publication is the descriptor file. We already saw
    that Gradle added a `generateDescriptorFile<publicationName>` task to our project.
    Furthermore, we can define some properties of the descriptor file inside a publication
    configuration. Gradle also offers a hook to customize the generated descriptor
    file even further.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ivy发布的的一个重要部分是描述符文件。我们已经看到Gradle为我们项目添加了一个`generateDescriptorFile<publicationName>`任务。此外，我们可以在发布配置中定义描述符文件的一些属性。Gradle还提供了一个钩子来进一步自定义生成的描述符文件。
- en: 'Gradle uses the project''s `version`, `group`, `name`, and `status` properties
    for the `info` element in the Ivy descriptor file generated. We will create a
    new example build file where we define the project properties, so they will be
    included in the file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle使用项目的`version`、`group`、`name`和`status`属性在生成的Ivy描述符文件中的`info`元素。我们将创建一个新的示例构建文件，在其中定义项目属性，因此它们将被包含在文件中：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we execute the `generateDescriptorFileForSamplePublication` task. An `ivy.xml`
    file is created in the `build/publications/sample` directory. If we open the file,
    we can see that the `info` element attributes are filled with the values from
    our Gradle build file. The following code shows this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们执行`generateDescriptorFileForSamplePublication`任务。在`build/publications/sample`目录中创建了一个`ivy.xml`文件。如果我们打开文件，我们可以看到`info`元素属性被填充了来自我们的Gradle构建文件中的值。下面的代码显示了这一点：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can override the values for `organisation`, `module`, `revision`, `status`,
    and `branch` inside a publication configuration. We need to set the properties
    in the configuration block of `IvyPublication`. The `status` and `branch` properties
    need to be set via the `descriptor` property. Via the `descriptor` property, we
    can also add new child elements to the `info` element in the Ivy descriptor file.
    In the next example build file, we will use these methods to set the values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在发布配置中覆盖`organisation`、`module`、`revision`、`status`和`branch`的值。我们需要在`IvyPublication`的配置块中设置属性。`status`和`branch`属性需要通过`descriptor`属性设置。通过`descriptor`属性，我们还可以向Ivy描述符文件中的`info`元素添加新的子元素。在下一个示例构建文件中，我们将使用这些方法来设置值：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We execute the `generateDescriptorFileForSamplePublication` task again, as
    shown in the following code, and we see the new values in the generated Ivy descriptor
    file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次执行`generateDescriptorFileForSamplePublication`任务，如下面的代码所示，我们可以在生成的Ivy描述符文件中看到新的值：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The dependencies of our project are added as dependencies in the generated descriptor
    file. This happens because we use the `from` method with the `components.java`
    value inside our publication configuration. The Java software component not only
    adds the `jar` archive tasks as an artifact, but also turns the project dependencies
    into dependencies in the descriptor file. If we use an archive task to define
    an artifact, the `dependencies` element is not added to the file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的依赖项被添加到生成的描述符文件中的依赖项中。这是因为我们在发布配置中使用`from`方法并指定`components.java`值。Java软件组件不仅添加了`jar`归档任务作为归档，还将项目依赖项转换为描述符文件中的依赖项。如果我们使用归档任务来定义归档，则不会添加`dependencies`元素。
- en: 'In the following example build file, we use the `artifact` method to define
    the publication:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例构建文件中，我们使用`artifact`方法来定义发布：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run the `generateDescriptorFileForSamplePublication` task from the
    command line, the Ivy descriptor file is generated. The contents of the file are
    now as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从命令行运行`generateDescriptorFileForSamplePublication`任务时，Ivy描述符文件被生成。现在文件的内容如下：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next section, you will learn how we can customize the descriptor using
    the `withXml` method of the `descriptor` property. We can then, for example, also
    change the dependency scope of our project dependencies.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何使用`descriptor`属性的`withXml`方法来自定义描述符。然后，例如，我们还可以更改项目依赖项的依赖范围。
- en: Customizing the descriptor file
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义描述符文件
- en: To add extra elements to the generated file, we must use the `descriptor` property
    that is part of `IvyPublication`. This returns an `IvyModuleDescriptorSpec` object,
    and we will invoke the `withXml` method from this object to add extra elements
    to the descriptor file. We use a closure with the `withXml` method to access an
    `XmlProvider` object. With the `XmlProvider` object, we can get a reference to
    a DOM element with the `asElement` method, a Groovy node object with the `asNode`
    method, or a `StringBuilder` object with the `asString` method to extend the descriptor
    XML.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要向生成的文件中添加额外元素，我们必须使用`IvyPublication`的一部分`descriptor`属性。这返回一个`IvyModuleDescriptorSpec`对象，我们将从这个对象调用`withXml`方法来向描述符文件添加额外元素。我们使用一个闭包与`withXml`方法来访问一个`XmlProvider`对象。有了`XmlProvider`对象，我们可以通过`asElement`方法获取一个DOM元素的引用，通过`asNode`方法获取一个Groovy节点对象，或者通过`asString`方法获取一个`StringBuilder`对象来扩展描述符XML。
- en: 'In the following example build file, we add the `description` and `issueMangement`
    elements to the generated descriptor file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们将`description`和`issueMangement`元素添加到生成的描述符文件中：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we generate the Ivy descriptor file, we can see our newly created elements
    in the XML version:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们生成Ivy描述符文件，我们可以在XML版本中看到我们新创建的元素：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous section, you already learned that if we use the `from` method
    with the `components.java` value, all project dependencies are added as runtime
    dependencies in the generated descriptor file. This might not be what we always
    want. Using the `withXml` method, we can not only add new elements, but also change
    values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你已经了解到，如果我们使用带有`components.java`值的`from`方法，所有项目依赖项都会被添加到生成的描述符文件中作为运行时依赖项。这可能不是我们总是想要的。使用`withXml`方法，我们不仅可以添加新元素，还可以更改值。
- en: 'Let''s add a hook where we change the module attribute of the info element.
    In the next build file, we will implement this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在info元素中更改模块属性的地方添加一个钩子。在下一个构建文件中，我们将实现这一点：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The generated descriptor file now has the following contents:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的描述符文件现在有以下内容：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Defining repositories
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义仓库
- en: We must configure an Ivy repository to publish our configured publication. We
    can choose a local directory or a repository manager, such as Artifactory or Nexus.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须配置一个Ivy仓库来发布我们的配置出版物。我们可以选择本地目录或仓库管理器，如Artifactory或Nexus。
- en: Publishing to a local directory
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到本地目录
- en: If we have a directory where we want to publish our publications, we must add
    it to the `publishing` configuration block. Inside the block, we add a `repositories`
    configuration block containing one or more named repositories. For the combination
    of each publication and repository, Gradle creates a task with the `publish<publicationName>To<repositoryName>Repository`
    name pattern.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个想要发布我们出版物的目录，我们必须将其添加到`publishing`配置块中。在块内部，我们添加一个包含一个或多个命名仓库的`repositories`配置块。对于每个出版和仓库的组合，Gradle都会创建一个名为`publish<publicationName>To<repositoryName>Repository`的任务。
- en: 'We define a simple directory repository in the next example build file with
    the name `localRepo`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们定义一个名为`localRepo`的简单目录仓库：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, we run the `tasks` task to see which task is added to the `Publishing
    tasks` group:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们运行`tasks`任务来查看哪些任务被添加到`Publishing tasks`组：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To publish our project''s artifact, we can execute the `publishPublishJarPublicationToLocalRepoRepository`
    or `publish` tasks. The following output shows the tasks that are executed:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布我们的项目工件，我们可以执行`publishPublishJarPublicationToLocalRepoRepository`或`publish`任务。以下输出显示了执行的任务：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the task has been run, we get the following files in the `build/localRepo`
    directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任务运行完成，我们将在`build/localRepo`目录中获得以下文件：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Publishing to Artifactory
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到Artifactory
- en: To publish our publications to an Artifactory repository, we only have to configure
    the repository in the `publications.repositories` configuration block. We can
    set the `url` property, a `name`, and optional security credentials.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的发布内容发布到Artifactory存储库，我们只需在`publications.repositories`配置块中配置存储库。我们可以设置`url`属性、一个`name`以及可选的安全凭据。
- en: 'In the next example build file, we will use an Artifactory repository to publish
    the publication to:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将使用Artifactory存储库来发布发布内容：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Gradle creates a new task, `publishPublishJarPublicationToArtifactoryRepository`,
    based on the publication name and the repository name. When we invoke the task,
    we can see that the publication is deployed to the Artifactory repository, as
    shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle根据发布名称和存储库名称创建了一个新的任务`publishPublishJarPublicationToArtifactoryRepository`。当我们调用该任务时，我们可以看到发布已部署到Artifactory存储库，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we open the Artifactory web application in a web browser, we can see that
    our project is now part of the repository, as shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Web浏览器中打开Artifactory Web应用程序时，我们可以看到我们的项目现在是存储库的一部分，如下面的截图所示：
- en: '![Publishing to Artifactory](img/image00139.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![发布到Artifactory](img/image00139.jpeg)'
- en: Publishing to Nexus
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到Nexus
- en: Another repository manager is Nexus. To publish to a Nexus repository manager
    is not much different from publishing to Artifactory or the local directory. We
    only have to change the `url` property to reference the repository and set the
    correct optional security credentials.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个存储库管理器是Nexus。将发布到Nexus存储库管理器与发布到Artifactory或本地目录没有太大区别。我们只需更改`url`属性以引用存储库并设置正确可选的安全凭据。
- en: 'In the following example build file, we use a Nexus repository manager:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们使用Nexus存储库管理器：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This time, the `publishPublishJarPublicationToNexusRepository` task is created.
    The task is also added as a task dependency to the `publish` task. The following
    code shows this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，创建了`publishPublishJarPublicationToNexusRepository`任务。该任务也被添加为`publish`任务的依赖任务。以下代码展示了这一点：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we take a look at the Nexus web application inside the repository, we
    can see that our project is added to the repository, as shown in the following
    screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看存储库中的Nexus Web应用程序时，我们可以看到我们的项目已添加到存储库中，如下面的截图所示：
- en: '![Publishing to Nexus](img/image00140.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![发布到Nexus](img/image00140.jpeg)'
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use the new and incubating `ivy-publish`
    plugin. You saw how we can declare our publications with the `publications` configuration
    block. Gradle will automatically create new tasks based on what we have declared
    as publications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用新的孵化`ivy-publish`插件。您看到了如何使用`publications`配置块声明我们的发布内容。Gradle将自动创建基于我们声明的发布内容的新任务。
- en: You also learned how to customize the Ivy descriptor file that is generated
    by Gradle publishing tasks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了如何自定义Gradle发布任务生成的Ivy描述符文件。
- en: Finally, you saw how we can configure repositories to deploy our publications
    to. We used a local directory using the `file` protocol, and we used the Artifactory
    and Nexus repository managers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您看到了我们如何配置存储库以部署我们的发布内容。我们使用了`file`协议的本地目录，并使用了Artifactory和Nexus存储库管理器。
- en: In this book, we saw how we can define the dependencies we need in our project.
    You learned how to customize the dependency resolution and how to define the repositories
    that store the dependencies.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们看到了我们如何在项目中定义所需的依赖项。您学习了如何自定义依赖项解析以及如何定义存储依赖项的存储库。
- en: Then, you learned how we can deploy our project as dependencies for others.
    We saw how we can publish to a Maven repository, including Bintray, and an Ivy
    repository. You now have the knowledge to manage dependencies in your Java projects
    with Gradle.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您学习了如何将我们的项目作为他人的依赖项进行部署。我们看到了如何将发布到Maven存储库，包括Bintray和Ivy存储库。您现在有了使用Gradle在Java项目中管理依赖项的知识。
