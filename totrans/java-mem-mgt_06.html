<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer078" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-87" lang="en-GB"><a id="_idTextAnchor086" class="pcalibre pcalibre2 pcalibre1 calibre6"/>6</h1>
<h1 id="_idParaDest-88" lang="en-GB" class="calibre5"><a id="_idTextAnchor087" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Configuring and Monitoring the Memory Management of the JVM</h1>
<p lang="en-GB" class="calibre4">So far, we have looked at the different areas of memory and how it is deallocated, but we have yet to look at optimizing the way a <strong class="bold" lang="">Java Virtual Machine</strong> (<strong class="bold" lang="">JVM</strong>) does this. The approach that the JVM uses to manage memory can be configured in <span lang="">different ways.</span></p>
<p lang="en-GB" class="calibre4">There is not one obvious way to configure the JVM though. The best configuration really depends on the application and the requirements. Getting the best configuration will improve the performance of your application and minimize the memory requirements. Monitoring performance and memory will help discover problems before <span lang="">users do.</span></p>
<p lang="en-GB" class="calibre4">In this chapter, we’re going to have a look at how to configure the JVM and monitor memory management. Changing the configurations of the JVM is typically done by tuning, meaning that you have an idea of where to start, then make small adjustments, and carefully measure their impact. Here are the topics that will <span lang="">be discussed:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">The basics of JVM tuning for <span lang="">memory management</span></li>
<li lang="en-GB" class="calibre11">Obtaining relevant metrics for <span lang="">memory management</span></li>
<li lang="en-GB" class="calibre11">Profiling of the <span lang="">Java application</span></li>
<li lang="en-GB" class="calibre11">Tuning the configurations of <span lang="">the JVM</span></li>
</ul>
<h1 id="_idParaDest-89" lang="en-GB" class="calibre5"><a id="_idTextAnchor088" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Technical requirements</h1>
<p lang="en-GB" class="calibre4">The code for this chapter can be found on GitHub <span lang="">at </span><a href="https://github.com/PacktPublishing/B18762_Java-Memory-Management" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang="">https://github.com/PacktPublishing/B18762_Java-Memory-Management</span></a><span lang="">.</span></p>
<h1 id="_idParaDest-90" lang="en-GB" class="calibre5"><a id="_idTextAnchor089" class="pcalibre pcalibre2 pcalibre1 calibre6"/>The basics of JVM tuning for memory management</h1>
<p lang="en-GB" class="calibre4">The first<a id="_idIndexMarker230" class="pcalibre pcalibre2 pcalibre1 calibre6"/> rule of JVM tuning for performance improvement is probably that it should be the last option for improvement. Look <a id="_idIndexMarker231" class="pcalibre pcalibre2 pcalibre1 calibre6"/>at this <span lang="">code snippet:</span></p>
<pre class="source-code" lang="en-GB">int i = 0;</pre>
<pre class="source-code" lang="en-GB">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</pre>
<pre class="source-code" lang="en-GB">while(i &lt; 100) {</pre>
<pre class="source-code" lang="en-GB">    list.add((int)Math.ceil(Math.random()*1000));</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">Will JVM tuning help? No, because we’re stuck in an infinite loop, since <strong class="source-inline" lang="">i</strong> never gets increased. Of course, there are a lot of less obvious examples, but when code can be improved and optimized, this must be done first before thinking about <span lang="">JVM tuning.</span></p>
<p lang="en-GB" class="calibre4">If the hardware can realistically be optimized, this should be done before JVM tuning as well. By this, I don’t mean that you should fix a memory leak by just adding more memory; of course, that’s not a fix. But when your application accidentally gets very successful and things get slow, chances are that you are better off upgrading the hardware than diving into JVM tuning to fix this. When all the other factors that come into play for performance are optimized, this is when JVM tuning can be applied for <span lang="">performance improvement.</span></p>
<p lang="en-GB" class="calibre4">When we are tuning the JVM, we are setting parameters. And that’s not it; this needs to be carefully monitored. Before changing any settings, we must make sure to have a good idea of the metrics of our application. These new settings need to be monitored carefully. If the performance improves, you could try to change the parameters a bit more; if it gets worse, you should probably change it back at least a little to gauge <span lang="">the difference.</span></p>
<p lang="en-GB" class="calibre4">It might sound like trial and error at this point, and to some extent it is – professionally conducted trial and error, that is. Let’s have a look at the relevant metrics to tune the memory management of <span lang="">the JVM.</span></p>
<h1 id="_idParaDest-91" lang="en-GB" class="calibre5"><a id="_idTextAnchor090" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Obtaining relevant metrics for memory management</h1>
<p lang="en-GB" class="calibre4">There are<a id="_idIndexMarker232" class="pcalibre pcalibre2 pcalibre1 calibre6"/> several important metrics for knowing how the memory of an application is doing. Understanding the following three important concepts that define the performance of the application is the first <span lang="">step here:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Memory that is <span lang="">functioning well</span></li>
<li lang="en-GB" class="calibre11"><span lang="">Normal latency</span></li>
<li lang="en-GB" class="calibre11">A normal level <span lang="">of throughput</span></li>
</ul>
<p lang="en-GB" class="calibre4">Let’s take a look at each one <span lang="">of these.</span></p>
<h2 id="_idParaDest-92" lang="en-GB" class="calibre7"><a id="_idTextAnchor091" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Well-functioning memory</h2>
<p lang="en-GB" class="calibre4">When you <a id="_idIndexMarker233" class="pcalibre pcalibre2 pcalibre1 calibre6"/>have experience with a specific application, you may know its stable memory-usage point. There needs to be more memory available than just the stable usage point though. Instead, a safe amount of memory needs to be available for the Java application, and this reserved memory should not be almost full. Conversely, having too much memory allocated for the Java application is also not the way to go. This is because the rest of the system will also need some memory for other processes, since the operating system is <span lang="">also running.</span></p>
<p lang="en-GB" class="calibre4">If you have an idea of the normal memory metrics of your application when it’s performing well, this will help you measure the outcome of any adjustments that you might be <span lang="">making later.</span></p>
<h2 id="_idParaDest-93" lang="en-GB" class="calibre7"><a id="_idTextAnchor092" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Normal latency</h2>
<p lang="en-GB" class="calibre4">Latency is <a id="_idIndexMarker234" class="pcalibre pcalibre2 pcalibre1 calibre6"/>also<a id="_idIndexMarker235" class="pcalibre pcalibre2 pcalibre1 calibre6"/> called the responsiveness of the application. An application with normal latency responds as expected and required. This can be measured in time – for example, the time the application takes to process a certain request such as processing an incoming <span lang="">HTTP request.</span></p>
<p lang="en-GB" class="calibre4">Of course, measuring latency is not always as easy. If we have a standalone Java application, this is somewhat trivial. We know that we are measuring the latency of our application. If we are trying to measure the latency of an enterprise application, it becomes tricky. We need to make sure we are measuring the latency of our application and not network issues, the server side of another application, or any layer that we have in our <a id="_idIndexMarker236" class="pcalibre pcalibre2 pcalibre1 calibre6"/>enterprise application landscape. In<a id="_idIndexMarker237" class="pcalibre pcalibre2 pcalibre1 calibre6"/> those cases, issues with the latency results are likely not related to the memory management of <span lang="">our application.</span></p>
<h2 id="_idParaDest-94" lang="en-GB" class="calibre7"><a id="_idTextAnchor093" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Level of throughput</h2>
<p lang="en-GB" class="calibre4">Throughput <a id="_idIndexMarker238" class="pcalibre pcalibre2 pcalibre1 calibre6"/>is the amount <a id="_idIndexMarker239" class="pcalibre pcalibre2 pcalibre1 calibre6"/>of work that can be done by the application in a certain amount of time. High throughput is typically what you want to aim for, but it does require more memory and might <span lang="">affect latency.</span></p>
<h1 id="_idParaDest-95" lang="en-GB" class="calibre5"><a id="_idTextAnchor094" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Profiling Java applications</h1>
<p lang="en-GB" class="calibre4">Profiling is<a id="_idIndexMarker240" class="pcalibre pcalibre2 pcalibre1 calibre6"/> used to make an analysis of the runtime performance of an application. This is something that needs to be done carefully, since it usually has an impact on the application that is being profiled. It is, therefore, advisable to profile the development environment if possible. We are going to have a look at profiling with the <strong class="source-inline" lang="">jstat</strong> and <strong class="source-inline" lang="">jmap</strong> command-line tools, and<a id="_idIndexMarker241" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the <strong class="bold" lang="">VisualVM</strong> application. The first two come with your <strong class="bold" lang="">Java Development Kit</strong> (<strong class="bold" lang="">JDK</strong>); the<a id="_idIndexMarker242" class="pcalibre pcalibre2 pcalibre1 calibre6"/> latter used to come with it but now it can be <span lang="">downloaded separately.</span></p>
<p class="callout-heading" lang="en-GB">Important note</p>
<p class="callout" lang="en-GB">You can download <a id="_idIndexMarker243" class="pcalibre pcalibre2 pcalibre1 calibre6"/>VisualVM <span lang="">here: </span><a href="https://visualvm.github.io/download.xhtml." class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang="">https://visualvm.github.io/download.xhtml.</span></a></p>
<p lang="en-GB" class="calibre4">There are other profiles out there; some IDEs even have their own profilers built in, which work in a <span lang="">similar way.</span></p>
<h2 id="_idParaDest-96" lang="en-GB" class="calibre7"><a id="_idTextAnchor095" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Profiling with jstat and jmap</h2>
<p lang="en-GB" class="calibre4">With<a id="_idIndexMarker244" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the two command-line utilities, <strong class="source-inline" lang="">jstat</strong> and <strong class="source-inline" lang="">jmap</strong>, we can analyze <a id="_idIndexMarker245" class="pcalibre pcalibre2 pcalibre1 calibre6"/>and profile memory. We are going to explore <a id="_idIndexMarker246" class="pcalibre pcalibre2 pcalibre1 calibre6"/>how to <span lang="">do that.</span></p>
<p lang="en-GB" class="calibre4">Let’s say we have a simple <span lang="">Java application:</span></p>
<pre class="source-code" lang="en-GB">package chapter6;</pre>
<pre class="source-code" lang="en-GB">import java.util.ArrayList;</pre>
<pre class="source-code" lang="en-GB">import java.util.List;</pre>
<pre class="source-code" lang="en-GB">public class ExampleAnalysis {</pre>
<pre class="source-code" lang="en-GB">   public static List&lt;String&gt; stringList = new ArrayList&lt;&gt;();</pre>
<pre class="source-code" lang="en-GB">    public static void main(String[] args) {</pre>
<pre class="source-code" lang="en-GB">        for(int i = 0; i &lt; 1000000000; i++) {</pre>
<pre class="source-code" lang="en-GB">            stringList.add("String " + i);</pre>
<pre class="source-code" lang="en-GB">            System.out.println(stringList.get(i));</pre>
<pre class="source-code" lang="en-GB">        }</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">This<a id="_idIndexMarker247" class="pcalibre pcalibre2 pcalibre1 calibre6"/> application is not doing a lot of interesting things, just adding a lot of <strong class="source-inline" lang="">String</strong> objects to our <strong class="source-inline" lang="">stringList</strong> <span lang="">static list.</span></p>
<p lang="en-GB" class="calibre4">We can run this program and see what is going on with the memory. In order to do this, we need to compile the <span lang="">program first:</span></p>
<pre class="source-code" lang="en-GB">javac ExampleAnalysis.java</pre>
<p lang="en-GB" class="calibre4">The preceding command assumes that you are in the same folder as Command Prompt or Terminal, since we access the file directly without any folders in front. This command compiles the code and stores the result in <strong class="source-inline" lang="">ExampleAnalysis.class</strong>. Let’s run this file by executing the following command (make sure to be one level above the <a href="B18762_06.xhtml#_idTextAnchor086" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter </em></span><span lang=""><em class="italic" lang="">6</em></span></a><span lang=""> directory):</span></p>
<pre class="source-code" lang="en-GB">java chapter6.ExampleAnalysis</pre>
<p lang="en-GB" class="calibre4">Now, we’ll first need the process ID to analyze our code using <strong class="source-inline" lang="">jstat</strong>. We can get the process IDs of all Java processes by running the following command in the <span lang="">command line:</span></p>
<pre class="source-code" lang="en-GB">jps</pre>
<p lang="en-GB" class="calibre4">The command produces the <span lang="">following output:</span></p>
<pre class="source-code" lang="en-GB">35169 Launcher</pre>
<pre class="source-code" lang="en-GB">35397 Jps</pre>
<pre class="source-code" lang="en-GB">30565</pre>
<pre class="source-code" lang="en-GB">35384 ExampleAnalysis</pre>
<pre class="source-code" lang="en-GB">34846</pre>
<p lang="en-GB" class="calibre4">Our <a id="_idIndexMarker248" class="pcalibre pcalibre2 pcalibre1 calibre6"/>program can be easily recognized, as it has the name of the class written after it. So, our process ID <span lang="">is </span><span lang=""><strong class="source-inline" lang="">35384</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">We need this process ID to run the <strong class="source-inline" lang="">jstat</strong> analysis. This command-line tool has several options. We are going to start by running it <span lang="">like this:</span></p>
<pre class="source-code" lang="en-GB">jstat -gc -t 35384 1000 10</pre>
<p lang="en-GB" class="calibre4">This will produce the result for our process with an ID of <strong class="source-inline" lang="">35384</strong>. The <strong class="source-inline" lang="">-gc</strong> option is one of the options available to get statistics about the garbage collected heap. It makes sure that it shows the behavior of the garbage collected heap. There are a few other flags that you could use as well; here are a <span lang="">few examples:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">gccapacity</strong>: Show data about the capacities of <span lang="">the generations</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">gcnew</strong>: Show data about the behavior of the <span lang="">young generations</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">gcnewcapacity</strong>: Show data about the size of the <span lang="">young generations</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">gcold</strong>: Show data about the old generation and <span lang="">the Metaspace</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">gcoldcapacity</strong>: Show data about the <span lang="">old generation</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">gcutil</strong>: Show a summary of the garbage <span lang="">collection data</span></li>
</ul>
<p lang="en-GB" class="calibre4"><strong class="source-inline" lang="">-t</strong> indicates that it should print the timestamp. <strong class="source-inline" lang="">1000</strong> means that it will show the statistics every 1,000 milliseconds and <strong class="source-inline" lang="">10</strong> means that it will show <span lang="">10 iterations.</span></p>
<p lang="en-GB" class="calibre4">The output will look as shown in <span lang=""><em class="italic" lang="">Figure 6</em></span><span lang=""><em class="italic" lang="">.1</em></span><span lang="">:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer069">
<img alt="Figure 6.1 – Output showing the jstat command with options" src="image/Figure_6.1_B18762.jpg" class="calibre73"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Output showing the jstat command with options</p>
<p lang="en-GB" class="calibre4">As you can see, it <a id="_idIndexMarker249" class="pcalibre pcalibre2 pcalibre1 calibre6"/>displays many columns. Let us see what these columns mean; the exact values aren’t too important for the discussion. We’ll go over them from left <span lang="">to right:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Timestamp</strong>: The time since the program started running. You can see that it increases with seconds, which makes sense, as we asked for iterations of <span lang="">1,000 milliseconds.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">S0C</strong>: The current capacity of the survivor space 0 <span lang="">in KB.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">S1C</strong>: The current capacity of the survivor space 1 <span lang="">in KB.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">S0U</strong>: The part of the survivor space 0 that is being used <span lang="">in KB.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">S1U</strong>: The part of the survivor space 1 that is being used <span lang="">in KB.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">EC</strong>: The current capacity of the Eden space in KB. You can see that the capacity scales up when the Eden space <span lang="">gets fuller.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">EU</strong>: The part of the Eden space that is being used in KB. At the seventh row, it drops, and the data gets moved to the <span lang="">old space.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">OC</strong>: The current capacity of the old space <span lang="">in KB.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">OU</strong>: The part of the old space that is being used in KB. You can see it increase during <span lang="">the program.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">MC</strong>: The current capacity of the Metaspace <span lang="">in KB.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">MU</strong>: The part of the Metaspace that is being used <span lang="">in KB.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">CCSC</strong>: <strong class="bold" lang="">Compressed Class Space Capacity</strong> <span lang="">in KB.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">CCSU</strong>: <strong class="bold" lang="">Compressed Class Space Utilized</strong> <span lang="">in KB.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">YGC</strong>: The number of young generation garbage collection events <span lang="">that happened.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">YGCT</strong>: The total time of the young generation garbage <span lang="">collection events.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">FGC</strong>: The total number of full garbage <span lang="">collection events.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">FGCT</strong>: The total time the full garbage collection <span lang="">events took.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">CGC</strong>: <strong class="bold" lang="">Concurrent </strong><span lang=""><strong class="bold" lang="">Garbage Collection</strong></span><span lang="">.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">CGCT</strong>: The total time of concurrent <span lang="">garbage collection.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">GCT</strong>: The total garbage <span lang="">collection time.</span></li>
</ul>
<p lang="en-GB" class="calibre4">With the <strong class="source-inline" lang="">jmap</strong> command, we <a id="_idIndexMarker250" class="pcalibre pcalibre2 pcalibre1 calibre6"/>can get more insights into the heap memory usage of our current process. Here is how to use it (Java 9 <span lang="">and later):</span></p>
<pre class="source-code" lang="en-GB">jhsdb jmap --heap --pid 35384</pre>
<p lang="en-GB" class="calibre4"><strong class="source-inline" lang="">jhsdb</strong> is a<a id="_idIndexMarker251" class="pcalibre pcalibre2 pcalibre1 calibre6"/> JDK tool that can attach to a running Java process, perform snapshot debugging, and inspect the content of the core dump of a crashed JVM. This outputs the current heap configuration and usage. Let’s have a look at how to get a more visual result while Java profiling with the help <span lang="">of VisualVM.</span></p>
<h2 id="_idParaDest-97" lang="en-GB" class="calibre7"><a id="_idTextAnchor096" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Profiling with VisualVM</h2>
<p lang="en-GB" class="calibre4">There<a id="_idIndexMarker252" class="pcalibre pcalibre2 pcalibre1 calibre6"/> are many profilers out there that will give a visual representation of memory. One of them is VisualVM. It is a tool that is suitable<a id="_idIndexMarker253" class="pcalibre pcalibre2 pcalibre1 calibre6"/> for getting detailed information about the Java<a id="_idIndexMarker254" class="pcalibre pcalibre2 pcalibre1 calibre6"/> applications that are running. VisualVM does not come by default with the JDK anymore, so it needs to be installed separately <span lang="">here: </span><a href="https://visualvm.github.io/." class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang="">https://visualvm.github.io/.</span></a></p>
<p lang="en-GB" class="calibre4">If your IDE supports profiling, you could work with that one too. However, the following examples use VisualVM, since it’s a free tool that can be easily downloaded. Profiling an application<a id="_idIndexMarker255" class="pcalibre pcalibre2 pcalibre1 calibre6"/> with VisualVM is easy. First, you start VisualVM. You will see a screen similar to the one in <span lang=""><em class="italic" lang="">Figure 6</em></span><span lang=""><em class="italic" lang="">.2</em></span><span lang="">.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer070">
<img alt="Figure 6.2 – The startup screen of VisualVM" src="image/Figure_6.2_B18762.jpg" class="calibre74"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The startup screen of VisualVM</p>
<p lang="en-GB" class="calibre4">On the screen of <span lang=""><em class="italic" lang="">Figure 6</em></span><em class="italic" lang="">.2</em>, we can check the applications that are running. The <strong class="bold" lang="">Applications</strong> tab can be <a id="_idIndexMarker256" class="pcalibre pcalibre2 pcalibre1 calibre6"/>found on the top left, positioned vertically. Here, we can see the local Java processes that are running, from where we can simply select the one that we need. Let’s start our example Java application, where we will create a huge list <span lang="">of strings.</span></p>
<p lang="en-GB" class="calibre4">In the <strong class="bold" lang="">Applications</strong> tab, we can see the processes, as shown in <span lang=""><em class="italic" lang="">Figure 6</em></span><span lang=""><em class="italic" lang="">.3</em></span><span lang="">.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer071">
<img alt="Figure 6.3 – An overview of the Java processes" src="image/Figure_6.3_B18762.jpg" class="calibre75"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.3 – An overview of the Java processes</p>
<p lang="en-GB" class="calibre4">We can<a id="_idIndexMarker257" class="pcalibre pcalibre2 pcalibre1 calibre6"/> now pick the process we want to examine. In this case, we<a id="_idIndexMarker258" class="pcalibre pcalibre2 pcalibre1 calibre6"/> would like to analyze the process with the <strong class="bold" lang="">6450</strong> PID. Once we click on it, we get an overview of the process, as shown in <span lang=""><em class="italic" lang="">Figure 6</em></span><span lang=""><em class="italic" lang="">.4</em></span><span lang="">.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer072">
<img alt="Figure 6.4 – An overview of the Java process" src="image/Figure_6.4_B18762.jpg" class="calibre74"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.4 – An overview of the Java process</p>
<p lang="en-GB" class="calibre4">We can<a id="_idIndexMarker259" class="pcalibre pcalibre2 pcalibre1 calibre6"/> see a summary of the data in the overview shown in <span lang=""><em class="italic" lang="">Figure 6</em></span><em class="italic" lang="">.4</em>. We see the process that we are analyzing, the JVM and Java<a id="_idIndexMarker260" class="pcalibre pcalibre2 pcalibre1 calibre6"/> version that we are running, and the JVM arguments used to start the application. There is also a lot more detailed data we can get from VisualVM. At the top, we have several tabs: <strong class="bold" lang="">Overview</strong>, <strong class="bold" lang="">Monitor</strong>, <strong class="bold" lang="">Threads</strong>, <strong class="bold" lang="">Sampler</strong>, and <strong class="bold" lang="">Profiler</strong>. We have seen the <strong class="bold" lang="">Overview</strong> tab; in <span lang=""><em class="italic" lang="">Figure 6</em></span><em class="italic" lang="">.5</em>, let’s look at the data under the <span lang=""><strong class="bold" lang="">Monitor</strong></span><span lang=""> tab.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer073">
<img alt="Figure 6.5 – Monitoring the Java process using VisualVM" src="image/Figure_6.5_B18762.jpg" class="calibre76"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Monitoring the Java process using VisualVM</p>
<p lang="en-GB" class="calibre4">This is <a id="_idIndexMarker261" class="pcalibre pcalibre2 pcalibre1 calibre6"/>where we get some serious details of what is going <a id="_idIndexMarker262" class="pcalibre pcalibre2 pcalibre1 calibre6"/>on in our application. We see four graphs. The top-left one shows <strong class="bold" lang="">CPU usage</strong>, and as you can see, we are using quite a bit of CPU for this program. This graph also shows the garbage collection activity, which is very low overall. This makes sense, as there is not a lot to be garbage-collected anyway. The garbage collection activity combined with the memory graph at the top right gives some great insights into how healthy our application is in terms of memory. If the garbage collector works really hard (as you can see, there is a lot of GC activity in the top-left graph) and the memory keeps increasing (the lower line representing <strong class="bold" lang="">Used heap</strong> in the top-right graph), it means that we are having a problem with a memory leak. Basically, if there are too frequent GC cycles, then it is an indication that you need to<a id="_idIndexMarker263" class="pcalibre pcalibre2 pcalibre1 calibre6"/> do some digging to see whether there is something wrong with GC and memory. After doing that, if there are still too frequent GC cycles and memory is also not coming down, then it is a red alert and you must investigate. In fact, <strong class="bold" lang="">OutOfMemoryError: GC Overhead limit exceeded</strong> is thrown by the JVM if it is spending more than 98% of the time on GC and recovering less than 2% of <span lang="">the heap.</span></p>
<p lang="en-GB" class="calibre4">The two bottom <a id="_idIndexMarker264" class="pcalibre pcalibre2 pcalibre1 calibre6"/>graphs show the loaded Java classes (left) and the threads in the application (right). We can get more details on threads by moving to the <strong class="bold" lang="">Threads</strong> tab. In <span lang=""><em class="italic" lang="">Figure 6</em></span><em class="italic" lang="">.6</em>, we see an overview of the threads in <span lang="">our application.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer074">
<img alt="Figure 6.6 – Threads in our application" src="image/Figure_6.6_B18762.jpg" class="calibre77"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Threads in our application</p>
<p lang="en-GB" class="calibre4">We can<a id="_idIndexMarker265" class="pcalibre pcalibre2 pcalibre1 calibre6"/> see the name of our threads on the far left. The <a id="_idIndexMarker266" class="pcalibre pcalibre2 pcalibre1 calibre6"/>bars indicate what the state of our threads is over time – for example, running or waiting. We can then see the time they have <span lang="">been running.</span></p>
<p lang="en-GB" class="calibre4">In the <strong class="bold" lang="">Sampler</strong> tab, shown in <span lang=""><em class="italic" lang="">Figure 6</em></span><em class="italic" lang="">.7</em>, we can see how the CPU or memory <span lang="">is doing.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer075">
<img alt="Figure 6.7 – The Sampler tab in VisualVM" src="image/Figure_6.7_B18762.jpg" class="calibre78"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.7 – The Sampler tab in VisualVM</p>
<p lang="en-GB" class="calibre4">We are <a id="_idIndexMarker267" class="pcalibre pcalibre2 pcalibre1 calibre6"/>now looking at memory sampling, which shows how many live objects there are and how much space is being occupied by a<a id="_idIndexMarker268" class="pcalibre pcalibre2 pcalibre1 calibre6"/> certain class. Here, the <strong class="source-inline" lang="">byte</strong> array is the biggest one. This makes sense because the value of a string is stored in a byte array. You can also filter this overview per thread or have a look at how the CPU <span lang="">is performing.</span></p>
<p lang="en-GB" class="calibre4">In the last tab, we can see profiling. Profiling and sampling are used for similar purposes, but the process is different. Sampling is done by making thread dumps and analyzing these thread dumps. Profiling requires adding a bit of logic to an application so that it gives a signal when something happens. This affects the performance of the application quite a bit. Therefore, this is not something you’d want to be doing on applications that are running in production. It can give a lot of <span lang="">insights though.</span></p>
<p lang="en-GB" class="calibre4">You<a id="_idIndexMarker269" class="pcalibre pcalibre2 pcalibre1 calibre6"/> can see<a id="_idIndexMarker270" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the result of profiling all the classes in <span lang=""><em class="italic" lang="">Figure 6</em></span><em class="italic" lang="">.8</em>. Here, you can see a similar result to what we were getting for the sampling (though it had fewer objects being allocated at that point in time). In this case, sampling would have worked just <span lang="">as well.</span></p>
<p lang="en-GB" class="calibre4">VisualVM is great to get quick, visual insights on what is going on with the memory of your application. This is going to be especially useful while tuning the JVM and checking the results. In the next section, we are going to do exactly that – learn how to adjust the configuration of the JVM and see the impact of <span lang="">these adjustments.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer076">
<img alt="Figure 6.8 – Profiling all the classes" src="image/Figure_6.8_B18762.jpg" class="calibre77"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Profiling all the classes</p>
<h1 id="_idParaDest-98" lang="en-GB" class="calibre5"><a id="_idTextAnchor097" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Tuning the configurations of the JVM</h1>
<p lang="en-GB" class="calibre4">The settings of JVM can be <a id="_idIndexMarker271" class="pcalibre pcalibre2 pcalibre1 calibre6"/>adjusted. The process of adjusting the settings of JVM is<a id="_idIndexMarker272" class="pcalibre pcalibre2 pcalibre1 calibre6"/> called <strong class="bold" lang="">tuning</strong>. The idea of these adjustments is to boost the performance of the JVM. Once again, tuning should not be the first step in improving performance. Good code should always <span lang="">come first.</span></p>
<p lang="en-GB" class="calibre4">We are going to have a look at the settings that are related to memory management: the heap size, Metaspace, and the <span lang="">garbage collector.</span></p>
<h2 id="_idParaDest-99" lang="en-GB" class="calibre7"><a id="_idTextAnchor098" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Tuning the heap size and thread stack size</h2>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker273" class="pcalibre pcalibre2 pcalibre1 calibre6"/>heap size can be changed. It is generally best practice to not set the heap size to more than half of what is available on the server. This could lead to performance issues, as the server will be having other processes running <span lang="">as well.</span></p>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker274" class="pcalibre pcalibre2 pcalibre1 calibre6"/>default size depends on the system. This command will show the defaults on a <span lang="">Windows system:</span></p>
<pre class="source-code" lang="en-GB">java -XX:+PrintFlagsFinal -version | findstr HeapSize</pre>
<p lang="en-GB" class="calibre4">This command shows the default output for a <span lang="">macOS system:</span></p>
<pre class="source-code" lang="en-GB">java -XX:+PrintFlagsFinal -version | grep HeapSize</pre>
<p lang="en-GB" class="calibre4">The output is displayed in bytes. You can see the output for my computer in <span lang=""><em class="italic" lang="">Figure 6</em></span><span lang=""><em class="italic" lang="">.9</em></span><span lang="">.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer077">
<img alt="Figure 6.9 – Output as seen on the macOS system" src="image/Figure_6.9_B18762.jpg" class="calibre79"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Output as seen on the macOS system</p>
<p lang="en-GB" class="calibre4">The size of the heap influences garbage collection. This might seem counterintuitive at first, but let’s do a little thought experiment here. If we had unlimited heap memory, would we need garbage collection? No, right? Why run such an expensive process if we don’t need to free up <span lang="">memory anyway?</span></p>
<p lang="en-GB" class="calibre4">The smaller the heap, the more we will need the garbage collector active because it would need to work harder to have space available, since memory gets filled up easier. However, the bigger the heap, the longer one full cycle of garbage collection takes. There’s simply more to scan for garbage. A good rule of thumb is that you want to have less than 5% of application execution time spent on <span lang="">garbage collection.</span></p>
<p lang="en-GB" class="calibre4">The actual tuning works differently for different servers. Here, we are going to see how to do so using the command line when starting the application. Please note that the names of the options that we are setting are the same between different servers, but how or where to set them <span lang="">might vary.</span></p>
<p lang="en-GB" class="calibre4">When we <a id="_idIndexMarker275" class="pcalibre pcalibre2 pcalibre1 calibre6"/>start the Java application, we can<a id="_idIndexMarker276" class="pcalibre pcalibre2 pcalibre1 calibre6"/> work with different options for the memory. We can specify a memory pool start size, a maximum memory pool, and the thread stack size. Here’s how to set all to <span lang="">1,024 MB:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-Xms1024m</strong> (initial <span lang="">size heap)</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-Xmx1024m</strong> (maximum <span lang="">size heap)</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-Xss1024m</strong> (thread <span lang="">stack size)</span></li>
</ul>
<p lang="en-GB" class="calibre4">If you want to set it to a different size, choose a different size and just adjust the option accordingly. You can use the following command to start a Java application with adjusted memory settings (on a <span lang="">64-bit system):</span></p>
<pre class="source-code" lang="en-GB">java -Xms4g -Xmx6g ExampleAnalysis</pre>
<p lang="en-GB" class="calibre4">This will start our example Java application with an initial heap size of 4 GB and a maximum of <span lang="">6 GB.</span></p>
<p lang="en-GB" class="calibre4">Similar to the way you can bind the total heap size using <strong class="source-inline" lang="">–Xmx</strong> and <strong class="source-inline" lang="">–Xms</strong>, you can bind the young generation size using <span lang="">the following:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-XX:MaxNewSize=1024m</strong> (maximum <span lang="">new size)</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-XX:NewSize=1024m</strong> (minimum <span lang="">new size)</span></li>
</ul>
<p lang="en-GB" class="calibre4">Here, we are setting the minimum and the maximum size to 1,024 MB. We may run out of memory. This will result in <strong class="source-inline" lang="">OutOfMemoryError</strong>. Let’s see how to get a heap dump when this happens so that we can inspect what <span lang="">went wrong.</span></p>
<h2 id="_idParaDest-100" lang="en-GB" class="calibre7"><a id="_idTextAnchor099" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Logging low memory</h2>
<p lang="en-GB" class="calibre4">It is very<a id="_idIndexMarker277" class="pcalibre pcalibre2 pcalibre1 calibre6"/> helpful to get a <strong class="bold" lang="">heap dump</strong> when<a id="_idIndexMarker278" class="pcalibre pcalibre2 pcalibre1 calibre6"/> an application ends with an out-of-memory error. A heap dump is a snapshot of the objects in the memory of the application. In this case, we can inspect the<a id="_idIndexMarker279" class="pcalibre pcalibre2 pcalibre1 calibre6"/> objects in the application that were present at the moment we ran out of memory. This way, we can use it to see which object is likely to overflow <span lang="">the memory.</span></p>
<p lang="en-GB" class="calibre4">If you want the JVM to create the heap dump whenever there is an <strong class="source-inline" lang="">OutOfMemoryError</strong> exception, then you can use the following JVM argument while starting <span lang="">the JVM:</span></p>
<pre class="source-code" lang="en-GB">java -XX:+HeapDumpOnOutOfMemoryError ExampleAnalysis</pre>
<p lang="en-GB" class="calibre4">We can also specify <span lang="">the path:</span></p>
<pre class="source-code" lang="en-GB">java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/some/path/to/dumps ExampleAnalysis</pre>
<p lang="en-GB" class="calibre4">With this, the<a id="_idIndexMarker280" class="pcalibre pcalibre2 pcalibre1 calibre6"/> heap dumps will be stored in the specified path. There are different ways to create a heap dump – for example, <strong class="source-inline" lang="">jmap</strong> can also be used to create a heap dump of the application, if it didn’t crash because <span lang="">of </span><span lang=""><strong class="source-inline" lang="">OutOfMemoryError</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">Next, let’s see how to configure <span lang="">the Metaspace.</span></p>
<h2 id="_idParaDest-101" lang="en-GB" class="calibre7"><a id="_idTextAnchor100" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Tuning the Metaspace</h2>
<p lang="en-GB" class="calibre4">The default behavior <a id="_idIndexMarker281" class="pcalibre pcalibre2 pcalibre1 calibre6"/>of Metaspace is quite peculiar, as it seems to have a limit. This is easy to interpret in the wrong way <a id="_idIndexMarker282" class="pcalibre pcalibre2 pcalibre1 calibre6"/>because this limit is not a real limit. If it reaches this limit, it will see what it can do in terms of garbage collection, and then it expands. Therefore, it is important to set the following <span lang="">variables carefully:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Maximum size, <span lang="">using </span><span lang=""><strong class="source-inline" lang="">-XX:MaxMetaspaceSize=2048m</strong></span></li>
<li lang="en-GB" class="calibre11">Threshold for garbage collection, <span lang="">using </span><span lang=""><strong class="source-inline" lang="">-XX:MetaspaceSize=1024m</strong></span></li>
<li lang="en-GB" class="calibre11">Minimum and maximum free ratio, using <span lang="">the following:</span><ul class="calibre43"><li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-</strong><span lang=""><strong class="source-inline" lang="">XX:MinMetaspaceFreeRatio=50</strong></span></li><li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-</strong><span lang=""><strong class="source-inline" lang="">XX:MaxMetaspaceFreeRatio=50</strong></span></li></ul></li>
</ul>
<p lang="en-GB" class="calibre4">The minimum and maximum free ratios are great for when you are planning to load a lot of classes dynamically. By making sure there is enough memory available, you can increase the speed to load classes dynamically. This is because the freeing up of memory for classes that need to be loaded takes some CPU time. We can skip the step that requires assigning additional memory by choosing a large enough free ratio and making sure memory is available. In the preceding example, they are set <span lang="">to 50%.</span></p>
<h2 id="_idParaDest-102" lang="en-GB" class="calibre7"><a id="_idTextAnchor101" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Garbage collection tuning</h2>
<p lang="en-GB" class="calibre4">As you may <a id="_idIndexMarker283" class="pcalibre pcalibre2 pcalibre1 calibre6"/>have realized by now, garbage collection is an expensive process. Optimizing it can really help the performance<a id="_idIndexMarker284" class="pcalibre pcalibre2 pcalibre1 calibre6"/> of an application. You cannot trigger garbage collection yourself; this is the decision of the JVM. You may have heard of the following way to suggest garbage collection to <span lang="">the JVM:</span></p>
<pre class="source-code" lang="en-GB">System.gc();</pre>
<p lang="en-GB" class="calibre4">This does not guarantee that garbage collection will take place. So, you cannot trigger garbage collection, but you can influence the way the JVM deals <span lang="">with it.</span></p>
<p lang="en-GB" class="calibre4">However, before tweaking anything in relation to garbage collection, it is important to make sure that you understand what you are doing exactly. For this, you’ll need solid knowledge about the <span lang="">garbage collector.</span></p>
<p lang="en-GB" class="calibre4">Also, before adjusting anything, you must have a look at memory usage. Make sure to know what spaces are filled and when this is happening. A heap that’s healthy will look a bit like a saw in VisualVM. It goes up and down, creating spikes, resembling the teeth of a saw. It has a certain amount of used memory, and then the garbage collection comes around and decreases the used memory to a certain base level. It grows again, and then at around the same usage level, the garbage collection comes around and decreases it to its base level, and <span lang="">so on.</span></p>
<p lang="en-GB" class="calibre4">If you see the memory growing over time and garbage collection ends at a slightly higher base level every time, you probably have a memory leak that needs to be dealt with. As we saw in <a href="B18762_04.xhtml#_idTextAnchor057" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 4</em></span></a>, there are several different garbage collector implementations available. When starting the JVM, we can also choose which garbage collector we want it <span lang="">to use:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-</strong><span lang=""><strong class="source-inline" lang="">XX:+UseSerialGC</strong></span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-</strong><span lang=""><strong class="source-inline" lang="">XX:-UseParallelGC</strong></span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-</strong><span lang=""><strong class="source-inline" lang="">XX:+UseConcMarkSweepGC</strong></span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-</strong><span lang=""><strong class="source-inline" lang="">XX:+G1GC</strong></span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-</strong><span lang=""><strong class="source-inline" lang="">XX:+UseZGC</strong></span></li>
</ul>
<p lang="en-GB" class="calibre4">This is not possible for every system, and all these garbage collection choices come with their own extra <a id="_idIndexMarker285" class="pcalibre pcalibre2 pcalibre1 calibre6"/>options as well. For example, we can choose the parallel garbage collector and specify the number of threads for the <span lang="">garbage collector:</span></p>
<pre class="source-code" lang="en-GB">java -XX:+UseParallelGC -XX:ParallelGCThreads=4 ExampleAnalysis</pre>
<p lang="en-GB" class="calibre4">This is how <a id="_idIndexMarker286" class="pcalibre pcalibre2 pcalibre1 calibre6"/>to start an application using the parallel garbage collector and giving it four threads to work with. The options for all the garbage collectors are too elaborate to discuss in detail. Details can be found in the official documentation of the Java implementation that you are using. Here is the link to the Oracle implementation, although it’s possible that newer versions will have been released by the time you are reading this <span lang="">book: </span><a href="https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm." class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang="">https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm.</span></a></p>
<p lang="en-GB" class="calibre4"><span lang="">Summary</span></p>
<p lang="en-GB" class="calibre4">In this chapter, we saw what to keep in mind when tuning the JVM. We need to focus on memory functioning, latency, <span lang="">and throughput.</span></p>
<p lang="en-GB" class="calibre4">In order to monitor how our application is doing, we can use profiles. We have seen how to use the <strong class="source-inline" lang="">jstat</strong> command-line tool that comes with the JDK by default. After that, we saw how to use VisualVM to get a better visual representation of what is <span lang="">going on.</span></p>
<p lang="en-GB" class="calibre4">Next, we saw how we could adjust the heap, Metaspace, and the garbage collector of our application. We also saw the effects for our simple <span lang="">example application.</span></p>
<p lang="en-GB" class="calibre4">To reiterate, please bear in mind that adjusting the JVM to boost performance should always be the last step, and more obvious actions, such as improving code, should always be <span lang="">taken first.</span></p>
<p lang="en-GB" class="calibre4">Having covered this, you are now ready to look at how to avoid memory leaks in the <span lang="">next chapter.</span></p>
</div>
<div class="calibre2">
<div id="_idContainer079" class="calibre2">
</div>
</div>
</div></body></html>