- en: Execution Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行控制
- en: Throughout this book, we have been working with Reactor operators. This has
    included performing various tasks, such as filtering, transforming, and collecting.
    Most operators do not create additional threads and just work on the main thread.
    However, we can configure multithreading and concurrency in Reactor by using a
    set of schedulers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在使用Reactor操作符。这包括执行各种任务，如过滤、转换和收集。大多数操作符不会创建额外的线程，只是在主线程上工作。然而，我们可以通过使用一组调度器来配置Reactor的多线程和并发。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Schedulers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器
- en: Parallel processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行处理
- en: Broadcasting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java标准版，JDK 8或更高版本
- en: IntelliJ IDEA IDE, 2018.1 or above
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE，2018.1或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter09).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub链接是[https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter09)。
- en: Scheduler
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器
- en: Reactor executes all operations using one of the schedulers. A Reactor scheduler
    does not belong to the `java.util.concurrent` API. The Java concurrent API is
    quite low-level, where we can initiate and control task execution. On the other
    hand, all tasks in a Reactor chain are executed by the Reactor engine. Consequently,
    we do not need a low-level API to manage task execution. Instead, Reactor offers
    a declarative model, which we can use to configure a `Scheduler` and alter the
    behavior of the chain execution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor使用调度器之一来执行所有操作。Reactor调度器不属于`java.util.concurrent` API。Java并发API相当底层，我们可以从中启动和控制任务执行。另一方面，Reactor链中的所有任务都由Reactor引擎执行。因此，我们不需要低级API来管理任务执行。相反，Reactor提供了一个声明性模型，我们可以使用它来配置`Scheduler`并改变链式执行的行怍。
- en: 'Before we start to configure Reactor, let''s first determine the default execution
    model. By default, Reactor is mostly single-threaded. The publisher and subscriber
    do not create additional threads for their execution. All life cycle hooks, and
    most operators, perform single-threaded execution. Before we jump ahead, let''s
    build some code to validate this, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始配置Reactor之前，让我们首先确定默认的执行模型。默认情况下，Reactor主要是单线程的。发布者和订阅者不会为它们的执行创建额外的线程。所有生命周期钩子和大多数操作符都执行单线程操作。在我们继续之前，让我们编写一些代码来验证这一点，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, the following applies:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下规则适用：
- en: We built a simple Fibonacci chain, using the `filter` operator and life cycle
    hooks.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`filter`操作符和生命周期钩子构建了一个简单的斐波那契链。
- en: Each operation prints to a console using the `print` function.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个操作都使用`print`函数打印到控制台。
- en: The `print` function prints the current thread name, along with the text.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`print`函数打印当前线程名称以及文本。'
- en: 'The following screenshot shows a simple debugging code snippet, which allows
    us to see how Reactor does stream execution. Let''s run this and see how it works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了一个简单的调试代码片段，它允许我们看到Reactor如何执行流式操作。让我们运行它看看效果：
- en: '![](img/5110c466-7ed1-4abe-84fd-70c48f9d8126.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5110c466-7ed1-4abe-84fd-70c48f9d8126.png)'
- en: In the preceding screenshot, we can see that all of the text is prefixed with
    `[main]`. Consequently, all operations are executed on the main thread, and no
    additional threads are used by Reactor. This output validates the idea that Reactor
    is single-threaded, by default. Due to the single-threaded execution, we did not
    pause the test execution using `Thread.sleep` or `latch.wait`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到所有文本都带有前缀 `[main]`。因此，所有操作都在主线程上执行，Reactor没有使用额外的线程。这个输出验证了Reactor默认是单线程的。由于单线程执行，我们没有使用`Thread.sleep`或`latch.wait`来暂停测试执行。
- en: 'However, the preceding concept is only partially true; Reactor operators do
    alter the behavior of chain execution. Previously, we used `latch` and `Thread.sleep`
    in our test cases, for the delay and timeout operator. Let''s add the operator
    to our test case and analyze the output, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的概念只是部分正确；Reactor操作符确实会改变链式执行的行怍。以前，我们在测试用例中使用了`latch`和`Thread.sleep`来处理延迟和超时操作符。让我们将操作符添加到测试用例中，并分析输出，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, the following applies:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下规则适用：
- en: We added the `delayElements` operator to our chain, after the `filter` operator.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`filter`操作符之后添加了`delayElements`操作符。
- en: The test now terminates quickly, so we need to add `Thread.sleep` to pause the
    execution of the main thread. The pause ensures that the complete chain is executed.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试现在迅速终止，因此我们需要添加`Thread.sleep`来暂停主线程的执行。暂停确保整个链被执行。
- en: 'Let''s run this and analyze the output, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它并分析输出，如下所示：
- en: '![](img/36366260-ab46-4522-b2e3-04fce9cbfb8f.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/36366260-ab46-4522-b2e3-04fce9cbfb8f.png)'
- en: 'We can deduce the following by looking at the preceding output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的输出，我们可以推断出以下内容：
- en: The publisher does not create a thread; it executes in the main thread.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者不会创建线程；它在主线程中执行。
- en: The `filter` operation does not create a thread; it executes in the main thread.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`操作不会创建线程；它在主线程中执行。'
- en: The `delayElements` operations add a thread pool of two threads, denoted by
    `parallel-1` and `parallel-2`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delayElements`操作添加了一个由`parallel-1`和`parallel-2`表示的两个线程的线程池。'
- en: The rest of the chain now executes in the thread pool, rather than the main
    thread.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接现在在线程池中执行，而不是主线程。
- en: Now that you have gained some understanding of the threading model of Reactor,
    let's discuss the ways in which we can configure it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Reactor的线程模型，让我们讨论我们可以如何配置它。
- en: Reactor schedulers
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor调度器
- en: As discussed in the previous section, Reactor operators configure reactive chain
    execution behavior. However, the behavior can be altered by using a different
    scheduler. Most of the operators have overloaded methods, which take a scheduler
    as an argument. In this section, we will look at the various schedulers available
    in Reactor. Reactor also provides a `schedulers` utility class, to build instances
    of the available implementations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，Reactor操作符配置反应链执行行为。然而，可以通过使用不同的调度器来改变这种行为。大多数操作符都有重载方法，这些方法接受一个调度器作为参数。在本节中，我们将查看Reactor中可用的各种调度器。Reactor还提供了一个`schedulers`实用类，用于构建可用实现的实例。
- en: The immediate scheduler
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立即调度器
- en: 'The `Schedulers.immediate` scheduler executes work on the currently executing
    thread. All tasks are executed on the caller thread, and no task is performed
    in parallel. This is the default execution model for most Reactor tasks. Consider
    the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.immediate`调度器在当前执行的线程上执行工作。所有任务都在调用线程上执行，没有任务以并行方式执行。这是大多数Reactor任务默认的执行模型。考虑以下代码：'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, the following has occurred:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发生了以下情况：
- en: We added the `delayElements` operator to our chain.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向我们的链中添加了`delayElements`操作符。
- en: The test tries to schedule the delay on the main thread.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试尝试在主线程上调度延迟。
- en: 'We can execute the code, but the task will fail, because the main thread lacks
    the time-based scheduling capability. The following screenshot shows this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行代码，但任务将失败，因为主线程缺乏基于时间的调度能力。以下截图显示了这一点：
- en: '![](img/d1152db0-c2a5-4ca0-91c7-afd42343bfeb.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d1152db0-c2a5-4ca0-91c7-afd42343bfeb.png)'
- en: The single scheduler
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个调度器
- en: 'The `Schedulers.single` scheduler executes work on a single-worker thread pool.
    Since this is a single worker, all tasks are executed one by one, and no task
    is performed in a concurrent manner. The scheduler is quite useful for isolating
    the execution of non-threadsafe operations to a single thread. Consider the following
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.single`调度器在单个工作线程池上执行工作。由于这是一个单个工作者，所有任务都是逐个执行的，没有任务是以并发方式执行的。调度器对于将非线程安全操作的执行隔离到单个线程中非常有用。考虑以下代码：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, the following has occurred:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发生了以下情况：
- en: We added the `delayElements` operator to our chain.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向我们的链中添加了`delayElements`操作符。
- en: The test tries to schedule the delay on a single thread, and not on the main
    thread of test execution.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试尝试在单个线程上调度延迟，而不是在测试执行的主线程上。
- en: 'From the output, we can validate that all of the tasks in the chain are executed
    on a `single-1` thread. Consider the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以验证链中的所有任务都是在`single-1`线程上执行的。考虑以下截图：
- en: '![](img/8eb38d32-4333-4ba7-9041-3ca1254d13c1.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/8eb38d32-4333-4ba7-9041-3ca1254d13c1.png)'
- en: 'Here, the `single` scheduler is meant to execute non-blocking, computation-intensive
    operations. This can be treated as an event loop, executing non-blocking tasks
    in its queue. If we invoke any reactive blocking APIs, the scheduler throws back
    the following error:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`single`调度器是用来执行非阻塞、计算密集型操作的。这可以被视为一个事件循环，在其队列中执行非阻塞任务。如果我们调用任何反应式阻塞API，调度器会抛出以下错误：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to the chain discussed previously, the following has occurred in
    the preceding code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前讨论的链之外，在之前的代码中还发生了以下情况：
- en: We invoked the `window` operator to generate batches of `10` elements each.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用了`window`操作符来生成每个包含`10`个元素的批次。
- en: The subscriber invoked the `blockFirst` API to get back the first element.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者调用了`blockFirst` API来获取第一个元素。
- en: 'Executing the preceding code leads to the following exception:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会导致以下异常：
- en: '![](img/53dbda69-8667-48a3-80b6-622dfff298f1.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53dbda69-8667-48a3-80b6-622dfff298f1.png)'
- en: The parallel scheduler
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行调度器
- en: 'The `Schedulers.parallel` scheduler executes work on a multiple-worker thread
    pool. It creates workers based on the number of available processors. This is
    the default scheduler used in various Reactor operators. Consider the following
    code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.parallel`调度器在多个工作线程池上执行工作。它根据可用的处理器数量创建工作线程。这是在Reactor操作符中使用的默认调度器。考虑以下代码：'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the output, we can validate that all of the tasks in the chain are executed
    on `paralle-1` and `parallel-2` threads. Go through the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以验证链中的所有任务都是在`paralle-1`和`parallel-2`线程上执行的。查看以下截图：
- en: '![](img/89563f6d-82a3-41b1-9ae3-c32573a5f199.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89563f6d-82a3-41b1-9ae3-c32573a5f199.png)'
- en: 'Similar to the `single` scheduler, the `parallel` scheduler is aimed at executing
    non-blocking tasks. If an operation invokes any of the reactive blocking APIs,
    the scheduler will throw back the following exception:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与`single`调度器类似，`parallel`调度器旨在执行非阻塞任务。如果操作调用了任何响应式阻塞API，调度器将抛出以下异常：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The elastic scheduler
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性调度器
- en: 'The `Schedulers.elastic` scheduler executes work on a multiple-worker thread
    pool. Each of the executed workers can execute long-lived tasks that ask for a
    blocking operation. Each worker is returned to the pool when the task finishes.
    There is also an idle time associated with the worker, after which the worked
    is disposed. The scheduler tries to consume an existing idle worker, but if there
    aren''t any, the scheduler dynamically generates one and schedules the task on
    it. The following code shows this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.elastic`调度器在多个工作线程池上执行工作。每个执行的工作线程都可以执行需要阻塞操作的长任务。任务完成后，每个工作线程返回到池中。与工作线程相关联的还有空闲时间，在此之后，工作线程将被销毁。调度器试图消耗现有的空闲工作线程，如果没有，调度器将动态生成一个，并将任务调度到它上面。以下代码展示了这一点：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unlike the previous worker, a blocking reactive call executes on an elastic
    scheduler successfully. Consider the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的工人类似，一个阻塞的响应式调用在弹性调度器上成功执行。查看以下截图：
- en: '![](img/26525eb6-bb91-4dfa-838b-1f526af5eb51.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26525eb6-bb91-4dfa-838b-1f526af5eb51.png)'
- en: The ExecutorService scheduler
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ExecutorService调度器
- en: 'The `Schedulers.fromExecutor` enables us to build a scheduler over the Java
    `ExecutorService`. The scheduler does not own thread generation, but instead,
    it is controlled by the underlying `ExecutorService`. The scheduler should not
    be favored over other schedulers, as the life cycle of the `ExecutorService` must
    be managed by the developer. Consider the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.fromExecutor`使我们能够在Java `ExecutorService`上构建一个调度器。调度器不拥有线程生成，而是由底层的`ExecutorService`控制。不应优先考虑其他调度器，因为`ExecutorService`的生命周期必须由开发者管理。考虑以下代码：'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the following output, we can validate that the service is still running
    after the execution of our reactive chain:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以验证在执行我们的响应式链之后，服务仍在运行：
- en: '![](img/6929c62c-c5ac-4ec0-81c6-d8f7f6d07cf2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6929c62c-c5ac-4ec0-81c6-d8f7f6d07cf2.png)'
- en: Parallel processing
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行处理
- en: Reactor publishers and subscribers do not create threads. However, as seen in
    the previous section, there are operators that can alter this behavior. In the
    last section, we saw that the `delay` operator moved the execution of the Reactor
    chain from the main thread to the scheduler thread. However, we do not need delay/timeout
    operators for the purpose of switching execution. Reactor offers the `publishOn`
    and `subscribeOn` operators for the purpose of switching the chain execution.
    Both of these operators change the execution context of the reactive chain to
    the configured scheduler.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor发布者和订阅者不会创建线程。然而，如前节所示，有一些操作符可以改变这种行为。在最后一节中，我们看到了`delay`操作符将Reactor链的执行从主线程移动到调度线程。但是，我们不需要延迟/超时操作符来切换执行。Reactor提供了`publishOn`和`subscribeOn`操作符来切换链执行。这两个操作符都将响应式链的执行上下文更改为配置的调度器。
- en: PublishOn operator
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PublishOn操作符
- en: 'The `publishOn` operator intercepts events from a publisher at a configured
    point in the execution chain, and sends them to a different scheduler for the
    rest of the chain. As a result, the operator changes the threading context of
    the downstream reactive chain. It is important to note that the operator only
    influences the downstream event chain. It does not alter the upstream chain, and
    leaves the upstream execution to the default execution model. The following code
    shows this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`publishOn`操作符在执行链中配置的点拦截发布者的事件，并将它们发送到链的其余部分的另一个调度器。因此，该操作符改变了下游反应链的线程上下文。需要注意的是，该操作符仅影响下游事件链。它不改变上游链，并让上游执行保持默认执行模型。以下代码展示了这一点：'
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, the following applies:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下规则适用：
- en: We configured the `publishOn` operator before the `filter` operator. This should
    leave the generation on the main thread, and execute the rest of the chain on
    the scheduler.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`filter`操作符之前配置了`publishOn`操作符。这应该会保留主线程上的生成，并在调度器上执行链的其余部分。
- en: We configured the `single` scheduler for the chain execution.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为链式执行配置了`single`调度器。
- en: Since we are not executing the chain on the main thread, we have to pause the
    test execution for some time. This is accomplished by using `Thread.sleep`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不在主线程上执行链，我们必须暂停测试执行一段时间。这是通过使用`Thread.sleep`来实现的。
- en: 'Let''s execute the test case and determine the output. The publisher generates
    events on the `main` thread, which are then passed over to a `single-1` thread,
    as shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行测试用例并确定输出。发布者在`main`线程上生成事件，然后传递到`single-1`线程，如下面的截图所示：
- en: '![](img/53503a77-3911-41b3-856d-520025c25adc.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53503a77-3911-41b3-856d-520025c25adc.png)'
- en: SubscribeOn operator
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SubscribeOn操作符
- en: 'The `subscribeOn` operator intercepts events from a publisher in the execution
    chain and sends them to a different scheduler for the complete chain. It is important
    to note that the operator changes the execution context for the complete chain,
    unlike the `publishOn` operator, which only alters the execution of a downstream
    chain:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn`操作符拦截执行链中的发布者事件，并将它们发送到链的另一个调度器。需要注意的是，该操作符改变了整个链的执行上下文，与仅改变下游链执行的`publishOn`操作符不同：'
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we did the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Configured the `subscribeOn` operator, prior to subscribing.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订阅之前配置了`subscribeOn`操作符。
- en: Configured the `single` scheduler for the chain execution.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置了用于链式执行的`single`调度器。
- en: Since we are not executing the chain on the main thread, we have to pause the
    test execution for some time. This is accomplished by using `Thread.sleep`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不在主线程上执行链，我们必须暂停测试执行一段时间。这是通过使用`Thread.sleep`来实现的。
- en: 'Let''s execute the test case and validate the output. All of the events are
    generated on the single thread configured by the `subscribeOn` operator:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行测试用例并验证输出。所有事件都是在由`subscribeOn`操作符配置的单个线程上生成的：
- en: '![](img/e40c33e3-47ea-431d-b0e4-fc1ebe2ae80a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e40c33e3-47ea-431d-b0e4-fc1ebe2ae80a.png)'
- en: 'We have the `subscribeOn` and `publishOn` operators in the same chain. The
    `subscribeOn` operator will execute the complete reactive chain on the configured
    scheduler. However, the `publishOn` operator will change the downstream chain
    to the specified scheduler. It leaves back the upstream chain on the scheduler
    configured by the `subscribeOn` scheduler:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在同一个链中有了`subscribeOn`和`publishOn`操作符。`subscribeOn`操作符将在配置的调度器上执行完整的反应链。然而，`publishOn`操作符将下游链改为指定的调度器。它将上游链留在由`subscribeOn`调度器配置的调度器上：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code will generate events on a `single-1` scheduler, configured
    by the `subscribeOn` operator. The rest of the chain is executed on a parallel
    scheduler, configured by the `publishOn` operator.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在由`subscribeOn`操作符配置的`single-1`调度器上生成事件。链的其余部分将在由`publishOn`操作符配置的并行调度器上执行。
- en: 'The following is the output after running the preceding code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是运行前面代码后的输出：
- en: '![](img/aecb7263-b72b-4e21-95f6-2a4e3599127b.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aecb7263-b72b-4e21-95f6-2a4e3599127b.png)'
- en: ParallelFlux
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ParallelFlux
- en: Reactor offers `ParallelFlux`, which is capable of splitting an existing stream
    into multiple streams in a round-robin manner. `ParallelFlux` is created from
    an existing `Flux`, using the `parallel` operator. By default, this splits the
    stream into the total number of CPU cores that are available. `ParallelFlux` only
    divides the stream, and does not change the execution model. Instead, it executes
    the streams on the default thread—the main thread. The divided stream can be configured
    for parallel processing by using the `runOn` operator. Similar to the `publishOn`
    operator, the `runOn` takes a scheduler and executes the downstream on the specified
    scheduler.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 提供了 `ParallelFlux`，它可以将现有流分割成多个流，采用轮询方式。`ParallelFlux` 是通过 `parallel`
    操作符从现有 `Flux` 创建的。默认情况下，它会将流分割成可用的 CPU 核心总数。`ParallelFlux` 只分割流，不改变执行模型。相反，它在默认线程——主线程上执行流。分割的流可以通过
    `runOn` 操作符进行并行处理配置。类似于 `publishOn` 操作符，`runOn` 接收一个调度器，并在指定的调度器上执行下游操作。
- en: 'It is important to note that `ParallelFlux` does not offer the `doFinally`
    life cycle hook. It can be converted back to a `Flux` by using the `sequential`
    operator, which can then be configured by using the `doFinally` hook:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`ParallelFlux` 不提供 `doFinally` 生命周期钩子。可以通过使用 `sequential` 操作符将其转换回 `Flux`，然后可以使用
    `doFinally` 钩子进行配置：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, the following applies:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: The `parallel` operator is configured to generate `ParallelFlux` from `fibonacciGenerator`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parallel` 操作符配置为从 `fibonacciGenerator` 生成 `ParallelFlux`。'
- en: The `runOn` operator is used to configure `ParallelFlux` on the parallel scheduler.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`runOn` 操作符用于在并行调度器上配置 `ParallelFlux`。'
- en: The `sequential` operator is used to convert `ParallelFlux` to Flux.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sequential` 操作符将 `ParallelFlux` 转换为 Flux。
- en: '`doFinally` is configured on the `sequential` Flux.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`doFinally` 在 `sequential` Flux 上进行配置。'
- en: '`subscribeOn` is configured to execute Flux generation on a single thread.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subscribeOn` 配置为在单个线程上执行 Flux 生成。'
- en: 'Let''s run the code and validate the output, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码并验证输出，如下所示：
- en: '![](img/7f82c6be-7615-42fb-954c-013baeb7e9d9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f82c6be-7615-42fb-954c-013baeb7e9d9.png)'
- en: So far, we have discussed how to perform stream operations in parallel. In the
    next section, we will deliver events to all subscribers simultaneously, and then
    configure parallel processing for all of them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何并行执行流操作。在下一节中，我们将同时将事件传递给所有订阅者，并为它们配置并行处理。
- en: Broadcasting
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播
- en: In networking, **broadcasting** is defined as simultaneous event publishing
    to multiple receivers. In terms of Reactive Streams, this means simultaneous event
    publishing to multiple subscribers. Until now, we have subscribed to cold publishers,
    where each subscription generates a new series of events. We have even subscribed
    to hot publishers, where the publisher keeps pushing events without waiting for
    a subscriber. Each subscriber gets the same event as soon as it is generated.
    A hot publisher may look like a broadcasting event, but there is a key difference
    with regard to the start of the event generation stream. Reactor allows us to
    create a `ConnecatableFlux`, capable of waiting for *n* subscribers before starting
    event generation. It then keeps publishing each event to all of its subscribers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，**广播** 被定义为向多个接收者同时发布事件。在反应式流中，这意味着向多个订阅者同时发布事件。到目前为止，我们已经订阅了冷发布者，其中每个订阅都会生成一系列新的事件。我们甚至订阅了热发布者，发布者会不断推送事件，而不等待订阅者。每个订阅者都会在事件生成后立即收到相同的事件。热发布者可能看起来像广播事件，但在事件生成流的开始方面有一个关键区别。Reactor
    允许我们创建一个 `ConnecatableFlux`，它能够在开始事件生成之前等待 *n* 个订阅者。然后它会继续将每个事件发布给所有订阅者。
- en: The replay operator
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重放操作符
- en: Reactor provides the `replay` operator to convert a Flux to a `ConnectableFlux`.
    The resulting `ConnectableFlux` keeps buffering events published to the first
    subscriber. The buffer can be configured to keep the last *n* entries, or it can
    be configured to be based on the time duration. Only the buffered events are replayed
    back to the subscribers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 提供了 `replay` 操作符，用于将 Flux 转换为 `ConnectableFlux`。生成的 `ConnectableFlux`
    会持续缓冲发送给第一个订阅者的事件。缓冲区可以配置为保留最后 *n* 个条目，或者可以配置为基于时间长度。只有缓冲的事件会被回放给订阅者。
- en: 'Refer to the following diagram:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下图表：
- en: '![](img/9415c581-8d26-468e-af00-a8ed25743872.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9415c581-8d26-468e-af00-a8ed25743872.png)'
- en: 'A `ConnectableFlux` must be subscribed by *n* subscribers before it starts
    to publish events. `ConnectableFlux` provides the following operators to manage
    subscribers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始发布事件之前，必须由 *n* 个订阅者订阅 `ConnectableFlux`。`ConnectableFlux` 提供以下操作符来管理订阅者：
- en: '**Connect**: The `connect` operator must be invoked after enough subscriptions
    have been made. We must manage the subscription count ourselves. Subscription
    cancellation must also be tracked by developers.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Connect**：必须在足够的订阅已经完成之后调用 `connect` 操作符。我们必须自己管理订阅计数。订阅取消也必须由开发者跟踪。'
- en: '**Auto-Connect**: The `autoConnect` operator configures a subscription count.
    This keeps track of subscriptions made to the publisher dynamically. It is best
    to use the `autoConnect` operator, and leave the subscription management to Reactor.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Auto-Connect**：`autoConnect` 操作符配置了一个订阅计数。这会动态跟踪对发布者的订阅。最好使用 `autoConnect`
    操作符，并将订阅管理留给 Reactor。'
- en: 'Let''s take a look at the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, you can see the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到以下：
- en: The `broadcastGenerator` is generated from `fibonacciGenerator`, using the `replay`
    operator.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`broadcastGenerator` 是使用 `replay` 操作符从 `fibonacciGenerator` 生成的。'
- en: The `broadcastGenerator` waits for two subscribers before starting event publishing.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`broadcastGenerator` 在开始事件发布之前等待两个订阅者。'
- en: '`fibonacciGenerator` is subscribed twice.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fibonacciGenerator` 也被订阅了两次。'
- en: '`broadcastGenerator` is also subscribed twice.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`broadcastGenerator` 也被订阅了两次。'
- en: 'In the preceding code, we have subscribed twice, to both the `fibonacciGenerator`
    and `broadcastGenerator` publishers. Let''s run the test case and validate the
    output, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经对 `fibonacciGenerator` 和 `broadcastGenerator` 发布者进行了两次订阅。让我们运行测试用例并验证输出，如下所示：
- en: '![](img/ed5f9ff8-5b15-46da-8f3e-6a48ba58103b.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed5f9ff8-5b15-46da-8f3e-6a48ba58103b.png)'
- en: In the preceding screenshot (output), we can see that the `fibonacciGenerator`
    publisher is called every time the next value is requested by the respective publisher.
    However, the `broadcastGenerator` publisher is invoked once, and the same value
    is published to both subscribers before generating the next value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图（输出）中，我们可以看到每当相应的发布者请求下一个值时，`fibonacciGenerator` 发布者就会被调用。然而，`broadcastGenerator`
    发布者只被调用一次，在生成下一个值之前，相同的值会被发布给两个订阅者。
- en: The `connect` and `autoConnect` operators, discussed in the preceding section,
    only keep track of subscription events. These start to process events when the
    configured count is reached. They keep publishing them until the publisher sends
    a terminating event. These operators do not keep track of a subscriber cancelling
    the subscription; once event generation has started, it keeps generating events,
    even when the subscribers have cancelled their subscription.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面章节中讨论的 `connect` 和 `autoConnect` 操作符，只跟踪订阅事件。这些操作符在达到配置的计数时开始处理事件。它们会一直发布事件，直到发布者发送一个终止事件。这些操作符不跟踪订阅者取消订阅；一旦事件生成开始，即使订阅者已经取消了订阅，它也会继续生成事件。
- en: 'Reactor provides a `refCount` operator for the previously discussed situation.
    The `refCount` operator also keeps track of the subscription. It stops generating
    new events if all subscribers have cancelled their subscription, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 为之前讨论的情况提供了一个 `refCount` 操作符。`refCount` 操作符也跟踪订阅情况。如果所有订阅者都取消了订阅，它将停止生成新事件，如下所示：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, the following applies:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: The `fibonacciGenerator` is configured for two subscribers, before starting
    event publishing.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始事件发布之前，`fibonacciGenerator` 被配置为两个订阅者。
- en: Each subscriber requests one event.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个订阅者请求一个事件。
- en: Each subscriber cancels its subscription while processing the generated event.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个订阅者在处理生成的事件时取消其订阅。
- en: 'Let''s run the following test case to get the output, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下测试用例以获取输出，如下所示：
- en: '![](img/684e01be-2524-4778-9d07-50cead22f0b1.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/684e01be-2524-4778-9d07-50cead22f0b1.png)'
- en: 'In the preceding output, we can see that the complete Fibonacci series is generated
    before the stream is closed. The subscribers did not ask for more than one event.
    Now, let''s replace `autoConnect` with `refCount`, and compare the output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到在流关闭之前生成了完整的斐波那契数列。订阅者没有请求超过一个事件。现在，让我们将 `autoConnect` 替换为 `refCount`，并比较输出：
- en: '![](img/658f0cfe-4d09-4339-aa64-53737ae41973.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/658f0cfe-4d09-4339-aa64-53737ae41973.png)'
- en: In the preceding output, you can see that the stream is closed as soon as all
    subscribers have cancelled their subscription. Now, if new subscribers arrive
    at `ConnectedFlux`, the series is generated from the first event.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，你可以看到，一旦所有订阅者取消了订阅，流就会立即关闭。现在，如果新的订阅者到达`ConnectedFlux`，序列将从第一个事件生成。
- en: The publish operator
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布操作符
- en: 'Reactor provides the `publish` operator to generate a `ConnectedFlux`. Unlike
    the `replay` operator, which buffers events received by the first subscriber,
    the `publish` operator gets events from the source stream. The operator keeps
    track of the demands raised by its subscribers. If any subscriber does not raise
    a demand, it pauses the event generation until a new demand is raised by all of
    its subscribers. Consider the following diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor提供了`publish`操作符来生成`ConnectedFlux`。与缓冲第一个订阅者接收到的事件的`replay`操作符不同，`publish`操作符从源流获取事件。该操作符跟踪其订阅者提出的请求。如果任何订阅者没有提出请求，它将暂停事件生成，直到所有订阅者都提出新的请求。考虑以下图示：
- en: '![](img/bb8f3485-b6fc-493d-b584-788333cd970e.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb8f3485-b6fc-493d-b584-788333cd970e.png)'
- en: 'Just like the `replay` operator, the `ConnectedFlux` generated by the publisher
    also needs subscriber management. Here, we can configure this by using any of
    the following three options—`connect`, `autoConnect`, or `refCount`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`replay`操作符一样，发布者生成的`ConnectedFlux`也需要订阅者管理。在这里，我们可以通过以下三种选项之一来配置它——`connect`、`autoConnect`或`refCount`：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, the following applies:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下适用：
- en: The `fibonacciGenerator` is configured for two subscribers, before starting
    event publishing.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始事件发布之前，`fibonacciGenerator`被配置为两个订阅者。
- en: The first subscriber requests only one event.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个订阅者只请求一个事件。
- en: The second subscriber does not put a constraint on the event count.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个订阅者不对事件数量施加限制。
- en: 'Let''s run the test case to analyze the output, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试用例来分析输出，如下所示：
- en: '![](img/eb239031-d37e-4604-89ec-6b9c155a5f6e.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb239031-d37e-4604-89ec-6b9c155a5f6e.png)'
- en: In the preceding output, you can see that only the first event is generated.
    There is no closing event either, because the stream was waiting for the next
    event request from subscriber one. Consequently, the stream did not terminate.
    The test finished after waiting for 500 ms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，你可以看到只生成了第一个事件。也没有关闭事件，因为流正在等待订阅者一的下一个事件请求。因此，流没有终止。测试在等待了500毫秒后完成。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Reactor execution models. We discovered that publisher
    and subscriber Reactive Streams are concurrency agnostic. Most of the operators
    in Reactor are also concurrency agnostic. Some operators, such as `delayElements`
    and `timeout`, do alter the concurrency behavior of a stream's execution. Reactor
    provides various schedulers, which can be used to control the execution behavior
    of the stream. We found out that these schedulers can be configured for various
    operators, such as `publishOn` and `subscribeOn`. Next, we discussed `ParallelFlux`,
    which can be configured, along with the available schedulers, to perform parallel
    processing. Finally, we discussed event broadcasting by using `ConnectedFlux`.
    Reactor presents `replay` and `publishOn` operators, to generate a `ConnectedFlux`
    from an existing Flux.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Reactor执行模型。我们发现发布者和订阅者Reactive Streams是并发无关的。Reactor中的大多数操作符也是并发无关的。一些操作符，如`delayElements`和`timeout`，会改变流执行并发行为。Reactor提供了各种调度器，可用于控制流的执行行为。我们发现这些调度器可以为各种操作符进行配置，例如`publishOn`和`subscribeOn`。接下来，我们讨论了可以配置的`ParallelFlux`，以及可用的调度器，以执行并行处理。最后，我们讨论了使用`ConnectedFlux`进行事件广播。Reactor提供了`replay`和`publishOn`操作符，从现有的Flux生成`ConnectedFlux`。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the different types of schedulers that are available in Reactor?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor中可用的不同类型的调度器有哪些？
- en: What scheduler should be used for blocking operations?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪个调度器进行阻塞操作？
- en: What scheduler should be used for computation-intensive operations?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪个调度器进行计算密集型操作？
- en: How are `PublishOn` and `SubscriberOn` different from each other?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PublishOn`和`SubscriberOn`之间有什么不同？'
- en: What is the limitation of `ParallelFlux`?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ParallelFlux`的限制是什么？'
- en: Which operators are available for generating a `ConnectedFlux`?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些操作符可用于生成`ConnectedFlux`？
