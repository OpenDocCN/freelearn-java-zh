- en: Chapter 9. Multi-module Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 多模块项目
- en: 'In this chapter we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Understanding project inheritance
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解项目继承
- en: Understanding project aggregation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解项目聚合
- en: Combining inheritance and aggregation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合继承和聚合
- en: Performing multi-module dependency management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行多模块依赖项管理
- en: Performing multi-module plugin management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行多模块插件管理
- en: Selectively building modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择性构建模块
- en: Reporting for multi-module projects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多模块项目的报告
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Except for simple projects, most real-life projects have more than one module.
    Each of them can be developed independently. Some modules might depend on others.
    A project that uses these modules would want to ensure that it builds successfully
    with the appropriate versions of all the modules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的项目外，大多数现实生活中的项目都有多个模块。每个模块都可以独立开发。一些模块可能依赖于其他模块。使用这些模块的项目希望确保它能够使用所有模块的正确版本成功构建。
- en: As we look at multiple modules, each module may use a number of dependencies.
    To avoid dependency hell, it is important that the versions of dependencies used
    by each module are managed well. There is also an opportunity to optimize on the
    dependencies and plugins to reduce the repetition of build scripts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看多个模块时，每个模块可能都会使用多个依赖项。为了避免依赖地狱，确保每个模块使用的依赖项版本得到良好管理非常重要。还有机会优化依赖项和插件，以减少构建脚本的重复。
- en: Understanding project inheritance
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解项目继承
- en: There are times when you might want a project to use values from another `.pom`
    file. You may be building a large software product, so you do not want to repeat
    the dependency and other elements multiple times.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望项目使用另一个`.pom`文件中的值。你可能正在构建一个大型软件产品，因此不希望多次重复依赖项和其他元素。
- en: Maven provides a feature called **project inheritance** for this. Maven allows
    a number of elements specified in the parent pom file to be merged to the inheriting
    project. In fact, the super pom file is an example of project inheritance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Maven为此提供了一个名为**项目继承**的功能。Maven允许将父POM文件中指定的多个元素合并到继承的项目中。实际上，超级POM文件就是项目继承的一个例子。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Maven is set up on your system and is verified to work. To do this, refer to
    [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Maven已在你的系统上设置并验证其工作。要这样做，请参阅[第1章](ch01.html "第1章. 入门"), *入门*。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open a project that has inheritance; project-with-inheritance in our case. This
    has a subfolder named `child`, which is the project that inherits from the parent.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个具有继承关系的项目；在我们的例子中是`project-with-inheritance`。这个项目有一个名为`child`的子文件夹，它是从父项目继承的项目。
- en: 'Update the parent pom file as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新父POM文件：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the pom file for `child` as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式为`child`创建POM文件：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the following Maven command in the `child` subfolder:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`child`子文件夹中运行以下Maven命令：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Observe the output:![How to do it...](img/6124OS_09_07.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察输出：![如何做到这一点...](img/6124OS_09_07.jpg)
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We specified a `parent` element in the pom file of `child`. Here, we added the
    coordinates of the parent, namely `groupId`, `artifactId`, and `version`. We did
    not specify the `groupId` and `version` coordinates of the `child` project. We
    also did not specify any `properties` and `dependencies`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`child`的POM文件中指定了一个`parent`元素。在这里，我们添加了父项目的坐标，即`groupId`、`artifactId`和`version`。我们没有指定`child`项目的`groupId`和`version`坐标。我们也没有指定任何`properties`和`dependencies`。
- en: In the parent pom file, we specified `properties` and `dependencies`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在父POM文件中，我们指定了`properties`和`dependencies`。
- en: Due to the relationship defined, when Maven runs on the `child` project, it
    inherits `groupId`, `version`, `properties`, and `dependencies` defined in the
    parent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于定义的关系，当Maven在`child`项目上运行时，它会继承父项目中定义的`groupId`、`version`、`properties`和`dependencies`。
- en: Interestingly, the parent pom file (`project-with-inheritance`) is oblivious
    to the fact that there is a `child` project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，父POM文件（`project-with-inheritance`）对存在`child`项目的事实一无所知。
- en: However, this only works if the parent project is of the `pom` type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅当父项目是`pom`类型时才有效。
- en: How did Maven know where the parent pom is located? We did not specify a location
    in the pom file. This is because, by default, Maven looks for the parent pom in
    the parent folder of `child`. Otherwise, it attempts to download the parent pom
    from the repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Maven是如何知道父POM的位置的？我们没有在POM文件中指定位置。这是因为，默认情况下，Maven会在`child`的父文件夹中查找父POM。否则，它会尝试从仓库下载父POM。
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What if the parent pom is not in any repository? Also, what if it is in a different
    folder from the parent folder of the child? Let''s see what happens:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父 pom 文件不在任何仓库中呢？如果它在子项目的父文件夹之外的不同文件夹中呢？让我们看看会发生什么：
- en: Open a child project, where the parent project is not in the `parent` folder
    but in a subfolder (in our case, `parent`):![There's more...](img/6124OS_09_01.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个子项目，其中父项目不在 `parent` 文件夹中，而是在一个子文件夹中（在我们的例子中，是 `parent`）：![还有更多...](img/6124OS_09_01.jpg)
- en: 'Update the pom file of the child project as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新子项目的 pom 文件：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Build the `child` project:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建子项目：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Maven now determines the location of the parent pom by virtue of the `relativePath`
    element, which indicates the folder where the parent pom is located. Using this,
    it builds the child project successfully.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 现在通过 `relativePath` 元素确定父 pom 文件的位置，这表明了父 pom 文件所在的文件夹。使用这个信息，它成功地构建了子项目。
- en: Understanding project aggregation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解项目聚合
- en: A key difference between inheritance and aggregation is that, aggregation is
    defined with a top-down approach, whereas inheritance is defined the other way
    around. In Maven, project aggregation is similar to project inheritance, except
    that the change is made in the parent pom instead of the child pom.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 继承和聚合之间的一个关键区别在于，聚合是通过自上而下的方法定义的，而继承则是相反的方式。在 Maven 中，项目聚合类似于项目继承，只是更改是在父 pom
    文件中进行的，而不是在子 pom 文件中。
- en: Maven uses the term **module** to define a child or subproject, which is part
    of a larger project. An aggregate project can build all the modules together.
    Also, a Maven command run on the parent pom or the pom file of the aggregate project
    will also apply to all the modules that it contains.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 使用术语 **模块** 来定义一个子项目或子项目，它是更大项目的一部分。一个聚合项目可以一起构建所有模块。此外，在父 pom 文件或聚合项目的
    pom 文件上运行的 Maven 命令也将适用于它包含的所有模块。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open a project that has aggregation; in our case `project-with-aggregation`.
    This has a subfolder named `aggregate-child`, which is the module that is aggregated
    by the parent project.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个具有聚合的项目；在我们的例子中是 `project-with-aggregation`。这个项目有一个名为 `aggregate-child`
    的子文件夹，它是被父项目聚合的模块。
- en: 'Update the parent pom as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新父 pom 文件：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the `module` section and specify the child:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `module` 部分，并指定子项目：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the following Maven command in the `parent` folder:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `parent` 文件夹中运行以下 Maven 命令：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Observe the output:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察输出：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We specified the `child` project as a module in the aggregator pom. The child
    project is a normal Maven project, which has no information about the fact that
    there exists an aggregator pom.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在聚合 pom 文件中将 `child` 项目指定为模块。子项目是一个正常的 Maven 项目，它没有关于存在聚合 pom 文件的信息。
- en: When the aggregator project is built, it builds the child project in turn. You
    will notice the word `Reactor` in the Maven output. Reactor is a part of Maven,
    which allows it to execute a goal on a set of modules. While modules are discrete
    units of work; they can be gathered together using the reactor to build them simultaneously.
    The reactor determines the correct build order from the dependencies stated by
    each module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当聚合项目构建时，它会依次构建子项目。你会在 Maven 输出中注意到 `Reactor` 这个词。Reactor 是 Maven 的一部分，它允许在一系列模块上执行目标。虽然模块是离散的工作单元；但可以使用
    reactor 将它们聚集在一起同时构建。Reactor 根据每个模块声明的依赖关系确定正确的构建顺序。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As in the case of inheritance, what the module is, is not a subfolder of the
    aggregator project, but a sibling.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像继承的情况一样，模块不是聚合项目的子文件夹，而是一个同级文件夹。
- en: 'Update the `module` section as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新 `module` 部分：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Build the aggregator project:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建聚合项目：
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Maven now determines the location of the module by virtue of the path specified,
    which indicates the folder where the parent pom is located. By convention, the
    module name is expected to be identical to the folder name.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 现在通过指定的路径确定模块的位置，这表明了父 pom 文件所在的文件夹。按照惯例，模块名称应与文件夹名称相同。
- en: Combining inheritance and aggregation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合继承和聚合
- en: By using the project inheritance feature of Maven, we can share common build
    attributes such as `properties` and `dependencies` across all children. We can
    also aggregate modules and build them together.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Maven 的项目继承功能，我们可以在所有子项目中共享公共构建属性，如 `properties` 和 `dependencies`。我们还可以聚合模块并将它们一起构建。
- en: When project inheritance is used, the parent is not aware of the child. In the
    case of project aggregation, each module is not aware of the aggregation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用项目继承时，父项目不会意识到子项目。在项目聚合的情况下，每个模块都不会意识到聚合。
- en: We will now see how to combine and get the benefits of both.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何结合两者并获取其好处。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open a multi-module project; in our case, `simple-multi-module`. This has a
    subfolder `child`, which is the module that is aggregated by the parent project.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个多模块项目；在我们的例子中，`simple-multi-module`。这个项目有一个子文件夹`child`，它是被父项目聚合的模块。
- en: 'Update the parent pom as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新父pom：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `module` section and specify the child:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`module`部分并指定子项目：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update the child pom to specify the `parent` element:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新子pom以指定`parent`元素：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the following Maven command in the parent folder:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父文件夹中运行以下Maven命令：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Observe the output:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察输出：
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have specified the `parent` element in the `child` pom to indicate who the
    parent is. We have also specified the `child` project as a module in the parent
    pom. Thus, both the relationships—inheritance and aggregation—are defined.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`child` pom中指定了`parent`元素，以指明父项目是谁。我们还在父pom中将`child`项目指定为一个模块。因此，这两种关系——继承和聚合——都被定义了。
- en: When we build the parent project, it automatically builds the child by virtue
    of the `modules` element. At the same time, the child project can be built independently
    as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建父项目时，它通过`modules`元素自动构建子项目。同时，子项目也可以独立构建。
- en: There's more...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The child project need not necessarily be a subfolder of the parent project.
    If it is elsewhere, as we have seen in the earlier recipes, it can be one of the
    following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 子项目不一定是父项目的子文件夹。如果它在其他地方，就像我们在前面的菜谱中看到的那样，它可以如下所示：
- en: '`relativePath`: `relativePath` of the parent element should point to the appropriate
    location of the parent'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`relativePath`：父元素的`relativePath`应指向父元素的正确位置'
- en: '`module`: The `module` element should contain the appropriate path to the child
    project'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`：`module`元素应包含指向子项目的适当路径'
- en: Performing multi-module dependency management
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行多模块依赖项管理
- en: Dependency management is a mechanism to centralize dependency information. When
    there are a set of projects (or modules) that inherit a common parent, all information
    about the dependency can be put in the parent pom and the projects can have simpler
    references to them. This makes it easy to maintain the dependencies across multiple
    projects and reduces the issues that typically arise due to multiple versions
    of the same dependencies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项管理是一种集中化依赖项信息的机制。当有一组项目（或模块）继承一个共同的父项目时，所有关于依赖项的信息都可以放在父pom中，项目可以对这些依赖项进行更简单的引用。这使得在多个项目之间维护依赖项变得容易，并减少了由于同一依赖项的多个版本而通常出现的问题。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open a multi-module project (`simple-multi-module`).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个多模块项目（`simple-multi-module`）。
- en: 'Add a dependency for `junit` in the `dependencyManagement` section:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dependencyManagement`部分添加对`junit`的依赖项：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Update the `dependencies` section of the child project as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新子项目的`dependencies`部分：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Ensure that the build completes successfully.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保构建过程成功完成。
- en: 'Run the Maven command to check the dependency:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Maven命令以检查依赖项：
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Observe the results:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察结果：
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Dependencies that are specified within the `dependencyManagement` section of
    the parent pom are available for use to all the child projects. The child project
    needs to choose the dependencies by explicitly specifying the required dependencies
    in the `dependencies` section. While doing this, the child projects can omit the
    `version` and `scope` information so that they are inherited from the parent.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在父pom的`dependencyManagement`部分指定的依赖项对所有子项目都是可用的。子项目需要通过在`dependencies`部分显式指定所需的依赖项来选择依赖项。在此过程中，子项目可以省略`version`和`scope`信息，以便从父项目继承。
- en: You may ask, "Why have the `dependencyManagement` section when child projects
    inherit dependencies defined in the parent pom anyway?" The reason is, the parent
    centralizes dependencies across several projects. A child project typically needs
    only some of the dependencies that the parent defines and not all of them. The
    `dependencyManagement` section allows child projects to selectively choose these.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：“为什么还要有`dependencyManagement`部分，子项目已经继承了父pom中定义的依赖项？”原因在于，父项目集中管理多个项目的依赖项。子项目通常只需要父项目定义的一些依赖项，而不是全部。`dependencyManagement`部分允许子项目有选择性地选择这些依赖项。
- en: There's more...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `dependencyManagement` section also helps address any surprises of Maven's
    dependency mediation. Dependency mediation is what determines what version of
    dependency will be used when multiple versions of an artifact are encountered.
    However, `dependencyManagement` takes precedence over dependency mediation and
    ensures that dependency mediation does not pick a version over the one specified
    in `dependencyManagement`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencyManagement`部分也有助于解决Maven依赖调解的任何意外。依赖调解是确定在遇到多个版本的工件时将使用哪个版本的过程。然而，`dependencyManagement`优先于依赖调解，并确保依赖调解不会选择`dependencyManagement`中指定的版本之外的版本。'
- en: It should be noted that dependencies on different versions are error prone and
    `dependencyManagement` cannot always save them from library version incompatibilities.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，不同版本的依赖项容易出错，`dependencyManagement`并不能总是避免库版本不兼容的问题。
- en: Performing multi-module plugin management
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行多模块插件管理
- en: In multi-module projects, `pluginManagement` allows you to configure plugin
    information that can be used as required by child projects. The parent pom can
    define the configurations for various plugins used by different child projects.
    Each child project can chose the plugins that it needs for the build.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在多模块项目中，`pluginManagement`允许你配置子项目所需使用的插件信息。父pom可以定义不同子项目使用的各种插件的配置。每个子项目可以选择它构建所需的插件。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open a multi-module project (`simple-multi-module`).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个多模块项目（`simple-multi-module`）。
- en: 'Add a configuration for the Maven build helper plugin in the `pluginManagement`
    section to copy additional resources:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父pom的`pluginManagement`部分添加Maven构建辅助插件的配置，以复制额外的资源：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the following command to build the project:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来构建项目：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the additional resources are not getting copied in the child project.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，额外的资源没有被复制到子项目中。
- en: 'Now, use the corresponding plugin in the child project:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在子项目中使用相应的插件：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Build the project again.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建项目。
- en: 'Observe the output:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察输出：
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We defined the Maven build helper plugin to copy resources from additional folders
    in the `pluginManagement` section of the parent pom. It is not available to the
    child pom until the child uses the plugin. When the child project did not define
    the plugin, the plugin definition in the parent pom had no effect. When the child
    project defined the plugin, it took effect and the additional resources got copied
    over.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在父pom的`pluginManagement`部分定义了Maven构建辅助插件，用于从额外的文件夹中复制资源。直到子项目使用该插件之前，它对子pom不可用。当子项目没有定义插件时，父pom中的插件定义没有效果。当子项目定义了插件时，它生效，并且额外的资源被复制过来。
- en: There's more...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If a plugin is used as part of the build lifecycle, then its configuration
    in the `pluginManagement` section will take effect, even if not explicitly defined
    by the child. Let us see how this happens:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插件是构建生命周期的一部分，那么即使在子项目中没有明确定义，`pluginManagement`部分的配置也会生效。让我们看看这是如何发生的：
- en: 'Define the Maven compiler plugin in `pluginManagement` of the parent pom:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父pom的`pluginManagement`中定义Maven编译插件：
- en: '[PRE25]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Without adding the plugin to the child pom, run the following command using
    Java 7:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不将插件添加到子pom中，使用Java 7运行以下命令：
- en: '[PRE26]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Observe the error:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察错误：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What happened here? Even though the child pom did not define the Maven Compiler
    plugin, the configuration for the Maven Compiler plugin in the `pluginManagement`
    section of the parent pom took effect because the `compile` goal was part of the
    build lifecycle. As the configuration stipulated a Java 8 target, the compilation
    failed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？尽管子pom没有定义Maven Compiler插件，但由于`compile`目标属于构建生命周期的一部分，父pom中`pluginManagement`部分的Maven
    Compiler插件配置仍然生效。由于配置指定了Java 8目标，编译失败。
- en: 'What if we do not want to inherit specific plugin configurations? Maven provides
    a way to do this. Let us see how:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想继承特定的插件配置怎么办？Maven提供了一种方法来实现这一点。让我们看看如何：
- en: 'Update the preceding Maven Compiler plugin configuration as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新前面的Maven编译器插件配置如下：
- en: '[PRE28]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now run the following using Java 7:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用Java 7运行以下命令：
- en: '[PRE29]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Observe that the project compiles without errors, though the plugin configuration
    specified Java 8.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，项目编译时没有错误，尽管插件配置指定了Java 8。
- en: This is because the configuration was not inherited to the child module as we
    set the `inherited` element to `false`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为配置没有被继承到子模块中，因为我们把`inherited`元素设置为`false`。
- en: Selectively building modules
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择性地构建模块
- en: When a project has a number of modules, there may be situations when we might
    want to selectively build modules. One such situation could be because the module
    might run only on specific machines. Another reason could be that a module may
    have long-running tests that may make sense only in test servers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个项目有多个模块时，可能会有一些情况，我们可能想要选择性地构建模块。这种情况之一可能是模块可能只在特定的机器上运行。另一个原因可能是模块可能有长时间运行的测试，这些测试可能只在测试服务器上有意义。
- en: Let us see how we can selectively build modules by using the **profile** feature
    of Maven.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过使用Maven的**配置文件**功能来选择性地构建模块。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open a multi-module project that has two modules (`two-multi-module`), namely
    `common-one` and `dev-two`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个包含两个模块（`two-multi-module`）的多模块项目，即`common-one`和`dev-two`。
- en: 'In the parent pom, add one project to the `modules` section:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父POM中，将一个项目添加到`modules`部分：
- en: '[PRE30]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define a profile and include both modules:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个配置文件并包含两个模块：
- en: '[PRE31]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the Maven command to build with the `dev` profile:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行带有`dev`配置文件的Maven命令构建：
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Observe the result:![How to do it...](img/6124OS_09_02.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察结果：![如何操作...](img/6124OS_09_02.jpg)
- en: 'Run the Maven command to build without profile:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Maven命令构建不带配置文件：
- en: '[PRE33]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Observe the result:![How to do it...](img/6124OS_09_03.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察结果：![如何操作...](img/6124OS_09_03.jpg)
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you have multiple modules and you want to control when specific ones should
    be built, the simplest way to achieve this is to define specific profiles and
    define modules within each of them. In our example, we created a `dev` profile
    to build both modules, `common-one` and `dev-two`. The default Maven build builds
    only the `common-one` module.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有多个模块，并且想要控制特定模块的构建时机时，最简单的方法是为它们定义特定的配置文件，并在每个配置文件中定义模块。在我们的例子中，我们创建了一个`dev`配置文件来构建两个模块，`common-one`和`dev-two`。默认的Maven构建过程只构建`common-one`模块。
- en: What we achieved is the ability to exclude or skip specific modules from build
    as required. As you saw, a profile can only extend the list of modules, so it
    cannot actually blacklist a module.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的是根据需要排除或跳过特定模块的构建。正如你所见，配置文件只能扩展模块列表，因此它实际上不能实现黑名单功能。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Similarly, we could define `pluginManagement` and `dependencyManagement` within
    profiles so that these take effect only for the profiles.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在配置文件中定义`pluginManagement`和`dependencyManagement`，这样它们只对配置文件生效。
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Maven also provides command-line options to build modules selectively. Here
    are some of them with examples based on the `two-multi-module` Maven project:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Maven还提供了命令行选项来选择性地构建模块。以下是一些示例，基于`two-multi-module` Maven项目：
- en: '`-pl –projects`: This is a comma-separated list of projects to be built. An
    example for this is as follows:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-pl –projects`：这是一个以逗号分隔的项目列表，用于指定要构建的项目。以下是一个示例：'
- en: '[PRE34]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`–am`: This stands for `--also-make`: This builds projects required by the
    list if the project list is specified:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–am`：这代表`--also-make`。如果指定了项目列表，这将构建列表中所需的项目：'
- en: '[PRE35]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`–amd`: This stands for `--also-make-dependants`. This builds projects that
    depend on projects on the list (if project list is specified):'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–amd`：这代表`--also-make-dependants`。这会构建依赖于列表中项目的项目（如果指定了项目列表）：'
- en: '[PRE36]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`-rf`: This stands for `–resume-from`. This resumes build from a specific project
    (useful in the case of failures in a multi-module build):'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-rf`：这代表`–resume-from`。这可以从特定的项目恢复构建（在多模块构建失败的情况下很有用）：'
- en: '[PRE37]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Reporting for multi-module projects
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多模块项目的报告
- en: When we talk about generating a site report for a multi-module project, we refer
    to generating this for each module of the project and the parent project. In the
    case of the site report for a multi-module project, a couple of factors need to
    be taken into account. The first one is to test if the links between the parent
    and the modules work correctly. The other is to check if certain site reports
    can be aggregated instead of being reported individually for each module.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论为多模块项目生成站点报告时，我们指的是为项目的每个模块和父项目生成此报告。在多模块项目的站点报告的情况下，需要考虑几个因素。第一个是要测试父模块和模块之间的链接是否正确工作。另一个是要检查是否可以将某些站点报告聚合，而不是为每个模块单独报告。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open a multi-module project (`two-multi-module`) with two modules, one and two.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个包含两个模块的多模块项目（`two-multi-module`），一个和两个。
- en: 'Add the following command to the `reporting` section of the parent pom for
    `checkstyle`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命令添加到父pom的`reporting`部分中的`checkstyle`：
- en: '[PRE38]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the command to generate site report:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令生成站点报告：
- en: '[PRE39]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Click on the **Checkstyle** link in the site report:![How to do it...](img/6124OS_09_04.jpg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击站点报告中**Checkstyle**链接：![如何操作...](img/6124OS_09_04.jpg)
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the `site` goal is run for a multi-module project, it generates the site
    report for all the modules in addition to the parent module. All the reports are
    separately generated for each module. However, plugins such as Checkstyle provide
    an option to generate aggregated report across all the modules of the project.
    This allows us to get a consolidated view of the Checkstyle violations across
    all the modules of the project.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当为多模块项目运行`site`目标时，它除了生成父模块的站点报告外，还为所有模块生成站点报告。所有报告都是为每个模块单独生成的。然而，像Checkstyle这样的插件提供了一个选项，可以在项目的所有模块之间生成聚合报告。这使我们能够获得项目所有模块的Checkstyle违规的统一视图。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Other reporting plugins such as FindBugs, PMD, and Cobertura support multi-module
    reporting. However, not all of them support the aggregation of reports. Other
    reporting plugins that allow aggregated reporting are Javadocs and JXR.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其他报告插件，如FindBugs、PMD和Cobertura支持多模块报告。然而，并非所有这些插件都支持报告的聚合。允许聚合报告的其他报告插件包括Javadocs和JXR。
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Though the site report generated for a multi-module project includes links to
    each child module, the links will not work correctly, as each module report is
    in the `target/site` folder of the respective module.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管为多模块项目生成的站点报告包含了指向每个子模块的链接，但这些链接将无法正确工作，因为每个模块报告都在相应模块的`target/site`文件夹中。
- en: 'Let''s see how we can verify that the modules are correctly linked in the report:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何验证报告中的模块是否正确链接：
- en: 'Add a `distributionManagement` section in the parent pom:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父pom中添加`distributionManagement`部分：
- en: '[PRE40]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the following command to generate site report:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令生成站点报告：
- en: '[PRE41]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the following command to stage the site:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来准备站点：
- en: '[PRE42]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Open the folder:![There's more...](img/6124OS_09_05.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件夹：![更多内容...](img/6124OS_09_05.jpg)
- en: 'You will notice that the site data for both the modules are now subfolders
    of the project site folder. Opening the index page of `fullsite` will allow us
    to navigate to each module site and ensure that the links are working:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，这两个模块的站点数据现在都是项目站点文件夹的子文件夹。打开`fullsite`的索引页面，我们可以导航到每个模块站点并确保链接正常工作：
- en: '![There''s more...](img/6124OS_09_06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/6124OS_09_06.jpg)'
