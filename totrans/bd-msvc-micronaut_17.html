<html><head></head><body>
		<div id="_idContainer148">
			<h1 id="_idParaDest-182"><em class="italic"><a id="_idTextAnchor183"/>Chapter 11</em>: Building Enterprise-Grade Microservices</h1>
			<p>We have reached the last stage of learning about hands-on microservices with Micronaut. Our journey is now in its final stage; we gained a lot of knowledge of being hands-on in Micronaut in the previous chapters. Now, we must connect all the pieces to build our enterprise-grade microservices with Micronaut. As we already know from our previous chapters, the following are some of the benefits of using Micronaut:</p>
			<ul>
				<li>Modern JVM-based full-stack framework</li>
				<li>Easily testable microservices</li>
				<li>Built for serverless applications</li>
				<li>Reactive stack</li>
				<li>Minimal memory footprint and startup time</li>
				<li>Cloud-native framework </li>
				<li>Multi-language support (Java, Groovy, Kotlin)</li>
			</ul>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Bringing it all together</li>
				<li>Architecting enterprise microservices</li>
				<li>Understanding Micronaut's OpenAPI</li>
				<li>Implementing Micronaut's microservices</li>
			</ul>
			<p>By the end of this chapter, you will be well-versed in building, architecting, and scaling enterprise-grade microservices.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>Technical requirements</h1>
			<p>All the commands and technical instructions in this chapter can be run on Windows 10 and Mac OS X. The code examples in this chapter are available in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter11/micronaut-petclinic">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter11/micronaut-petclinic</a>.</p>
			<p>The following tools need to be installed and set up in your development environment:</p>
			<ul>
				<li><strong class="bold">Java SDK</strong>: Version 8 or above (we used Java 13).</li>
				<li><strong class="bold">Maven</strong>: This is optional and only required if you would like to use Maven as your build system. However, we recommend having Maven set up on any development machine. The instructions for downloading and installing Maven can be found at <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</li>
				<li><strong class="bold">Development IDE</strong>: Based on your preference, any Java-based IDE can be used, but in this chapter, IntelliJ was used. </li>
				<li><strong class="bold">Git</strong>: The instructions for downloading and installing Git can be found at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</li>
				<li><strong class="bold">PostgreSQL</strong>: The instructions for downloading and installing PostgreSQL can be found at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>.</li>
				<li><strong class="bold">MongoDB</strong>: MongoDB Atlas provides a free online Database-as-a-Service and up to 512 MB of storage. However, if you would prefer to use a local database, then the instructions for downloading and installing MongoDB can be found at <a href="https://docs.mongodb.com/manual/administration/install-community/">https://docs.mongodb.com/manual/administration/install-community/</a>. We used a local installation while writing this chapter.</li>
				<li><strong class="bold">REST client</strong>: Any HTTP REST client can be used. We used the Advanced REST Client Chrome plugin in this chapter.</li>
				<li><strong class="bold">Docker</strong>: The instructions for downloading and installing Docker can be found at <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>.</li>
				<li><strong class="bold">Amazon</strong>: An Amazon account for Alexa: <a href="https://developer.amazon.com/alexa">https://developer.amazon.com/alexa</a>.</li>
			</ul>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor185"/>Bringing it all together </h2>
			<p>Let's recap everything we learned about in all the chapters so far. In <a href="B16585_01_Final_VK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Microservices Using the Micronaut Framework</em>, we started by looking at microservices while using the Micronaut framework. There, we learned about microservices and their evolution: microservices design patterns. We learned about why Micronaut is the best choice for developing microservices and created our first Micronaut application. In <a href="B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Working on Data Access,</em> we learned about working on data access. </p>
			<p>We started our first pet clinic, pet owner, and pet clinic review Micronaut project. We learned about integrating the persistence layer using the Micronaut framework, as well as about integrating with a relational database using an object-relational mapping Hibernate framework. We created our Micronaut backend database in PostgreSQL, defined relationships among entities, mapped the relationship between entities, and created data access repositories. We also created basic CRUD operations by inserting/creating, reading/fetching, updating, and deleting in the database using Micronaut. After, we integrated the relational database using the MyBatis framework. We also explored NoSQL database functionalities with MongoDB and Micronaut. </p>
			<p>In <a href="B16585_03_Final_VK_ePub.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a>, <em class="italic">Working on RESTful Web Services</em>, we learned about working on RESTful web services using Micronaut. We added RESTful web service capabilities to our pet clinic, pet owner, and pet clinic review Micronaut projects. We learned about data transfer objects, endpoint payloads, map structs, RESTful endpoints, the HTTP server API, validating data, handling errors, versioning the APIs, and the HTTP client API. We performed a RESTful operation on the service with GET, POST, PUT, and DELETE. In <a href="B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a>, <em class="italic">Securing Microservices</em>, we learned about securing microservices. We created a working example of a RESTful microservice by enabling security aspects. We learned about the basics of Micronaut security by using session authentication for securing the service endpoints, implementing a basic authentication provider, configuring authorizations, granting unauthorized and secure access, using JWT authentication, setting up Keycloak in Docker, using OAuth, setting up the Okta identity provider, and enabling SSL in the Micronaut framework.</p>
			<p>In <a href="B16585_05_Final_VK_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Integrating Microservices Using the Event-Driven Architecture</em>, we learned about integrating microservices using the event-driven architecture. We learned about the basics of the event-driven architecture, event streaming with Apache Kafka, and implementing an event producer and event consumer client in the pet clinic reviews microservice. In <a href="B16585_06_Final_VK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Testing Microservices</em>, we mastered testing our microservices with Micronaut. We learned about the basics of unit testing in the Micronaut framework with JUnit 5, mock testing, service testing, the test suite that's available, and integration testing using test Docker containers. </p>
			<p>In <a href="B16585_07_Final_VK_ePub.xhtml#_idTextAnchor132"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling Microservices Concerns</em>, we learned about handling microservices concerns. We learned about externalizing application configurations, distributed configuration management, documenting the Service API using Swagger, implementing service discovery, creating service discovery using Consul, implementing the API gateway service, and implementing fault tolerance mechanisms using circuit breakers and fallbacks. In <a href="B16585_08_Final_VK_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 8</em></a>, <em class="italic">Deploying Microservices</em>, we learned about deploying microservices. We learned about building container artifacts, containerizing using Jib, deploying container artifacts, using <strong class="source-inline">docker-compose</strong>, and deploying a multi-service application. </p>
			<p>In <a href="B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155"><em class="italic">Chapter 9</em></a>, <em class="italic">Distributed Logging, Tracing, and Monitoring</em>, we learned about distributed logging, tracing, and monitoring. We also learned about the log producer, dispatcher, storage, and visualizer. We implemented Elasticsearch, Logstash, and Kibana. After, we set up ELK in Docker, integrated with some Micronaut microservices, and implemented distributed tracing in Micronaut. Finally, we set up Prometheus and Grafana in Docker. In <a href="B16585_10_Final_VK_ePub.xhtml#_idTextAnchor172"><em class="italic">Chapter 10</em></a>, <em class="italic">IoT with Micronaut</em>, we learned about IoT with Micronaut. We learned about IoT, Alexa skills, space facts, utterances, intents, your first Alexa skills, the voice interaction model, integrating Micronaut with Alexa, AWS, AlexaFunction, and testing your AlexaFunction with Micronaut. </p>
			<p>To summarize, we learned about all the building blocks that are required to create an enterprise application using databases, web services, containers, deployments, testing, configuration, monitoring, event-driven architecture, security, and IoT. All the working examples we covered are available in this book's GitHub repository. </p>
			<p>The following diagram provides a summary of all the chapters in this book:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/Figure_11.1_B16585.jpg" alt="Figure 11.1 – Bringing it all together – chapters roadmap&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Bringing it all together – chapters roadmap</p>
			<p>With that, we have learned about the foundations of creating Micronaut microservices. Now that we are familiar with Micronaut, the necessary development tools, testing, databases, the event-driven architecture, distributed logging, tracing, monitoring, and IoT, we have all the necessary knowledge and skills to create enterprise microservices. We will learn about architecting enterprise microservices in the next section. </p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/>Architecting enterprise microservices </h1>
			<p>Implementing <a id="_idIndexMarker795"/>enterprise microservices requires understanding and motivation from multiple stakeholders in the organization. You need to plan and analyze whether a microservice is the right fit for the problem at hand. If it is a fit, then you must design, develop, deploy, manage, and maintain the service.</p>
			<p>Before you start using microservices, let's understand when not to use them. Ask yourself the following questions:</p>
			<ul>
				<li>Does your team know about microservices? </li>
				<li>Is your business mature enough to adopt microservices? </li>
				<li>Do you have an Agile DevOps practice and infrastructure? </li>
				<li>Do you have a scalable on-premises or cloud infrastructure? </li>
				<li>Do you have support to use modern tools and technology? </li>
				<li>Is your database ready to be decentralized?  </li>
				<li>Do you have support from all the stakeholders?</li>
			</ul>
			<p>If your<a id="_idIndexMarker796"/> answer is yes to each of these questions, you can adapt and roll out microservices. The hardest part about rolling out microservices is your data and infrastructure. Traditionally, applications are designed to be big monolithic apps compared to decentralized, loosely coupled microservices. When you architect a microservice, you need to apply multiple techniques during the various phases. The following diagram illustrates the stages of rolling out enterprise microservices:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Figure_11.2_B16585.jpg" alt="Figure 11.2 – Phases of architecting and rolling out enterprise microservices&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Phases of architecting and rolling out enterprise microservices</p>
			<p>We'll look at each of these stages in the following sections.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>Planning and analysis</h2>
			<p>Before you can <a id="_idIndexMarker797"/>create an architecture for an enterprise microservice, you need to analyze whether it is a good fit based on your requirements. You can also implement microservices for just a part of the application. </p>
			<p>Transitioning from a traditional monolithic architecture to microservices can be a time-consuming and complex process. However, if it is planned well, it can be rolled out seamlessly. Getting all stakeholders to support this is crucial, and this can be accomplished in the planning and analysis phase. Team members having knowledge of microservices is also vital and a critical success factor.<a id="_idTextAnchor188"/></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor189"/>Design</h2>
			<p>During the<a id="_idIndexMarker798"/> design phase, you can use design patterns, as we learned in <a href="B16585_01_Final_VK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Microservices Using Micronaut Framework</em>. Design patterns are reusable proven solutions for recurring business or technology problems. The following are the design patterns that we have explored so far in this book:</p>
			<ul>
				<li>Decomposition by business capability</li>
				<li>Decomposing by domains/subdomains</li>
				<li>API gateway pattern </li>
				<li>Chained microservices pattern</li>
				<li>Database per service </li>
				<li>Command query responsibility segregation pattern</li>
				<li>Service discovery pattern </li>
				<li>Circuit breaker pattern </li>
				<li>Log aggregation pattern </li>
			</ul>
			<p>Design patterns are continuously evolving. Always check for new patterns in the industry and evaluate whether they are a good fit for your solution. The next important area to consider when designing a microservice is security. We learned about securing microservices in <a href="B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a>, <em class="italic">Securing Microservices</em>. Here, we learned about evaluating authentication strategies, security rules, privilege-based access, OAuth, and SSL. </p>
			<p>Other factors<a id="_idIndexMarker799"/> to consider when designing are to check for privacy-specific standards in the application such as <strong class="bold">HIPAA</strong> (short for <strong class="bold">Health Insurance Portability and Accountability Act</strong>), <strong class="bold">General Data Protection Regulation</strong> (<strong class="bold">GDPR</strong>), <strong class="bold">Personal Information Protection and Electronic Documents Act</strong> (<strong class="bold">PIPEDA</strong>), Bank Act, and so on. Check for encryption <a id="_idIndexMarker800"/>standards such as<a id="_idIndexMarker801"/> encryption at rest and encryption in transit, whether<a id="_idIndexMarker802"/> your data is encrypted before transmission, or whether your data has been stored and encrypted. Check for the security protocol version currently being used and apply the latest stable, supported version patches. The data retention strategy is another area to think about while designing a microservice. How long do you need to store the data for, and what is the archival strategy for data and log files? Also, some countries have regulations where you can store the data, check the requirements, and consider them while designing.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor190"/>Develop</h2>
			<p>Development is an <a id="_idIndexMarker803"/>essential phase in implementing microservices. Always use the latest stable, supported version for development. Use the Micronaut framework to perform automated testing. Test at various levels, such as unit testing, service testing, and integration testing. In <a href="B16585_06_Final_VK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a><em class="italic">, Testing the Microservices</em>, we learned about testing microservices. Here, we learned that you should always emulate a real-world environment using containers or a cloud infrastructure, as well as using mocking and spying concepts during testing.  </p>
			<p>If you create a separate version control strategy for each service, the service can be stored in separate repositories with the required configuration and logs. Make sure that you synchronize your development, QA, UAT, and PROD environments and that you have an identical infrastructure across various stages of development. During development, think about backward compatibility for the microservices if you would like to support older versions of the microservices. Have a separate database for each microservice to attain their fullest potential. </p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor191"/>Deploy</h2>
			<p>When it comes to <a id="_idIndexMarker804"/>deployment, you should use automated tools and techniques and leverage rapid application deployment strategies. We learned about deploying microservices in <a href="B16585_08_Final_VK_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 8</em></a>, <em class="italic">Deploying Microservices</em>. Use tools such as containers, virtual machines, the cloud, Jib, and Jenkins, and use infrastructure efficiently – don't overallocate. Finally, ensure that you have a <a id="_idIndexMarker805"/>dedicated microservices DevOps strategy to facilitate <strong class="bold">continuous integration</strong> and <strong class="bold">continuous delivery</strong> (<strong class="bold">CI/CD</strong>). </p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor192"/>Manage and maintain </h2>
			<p>Maintaining multiple <a id="_idIndexMarker806"/>microservices is crucial and complex. You should monitor your application with distributed logging, tracing, and monitoring, as we learned in <a href="B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155"><em class="italic">Chapter 9</em></a>, <em class="italic">Distributed Logging, Tracing, and Monitoring</em>. Use tools such as Elasticsearch, Logstash, Kibana, Prometheus, and Grafana to do so. Monitor the code base's health using Sonar DevSecOps and check for security vulnerabilities in the code periodically. You should always update the technology's version, operating system, and tools frequently. Also, monitor your CPU usage, memory footprint, and storage space in real time.</p>
			<p>Finally, scale your infrastructure at runtime to avoid hardware overuse. We will discuss how to scale Micronaut in the upcoming sections.</p>
			<p>Now that we know how to architect the microservices, let's understand more about Micronaut's OpenAPI.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor193"/>Understanding Micronaut's OpenAPI</h1>
			<p>APIs are <a id="_idIndexMarker807"/>generic languages for machines to interact with each other. Having <a id="_idIndexMarker808"/>an API definition ensures there is a formalized specification in place. All APIs should have a specification, which improves development efficiency and reduces interaction problems. The specifications act as documentation that helps third-party developers or systems to understand the service easily. Micronaut supports OpenAPI (Swagger) YAML at compile time. We learned about this in <a href="B16585_07_Final_VK_ePub.xhtml#_idTextAnchor132"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling Microservices Concerns</em>. The <strong class="bold">OpenAPI Initiative </strong>(<strong class="bold">OAI</strong>) was previously known as the <strong class="bold">Swagger Specification</strong>. It is<a id="_idIndexMarker809"/> used to create machine-readable interface files for describing, producing, consuming, and visualizing RESTful web services. The <strong class="bold">OAI</strong> is now a consortium that promotes a vendor-neutral description <a id="_idIndexMarker810"/>format. OpenAPI is also called a <em class="italic">public API</em>, which is publicly made available to software developers and companies. Open APIs can be implemented with REST APIs or SOAP APIs. RESTful APIs are the most popular trending API format used in the industry. OpenAPI must have strong encryption and security in place. These APIs can be public or private (closed). A public <a id="_idIndexMarker811"/>OpenAPI can be accessed over the internet; however, a private OpenAPI can only be accessed in the intranet within a firewall or VPN service. Open APIs generate accurate documentation, such as all the required meta-information, reusable components, and <a id="_idIndexMarker812"/>endpoint details. There are several versions of the <strong class="bold">OpenAPI Specification</strong> (<strong class="bold">OAS</strong>); the current version is 3.1.</p>
			<p>You can learn more about OpenAPI<a id="_idIndexMarker813"/> at <a href="https://www.openapis.org/">https://www.openapis.org/</a>.</p>
			<p>Now that we have learned about Micronaut's OpenAPI, lets, understand scaling Micronaut in the enterprise. </p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor194"/>Scaling Micronaut</h2>
			<p>When designing and <a id="_idIndexMarker814"/>implementing an enterprise application, the ability to scale needs to be planned. One of the biggest advantages of using microservices is scalability. Scaling Micronaut services is a crucial factor by design. It is more than just handling volume – it is about scaling with minimal effort involved. Micronaut makes it easier to identify scaling problems and then resolve challenges at each microservice level. Micronaut microservices are single-purpose applications that can be assembled to build large enterprise-scale software systems. Scaling at runtime is a vital factor in modernizing the enterprise. </p>
			<p>There are three types of scaling: <em class="italic">x</em>-axis, <em class="italic">y</em>-axis, and <em class="italic">z</em>-axis scaling. The following diagram illustrates the x-axis (horizontal scaling) and y-axis (vertical scaling):</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Figure_11.3_B16585.jpg" alt="Figure 11.3 – Vertical scaling versus horizontal scaling&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Vertical scaling versus horizontal scaling</p>
			<p>Horizontal scaling is <a id="_idIndexMarker815"/>also called x-axis scaling. In horizontal scaling, we scale by creating new servers or virtual machines; the entire infrastructure for the service is scaled. For example, if 10 services are running in a virtual machine, we need to add a virtual machine with 10 services if one service requires additional capacity. If you analyze this scenario, there will be unused server capacity as only one service required an additional CPU instead of 10. However, this type of scaling provides unlimited scaling of the infrastructure. </p>
			<p>Vertical scaling is also called y-axis scaling. In vertical scaling, we scale by adding capacity to the existing servers. Capacity is scaled by adding additional CPU, storage, and RAM. For example, if 10 services are running in a virtual machine, if one service requires additional capacity such as RAM and CPU, we need to add extra RAM and CPU to the same virtual machine. This is the fundamental difference between horizontal and vertical scaling. However, vertical scaling has a limitation: it cannot scale beyond a specific limit. The following diagram illustrates the x-axis (horizontal scaling) and z-axis (microservices horizontal scaling):</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/Figure_11.4_B16585.jpg" alt="Figure 11.4 – Traditional horizontal scaling versus microservices horizontal scaling&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – Traditional horizontal scaling versus microservices horizontal scaling</p>
			<p>Microservices<a id="_idIndexMarker816"/> horizontal scaling is also known as z-axis scaling. This is almost the same as traditional horizontal scaling. For example, if 10 services are running in a microservice container environment, if one service requires additional capacity, we need to add one microservice container environment instead of 10. If you analyze this scenario, you will see that this is the most optimal use of the available capacity. This type of scaling allows you to scale the infrastructure as many times as you like and is the most cost-efficient method. Its performance is a lot better than in a non-scaled environment. You can scale with containers and also with cloud infrastructure. The capabilities of autoscaling are very powerful and come in handy for microservices.</p>
			<p>Now we have learned about scaling microservices, let's implement the enterprise microservices with all the features we have learned. </p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor195"/>Implementing Micronaut's microservices</h1>
			<p>Now, let's implement<a id="_idIndexMarker817"/> what we have learned so far in this chapter. You can use the code in this chapter's GitHub repository. We will use the four projects we've covered in this book – pet clinic, pet owner, pet reviews, and concierge. We will also be using a Zipkin container image for distributed tracing, Prometheus for metrics and monitoring, and the <strong class="source-inline">elk</strong> container image for Elasticsearch, Logstash, and Kibana.</p>
			<p>The following screenshot illustrates the list of projects in this book's GitHub repository that we will be using:</p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/Figure_11.5_B16585.jpg" alt="Figure 11.5 – GitHub projects for our implementation &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – GitHub projects for our implementation </p>
			<p>Follow these steps:</p>
			<ol>
				<li>The first step is to set up Keycloak. Please refer to <a href="B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a>, <em class="italic">Securing Microservices</em>, the <em class="italic">Setting up Keycloak as the identity provider</em> and <em class="italic">Creating a client on the Keycloak server</em> sections. <p>The following command can be run to create the Keycloak Docker image: </p><p class="source-code"><strong class="bold">docker run -d --name keycloak -p 8888:8080 -e KEYCLOAK_USER=micronaut -e KEYCLOAK_PASSWORD=micronaut123 jboss/keycloak</strong></p><p class="callout-heading">Note</p><p class="callout">Setting up Keycloak is an important activity, so please ensure that you refer to <a href="B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a>, <em class="italic">Securing Microservices</em>.</p><p>Once your<a id="_idIndexMarker818"/> Keycloak image has been created, start the Keycloak Docker image. The following screenshot illustrates Keycloak running in a Docker container on port <strong class="source-inline">8888</strong>:</p><div id="_idContainer128" class="IMG---Figure"><img src="image/Figure_11.6_B16585.jpg" alt="Figure 11.6 – Docker Keycloak running &#13;&#10;"/></div><p class="figure-caption">Figure 11.6 – Docker Keycloak running </p></li>
				<li>Once Keycloak is up and running, the client secret key needs to be copied from the <strong class="bold">Clients | Credentials</strong> screen. Go to <strong class="bold">Keycloak</strong> | <strong class="bold">Clients</strong> | <strong class="bold">Credentials</strong> | <strong class="bold">Secret</strong>.<p>The following screenshot illustrates the location of your Keycloak <strong class="bold">client ID and secret</strong>:</p><div id="_idContainer129" class="IMG---Figure"><img src="image/Figure_11.7_B16585.jpg" alt="Figure 11.7 – Keycloak portal – Clients – pet-clinic secret &#13;&#10;"/></div><p class="figure-caption">Figure 11.7 – Keycloak portal – Clients – pet-clinic secret </p><p class="callout-heading">Note</p><p class="callout">The Keycloak <strong class="source-inline">pet clinic</strong> user and clients should be set up already. Please refer to <a href="B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a>, <em class="italic">Securing Microservices</em>, for more information.  </p></li>
				<li>Change the <a id="_idIndexMarker819"/>timeout settings in Keycloak. Go to the<strong class="bold"> Keycloak</strong> console | <strong class="bold">Clients</strong> | <strong class="bold">Settings</strong> | <strong class="bold">Advanced Settings</strong>. <strong class="bold">15 Minutes</strong> is recommended for testing the sample code. <p>The following screen illustrates the Keycloak <strong class="bold">Access</strong> <strong class="bold">Token Lifespan</strong> location:</p><div id="_idContainer130" class="IMG---Figure"><img src="image/Figure_11.8_B16585.jpg" alt="Figure 11.8 – Keycloak Access Token Lifespan &#13;&#10;"/></div><p class="figure-caption">Figure 11.8 – Keycloak Access Token Lifespan </p></li>
				<li>The <a id="_idIndexMarker820"/>secret needs to be copied so that it can be replaced in the <strong class="source-inline">pet-clinic</strong>, <strong class="source-inline">pet-owner</strong>, <strong class="source-inline">pet-clinic-reviews</strong>, and <strong class="source-inline">pet-clinic-concierge</strong> projects. The YAML application configuration file, <strong class="source-inline">client-secret</strong>, needs to be updated from the Keycloak secret, as shown in the preceding screenshot. The following are the files that must be updated:<p class="source-code">Chapter11/micronaut-petclinic/pet-clinic-reviews/src/main/resources/application.yml</p><p class="source-code">Chapter11/micronaut-petclinic/pet-owner/src/main/resources/application.yml</p><p class="source-code">Chapter11/micronaut-petclinic/pet-clinic/src/main/resources/application.yml</p><p class="source-code">Chapter11/micronaut-petclinic/pet-clinic-concierge/src/main/resources/application.yml </p><p>The following screenshot illustrates a sample <strong class="source-inline">.yaml</strong> file configuration where the client secret ID needs to be replaced:</p><div id="_idContainer131" class="IMG---Figure"><img src="image/Figure_11.9_B16585.jpg" alt="Figure 11.9 – Keycloak portal – client secret in the application YAML file&#13;&#10;"/></div><p class="figure-caption">Figure 11.9 – Keycloak portal – client secret in the application YAML file</p></li>
				<li>Once <a id="_idIndexMarker821"/>every client secret has been updated, execute the Maven Docker build in all four projects (<strong class="source-inline">pet-clinic-concierge</strong>, <strong class="source-inline">pet-clinic-reviews</strong>, <strong class="source-inline">pet-clinic</strong>, and <strong class="source-inline">pet-owner</strong>). The following Maven command creates a Docker image for each project:<p class="source-code"><strong class="bold">mvn clean compile jib:dockerBuild</strong></p><p class="callout-heading">Note</p><p class="callout">The Postgres database and MongoDB database must be running. Also it must have the database table with data for <strong class="source-inline">pet-clinic</strong> and <strong class="source-inline">pet-reviews</strong>. Refer to <em class="italic">Chapter 02, Working on Data Access</em> for more details.</p></li>
				<li>Check the Docker setting resources. You need four CPUs and at least 6 GB of memory. Go to the<strong class="bold"> Docker</strong> settings | <strong class="bold">Resources</strong> | <strong class="bold">Advanced</strong>:<div id="_idContainer132" class="IMG---Figure"><img src="image/Figure_11.10_B16585.jpg" alt="Figure 11.10 – Docker CPU and memory settings&#13;&#10;"/></div><p class="figure-caption">Figure 11.10 – Docker CPU and memory settings</p></li>
				<li>The <a id="_idIndexMarker822"/>next step, after creating the Docker images, is to create <strong class="source-inline">docker-compose</strong> for Kafka, Zipkin, Prometheus, and ELK. Execute the following command in a terminal or console to create the Docker image:<p class="source-code"><strong class="bold">docker-compose create</strong></p><p class="source-code"><strong class="bold">or </strong></p><p class="source-code"><strong class="bold">docker-compose up -d </strong></p><p>First, Docker Compose needs to be created for <strong class="bold">Kafka</strong>. The configuration file is located here:</p><p class="source-code">Chapter11/micronaut-petclinic/pet-clinic-reviews/src/main/resources/kafka-zookeeper-kafdrop-docker/docker-compose.yml</p><p>This is how the file works:</p><div id="_idContainer133" class="IMG---Figure"><img src="image/Figure_11.11_B16585.jpg" alt="Figure 11.11 – Docker Compose – Kafka&#13;&#10;"/></div><p class="figure-caption">Figure 11.11 – Docker Compose – Kafka</p><p>Next, Docker<a id="_idIndexMarker823"/> Compose needs to be created for <strong class="bold">Zipkin</strong>. The configuration file is located here: </p><p class="source-code"><strong class="source-inline">Chapter11/micronaut-petclinic/docker-zipkin/docker-compose.yml</strong></p><p>This is how the file works:</p><div id="_idContainer134" class="IMG---Figure"><img src="image/Figure_11.12_B16585.jpg" alt="Figure 11.12 – Docker Compose – Zipkin&#13;&#10;"/></div><p class="figure-caption">Figure 11.12 – Docker Compose – Zipkin</p><p>Next, Docker Compose needs to be created for <strong class="bold">Prometheus</strong>. The configuration file is located here:</p><p class="source-code">Chapter11/micronaut-petclinic/docker-prometheus/docker-compose.yml</p><p>This is <a id="_idIndexMarker824"/>how the file works:</p><div id="_idContainer135" class="IMG---Figure"><img src="image/Figure_11.13_B16585.jpg" alt="Figure 11.13 – Docker Compose – Prometheus&#13;&#10;"/></div><p class="figure-caption">Figure 11.13 – Docker Compose – Prometheus</p><p>Now, Docker Compose needs to be created for <strong class="bold">ELK</strong>. The configuration file is located here:</p><p class="source-code"><strong class="source-inline">Chapter11/micronaut-petclinic/docker-prometheus/docker-elk</strong></p><p>This is how the file works:</p><div id="_idContainer136" class="IMG---Figure"><img src="image/Figure_11.14_B16585.jpg" alt="Figure 11.14 – Docker Compose – ELK&#13;&#10;"/></div><p class="figure-caption">Figure 11.14 – Docker Compose – ELK</p><p>Finally, Docker <a id="_idIndexMarker825"/>Compose needs to be created at the parent level. You can do this by going to the following location:</p><p class="source-code">Chapter11/micronaut-petclinic/docker-compose.yml</p><p>Now, this is how the file works:</p><div id="_idContainer137" class="IMG---Figure"><img src="image/Figure_11.15_B16585.jpg" alt="Figure 11.15 – Docker Compose Micronaut pet clinic&#13;&#10;"/></div><p class="figure-caption">Figure 11.15 – Docker Compose Micronaut pet clinic</p><p>Note that the<a id="_idIndexMarker826"/> security configuration protects all the projects using Keycloak, except <strong class="source-inline">pet-clinic-reviews</strong>:</p><ul><li><strong class="source-inline">pet-clinic-concierge</strong>: Protected using Keycloak</li><li><strong class="source-inline">pet-clinic</strong>: Protected using Keycloak</li><li><strong class="source-inline">pet-owner</strong>: Protected using Keycloak</li><li><strong class="source-inline">pet-clinic-reviews</strong>: Unprotected</li></ul></li>
				<li>Before testing the applications, check whether all the applications are running in the Docker container. The following screenshot illustrates the application running in a Docker container successfully:<div id="_idContainer138" class="IMG---Figure"><img src="image/Figure_11.16_B16585.jpg" alt="Figure 11.16 – Docker container running all required applications&#13;&#10;"/></div><p class="figure-caption">Figure 11.16 – Docker container running all required applications</p></li>
				<li>Now that all the <a id="_idIndexMarker827"/>projects are running in Docker, let's test the URL's integration. You can call all the services from the API gateway, as follows:<ul><li><strong class="source-inline">pet-owner</strong>: <strong class="source-inline">http://localhost:32584/api/owners</strong></li><li><strong class="source-inline">pet-clinic</strong>: <strong class="source-inline">http://localhost:32584/api/vets</strong></li><li><strong class="source-inline">pet-clinic-reviews</strong>: <strong class="source-inline">http://localhost:32584/api/vet-reviews </strong><p>Once you have the apps running in Docker, you need to obtain the security token by invoking the following API on Keycloak:</p><p class="source-code">curl -L -X POST 'http://localhost:8888/auth/realms/master/protocol/openid-connect/token' \</p><p class="source-code">-H 'Content-Type: application/x-www-form-urlencoded' \</p><p class="source-code">--data-urlencode 'client_id=pet-clinic' \</p><p class="source-code">--data-urlencode 'grant_type=password' \</p><p class="source-code">--data-urlencode 'client_secret=PUT_CLIENT_SECRET_HERE' \</p><p class="source-code">--data-urlencode 'scope=openid' \</p><p class="source-code">--data-urlencode 'username=alice' \</p><p class="source-code">--data-urlencode 'password=alice'</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">PUT_CLIENT_SECRET_HERE</strong> must be replaced with the Keycloak credentials secret.</p><p>Now, this is<a id="_idIndexMarker828"/> what the request in the console looks like:</p></li></ul></li>
			</ol>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/Figure_11.17_B16585.jpg" alt="Figure 11.17 – curl request to get the JWT&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.17 – curl request to get the JWT</p>
			<p>We can then check that the <strong class="source-inline">curl</strong> request returns an access token:</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/Figure_11.18_B16585.jpg" alt="Figure 11.18 – curl response JWT&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.18 – curl response JWT</p>
			<ol>
				<li value="10">Copy and<a id="_idIndexMarker829"/> format the JSON response using a JSON formatter. The <strong class="source-inline">access_token</strong> attribute value from the formatter response must be copied, and this value will be passed as a JWT, shown as follows:<div id="_idContainer141" class="IMG---Figure"><img src="image/Figure_11.19_B16585.jpg" alt="Figure 11.19 – curl response JWT&#13;&#10;"/></div><p class="figure-caption">Figure 11.19 – curl response JWT</p></li>
				<li>Once you <a id="_idIndexMarker830"/>receive a response from <strong class="source-inline">curl</strong>, you can copy the <strong class="source-inline">access_token</strong> value. <strong class="source-inline">access_token</strong> can be passed to call the services in the request header, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/Figure_11.20_B16585.jpg" alt="Figure 11.20 – REST response for the vets API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.20 – REST response for the vets API</p>
			<p>Now, we must<a id="_idIndexMarker831"/> test all the application URLs and their integration using the following links:</p>
			<ul>
				<li><strong class="bold">API gateway</strong>: <strong class="source-inline">http://localhost:32584/</strong>.</li>
				<li><strong class="bold">Service discovery</strong>: <strong class="source-inline">http://localhost:8500/ui/dc1/services</strong>. This will launch Consul as shown in the screenshot:</li>
			</ul>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/Figure_11.21_B16585.jpg" alt="Figure 11.21 – REST response for the vets API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.21 – REST response for the vets API</p>
			<ul>
				<li><strong class="bold">Distributed logging</strong>: <strong class="source-inline">http://localhost:5601/app/kibana</strong>. This will launch<a id="_idIndexMarker832"/> the Kibana logging portal as shown in the following screenshot:</li>
			</ul>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/Figure_11.22_B16585.jpg" alt="Figure 11.22 – Kibana logging portal&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.22 – Kibana logging portal</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Kibana default username is <strong class="source-inline">elastic</strong> and password is <strong class="source-inline">changeme</strong>.</p>
			<ul>
				<li><strong class="bold">Distributed monitoring</strong>: <strong class="source-inline">http://localhost:3000/?orgId=1</strong>. This will launch the <a id="_idIndexMarker833"/>Grafana monitoring tool. Detailed steps to configure the dashboard can be found in <a href="B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155"><em class="italic">Chapter 9</em></a>, <em class="italic">Distributed Logging, Tracing, and Monitoring</em>:</li>
			</ul>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/Figure_11.23_B16585.jpg" alt="Figure 11.23 – Distributed monitoring using Grafana&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.23 – Distributed monitoring using Grafana</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Prometheus, default username is <strong class="source-inline">admin</strong> and password is <strong class="source-inline">pass</strong>.</p>
			<ul>
				<li><strong class="bold">Distributed tracing</strong>: <strong class="source-inline">http://localhost:9411/zipkin/</strong>. The following <a id="_idIndexMarker834"/>screenshot illustrates the Zipkin user interface for distributed tracing:</li>
			</ul>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/Figure_11.24_B16585.jpg" alt="Figure 11.24 – Distributed tracing using Zipkin&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.24 – Distributed tracing using Zipkin</p>
			<ul>
				<li><strong class="bold">IDP</strong>: <strong class="source-inline">http://localhost:8888/auth/</strong> is the identity provider that will launch Keycloak<a id="_idIndexMarker835"/> which is the identity provider.</li>
				<li><strong class="bold">Kafka Kafdrop</strong>: <strong class="source-inline">http://localhost:9100/</strong>. Here you can view the cluster with Kafdrop:</li>
			</ul>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/Figure_11.25_B16585.jpg" alt="Figure 11.25 – Kafdrop Cluster view &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.25 – Kafdrop Cluster view </p>
			<p>Overall, we have <a id="_idIndexMarker836"/>tested all the features of the integration from the gateway to distributed monitoring, tracking, logging, and searching. With this, we have completed this chapter. In this section, we learned how to implement microservices in Micronaut while in production.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor196"/>Summary</h1>
			<p>In this chapter, we brought everything we'd learned about in the previous chapters together. Then, we dived into architecting enterprise-grade microservices. We also learned about scaling microservices, the different types of scaling, and their advantages. </p>
			<p>This chapter enhanced your Micronaut microservices knowledge so that you can make production-ready applications. It has equipped you with all the necessary skills and expertise. We started the journey with the basics of microservices, and now we have the knowledge to create enterprise-grade microservices with Micronaut. We hope you enjoyed the journey of learning with us. </p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor197"/>Questions</h1>
			<ol>
				<li value="1">Name a few factors you should consider when architecting microservices.</li>
				<li>Name a few design patterns.</li>
				<li>What factors should you consider during the design phase of microservices?</li>
				<li>What factors should you consider during the development phase of microservices?</li>
				<li>Name a few tools that are used in the deployment phase. </li>
				<li>Name a few tools that are used in the manage and maintain phase. </li>
				<li>What are the different types of scaling?</li>
				<li>What type of scaling is used in a microservices architecture?</li>
			</ol>
		</div>
	</body></html>