- en: Adding Web Interfaces to Quarkus Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to build a simple REST application with Quarkus
    and covered the actions that should be put in place to build, test, and deploy
    our application on a Kubernetes environment.
  prefs: []
  type: TYPE_NORMAL
- en: We could stop at this point and be happy with what we have achieved; however,
    there are still lots of milestones to reach. For example, we haven't used any
    web interfaces to access Quarkus services. As you will see in this chapter, Quarkus
    features some extensions that allow us to reuse standard enterprise APIs such
    as Servlets and web sockets. At the same time, you can use lighter JavaScript/HTML
    5 frameworks as user interfaces for your services. We will explore both approaches
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding web content to Quarkus applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our application on Minishift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding enterprise web components to our application such as Servlet and WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Adding web content to Quarkus applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the examples we''ve discussed so far, we''ve tested the web server capabilities
    of Quarkus by adding RESTful services. Under the hood, Quarkus uses the following
    core components to handle web requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vert.x Web server**: It is the core web component in Quarkus delivering RESTful
    services as long as **real-time** (server push) web applications. We will discuss
    more in detail about Vert.x in [Chapter 9](3ca131cb-e293-4c25-a7c8-29d05a409ccd.xhtml),
    *Unifying Imperative and Reactive with Vert.x* of this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undertow Web server**: It is a flexible product, built by combining different
    small single-purpose handlers, that comes into play in Quarkus when delivering
    `WebSocket` applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As already discussed, we can add static web content (HTML, JavaScript, images)
    to our applications by including them under the `resources/META-INF/resources`
    folder of your project. What is the purpose of having static web content in a
    microservice-styled application? As a matter of fact, static content can be used
    in several contexts, including microservices. For example, we could provide helper
    pages for the service itself. We could also mix and match Quarkus with existing
    frameworks such as Swagger UI to test our REST endpoints without even writing
    complex user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: With this premise, we are going to demonstrate how to build a **Create, Read,
    Update, Delete** (**CRUD**) application that uses JSON to consume and produce
    data. Then, we will enrich our application with a thin web interface made from
    a JavaScript-based web framework.
  prefs: []
  type: TYPE_NORMAL
- en: Building a CRUD application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the GitHub source folder for this chapter, you will find two examples.
    The first one is located in the `Chapter04/customer-service/basic` folder and
    will be discussed in this section. We recommend importing the project into your
    IDE before you move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the project''s structure, you will see that it is made
    up of three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, there is a model class that records customer entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Customer` class is the minimal definition of a `Customer` record. It is
    defined as a Plain Old Java Object that should be stored in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, take a look at the `CustomerRepository` class, which contains the core
    functionalities that we''ll use to manage our model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's just a vanilla implementation of a repository that serves
    as a pattern that stores and retrieves our data. In upcoming chapters, we will
    be adding other features, such as persistent storage and asynchronous behavior.
    Due to this, it's good to start with a service-agnostic example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The customer service is completed by the `CustomerEndpoint` class, which has
    the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `CustomerEndpoint` is a thin REST layer over the `CustomerRepository`
    class and contains a method for each CRUD action, where it maps each one to the
    appropriate HTTP method. When using this approach, it would suffice to have a
    single REST path for the whole application (`/customers`) since the REST engine
    will call the appropriate method based on the HTTP request method.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a UI to our customer service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned in [Chapter 1](0e04a6a1-5a50-4557-be00-f4a3406fa1dd.xhtml),
    *Introduction to Quarkus Core Concepts*, you can include static resources such
    as HTML pages, JavaScript, CSS, or images in the `src/main/resources/META-INF/resources`
    folder. An `index.html` page is provided as a marker in our project, as shown
    in the project''s hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to connect to our REST endpoint, we will include a JavaScript framework
    called AngularJS and some CSS styling in the head section of our `index.html`
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, within the head section of the `index.html` page, we will include the
    **AngularJS Controller**, which contains a function that we can use to access
    REST endpoint methods. We will pass the HTML form data as an argument, which we
    will discuss next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An in-depth discussion of AngularJS is beyond the scope of this book; however,
    in a nutshell, Angular applications rely on controllers to manage their flow of
    data. Each controller accepts `$scope` as a parameter. This parameter refers to
    the module or application that the controller needs to handle.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of our controller will be to reach out to our REST application using
    different HTTP methods (`GET`, `POST`, `PUT`, and `DELETE`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of the `index.html` page contains the form data, which can be
    used to insert new customers and edit existing ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we're done with the `index.html` page, we can write a test class for
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before testing our application, it is worth mentioning that the `quarkus-jsonb`
    dependency has been included in this project in order to produce JSON content
    through the REST endpoint and to create JSON objects programmatically in the test
    class. The following is the dependency we have included in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is our `CustomerEndpointTest` class, which can be used to validate
    the `Customer` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's switch gears and look a little more closely at the test class. Most of
    the content here should look familiar to you, except for the `Json.createObjectBuilder`
    API, which is a convenient factory method that we can use to fluently create JSON
    objects. In our code, we have used it to produce two instances of `javax.json.JsonObject`.
    The first one has been serialized as a string and sent to our `CustomerEndpoint`
    via an HTTP `POST` call. The second one has been adopted to update the customer
    via the HTTP `PUT` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can package and test the application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show the test result, which should be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `testCustomerService` method completed successfully. Now that we have a
    tested REST application, we'll learn how to get our application running in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Running the example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the full project is at our fingertips, let''s see it in action! You
    can start the application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go to the home page at `http://localhost:8080`. You should be able to
    see the following UI, where you can add new customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2063641a-ff2f-462e-9c0d-b51c8dae5814.png)'
  prefs: []
  type: TYPE_IMG
- en: As you already know, the embedded Vert.x server will serve content from under
    the root context. If you want to vary this, you can configure the `quarkus.http.root-path`
    key in `application.properties` to set the context path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have some data, other actions (such as Edit and Delete) will be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cd1c02c-5776-4c27-a149-b851814d1b73.png)'
  prefs: []
  type: TYPE_IMG
- en: Cool! You can try editing and deleting data to verify that all the REST methods
    work properly. Now, we will learn how to deploy our application on Minishift.
  prefs: []
  type: TYPE_NORMAL
- en: Running our application on Minishift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start your Minishift environment as usual and execute the following command
    to build the native executable Docker image of your application and deploy it
    in a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Building the native image of your application will take a minute or so. Next,
    we will upload the application as a binary build into a Minishift namespace. You
    should already be familiar with these steps, so we will just include the script
    to be executed, along with some inline comments. Execute each line and verify
    that the output is successful for all the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should be able to see the Pod where your application is running in
    the Overview panel, which can be reached through the Route - External Traffic
    link: http://quarkus-customer-service-quarkus-customer-service.192.168.42.53.nip.io
    (the actual route address depends on the IP address that''s been assigned to your
    environment):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78836d82-1c4b-45ef-bb7c-d06ea32f4ddb.png)'
  prefs: []
  type: TYPE_IMG
- en: By clicking on the Route - External Traffic link, you will be able to verify
    that your application works in a Kubernetes environment, just like your local
    copy does.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Cross-Origin Resource Sharing in Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have used JavaScript to drive a request into Quarkus' service.
    In a more complex scenario where your JavaScript code is deployed in its own service
    on a distinct host or context, you will have to implement **Cross-Origin Resource
    Sharing** (**CORS**) to make it work. In a nutshell, CORS allows web clients to
    make HTTP requests to servers hosted on different origins. By **origin**, we mean
    a combination of the URI scheme, hostname, and port number.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially challenging for client-side languages such as JavaScript
    because all modern browsers require a same-origin policy for scripting languages.
  prefs: []
  type: TYPE_NORMAL
- en: To make this work, we need to put our server applications in charge of deciding
    who can make requests and what type of requests are allowed in using HTTP headers.
    In practice, when the server receives a request from a different origin, it can
    reply and state which clients are allowed to access the API, which HTTP methods
    or headers are allowed, and finally whether cookies are allowed in the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does that translate into Quarkus configurations? As you may have guessed,
    the configuration has to be applied to the `application.properties` file, under
    the `quarkus.http.cors` namespace. The following is a sample configuration that
    allows CORS for all domains, all HTTP methods, and all common headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In real-world scenarios, you would probably set the list of allowed origins
    to the domain asking to connect remotely, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've clarified this, we can look at another example where we'll use
    a Java Enterprise component, such as `WebSocket`, to reach our Quarkus service.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Enterprise web components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our customer service example, the frontend application used a JavaScript
    structural framework (AngularJS) to test our application. Now, we will consider
    a different use case: a new external service is going to connect to our application
    using a different protocol stack. Besides JAX-RS endpoints, Quarkus has native
    support for the `WebSocket` technology that runs in the embedded Undertow web
    server. Therefore, in this example, we will add a `WebSocket` endpoint to our
    existing application. This will be paired with another `WebSocket` running in
    a different application.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First off, let's briefly introduce new components for our application. `WebSocket`,
    as defined by its enterprise specification, is an API that establishes **socket**
    connections between a browser and a server endpoint. This is pretty much similar
    to standard TCP sockets due to its persistent connection between the client and
    the server, where both parties can start sending data at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, you would open a `WebSocket` connection simply by calling the `WebSocket`
    constructor in your JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice the URL schema for `WebSocket` connections (`ws:`). We also have `wss:`
    for secure `WebSocket` connections, which is used in the same way as `https:`
    is for secure HTTP connections.
  prefs: []
  type: TYPE_NORMAL
- en: We can attach some event handlers to the connection to help us determine when
    the connection status is open, receiving messages, or when errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare a Java class `WebSocket` server endpoint on the server-side
    by annotating it with `@ServerEndpoint`. The URI where the endpoint is deployed
    needs to be specified as well, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will be adding a `WebSocket` layer to our existing project
    and then creating another thin project to remotely access `WebSocket` and add
    new customers.
  prefs: []
  type: TYPE_NORMAL
- en: Building a project that uses Websockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will find two distinct projects within the `Chapter04/customer-service/websockets`
    folder in this book''s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: An updated `customer-service` project that ships with a `WebSocket` endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A project called `customer-service-fe` that features a minimal JavaScript frontend
    for our `WebSocket` application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should import both projects into your IDE before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s discuss the `customer-service` project. The main enhancement
    we have added is a `WebSocket` endpoint, which is in charge of inserting a new
    customer (using the `CustomerRepository` bean) and returning a tabular view of
    our customers. The following is the content of the `WebsocketEndpoint` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to notice here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method tagged with `@OnMessage` receives the customer to be added in JSON
    format as input and returns an updated list of customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class uses an **encoder** in order to customize the message that's returned
    to the client. An encoder takes a Java object and produces its serialized representation,
    which can then be transmitted to the client. For example, an encoder is typically
    in charge of producing JSON, XML, and binary representations. In our case, it
    encodes the customer list in JSON format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `MessageEncoder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, an `Encoder` must implement either of the following interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Encoder.Text<T>` for text messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Encoder.Binary<T>` for binary messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, `List<Customer>` is received as a generic type in the `encode`
    method and transformed into a JSON string array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be compiled, our project needs the `quarkus-undertow-websockets` extension,
    which can be added manually into the `pom.xml` file. Alternatively, you can let
    the Maven plugin do it for you with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output on your console, which confirms that the
    extension has been added to our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The server project is now complete. You can compile it and run it with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's create a new frontend project with a thin `WebSocket` JavaScript
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebSocket client project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WebSocket` clients, just like their server counterparts, can be written in
    many different languages. Since modern browsers have native support for `WebSocket`,
    we will write a simple JavaScript client so that we don''t have to install any
    additional tools or SDKs to run our example.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the `customer-service-fe` folder, you will find the frontend project
    that can be used to reach our `WebSocket` example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our project contains a landing page named `index.html`, which is served when
    we request the root web context of our application. Within this page, we have
    included an HTML form and a table to display a list of customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The connection to the `WebSocket` endpoint takes place in an external JavaScript
    file named `function.js` (you can find this in the `customer-service-fe/src/main/resources/META-INF/resources`
    folder in this book''s GitHub repository). Then following is the content of this
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are several callback methods (`onOpen`, `onMessage`, `onError`)
    that are coupled with server events once the connection is established. Here,
    we will be adding a new customer, serialized as a JSON string, in the `doSend`
    method, while the `onMessage` callback method will receive the list of customers
    that was produced by our `WebSocket` encoder. This data will eventually be included
    in an HTML table.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the project with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have shifted the HTTP and debug port with an offset of `1000`
    so that it doesn't conflict with the `customer-service` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing to `http://localhost:9080` will let you into the `WebSocket` client
    application. Add some sample data to verify that customers can be included in
    the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27c0ff2a-9cbd-476c-8657-ef9151bfed99.png)'
  prefs: []
  type: TYPE_IMG
- en: Verify that the same data is also displayed in the AngularJS frontend, which
    is available at `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an AJAX handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our JavaScript client is primarily required when it comes to testing our `WebSocket`
    example. However, one more enhancement you will find in this project is a Java
    Servlet that will let you remove any hardcoded links to your backend so that both
    services can still communicate as we move our example to a different machine or
    port.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Servlet determines server endpoint information from an environment
    variable named `CUSTOMER_SERVICE` by using the `ws://localhost:8080/customers`
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This change needs to be reflected in our JavaScript client so that it doesn''t
    use a hardcoded endpoint for our web socket. In the final version of the `function.js`
    file, you will find the following JavaScript function, which queries our Servlet
    via AJAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is called when the HTML page is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start the server from the same shell so that it reads the environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, go to `http://localhost:9080` and verify that the output produced by the
    `WebSocket` request is the same as when the server endpoint address was statically
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take this example one step further by varying `quarkus.http.port` in
    your `customer-service` application. For example, you could set it to `8888`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`customer-service-fe` will be able to connect to the `WebSocket` endpoint once
    you have set the `CUSTOMER_SERVICE` environment variable accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Great! In this section, we removed any static hardcoded information from our
    client application, which now uses an environment variable to reach out to the
    customer service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the different paths we can take to add web content
    to our Quarkus applications. First, we learned how to create a CRUD in-memory
    application to manage a set of Java objects. The example application was then
    accessed by a JavaScript layer (AngularJS) with some peculiar APIs to handle REST
    calls. We also looked at some configuration parameters that are needed when we
    want to enable CORS in Quarkus projects. Next, we added a `WebSocket` layer to
    introduce full-duplex communication between the initial project and the client
    frontend.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this chapter, you now know how to use the embedded Vert.x and
    Undertow server to leverage REST APIs (`quarkus-resteasy`) and `WebSocket`/Servlet
    APIs (`quarkus-undertow-websockets`).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add database storage for our application using
    the Hibernate ORM and Hibernate Panache extensions.
  prefs: []
  type: TYPE_NORMAL
