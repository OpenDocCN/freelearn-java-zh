<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Hacking OpenJDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Hacking OpenJDK</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the development environment with NetBeans</li><li class="listitem" style="list-style-type: disc">Working with Mercurial forests</li><li class="listitem" style="list-style-type: disc">Understanding OpenJDK 6 and 7 incremental builds</li><li class="listitem" style="list-style-type: disc">Debugging Java code using NetBeans</li><li class="listitem" style="list-style-type: disc">Debugging C++ code using NetBeans</li><li class="listitem" style="list-style-type: disc">Using NetBeans to compile HotSpot</li><li class="listitem" style="list-style-type: disc">Using HotSpot dev parameters</li><li class="listitem" style="list-style-type: disc">Adding new intrinsic to HotSpot</li><li class="listitem" style="list-style-type: disc">Building VisualVM from the source code</li><li class="listitem" style="list-style-type: disc">Creating a plugin for VisualVM</li><li class="listitem" style="list-style-type: disc">Getting benefits from the AdoptOpenJDK project</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec56"/>Introduction</h1></div></div></div><p>The real beauty of OpenJDK is its open nature, which means that developers can not only use it to run an application, but also change it to their needs or contribute to its development. The availability of the source code and ease of access to it opens huge opportunities to individuals who have special requirements, or just want to learn more about the way JVM works internally and want to adapt it for any special requirements. This chapter will help you to get into it and provide some recipes to make the process of setting up the required development environment as easy as possible.</p><p>At first, it will cover how to set up the development environment and which tools are required to get started. It will cover the IDE setup, and some tweaks required to launch JVM and start debugging. The next step is to make changes and rebuild the code, and the latter is going to be slightly different from the normal build described in <a class="link" href="ch05.html" title="Chapter 5. Building IcedTea">Chapter 5</a>, <span class="emphasis"><em>Building IcedTea</em></span>, <a class="link" href="ch06.html" title="Chapter 6. Building IcedTea with Other VM Implementations">Chapter 6</a>, <span class="emphasis"><em>Building IcedTea with Other VM Implementations</em></span>, and <a class="link" href="ch07.html" title="Chapter 7. Working with WebStart and the Browser Plugin">Chapter 7</a>, <span class="emphasis"><em>Working with WebStart and the Browser Plugin</em></span>. The rest of that section dedicated to will be useful techniques which can be used to debug changes.</p><p>This chapter assumes that the reader has a reasonable knowledge of C++ and Java. Any knowledge of JVM is ideal, as the reader should know what JIT is and how it works.</p><p>Most of the recipes in the JIT section are independent and can be executed separately, so the reader just can pick what he/she needs and proceed with it.</p></div></div>
<div class="section" title="Setting up the development environment with NetBeans"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Setting up the development environment with NetBeans</h1></div></div></div><p>This recipe <a id="id273" class="indexterm"/>will cover the steps required to install, run, and set up the project in NetBeans IDE. NetBeans is an open source IDE for <a id="id274" class="indexterm"/>developing, primarily in Java. It also has rich support for C++ and that makes it a good tool for OpenJDK development which uses both languages. This recipe uses NetBeans IDE v.7.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec193"/>Getting ready</h2></div></div></div><p>Download the latest version of the NetBeans <code class="literal">All</code> bundle<a id="id275" class="indexterm"/> for your platform from <a class="ulink" href="http://www.netbeans.org/downloads">http://www.netbeans.org/downloads</a>. The <code class="literal">All</code> bundle must have C/C++ and Java support in the same IDE. It is also necessary to have the OpenJDK code checked out and available on the machine.</p><p>Make sure that everything is set up for the OpenJDK build and it can be executed without errors. How to do that is described in <a class="link" href="ch02.html" title="Chapter 2. Building OpenJDK 6">Chapter 2</a>, <span class="emphasis"><em>Building OpenJDK 6</em></span>, <a class="link" href="ch03.html" title="Chapter 3. Building OpenJDK 7">Chapter 3</a>, <span class="emphasis"><em>Building OpenJDK 7</em></span>, and <a class="link" href="ch04.html" title="Chapter 4. Building OpenJDK 8">Chapter 4</a>, <span class="emphasis"><em>Building OpenJDK 8</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec194"/>How to do it...</h2></div></div></div><p>We will install and configure the NetBeans IDE that is used in the OpenJDK project as the standard one.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First we need to install the NetBeans IDE. This is a very simple process which consists of a few simple steps. Run the downloaded executable and at the bottom of the first screen, select the <span class="strong"><strong>Customize</strong></span> button. This will show following window:<div class="mediaobject"><img src="graphics/8405OT_08_01.jpg" alt="How to do it..."/></div><p>Ensure that <span class="strong"><strong>Base IDE</strong></span>, <span class="strong"><strong>Java SE</strong></span>, <span class="strong"><strong>C/C++</strong></span>, and <span class="strong"><strong>Features on Demand</strong></span> are selected. The rest are optional and not required to run and debug OpenJDK, but there is no harm in installing that functionality.</p></li><li class="listitem">After<a id="id276" class="indexterm"/> the<a id="id277" class="indexterm"/> setup, all plugins you should update to the latest version. Updates are available via the <span class="strong"><strong>Help/Check for updates</strong></span> menu item.</li><li class="listitem">When NetBeans is set up, it is required to make a slight change to its configuration.<p>OpenJDK is a big project and its memory requirements are bigger than the ones defined in the default settings. To increase the memory available for IDE:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the <code class="literal">$HOME/.netbeans/NETBEANS_VERSION/etc</code> folder (on Windows <code class="literal">$HOME</code> is <code class="literal">%HOMEPATH%</code>).</li><li class="listitem">If the folder doesn't exist, create it.</li><li class="listitem">Then, if that folder doesn't have the <code class="literal">netbeans.conf</code> file, copy it from the Netbeans installation directory, which is located in the <code class="literal">etc</code> folder.</li><li class="listitem">Open the file with any text editor and locate the <code class="literal">netbeans_default_options</code> parameter which it should look similar to this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>netbeans_default_options="-J-client -J-Xss2m -J-Xms32m -J-XX:PermSize=32m -J-Dapple.laf.useScreenMenuBar=true -J-Dapple.awt.graphics.UseQuartz=true -J-Dsun.java2d.noddraw=true -J-Dsun.java2d.dpiaware=true -J-Dsun.zip.disableMemoryMapping=true"</strong></span>
</pre></div></li></ol></div></li><li class="listitem">When<a id="id278" class="indexterm"/> the <a id="id279" class="indexterm"/>parameter is located, add <code class="literal">-J-Xmx2g</code>, or, if that option is already present, update it to a value not less than <code class="literal">2G</code> (2 gigabytes). This will increase the memory available to JDK to <code class="literal">2G</code>. Restart your IDE if it was running before in order to apply that change.<div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>It is worth adding that, because of the large memory requirement of Netbeans IDE, It's recommended to run it on a system that is capable of providing nothing less than 2 GB of memory to the process. Basically, it means that it should be a machine with a 64-bit OS and about 4 to 6 GB of RAM.</p></div></div></li><li class="listitem">Now Netbeans IDE is ready for the project to be set up. Run it and go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Project</strong></span> on the dialog box and select <span class="strong"><strong>C/C++ Project with Existing Sources</strong></span>:<div class="mediaobject"><img src="graphics/8405OT_08_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Then <a id="id280" class="indexterm"/>press <span class="strong"><strong>Next</strong></span> and, on the <a id="id281" class="indexterm"/>following dialog box, select the folder with the root of OpenJDK sources:<div class="mediaobject"><img src="graphics/8405OT_08_03.jpg" alt="How to do it..."/></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>You can always obtain your OpenJDK code by typing <code class="literal">hg clone http://hg.openjdk.java.net/jdk6/jdk6 &amp;&amp; ./get_source.sh</code></p></div></div></li><li class="listitem">Press <a id="id282" class="indexterm"/><span class="strong"><strong>Finish</strong></span> and Netbeans will attempt to clean and build the project<a id="id283" class="indexterm"/>. Clean, most probably, will execute without problems, but build will not work because it requires some environment setup, which we will do later on.<p>After trying to build the project, Netbeans will spend a fair bit of time (minutes) scanning sources and building indexes. This would be a good time to have some coffee.</p></li><li class="listitem">The next step is to configure Netbeans to build the project. As already mentioned, the build script requires some environment setup. The following is a simple bash script which can be used to create an appropriate environment:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/bin/sh</strong></span>
<span class="strong"><strong>export LANG=C</strong></span>
<span class="strong"><strong>export ALT_BOOTDIR=/usr/lib/jvm/java</strong></span>
<span class="strong"><strong>./jdk/make/jdk_generic_profile.sh</strong></span>
<span class="strong"><strong>make $*</strong></span>
</pre></div></li><li class="listitem">In the <a id="id284" class="indexterm"/>root folder of the OpenJDK source tree, create a file <code class="literal">build.sh</code> and save this script in that folder.</li><li class="listitem">Then <a id="id285" class="indexterm"/>navigate to the <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Set project configuration</strong></span> | <span class="strong"><strong>Customize</strong></span> menu item and, in the tree on the left-hand side, select <span class="strong"><strong>Build</strong></span> | <span class="strong"><strong>Make</strong></span>. There you will see the following dialog:<div class="mediaobject"><img src="graphics/8405OT_08_04.jpg" alt="How to do it..."/></div></li><li class="listitem">As show<a id="id286" class="indexterm"/>n in the screenshot, set the <span class="strong"><strong>Build Command</strong></span> and <span class="strong"><strong>Clean Command</strong></span> variables to execute your <code class="literal">./build.sh</code> with the <code class="literal">debug_build</code> and <code class="literal">clean</code> commands, respectively.</li><li class="listitem">If the<a id="id287" class="indexterm"/> <code class="literal">product</code> version of OpenJDK is required, then just create another configuration with <code class="literal">product_build</code> and the parameter for <code class="literal">build.sh</code>.</li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec195"/>See also</h2></div></div></div><p>Netbeans is not the only available IDE which supports both Java and C++. There are other IDEs which are similarly capable. One example is the Eclipse IDE which is also a powerful multiplatform IDE written in Java, and has similar functionality.</p></div></div>
<div class="section" title="Working with Mercurial forest"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Working with Mercurial forest</h1></div></div></div><p>Mercurial is<a id="id288" class="indexterm"/> a cross-platform version control system. It was designed to work with big projects and large amounts of code, which undoubtedly are present in the OpenJDK project. The OpenJDK official repository is a Mercurial.</p><p>The Forest plugin is the one used for various OpenJDK subprojects to merge and coexist. It works with nested Mercurial repositories, which normally are regarded as isolated. The main idea is to propagate changes from the root repository to the nested ones.</p><p>The main <a id="id289" class="indexterm"/>purpose of it is to allow a developer to work with the code, which is a minor part of a full OpenJDK project repository, without needing to make any changes to the whole repository (change a revision number, for example).</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec196"/>Getting ready</h2></div></div></div><p>First of all, we will need to<a id="id290" class="indexterm"/> install Mercurial itself. On Windows it can be done by going to the official Mercurial site and <a id="id291" class="indexterm"/>downloading it from <a class="ulink" href="http://mercurial.selenic.com/wiki/Download">http://mercurial.selenic.com/wiki/Download</a>.</p><p>For Linux distributions, there are, usually, Mercurial versions in their official repositories.</p><p>For example, on Debian and Debian-inherited distributions, Mercurial installs as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install mercurial</strong></span>
</pre></div><p>If you have any problems with a Mercurial installation, refer to the official site or to your Linux distribution resources.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec197"/>How to do it...</h2></div></div></div><p>Let's explain it with a simple, non Java-related example. We will assume that a Mercurial instance already exists in the OS. Since Mercurial has a command line tool, we will use a command line for everything.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's create two repositories:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir repo-one</strong></span>
<span class="strong"><strong>cd repo-one</strong></span>
<span class="strong"><strong>hg init</strong></span>
<span class="strong"><strong>echo "hello" &gt; hello.txt</strong></span>
<span class="strong"><strong>hg ci -m"init one"</strong></span>
<span class="strong"><strong>cd ..</strong></span>

<span class="strong"><strong>mkdir repo-two</strong></span>
<span class="strong"><strong>cd repo-two</strong></span>
<span class="strong"><strong>hg init</strong></span>
<span class="strong"><strong>echo "hello" &gt; hello.txt</strong></span>
<span class="strong"><strong>hg ci -m"init two"</strong></span>
<span class="strong"><strong>cd ..</strong></span>
</pre></div></li><li class="listitem">We will need to locate the <code class="literal">.hgrc</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>locate hgrc</strong></span>
</pre></div></li><li class="listitem">Let's copy the <code class="literal">forest.py</code> file from <a class="ulink" href="https://bitbucket.org/gxti/hgforest/src">https://bitbucket.org/gxti/hgforest/src</a>.</li><li class="listitem">Then let's edit your <code class="literal">.hgrc</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[extensions]</strong></span>
<span class="strong"><strong>forest = patch/to/forest.py</strong></span>
</pre></div></li></ol></div><p>We <a id="id292" class="indexterm"/>now have a brand new <code class="literal">fclone</code> command in our repository.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's copy the first repository into the second one:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>hg clone repo-one repo-two/one</strong></span>
</pre></div><p>The <code class="literal">repo-two</code> repository isn't an integral part of <code class="literal">repo-one</code>, it only lays inside it.</p></li><li class="listitem">Let's clone a <code class="literal">repo-two</code> repository and attach <code class="literal">repo-one to it</code>, using the <code class="literal">fclone</code> command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>hg fclone repo-two wc-two</strong></span>
</pre></div><p>We've just copied <code class="literal">repo-two</code>, including <code class="literal">repo-two/one</code>.</p></li><li class="listitem">Let's make some changes to <code class="literal">repo-two/hello.txt</code> and <code class="literal">repo-two/one/hello.txt</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>echo some &gt;&gt; repo-two/hello.txt  &amp;&amp;  echo some1 &gt;&gt; repo-two/hello.txt</strong></span>
</pre></div></li><li class="listitem">We will commit each change using a separate command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd wc-two/ &amp;&amp; ls</strong></span>
<span class="strong"><strong>hg ci -m"edited hello.txt"</strong></span>
<span class="strong"><strong>cd one/</strong></span>
<span class="strong"><strong>hg ci -m"edited hello.txt"</strong></span>
<span class="strong"><strong>cd ..</strong></span>
</pre></div></li><li class="listitem">Let's push a result back to <code class="literal">repo-two</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> hg fpush</strong></span>
</pre></div><p>We will have two changed files in repo-one.</p></li><li class="listitem">Let's push one of them further to <code class="literal">repo-two</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd ../repo-two</strong></span>
<span class="strong"><strong>hg fpush</strong></span>
</pre></div></li><li class="listitem">Now, the changes from <code class="literal">repo-two/one</code> are propagated to <code class="literal">repo-one</code>.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec198"/>How it works…</h2></div></div></div><p>Mercurial is a <a id="id293" class="indexterm"/>relatively simple control system. It is vastly extendable with different plugins, which are configured through the <code class="literal">.hgrc</code> file.</p><p>The Mercurial <code class="literal">forest</code> plugin propagates changes in nested repositories to the root ones, and synchronizes the parent repository content with a nested one.</p></div></div>
<div class="section" title="Understanding OpenJDK 6 and 7 incremental builds"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Understanding OpenJDK 6 and 7 incremental builds</h1></div></div></div><p>The process of <a id="id294" class="indexterm"/>OpenJDK compilation is very time consuming. It is very boring, especially when one is developing a small part of the whole project, which needs full <a id="id295" class="indexterm"/>recompilation for testing purposes. To do it in a simple way and to compile only the necessary parts, there are incremental builds.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec199"/>Getting ready</h2></div></div></div><p>We need to download the OpenJDK (6 or 7) source code. You may need <code class="literal">libmotif</code> installed. Windows users may need to install Cygwin.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec200"/>How to do it...</h2></div></div></div><p>We will see how <a id="id296" class="indexterm"/>OpenJDK is built incrementally, avoiding adding any nasty bugs.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's build OpenJDK for the first time:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>make all</strong></span>
</pre></div></li><li class="listitem">This will <a id="id297" class="indexterm"/>take some time, so have a cup of tea.</li><li class="listitem">Then, we will build it for the second time:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>make all</strong></span>
</pre></div></li><li class="listitem">You can see from the input that nothing was actually built.</li><li class="listitem">Then, let's insignificantly change some source file (for example, <code class="literal">cardTableModRefBS.cpp</code>).</li><li class="listitem">Let's <code class="literal">make</code> OpenJDK again, but this time we will <code class="literal">grep</code> the output:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>make all | grep -i .cpp</strong></span>
</pre></div></li><li class="listitem">We see that, in the output, only two files are actually compiled, <code class="literal">hotspot/src/share/vm/memory/cardTableModRefBS.cpp</code> and <code class="literal">hotspot/src/share/vm/runtime/vm_version.cpp</code>.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec201"/>How it works…</h2></div></div></div><p>The build program checks the files that were updated and compiles only those which were updated after the last compiler run. However, if any <code class="literal">.hpp</code> files are modified, the build will be performed in clean mode, for example, no optimization will be performed.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec202"/>There's more…</h2></div></div></div><p>Weird things tend to happen while using incremental builds. The probability of such things is increased proportionally with build times.</p><p>There are, basically, two ways to perform a clean build:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One cleans all files, and compilation from scratch becomes necessary:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>make clean &amp;&amp; make all</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">The second is to specify parameters, which will force the clean mode of the build.</li></ul></div></div></div>
<div class="section" title="Debugging Java code using NetBeans"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Debugging Java code using NetBeans</h1></div></div></div><p>Obviously, when <a id="id298" class="indexterm"/>someone is writing any code, some<a id="id299" class="indexterm"/> debugging is required. It is no surprise that NetBeans, as a high-standard IDE, provides some tools to do that. This recipe will show how to debug the Java code using NetBeans.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec203"/>Getting ready</h2></div></div></div><p>You will need to install NetBeans and set up a development environment, as described previously in the chapter.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec204"/>How to do it...</h2></div></div></div><p>We will use NetBeans to debug our own OpenJDK Java code. We will need to rebuild OpenJDK with debug symbols, and configure NetBeans to make debugging possible:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's make our OpenJDK instance with debug symbols:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bash ./configure --enable-debug</strong></span>
<span class="strong"><strong>make all CONF=linux-x86_64-normal-server-fastdebug</strong></span>
</pre></div></li><li class="listitem">Let's ensure that a debuggable version is built:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./build/linux-x86_64-normal-server-fastdebug/jdk/bin/java -version</strong></span>
<span class="strong"><strong>openjdk version "1.8.0-internal-fastdebug"</strong></span>
<span class="strong"><strong>OpenJDK Runtime Environment (build 1.8.0-internal-fastdebug-dsmd_2014_03_27_05_34-b00)</strong></span>
<span class="strong"><strong>OpenJDK 64-Bit Server VM (build 25.0-b70-fastdebug, mixed mode)</strong></span>
</pre></div></li><li class="listitem">Now we have a debuggable OpenJDK. Let's set it as the default for NetBeans.</li><li class="listitem">Let's open the <code class="literal">etc/netbeans.conf</code> file in your NetBeans installation path.</li><li class="listitem">We will change one line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>netbeans_jdkhome="&lt;path_to_jdkhome&gt;"</strong></span>
</pre></div></li><li class="listitem">After that, we will launch NetBeans and ensure that our JDK is loaded correctly.</li><li class="listitem">We will select <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Java Platforms</strong></span>, and the following screen will appear:<div class="mediaobject"><img src="graphics/8405OT_08_05.jpg" alt="How to do it..."/></div></li><li class="listitem">Let's try<a id="id300" class="indexterm"/> to <a id="id301" class="indexterm"/>debug the <code class="literal">java.lang.String</code> class. We will set our breakpoints to an unavoidable part of this class—to one of the constructors, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/8405OT_08_06.jpg" alt="How to do it..."/></div></li><li class="listitem">This set of breakpoints is sufficient to hook up virtually every Java executable ever launched. But, if we decide to push things forward and attach a debugger, we will get an error message:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Not able to submit breakpoint LineBreakpoint String.java : 138, reason: No source root found for URL 'file:/home/dsmd/00experimental/java_build/jdk8intr/jdk8/jdk/src/share/classes/java/lang/String.java'. Verify the setup of project sources.</strong></span>
<span class="strong"><strong>Invalid LineBreakpoint String.java : 138</strong></span>
</pre></div></li><li class="listitem">To<a id="id302" class="indexterm"/> avoid<a id="id303" class="indexterm"/> this, we need to specify our Java sources directly to NetBeans. Our project is a C++ project, and it tends to ignore the Java files.</li><li class="listitem">The result for the <code class="literal">String</code> class will be as shown in the following screenshot:<div class="mediaobject"><img src="graphics/8405OT_08_07.jpg" alt="How to do it..."/></div></li><li class="listitem">Then, just launch some Java executable, that uses strings:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>build/linux-x86_64-normal-server-fastdebug/jdk/bin/java -Xdebug -Xrunjdwp:transport=dt_socket,address=8998,server=y -jar /path/to/jar.jar</strong></span>
</pre></div></li><li class="listitem">Attach the Java debugger, as shown:<div class="mediaobject"><img src="graphics/8405OT_08_08.jpg" alt="How to do it..."/></div></li><li class="listitem">Enjoy, you <a id="id304" class="indexterm"/>can now see OpenJDK<a id="id305" class="indexterm"/> from the inside, in motion:<div class="mediaobject"><img src="graphics/8405OT_08_09.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec205"/>How it works…</h2></div></div></div><p>It's just a debugger with a few simple nuances.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec206"/>There's more...</h2></div></div></div><p>In some<a id="id306" class="indexterm"/> Linux distributions, you can install debug versions<a id="id307" class="indexterm"/> of OpenJDK with sources provided in a ZIP file. These sources are automatically picked up by NetBeans.</p></div></div>
<div class="section" title="Debugging C++ code using NetBeans"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Debugging C++ code using NetBeans</h1></div></div></div><p>If you <a id="id308" class="indexterm"/>plan <a id="id309" class="indexterm"/>to make changes to HotSpot or any other C++ part of OpenJDK, then it is certain that you will need to do some step-by-step debugging of the code. This recipe will explain how to set up NetBeans IDE for that purpose.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec207"/>Getting ready</h2></div></div></div><p>To get started, there are only a few things required—downloaded Open JDK sources and installed NetBeans IDE. It is assumed that the OpenJDK project is already set up and can build sources.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec208"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The<a id="id310" class="indexterm"/> first step is to set up an executable that <a id="id311" class="indexterm"/>will run. Go to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Set project configuration</strong></span> / <span class="strong"><strong>Customize</strong></span> and then <span class="strong"><strong>Build</strong></span> | <span class="strong"><strong>Make</strong></span>, and set <span class="strong"><strong>build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg/gamma</strong></span> as the build result, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/8405OT_08_10.jpg" alt="How to do it..."/></div></li><li class="listitem">Then select the <span class="strong"><strong>Run</strong></span> option on the tree on the left had side and set <span class="strong"><strong>Run Command</strong></span> as <span class="strong"><strong>"${OUTPUT_PATH}" –version</strong></span>:<div class="mediaobject"><img src="graphics/8405OT_08_11.jpg" alt="How to do it..."/></div></li><li class="listitem">The <code class="literal">–version</code> flag <a id="id312" class="indexterm"/>here is just the simplest thing <a id="id313" class="indexterm"/>you can run—get the Java version. You can later change it to whatever you want, for example, to run a Java program.</li><li class="listitem">The next step is to set up some environment variables required for Java to run. This can be done by setting them up in the <span class="strong"><strong>Environment</strong></span> section as shown in the following dialog. Set <code class="literal">LD_LIBRARY_PATH</code> to <code class="literal">build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg</code> and <code class="literal">JAVA_HOME</code> to <code class="literal">build/linux-amd64-debug/j2sdk-server-image</code>.</li><li class="listitem">Now it's all ready to debug. To check that it works, set a breakpoint in <code class="literal">hotspot/src/share/tools/launcher/java.c</code> somewhere at the beginning of the <code class="literal">main</code> function and go to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Debug Main Project</strong></span> or use the shortcut <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F5</em></span>.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec209"/>How it works…</h2></div></div></div><p>Careful readers<a id="id314" class="indexterm"/> may have noticed that <span class="strong"><strong>Debug</strong></span> used <code class="literal">gamma</code> JVM launcher, instead of <code class="literal">java</code>, which is used when you<a id="id315" class="indexterm"/> run Java normally. This is to simplify things; <code class="literal">gamma</code> is the lightweight version of <code class="literal">java</code>, it doesn't perform checks which are not necessary for debugging purposes.</p></div></div>
<div class="section" title="Using NetBeans to compile HotSpot"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Using NetBeans to compile HotSpot</h1></div></div></div><p>When doing<a id="id316" class="indexterm"/> HotSpot development, it is very annoying to <a id="id317" class="indexterm"/>wait for a complete OpenJDK build to be executed. So, it makes sense to exclude other parts and compile just what we are interested in, that is, the HotSpot part. This recipe will explain how to do that.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec210"/>Getting ready</h2></div></div></div><p>The only prerequisite for this recipe is the availability of source code on the machine, and Netbeans installed, with an OpenJDK project created.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec211"/>How to do it...</h2></div></div></div><p>This is a very simple recipe to follow. If you have already completed <span class="emphasis"><em>Setting up development environment with NetBeans</em></span>, the only thing which is required to be done is to change the argument <code class="literal">hotspot_build</code> and add another argument <code class="literal">DEBUG_NAME=debug</code>, the whole build command line should look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>build.sh hotspot-build DEBUG_NAME=debug</strong></span>
</pre></div><p>The <span class="strong"><strong>Build/Make</strong></span> screen of the <span class="strong"><strong>Project Properties</strong></span> dialog in that case will look like this:</p><div class="mediaobject"><img src="graphics/8405OT_08_12.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec212"/>How it works…</h2></div></div></div><p>Luckily, there <a id="id318" class="indexterm"/>are targets created in the <code class="literal">make</code> configuration which only built the HotSpot bit. These targets can be located in the <code class="literal">./make/hotspot-rules.gmk</code> file.</p><p>The <a id="id319" class="indexterm"/>
<code class="literal">debug</code> command <a id="id320" class="indexterm"/>which creates the non-optimized version or the HotSpot, is not the only option for the <code class="literal">DEBUG_NAME</code> variable. The <code class="literal">fastdebug</code> command<a id="id321" class="indexterm"/> is the other option in which build will create an optimized version with assertions. When <code class="literal">DEBUG_NAME</code> is not set, the product version of HotSpot is built.</p></div></div>
<div class="section" title="Using HotSpot dev parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Using HotSpot dev parameters</h1></div></div></div><p>HotSpot has <a id="id322" class="indexterm"/>other options, which may significantly<a id="id323" class="indexterm"/> change its behavior. Here we will make use of some of these options, which are used only on the dev versions of OpenJDK.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec213"/>Getting ready</h2></div></div></div><p>We will need to compile a dev OpenJDK version, in order to use the dev options.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec214"/>How to do it...</h2></div></div></div><p>We will use <a id="id324" class="indexterm"/>parameters that are available in the <a id="id325" class="indexterm"/>developer version of OpenJDK. In the production builds, they are disabled or set as constant values.</p><p>To make use of these parameters, we will run Java as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java - -XX:&lt;optionName&gt;</strong></span>
</pre></div><p>Here is a list of some usable dev options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">InlineUnsafeOps</code>: This <a id="id326" class="indexterm"/>option will, if enabled, inline native memory operations from <code class="literal">sun.misc.Unsafe</code>. It may offer some performance improvements in some cases.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DieOnSafepointTimeout</code>: This <a id="id327" class="indexterm"/>option will kill the process if the safepoint is not reached, but the timeout is exceeded. It is disabled by default.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ZapResourceArea</code>: This<a id="id328" class="indexterm"/> option will zap freed resource / arena space with <code class="literal">0xABABABAB</code>. It is true in debug mode, but is deselected in production VMs. It may be used for really paranoid security reasons, though it has some performance impact.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ZapJNIHandleArea</code>: This <a id="id329" class="indexterm"/>option will zap freed JNI handle space with <code class="literal">0xFEFEFEFE</code>. It only has a debug value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ZapUnusedHeapArea</code>: This<a id="id330" class="indexterm"/> option will zap unused heap space with <code class="literal">0xBAADBABE</code>. It may be used for security reasons.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Verbose</code>: This<a id="id331" class="indexterm"/> option prints additional debugging information from other modes. It is the main logging option of the dev HotSpot.</li><li class="listitem" style="list-style-type: disc"><code class="literal">UsePrivilegedStack</code>: This<a id="id332" class="indexterm"/> option enables the security JVM functions. It is <code class="literal">true</code> by default, but in dev mode, you still have the opportunity to run HotSpot with disabled security.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MemProfiling</code>: This<a id="id333" class="indexterm"/> option writes memory usage profiling to logfile. It is <code class="literal">false</code> by default, and can be run for some memory profiling issues.</li><li class="listitem" style="list-style-type: disc"><code class="literal">VerifyParallelOldWithMarkSweep</code>: This<a id="id334" class="indexterm"/> option will use the <code class="literal">MarkSweep</code> GC code to verify phases of the parallel old. It may be used for debugging purposes when changing the JVM memory handling mechanism.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ScavengeWithObjectsInToSpace</code>: This <a id="id335" class="indexterm"/>option is really interesting. Java uses two-space GC, where survivor space is concerned, and this options allows scavenges to occur when <code class="literal">to_space</code> contains objects. Also, when doing so, it clears an unused area, if <code class="literal">ZapUnusedHeapArea</code> is enabled.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FullGCALot</code>: This <a id="id336" class="indexterm"/>option forces full GC at every <span class="emphasis"><em>Nth</em></span> exit from the runtime system (<code class="literal">N=FullGCALotInterval</code>). It may be a very expensive operation, but some developers may build it into JDKs for desktop use. It may be cheaper than to use swap space to absorb endless megabytes from the overgrown heap.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AdaptiveSizePolicyReadyThreshold</code>: This<a id="id337" class="indexterm"/> option is the number of collections before adaptive sizing is started. The default is <code class="literal">5</code>, but it may make sense to make it <code class="literal">1</code> on desktop systems since the biggest bottleneck of those is the swap space, especially if several Java programs are running simultaneously on one machine.</li><li class="listitem" style="list-style-type: disc"><code class="literal">EagerInitialization</code>: This <a id="id338" class="indexterm"/>option eagerly initializes classes if possible. It is <code class="literal">false</code> by default, so maybe it is unsafe to turn it on. But the idea seems good, especially on server machines.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GuaranteedSafepointInterval</code>: This<a id="id339" class="indexterm"/> option guarantees a safepoint (at least) every few milliseconds (<code class="literal">0</code> means none). The default is <code class="literal">1000</code>. It may be used to tweak the stop-the-world state problem. The bigger the option value, the longer these stops will be; and if we make the value too small, we will have too many unnecessary stops.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MaxTrivialSize</code>: This<a id="id340" class="indexterm"/> option is the maximum bytecode size of a trivial method to be inline. It is <code class="literal">6</code> by default. It is similar to the C++ compiler inline options, but for the bytecode compiler.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MinInliningThreshold</code>: This <a id="id341" class="indexterm"/>option is the minimal invocation count a method needs to have to be inline. It is <code class="literal">250</code> by default.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SharedOptimizeColdStartPolicy</code>: This<a id="id342" class="indexterm"/> option is the reordering policy for <code class="literal">SharedOptimizeColdStart</code>. The <code class="literal">0</code> value favors the classload-time locality, <code class="literal">1</code> uses a balanced policy, and <code class="literal">2</code> favors runtime locality.</li></ul></div><p>The default is <code class="literal">2</code> and it is rarely necessary to change it, but in some cases it will make sense to make it <code class="literal">1</code> if your application has too many classes that may load after the application starts.</p></div></div>
<div class="section" title="Adding new intrinsic to HotSpot"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Adding new intrinsic to HotSpot</h1></div></div></div><p>Intrinsic<a id="id343" class="indexterm"/> is <a id="id344" class="indexterm"/>a function whose implementation is handled specially by a compiler. Typically, it means that the function call is replaced <a id="id345" class="indexterm"/>by automatically generated instructions. This is very similar to the inline functions, but the compiler knows more about intrinsics as they are part of the compiler itself, so it can use them more wisely.</p><p>Intrinsics are usually more performance-oriented than native functions because there is no JNI overhead.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec215"/>Getting ready</h2></div></div></div><p>To get started, all <a id="id346" class="indexterm"/>we need is an installed NetBeans IDE for code editing and OpenJDK sources. The user should be able to read C++ code and a little knowledge of assembly would be beneficial.</p><p>It would be worth checking that SSE4.2 (an extended instruction set with six new commands, mostly for character searching and comparison) is supported by the CPU (the <code class="literal">CRC32</code> command used in our example is from that command set). It was introduced with Core i7 Intel chips back in 2009, so if you are using an Intel CPU, it should be present. The first time it was introduced for AMD was as Bulldozer chips back in 2011, so you should have relatively recent chips to support it. If your CPU is not compatible with that command, do not worry. The recipe is applicable to any intrinsics you may want to introduce; there is no difference, apart from the actual implementation of the code you want to intrinsify.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec216"/>How to do it...</h2></div></div></div><p>Adding new intrinsics is <a id="id347" class="indexterm"/>not a simple process. Follow these instructions carefully. Ensure you compile the code after every step; doing so may save some time.</p><p>The instruction which we are going to intrinsify is the CRC32 calculation, which is implemented by <code class="literal">java.util.zip.CRC32</code>.</p><p>To start, let's make a small amendment to the Java class that is responsible for the CRC32 calculation. We are going to add a method which will be intrinsified by HotSpot. Open the <code class="literal">jdk/src/share/classes/java/util/zip/CRC32.java</code> file and add a new method <code class="literal">doUpdateBytes</code>:</p><div class="informalexample"><pre class="programlisting">private static int doUpdateBytes(int crc, byte[] b, int off, int len) {
    return updateBytes(crc, b, off, len);
}</pre></div><p>That implementation just makes a call to the currently used <code class="literal">updateBytes</code> native method. That's the only change in Java. The rest is going to be the C++ internals of the HotSpot.</p><p>Open the <code class="literal">hotspot/src/share/vm/precompiled/precompiled.hpp</code> file and add the following line into it:</p><div class="informalexample"><pre class="programlisting">#include "smmintrin.h"</pre></div><p>The <code class="literal">smmintrin.h</code> file contains GCC intrinsics, which are going to be used by our implementation of the CRC32 function.</p><p>Then, as we are using SSE4.2 instructions, we need to inform the compiler. To do so, open the <code class="literal">hotspot/make/linux/makefiles/gcc.make</code> file (assuming you are making the build on Linux), and <a id="id348" class="indexterm"/>locate the line consisting of <code class="literal">CFLAGS += -fno-rtti</code>. Just after that line, add the <code class="literal">-msse4.2</code> flag, so it will look like this:</p><div class="informalexample"><pre class="programlisting">CFLAGS += -fno-rtti # locate that line
CFLAGS += -msse4.2  # add this new line here</pre></div><p>Now we are<a id="id349" class="indexterm"/> ready to implement our CRC32 function in C++. In the <code class="literal">hotspot/src/cpu/x86/vm/</code> folder, create the <code class="literal">CRC32Calc</code> class and the <code class="literal">static_calcCrc32</code> static method. Here is the <code class="literal">CRC32Calc.hpp</code> file with the class declaration:</p><div class="informalexample"><pre class="programlisting">#ifndef CRC32CALC_HPP
#define  CRC32CALC_HPP

class CRC32Calc {
public:
    CRC32Calc() {};
    virtual ~CRC32Calc() {};
    
    static int static_calcCrc32(int crc, const char* data, int dataOffset, int dataLen);
};
#endif  /* CRC32CALC_HPP */</pre></div><p>The <code class="literal">CRC32Calc.cpp</code> file with its implementation is as shown:</p><div class="informalexample"><pre class="programlisting">#include "CRC32Calc.hpp"
#include "precompiled.hpp"
int CRC32Calc::static_calcCrc32(int crc, const char* data, int dataOffset, int dataLen) {
    const int dataSize = dataLen - dataOffset;
    int result = crc;
    int uints32 = (int)(dataSize / sizeof(int));
    int units8 = dataSize % sizeof(int);

    const int* pUint32 = (const int*)data;
    while (uints32--) {
        result = ::_mm_crc32_u32(result, *pUint32);
        pUint32++;
    }

    const char* pUnit8 = (const char*)pUint32;
    while (units8--) {
        result = ::_mm_crc32_u8(result, *pUnit8);
        pUnit8++;
    }

    return result;
}</pre></div><p>The following instructs<a id="id350" class="indexterm"/> HotSpot how to intrinsify our method.</p><p>Locate <code class="literal">hotspot/src/share/vm/classfile/vmSymbols.hpp</code>. That is the file which contains the declaration of all intrinsics and add the following definition to it:</p><div class="informalexample"><pre class="programlisting">do_class(java_util_zip_crc32,      "java/util/zip/CRC32")                                                        \
do_intrinsic(_crc32_doUpdateBytes, java_util_zip_crc32, doUpdateBytes_name, int_byteArray_int_int_signature, F_R)  \
do_name(     doUpdateBytes_name,                                 "doUpdateBytes")                                  \
do_signature(int_byteArray_int_int_signature,             "(I[BII)I")                                              \</pre></div><p>This is the <a id="id351" class="indexterm"/>declaration of intrinsics which maps the Java method with the code which will replace it in the runtime. Be careful when adding it. It is based on macros, which means, if there is a typo or any other mistake, it will be very hard to figure out where the problem is.</p><p>The next step is to define which code we are going to generate for the intrinsic. We are not going to be very smart here, as this is just an exercise to see how the functionality works. So all our assembler is going to do is generate a call to the C function. Add the following into <code class="literal">hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp</code> and <code class="literal">hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp</code>:</p><div class="informalexample"><pre class="programlisting">#include "CRC32Calc.hpp"</pre></div><p>Now it's a bit tricky and requires some low-level code. We are going to tell HotSpot how to generate the assembly for our method. To do so, add the <code class="literal">generator</code> method into the <code class="literal">StubGenerator</code> class which is declared in both <code class="literal">hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp</code> and <code class="literal">hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp</code> for x86_64 and x86 architectures respectively. The code for the method is as follows:</p><div class="informalexample"><pre class="programlisting">  // Arguments:
  //
  // Inputs:
  //   c_rarg0   - input crc
  //   c_rarg1   - byte array with data for calculation
  //   c_rarg2   - offset in the input array
  //   c_rarg3   - number of data bytes after offset
  //
  // Output:
  //    eax - result crc
  address generate_crc32_doUpdateBytes() {
    __ align(CodeEntryAlignment);
    StubCodeMark mark(this, "StubRoutines", "crc32_doUpdateBytes");
    address start = __ pc();

    __ enter(); // required for proper stackwalking of RuntimeStub frame
    __ pusha();
    // no need to put params in regr - they are already there
    // after this call rax should already have required return value
    __ call_VM_leaf(CAST_FROM_FN_PTR(address, CRC32Calc::static_calcCrc32), 4);
    __ popa();
    
    __ leave(); // required for proper stackwalking of RuntimeStub frame
    return start;
  }</pre></div><p>Now we <a id="id352" class="indexterm"/>need a <a id="id353" class="indexterm"/>variable which will contain the address of the generated method. To do so, add the following static member declaration to <code class="literal">hotspot/src/share/vm/runtime/stubRoutines.hpp</code>:</p><div class="informalexample"><pre class="programlisting">static address _crc32_doUpdateBytes;</pre></div><p>To the same file, add the following method, which just returns the value of the declared variable:</p><div class="informalexample"><pre class="programlisting">static address crc32_doUpdateBytes() { return _crc32_doUpdateBytes; }</pre></div><p>Then, in <code class="literal">hotspot/src/share/vm/runtime/stubRoutines.cpp</code>, assign a default value to <code class="literal">_crc32_doUpdateBytes</code>:</p><div class="informalexample"><pre class="programlisting">address StubRoutines::_crc32_doUpdateBytes = NULL;</pre></div><p>Then, in both <code class="literal">hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp</code> and <code class="literal">hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp</code>, locate the <code class="literal">generate_all</code> method and assign the following value to the variable <code class="literal">_crc32_doUpdateBytes</code>:</p><div class="informalexample"><pre class="programlisting">StubRoutines::_crc32_doUpdateBytes = generate_crc32_doUpdateBytes();</pre></div><p>The next step is to add the method which creates a descriptor. The descriptor is the definition of our function—how many arguments it takes, which types of arguments it accepts, and so on. The first step is to add the method declaration into the <code class="literal">OptoRuntime</code> class in the <code class="literal">hotspot/src/share/vm/opto/runtime.hpp</code> file:</p><div class="informalexample"><pre class="programlisting">static const TypeFunc* crc32_Type();</pre></div><p>This will be <a id="id354" class="indexterm"/>the <a id="id355" class="indexterm"/>function which creates the type information for our method call—it describes the arguments and returns the parameters. After implementation it creates an array of types of input parameters and the type of the return value. Place it in the <code class="literal">hotspot/src/share/vm/opto/runtime.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">const TypeFunc* OptoRuntime::crc32_Type() {
  // create input type (domain): int, pointer, int, int
  int num_args      = 4;
  int argcnt = num_args;
  const Type** fields = TypeTuple::fields(argcnt);
  int argp = TypeFunc::Parms;
  fields[argp++] = TypeInt::INT;      // crc
  fields[argp++] = TypePtr::NOTNULL;  // data
  fields[argp++] = TypeInt::INT;      // offset
  fields[argp++] = TypeInt::INT;      // len
  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
  
  // create return value
  fields = TypeTuple::fields(1);
  fields[TypeFunc::Parms+0] = TypeInt::INT;
  
  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);

  return TypeFunc::make(domain, range);
}</pre></div><p>Now we will implement the method that will inline the code in the runtime. In the <code class="literal">hotspot/src/share/vm/opto/library_call.cpp</code> file, locate the definition of the <code class="literal">LibraryCallKit</code> class, and add the following method declaration:</p><div class="informalexample"><pre class="programlisting">bool inline_crc32();</pre></div><p>Also, in the same file, add the implementation:</p><div class="informalexample"><pre class="programlisting">bool LibraryCallKit::inline_crc32() {
  address stubAddr = StubRoutines::crc32_doUpdateBytes();
  const char *stubName = "crc32_doUpdateBytes";
  Node* inputCrc = argument(0);
  Node* in_data  = argument(1);
  Node* offset   = argument(2);
  Node* len      = argument(3);

  // Call the stub.
  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::crc32_Type(),
                    stubAddr, stubName, TypePtr::BOTTOM,
                    inputCrc, in_data, offset, len);
  
  return true;
}</pre></div><p>Finally<a id="id356" class="indexterm"/> tell HotSpot that we indeed want to intrinsify our method call and make a call to the inlining method <code class="literal">inline_crc32</code>.</p><p>To tell <a id="id357" class="indexterm"/>HotSpot that we want to intrinsify the method, <code class="literal">Compile::make_vm_intrinsic</code> method in the file <code class="literal">hotspot/src/share/vm/opto/library_call.cpp</code> has to return a non-null pointer to <code class="literal">CallGenerator</code>. To do so, add the following line into the <code class="literal">switch(id)</code> switch statement in that method:</p><div class="informalexample"><pre class="programlisting">  case vmIntrinsics::_crc32_doUpdateBytes:
    break;</pre></div><p>It is not strictly required to have that case and break, the default works just well; but it makes it more explicit that we are using intrinsics for the CRC32 calculation method.</p><p>Then, to make a call to the inlining method, in the same <code class="literal">hotspot/src/share/vm/opto/library_call.cpp</code> file, locate <code class="literal">LibraryCallKit::try_to_inline</code>, find <code class="literal">switch (intrinsic_id())</code>, and add the following line of code:</p><div class="informalexample"><pre class="programlisting">case vmIntrinsics:: _crc32_doUpdateBytes: return inline_crc32();
new line.</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec217"/>How it works…</h2></div></div></div><p>To check whether the method was intrinsified, use the <code class="literal">-XX:+PrintCompilation</code> and <code class="literal">-XX:+PrintInlining</code> Java arguments. To see what the intrinsics are compiled into, use <code class="literal">-XX:+PrintAssembly</code> (this should be prepended by <code class="literal">-XX:+UnlockDiagnosticsVMOptions</code> when running on the product build).</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec218"/>There's more…</h2></div></div></div><p>To see if SSE4.2 is supported, just compile and run the following code:</p><div class="informalexample"><pre class="programlisting">// This is Linux version
#include &lt;cpuid.h&gt;T
#include &lt;stdio.h&gt;
void main () {
    unsigned int eax, ebx, ecx, edx;
    __get_cpuid(1, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);
    if (ecx &amp; bit_SSE4_2)
        printf ("SSE4.2 is supported\n");
    return;
}

// And this is the version for windows
#include &lt;intrin.h&gt;
int _tmain(int argc, _TCHAR* argv[])
{
  int cpuInfo[4] = { -1 };
  __cpuid(cpuInfo, 1);
  bool bSSE42Extensions = (cpuInfo[2] &amp; 0x100000) || false;
  if (bSSE42Extensions) {
    printf("SSE4.2 is supported\n");
  }
  return 0;
}</pre></div><p>There are lots of intrinsic methods. See <code class="literal">library_call.cpp</code> and <code class="literal">vmSymbols.hpp</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Object.getClass</code> gives one or two instructions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Class.isInstance</code> and <code class="literal">Class.isAssignableFrom</code> are as cheap as instances of bytecodes when the operands are constants, and otherwise no more expensive than aastore type checks.</li><li class="listitem" style="list-style-type: disc">Most single-bit class queries are cheap and even constant-foldable.</li><li class="listitem" style="list-style-type: disc">Reflective array creation is about as cheap as the <code class="literal">newarray</code> or <code class="literal">anewarray</code> instructions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Object.clone</code> is cheap and shares code with <code class="literal">Arrays.copyOf</code> (after Java6).</li></ul></div><p>Java is not the only language which uses intrinsics they are also widely used in C++ for SSE operations.</p><p>Interestingly, <code class="literal">_mm_crc32_u32</code> and <code class="literal">_mm_crc32_u8</code> are intrinsics themselves, known by the GCC or MS compiler, which are directly replaced by assembly instructions in the compiled code.</p></div></div>
<div class="section" title="Building VisualVM from the source code"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>Building VisualVM from the source code</h1></div></div></div><p>VisualVM is an <a id="id358" class="indexterm"/>open source project which is not a part of OpenJDK. It is a powerful tool which is helpful to anyone who uses applications based on JDK. It allows us to monitor parameters of the system, browse heap dumps, create thread dumps, and so on. As the tool is open source, it is possible to get the source code and customize it as required, or simply just to see how it works. This recipe will go through the steps which are required to download the source code and build VisualVM from it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec219"/>Getting ready</h2></div></div></div><p>This recipe requires a machine with Subversion and Ant installed. Also, as VisualVM is a graphical application, a graphical environment is required to run it. It is possible to perform a build without launching the application.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec220"/>How to do it...</h2></div></div></div><p>The first step is to get the source code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a folder for the sources, for example, <code class="literal">/home/user/visualvm</code>.</li><li class="listitem">Go to the newly created folder and, assuming you need sources from the <code class="literal">trunk</code>, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>svn checkout https://svn.java.net/svn/visualvm~svn/trunk</strong></span>
</pre></div></li><li class="listitem">This will create the <code class="literal">trunk</code> folder with sources in the current directory.</li></ol></div><p>To start, we need to download the NetBeans Platform binaries. The version needed depends on the version of VisualVM <a id="id359" class="indexterm"/>we are going to build. In this example, we will use <code class="literal">trunk</code>, the current development version which requires NetBeans Platform v.8; but as that may change, it is recommended to consult the page for the appropriate version <a id="id360" class="indexterm"/>using the link <a class="ulink" href="http://visualvm.java.net/build.html">http://visualvm.java.net/build.html</a>. These binaries are available directly from the VisualVM website, not from the NetBeans website. For this example, the URL is <a class="ulink" href="https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip">https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip</a>. When the file is downloaded, unpack it into the <code class="literal">trunk/visualvm</code> folder, as shown:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Now, execute Ant to run the build.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ant build-zip</strong></span>
</pre></div></li><li class="listitem">When the build is complete, we should see something similar to the following output in the command prompt:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong>Total time: 34 seconds</strong></span>
</pre></div><p>This indicates that the build was successful. This step is not required if we just need to run VisualVM, as Ant will also run the build target; but if there is no need to run, and just build is required, this step can be useful.</p></li><li class="listitem">To run VisualVM, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ant run</strong></span>
</pre></div></li><li class="listitem">If the application is not built yet, then Ant will build it first and then run it. As VisualVM is a GUI application, we will see the following screen:<div class="mediaobject"><img src="graphics/8405OT_08_13.jpg" alt="How to do it..."/></div></li></ol></div><p>This is the landing <a id="id361" class="indexterm"/>screen of VisualVM. The fact that we can see it means that the application is built and works properly. The zipped archive file with the distribution can be found in the <code class="literal">visualvm/dist</code> folder.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec221"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More information about VisualVM build is available <a id="id362" class="indexterm"/>on the home page <a class="ulink" href="http://visualvm.java.net/build.html">http://visualvm.java.net/build.html</a>. Each version has a different page, as build instructions vary from version to version. For example, each build may require a slightly different version of the Netbeans platform.</li></ul></div></div></div>
<div class="section" title="Creating a plugin for VisualVM"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec66"/>Creating a plugin for VisualVM</h1></div></div></div><p>VisualVM is <a id="id363" class="indexterm"/>just an application which has a predefined and<a id="id364" class="indexterm"/> limited set of features. It is a framework, which means that it is possible to extend it. The way in which VisualVM provides for extension is via the plugin API which allows us to create new plugins which are then available through the application. Such plugins can do various things, but are mostly used to provide new ways of monitoring or controlling the JVM applications.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec222"/>Getting ready</h2></div></div></div><p>The current (at the time of writing) trunk version of VisualVM requires the NetBeans platform and IDE v.8. So we need to ensure that the current version of the platform is available on the machine. If there is any doubt, check the page with VisualVM trunk build instructions at <a class="ulink" href="http://visualvm.java.net/build/build.html">http://visualvm.java.net/build/build.html</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec223"/>How to do it...</h2></div></div></div><p>Let's start with what we <a id="id365" class="indexterm"/>are going to monitor. It seems like the simplest<a id="id366" class="indexterm"/> thing we can do is to build a component which will tick the data that we can read. For example, look at the following class:</p><div class="informalexample"><pre class="programlisting">package org.openjdk.cookbook;

import javax.management.MBeanServer;
import javax.management.ObjectName;
import java.lang.management.ManagementFactory;

public class SleepProbe implements SleepProbeMBean {
    private volatile long lastSleepSampleMs = 100;

    public static void main(String[] args) throws Exception {
        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
        ObjectName name = new ObjectName("org.openjdk.cookbook:type=SleepProbe");
        SleepProbe mbean = new SleepProbe();
        mbean.start();
        mbs.registerMBean(mbean, name);
        System.out.println("Started MBean");
        Thread.sleep(Long.MAX_VALUE);
    }

    @Override
    public long getActualSleepTime() {
        return lastSleepSample;
    }

    public void start() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while ( !Thread.currentThread().isInterrupted() ) {
                    try {
                        final long start = System.nanoTime();
                        Thread.sleep(100);
                        final long end = System.nanoTime();
                        lastSleepSampleMs = (long)((double)(end-start))/1000000;
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }).start();
    }
}</pre></div><p>This code <a id="id367" class="indexterm"/>sleeps <a id="id368" class="indexterm"/>for 100 ms and measures how long it actually slept. The value is not going to be exact, but will be about <code class="literal">100</code>. It publishes the last measurement of the sleep time via the <code class="literal">lastSleepSample</code> variable which is available via the <code class="literal">SleepProbeMBean</code> interface:</p><div class="informalexample"><pre class="programlisting">package org.openjdk.cookbook;
public interface SleepProbeMBean {
    public long getActualSleepTime();
}</pre></div><p>This class and interface should be put into a separate project, so you can run them independently of the VirtualVM plugin project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To start, we need to create a plugin project in IDE. Launch the IDE, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Project</strong></span> and select <span class="strong"><strong>NetBeans Platform Application</strong></span> from the project type:<div class="mediaobject"><img src="graphics/8405OT_08_14.jpg" alt="How to do it..."/></div></li><li class="listitem">On the <a id="id369" class="indexterm"/>next <a id="id370" class="indexterm"/>screen, select <span class="strong"><strong>VisualVM</strong></span> as the <span class="strong"><strong>NetBeans Platform</strong></span> (if it is not available, see further instructions), the project name, and the location, as shown:<div class="mediaobject"><img src="graphics/8405OT_08_15.jpg" alt="How to do it..."/></div></li><li class="listitem">If <span class="strong"><strong>VisualVM</strong></span> is <a id="id371" class="indexterm"/>not available in the list of platforms, then<a id="id372" class="indexterm"/> click on the Manage icon and, in the displayed dialog, add a new platform by pointing it to the folder with the VisualVM distribution, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/8405OT_08_16.jpg" alt="How to do it..."/></div></li><li class="listitem">In this <a id="id373" class="indexterm"/>example, the distribution was built from<a id="id374" class="indexterm"/> source (see the <span class="emphasis"><em>Building VisualVM from the source code</em></span> recipe). Press <span class="strong"><strong>Next</strong></span> and then <span class="strong"><strong>Finish</strong></span>.</li><li class="listitem">Now just complete the wizard and you will have a new empty project with some properties and build script.</li><li class="listitem">Note that there is a known bug in some versions of NetBeans (<a class="ulink" href="https://netbeans.org/bugzilla/show_bug.cgi?id=242564">https://netbeans.org/bugzilla/show_bug.cgi?id=242564</a>), which is causing problem with dependencies and which will not allow us to add the required dependencies later. To work around this, right click on the project and then click on <span class="strong"><strong>Properties</strong></span>. On the <span class="strong"><strong>Project Properties</strong></span> dialog, select <span class="strong"><strong>Libraries</strong></span>:<div class="mediaobject"><img src="graphics/8405OT_08_17.jpg" alt="How to do it..."/></div></li><li class="listitem">Uncheck <a id="id375" class="indexterm"/><span class="strong"><strong>JavaFX wrapper</strong></span> under the platform component. Ensure<a id="id376" class="indexterm"/> that all the other checkboxes are checked, including <span class="strong"><strong>profiles</strong></span> and <span class="strong"><strong>visualvm</strong></span> nodes.</li><li class="listitem">Now we need to create a module for our plugin. Right click on the <span class="strong"><strong>Modules</strong></span> item in the project tree and select <span class="strong"><strong>Add New…</strong></span>:<div class="mediaobject"><img src="graphics/8405OT_08_18.jpg" alt="How to do it..."/></div></li><li class="listitem">Name it as <code class="literal">SamplingModule</code> and <a id="id377" class="indexterm"/>press <span class="strong"><strong>Next</strong></span>. On the next screen, put <code class="literal">net.cookbook.openjdk</code> as <code class="literal">Code Name Base</code> and press on <span class="strong"><strong>Finish</strong></span>. This will create an empty module where we will need to add some components.</li><li class="listitem">The next step is to <a id="id378" class="indexterm"/>add the dependencies to the module. Right click on the module and select <span class="strong"><strong>Properties</strong></span>, then go to <span class="strong"><strong>Libraries</strong></span> | <span class="strong"><strong>Module Dependencies</strong></span>, and click on <span class="strong"><strong>Add Dependency</strong></span>. On the <span class="strong"><strong>Add Module Dependency</strong></span> dialog, put <code class="literal">VisualVM</code> into the <span class="strong"><strong>Filter</strong></span> field as shown:<div class="mediaobject"><img src="graphics/8405OT_08_19.jpg" alt="How to do it..."/></div></li><li class="listitem">Select <a id="id379" class="indexterm"/><span class="strong"><strong>VisualVM-Application</strong></span>, <span class="strong"><strong>VisualVM-Core</strong></span>, and <span class="strong"><strong>VisualVM-Tools</strong></span> (not visible on the screenshot), then click on <span class="strong"><strong>OK</strong></span>.</li><li class="listitem">The next step<a id="id380" class="indexterm"/> is to add the installer and some source code. To do so, right click on the newly created module and go to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Other</strong></span>. This will show the dialog with the option to select the file type. Click on <span class="strong"><strong>Installer/Activator</strong></span> and click on <span class="strong"><strong>Next</strong></span>, as shown:<div class="mediaobject"><img src="graphics/8405OT_08_20.jpg" alt="How to do it..."/></div></li><li class="listitem">Then<a id="id381" class="indexterm"/> just<a id="id382" class="indexterm"/> complete the wizard by clicking on <span class="strong"><strong>Finish</strong></span>. This will create a class with the name <code class="literal">Installer</code> in the package <code class="literal">net.cookbook.openjdk</code>. For now, leave that class as it is, we will update it later in the recipe.</li><li class="listitem">The next step is to create a component which will draw a graph for us. To do so, we will create a simple panel which will refresh itself every half a second with a new sample from the sampler <code class="literal">MBean</code>. In the <code class="literal">net.cookbook.openjdk</code> package, create a new class and name it as <code class="literal">SamplingGraphPanel</code>:<div class="informalexample"><pre class="programlisting">package net.cookbook.openjdk;

import com.sun.tools.visualvm.application.Application;
import com.sun.tools.visualvm.tools.jmx.*;
import java.awt.*;
import java.util.LinkedList;
import javax.management.*;
import javax.swing.JPanel;
import org.openide.util.Exceptions;

public class SamplingGraphPanel extends JPanel implements Runnable {
    private static final int MAX_DATA_POINTS = 20;
    private static final int MAX_VALUE = 110;
    private static final int GAP = 30;

    private final LinkedList&lt;Long&gt; samples = new LinkedList&lt;Long&gt;();
    private final Application application;
    private Thread refreshThread;

    public SamplingGraphPanel(Application application) {
        this.application = application;
        this.setBackground(Color.black);
    }

    @Override
    public void paintComponent(Graphics gr) {
        super.paintComponent(gr);

        Graphics2D g2 = (Graphics2D)gr;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        final double xScale = ((double) getWidth()-2*GAP)/(samples.size()-1);
        final double yScale = ((double) getHeight()-2*GAP)/(MAX_VALUE-1);

        Stroke oldStroke = g2.getStroke();
        g2.setColor(Color.green);
        g2.setStroke(new BasicStroke(3f));
        for (int i = 0; i &lt; samples.size()-1; ++i) {
            final int x1 = (int) (i * xScale + GAP);
            final int y1 = (int) ((MAX_VALUE-samples.get(i))*yScale+GAP);
            final int x2 = (int) ((i+1) * xScale + GAP);
            final int y2 = (int) ((MAX_VALUE - samples.get(i+1)) * yScale + GAP);
            g2.drawLine(x1, y1, x2, y2);         
        }
    }

public void start() {
       refreshThread = new Thread(this);
       refreshThread.start();
    }

    public void stop() {
        if ( refreshThread != null ) {
            refreshThread.interrupt();
            refreshThread = null;
        }
    }

    @Override
    public void run() {
        JmxModel jmx = JmxModelFactory.getJmxModelFor(application);
        MBeanServerConnection mbsc = null;
        if (jmx != null &amp;&amp; jmx.getConnectionState() == JmxModel.ConnectionState.CONNECTED) {
            mbsc = jmx.getMBeanServerConnection();
        }

        try {
            while ( mbsc != null &amp;&amp; !Thread.currentThread().isInterrupted() ) {
                if ( samples.size() == MAX_DATA_POINTS ) {
                    samples.remove();
                }
                Long val = (Long)mbsc.getAttribute(new ObjectName("org.openjdk.cookbook:type=SleepProbe"), "ActualSleepTime");
                samples.add(val);
                repaint();
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) { break; }
            }
        } catch (Exception e) {
            Exceptions.printStackTrace(e);
        }
    }
}</pre></div></li><li class="listitem">This class will read a value from the <code class="literal">MBean</code> implements on the first step of this receipt every 500ms, and add the value to the list with samples. Then it refreshes the <a id="id383" class="indexterm"/>graph, which gets repainted. Fundamentally, that<a id="id384" class="indexterm"/> code is just a Java Swing code, which can be run in any application. The only VisualVM-specific bit here is some helper classes used to get <code class="literal">MBean</code> from the <code class="literal">Application</code> object.</li><li class="listitem">Now, in <code class="literal">SamplingModule</code>, create a class which will be responsible for showing the data. Name it <code class="literal">SamplingView</code> and put it into the <code class="literal">net.cookbook.openjdk</code> package, as shown below:<div class="informalexample"><pre class="programlisting">package net.cookbook.openjdk;

import com.sun.tools.visualvm.application.Application;
import com.sun.tools.visualvm.core.ui.DataSourceView;
import com.sun.tools.visualvm.core.ui.components.DataViewComponent;
import javax.swing.*;
import org.openide.util.Utilities;

public class SamplingView extends DataSourceView {
    private DataViewComponent dvc;
    private SamplingGraphPanel panel;
    public static final String IMAGE_PATH = "net/cookbook/openjdk/icon.png";

    public SamplingView(Application application) {
        super(application,"Sampling Application", new ImageIcon(Utilities.loadImage(IMAGE_PATH, true)).getImage(), 60, false);
    }

    protected DataViewComponent createComponent() {
        //Data area for master view:
        JEditorPane generalDataArea = new JEditorPane();
        generalDataArea.setBorder(BorderFactory.createEmptyBorder(14, 8, 14, 8));

        panel = new SamplingGraphPanel(SamplingProvider.getSleepProbeInstance((Application)getDataSource()));        DataViewComponent.MasterView masterView = new DataViewComponent.MasterView("Sampling Overview", null, generalDataArea);
        DataViewComponent.MasterViewConfiguration masterConfiguration = new DataViewComponent.MasterViewConfiguration(false);
        dvc = new DataViewComponent(masterView, masterConfiguration);
        //Add detail views to the component:
        dvc.addDetailsView(new DataViewComponent.DetailsView("Sampling Graph", null, 10, panel, null), DataViewComponent.TOP_LEFT);

        return dvc;
    }

    @Override
    protected void removed() {
        super.removed();
        panel.stop();
    }
}</pre></div></li><li class="listitem">It is important <a id="id385" class="indexterm"/>that the file referenced by <code class="literal">IMAGE_PATH</code> actually exists, otherwise the plugin will not start and will fail with an exception. The simplest way you can do this is to download any of available free icons from the Internet, for example at <a class="ulink" href="https://www.iconfinder.com/icons/131715/download/png/32">https://www.iconfinder.com/icons/131715/download/png/32</a> and put it into the same package folder as the <code class="literal">SamplingView</code> class.</li><li class="listitem">The next step <a id="id386" class="indexterm"/>is to create a provider which will create the view instance and identify that the application we are connected to is supported by the plugin. In the <code class="literal">net.cookbook.openjdk</code> package, create a class with the name <code class="literal">SamplingProvider</code> and with the following implementation:<div class="informalexample"><pre class="programlisting">package net.cookbook.openjdk;

import com.sun.tools.visualvm.application.Application;
import com.sun.tools.visualvm.core.ui.*;
import com.sun.tools.visualvm.tools.jmx.*;
import javax.management.*;
import org.openide.util.Exceptions;

public class SamplingProvider extends DataSourceViewProvider&lt;Application&gt; {
    private static DataSourceViewProvider instance = new SamplingProvider();
    @Override
    public boolean supportsViewFor(Application application) {
        boolean result = false;
        JmxModel jmx = JmxModelFactory.getJmxModelFor(application);
        if (jmx != null &amp;&amp; jmx.getConnectionState() == JmxModel.ConnectionState.CONNECTED) {
            MBeanServerConnection mbsc = jmx.getMBeanServerConnection();
            if (mbsc != null) {
                try {
                    mbsc.getObjectInstance(new ObjectName("org.openjdk.cookbook:type=SleepProbe"));
                    result = true; // no exception - bean found
                }catch (InstanceNotFoundException e) {
                    // bean not found, ignore
                } catch (Exception e1) {
                    Exceptions.printStackTrace(e1);
                }
            }
        }
        return result;
    }

    @Override
    protected DataSourceView createView(Application application) {
        return new SamplingView(application);
    }

    static void initialize() {
        DataSourceViewsManager.sharedInstance().addViewProvider(instance, Application.class);
    }

    static void unregister() {
        DataSourceViewsManager.sharedInstance()
                     .removeViewProvider(instance);
    }

    public static Object getSleepProbeInstance(Application application) {
        ObjectInstance instance = null;
        JmxModel jmx = JmxModelFactory.getJmxModelFor(application);
        if (jmx != null &amp;&amp; jmx.getConnectionState() == JmxModel.ConnectionState.CONNECTED) {
            MBeanServerConnection mbsc = jmx.getMBeanServerConnection();
            if (mbsc != null) {
                try {
                    instance = mbsc.getObjectInstance(new ObjectName("org.openjdk.cookbook:type=SleepProbe"));
                } catch (InstanceNotFoundException e) {
                    // bean not found, ignore
                } catch (Exception e) {
                    Exceptions.printStackTrace(e);
                }
            }
        }
        return instance;
    }
}</pre></div></li><li class="listitem">The main methods<a id="id387" class="indexterm"/> of this class are <code class="literal">supportsViewFor</code> and <code class="literal">createView</code>. The <code class="literal">createView</code> method is small and easy, it just creates a view instance and passes through the application so that the view can get data out of it. The <code class="literal">supportsViewFor</code> class is slightly bigger, but it doesn't really match. It connects to the given application via JMX and tries to get the instance of <code class="literal">MBean</code> which our plugin is interested in. If <code class="literal">MBean</code> is not there, it means that the application is not supported and the method returns <code class="literal">false</code>.</li><li class="listitem">Now it is time to<a id="id388" class="indexterm"/> see how the plugin works. To do this, first start the application created on the first step of this receipt. Then right-click on <span class="strong"><strong>SamplingModule</strong></span> and select <span class="strong"><strong>Run</strong></span>. This will start VisualVM with our plugin. From the list of processes in VisualVM, select our process and click on the <span class="strong"><strong>Sampling Application</strong></span> tab. There you will see our graph showing slight changes in the sleep time as shown in the following screenshot:<div class="mediaobject"><img src="graphics/8405OT_08_21.jpg" alt="How to do it..."/></div></li></ol></div><p>After<a id="id389" class="indexterm"/> following<a id="id390" class="indexterm"/> these steps, it should not be a problem for the reader to extend this example and use it for any kind of monitoring applications that he/she wants in VisualVM.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec224"/>See also</h2></div></div></div><p>There is some documentation available on the VisualVM website, which helps with creating the plugin for VisualVM and which covers, in more detail, some classes which are used in this receipt, at <a class="ulink" href="http://visualvm.java.net/api-quickstart.html">http://visualvm.java.net/api-quickstart.html</a>.</p><p>It is also worth having a look at existing plugins source code and some samples available. These can be found in <code class="literal">&lt;code_root&gt;/plugins</code> and <code class="literal">&lt;code_root&gt;/samples</code> respectively. For instructions on how to download the source code, please see the <span class="emphasis"><em>Building VisualVM from the source code</em></span> recipe.</p></div></div>
<div class="section" title="Getting benefits from the AdoptOpenJDK project"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec67"/>Getting benefits from the AdoptOpenJDK project</h1></div></div></div><p>AdoptOpenJDK is <a id="id391" class="indexterm"/>a program, initially developed by a small group of enthusiasts, but which became part of an official<a id="id392" class="indexterm"/> OpenJDK community. Some of the purposes are to clarify and simplify OpenJDK building, installation, and usage, but there is still more. It provides build automation, a report generator, build testing, and more. We will cover some basic features that will be useful for everyone.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec225"/>Getting ready</h2></div></div></div><p>To follow this recipe, we will need an OpenJDK instance installed, and an Internet connection established.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec226"/>How to do it...</h2></div></div></div><p>AdoptOpenJDK<a id="id393" class="indexterm"/> is a very helpful and a very sophisticated project set with quite a few different subprojects. Many of them concern testing and evangelism, so we could not include them here as recipes.</p><div class="section" title="Visualizing JIT logs"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec08"/>Visualizing JIT logs</h3></div></div></div><p>There is <a id="id394" class="indexterm"/>a project named <a id="id395" class="indexterm"/>Jitwatch in AdoptOpenJDK. Its purpose is to visualize JIT compiler logs. It helps to find some of our project's performance deficiencies and inspect a native assembly output, as it's just fun after all. Have a look at the following points:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's download an <a id="id396" class="indexterm"/>executable jar <a class="ulink" href="http://www.chrisnewland.com/images/jitwatch.jar">http://www.chrisnewland.com/images/jitwatch.jar</a>.</li><li class="listitem">In order to analyze an executable, we will need to run it with the following switches:<div class="informalexample"><pre class="programlisting">-XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading -XX:+LogCompilation -XX:+PrintAssembly</pre></div><p>The <code class="literal">UnlockDiagnosticVMOptions</code> parameter<a id="id397" class="indexterm"/> gives access to other diagnostic options, such as <code class="literal">SharedOptimizeColdStart</code>, <code class="literal">PauseAtStartup</code>, and so on.</p><p>The <code class="literal">LogCompilation</code><a id="id398" class="indexterm"/> logs compilation activity in detail to <code class="literal">hotspot.log</code> or <code class="literal">LogFile</code>, which is yet another VM option.</p><p>The <code class="literal">TraceClassLoading</code> parameter<a id="id399" class="indexterm"/> lets JVM ensure that all loaded classes are visible, even the ones without any JIT-compiled code related to them.</p><p>The <code class="literal">PrintAssembly</code> parameter<a id="id400" class="indexterm"/> lets us see the assembler output of the JIT compilation. It uses <code class="literal">hsdis</code>, a HotSpot disassembler, which is a part of OpenJDK.</p></li><li class="listitem">Start the analyzer:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> java -jar ./jitwatch.jar</strong></span>
</pre></div><p>You will see the following screen:</p><div class="mediaobject"><img src="graphics/8405OT_08_22.jpg" alt="Visualizing JIT logs"/></div></li><li class="listitem">Open<a id="id401" class="indexterm"/> your <code class="literal">hotspot.log</code> and, then press <span class="strong"><strong>Start</strong></span>.</li></ol></div><p>Enjoy the experience.</p></div><div class="section" title="Securing your javadocs"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec09"/>Securing your javadocs</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will<a id="id402" class="indexterm"/> try to eliminate a javadoc vulnerability (CVE-2013-1571) that seems to exist in Java releases before 7u22.</li><li class="listitem">To do that, we will need to clone a repository, such as:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git clone https://github.com/AdoptOpenJDK/JavadocUpdaterTool.git &amp;&amp; cd JavadocUpdaterTool</strong></span>
</pre></div><p>Build the project</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn clean install</strong></span>
</pre></div></li><li class="listitem">We will try to scan a directory for potential vulnerabilities. We will run the following command from the directory in which the <code class="literal">JavadocPatchTool.jar</code> file is located:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -jar JavadocPatchTool.jar -R -C &lt;directory&gt;</strong></span>
</pre></div><p>If the tool finds any applicable HTML files, it will print out a list of such files.</p></li><li class="listitem">To fix a single applicable file, we will run the following command:<p>java -jar JavadocPatchTool.jar &lt;path&gt;</p><p>Here, <code class="literal">&lt;path&gt;</code> is the path to the directory which contains the applicable file.</p></li><li class="listitem">To fix all the <a id="id403" class="indexterm"/>applicable files in the tree, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -jar JavadocPatchTool.jar -R &lt;path_to_tree&gt;</strong></span>
</pre></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>To learn about more benefits from the AdoptOpenJDK project, visit the appropriate page at <a class="ulink" href="https://java.net/projects/adoptopenjdk/pages/Benefits">https://java.net/projects/adoptopenjdk/pages/Benefits</a>.</p></div></div></li></ol></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec227"/>How it works…</h2></div></div></div><p>JIT log visualizer<a id="id404" class="indexterm"/> is no more than a tool to process logs generated by OpenJDK. But it is a very useful tool that may significantly improve performance.</p><p>Java is used in various projects that need security, so the vulnerability in javadocs has an impact on those who still use Java 6 and are unable to change it to Java 7. So the tool that fixes it with no transitions in the technology is really invaluable.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec228"/>There's more...</h2></div></div></div><p>There are many more projects in AdoptOpenJDK. Most of them are evangelist or testing ones; thus, they are slightly beyond the scope of this book.</p><p>However, you can always find them on various AdoptOpenJDK sites. There is no need to mention all of them in this book, they are tightly linked. In order to find them, it is sufficient to just look around.</p></div></div></body></html>