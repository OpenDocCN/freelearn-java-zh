["```java\n    GET          /users/1   = List information about user id 1 \n    PUT          /users/1   = Insert user 1 \n    POST         /users/1   = Update user 1 \n    DELETE       /users/1   =  Delete user 1 \n    GET          /users/    = Lists All users \n\n```", "```java\n    HTTP HEADER Content-Type = XML - GET /cars/1  \n    HTTP HEADER Content-Type = JSON - GET /cars/1  \n\n```", "```java\n    GET /projects/1/tasks?by=priority             -> Sorting  \n    GET /projects/1/tasks?status=done             -> Filter \n    GET /projects/1/tasks?limit=30&offset=5       -> Pagination \n\n```", "```java\n    package controllers  \n    @Singleton \n    class RestAPIController @Inject() \n    (val productService:IProductService, \n      val reviewService:IReviewService, \n    val imageService:IImageService) extends Controller {  \n      import play.api.libs.concurrent.Execution.\n      Implicits.defaultContext  \n      def listAllProducts = Action { \n        val future = productService.findAll() \n        val products = Awaits.get(5,future) \n        val json = ProductsJson.toJson(products) \n        Ok(json) \n      }  \n      def listAllReviews = Action { \n        val future = reviewService.findAll() \n        val reviews = Awaits.get(5,future) \n        val json = ReviewsJson.toJson(reviews) \n        Ok(json) \n      } \n      def processImages = { \n        val future = imageService.findAll() \n        val images = Awaits.get(5,future) \n        val json = ImagesJson.toJson(images) \n        json \n      } \n      def listAllImages = Action { \n        Ok(processImages) \n      }\n    } \n\n```", "```java\n    object ProductsJson {  \n      import play.api.libs.json._ \n      import play.api.libs.json.Reads._ \n      import play.api.libs.functional.syntax._  \n      implicit val productWrites: Writes[Product] = ( \n        (JsPath \\ \"id\").write[Option[Long]] and \n        (JsPath \\ \"name\").write[String] and \n        (JsPath \\ \"details\").write[String] and \n        (JsPath \\ \"price\").write[BigDecimal] \n      )(unlift(Product.unapply)) \n      implicit val productReads: Reads[Product] = ( \n        (JsPath \\ \"id\").readNullable[Long] and \n        (JsPath \\ \"name\").read[String] and \n        (JsPath \\ \"details\").read[String] and \n        (JsPath \\ \"price\").read[BigDecimal] \n      )(Product.apply _)  \n      def toJson(products:Option[Seq[Product]]) = Json.toJson(products) \n    } \n\n```", "```java\n    object ReviewsJson {  \n      import play.api.libs.json._ \n      import play.api.libs.json.Reads._ \n      import play.api.libs.functional.syntax._  \n      implicit val reviewWrites: Writes[Review] = ( \n        (JsPath \\ \"id\").write[Option[Long]] and \n        (JsPath \\ \"productId\").write[Option[Long]] and \n        (JsPath \\ \"author\").write[String] and \n        (JsPath \\ \"comment\").write[String] \n      )(unlift(Review.unapply)) \n      implicit val reviewReads: Reads[Review] = ( \n        (JsPath \\ \"id\").readNullable[Long] and \n        (JsPath \\ \"productId\").readNullable[Long] and \n        (JsPath \\ \"author\").read[String] and \n        (JsPath \\ \"comment\").read[String] \n      )(Review.apply _)  \n      def toJson(reviews:Option[Seq[Review]]) = Json.toJson(reviews) \n    } \n\n```", "```java\n    object ImagesJson {  \n      import play.api.libs.json._ \n      import play.api.libs.json.Reads._ \n      import play.api.libs.functional.syntax._  \n      implicit val imagesWrites: Writes[Image] = ( \n        (JsPath \\ \"id\").write[Option[Long]] and \n        (JsPath \\ \"productId\").write[Option[Long]] and \n        (JsPath \\ \"url\").write[String] \n      )(unlift(Image.unapply))     \n      implicit val imagesReads: Reads[Image] = ( \n        (JsPath \\ \"id\").readNullable[Long] and \n        (JsPath \\ \"productId\").readNullable[Long] and \n        (JsPath \\ \"url\").read[String] \n      )(Image.apply _)  \n      def toJson(images:Option[Seq[Image]]) = Json.toJson(images) \n    } \n\n```", "```java\n    # \n    # REST API \n    # \n    GET /REST/api/product/all \n    controllers.RestAPIController.listAllProducts \n    GET /REST/api/review/all \n    controllers.RestAPIController.listAllReviews \n    GET /REST/api/image/all controllers.RestAPIController.listAllImages \n\n```", "```java\n    sbt.version=0.13.11 \n\n```", "```java\n    addSbtPlugin(\"com.typesafe.sbteclipse\" % \"sbteclipse-plugin\" % \n      \"2.5.0\") \n    addSbtPlugin(\"com.github.mpeltonen\" % \"sbt-idea\" % \"1.6.0\") \n\n```", "```java\n    name := \"rest-client\"  \n    version := \"1.0\" \n    scalaVersion := \"2.11.7\" \n    scalaVersion in ThisBuild := \"2.11.7\"  \n    resolvers += DefaultMavenRepository \n    resolvers += JavaNet1Repository \n    resolvers += \"OSSSonatype\" at \n    \"https://oss.sonatype.org/content/repositories/releases\" \n    resolvers += \"Sonatype OSS Snapshots\" at \n    \"https://oss.sonatype.org/content/repositories/snapshots\" \n    resolvers += \"Sonatype OSS Snapshots\" at \n    \"https://oss.sonatype.org/content/repositories/snapshots\" \n    resolvers += \"amateras-repo\" at \n    \"http://amateras.sourceforge.jp/mvn/\"  \n    libraryDependencies += \"com.typesafe.play\" % \"play-ws_2.11\" % \n    \"2.5.6\" \n    libraryDependencies += \"org.scalatest\" % \"scalatest_2.11\" % \"2.2.6\" \n    % Test \n\n```", "```java\n    package client  \n    object WSFactory {  \n      import akka.actor.ActorSystem \n      import akka.stream.ActorMaterializer  \n      def ws = {  \n        implicit val system = ActorSystem() \n        implicit val materializer = ActorMaterializer()  \n        import com.typesafe.config.ConfigFactory \n        import play.api._ \n        import play.api.libs.ws._ \n        import play.api.libs.ws.ahc.{AhcWSClient, AhcWSClientConfig} \n        import play.api.libs.ws.ahc.AhcConfigBuilder \n        import org.asynchttpclient.AsyncHttpClientConfig \n        import java.io.File  \n        val configuration = Configuration.reference ++ \n        Configuration(ConfigFactory.parseString( \n          \"\"\" \n          |ws.followRedirects = true \n        \"\"\".stripMargin))  \n        val parser = new WSConfigParser(configuration, \n        play.api.Environment.simple(\n        new File(\"/tmp/\"), null)) \n        val config = new AhcWSClientConfig(wsClientConfig = \n        parser.parse()) \n        val builder = new AhcConfigBuilder(config) \n        val logging = new \n        AsyncHttpClientConfig.AdditionalChannelInitializer() { \n          override def initChannel(channel: io.netty.channel.Channel): \n          Unit = { \n            channel.pipeline.addFirst(\"log\", new \n            io.netty.handler.logging.LoggingHandler(\"debug\")) \n          }\n        }  \n        val ahcBuilder = builder.configure() \n        ahcBuilder.setHttpAdditionalChannelInitializer(logging) \n        val ahcConfig = ahcBuilder.build() \n        new AhcWSClient(ahcConfig) \n      }\n    } \n\n```", "```java\n    package utils  \n    import scala.concurrent.Future \n    import scala.concurrent.duration._ \n    import scala.concurrent.Await  \n    object Awaits { \n      def get[T](sec:Int,f:Future[T]):T = { \n        Await.result[T](f, sec seconds) \n      }\n    } \n\n```", "```java\n    package proxy  \n    import client.WSFactory \n    import utils.Awaits  \n    case class Product \n    ( var id:Option[Long], \n      var name:String, \n      var details:String, \n    var price:BigDecimal ) { \n      override def toString:String = { \n        \"Product { id: \" + id.getOrElse(0) + \",name: \" + name + \", \n        details: \"+ details + \", price: \n        \" + price + \"}\" \n      }\n    }  \n    object ProductsJson {  \n      import play.api.libs.json._ \n      import play.api.libs.json.Reads._ \n      import play.api.libs.functional.syntax._ \n      implicit val productWrites: Writes[Product] = (  \n        (JsPath \\ \"id\").write[Option[Long]] and \n        (JsPath \\ \"name\").write[String] and \n        (JsPath \\ \"details\").write[String] and \n        (JsPath \\ \"price\").write[BigDecimal] \n      )(unlift(Product.unapply)) \n      implicit val productReads: Reads[Product] = ( \n        (JsPath \\ \"id\").readNullable[Long] and \n        (JsPath \\ \"name\").read[String] and \n        (JsPath \\ \"details\").read[String] and \n        (JsPath \\ \"price\").read[BigDecimal] \n      )(Product.apply _)  \n      def toJson(products:Option[Seq[Product]]) = Json.toJson(products) \n    }  \n    object ProductProxy {  \n      import scala.concurrent.Future \n      import play.api.libs.json._ \n      import ProductsJson._  \n      val url = \"http://localhost:9000/REST/api/product/all\" \n      implicit val context = \n      play.api.libs.concurrent.Execution.Implicits.defaultContext  \n      def listAll():Option[List[Product]] = { \n        val ws = WSFactory.ws \n        val futureResult:Future[Option[List[Product]]] = \n        ws.url(url).withHeaders(\"Accept\" -> \n        \"application/json\").get().map( \n          response => \n          Json.parse(response.body).validate[List[Product]].asOpt \n        )  \n        val products = Awaits.get(10, futureResult) \n        ws.close \n        products \n      }\n    } \n\n```", "```java\n    package proxy  \n    import client.WSFactory \n    import utils.Awaits  \n    case class Review \n    (var id:Option[Long], \n      var productId:Option[Long], \n      var author:String, \n    var comment:String) \n    { \n      override def toString:String = { \n        \"Review { id: \" + id + \" ,productId: \" + productId.getOrElse(0) \n        + \",author: \" + author + \n        \",comment: \" + comment + \" }\" \n      } \n    }  \n    object ReviewsJson {  \n      import play.api.libs.json._ \n      import play.api.libs.json.Reads._ \n      import play.api.libs.functional.syntax._  \n      implicit val reviewWrites: Writes[Review] = ( \n        (JsPath \\ \"id\").write[Option[Long]] and \n        (JsPath \\ \"productId\").write[Option[Long]] and \n        (JsPath \\ \"author\").write[String] and \n        (JsPath \\ \"comment\").write[String] \n      )(unlift(Review.unapply))  \n      implicit val reviewReads: Reads[Review] = ( \n        (JsPath \\ \"id\").readNullable[Long] and \n        (JsPath \\ \"productId\").readNullable[Long] and \n        (JsPath \\ \"author\").read[String] and \n        (JsPath \\ \"comment\").read[String] \n      )(Review.apply _) \n      def toJson(reviews:Option[Seq[Review]]) = Json.toJson(reviews) \n    }  \n    object ReviewProxy { \n      import scala.concurrent.Future \n      import play.api.libs.json._ \n      import ReviewsJson._ \n      val url = \"http://localhost:9000/REST/api/review/all\" \n      implicit val context = \n      play.api.libs.concurrent.Execution.Implicits.defaultContext \n      def listAll():Option[List[Review]] = { \n        val ws = WSFactory.ws \n        val futureResult:Future[Option[List[Review]]] = \n        ws.url(url).withHeaders(\"Accept\" -> \n        \"application/json\").get().map( \n          response => \n          Json.parse(response.body).validate[List[Review]].asOpt \n        ) \n        val reviews = Awaits.get(10, futureResult) \n        ws.close \n        reviews \n      }\n    } \n\n```", "```java\n    package proxy  \n    import client.WSFactory \n    import utils.Awaits  \n    case class Image \n    (var id:Option[Long], \n      var productId:Option[Long], \n    var url:String) \n    { \n      override def toString:String = { \n        \"Image { productId: \" + productId.getOrElse(0) + \",url: \" + url \n        + \"}\" \n      } \n    }  \n    object ImagesJson {  \n      import play.api.libs.json._ \n      import play.api.libs.json.Reads._ \n      import play.api.libs.functional.syntax._  \n      implicit val imagesWrites: Writes[Image] = ( \n        (JsPath \\ \"id\").write[Option[Long]] and \n        (JsPath \\ \"productId\").write[Option[Long]] and \n        (JsPath \\ \"url\").write[String] \n      )(unlift(Image.unapply))  \n      implicit val imagesReads: Reads[Image] = ( \n        (JsPath \\ \"id\").readNullable[Long] and \n        (JsPath \\ \"productId\").readNullable[Long] and \n        (JsPath \\ \"url\").read[String] \n      )(Image.apply _) \n      def toJson(images:Option[Seq[Image]]) = Json.toJson(images) \n    } \n    object ImageProxy { \n      import scala.concurrent.Future \n      import play.api.libs.json._ \n      import ImagesJson._ \n      val url = \"http://localhost:9000/REST/api/image/all\" \n      implicit val context =  \n      play.api.libs.concurrent.Execution.Implicits.defaultContext \n      def listAll():Option[List[Image]] = { \n        val ws = WSFactory.ws \n        val futureResult:Future[Option[List[Image]]] = \n        ws.url(url).withHeaders(\"Accept\" -> \n        \"application/json\").get().map( \n          response => \n          Json.parse(response.body).validate[List[Image]].asOpt \n        ) \n        val images = Awaits.get(10, futureResult) \n        ws.close \n        images \n      }\n    } \n\n```", "```java\n    package proxy.test  \n    import org.scalatest._ \n    import proxy.ProductProxy  \n    class ProductProxtTestSpec extends FlatSpec with Matchers {  \n      \"A Product Rest proxy \" should \"return all products\" in { \n        val products = ProductProxy.listAll().get \n        products shouldNot(be(null)) \n        products shouldNot(be(empty))  \n      }\n    } \n\n```", "```java\n    package proxy.test  \n    import org.scalatest._ \n    import proxy.ReviewProxy  \n    class ReviewProxyTestSpec extends FlatSpec with Matchers {  \n      \"A Review REST Proxy \" should \"return all reviews\" in { \n        val reviews = ReviewProxy.listAll().get \n        reviews shouldNot(be(null)) \n        reviews shouldNot(be(empty)) \n        for( r <- reviews){ \n          println(r) \n        }\n      }\n    } \n\n```", "```java\n    package proxy.test  \n    import org.scalatest._ \n    import proxy.ImageProxy \n    import scala.concurrent.Future \n    import play.api.libs.concurrent.Execution.Implicits.defaultContext \n    import java.util.concurrent.CountDownLatch  \n    class ImageProxyTestSpec extends FlatSpec with Matchers {  \n      \"A Image REST Proxy \" should \"return all images\" in { \n        val images = ImageProxy.listAll().get \n        images shouldNot(be(null)) \n        images shouldNot(be(empty)) \n        for( i <- images){ \n          println(i) \n        }\n      }\n    } \n\n```", "```java\n    package backpresurre  \n    import scala.concurrent.duration._ \n    import java.util.Date  \n    class LeakyBucket(var rate: Int, var perDuration: FiniteDuration) {  \n      var numDropsInBucket: Int = 0 \n      var timeOfLastDropLeak:Date = null \n      var msDropLeaks = perDuration.toMillis  \n      def dropToBucket():Boolean = { \n        synchronized { \n          var now = new Date()  \n          if (timeOfLastDropLeak != null) { \n            var deltaT = now.getTime() - timeOfLastDropLeak.getTime() \n            var numberToLeak:Long = deltaT / msDropLeaks  \n              if (numberToLeak > 0) { \n                if (numDropsInBucket <= numberToLeak) { \n                  numDropsInBucket -= numberToLeak.toInt \n                } else { \n                numDropsInBucket = 0 \n              } \n              timeOfLastDropLeak = now \n            } \n          }else{ \n            timeOfLastDropLeak = now   \n          }  \n          if (numDropsInBucket < rate) { \n            numDropsInBucket = numDropsInBucket + 1 \n            return true; \n          } \n          return false; \n        }\n      }\n    } \n\n```", "```java\n    package controllers  \n    class RestAPIController @Inject() \n    (val productService:IProductService, \n      val reviewService:IReviewService, \n      val imageService:IImageService) extends Controller {  \n        import \n        play.api.libs.concurrent.Execution.Implicits.defaultContext  \n        // REST of the Controller...  \n        import scala.concurrent.duration._  \n        var bucket = new LeakyBucket(5, 60 seconds)  \n        def processImages = { \n          val future = imageService.findAll() \n          val images = Awaits.get(5,future) \n          val json = ImagesJson.toJson(images) \n          json \n        }  \n        def processFailure = { \n          Json.toJson(\"Too Many Requests - Try Again later... \") \n        } \n        def listAllImages = Action { \n          bucket.dropToBucket() match { \n            case true => Ok(processImages) \n            case false => \n            InternalServerError(processFailure.toString()) \n          }\n        }\n     } \n\n```", "```java\n    package proxy.test  \n    class ImageProxyTestSpec extends FlatSpec with Matchers {  \n      // REST of the tests...  \n      \"A Image REST Proxy \" should \"suffer backpressure\" in { \n        val latch = new CountDownLatch(10) \n        var errorCount:Int = 0 \n        for(i <- 1 to 10){ \n          Future{ \n            try{ \n              val images = ImageProxy.listAll().get \n              images shouldNot(be(null)) \n              for( i <- images){ \n                println(i) \n              } \n            }catch{ \n              case t:Throwable => errorCount += 1 \n            } \n            latch.countDown() \n          }\n        }     \n        while( latch.getCount >= 1 ) \n        latch.await() \n        errorCount should be >=5 \n      } \n    } \n\n```", "```java\n    // Rest of build file...   \n    libraryDependencies ++= Seq( \n      // Rest of other deps...  \n      \"io.swagger\" %% \"swagger-play2\" % \"1.5.2-SNAPSHOT\" \n    ) \n\n```", "```java\n$ git clone https://github.com/CreditCardsCom/swagger-play.git\n$ cd swagger-play/\n$ sbt publishLocal\n\n```", "```java\n    play.modules { \n      enabled += \"play.modules.swagger.SwaggerModule\" \n    } \n\n```", "```java\n    package controllers  \n    @Singleton \n    @Api(value = \"/REST/api\", description = \"REST operations on \n    Products, Images and Reviews. \") \n    class RestAPIController @Inject() \n    (val productService:IProductService, \n      val reviewService:IReviewService, \n      val imageService:IImageService) extends Controller { \n        import \n        play.api.libs.concurrent.Execution.Implicits.defaultContext  \n        @ApiOperation( \n          nickname = \"listAllProducts\", \n          value = \"Find All Products\", \n          notes = \"Returns all Products\", \n          response = classOf[models.Product], \n          httpMethod = \"GET\" \n        ) \n        @ApiResponses(Array( \n          new ApiResponse(code = 500, message = \"Internal Server \n          Error\"), \n          new ApiResponse(code = 200, message = \"JSON response with \n          data\") \n        )\n      ) \n      def listAllProducts = Action { \n        val future = productService.findAll() \n        val products = Awaits.get(5,future) \n        val json = ProductsJson.toJson(products) \n        Ok(json) \n      }  \n      @ApiOperation( \n        nickname = \"listAllReviews\", \n        value = \"Find All Reviews\", \n        notes = \"Returns all Reviews\", \n        response = classOf[models.Review], \n        httpMethod = \"GET\" \n      ) \n      @ApiResponses(Array( \n        new ApiResponse(code = 500, message = \"Internal Server Error\"), \n        new ApiResponse(code = 200, message = \"JSON response with \n        data\") \n      )\n      ) \n      def listAllReviews = Action { \n        val future = reviewService.findAll() \n        val reviews = Awaits.get(5,future) \n        val json = ReviewsJson.toJson(reviews) \n        Ok(json) \n      }  \n      import scala.concurrent.duration._ \n      var bucket = new LeakyBucket(5, 60 seconds) \n      def processImages = { \n        val future = imageService.findAll() \n        val images = Awaits.get(5,future) \n        val json = ImagesJson.toJson(images) \n        json \n      }  \n      def processFailure = { \n        Json.toJson(\"Too Many Requests - Try Again later... \") \n      }  \n      @ApiOperation( \n        nickname = \"listAllImages\", \n        value = \"Find All Images\", \n        notes = \"Returns all Images - There is throttling of 5 \n        reqs/sec\", \n        response = classOf[models.Image], \n        httpMethod = \"GET\" \n      ) \n      @ApiResponses(Array( \n        new ApiResponse(code = 500, message = \"Internal Server Error\"), \n        new ApiResponse(code = 200, message = \"JSON response with \n        data\") \n      )\n      )  \n      def listAllImages = Action { \n        bucket.dropToBucket() match { \n          case true => Ok(processImages) \n          case false => InternalServerError(processFailure.toString()) \n        }\n      }\n    } \n\n```", "```java\n    // REST of the other routes..  \n    GET     /swagger.json    controllers.ApiHelpController.getResources \n\n```", "```java\n$ sudo apt-get update $ sudo apt-get install nodej $ sudo apt-get install npm \n$ git clone https://github.com/swagger-api/swagger-ui.git $ cd swagger-ui/ $ sudo -E npm install -g $ sudo -E npm run build $ npm run serve $ GOTO: http://localhost:8080/\n\n```", "```java\n    url = \"http://localhost:9000/swagger.json\"; \n\n```", "```java\n    @(message: String)(implicit flash:Flash)  \n    @main(\"Welcome to Reactive Web Store\"){ \n      <div class=\"row-fluid\"> \n        <BR> \n        <div class=\"span12\"> \n          <div class=\"row-fluid\"> \n            <div class=\"span6\"> \n              <a href=\"/product\"><img height=\"42\" width=\"42\" \n              src=\"img/@routes.Assets.at(\"images/product.png\")\"> Manage \n              Products</a><BR> \n              <a href=\"/review\"><img height=\"42\" width=\"42\" \n              src=\"img/@routes.Assets.at(\"images/review.png\")\"> Manage \n              Reviews</a><BR> \n              <a href=\"/image\"><img height=\"42\" width=\"42\" \n              src=\"img/@routes.Assets.at(\"images/image.png\")\"> Manage \n              Images</a><BR> \n            </div> \n            <div class=\"span6\"> \n            <a href=\"/reports\"><img height=\"42\" width=\"42\" \n            src=\"img/@routes.Assets.at(\"images/reports.png\")\"> Reports </a>\n            <BR> \n            <a href=\"/chat/index_socket\"><img height=\"42\" width=\"42\" \n            src=\"img/@routes.Assets.at(\"images/chat.png\")\"> Chat Room </a>\n            <BR> \n            <a href=\"/assets/swaggerui/index.html\"><img height=\"42\" \n            width=\"42\" \n            src=\"img/@routes.Assets.at(\"images/swagger.png\")\"> Swagger REST \n            API </a><BR> \n          </div> \n        </div> \n      </div>             \n    </div>} \n\n```"]