- en: Implementing CRUD User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most business applications have to deal with data manipulation. Users are able
    to see, change, delete, and add data. All these actions are executed according
    to and in the context of a set of rules dictated by the business. In its more
    fundamental form, business applications include graphical user interfaces to perform
    CRUD actions over the data. **CRUD** is an acronym for **Create, Read, Update,
    and Delete**. This chapter explores the design and implementation of CRUD views.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with a quick discussion about CRUD views from a **User Experience**
    (**UX**) perspective. Then, we will move on to how to design and implement CRUD
    user interfaces using two different UI designs. This chapter also explains the
    basics of data binding, shows how to use the Java Bean Validation API, and demonstrates
    how to render UI components inside `Grid` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: CRUD user interface design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating with JSR-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grid renderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-07](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-07)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/szGaRy](https://goo.gl/szGaRy)'
  prefs: []
  type: TYPE_NORMAL
- en: CRUD user interface design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UX in the context of **user interfaces** (**UI**) refers to the degree of quality
    in the interaction between the user and the UI. An application designed with UX
    in mind enhances the user satisfaction by improving its usability. Simplicity
    is key in the process of UX design, but avoid falling into a minimalistic design,
    which may otherwise spoil usability.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about simplicity, minimalism, and general myths
    about UX design at [http://uxmyths.com](http://uxmyths.com).
  prefs: []
  type: TYPE_NORMAL
- en: UX design may include several disciplines, including wireframing, prototyping,
    testing, and validating designs. In this section, we'll explore variations of
    typical CRUD views. Examples of this kind of views are the admin views for managing
    registered users, views for internal application configuration, or views used
    by **DevOps** members.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps is a softwares engineering discipline that unifies software development
    and software operation (deployment and infrastructure management).
  prefs: []
  type: TYPE_NORMAL
- en: We'll avoid the term CRUD for more sophisticated views that might include all
    of the CRUD operations. In general, these views are business-specific, and developers
    should design them according to the particularities of each case.
  prefs: []
  type: TYPE_NORMAL
- en: 'CRUD views are about *record* editing. Records are items that are usually understood
    as a whole. Some are suitable for tabular presentation, while others are not;
    for example, events on a calendar. When designing a CRUD view, think about the
    following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Record complexity**: How many fields does the record contain? Do the fields
    change depending on the state of other fields? Are there any complex fields such
    as maps or calendars? How complex are the validation rules?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Editing frequency**: How often do users need to edit the record? Do they
    need a quick way to edit certain fields?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context awareness**: Do users need extra data when editing a record? Do they
    need, or would they benefit from, seeing other records when editing one?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a rule of thumb, think about how frequently users will perform the actions
    on the view, and if they can benefit from seeing many records at a time or not.
    If the frequency is high for any operation, and they won't benefit from seeing
    other records in the view, don't use a *generic* CRUD interface. Implement the
    view tailored to the use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze three CRUD user interface designs: in-place fields, modal pop-up
    windows, and hierarchical menus.'
  prefs: []
  type: TYPE_NORMAL
- en: In-place fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this design, users can activate a field to edit a single value. Data can
    be presented in a tabular format, in which case, clicking a cell would activate
    an input field, which would allow the user to directly edit the value. The following
    figure shows an example of this kind of interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35e20d1c-121d-4f7a-865b-c0e31333f633.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Vaadin Framework** allows this through the `Grid.addComponentColumn`
    method. The following line adds a `Button` to an existing `Grid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are advantages and disadvantages of using this option. The main advantage
    is speed. Users can quickly edit a value, and there's no need to navigate to other
    views in order to edit the data; however, implementing the `add` operation requires
    extra considerations. When the user clicks the Add button, a new empty row is
    added; however, it's not easy to know when the row can be saved (in a database,
    for example). Is a completely empty row a valid record? One way of solving this
    is by only persisting the record when all the values in it are valid. Another
    disadvantage is evident when the record has many fields, which, in this case,
    means a grid with many columns. Editing the data in columns that are scrolled
    out of the view requires extra interaction from the user, which wipes out the
    advantage of editing data quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Modal pop-up windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This kind of user interface shows a modal window anytime the user wants to
    create, modify, or delete a record. A first approach to this is to combine in-place
    editors with modal windows. When the user clicks or double-clicks a row, an editor
    is placed on top of the row, showing all the input fields required to edit the
    data, and the buttons to cancel the action or save the data. This is exactly what
    `Grid` editors are in Vaadin Framework, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5610e18f-b17c-404e-9a2c-b708baebb7d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is enabled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A second approach is to actually show a modal window that blocks any other
    interaction with other parts of the page. The following is a figure of this kind
    of interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3182171e-c5c3-4372-9ada-b3202220c36c.png)'
  prefs: []
  type: TYPE_IMG
- en: There are several advantages of this approach. The window allows any kind of
    design for the form it contains. Input fields can be grouped if they are related,
    help text or instructions can be added, and validation errors can be shown in
    multiple ways. It is also an intuitive *dead-end view*; users cannot navigate
    anywhere else but back, which makes it an easy-to-use interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When data can be represented in a hierarchical way, it can serve as the *Read*
    part in CRUD, and as a navigation tool. The following figure shows a CRUD of *Organizations*,
    *Departments*, and *Employees* records:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92892c05-ea83-4a83-a2a4-b677f87b11b9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A key element in this kind of design is the use of most of the available space
    for the forms containing the input fields. Forms are shown in *view mode,* and
    are made editable when the user clicks an edit button. In the preceding figure,
    a short representation of the records appears in the navigation menu itself. In
    order to edit one record, the user can click it from the menu. When a record can
    be associated with one or many records of another type, they are grouped and shown
    in a hierarchical fashion in the menu. Top-level items in the menu don't necessarily
    need to be records themselves, since they can serve as a different kind of grouping.
    For example, a top item could show the Organizations option having all the actual
    organization records as *children*.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of design works well for configuration options; however, it has the
    disadvantage of showing many options at the same time, which might cause a distraction
    for end users. For example, a user might forget to click the **Save** button after
    editing some fields.
  prefs: []
  type: TYPE_NORMAL
- en: The domain model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following sections show how to implement CRUD views using two different
    designs: a `Grid` in editable mode, and modal windows. But first, we need to implement
    a **domain model**. We''ll use JPA and *repository classes*, which we explained
    in the previous chapters. The domain model consists of simple classes to model
    a role-based schema: `User`, and `Role`. It also includes the corresponding `UserRepository`
    and `RoleRepository` classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the simplest of the classes, `Role`. The following is the
    full implementation of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Besides the usual JPA configuration stuff (such as the `@Entity`, `@Id`, and
    `@GeneratedValue` annotations), the most interesting thing in this class is that
    there are no `getters` and `setters`. Nevertheless, `getters` and `setters` for
    each Java field in the class exist! This is thanks to *Project Lombok*, a library
    that reduces the amount of boilerplate code needed in Java programs. Lombok generates
    code at the class level. In the previous class, we used the `@Data` annotation
    in order to tell Lombok to generate `getters` and `setters`, and `toString`, `equals`,
    and `hashCode` methods. Since the `toString` method generated by Lombok doesn't
    fit our requirements, we override it and provided a custom one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use Lombok, you need to install it in your IDE, and add the dependency
    to the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find installation instructions for IntelliJ IDEA, NetBeans, Eclipse,
    and other IDEs at: [https://projectlombok.org](https://projectlombok.org). After
    installing Lombok, you''ll be able to use `autocomplete` and any other features
    of your IDE in order to use the generated code, even when you don''t see it in
    the Java class. For example, the following screenshot shows **IntelliJ IDEA**
    suggesting the generated `getName` method when using the autocomplete feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cec7d32-4af6-48de-9fb3-8c93a3ded99a.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use your own implementations for the `getters`, `setters`, `equals`,
    and `hashCode` instead of using Lombok. Most IDEs, if not all of them have features
    to generate these methods at the source code level; however, Lombok source files
    become much shorter, making them easier to maintain in most cases. `@Data` is
    not the only useful annotation offered by Lombok. See the documentation at [https://projectlombok.org](https://projectlombok.org)
    for more information about its features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the implementation of the `User` class, which uses Lombok
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `@ManyToMany` annotation in the `roles` field. What's the difference
    between `@ManyToMany` and `@OneToMany`? The `-ToMany` part means that every `User`
    can be associated with many `Role` objects. The `@Many-` part means that every
    `Role` can have many `User` instances. If `@OneToMany` was used, the `@One-` part
    would mean that every `Role` can be associated with only one `User`, which is
    clearly not what we want in this model.
  prefs: []
  type: TYPE_NORMAL
- en: Why does the `@ManyToMany` annotation specify `FetchType.EAGER` for the fetch
    strategy? Hibernate uses `Fetch.LAZY` by default, which might cause a `LazyInitializationException`.
    `Lazy` fetch can be useful if you want to load the data when it is actually needed.
    This, however, requires an open Hibernate session when the collection is accessed.
    In a web environment, the session is usually closed after the request is handled.
    Since we need to show `Role` data in the views, the best approach is to eagerly
    fetch the data. A common practice in many applications is to use the *Open Session
    in View* pattern; however, this might as well be considered an anti-pattern. Always
    consider using DTO projections instead of the Open Session in the View pattern.
    For a more detailed discussion about this topic, visit [https://vladmihalcea.com/2016/05/30/the-open-session-in-view-anti-pattern](https://vladmihalcea.com/2016/05/30/the-open-session-in-view-anti-pattern).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the domain model is the repository classes. For the `RoleRepository`
    class, we only need a method to find all the `Role` objects, and another to save
    a new one, as shown in the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And for completeness, the following are the methods in the `UserRepository`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The actual implementation of the methods is omitted here for simplicity, but
    you can find the complete source code of this chapter's example in the `Data-centric-Applications-with-Vaadin-8\chapter-07`
    Maven project of the source code that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a CRUD using an editable Grid component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll implement a component containing an editable `Grid`.
    The following is a screenshot of the application showing the `Grid` component
    in edit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caefa9c4-cd6c-404b-aeac-ec0e398d1191.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For simplicity, in this example, we''ll omit the *add* and the *delete* CRUD
    operations for now. Let''s start by creating a class to encapsulate the component
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The class, which extends `Composite`, declares a `Grid` to show `User` instances.
    There are several constructors available in the `Grid` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Grid()`: Creates a new `Grid`, without columns. Columns have to be manually
    added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid(String caption)`: The same as `Grid()`, but sets a caption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid(Class<T> beanType)`: Creates a new `Grid` and automatically creates columns
    for each property (having a `getter` and a `setter`) in the specified class. Columns
    can be retrieved by a name using the `getColumn(String)` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid(DataProvider<T, ?> dataProvider)`: Creates a new `Grid` without columns.
    It accepts a `DataProvider`, which is an abstraction to provide data from any
    kind of backend. You can implement this interface, or use the implementations
    available in the framework. If you are not familiar with data providers, refer
    to the official documentation at: [https://vaadin.com/docs/v8/framework/datamodel/datamodel-providers.html](https://vaadin.com/docs/v8/framework/datamodel/datamodel-providers.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid(String caption, DataProvider<T, ?> dataProvider)`: The same as `Grid(DataProvider)`,
    but sets a caption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid(String caption, Collection<T> items)`: Creates a new `Grid` without columns,
    and sets a caption. The provided collection is used to fetch the data that is
    going to be rendered in the `Grid` (a `DataProvider` is used behind the scenes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we have a `Grid` component without columns and without rows (data).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the read operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *read* CRUD operation can be thought of as the action of showing all the
    `User` instances inside the `Grid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `Grid` doesn''t have any columns at this point, adding rows to it
    won''t make any difference, so let''s start by adding columns. The easiest way
    to add columns to a `Grid` is by passing the type of the bean (`User`) to the
    `Grid` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can add columns by using the property names in the bean. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is not type-safe. When manually adding columns to a `Grid`, a
    better approach is not to use the `Grid(Class<T> beanType)` constructor, and instead
    use a `ValueProvider`. Let''s do this in the example application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a better approach, since it''s completely type-safe. The `addColumn`
    method accepts a `ValueProvider`, a functional interface compatible with any getter
    in the bean type. The `addColumn` method returns an instance of `Grid.Column`,
    from which we can configure any additional properties for it. In the previous
    snippet of code, we configured the column''s caption. All the `setXX` methods
    return the same instance of `Column`, which allows you to chain calls to further
    configure the column. For example, you can set the column''s caption and width
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the columns in place, we can now add rows to the `Grid`. This is as simple
    as calling the `setItems(Collection)` method, and passing a `Collection` of `User`
    instances. Since we will need to reload the content of the `Grid` after editing
    a row, it''s a good idea to encapsulate the call to `setItems` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a slight security problem at this point, and by "slight", I mean "major".
    Passwords are shown in plain text in the `Grid`. We want to keep the Password
    column, so that it plays nice with the `Grid` editor later, but we want to show
    a series of asterisks (`********`) instead of the actual passwords. This can be
    done through the `Renderer` interface. A `Renderer` is an extension that *draws*
    client-side representations of a value. We can use the provided `TextRenderer`
    implementation to change the text shown in the Password column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setRenderer` method accepts a `ValueProvider` and a `Renderer`. Instead
    of returning `user.getPassword()`, we return the `"********"` string, no matter
    what the value of the password is. `TextRenderer` will take the string, and *draw*
    it as text. There are many other `Renderers` that would take the value and draw
    it in many other forms; for example, as a `Button` or `HTML`. The following figure
    shows the implementations included with the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/651f918f-6f97-4382-80fa-86657a9b8d0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the update operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The update CRUD operation is implemented through the `Grid.Editor` class. Enabling
    the editor is as easy as calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `Editor` needs a way to know what kind of input component to use
    for each column, and also where to get the values for these input components,
    and how to set the values back in the bean once the user edits them. This is done
    with the help of two methods: `Grid.Editor.getBinder` , and `Grid.Column.setEditorBinding`.
    You should be familiar with the `Binder` class in the Vaadin Framework; it is
    a utility class that allows you to connect `setters` and `getters` with input
    components, as well as validators, converters, and other configurations for *data-binding*.
    You can get the `Binder` instance by calling the `getBinder` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic idea of the `Binder` class is that you can specify an input component
    and bind a getter and a setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`binder.bind(textField, User::getFirstName, User::setLastName);`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with the `Binder` class, go through the must-read documentation
    at: [https://vaadin.com/docs/v8/framework/datamodel/datamodel-forms.html](https://vaadin.com/docs/v8/framework/datamodel/datamodel-forms.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Editor` enabled, we can set an input component for each column. For
    example, we can use a `TextField` for the First Name column using the `setEditorBinding`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `setEditorBinding` accepts a `Binding` instance that we can easily get from
    the `binder`. We use the `forField` method in the `Binder` to specify a new `TextField`,
    and the `bind` method, which returns an instance of `Binding`, to configure the
    corresponding `getter` and setter in the `User` bean. The end result is that when
    you double-click a row in the `Grid`, the `Editor` will present a new `TextField`
    in the first name cell, which will set its value to what `User::getFirstName`
    returns, and will call `User::setFirstName`, passing the value in the `TextField`
    when you click the Save button.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when you set several editor bindings and copy/paste code. You might
    forget to change one of the three method references, which would result in strange
    behaviors, such as values not being updated or values being updated in wrong fields
    in the bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to persist the edited `User` instance, we need to add an `EditorSaveListener`,
    which, conveniently, is a functional interface. We add this listener using the
    `addSaveListener` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `save` method can be simply implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Adding Bean Validation with JSR-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSR-303 is the specification for **Java Bean Validation**. It makes it possible
    to use annotations such as `@NotNull`, `@Email`, and `@Size` to indicate constraints
    in a Java Bean. Java Bean Validation is a specification and there are several
    implementations for it, two of the most popular ones being **Hibernate Validation**
    and *Apache Bean Validation*. Since we are already using Hibernate in this chapter''s
    example, it makes sense to use Hibernate Validation as well. This is done by adding
    the `hibernate-validator` dependency in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can use the annotations available in the `javax.validation.constraints`
    package in the `User` class. The following code adds *not-null* constraints to
    the `firstName`, `lastName`, and `password` fields, an *email-format* constraint
    to the `email` field, and a *size* (or length) constraint to the `password` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make it work with the `Editor`, we need to add `BeanValidators`
    to its `Binder`. The following snippet of code shows how to add it to the First
    Name column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we also called `withNullRepresentation`. This allows us to use an
    empty `String` on the client side, and interpret them as null values on the server
    side. The `BeanValidator` implementation is provided by the framework, and will
    take care of running validations for each JavaBean Validation annotation in the
    `User` class.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, you have to specify the name of the property as a `String` literal,
    which is not type-safe, and might lead to problems if you forget to update it
    when you refactor the name of the property. On the other hand, modern IDEs are
    capable of suggesting such changes when you use the tools for refactoring Java
    identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same approach to configure the `Editor` for the rest of the
    columns in the `Grid`.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, try implementing the `add` operation by creating a button to
    add a new empty row. When the button is clicked, you can create and persist a
    new `User` (you will have to set default values for the `firstName`, `lastName`,
    and `password` fields of the `User` class), refresh the `Grid`, and open the editor
    for the new `User` using the `grid.getEditor().editRow(rowIndex)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a CRUD using Grids and forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll develop a CRUD user interface using modal pop-up windows
    to show a form for adding and editing `User` instances. The following is a screenshot
    of the finished form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d395e297-9851-40f4-9c87-9285f41a0285.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things to take notice of here. We are using the `Grid(Class<T>
    beanType)` constructor, which means columns are created automatically, and we''ll
    be able to reference them later by name. We are using the `VaadinIcons` class
    to set icons instead of text for the refresh (read), add, and update buttons.
    This class is included in the Vaadin Framework. Finally, we are using a `CssLayout`
    with the `LAYOUT_COMPONENT_GROUP` style, which makes the buttons look like a toolbar.
    The following is a screenshot of the component at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8903e5b-b814-4ae9-80be-64cb58039c36.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the read operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can start by configuring the columns we actually want to show in the `Grid`.
    Since the columns were automatically created by the constructor, we can set their
    visibility by name using the `setColumns` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to the previous editable `Grid`, we don't need the *Password* column
    here, since we are not using an `Editor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can continue by adding a click listener to the `refresh` button, and implementing
    the `refresh` method. This is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a new `updateHeader` method to enable or disable the `edit` button
    depending on the selection state in the `Grid`. It makes sense to have the `edit`
    button enabled only when there's a row selected. We need to call this method when
    we refresh the list and when the value selected in the `Grid` changes (see the
    `Grid.addValueChangeListener` method).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the create and update operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *create* CRUD operation starts when the user clicks the `add` button. Similarly,
    the *update* CRUD operation starts when the user clicks the `update` button. We
    need the following *infrastructur**e* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When any of the buttons is clicked, we show a `UserFormindow` (implemented
    shortly). For the `add` button, we pass a new `User` instance. For the `update`
    button, we pass the `User` instance selected in the `Grid`. We can implement `UserWindow`
    as an inner class inside `CustomCrud`. We''ll omit the details of the layout configuration,
    and focus on the data binding part. Let''s start with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'All the input fields in the form are members of the `UserFormWindow` class,
    and are added to some sort of layout in the `initLayout` method (not shown). The
    `initBehaviour` method should configure the data binding between the `User` instance
    and the input fields. It also should add behavior to the `cancel` and `save` buttons.
    Let''s think about what''s required before we start coding:'
  prefs: []
  type: TYPE_NORMAL
- en: We need data-binding. In the Vaadin Framework, that usually means using a `Binder`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to bind the fields in the `UserFormWindow` class to the fields in the
    `User` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to make sure that the input fields show the correct values initially.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to make sure that the values in the input fields are written in the
    `User` instance when the save button is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to make sure no values are written in the `User` instance when the cancel
    button is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can start coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Two important things happen in the previous code: one) all the Java fields
    that are also input fields in the `UserFormWindow` class are bound to the Java
    fields in the `User` class (with the `bindIntanceFields` call); and two), all
    the values in the Java fields of the `User` class are set to the corresponding
    input fields in the `UserFormWindow` class (with the `readBean` call).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the following code adds the behavior to the buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The listener on the `cancel` button only has to call `Window.close()` (inherited).
    The listener on the `save` button calls `writeBean` in order to write the values
    in the input fields in the `user` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `writeBean` throws a `ValidationException`. There are no validations
    at the moment, though. Adding the JavaBean Validation constraints we have in the
    `User` class is as simple as changing the `Binder` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the delete operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement the *delete* CRUD operation using a different approach. Instead
    of simply adding one single button for the operation, we''ll add a delete button
    on each row in the `Grid`. The simplest way of adding a UI component inside a
    `Grid` is by using the `addComponentColumn` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `addComponentColumn` method accepts a `ValueProvider` used to get a UI component.
    The constructor used to create the `Button` accepts a click listener that, in
    turn, calls the `showRemoveWindow` method, passing the `User` instance corresponding
    to the row where the button resides. The actual implementation of the `RemoveWindow`
    class is left as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The `addComponentColumn` method is a shortcut to `addColumn(user -> new Button("Delete",
    e -> deleteClicked(user)), new ComponentRenderer())`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Crud UI add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to its open source nature, there are hundreds of third-party components
    and utilities published available at: [https://vaadin.com/directory](https://vaadin.com/directory).
    One of them does almost all the work we have done in this chapter. The following
    class shows how to implement a CRUD user interface using the `Crud UI add-on`
    available at [https://vaadin.com/directory/component/crud-ui-add-on](https://vaadin.com/directory/component/crud-ui-add-on),
    which is maintained by the author of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The add-on offers several configuration options, such as the possibility to
    configure a layout, set field providers, and use JavaBean Validation. It also
    delegates the CRUD operations to your own code, allowing you to use any kind of
    Java backend technology. The following is a screenshot of the CRUD component created
    with the Crud UI add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09d24af9-0ffb-409c-bc9d-cfffc25b8d59.png)'
  prefs: []
  type: TYPE_IMG
- en: Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filtering can be implemented by adding UI components such as a `TextField`
    and a `ComoboBox` with value listeners on them. When the user changes the filtering
    components, the value listeners update the data by passing their values to the
    backend and updating the view accordingly. For example, in order to filter by
    last name, the `UserRepository.findAll` method should accept a string with the
    value to match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Always keep in mind that `findAll` methods are useful and safe to use when they
    return a small number of results. When this is not the case, you should add *lazy
    loading* capabilities like the ones discussed in [Chapter 9](a297744e-ca27-423b-96a2-b28326405871.xhtml),
    *Lazy Loading*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming there is a `lastNameFilter` input component (of type `TextField`,
    for example), the `Grid` should be populated using the new method, and passing
    the value in the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to implement *generic* CRUD user interfaces.
    We studied three different UI designs for CRUD user interfaces: in-place fields,
    modal pop-up windows, and hierarchical menus. We learned about Project Lombok,
    which allows us to reduce the amount of boilerplate code needed in Java programs,
    and we implemented a domain model using JPA and JavaBean Validation constraints.
    We also covered data binding with the `Binder` class, `Grid` renderers, and filtering.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll explore another interesting topic that is useful
    in many business applications: generating and visualizing reports.'
  prefs: []
  type: TYPE_NORMAL
