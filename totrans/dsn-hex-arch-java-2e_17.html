<html><head></head><body>
<div id="_idContainer096">
<h1 class="chapter-number" id="_idParaDest-280"><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.1.1">17</span></h1>
<h1 id="_idParaDest-281"><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.2.1">Good Design Practices for Your Hexagonal Application</span></h1>
<p><span class="koboSpan" id="kobo.3.1">While exploring the hexagonal architecture in this book, we learned about some of the principles and techniques that characterize a hexagonal application. </span><span class="koboSpan" id="kobo.3.2">By visualizing a system with clearly defined boundaries, we established three hexagons: Domain, Application, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and Framework.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Using these hexagons as a guide, we explored how to separate the business code from the technology code. </span><span class="koboSpan" id="kobo.5.2">This separation allowed us to explore ways of creating change-tolerant systems. </span><span class="koboSpan" id="kobo.5.3">But we did not stop there. </span><span class="koboSpan" id="kobo.5.4">Going the extra mile, we learned how the Quarkus framework could be used to turn a hexagonal application into a </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">cloud-native application.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We have reached the end of this book equipped with the fundamental ideas needed to create hexagonal systems. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we will explore some helpful design practices we can apply when creating robust </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">hexagonal applications.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we’ll cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Using </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">DDD</span></strong><span class="koboSpan" id="kobo.15.1">) to shape the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Domain hexagon</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">The need for creating ports and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">use cases</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Dealing with multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">adapter categories</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Conclusion – the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">hexagonal journey</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.23.1">By the end of this chapter, you’ll be aware of the design practices that can make your hexagonal architecture project more robust. </span><span class="koboSpan" id="kobo.23.2">These practices will also help you to decide when and how to employ the hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">architecture principles.</span></span></p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">To compile and run the code examples presented in this chapter, you need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.28.1">  and </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.30.1"> installed on your computer. </span><span class="koboSpan" id="kobo.30.2">They are both available for the </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Linux</span></strong><span class="koboSpan" id="kobo.32.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Mac</span></strong><span class="koboSpan" id="kobo.34.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Windows</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.36.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">You can find the code files for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">on GitHub:</span></span></p>
<p><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter17"><span class="No-Break"><span class="koboSpan" id="kobo.39.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter17</span></span></a></p>
<h1 id="_idParaDest-283"><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.40.1">Using Domain-Driven Design to shape the Domain hexagon</span></h1>
<p><span class="koboSpan" id="kobo.41.1">When employing the hexagonal architecture to design a system’s code structure, we cannot stress enough how important it is to first implement the Domain hexagon. </span><span class="koboSpan" id="kobo.41.2">It’s the Domain hexagon that sets the tone for the development of the </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">entire application.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">As long as you keep the code in the Domain hexagon that purely expresses the problem domain—the code</span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.44.1"> that does not merge business concerns with technology ones—you are on the right path to ensuring the encapsulation level that favors a more change-tolerant design. </span><span class="koboSpan" id="kobo.44.2">The technique</span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.45.1"> you’ll use to develop the Domain hexagon should not be your main concern at this stage—instead, your aim should be to create a Domain hexagon that is focused on the system’s purpose, rather than the technology you might use to implement it. </span><span class="koboSpan" id="kobo.45.2">So, you can develop the Domain hexagon using your own set of principles, or you can borrow ideas from others who have addressed a similar </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">problem previously.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The advantage of using DDD is that it means you don’t need to reinvent the wheel. </span><span class="koboSpan" id="kobo.47.2">Most—if not all—of the concepts and principles that you need to model your problem domain are well established in the rich body of knowledge present in DDD techniques. </span><span class="koboSpan" id="kobo.47.3">However, this does not mean you must follow all DDD principles to the letter. </span><span class="koboSpan" id="kobo.47.4">The recommended approach is to adopt and adapt the things you find helpful for </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">your project.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Next, we’ll explore some of the approaches you can follow when using DDD to design the </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">Domain hexagon.</span></span></p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.51.1">Understanding the business we are in</span></h2>
<p><span class="koboSpan" id="kobo.52.1">A good application design reflects a good understanding of the business it is intended to serve. </span><span class="koboSpan" id="kobo.52.2">The design journey does not start in the code but by seeking business knowledge. </span><span class="koboSpan" id="kobo.52.3">I’m not</span><a id="_idIndexMarker1080"/><span class="koboSpan" id="kobo.53.1"> telling you to become a business expert in the field you intend to build software for. </span><span class="koboSpan" id="kobo.53.2">However, I think it’s important to understand the fundamentals because if you don’t, mistakes made at the start of the design phase can cause irreversible damage that will extend through the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">software project.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">In the best scenario, the project can survive these early mistakes, but not without paying the high cost of tangled and hard-to-maintain software. </span><span class="koboSpan" id="kobo.55.2">In the worst scenario, the result is unusable software, and starting a new project from scratch is the best thing </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">to do.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Understanding the business fundamentals is the first thing we should do. </span><span class="koboSpan" id="kobo.57.2">The business details are important too, and we should pay close attention to them if we want to make top-notch software. </span><span class="koboSpan" id="kobo.57.3">But mistakes relating to details aren’t as serious as mistakes relating to fundamentals. </span><span class="koboSpan" id="kobo.57.4">The former is generally easier and cheaper to fix than </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the latter.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Let’s revisit the topology and inventory system for a moment. </span><span class="koboSpan" id="kobo.59.2">We have a business rule stating that only edge routers from the same country can be connected to each other. </span><span class="koboSpan" id="kobo.59.3">We use the edge routers to handle regional traffic because they have less traffic capacity than core routers. </span><span class="koboSpan" id="kobo.59.4">The core routers can be located in different countries because they have more </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">traffic capacity.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">The whole domain model has been built based on these business premises. </span><span class="koboSpan" id="kobo.61.2">We compromise the entire system development if we fail to understand and translate these business premises into a cohesive domain model. </span><span class="koboSpan" id="kobo.61.3">Everything we build on top of such a model will be based on weak or wrong assumptions. </span><span class="koboSpan" id="kobo.61.4">That’s why we need to spend whatever time is necessary to grasp the </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">business fundamentals.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Now, let’s see some of the techniques we can use to build </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">business knowledge.</span></span></p>
<h3><span class="koboSpan" id="kobo.65.1">Business Model Canvas</span></h3>
<p><span class="koboSpan" id="kobo.66.1">An excellent exercise to understand how the business works can be done</span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.67.1"> with the Business Model Canvas technique. </span><span class="koboSpan" id="kobo.67.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">Business Model Canvas</span></strong><span class="koboSpan" id="kobo.69.1"> is a tool for </span><a id="_idIndexMarker1082"/><span class="koboSpan" id="kobo.70.1">creating business models. </span><span class="koboSpan" id="kobo.70.2">It provides instruments to analyze and understand the main elements of a business. </span><span class="koboSpan" id="kobo.70.3">By providing a structured and simplified way to identify a business’s main aspects, the Business Model Canvas can be the starting point to draw the big picture you and your team need to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">business fundamentals.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">The </span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.73.1">tool’s main benefit is its focus on the key elements that are crucial for the profitability of a business. </span><span class="koboSpan" id="kobo.73.2">Another helpful </span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.74.1">aspect is how it represents customers and partners in the overall business landscape. </span><span class="koboSpan" id="kobo.74.2">This helps us to understand how well the business model is fulfilling the expectations of both customers </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">and partners.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">A disadvantage is that it does not provide a deep and comprehensive view of how a business should operate to produce good results. </span><span class="koboSpan" id="kobo.76.2">Also, it does not touch on the business strategy. </span><span class="koboSpan" id="kobo.76.3">Much of its emphasis is on end results instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">long-term goals.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">There is a variation of—and an alternative to—the Business Model Canvas called the </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">Lean Canvas</span></strong><span class="koboSpan" id="kobo.80.1">, which is more directed toward start-ups. </span><span class="koboSpan" id="kobo.80.2">The main difference with this approach</span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.81.1"> is that it focuses on the high uncertainty level that start-ups face when they try to develop new ideas </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">and products.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">Here is an</span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.84.1"> illustration of the Business </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">Model Canvas:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.86.1"><img alt="Figure 17.1 – The Business Model Canvas" src="image/B19777_17_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.87.1">Figure 17.1 – The Business Model Canvas</span></p>
<p><span class="koboSpan" id="kobo.88.1">As we can see in the preceding figure, the Business Model Canvas lets us structure each business aspect in distinct parts. </span><span class="koboSpan" id="kobo.88.2">This separation helps us to visualize the main elements comprising the business. </span><span class="koboSpan" id="kobo.88.3">Here are the elements of the Business </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">Model Canvas:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.90.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">Key Partners</span></strong><span class="koboSpan" id="kobo.92.1"> element represents our key partners and suppliers and contains information about the key resources or activities that are involved in </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">that relationship</span></span></li>
<li><span class="koboSpan" id="kobo.94.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">Key Activities</span></strong><span class="koboSpan" id="kobo.96.1">, we state the value propositions required for the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">key activities</span></span></li>
<li><span class="koboSpan" id="kobo.98.1">For </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">Key Resources</span></strong><span class="koboSpan" id="kobo.100.1">, we need to identify the value propositions required to enable the </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">key resources</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">Value Propositions</span></strong><span class="koboSpan" id="kobo.104.1">, we describe the elements of value we intend to deliver to </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">the customer</span></span></li>
<li><span class="koboSpan" id="kobo.106.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">Customer Relationships</span></strong><span class="koboSpan" id="kobo.108.1"> element is about the expectations of each customer segment in establishing and maintaining a relationship </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">with us</span></span></li>
<li><span class="koboSpan" id="kobo.110.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">Channels</span></strong><span class="koboSpan" id="kobo.112.1">, we identify the communication channels through which our customer</span><a id="_idIndexMarker1087"/><span class="koboSpan" id="kobo.113.1"> segments will </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">reach us</span></span></li>
<li><span class="koboSpan" id="kobo.115.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">Customer Segments</span></strong><span class="koboSpan" id="kobo.117.1"> element represents the groups of people we want to deliver </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">value to</span></span></li>
<li><span class="koboSpan" id="kobo.119.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Cost Structure</span></strong><span class="koboSpan" id="kobo.121.1"> element describes the highest costs involved in enabling the </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">business model</span></span></li>
<li><span class="koboSpan" id="kobo.123.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">Revenue Streams</span></strong><span class="koboSpan" id="kobo.125.1"> element shows the value our customers are really willing to </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">pay for</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.127.1">In addition to the Business Model Canvas, we also have the Event Storming technique as an alternative, which is geared more toward DDD projects. </span><span class="koboSpan" id="kobo.127.2">Let’s examine </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">it now.</span></span></p>
<h3><span class="koboSpan" id="kobo.129.1">Event storming</span></h3>
<p><span class="koboSpan" id="kobo.130.1">If you do not find the Business Model Canvas</span><a id="_idIndexMarker1088"/><span class="koboSpan" id="kobo.131.1"> a suitable approach, another technique called </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">event storming</span></strong><span class="koboSpan" id="kobo.133.1"> can help you understand your business needs. </span><span class="koboSpan" id="kobo.133.2">Created by Alberto Brandolini, event storming uses colored sticky notes to map business elements into domain events, commands, actors, and aggregates. </span><span class="koboSpan" id="kobo.133.3">Each </span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.134.1">one of these sticky note elements has its own color, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">following flowchart:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.136.1"><img alt="Figure 17.2 – The Event Storming technique" src="image/B19777_17_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.137.1">Figure 17.2 – The Event Storming technique</span></p>
<p><span class="koboSpan" id="kobo.138.1">As we can see in the preceding diagram, the sticky notes from event storming use the same terminology we encounter when dealing with DDD. </span><span class="koboSpan" id="kobo.138.2">That’s because event storming was created especially for those who use DDD and need to understand the business requirements for </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">their project.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">The event storming sessions should be conducted by developers, domain experts, and a facilitator who coordinates the session to ensure the mapping efforts go in the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">right direction.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">The starting point of an event storming session is usually a challenging business process to model. </span><span class="koboSpan" id="kobo.142.2">In these sessions, it’s common to discuss how actors and their actions influence the business processes. </span><span class="koboSpan" id="kobo.142.3">Another central point is how external systems support and interact with the business processes. </span><span class="koboSpan" id="kobo.142.4">Risks and pain points are also essential subjects to map to identify business-critical areas. </span><span class="koboSpan" id="kobo.142.5">To learn more about event storming, check </span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.143.1">out its website </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">at </span></span><a href="https://www.eventstorming.com"><span class="No-Break"><span class="koboSpan" id="kobo.145.1">https://www.eventstorming.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.146.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Once we understand how the business works, we need to translate that knowledge into a domain model. </span><span class="koboSpan" id="kobo.147.2">In the next section, we’ll see how collaboration can help us to increase our knowledge about </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">the business.</span></span></p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.149.1">Promoting collaboration to increase knowledge</span></h2>
<p><span class="koboSpan" id="kobo.150.1">The</span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.151.1"> domain model is the outcome of people trying to understand the business and translating that understanding into code. </span><span class="koboSpan" id="kobo.151.2">In order to get the most out of this process, collaboration plays a vital role where the degree of complexity is high and things are hard to accomplish. </span><span class="koboSpan" id="kobo.151.3">To overcome this complexity, we need to establish a collaborative atmosphere where everyone involved in the project can contribute with relevant information that helps to build the big picture. </span><span class="koboSpan" id="kobo.151.4">The collaborative approach helps to ensure that everyone is on the same page regarding the problem domain, leading to a domain model that better reflects the </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">business concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">Aside from using the code itself to capture and convey the problem domain knowledge, written documentation is another useful tool for collaboration. </span><span class="koboSpan" id="kobo.153.2">I’m not talking about writing long and comprehensive documentation – I mean the opposite. </span><span class="koboSpan" id="kobo.153.3">Let </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">me explain.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">Concise documentation that is focused on explaining the building blocks of a system can help people who aren’t acquainted with the code to make their first steps into understanding the system and, consequently, the problem domain. </span><span class="koboSpan" id="kobo.155.2">Sometimes, an introduction to the system’s main elements quickly leads to a comprehensive understanding of the </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">problem domain.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">What I’m saying may seem obvious, but very often, I’ve stumbled upon a complex code base with poor or no documentation at all. </span><span class="koboSpan" id="kobo.157.2">When the problem domain is complex, it’s natural for the code to be complex too. </span><span class="koboSpan" id="kobo.157.3">Without documentation to explain the basic system, what’s already complicated becomes even harder </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">to grasp.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">I recommend allocating some time at the end of the project to write the system documentation. </span><span class="koboSpan" id="kobo.159.2">New joiners, in particular, will benefit from a friendly document providing an overview of the system’s </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">big picture.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">Now that we know how important it is to have a solid foundation based on an understanding of the business requirements and have discussed the value of collaboration in increasing our knowledge of the problem domain, let’s explore some of the DDD techniques to adopt when building the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">Domain hexagon.</span></span></p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.163.1">Applying DDD techniques to build the Domain hexagon</span></h2>
<p><span class="koboSpan" id="kobo.164.1">In this</span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.165.1"> section, we’ll explore some design practices to help us establish clear boundaries in the hexagonal system. </span><span class="koboSpan" id="kobo.165.2">Complementing what we saw in </span><a href="B19777_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.166.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.167.1">, </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Wrapping Business Rules inside Domain Hexagon</span></em><span class="koboSpan" id="kobo.169.1">, we’ll see the importance of creating subdomains, searching for a ubiquitous </span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.170.1">language, and defining bounded contexts to distinguish the different aspects of the </span><a id="_idTextAnchor355"/><span class="No-Break"><span class="koboSpan" id="kobo.171.1">problem domain.</span></span></p>
<h3><span class="koboSpan" id="kobo.172.1">Subdomains</span></h3>
<p><span class="koboSpan" id="kobo.173.1">The purpose </span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.174.1">of a </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">subdomain</span></strong><span class="koboSpan" id="kobo.176.1"> is to group the elements that support the core domain but cannot be considered elements that express the</span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.177.1"> core domain. </span><span class="koboSpan" id="kobo.177.2">These supporting elements are essential for the activities conducted by the core domain. </span><span class="koboSpan" id="kobo.177.3">Without the supporting elements, the core domain cannot work. </span><span class="koboSpan" id="kobo.177.4">There are also generic subdomains whose purpose is to provide additional capabilities to both core domains and supporting subdomains. </span><span class="koboSpan" id="kobo.177.5">A generic subdomain works as a standalone component that doesn’t depend on things provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">other domains.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">We can say that we have primary activities in the core domain. </span><span class="koboSpan" id="kobo.179.2">And in the subdomain, we have secondary activities that enable the primary ones. </span><span class="koboSpan" id="kobo.179.3">If we blend primary and secondary activities, we’ll end up with a domain model with mixed concerns. </span><span class="koboSpan" id="kobo.179.4">It may not be a big deal for smaller systems, but in larger ones, it can add a considerable complexity that can undermine the productivity of anyone trying to understand the system. </span><span class="koboSpan" id="kobo.179.5">That’s why it’s a good approach to break a domain into subdomains. </span><span class="koboSpan" id="kobo.179.6">We’ll always have a core domain concentrating on the most important part of </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">Let’s use a banking system </span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.182.1">as an example to explore the subdomain idea further. </span><span class="koboSpan" id="kobo.182.2">In such a system, it’s possible to identify the </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">following domains:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.184.1">As a core domain, we have </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">Transactions</span></strong><span class="koboSpan" id="kobo.186.1"> that allow users to receive and </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">send money</span></span></li>
<li><span class="koboSpan" id="kobo.188.1">As supporting subdomains, we may have </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">Loans</span></strong><span class="koboSpan" id="kobo.190.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">Insurances</span></strong><span class="koboSpan" id="kobo.192.1"> that add more capabilities to the system but rely on the </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">Transactions</span></strong><span class="koboSpan" id="kobo.194.1"> core domain to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">such capabilities</span></span></li>
<li><span class="koboSpan" id="kobo.196.1">Finally, we have </span><strong class="bold"><span class="koboSpan" id="kobo.197.1">Authentication</span></strong><span class="koboSpan" id="kobo.198.1"> as a generic subdomain, serving both the core domain and supporting subdomains that require every transaction to </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">be authenticated</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.200.1">The following diagram shows how subdomains relate to the </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">core domain:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.202.1"><img alt="Figure 17.3 – Banking system subdomains" src="image/B19777_17_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.203.1">Figure 17.3 – Banking system subdomains</span></p>
<p><span class="koboSpan" id="kobo.204.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">Transactions</span></strong><span class="koboSpan" id="kobo.206.1"> core </span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.207.1">domain contains the system’s building</span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.208.1"> block elements. </span><span class="koboSpan" id="kobo.208.2">These elements are also present in the </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Loans</span></strong><span class="koboSpan" id="kobo.210.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">Insurances</span></strong><span class="koboSpan" id="kobo.212.1"> subdomains, but for different purposes. </span><span class="koboSpan" id="kobo.212.2">The generic </span><strong class="bold"><span class="koboSpan" id="kobo.213.1">Authentication</span></strong><span class="koboSpan" id="kobo.214.1"> subdomain knows nothing about the other domains. </span><span class="koboSpan" id="kobo.214.2">It only provides an authentication mechanism that is shared across the core domain and </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">supporting subdomains.</span></span></p>
<h3><span class="koboSpan" id="kobo.216.1">Ubiquitous language</span></h3>
<p><span class="koboSpan" id="kobo.217.1">One </span><a id="_idIndexMarker1099"/><span class="koboSpan" id="kobo.218.1">of DDD’s touchstones is</span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.219.1"> its emphasis on how we use language to describe a domain model. </span><span class="koboSpan" id="kobo.219.2">This emphasis aims to avoid the pitfall of ambiguities in our general communication seeping into the system code we want </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">to create.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">As human beings, we have much more capacity than computers to handle ambiguities in language because we can add context to our words. </span><span class="koboSpan" id="kobo.221.2">Computers, on the other hand, don’t have this ability unless we provide it for them. </span><span class="koboSpan" id="kobo.221.3">In order to decrease the ambiguity level of a system, a ubiquitous language seeks precise terminology to describe the things that comprise the </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">domain model.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Defining precise terminology, however, is not enough to ensure that we’ll always convey the right meaning in</span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.224.1"> the domain model, as similar words may have a different meaning depending on the </span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.225.1">context in which they are used. </span><span class="koboSpan" id="kobo.225.2">That’s why there’s another technique in DDD called bounded context that we can use to deal with differences in meaning within a </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">domain model.</span></span></p>
<h3><span class="koboSpan" id="kobo.227.1">Bounded context</span></h3>
<p><span class="koboSpan" id="kobo.228.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">bounded context</span></strong><span class="koboSpan" id="kobo.230.1"> idea</span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.231.1"> is a response to the fact that words have a different meaning depending on the context in which they are used. </span><span class="koboSpan" id="kobo.231.2">When we bring this idea to DDD, we may find that a domain model element can have a different meaning or behave differently depending on the context </span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.232.1">where it’s applied. </span><span class="koboSpan" id="kobo.232.2">If we do not actively take action to explicitly define a context to clarify the meaning of such a domain model element, we are contributing to the ambiguity within </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">For example, take the topology and inventory system. </span><span class="koboSpan" id="kobo.234.2">Suppose that other than inventory capabilities, we want to allow the system to get a real-time status and basic information from routers and other network equipment. </span><span class="koboSpan" id="kobo.234.3">This new feature could result in two contexts: one for inventory and the other </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">for status.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">From the inventory perspective, a router means a static record in a database. </span><span class="koboSpan" id="kobo.236.2">On the other hand, from the status perspective, a router is a </span><em class="italic"><span class="koboSpan" id="kobo.237.1">living</span></em><span class="koboSpan" id="kobo.238.1"> thing that issues real-time data. </span><span class="koboSpan" id="kobo.238.2">By expressing this distinction in the form of a bounded context, we ensure that our understanding of one context does not blur with another. </span><span class="koboSpan" id="kobo.238.3">More than that, by structuring the code within the clear boundaries that a bounded context can provide, we’re creating a system that can evolve and receive changes in a more organized way. </span><span class="koboSpan" id="kobo.238.4">Also, we are enforcing the Single Responsibility Principle at the level of modules. </span><span class="koboSpan" id="kobo.238.5">This means a module should change only for a single reason and not </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">multiple reasons.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">The DDD techniques discussed in this session don’t offer much value if we don’t first grasp our business needs. </span><span class="koboSpan" id="kobo.240.2">That’s why we started by exploring some of the techniques we can use to enhance our understanding of the business model. </span><span class="koboSpan" id="kobo.240.3">Once we know about the business we’re in, we can safely employ the DDD techniques (such as subdomains and bounded contexts) to establish boundaries between different system components and remove ambiguities within the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">domain model.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">So, let’s see how we can implement bounded contexts and subdomains in a </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">hexagonal system.</span></span></p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.244.1">Implementing bounded contexts and subdomains in a hexagonal system</span></h2>
<p><span class="koboSpan" id="kobo.245.1">Our approach to</span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.246.1"> implementing a bounded context relies on the creation of a subdomain. </span><span class="koboSpan" id="kobo.246.2">Here, we discuss both bounded contexts </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">and subdomains.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">Bounded contexts </span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.249.1">can exist with or without a subdomain. </span><span class="koboSpan" id="kobo.249.2">We’ve already seen that the topology and inventory system can check the status of network equipment. </span><span class="koboSpan" id="kobo.249.3">Suppose we determine that the status element is an integral and critical characteristic of the problem domain. </span><span class="koboSpan" id="kobo.249.4">In that case, we can make the status element part of the core domain instead of putting it into a supporting subdomain. </span><span class="koboSpan" id="kobo.249.5">But we’d still need to deal with the ambiguity of having domain elements serving different purposes. </span><span class="koboSpan" id="kobo.249.6">To solve this problem, we’d have to establish two bounded contexts within the core domain: one bounded context for inventory and another </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">for status.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">If we decide that the status element is not a part of the core domain, we can model it as a subdomain, as we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">see next.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">When developing the topology and inventory system, we placed a single domain model inside the Domain hexagon. </span><span class="koboSpan" id="kobo.253.2">This domain model meets the business requirements related to the inventory management of network assets. </span><span class="koboSpan" id="kobo.253.3">Consider the scenario where the topology and inventory system can access network equipment to check its status. </span><span class="koboSpan" id="kobo.253.4">To avoid mixing concerns between inventory management and status information, we’ll break the </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">Domain Hexagon</span></strong><span class="koboSpan" id="kobo.255.1"> into two domain models. </span><span class="koboSpan" id="kobo.255.2">The first one is a </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">Core Domain</span></strong><span class="koboSpan" id="kobo.257.1"> serving inventory management needs. </span><span class="koboSpan" id="kobo.257.2">The second domain model is a </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">Subdomain</span></strong><span class="koboSpan" id="kobo.259.1"> for status information needs. </span><span class="koboSpan" id="kobo.259.2">The following diagram shows the representation of the new </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.260.1">Domain Hexagon</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.262.1"><img alt="Figure 15.4 – The Domain Hexagon" src="image/B19777_17_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.263.1">Figure 15.4 – The Domain Hexagon</span></p>
<p><span class="koboSpan" id="kobo.264.1">Inside the </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">Domain Hexagon</span></strong><span class="koboSpan" id="kobo.266.1">, we now have the </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">Inventory Core Domain</span></strong><span class="koboSpan" id="kobo.268.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">Status Subdomain</span></strong><span class="koboSpan" id="kobo.270.1">. </span><span class="koboSpan" id="kobo.270.2">In the following</span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.271.1"> steps, we’ll configure the Domain hexagon module to reflect the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">new structure:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.273.1">In the project’s root </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">pom.xml</span></strong><span class="koboSpan" id="kobo.275.1"> file, we add the new Maven </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">modules</span></strong><span class="koboSpan" id="kobo.277.1"> element, which represents the core domain </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">and subdomains:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.279.1">
&lt;modules&gt;
  &lt;module&gt;domain&lt;/module&gt;
  &lt;module&gt;domain/inventory-core-domain&lt;/module&gt;
  &lt;module&gt;domain/status-sub-domain&lt;/module&gt;
  &lt;module&gt;application&lt;/module&gt;
  &lt;module&gt;framework&lt;/module&gt;
  &lt;module&gt;bootstrap&lt;/module&gt;
&lt;/modules&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.280.1">Note, we added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">domain/inventory-core-domain</span></strong><span class="koboSpan" id="kobo.282.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">domain/status-sub-domain</span></strong><span class="koboSpan" id="kobo.284.1"> Maven modules in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">pom.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1"> file.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.287.1">Before proceeding, please ensure to move all the files from </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">domain/src/main/java</span></strong><span class="koboSpan" id="kobo.289.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">domain/inventory-core-domain/src/main/java</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">domain</span></strong><span class="koboSpan" id="kobo.293.1"> Maven module will be used as a parent project to aggregate both the core domain and </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">subdomain projects.</span></span></p></li> <li><span class="koboSpan" id="kobo.295.1">Next, we’ll configure</span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.296.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">pom.xml</span></strong><span class="koboSpan" id="kobo.298.1"> file from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">domain</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.300.1">Maven module:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.301.1">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;!-- Code omitted --&gt;
  &lt;artifactId&gt;domain&lt;/artifactId&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dev.davivieira&lt;/groupId&gt;
      &lt;artifactId&gt;inventory-core-domain&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dev.davivieira&lt;/groupId&gt;
      &lt;artifactId&gt;status-sub-domain&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.302.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">domain</span></strong><span class="koboSpan" id="kobo.304.1"> Maven module depends on </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">inventory-core-domain</span></strong><span class="koboSpan" id="kobo.306.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">status-sub-domain</span></strong><span class="koboSpan" id="kobo.308.1">. </span><span class="koboSpan" id="kobo.308.2">We kept the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">domain</span></strong><span class="koboSpan" id="kobo.310.1"> module but broke it into two parts. </span><span class="koboSpan" id="kobo.310.2">With this approach, there will be no need to change anything in the Application and </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">Framework hexagons.</span></span></p></li> <li><span class="koboSpan" id="kobo.312.1">We also need to reconfigure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">module-info.java</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.314.1">module descriptor:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.315.1">
module domain {
    requires transitive inventory_core_domain;
    requires transitive status_sub_domain;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.316.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">transitive</span></strong><span class="koboSpan" id="kobo.318.1"> keyword is necessary to ensure the exports from </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">inventory_core_domain</span></strong><span class="koboSpan" id="kobo.320.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">status_sub_domain</span></strong><span class="koboSpan" id="kobo.322.1"> are visible for other modules</span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.323.1"> depending on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">domain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1"> module.</span></span></p></li> <li><span class="koboSpan" id="kobo.326.1">Next, we configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">pom.xml</span></strong><span class="koboSpan" id="kobo.328.1"> file for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">inventory-core-domain</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.330.1">Maven module:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.331.1">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;!-- Code omitted --&gt;
  &lt;parent&gt;
    &lt;groupId&gt;dev.davivieira&lt;/groupId&gt;
    &lt;artifactId&gt;topology-inventory&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;inventory-core-domain&lt;/artifactId&gt;
&lt;/project&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.332.1">The preceding example is a straightforward </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">pom.xml</span></strong><span class="koboSpan" id="kobo.334.1"> file containing only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">artifactId</span></strong><span class="koboSpan" id="kobo.336.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">parent</span></strong><span class="koboSpan" id="kobo.338.1"> coordinates. </span><span class="koboSpan" id="kobo.338.2">In addition to </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">pom.xml</span></strong><span class="koboSpan" id="kobo.340.1">, we need to provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">module-info.java</span></strong><span class="koboSpan" id="kobo.342.1"> file, as </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">shown here:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.344.1">module inventory_core_domain {
    exports
      dev.davivieira.topologyinventory.domain.entity;
    exports
      dev.davivieira.topologyinventory.domain.service;
    exports
      dev.davivieira.topologyinventory.domain
      .specification;
    exports
      dev.davivieira.topologyinventory.domain.vo;
    exports
      dev.davivieira.topologyinventory.domain.entity
      .factory;
    requires static lombok;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.345.1">This Java module provides better encapsulation for the inventory core domain. </span><span class="koboSpan" id="kobo.345.2">Note that we’re also</span><a id="_idIndexMarker1110"/><span class="koboSpan" id="kobo.346.1"> exporting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">entity</span></strong><span class="koboSpan" id="kobo.348.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">service</span></strong><span class="koboSpan" id="kobo.350.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">specification</span></strong><span class="koboSpan" id="kobo.352.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">vo</span></strong><span class="koboSpan" id="kobo.354.1"> packages. </span><span class="koboSpan" id="kobo.354.2">They are all part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">core domain.</span></span></p></li> <li><span class="koboSpan" id="kobo.356.1">Next, we configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">pom.xml</span></strong><span class="koboSpan" id="kobo.358.1"> file of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">status-sub-domain</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.360.1">Maven module:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.361.1">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;!-- Code omitted --&gt;
  &lt;artifactId&gt;status-sub-domain&lt;/artifactId&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dev.davivieira&lt;/groupId&gt;
      &lt;artifactId&gt;inventory-core-domain&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.362.1">We declare a dependency on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">inventory-core-domain</span></strong><span class="koboSpan" id="kobo.364.1"> Maven module because we use the same entities present in the core domain to provide status information capabilities in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">status-sub-domain</span></strong><span class="koboSpan" id="kobo.366.1"> subdomain Maven module. </span><span class="koboSpan" id="kobo.366.2">The difference, though, is that the same entity, in the same way as </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">Router</span></strong><span class="koboSpan" id="kobo.368.1">, can have a different meaning (and also a data model) when we are in the status </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">information context.</span></span></p></li> <li><span class="koboSpan" id="kobo.370.1">To finish, we need</span><a id="_idIndexMarker1111"/><span class="koboSpan" id="kobo.371.1"> to configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">module-info.java</span></strong><span class="koboSpan" id="kobo.373.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">status_sub_domain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.377.1">
module status_sub_domain {
   exports dev.davivieira.topologyinventory.status;
   requires inventory_core_domain;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.378.1">We’re exporting only one package and declaring that this module depends </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">inventory_core_domain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.382.1">Now that we have the Maven and Java modules properly configured to help us enforce the boundaries between the core domain and subdomain, let’s explore the use of a </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">bounded context.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.384.1">Let’s consider that the topology and inventory system can now check the status of a router. </span><span class="koboSpan" id="kobo.384.2">To isolate this behavior and establish a context for such activities, we will create a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">RouterInfo</span></strong><span class="koboSpan" id="kobo.386.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">the subdomain:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
package dev.davivieira.topologyinventory.status;
import dev.davivieira.topologyinventory.domain.entity.factory.RouterFactory;
import dev.davivieira.topologyinventory.domain.vo.IP;
import dev.davivieira.topologyinventory.domain.vo.Id;
import dev.davivieira.topologyinventory.domain.vo.Model;
import dev.davivieira.topologyinventory.domain.vo.RouterType;
import dev.davivieira.topologyinventory.domain.vo.Vendor;
public class RouterInfo {
    public String getRouterStatus () {
        var router = RouterFactory.getRouter(
                Id.withoutId(),
                Vendor.CISCO,
                Model.XYZ0004,
                IP.fromAddress("55.0.0.1"),
                null,
                RouterType.CORE);
        return "Router with "+router.getIp()+" is alive!";
    }
}</span></pre> <p><span class="koboSpan" id="kobo.389.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">RouterInfo</span></strong><span class="koboSpan" id="kobo.391.1"> class, we have a dummy</span><a id="_idIndexMarker1112"/><span class="koboSpan" id="kobo.392.1"> method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">getRouterStatus</span></strong><span class="koboSpan" id="kobo.394.1">, which is just to illustrate that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">Router</span></strong><span class="koboSpan" id="kobo.396.1"> entity can assume a different behavior and data model in the context of status information. </span><span class="koboSpan" id="kobo.396.2">It’s very simple to make this subdomain feature available for the Application and </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">Framework hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">Let’s do that to see how the subdomain</span><a id="_idIndexMarker1113"/><span class="koboSpan" id="kobo.399.1"> fits into the overall hexagonal system by executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.401.1">We start by adding a new method definition </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.405.1">
public interface RouterManagementUseCase {
    /** Code omitted **/
    String getRouterStatus();
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.406.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">getRouterStatus</span></strong><span class="koboSpan" id="kobo.408.1"> method integrates with the subdomain to retrieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">router status.</span></span></p></li> <li><span class="koboSpan" id="kobo.410.1">Next, we implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">getRouterStatus</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.412.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">RouterManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.415.1">
@Override
public String getRouterStatus() {
    var routerInfo = new RouterInfo();
    return routerInfo.getRouterStatus();
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.416.1">Here, we are getting an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">RouterInfo</span></strong><span class="koboSpan" id="kobo.418.1"> object from the subdomain and calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">getRouterStatus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.420.1"> method.</span></span></p></li> <li><span class="koboSpan" id="kobo.421.1">Finally, we implement the endpoint </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">RouterManagementAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.425.1">
@Transactional
@GET
@Path("/get-router-status")
@Operation(operationId = "g</span><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.426.1">etRouterStatus", description = "Get router status")
@Produces(MediaType.TEXT_PLAIN)
public Uni&lt;Response&gt; getRouterStatus() {
    return Uni.createFrom()
            .item(routerManagementUseCase
            .getRouterStatus())
            .onItem()
            .transform(
              router -&gt; router != null ?
</span><span class="koboSpan" id="kobo.426.2">              Response.ok(router) :
              Response.ok(null))
            .onItem()
            .transform(Re</span><a id="_idTextAnchor358"/><span class="koboSpan" id="kobo.427.1">sponse.ResponseBuilder::build);
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.428.1">Here, we are using the RESTEasy Reactive</span><a id="_idIndexMarker1114"/><span class="koboSpan" id="kobo.429.1"> to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">/get-router-status</span></strong><span class="koboSpan" id="kobo.431.1"> endpoint that will get the router status information from </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">the subdomain:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.433.1">
$ curl -X GET http://localhost:8080/router/get-router-status</span></pre> <p><span class="koboSpan" id="kobo.434.1">Running the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">curl</span></strong><span class="koboSpan" id="kobo.436.1"> command gives us the </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.438.1">
Router with IP(ipAddress=55.0.0.1, protocol=IPV4) is alive!</span></pre> <p><span class="koboSpan" id="kobo.439.1">This implementation of DDD elements such as subdomains and bounded contexts helps us understand how we can integrate these elements with the hexagonal architecture. </span><span class="koboSpan" id="kobo.439.2">Using Maven and Java modules, we can emphasize the boundaries between the core domain and subdomain </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">even more.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Now, let’s shift our attention to the Application hexagon, which is the realm of ports and </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">use cases.</span></span></p>
<h1 id="_idParaDest-288"><a id="_idTextAnchor359"/><span class="koboSpan" id="kobo.443.1">The need for creating ports and use cases</span></h1>
<p><span class="koboSpan" id="kobo.444.1">After </span><a id="_idIndexMarker1115"/><span class="koboSpan" id="kobo.445.1">putting some effort into modeling the problem domain in the Domain hexagon, the next step is to move on to the Application hexagon and define how the system enables the behaviors that fulfills the</span><a id="_idIndexMarker1116"/><span class="koboSpan" id="kobo.446.1"> business-related operations that come from the Domain hexagon. </span><span class="koboSpan" id="kobo.446.2">Actors—who could be both users and other systems—drive these behaviors. </span><span class="koboSpan" id="kobo.446.3">They dictate the </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">system’s capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">The moment when we start implementing the Application hexagon is crucial because we begin to think in aspects that are not directly related to the domain model. </span><span class="koboSpan" id="kobo.448.2">Instead, these aspects may be related to integrations for communicating with other systems. </span><span class="koboSpan" id="kobo.448.3">But we shouldn’t go so far as to decide which technologies to use. </span><span class="koboSpan" id="kobo.448.4">We don’t take decisions related to technology when implementing the Application hexagon. </span><span class="koboSpan" id="kobo.448.5">Rather, technology concerns are a subject that we go deep into in the </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">Framework hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">We employ use cases to define what a system can do to meet actors’ needs. </span><span class="koboSpan" id="kobo.450.2">Without considering specific technical details, we can state that a good moment to create a use case is when we need to express an actor’s intent on the system. </span><span class="koboSpan" id="kobo.450.3">The actor’s intent plays a fundamental role in shaping the system’s behaviors. </span><span class="koboSpan" id="kobo.450.4">By employing use cases, we can describe such behaviors. </span><span class="koboSpan" id="kobo.450.5">Input ports come next by defining how the system will actually accomplish the actor’s goals. </span><span class="koboSpan" id="kobo.450.6">Input ports can be implemented right away or be implemented later. </span><span class="koboSpan" id="kobo.450.7">However, they must be implemented before you decide to move on to the Framework hexagon. </span><span class="koboSpan" id="kobo.450.8">If you choose to implement the Framework hexagon before implementing input ports, there will be no way to make the Framework hexagon communicate with the Application hexagon. </span><span class="koboSpan" id="kobo.450.9">In other words, use cases and ports are the bridge between </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">both hexagons.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">There is not much to be concerned about when it comes to output ports because they are interfaces implemented by output adapters in the Framework hexagon. </span><span class="koboSpan" id="kobo.452.2">Output adapters, in their turn, can pose some problems if we have multiple categories of them. </span><span class="koboSpan" id="kobo.452.3">Next, we’ll assess some of the consequences of having multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">adapter categories.</span></span></p>
<h1 id="_idParaDest-289"><a id="_idTextAnchor360"/><span class="koboSpan" id="kobo.454.1">Dealing with multiple adapter categories</span></h1>
<p><span class="koboSpan" id="kobo.455.1">In the</span><a id="_idIndexMarker1117"/><span class="koboSpan" id="kobo.456.1"> context of the hexagonal architecture, adapters help us to increase the hexagonal system’s compatibility with different protocols and technology. </span><span class="koboSpan" id="kobo.456.2">In the Framework hexagon, we finally decide</span><a id="_idIndexMarker1118"/><span class="koboSpan" id="kobo.457.1"> how the system will expose its features through input adapters and how it will communicate with external systems through </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">output adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">In a similar way to what happens in the Application and Domain hexagons, the Framework hexagon is encapsulated in its own Java module. </span><span class="koboSpan" id="kobo.459.2">This module approach helps us enforce the boundaries between each system hexagon. </span><span class="koboSpan" id="kobo.459.3">From the Framework hexagon’s perspective, it’s good to group all input and output adapters within the same module. </span><span class="koboSpan" id="kobo.459.4">Although modularization can help us set boundaries, it is not enough to prevent the maintainability challenges we may face when dealing with multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">adapter categories.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">What I mean by adapter category is a classification to group adapters that enable the integration with a specific technology. </span><span class="koboSpan" id="kobo.461.2">For example, in the topology and inventory system, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">RouterManagementAdapter</span></strong><span class="koboSpan" id="kobo.463.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">SwitchManagementAdapter</span></strong><span class="koboSpan" id="kobo.465.1"> input adapters. </span><span class="koboSpan" id="kobo.465.2">These adapters expose HTTP RESTful endpoints. </span><span class="koboSpan" id="kobo.465.3">So, these input adapters comprise the adapter category that provides HTTP support for the hexagonal system. </span><span class="koboSpan" id="kobo.465.4">If we want to enable integration with another technology, for example, gRPC, we need to create a new set of adapters in an adapter category that supports exposing </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">gRPC endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">When dealing with input adapters, we don’t face a significant maintainability burden by having multiple adapter categories providing support to different technologies in the hexagonal system. </span><span class="koboSpan" id="kobo.467.2">However, some issues may arise if we have multiple adapter categories for </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">output adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">With output adapters, we can integrate the hexagonal application with external systems. </span><span class="koboSpan" id="kobo.469.2">But it’s important to pay attention where we need to provide translation mechanisms for every new integration. </span><span class="koboSpan" id="kobo.469.3">These translations help us to map data coming in and going out through output adapters. </span><span class="koboSpan" id="kobo.469.4">If adapter categories for output adapters grow too large, it can potentially create a maintainability problem. </span><span class="koboSpan" id="kobo.469.5">In that scenario, we would need to keep multiple translation mechanisms for every </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">adapter category.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">Consider the following scenario. </span><span class="koboSpan" id="kobo.471.2">Imagine a system that started out with all of its data being served by a database. </span><span class="koboSpan" id="kobo.471.3">As the main system evolved, the developers migrated its parts into smaller subsystems to prevent the main system from becoming too big. </span><span class="koboSpan" id="kobo.471.4">But during this </span><a id="_idIndexMarker1119"/><span class="koboSpan" id="kobo.472.1">migration process, certain use cases could not be fully migrated to the new subsystems, resulting in a situation where the main system still needed to fetch data from both</span><a id="_idIndexMarker1120"/><span class="koboSpan" id="kobo.473.1"> the database and the subsystems in order to fulfill some of its business rules. </span><span class="koboSpan" id="kobo.473.2">In this circumstance, the main system requires two output adapters: one for the database and another for the subsystem. </span><span class="koboSpan" id="kobo.473.3">Allowing two output adapters to serve the same purpose due to an unfinished migration can potentially increase the maintenance cost. </span><span class="koboSpan" id="kobo.473.4">One of the main problems of this approach is the need to translate the domain model data, which comes from the database and </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">the subsystem.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">So, for input adapters, we have a low risk when employing multiple adapter categories. </span><span class="koboSpan" id="kobo.475.2">However, the same cannot be said about output adapters. </span><span class="koboSpan" id="kobo.475.3">The recommendation here is to be aware of the trade-off in having to maintain several translation mechanisms for multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">output adapters.</span></span></p>
<h1 id="_idParaDest-290"><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.477.1">Conclusion – the hexagonal journey</span></h1>
<p><span class="koboSpan" id="kobo.478.1">One of the </span><a id="_idIndexMarker1121"/><span class="koboSpan" id="kobo.479.1">fascinating things about software development is that we can employ many methods to achieve the same result. </span><span class="koboSpan" id="kobo.479.2">This freedom adds to the fun of software development and fosters creativity. </span><span class="koboSpan" id="kobo.479.3">Creativity is the main force behind clever solutions for complex problems. </span><span class="koboSpan" id="kobo.479.4">That’s why we should always leave space for creativity in any software project. </span><span class="koboSpan" id="kobo.479.5">But when combined with tight schedules and resources, freedom and creativity should be managed to produce valuable software without adding </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">unnecessary complexity.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">I see the hexagonal architecture as an approach that can help us manage these different requirements. </span><span class="koboSpan" id="kobo.481.2">It provides a clear set of principles to organize system code within flexible yet consistent boundaries. </span><span class="koboSpan" id="kobo.481.3">The hexagonal approach offers a model to direct our creative efforts in an organized and – to a certain extent – </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">standardized way.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">The hexagonal architecture is not for everyone, nor is it suitable for every project. </span><span class="koboSpan" id="kobo.483.2">However, people seeking ways to standardize their software development practices will find the hexagonal architecture to be a useful blueprint to scaffold their next software project. </span><span class="koboSpan" id="kobo.483.3">Nevertheless, it’s important to understand the considerable complexity involved in structuring a system using hexagonal principles. </span><span class="koboSpan" id="kobo.483.4">If the project is for a medium or large, long-term, and highly mutable system, I believe the hexagonal architecture is an excellent choice to ensure the system’s maintainability in the long run. </span><span class="koboSpan" id="kobo.483.5">On the other hand, if we’re talking about small applications responsible for, let’s say, one or two things, then using the hexagonal architecture</span><a id="_idIndexMarker1122"/><span class="koboSpan" id="kobo.484.1"> would be like using a gun to kill an ant. </span><span class="koboSpan" id="kobo.484.2">So, you need to carefully assess the scenario to check if the hexagonal architecture will bring more solutions than problems to </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">your project.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">The hexagonal architecture is not a silver bullet that will magically solve your technical debt and maintainability issues. </span><span class="koboSpan" id="kobo.486.2">These problems have more to do with your attitude to keep things simple than with the software architecture you choose to structure your application. </span><span class="koboSpan" id="kobo.486.3">But the hexagonal architecture can help you tackle those issues if you’re already committed to an attitude to keep things simple and easy to understand no matter how complex the problem domain you’re dealing with is. </span><span class="koboSpan" id="kobo.486.4">I encourage you to keep a simple attitude and explore and extend the hexagonal architecture ideas. </span><span class="koboSpan" id="kobo.486.5">For me, it’s been an unending learning and rewarding experience to design hexagonal systems. </span><span class="koboSpan" id="kobo.486.6">I wish the same </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">to you.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">Let me finish this book by sincerely thanking you for accompanying me on this </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">hexagonal journey.</span></span></p>
<h1 id="_idParaDest-291"><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.490.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.491.1">We started this chapter by exploring some ideas relating to DDD, and we discussed the importance of understanding our business needs before jumping straight to development. </span><span class="koboSpan" id="kobo.491.2">We also learned about the Business Model Canvas and </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">event storming.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">While on the topic of DDD, we learned how subdomains and bounded contexts are essential to help establish clear boundaries within the Domain hexagon. </span><span class="koboSpan" id="kobo.493.2">After that, we discussed use cases and ports. </span><span class="koboSpan" id="kobo.493.3">We learned that it’s essential to implement input ports before starting to build the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">Framework hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">Next, we learned about the maintainability consequences of having multiple adapter categories, mainly when dealing with output adapters that require translation mechanisms. </span><span class="koboSpan" id="kobo.495.2">Finally, we ended the book by reflecting on our hexagonal journey and the importance of keeping software </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">development simple.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">When using Quarkus, especially the native image feature, we need to consider the large amount of memory and time required to build a native executable. </span><span class="koboSpan" id="kobo.497.2">If your CI environment is constrained, you may face problems caused by insufficient computational resources. </span><span class="koboSpan" id="kobo.497.3">Also, bear in mind that compilation time considerably increases when compiling native images. </span><span class="koboSpan" id="kobo.497.4">If your priority is faster compilation rather than a more rapid system startup, you may have to reconsider using native images. </span><span class="koboSpan" id="kobo.497.5">I always recommend checking the Quarkus documentation and the Quarkus community through the official mailing list and other channels. </span><span class="koboSpan" id="kobo.497.6">This can help you learn more about Quarkus and stay updated on common issues and how to solve them. </span><span class="koboSpan" id="kobo.497.7">If the community help is not enough, you can seek Quarkus’ official support provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">Red Hat.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">The hexagonal architecture provides us with the principles to develop robust and change-tolerant systems. </span><span class="koboSpan" id="kobo.499.2">Quarkus is a cutting-edge technology that we can use to apply hexagonal principles to create modern, cloud-native applications. </span><span class="koboSpan" id="kobo.499.3">By combining hexagonal architecture with Quarkus, we can produce fantastic software. </span><span class="koboSpan" id="kobo.499.4">I encourage you to experiment and further explore the possibilities of such a fascinating combination. </span><span class="koboSpan" id="kobo.499.5">The hexagonal journey of this book ends here, but you guys can start a new one by applying, tweaking, and evolving the ideas I have presented </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">to you.</span></span></p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor363"/><span class="koboSpan" id="kobo.501.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.502.1">What techniques can we use to understand our </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">business needs?</span></span></li>
<li><span class="koboSpan" id="kobo.504.1">Why should we employ subdomains and </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">bounded contexts?</span></span></li>
<li><span class="koboSpan" id="kobo.506.1">Why is it important to define use cases and create input ports before implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">Framework hexagon?</span></span></li>
<li><span class="koboSpan" id="kobo.508.1">What are the consequences of having multiple adapter categories for </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">output adapters?</span></span></li>
</ol>
<h1 id="_idParaDest-293"><a id="_idTextAnchor364"/><span class="koboSpan" id="kobo.510.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.511.1">The Business Model Canvas and </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">event storming.</span></span></li>
<li><span class="koboSpan" id="kobo.513.1">Subdomains and bounded contexts help us establish clear boundaries to prevent mixing the meaning and concerns of the entities in a </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">domain model.</span></span></li>
<li><span class="koboSpan" id="kobo.515.1">Because use cases and input ports are the bridge between the Framework and </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">Application hexagons.</span></span></li>
<li><span class="koboSpan" id="kobo.517.1">It can lead to several translation mechanisms that may be hard to maintain if we have too many </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">of them.</span></span></li>
</ol>
</div>
</body></html>