<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating JEE Database Applications</h1>
                
            
            <article>
                
<p class="calibre3">In the previous chapter, we learned how to use source control management software from Eclipse. Specifically, we learned how to use SVN and Git from Eclipse. In this chapter, we will get back to discussing JEE application development. <span class="calibre12">Most web applications today require access to the database. In this chapter, we will learn two ways to access databases from JEE web applications: u</span>sing JDBC APIs, and using JPA APIs.</p>
<p class="calibre3">JDBC4 has been part of JDK since version 1.1. It provides uniform APIs to access different relational databases. Between JDBC APIs and the database sits the JDBC driver for that database (either provided by the vendor of the database or a third-party vendor). JDBC translates common API calls to database-specific calls. The results returned from the database are also converted into objects of common data access classes. Although JDBC APIs require you to write a lot more code to access the database, it is still popular in JEE web applications because of its simplicity, flexibility of using database-specific SQL statements, and low learning curve.</p>
<p class="calibre3">JPA is the result of <strong class="calibre5">Java Specification Request</strong> 220 (which stands for <strong class="calibre5">JSR</strong>). One of the problems of using JDBC APIs directly is converting object representation of data to relation data. Object representation is in your JEE application, which needs to be mapped to tables and columns in the relational database. The process is reversed when handling data returned from the relational database. If there is a way to automatically map object-oriented representation of data in web applications to relational data, it would save a lot of developer time. This is also called <strong class="calibre5">object-relational mapping</strong> (<strong class="calibre5">ORM</strong>). Hibernate (<a href="http://hibernate.org/" class="calibre9"><span>http://hibernate.org/</span></a>) is a very popular framework for ORM in Java applications.</p>
<p class="calibre3">Many of the concepts of such popular third-party ORM frameworks were incorporated in JPA. Just as JDBC provides uniform APIs for accessing relational databases, JPA provides uniform APIs for accessing ORM libraries. Third-party ORM frameworks provide implementations of JPA on top of their own framework. The JPA implementation may use the JDBC APIs underneath.</p>
<p class="calibre3">We will explore many features of JDBC and JPA in this chapter as we build applications using these frameworks. In fact, we will build the same application, once using JDBC and then using JPA.</p>
<p class="calibre3">The application that we are going to build is for student-course management. The goal is to take an example that can show how to model relationships between tables and use them in JEE applications. We will use a MySQL database and Tomcat web application container. Although this chapter is about database programming in JEE, we will revisit some of the things we learned about JSTL and JSF in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>. We will use them to create user interfaces for our database web application. Make sure that you have configured Tomcat in Eclipse as described in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>.</p>
<p class="calibre3">We will cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Core JDBC concepts</li>
<li class="calibre11">Using JDBC to access the database</li>
<li class="calibre11">Using JDBC connection pool</li>
<li class="calibre11">Core JPA concepts </li>
<li class="calibre11">Using JPA to map entities (classes) to tables in the database</li>
<li class="calibre11">Configuring relationships between JPA entities</li>
</ul>
<p class="calibre3">Let's first create a database and tables for this application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating database schema</h1>
                
            
            <article>
                
<p class="calibre3">There are many ways of creating database tables and relationships in MySQL:</p>
<ul class="calibre10">
<li class="calibre11">You can use <strong class="calibre1">data description language</strong> (<strong class="calibre1">DDL</strong>) statements directly at MySQL Command Prompt from the Terminal</li>
<li class="calibre11">You can use MySQL Workbench and create tables directly</li>
<li class="calibre11">You can create an entity-relationship diagram in MySQL Workbench, export it to create a DDL script, and then run this script to create tables and relationships</li>
</ul>
<p class="calibre3">We will use the third option. If you just want to get the script to create tables and want to skip creating the ER diagram, then jump to the <em class="calibre21">Script to create tables and relationships</em> section of this chapter.</p>
<p class="calibre3">If you have not already installed MySQL and MySQL Workbench, then refer to <a target="_blank" href="part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre21">Introducing JEE and Eclipse</em>, for instructions:</p>
<ol class="calibre14">
<li class="calibre11" value="1"><span>Open MySQL Workbench. Select the </span><span>File</span> <span>|</span> <span>New Model</span> <span>menu. A blank model will be created with the option to create ER diagrams:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00093.jpeg" class="calibre111"/></div>
<div class="packt_figure1">Figure 4.1: Creating a new MySQL Workbench model</div>
<ol start="2" class="calibre14">
<li class="calibre11" value="2"><span>Double-click the </span><span>Add Diagram</span> <span>icon; a blank ER diagram will be opened:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00094.jpeg" class="calibre112"/></div>
<div class="packt_figure1">Figure 4.2: Creating a new ER diagram</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">By default, the new schema is named <kbd class="calibre13">mydb</kbd><span>. Double-click on it to open properties of the schema. Rename the schema</span><kbd class="calibre13">course_management</kbd><span>:</span>
<ol start="2" class="calibre15"/>
</li>
</ol>
<div class="packt_figure2"><img src="../images/00095.jpeg" class="calibre113"/></div>
<div class="packt_figure1">Figure 4.3: Renaming the schema</div>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">Hover over the toolbar buttons on the left-hand side of the page, and you will see tool tips about their functions. Click on the button for a new table and then click on the blank page. This will insert a new table with the name <kbd class="calibre13">table1</kbd><span>. Double-click the table icon to open the</span> <span>Properties</span> <span>page of the table. In the</span> <span>Properties</span> <span>page, change the name of the table to</span> <kbd class="calibre13">Course</kbd><span>:</span>
<ol start="2" class="calibre15"/>
</li>
</ol>
<div class="packt_figure2"><img src="../images/00096.jpeg" class="calibre114"/></div>
<div class="packt_figure1">Figure 4.4: Creating a table in ER diagram</div>
<ol start="5" class="calibre14">
<li value="5" class="calibre11">We will now create columns of the table. Double-click on the first column and name it <span>id</span><span>. Check the </span><span>PK</span> <span>(</span><strong class="calibre1">primary key</strong><span>),</span> <span>NN</span> <span>(</span><strong class="calibre1">not null</strong><span>), and</span> <span>AI</span> <span>(</span><strong class="calibre1">auto increment</strong><span>) checkboxes. Add other columns as shown in the following screenshot:</span>
<ol start="2" class="calibre15"/>
</li>
</ol>
<div class="packt_figure2"><img src="../images/00097.jpeg" class="calibre115"/></div>
<div class="packt_figure1">Figure 4.5: Creating columns in a table in the ER diagram</div>
<ol start="6" class="calibre14">
<li value="6" class="calibre11">Create other tables, namely <kbd class="calibre13">Student</kbd> <span>and</span> <kbd class="calibre13">Teacher</kbd><span>, as shown in the following screenshot:</span>
<ol start="2" class="calibre15"/>
</li>
</ol>
<div class="packt_figure2"><img src="../images/00098.jpeg" class="calibre116"/></div>
<div class="packt_figure1">Figure 4.6: Creating additional tables</div>
<p class="calibre3">Note that if you want to edit column properties of any table, then double-click the table in the ER diagram. Just selecting a table by a single click would not change the table selection in the <span class="calibre12">Properties</span> page. All columns in all tables are required (not null), except the <kbd class="calibre13">last_name</kbd> column in <kbd class="calibre13">Student</kbd> and <kbd class="calibre13">Teacher</kbd> tables.</p>
<p class="calibre3">We will now create relationships between the tables. One course can have many students, and students can take many courses. So, there is a many-to-many relationship between <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Student</kbd>.</p>
<p class="calibre3">We will assume that one course is taught by only one teacher. However, a teacher can teach more than one course. Therefore, there is a many-to-one relationship between <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd>.</p>
<p class="calibre3">Let's now model these relationships in the ER diagram:</p>
<ol class="calibre14">
<li value="1" class="calibre11">First, we will create a non-identifying relationship between <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd>.</li>
<li value="2" class="calibre11">Click on the non-identifying one-to-many button in the toolbar (dotted lines and <span>1:n</span>).</li>
<li value="3" class="calibre11">Then, click on the <kbd class="calibre13">Course</kbd> table first and then on the <kbd class="calibre13">Teacher</kbd> table. It will create a relationship as shown in <em class="calibre2">Figure 4.7</em>. Note that a foreign key <kbd class="calibre13">Teacher_id</kbd> is created in the <kbd class="calibre13">Course</kbd> table. We don't want to make a <kbd class="calibre13">Teacher_id</kbd> field required in <kbd class="calibre13">Course</kbd>. A course can exist without a teacher in our application. Therefore, double-click on the link joining <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd> tables.</li>
<li value="4" class="calibre11">Then, click on the <span>Foreign Key</span> tab.</li>
</ol>
<ol start="5" class="calibre14">
<li value="5" class="calibre11">On the <span>Referenced Table</span> <span>side, uncheck the</span> <span>Mandatory</span> <span>checkbox:</span>
<ol start="6" class="calibre15"/>
</li>
</ol>
<div class="packt_figure2"><img src="../images/00099.jpeg" class="calibre117"/></div>
<div class="packt_figure1">Figure 4.7: Creating a one-to-many relationship between tables</div>
<p class="calibre3">Creation of a many-to-many relationship requires a link table to be created. To create a many-to-many relationship between <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Student</kbd>, click on the icon for many-to-many (<span class="calibre12">n:m</span>) and then click on the <kbd class="calibre13">Course</kbd> table and <kbd class="calibre13">Student</kbd> table. This will create a third table (link table) called <kbd class="calibre13">Course_has_Student</kbd>. We will rename this table <kbd class="calibre13">Course_Student</kbd>. The final diagram is as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00100.jpeg" class="calibre118"/></div>
<div class="packt_figure1">Figure 4.8: ER diagram for the course management example</div>
<p class="calibre3">Follow these steps to create DDL scripts from the ER diagram:</p>
<ol class="calibre14">
<li value="1" class="calibre11">Select the <span>File</span> | <span>Export</span> | <span>Forward Engineer SQL Create Script...</span> menu.</li>
<li value="2" class="calibre11">On the <span>SQL Export Options</span> page, select checkboxes for two options:
<ul class="calibre119">
<li class="calibre11"><span>Generate DROP Statements Before Each CREATE Statement</span></li>
<li class="calibre11"><span>Generate DROP SCHEMA</span></li>
</ul>
</li>
<li value="3" class="calibre11">Specify the <span>Output SQL Script File</span> path if you want to save the script.</li>
<li value="4" class="calibre11">On the last page of the <span>Export</span> wizard, you will see the script generated by MySQL Workbench. Copy this script by clicking the <span>Copy to Clipboard</span> button.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Script to create tables and relationships</h1>
                
            
            <article>
                
<p class="calibre3">The following is the DDL script to create tables and relationships for the course management example:</p>
<pre class="calibre25">-- MySQL Script generated by MySQL Workbench 
-- Sun Mar  8 18:17:07 2015 
-- Model: New Model    Version: 1.0 
-- MySQL Workbench Forward Engineering 
 
SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0; 
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0; 
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES'; 
 
-- ----------------------------------------------------- 
-- Schema course_management 
-- ----------------------------------------------------- 
DROP SCHEMA IF EXISTS `course_management` ; 
 
-- ----------------------------------------------------- 
-- Schema course_management 
-- ----------------------------------------------------- 
CREATE SCHEMA IF NOT EXISTS `course_management` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci ; 
USE `course_management` ; 
 
-- ----------------------------------------------------- 
-- Table `course_management`.`Teacher` 
-- ----------------------------------------------------- 
DROP TABLE IF EXISTS `course_management`.`Teacher` ; 
 
CREATE TABLE IF NOT EXISTS `course_management`.`Teacher` ( 
  `id` INT NOT NULL AUTO_INCREMENT, 
  `first_name` VARCHAR(45) NOT NULL, 
  `last_name` VARCHAR(45) NULL, 
  `designation` VARCHAR(45) NOT NULL, 
  PRIMARY KEY (`id`)) 
ENGINE = InnoDB; 
 
 
-- ----------------------------------------------------- 
-- Table `course_management`.`Course` 
-- ----------------------------------------------------- 
DROP TABLE IF EXISTS `course_management`.`Course` ; 
 
CREATE TABLE IF NOT EXISTS `course_management`.`Course` ( 
  `id` INT NOT NULL AUTO_INCREMENT, 
  `name` VARCHAR(45) NOT NULL, 
  `credits` INT NOT NULL, 
  `Teacher_id` INT NULL, 
  PRIMARY KEY (`id`), 
  INDEX `fk_Course_Teacher_idx` (`Teacher_id` ASC), 
  CONSTRAINT `fk_Course_Teacher` 
    FOREIGN KEY (`Teacher_id`) 
    REFERENCES `course_management`.`Teacher` (`id`) 
    ON DELETE NO ACTION 
    ON UPDATE NO ACTION) 
ENGINE = InnoDB; 
 
 
-- ----------------------------------------------------- 
-- Table `course_management`.`Student` 
-- ----------------------------------------------------- 
DROP TABLE IF EXISTS `course_management`.`Student` ; 
 
CREATE TABLE IF NOT EXISTS `course_management`.`Student` ( 
  `id` INT NOT NULL AUTO_INCREMENT, 
  `first_name` VARCHAR(45) NOT NULL, 
  `last_name` VARCHAR(45) NULL, 
  `enrolled_since` MEDIUMTEXT NOT NULL, 
  PRIMARY KEY (`id`)) 
ENGINE = InnoDB; 
 
 
-- ----------------------------------------------------- 
-- Table `course_management`.`Course_Student` 
-- ----------------------------------------------------- 
DROP TABLE IF EXISTS `course_management`.`Course_Student` ; 
 
CREATE TABLE IF NOT EXISTS `course_management`.`Course_Student` ( 
  `Course_id` INT NOT NULL, 
  `Student_id` INT NOT NULL, 
  PRIMARY KEY (`Course_id`, `Student_id`), 
  INDEX `fk_Course_has_Student_Student1_idx` (`Student_id` ASC), 
  INDEX `fk_Course_has_Student_Course1_idx` (`Course_id` ASC), 
  CONSTRAINT `fk_Course_has_Student_Course1` 
    FOREIGN KEY (`Course_id`) 
    REFERENCES `course_management`.`Course` (`id`) 
    ON DELETE NO ACTION 
    ON UPDATE NO ACTION, 
  CONSTRAINT `fk_Course_has_Student_Student1` 
    FOREIGN KEY (`Student_id`) 
    REFERENCES `course_management`.`Student` (`id`) 
    ON DELETE NO ACTION 
    ON UPDATE NO ACTION) 
ENGINE = InnoDB; 
 
 
SET SQL_MODE=@OLD_SQL_MODE; 
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS; 
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating tables in MySQL</h1>
                
            
            <article>
                
<p class="calibre3">Let's now create tables and relationships in the MySQL database by using the script created in the previous section.</p>
<p class="calibre3">Make sure that MySQL is running and there is an open connection to the server from MySQL Workbench (see <a target="_blank" href="part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre21">Introducing JEE and Eclipse</em>, for more details):</p>
<ol class="calibre14">
<li value="1" class="calibre11">Create a new query tab (the first button in the toolbar) and paste the preceding script.</li>
<li value="2" class="calibre11">Execute the query.</li>
<li value="3" class="calibre11">At the end of the execution, refresh schemas in the left-hand pane. You should see the <span>course_management</span> <span>schema and the tables created in it.</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00101.jpeg" class="calibre120"/></div>
<div class="packt_figure1">Figure 4.9: MySQL schema for the course management example</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a database application using JDBC</h1>
                
            
            <article>
                
<p class="calibre3">In this section, we will use JDBC to create a simple course management web application. We will use the MySQL schema created in the previous section. Furthermore, we will create the web application using Tomcat; we have already seen how to create one in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>. We have also learned how to use JSTL and JSF in the same chapter. In this section, we will use JSTL and JDBC to create the course management application, and in the next section, we will use JSF and JPA to create the same application. We will use Maven (as described in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>) for project management, and of course, our IDE is going to be Eclipse JEE.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a project and setting up Maven dependencies</h1>
                
            
            <article>
                
<p class="calibre3">We will perform the following steps to create the Maven project for our application:</p>
<ol class="calibre14">
<li value="1" class="calibre11">Create a Maven web project as described in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre2">Creating a Simple JEE Web Application</em>.</li>
<li value="2" class="calibre11">Name the project <kbd class="calibre13">CourseManagementJDBC</kbd>.</li>
<li value="3" class="calibre11">Add dependencies for servlet and JSP, but do not add a dependency for JSF.</li>
</ol>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">To add the dependency for JSTL, open <kbd class="calibre13">pom.xml</kbd> <span>and go to the </span><span>Dependencies</span> <span>tab. Click on the </span><span>Add...</span> <span>button. Type</span> <kbd class="calibre13">javax.servlet</kbd> <span>in the search box and select</span> <span>jstl</span><span>:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00102.jpeg" class="calibre121"/></div>
<div class="packt_figure1">Figure 4.10: Adding a dependency for jstl</div>
<ol start="5" class="calibre14">
<li value="5" class="calibre11">Add the dependency for the MySQL JDBC driver too:
<ol start="5" class="calibre15"/>
</li>
</ol>
<div class="packt_figure2"><img src="../images/00103.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 4.11: Adding dependency for the MySQL JDBC driver</div>
<p class="calibre3">Here is the <kbd class="calibre13">pom.xml</kbd> file after adding dependencies:</p>
<pre class="calibre25">&lt;project  
   
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 <br class="title-page-name"/> http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; 
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 
  &lt;groupId&gt;packt.book.jee.eclipse&lt;/groupId&gt; 
  &lt;artifactId&gt;CourseManagementJDBC&lt;/artifactId&gt; 
  &lt;version&gt;1&lt;/version&gt; 
  &lt;packaging&gt;war&lt;/packaging&gt; 
  &lt;dependencies&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt; 
      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; 
      &lt;version&gt;3.1.0&lt;/version&gt; 
&lt;scope&gt;provided&lt;/scope&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt; 
      &lt;artifactId&gt;jstl&lt;/artifactId&gt; 
      &lt;version&gt;1.2&lt;/version&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;mysql&lt;/groupId&gt; 
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; 
      &lt;version&gt;8.0.9-rc&lt;/version&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; 
      &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; 
      &lt;version&gt;2.2&lt;/version&gt; 
      &lt;scope&gt;provided&lt;/scope&gt; 
    &lt;/dependency&gt; 
  &lt;/dependencies&gt; 
&lt;/project&gt; </pre>
<p class="calibre3">Note that the dependencies for servlet and JSP are marked as provided, which means that they will be provided by the web container (Tomcat) and will not be packaged with the application.</p>
<p class="calibre3">The description of how to configure Tomcat and add a project to it is skipped here. Refer to <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>, for these details. This section will also not repeat information on how to run JSP pages and about JSTL that were covered in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating JavaBeans for data storage</h1>
                
            
            <article>
                
<p class="calibre3">We will first create JavaBean classes for <kbd class="calibre13">Student</kbd>, <kbd class="calibre13">Course</kbd>, and <kbd class="calibre13">Teacher</kbd>. Since both student and teacher are people, we will create a new class called <kbd class="calibre13">Person</kbd> and have <kbd class="calibre13">Student</kbd> and <kbd class="calibre13">Teacher</kbd> classes extend it. Create these JavaBeans in the <kbd class="calibre13">packt.book.jee.eclipse.ch4.beans</kbd> package as follows.</p>
<p class="calibre3">The code for the <kbd class="calibre13">Course</kbd> bean will be as follows:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.bean; 
 
public class Course { 
  private int id; 
  private String name; 
  private int credits; 
  public int getId() { 
    return id; 
  } 
  public void setId(int id) { 
    this.id = id; 
  } 
  public String getName() { 
    return name; 
  } 
  public void setName(String name) { 
    this.name = name; 
  } 
  public int getCredits() { 
    return credits; 
  } 
  public void setCredits(int credits) { 
    this.credits = credits; 
  } 
} </pre>
<p class="calibre3">The code for the <kbd class="calibre13">Person</kbd> bean will be as follows:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.bean; 
 
public class Person { 
  private int id; 
  private String firstName; 
  private String lastName; 
 
  public int getId() { 
    return id; 
  } 
  public void setId(int id) { 
    this.id = id; 
  } 
  public String getFirstName() { 
    return firstName; 
  } 
  public void setFirstName(String firstName) { 
    this.firstName = firstName; 
  } 
  public String getLastName() { 
    return lastName; 
  } 
  public void setLastName(String lastName) { 
    this.lastName = lastName; 
  } 
} </pre>
<p class="calibre3">The code for the <kbd class="calibre13">Student</kbd> bean will be as follows:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.bean; 
 
public class Student extends Person { 
  private long enrolledsince; 
 
  public long getEnrolledsince() { 
    return enrolledsince; 
  } 
 
  public void setEnrolledsince(long enrolledsince) { 
    this.enrolledsince = enrolledsince; 
  } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">Teacher</kbd> bean will be as follows:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.bean; 
 
public class Teacher extends Person { 
  private String designation; 
 
  public String getDesignation() { 
    return designation; 
  } 
 
  public void setDesignation(String designation) { 
    this.designation = designation; 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating JSP to add a course</h1>
                
            
            <article>
                
<p class="calibre3">Let's now create a JSP page to add new courses. Right-click on the project in <span class="calibre12">Package Explorer</span> and select the <span class="calibre12">New</span> | <span class="calibre12">Other...</span> option. Type <kbd class="calibre13">jsp</kbd> in the filter box and select <span class="calibre12">JSP File</span>. Name the file <kbd class="calibre13">addCourse.jsp</kbd>. Eclipse will create the file in the <kbd class="calibre13">src/main/webapp</kbd> folder of the project.</p>
<p class="calibre3">Type the following code in <kbd class="calibre13">addCourse.jsp</kbd>:</p>
<pre class="calibre25">&lt;%@ page language="java" contentType="text/html; charset=UTF-8" 
    pageEncoding="UTF-8"%&gt; 
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; 
 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; 
&lt;html&gt; 
&lt;head&gt; 
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 
&lt;title&gt;Add Course&lt;/title&gt; 
&lt;/head&gt; 
&lt;body&gt; 
  &lt;c:set var="errMsg" value="${null}"/&gt; 
  &lt;c:set var="displayForm" value="${true}"/&gt; 
    &lt;c:if test="${\"POST\".equalsIgnoreCase(pageContext.request.method) <br class="title-page-name"/>        &amp;&amp; pageContext.request.getParameter(\"submit\") != null}"&gt; 
    &lt;jsp:useBean id="courseBean" class="packt.book.jee.eclipse.ch4.bean.Course"&gt; 
      &lt;c:catch var="beanStorageException"&gt; 
        &lt;jsp:setProperty name="courseBean" property="*" /&gt; 
      &lt;/c:catch&gt; 
    &lt;/jsp:useBean&gt; 
    &lt;c:choose&gt; 
      &lt;c:when test="${!courseBean.isValidCourse() || beanStorageException != null}"&gt; 
        &lt;c:set var="errMsg" value="Invalid course details. Please <br class="title-page-name"/>         try again"/&gt; 
      &lt;/c:when&gt; 
      &lt;c:otherwise&gt; 
        &lt;c:redirect url="listCourse.jsp"/&gt; 
      &lt;/c:otherwise&gt; 
    &lt;/c:choose&gt; 
  &lt;/c:if&gt; 
 
  &lt;h2&gt;Add Course:&lt;/h2&gt; 
  &lt;c:if test="${errMsg != null}"&gt; 
    &lt;span style="color: red;"&gt; 
      &lt;c:out value="${errMsg}"&gt;&lt;/c:out&gt; 
    &lt;/span&gt; 
  &lt;/c:if&gt; 
  &lt;form method="post"&gt; 
    Name: &lt;input type="text" name="name"&gt; &lt;br&gt; 
    Credits : &lt;input type="text" name="credits"&gt; &lt;br&gt; 
    &lt;button type="submit" name="submit"&gt;Add&lt;/button&gt; 
  &lt;/form&gt; 
 
&lt;/body&gt; 
&lt;/html&gt; </pre>
<p class="calibre3">Most of the code should be familiar, if you have read <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em> (see the <em class="calibre21">Using JSTL </em><span class="calibre12">section</span>). We have a form to add courses. At the top of the file, we check whether the <kbd class="calibre13">post</kbd> request is made; if so, store content of the form in <kbd class="calibre13">courseBean</kbd> (make sure that names of the <kbd class="calibre13">form</kbd> field are the same as the members defined in the bean). The new tag that we have used here is <kbd class="calibre13">&lt;c:catch&gt;</kbd>. It is like a <em class="calibre21">try-catch</em> block in Java. Any exception thrown from within the body of <kbd class="calibre13">&lt;c:catch&gt;</kbd> is assigned to the variable name declared in the <kbd class="calibre13">var</kbd> attribute. Here, we are not doing anything with <kbd class="calibre13">beanStorageException</kbd>; we are suppressing the exception. When an exception is thrown, the <kbd class="calibre13">credits</kbd> field of the <kbd class="calibre13">Course</kbd> bean will remain set to zero and it will be caught in the <kbd class="calibre13">courseBean.isValidCourse</kbd> method. If the course data is valid, then we redirect the request to the <kbd class="calibre13">listCourse.jsp</kbd> page using the JSTL <kbd class="calibre13">&lt;c:redirect&gt;</kbd> tag.</p>
<p class="calibre3">We need to add the <kbd class="calibre13">isValidCourse</kbd> method in the <kbd class="calibre13">Course</kbd> bean. Therefore, open the class in the editor and add the following method:</p>
<pre class="calibre25">  public boolean isValidCourse() { 
    return name != null &amp;&amp; credits != 0; 
  } </pre>
<p class="calibre3">We also need to create <kbd class="calibre13">listCourse.jsp</kbd>. For now, just create a simple JSP with no JSTL/Java code and with only one header in the <kbd class="calibre13">body</kbd> tag:</p>
<pre class="calibre25">&lt;h2&gt;Courses:&lt;/h2&gt; </pre>
<p class="calibre3">Right-click on <kbd class="calibre13">addCourse.jsp</kbd> in <span class="calibre12">Package Explorer </span>and select <span class="calibre12">Run As</span> | <span class="calibre12">Run on Server</span>. If you have configured Tomcat properly and added your project in Tomcat (as described in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>), then you should see the JSP page running in the internal Eclipse browser. Test the page with both valid and invalid data (a wrong credit value; for example, a non-numeric value). If the data entered is valid, then you would be redirected to <kbd class="calibre13">listCourse.jsp</kbd>, or else the same page would be displayed with the error message.</p>
<p class="calibre3">Before we start writing JDBC code, let's learn some fundamental concepts of JDBC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">JDBC concepts</h1>
                
            
            <article>
                
<p class="calibre3">Before performing any operations in JDBC, we need to establish a connection to the database. Here are some of the important classes/interfaces in JDBC for executing SQL statements:</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">JDBC class/interface</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Description</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java.sql.Connection</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">Represents the connection between the application and the backend database. Must for performing any action on the database.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java.sql.DriverManager</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">Manages JDBC drivers used in the application. Call the <kbd class="calibre13">DriverManager.getConnection</kbd> static method to obtain the connection.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java.sql.Statement</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">Used for executing static SQL statements.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java.sql.PreparedStatement</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">Used for preparing parameterized SQL statements. SQL statements are pre-compiled and can be executed repeatedly with different parameters.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">Java.sqlCallableStatement</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">Used for executing a stored procedure.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java.sql.ResultSet</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">Represents a row in the database table in the result returned after execution of an SQL query by <kbd class="calibre13">Statement</kbd> or <kbd class="calibre13">PreparedStatement</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_infobox">You can find all the interfaces for JDBC at <a href="http://docs.oracle.com/javase/8/docs/api/java/sql/package-frame.html" class="calibre17"><span class="calibre23">http://docs.oracle.com/javase/8/docs/api/java/sql/package-frame.html</span></a>.<br class="calibre26"/>
<br class="calibre26"/>
Many of these are interfaces, and implementations of these interfaces are provided by the JDBC drivers.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating database connections</h1>
                
            
            <article>
                
<p class="calibre3">Make sure that the JDBC driver for the database you want to connect to is downloaded and is in the classpath. In our project, we have already ensured this by adding a dependency in Maven. Maven downloads the driver and adds it to the class path of our web application.</p>
<p class="calibre3">It is always a good practice to make sure that the JDBC driver class is available when the application is running. If it is not, we can set a suitable error message and not perform any JDBC operations. The name of the MySQL JDBC driver class is <kbd class="calibre13">com.mysql.cj.jdbc.Driver</kbd>:</p>
<pre class="calibre25">try { 
  Class.forName("com.mysql.cj.jdbc.Driver"); 
} 
catch (ClassNotFoundException e) { 
  //log excetion 
  //either throw application specific exception or return 
  return; 
} 
 </pre>
<p class="calibre3">Then, get the connection by calling the <kbd class="calibre13">DriverManager.getConnection</kbd> method:</p>
<pre class="calibre25">try { 
  Connection con = <br class="title-page-name"/> DriverManager.getConnection("jdbc:mysql://localhost:3306/schema_name?" + 
      "user=your_user_name&amp;password=your_password"); 
//perform DB operations and then close the connection 
  con.close(); 
} 
catch (SQLException e) { 
  //handle exception 
} </pre>
<p class="calibre3">The argument to <kbd class="calibre13">DriverManager.getConnection</kbd> is called a connection URL. It is specific to the JDBC driver. So, check the documentation of the JDBC driver to understand how to create a connection URL. The URL format in the preceding code snippet is for MySQL. See <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html" class="calibre9">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html</a>.</p>
<p class="calibre3">The connection URL contains the following details: hostname of the MySQL database server, port on which it is running (default is 3306), and the schema name (database name that you want to connect to). You can pass username and password to connect to the database as URL parameters.</p>
<p class="calibre3">Creating a connection is an expensive operation. Also, database servers allow a certain maximum number of connections to it, so connections should be created sparingly. It is advisable to cache database connections and reuse. However, make sure that you close the connection when you no longer need it, for example, in the <kbd class="calibre13">final</kbd> blocks of your code. Later, we will see how to create a pool of connections so that we create a limited number of connections, take them out of the pool when required, perform the required operations, and return them to the pool so that they can be reused.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Executing SQL statements</h1>
                
            
            <article>
                
<p class="calibre3">Use <kbd class="calibre13">Statement</kbd> for executing static SQL (having no parameters) and <kbd class="calibre13">PreparedStatement</kbd> for executing parameterized statements.</p>
<div class="packt_tip"><span class="calibre23"><br class="calibre26"/>
To avoid the risk of SQL injection, refer to</span><span class="calibre23"> <a href="https://www.owasp.org/index.php/SQL_injection" class="calibre17">https://www.owasp.org/index.php/SQL_injection</a>.</span></div>
<p class="calibre3">To execute any <kbd class="calibre13">Statement</kbd>, you first need to create the statement using the <kbd class="calibre13">Connection</kbd> object. You can then perform any SQL operation, such as <kbd class="calibre13">create</kbd>, <kbd class="calibre13">update</kbd>, <kbd class="calibre13">delete</kbd>, and <kbd class="calibre13">select</kbd>. The <kbd class="calibre13">Select</kbd> statement (query) returns a <kbd class="calibre13">ResultSet</kbd> object. Iterate over the <kbd class="calibre13">ResultSet</kbd> object to get individual rows.</p>
<p class="calibre3">For example, the following code gets all rows from the <kbd class="calibre13">Course</kbd> table:</p>
<pre class="calibre25">Statement stmt = null; 
ResultSet rs = null; 
try { 
  stmt = con.createStatement(); 
  rs = stmt.executeQuery("select * from Course"); 
 
  List&lt;Course&gt; courses = new ArrayList&lt;Course&gt;(); 
  //Depending on the database that you connect to, you may have to  
  //call rs.first() before calling rs.next(). In the case of a MySQL 
  //database, it is not necessary to call rs.first() 
  while (rs.next()) { 
    Course course = new Course(); 
    course.setId(rs.getInt("id")); 
    course.setName(rs.getString("name")); 
    course.setCredits(rs.getInt("credits")); 
    courses.add(course); 
  } 
} 
catch (SQLException e) { 
  //handle exception 
  e.printStackTrace(); 
} 
finally { 
  try { 
    if (rs != null) 
    rs.close(); 
    if (stmt != null) 
    stmt.close(); 
  } 
  catch (SQLException e) { 
    //handle exception 
  } 
} </pre>
<p class="calibre3">Things to note:</p>
<ul class="calibre10">
<li class="calibre11">Call <kbd class="calibre13">Connection.createStatement ()</kbd> to create an instance of <kbd class="calibre13">Statement</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">Statement.executeQuery</kbd> returns <kbd class="calibre13">ResultSet</kbd>. If the SQL statement is not a query, for example <kbd class="calibre13">create</kbd>, <kbd class="calibre13">update</kbd>, and <kbd class="calibre13">delete</kbd> statements, then call <kbd class="calibre13">Statement.execute</kbd> (which returns <kbd class="calibre13">true</kbd> if the statement is executed successfully; or else, <kbd class="calibre13">false</kbd>) or call <kbd class="calibre13">Statement.executeUpdate</kbd> (which returns the number of rows affected or zero if none is affected).</li>
<li class="calibre11">Pass the SQL statement to the <kbd class="calibre13">Statement.executeQuery</kbd> function. This can be any valid SQL string understood by the database.</li>
<li class="calibre11">Iterate over <kbd class="calibre13">ResultSet</kbd> by calling the <kbd class="calibre13">next</kbd> method, until it returns <kbd class="calibre13">false</kbd>.</li>
<li class="calibre11">Call different variations of <kbd class="calibre13">get</kbd> <span>methods (depending on the data type of the column) to obtain values of columns in the current row that the </span><kbd class="calibre13">ResultSet</kbd> <span>is pointing to. You can either pass positional index of the column in SQL that you passed to</span> <kbd class="calibre13">executeQuery</kbd> <span>or column names as used in the database table or alias specified in the SQL statement. For example, we would use the following code if we had specified column names in the SQL:</span></li>
</ul>
<pre class="calibre35">rs = stmt.executeQuery("select id, name, credits as courseCredit from Course"); </pre>
<p class="mce-root2"><span class="calibre12">Then, we could retrieve column values as follows:</span></p>
<pre class="calibre35">course.setId(rs.getInt(1)); 
course.setName(rs.getString(2)); 
course.setCredits(rs.getInt("courseCredit")); </pre>
<ul class="calibre10">
<li class="calibre11">Make sure you close <kbd class="calibre13">ResultSet</kbd> and <kbd class="calibre13">Statement</kbd>.</li>
</ul>
<p class="calibre3">Instead of getting all courses, if you want to get a specific course, you would want to use <kbd class="calibre13">PreparedStatement</kbd>:</p>
<pre class="calibre25">PreparedStatement stmt = null; 
int courseId = 10; 
ResultSet rs = null; 
try { 
  stmt = con.prepareStatement("select * from Course where id = <br class="title-page-name"/>   ?"); 
  stmt.setInt(1, courseId); 
  rs = stmt.executeQuery(); 
 
  Course course = null; 
  if (rs.next()) { 
    course = new Course(); 
    course.setId(rs.getInt("id")); 
    course.setName(rs.getString("name")); 
    course.setCredits(rs.getInt("credits")); 
  } 
} 
catch (SQLException e) { 
  //handle exception 
  e.printStackTrace(); 
} 
finally { 
  try { 
    if (rs != null) 
    rs.close(); 
    if (stmt != null 
    stmt.close(); 
  } 
catch (SQLException e) { 
    //handle exception 
  } 
} </pre>
<p class="calibre3">In this example, we are trying to get the course with ID <kbd class="calibre13">10</kbd>. We first get an instance of <kbd class="calibre13">PreparedStatement</kbd> by calling <kbd class="calibre13">Connection.prepareStatement</kbd>. Note that you need to pass an SQL statement as an argument to this function. Parameters in the query are replaced by the <kbd class="calibre13">?</kbd> placeholder. We then set the value of the parameter by calling <kbd class="calibre13">stmt.setInt</kbd>. The first argument is the position of the parameter (it starts from <kbd class="calibre13">1</kbd>) and the second argument is the value. There are many variations of the <kbd class="calibre13">set</kbd> method for different data types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling transactions</h1>
                
            
            <article>
                
<p class="calibre3">If you want to perform multiple changes to the database as a single unit, that is, either all changes should be done or none, then you need to start a transaction in JDBC. You start a transaction by calling <kbd class="calibre13">Connection. setAutoCommit(false)</kbd>. Once all operations are executed successfully, commit the changes to the database by calling <kbd class="calibre13">Connection.commit</kbd>. If for any reason you want to abort the transaction, call <kbd class="calibre13">Connection.rollback()</kbd>. Changes are not done in the database until you call <kbd class="calibre13">Connection.commit</kbd>.</p>
<p class="calibre3">Here is an example of inserting a bunch of courses into the database. Although in a real application, it may not make sense to abort a transaction when one of the courses is not inserted, here we assume that either all courses must be inserted into the database or none:</p>
<pre class="calibre25">PreparedStatement stmt = con.prepareStatement("insert into Course (id, name, credits) values (?,?,?)"); 
 
con.setAutoCommit(false); 
try { 
  for (Course course : courses) { 
    stmt.setInt(1, course.getId()); 
    stmt.setString(2, course.getName()); 
    stmt.setInt(3, course.getCredits()); 
    stmt.execute(); 
  } 
  //commit the transaction now 
  con.commit(); 
} 
catch (SQLException e) { 
  //rollback commit 
  con.rollback(); 
} </pre>
<div class="packt_infobox"><br class="calibre26"/>
There is more to learn about transactions than explained here. Refer to Oracle's JDBC tutorial at <a href="http://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html" class="calibre17"><span class="calibre23">http://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using a JDBC database connection pool</h1>
                
            
            <article>
                
<p class="calibre3">As mentioned before, a JDBC database connection is an expensive operation and connection objects should be reused. Connection pools are used for this purpose. Most web containers provide their own implementation of a connection pool along with ways to configure it using JNDI. Tomcat also lets you configure a connection pool using JNDI. The advantage of configuring a connection pool using JNDI is that the database configuration parameters, such as hostname and port, remain outside the source code and can be easily modified. See <a href="http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html" class="calibre9"><span>http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html</span></a>.</p>
<p class="calibre3">However, a Tomcat connection pool can also be used without JNDI, as described in the preceding link. In this example, we will use a connection pool without JNDI. The advantage is that you can use the connection pool implementation provided by a third party; your application then becomes easily portable to other web containers. With JNDI, you can also port your application, as long as you create the JNDI context and resources in the web container that you are switching to.</p>
<p class="calibre3">We will add the dependency of the Tomcat connection pool library to Maven's <kbd class="calibre13">pom.xml</kbd>. Open the <kbd class="calibre13">pom.xml</kbd> file and add the following dependencies (see <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>, to know how to add dependencies to Maven):</p>
<pre class="calibre25">  &lt;dependency&gt; 
    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; 
    &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; 
    &lt;version&gt;9.0.6&lt;/version&gt; 
  &lt;/dependency&gt; </pre>
<p class="calibre3">Note that you can use any other implementation of the JDBC connection pool. One such connection pool library is HikariCP (<a href="https://github.com/brettwooldridge/HikariCP" class="calibre9"><span>https://github.com/brettwooldridge/HikariCP</span></a>).</p>
<p class="calibre3">We also want to move the database properties out of the code. Therefore, create a file called <kbd class="calibre13">db.properties</kbd> in <kbd class="calibre13">src/main/resources</kbd>. Maven puts all files in this folder in the classpath of the application. Add the following properties in <kbd class="calibre13">db.properties</kbd>:</p>
<pre class="calibre25">db_host=localhost 
db_port=3306 
db_name=course_management 
db_user_name=your_user_name 
db_password=your_password 
db_driver_class_name=com.mysql.cj.jdbc.Driver </pre>
<p class="calibre3">We will create a singleton class to create JDBC connections using the Tomcat connection pool. Create a <kbd class="calibre13">packt.book.jee.eclipse.ch4.db.connection</kbd> package and create a <kbd class="calibre13">DatabaseConnectionFactory</kbd> class in it:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.db.connection; 
 
// skipping imports to save space here
 
/** 
 * Singleton Factory class to create JDBC database connections 
 * 
 */ 
public class DatabaseConnectionFactory { 
  //singleton instance 
  private static DatabaseConnectionFactory conFactory = new <br class="title-page-name"/>   DatabaseConnectionFactory(); 
 
  private DataSource dataSource = null; 
 
  //Make the construction private 
  private DatabaseConnectionFactory() {} 
 
  /** 
   * Must be called before any other method in this class. 
   * Initializes the data source and saves it in an instance <br class="title-page-name"/>   variable 
   * 
   * @throws IOException 
   */ 
  public synchronized void init() throws IOException { 
    //Check if init was already called 
  if (dataSource != null) 
    return; 
 
    //load db.properties file first 
    InputStream inStream = <br class="title-page-name"/> this.getClass().getClassLoader().getResourceAsStream("db.properties"); 
    Properties dbProperties = new Properties(); 
    dbProperties.load(inStream); 
    inStream.close(); 
 
    //create Tomcat specific pool properties 
    PoolProperties p = new PoolProperties(); 
p.setUrl("jdbc:mysql://" + dbProperties.getProperty("db_host") + 
":" + dbProperties.getProperty("db_port") + "/" + 
dbProperties.getProperty("db_name")); 
 
p.setDriverClassName(dbProperties.getProperty("db_driver_class_name")); 
    p.setUsername(dbProperties.getProperty("db_user_name")); 
    p.setPassword(dbProperties.getProperty("db_password")); 
    p.setMaxActive(10); 
 
    dataSource = new DataSource(); 
    dataSource.setPoolProperties(p); 
  } 
 
  //Provides access to singleton instance 
  public static DatabaseConnectionFactory getConnectionFactory() { 
    return conFactory; 
  } 
 
  //returns database connection object  
  public Connection getConnection () throws SQLException { 
    if (dataSource == null) 
      throw new SQLException("Error initializing datasource"); 
    return dataSource.getConnection(); 
  } 
} </pre>
<p class="calibre3">We must call the <kbd class="calibre13">init</kbd> method of <kbd class="calibre13">DatabaseConnectionFactory</kbd> before getting connections from it. We will create a servlet and load it on startup. Then, we will call <kbd class="calibre13">DatabaseConnectionFactory.init</kbd> from the <kbd class="calibre13">init</kbd> method of the servlet.</p>
<p class="calibre3">Create <kbd class="calibre13">package packt.book.jee.eclipse.ch4.servlet</kbd> and then create an <kbd class="calibre13">InitServlet</kbd> class in it:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.servlet; 
import java.io.IOException; 
import javax.servlet.ServletConfig; 
import javax.servlet.ServletException; 
import javax.servlet.annotation.WebServlet; 
import javax.servlet.http.HttpServlet; 
 
import packt.book.jee.eclipse.ch4.db.connection.DatabaseConnectionFactory; 
 
@WebServlet(value="/initServlet", loadOnStartup=1) 
public class InitServlet extends HttpServlet { 
  private static final long serialVersionUID = 1L; 
 
  public InitServlet() { 
    super(); 
  } 
 
  public void init(ServletConfig config) throws ServletException { 
    try { 
      DatabaseConnectionFactory.getConnectionFactory().init(); 
    } 
    catch (IOException e) { 
      config.getServletContext().log(e.getLocalizedMessage(),e); 
    } 
  } 
} </pre>
<p class="calibre3">Note that we have used the <kbd class="calibre13">@WebServlet</kbd> annotation to mark this class as a servlet and the <kbd class="calibre13">loadOnStartup</kbd> attribute is set to <kbd class="calibre13">1</kbd>, to tell the web container to load this servlet on startup.</p>
<p class="calibre3">Now we can call the following statement to get a <kbd class="calibre13">Connection</kbd> object from anywhere in the application:</p>
<pre class="calibre25">Connection con = DatabaseConnectionFactory.getConnectionFactory().getConnection(); </pre>
<p class="calibre3">If there are no more connections available in the pool, then the <kbd class="calibre13">getConnection</kbd> method throws an exception (in particular, in the case of the <kbd class="calibre13">Tomcat</kbd> datasource, it throws <kbd class="calibre13">PoolExhaustedException</kbd>). When you close the connection that was obtained from the connection pool, the connection is returned to the pool for reuse.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Saving courses in database tables using JDBC</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have figured out how to use the JDBC connection pool and get a connection from it, let's write the code to save a course to the database.</p>
<p class="calibre3">We will create <strong class="calibre5">Course Data Access Object</strong> (<strong class="calibre5">CourseDAO</strong>), which will have functions required to directly interact with the database. We are thus separating the code to access the database from the UI and business code.</p>
<p class="calibre3">Create <kbd class="calibre13">package packt.book.jee.eclipse.ch4.dao</kbd>. Create a class called <kbd class="calibre13">CourseDAO</kbd> in it:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.dao; 
 
import java.sql.Connection; 
import java.sql.PreparedStatement; 
import java.sql.ResultSet; 
import java.sql.SQLException; 
import java.sql.Statement; 
 
import packt.book.jee.eclipse.ch4.bean.Course; 
import packt.book.jee.eclipse.ch4.db.connection.DatabaseConnectionFactory; 
 
public class CourseDAO { 
 
  public static void addCourse (Course course) throws SQLException <br class="title-page-name"/>   { 
    //get connection from connection pool 
    Connection con = <br class="title-page-name"/> DatabaseConnectionFactory.getConnectionFactory().getConnection(); 
    try { 
      final String sql = "insert into Course (name, credits) <br class="title-page-name"/>       values (?,?)";      //create the prepared statement with an option to get auto- <br class="title-page-name"/>       generated keys      PreparedStatement stmt = con.prepareStatement(sql, <br class="title-page-name"/>       Statement.RETURN_GENERATED_KEYS); 
      //set parameters 
      stmt.setString(1, course.getName()); 
      stmt.setInt(2, course.getCredits()); 
 
      stmt.execute(); 
 
      //Get auto-generated keys 
      ResultSet rs = stmt.getGeneratedKeys(); 
 
      if (rs.next()) 
        course.setId(rs.getInt(1)); 
 
      rs.close(); 
      stmt.close(); 
    } 
    finally { 
      con.close(); 
    } 
  } 
} </pre>
<p class="calibre3">We have already seen how to insert a record using JDBC. The only new thing in the preceding code is to get the autogenerated ID. Recall that the <kbd class="calibre13">id</kbd> column in the <kbd class="calibre13">Course</kbd> table is autogenerated. This is the reason that we did not specify it in the insert SQL:</p>
<pre class="calibre25">String sql = "insert into Course (name, credits) values (?,?)"; </pre>
<p class="calibre3">When we prepare a statement, we are telling the driver to get the autogenerated ID. After the row is inserted into the table, we get the autogenerated ID by calling the following:</p>
<pre class="calibre25">ResultSet rs = stmt.getGeneratedKeys(); </pre>
<p class="calibre3">We have already created <kbd class="calibre13">addCourse.jsp</kbd>. Somehow <kbd class="calibre13">addCourse.jsp</kbd> needs to send the form data to <kbd class="calibre13">CourseDAO</kbd> in order to save the data in the database. <kbd class="calibre13">addCourse.jsp</kbd> already has access to the <kbd class="calibre13">Course</kbd> bean and saves the form data in it. So, it makes sense for the <kbd class="calibre13">Course</kbd> bean to interface between <kbd class="calibre13">addCourse.jsp</kbd> and <kbd class="calibre13">CourseDAO</kbd>. Let's modify the <kbd class="calibre13">Course</kbd> bean to add an instance of <kbd class="calibre13">CourseDAO</kbd> as a member variable and then create a function to add a course (instance of <kbd class="calibre13">CourseDAO</kbd>) to the database:</p>
<pre class="calibre25">public class Course { 
.... 
 
  private CourseDAO courseDAO = new CourseDAO(); 
 
... 
 
  public void addCourse() throws SQLException { 
    courseDAO.addCourse(this); 
  } 
} </pre>
<p class="calibre3">We will then modify <kbd class="calibre13">addCourse.jsp</kbd> to call the <kbd class="calibre13">addCourse</kbd> method of the <kbd class="calibre13">Course</kbd> bean. We will have to add this code after the form is submitted and the data is validated:</p>
<pre class="calibre25">&lt;c:catch var="addCourseException"&gt; 
  ${courseBean.addCourse()} 
&lt;/c:catch&gt; 
&lt;c:choose&gt; 
  &lt;c:when test="${addCourseException != null}"&gt; 
    &lt;c:set var="errMsg" value="${addCourseException.message}"/&gt; 
  &lt;/c:when&gt; 
  &lt;c:otherwise&gt; 
    &lt;c:redirect url="listCourse.jsp"/&gt; 
  &lt;/c:otherwise&gt; 
&lt;/c:choose&gt; </pre>
<p class="calibre3">One thing to note in the preceding code is the following statement:</p>
<pre class="calibre25">${courseBean.addCourse()} </pre>
<p class="calibre3">You can insert <strong class="calibre5">Expression Language</strong> (<strong class="calibre5">EL</strong>) in JSP as discussed previously. This method does not return anything (it is a void method). Therefore, we didn't use the <kbd class="calibre13">&lt;c:set&gt;</kbd> tag. Furthermore, note that the call is made within the <kbd class="calibre13">&lt;c:catch&gt;</kbd> tag. If any <kbd class="calibre13">SQLException</kbd> is thrown from the method, then it will be assigned to the <kbd class="calibre13">addCourseException</kbd> variable. We then check whether <kbd class="calibre13">addCourseException</kbd> is set in the <kbd class="calibre13">&lt;c:when&gt;</kbd> tag. If the value is not null, then it means that the exception was thrown. We set the error message, which is later displayed on the same page. If no error is thrown, then the request is redirected to <kbd class="calibre13">listCourse.jsp</kbd>. Here is the complete code of <kbd class="calibre13">addCourse.jsp</kbd>:</p>
<pre class="calibre25">&lt;%@ page language="java" contentType="text/html; charset=UTF-8" 
    pageEncoding="UTF-8"%&gt; 
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; 
 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" <br class="title-page-name"/> "http://www.w3.org/TR/html4/loose.dtd"&gt; 
&lt;html&gt; 
&lt;head&gt; 
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 
&lt;title&gt;Insert title here&lt;/title&gt; 
&lt;/head&gt; 
&lt;body&gt; 
  &lt;c:set var="errMsg" value="${null}"/&gt; 
  &lt;c:set var="displayForm" value="${true}"/&gt; 
  &lt;c:if <br class="title-page-name"/> test="${"POST".equalsIgnoreCase(pageContext.request.method) 
&amp;&amp; pageContext.request.getParameter("submit") != null}"&gt; 
  &lt;jsp:useBean id="courseBean" <br class="title-page-name"/>   class="packt.book.jee.eclipse.ch4.bean.Course"&gt; 
    &lt;c:catch var="beanStorageException"&gt; 
    &lt;jsp:setProperty name="courseBean" property="*" /&gt; 
    &lt;/c:catch&gt; 
    &lt;/jsp:useBean&gt; 
    &lt;c:choose&gt; 
      &lt;c:when test="${!courseBean.isValidCourse() || <br class="title-page-name"/>       beanStorageException != null}"&gt;      &lt;c:set var="errMsg" value="Invalid course details. Please <br class="title-page-name"/>       try again"/&gt; 
      &lt;/c:when&gt; 
      &lt;c:otherwise&gt; 
        &lt;c:catch var="addCourseException"&gt; 
        ${courseBean.addCourse()} 
        &lt;/c:catch&gt; 
        &lt;c:choose&gt; 
          &lt;c:when test="${addCourseException != null}"&gt; 
          &lt;c:set var="errMsg" <br class="title-page-name"/>           value="${addCourseException.message}"/&gt; 
          &lt;/c:when&gt; 
          &lt;c:otherwise&gt; 
            &lt;c:redirect url="listCourse.jsp"/&gt; 
          &lt;/c:otherwise&gt; 
        &lt;/c:choose&gt; 
      &lt;/c:otherwise&gt; 
    &lt;/c:choose&gt; 
  &lt;/c:if&gt; 
 
  &lt;h2&gt;Add Course:&lt;/h2&gt; 
  &lt;c:if test="${errMsg != null}"&gt; 
    &lt;span style="color: red;"&gt; 
      &lt;c:out value="${errMsg}"&gt;&lt;/c:out&gt; 
    &lt;/span&gt; 
  &lt;/c:if&gt; 
  &lt;form method="post"&gt; 
    Name: &lt;input type="text" name="name"&gt; &lt;br&gt; 
    Credits : &lt;input type="text" name="credits"&gt; &lt;br&gt; 
    &lt;button type="submit" name="submit"&gt;Add&lt;/button&gt; 
  &lt;/form&gt; 
 
&lt;/body&gt; 
&lt;/html&gt; </pre>
<p class="calibre3">Run the page, either in Eclipse or outside (see <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>, to know how to run JSP in Eclipse and view it in Eclipse's internal browser) and add a couple of courses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting courses from database tables using JDBC</h1>
                
            
            <article>
                
<p class="calibre3">We will now modify <kbd class="calibre13">listCourses.jsp</kbd> to display the courses that we have added using <kbd class="calibre13">addCourse.jsp</kbd>. However, we first need to add a method in <kbd class="calibre13">CourseDAO</kbd> to get all courses from the database.</p>
<p class="calibre3">Note that the <kbd class="calibre13">Course</kbd> table has a one-to-many relationship with <kbd class="calibre13">Teacher</kbd>. It stores the teacher ID in it. Further, the teacher ID is not a required field, so a course can exist in the <kbd class="calibre13">Course</kbd> table with null <kbd class="calibre13">teacher_id</kbd>. To get all the details of a course, we need to get the teacher for the course too. However, we cannot create a simple join in an SQL query to get the details of a course and of the teacher for each course, because a teacher may not have been set for the course. In such cases, we use the <em class="calibre21">left outer join</em>, which returns all records from the table on the left-hand side of the join, but only matching records from the table on the right-hand side of the join. Here is the SQL statement to get all courses and teachers for each course:</p>
<pre class="calibre25">select course.id as courseId, course.name as courseName, 
  course.credits as credits, Teacher.id as teacherId, 
  Teacher.first_name as firstName,Teacher.last_name as lastName, 
  Teacher.designation designation 
from Course left outer join Teacher on 
course.Teacher_id = Teacher.id 
order by course.name </pre>
<p class="calibre3">We will use the preceding query in <kbd class="calibre13">CourseDAO</kbd> to get all courses. Open the <kbd class="calibre13">CourseDAO</kbd> class and add the following method:</p>
<pre class="calibre25">public List&lt;Course&gt; getCourses () throws SQLException { 
  //get connection from connection pool 
  Connection con = <br class="title-page-name"/> DatabaseConnectionFactory.getConnectionFactory().getConnection(); 
 
  List&lt;Course&gt; courses = new ArrayList&lt;Course&gt;(); 
  Statement stmt = null; 
  ResultSet rs = null; 
  try { 
    stmt = con.createStatement(); 
 
    //create SQL statement using left outer join 
    StringBuilder sb = new StringBuilder("select course.id as <br class="title-page-name"/>     courseId, course.name as courseName,")      .append("course.credits as credits, Teacher.id as teacherId, <br class="title-page-name"/>       Teacher.first_name as firstName, ")      .append("Teacher.last_name as lastName, Teacher.designation <br class="title-page-name"/>       designation ") 
      .append("from Course left outer join Teacher on ") 
      .append("course.Teacher_id = Teacher.id ") 
      .append("order by course.name"); 
 
//execute the query 
    rs = stmt.executeQuery(sb.toString()); 
 
//iterate over result set and create Course objects 
//add them to course list 
    while (rs.next()) { 
      Course course = new Course(); 
      course.setId(rs.getInt("courseId")); 
      course.setName(rs.getString("courseName")); 
      course.setCredits(rs.getInt("credits")); 
      courses.add(course); 
 
      int teacherId = rs.getInt("teacherId"); 
//check whether teacher id was null in the table 
      if (rs.wasNull()) //no teacher set for this course. 
        continue; 
      Teacher teacher = new Teacher(); 
      teacher.setId(teacherId); 
      teacher.setFirstName(rs.getString("firstName")); 
      teacher.setLastName(rs.getString("lastName")); 
      teacher.setDesignation(rs.getString("designation")); 
      course.setTeacher(teacher); 
    } 
 
    return courses; 
  } 
finally { 
  try {if (rs != null) rs.close();} catch (SQLException e) {} 
  try {if (stmt != null) stmt.close();} catch (SQLException e) {} 
  try {con.close();} catch (SQLException e) {} 
  } 
} </pre>
<p class="calibre3">We have used <kbd class="calibre13">Statement</kbd> to execute the query because it is a static query. We have used <kbd class="calibre13">StringBuilder</kbd> to build the SQL statement because it is a relatively large query (compared to those that we have written so far) and we would like to avoid concatenation of string objects, because Strings are immutable. After executing the query, we iterate over the resultset and create a <kbd class="calibre13">Course</kbd> object and add it to the list of courses, which is returned at the end.</p>
<p class="calibre3">One interesting thing here is the use of <kbd class="calibre13">ResultSet.wasNull</kbd>. We want to check whether the <kbd class="calibre13">teacher_id</kbd> field in the <kbd class="calibre13">Course</kbd> table for that particular row was null. Therefore, immediately after calling <kbd class="calibre13">rs.getInt("teacherId")</kbd>, we check whether the value fetched by <kbd class="calibre13">ResultSet</kbd> was null by calling <kbd class="calibre13">rs.wasNull</kbd>. If <kbd class="calibre13">teacher_id</kbd> was null, then the teacher was not set for that course, so we continue the loop, skipping the code to create a <kbd class="calibre13">Teacher</kbd> object.</p>
<p class="calibre3">In the final block, we catch an exception when closing <kbd class="calibre13">ResultSet</kbd>, <kbd class="calibre13">Statement</kbd>, and <kbd class="calibre13">Connection</kbd> and ignore it.</p>
<p class="calibre3">Let's now add a method in the <kbd class="calibre13">Course</kbd> bean to fetch courses by calling the <kbd class="calibre13">getCourses</kbd> method of <kbd class="calibre13">CourseDAO</kbd>. Open the <kbd class="calibre13">Course</kbd> bean and add the following method:</p>
<pre class="calibre25">public List&lt;Course&gt; getCourses() throws SQLException { 
  return courseDAO.getCourses(); 
} </pre>
<p class="calibre3">We are now ready to modify <kbd class="calibre13">listCourse.jsp</kbd> to display courses. Open the JSP and replace the existing code with the following:</p>
<pre class="calibre25">&lt;%@ page language="java" contentType="text/html; charset=UTF-8" 
    pageEncoding="UTF-8"%&gt; 
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; 
 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; 
&lt;html&gt; 
&lt;head&gt; 
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 
&lt;title&gt;Courses&lt;/title&gt; 
&lt;/head&gt; 
&lt;body&gt; 
  &lt;c:catch var="err"&gt; 
    &lt;jsp:useBean id="courseBean" <br class="title-page-name"/>     class="packt.book.jee.eclipse.ch4.bean.Course"/&gt; 
    &lt;c:set var="courses" value="${courseBean.getCourses()}"/&gt; 
  &lt;/c:catch&gt; 
  &lt;c:choose&gt; 
    &lt;c:when test="${err != null}"&gt; 
      &lt;c:set var="errMsg" value="${err.message}"/&gt; 
    &lt;/c:when&gt; 
    &lt;c:otherwise&gt; 
    &lt;/c:otherwise&gt; 
  &lt;/c:choose&gt; 
  &lt;h2&gt;Courses:&lt;/h2&gt; 
  &lt;c:if test="${errMsg != null}"&gt; 
    &lt;span style="color: red;"&gt; 
      &lt;c:out value="${errMsg}"&gt;&lt;/c:out&gt; 
    &lt;/span&gt; 
  &lt;/c:if&gt; 
  &lt;table&gt; 
    &lt;tr&gt; 
      &lt;th&gt;Id&lt;/th&gt; 
      &lt;th&gt;Name&lt;/th&gt; 
      &lt;th&gt;Credits&lt;/th&gt; 
      &lt;th&gt;Teacher&lt;/th&gt; 
    &lt;/tr&gt; 
    &lt;c:forEach items="${courses}" var="course"&gt; 
      &lt;tr&gt; 
        &lt;td&gt;${course.id}&lt;/td&gt; 
        &lt;td&gt;${course.name}&lt;/td&gt; 
        &lt;td&gt;${course.credits}&lt;/td&gt; 
        &lt;c:choose&gt; 
          &lt;c:when test="${course.teacher != null}"&gt; 
            &lt;td&gt;${course.teacher.firstName}&lt;/td&gt; 
          &lt;/c:when&gt; 
          &lt;c:otherwise&gt; 
            &lt;td&gt;&lt;/td&gt; 
          &lt;/c:otherwise&gt; 
        &lt;/c:choose&gt; 
      &lt;/tr&gt; 
    &lt;/c:forEach&gt; 
  &lt;/table&gt; 
&lt;/body&gt; 
&lt;/html&gt; </pre>
<p class="calibre3">Most of the code should be easy to understand because we have used similar code in previous examples. At the beginning of the script, we create a <kbd class="calibre13">Course</kbd> bean and get all the courses and assign the course list to a variable called <kbd class="calibre13">courses</kbd>:</p>
<pre class="calibre25">&lt;c:catch var="err"&gt; 
    &lt;jsp:useBean id="courseBean" <br class="title-page-name"/>     class="packt.book.jee.eclipse.ch4.bean.Course"/&gt; 
    &lt;c:set var="courses" value="${courseBean.getCourses()}"/&gt; 
&lt;/c:catch&gt; </pre>
<p class="calibre3">To display courses, we create a HTML table and set its headers. A new thing in the preceding code is the use of the <kbd class="calibre13">&lt;c:forEach&gt;</kbd> JSTL tag to iterate over the list. The <kbd class="calibre13">forEach</kbd> tag takes the following two attributes:</p>
<ul class="calibre10">
<li class="calibre11">List of objects</li>
<li class="calibre11">Variable name of a single item when iterating over the list</li>
</ul>
<p class="calibre3">In the preceding case, the list of objects is provided by the <kbd class="calibre13">courses</kbd> variable that we set at the beginning of the script and we identify a single item in the list with the variable name <kbd class="calibre13">course</kbd>. We then display the course details and teacher for the course, if any.</p>
<p class="calibre3">Writing code to add <kbd class="calibre13">Teacher</kbd> and <kbd class="calibre13">Student</kbd> and list them is left to readers as an exercise. The code would be very similar to that for <kbd class="calibre13">course</kbd>, but with different table and class names.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Completing add course functionality</h1>
                
            
            <article>
                
<p class="calibre3">We still haven't completed the functionality for adding a new course; we need to provide an option to assign a teacher to a course when adding a new course. Assuming that you have implemented <kbd class="calibre13">TeacherDAO</kbd> and created <kbd class="calibre13">addTeacher</kbd> and <kbd class="calibre13">getTeachers</kbd> methods in the <kbd class="calibre13">Teacher</kbd> bean, we can now complete the add course functionality.</p>
<p class="calibre3">First, modify <kbd class="calibre13">addCourse</kbd> in <kbd class="calibre13">CourseADO</kbd> to save the teacher ID for each course, if it is not zero. The SQL statement to insert course changes is as follows:</p>
<pre class="calibre25">String sql = "insert into Course (name, credits, Teacher_id) values (?,?,?)"; </pre>
<p class="calibre3">We have added the <kbd class="calibre13">Teacher_id</kbd> column and the corresponding parameter holder <kbd class="calibre13">?</kbd>. We will set <kbd class="calibre13">Teacher_id</kbd> to null if it is zero; or else the actual value:</p>
<pre class="calibre25">if (course.getTeacherId() == 0) 
  stmt.setNull(3, Types.INTEGER); 
else 
  stmt.setInt(3,course.getTeacherId()); </pre>
<p class="calibre3">We will then modify the <kbd class="calibre13">Course</kbd> bean to save the teacher ID that will be passed along with the <kbd class="calibre13">POST</kbd> request from the HTML form:</p>
<pre class="calibre25">public class Course { 
 
  private int teacherId; 
  public int getTeacherId() { 
    return teacherId; 
} 
  public void setTeacherId(int teacherId) { 
    this.teacherId = teacherId; 
  } 
} </pre>
<p class="calibre3">Next, we will modify <kbd class="calibre13">addCourse.jsp</kbd> to display the drop-down list of teachers when adding a new course. We first need to get the list of teachers. Therefore, we will create a <kbd class="calibre13">Teacher</kbd> bean and call the <kbd class="calibre13">getTeachers</kbd> method on it. We will do this just before the <span class="calibre12">Add Course</span> header:</p>
<pre class="calibre25">&lt;jsp:useBean id="teacherBean" class="packt.book.jee.eclipse.ch4.bean.Teacher"/&gt; 
&lt;c:catch var="teacherBeanErr"&gt; 
&lt;c:set var="teachers" value="${teacherBean.getTeachers()}"/&gt; 
&lt;/c:catch&gt; 
&lt;c:if test="${teacherBeanErr != null}"&gt; 
  &lt;c:set var="errMsg" value="${err.message}"/&gt; 
&lt;/c:if&gt; </pre>
<p class="calibre3">Finally, we will display the HTML drop-down list in the form and populate it with teacher names:</p>
<pre class="calibre25">Teacher : 
&lt;select name="teacherId"&gt; 
&lt;c:forEach items="${teachers}" var="teacher"&gt; 
&lt;option value="${teacher.id}"&gt;${teacher.firstName} 
&lt;/option&gt; 
&lt;/c:forEach&gt; 
&lt;/select&gt; </pre>
<p class="calibre3">Download the accompanying code for this chapter to see the complete source code of <kbd class="calibre13">CourseDAO</kbd> and <kbd class="calibre13">addCourse.jsp</kbd>.</p>
<p class="calibre3">With this, we conclude our discussion on using JDBC to create a web application that uses a database. With the examples that you have seen so far, you should be in a good position to complete the remaining application by adding functionality to modify and delete records in the database. The <kbd class="calibre13">update</kbd> and <kbd class="calibre13">delete</kbd> SQL statements can be executed by <kbd class="calibre13">Statement</kbd> or <kbd class="calibre13">PreparedStatement</kbd>, just as <kbd class="calibre13">insert</kbd> statements are executed using these two classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Eclipse Data Source Explorer</h1>
                
            
            <article>
                
<p class="calibre3">It is sometimes useful if you can see data in database tables from your IDE and can modify it. This is possible in Eclipse JEE using <span class="calibre12">Data Source Explorer</span>. This view is displayed in a tab at the lower pane, just below editors, in the <span class="calibre12">Java EE</span> perspective. If you do not see the view, or have closed the view, you can reopen it by selecting the <span class="calibre12">Window</span> | <span class="calibre12">Show View</span> | <span class="calibre12">Other</span> menu. Type <kbd class="calibre13">data source</kbd> in the filter textbox and you should see the view name under the <span class="calibre12">Data Management</span> group. Open the view:</p>
<div class="mce-root1"><img src="../images/00104.jpeg" class="calibre122"/></div>
<div class="packt_figure1">Figure 4.12: Data Source Explorer</div>
<p class="mce-root">Right-click on the <span class="calibre12">Database Connections</span> node and select <span class="calibre12">New</span>. From the list, select <span class="calibre12">MySQL</span>:</p>
<div class="mce-root1"><img src="../images/00105.jpeg" class="calibre123"/></div>
<div class="packt_figure1">Figure 4.13: Select the MySQL Connection Profile</div>
<p class="mce-root">Click <span class="calibre12">Next</span>. If the drivers list is empty, you haven't configured the driver yet. Click on the icon next to the drop-down list for drivers to open the configuration page:</p>
<div class="mce-root1"><img src="../images/00106.jpeg" class="calibre124"/></div>
<div class="packt_figure1">Figure 4.14: Selecting Database Driver in JDBC New Driver Definition page</div>
<p class="mce-root">Select the appropriate MySQL version and click on the <span class="calibre12">JAR List</span> tab:</p>
<p class="mce-root3"><img src="../images/00107.jpeg" class="calibre125"/></p>
<div class="packt_figure1">Figure 4.15: Adding Driver Files in JDBC New Driver Definition page</div>
<p class="calibre3">Remove any files from the <span class="calibre12">Driver files</span> list. Click on the <span class="calibre12">Add JAR/Zip...</span> button. This opens the <span class="calibre12">File Open</span> dialog. Select the JAR file for the MySQL driver version that you have selected. Since Maven has already downloaded the JAR file for you, you can select it from the local Maven repository. On OS X and Linux, the path is <kbd class="calibre13">~/.m2/repository/mysql/mysql-connector-java/&lt;version_num&gt;/mysql_connector_java_version_num/mysql-connector-java-version_num.jar</kbd> (<kbd class="calibre13">version_num</kbd> is a placeholder for the actual version number in the path). On Windows, you can find the Maven repository at <kbd class="calibre13">C:\Users\{your-username}\.m2</kbd> and then, the relative path for the MySQL driver is the same as that in OS X.</p>
<div class="packt_tip"><br class="calibre26"/>
If you have trouble finding the JAR in the local Maven repository, you can download the JAR file (for the MySQL JDBC driver) from <a href="http://dev.mysql.com/downloads/connector/j/." class="calibre17"><span class="calibre23">http://dev.mysql.com/downloads/connector/j/</span>.</a></div>
<p class="mce-root">Once you specify the correct driver JAR file, you need to set the following properties:</p>
<div class="mce-root1"><img src="../images/00108.jpeg" class="calibre126"/></div>
<div class="packt_figure1">Figure 4.16: Setting JDBC driver properties</div>
<p class="mce-root">Click <span class="calibre12">Next</span> and then <span class="calibre12">Finish</span>. A new database connection will be added in <span class="calibre12">Data Source Explorer</span>. You can now browse the database schema and tables:</p>
<div class="mce-root1"><img src="../images/00109.jpeg" class="calibre127"/></div>
<div class="packt_figure1">Figure 4.17: Browsing tables in Data Source Explorer</div>
<p class="mce-root">Right-click on any table to see the menu options available for different actions:</p>
<div class="mce-root1"><img src="../images/00110.jpeg" class="calibre128"/></div>
<div class="packt_figure1">Figure 4.18: Table menu options in Data Source Explorer</div>
<p class="calibre3">Select the <span class="calibre12">Edit</span> menu to open a page in the editor where you can see the existing records in the table. You can also modify or add new data in the same page. Select the <span class="calibre12">Load</span> option to load data from an external file into the table. Select the <span class="calibre12">Extract</span> option to export data from the table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating database applications using JPA</h1>
                
            
            <article>
                
<p class="calibre3">In the previous section, we learned how to create the <em class="calibre21">Course Management</em> application using JDBC and JSTL. In this section, we will build the same application using JPA and JSF. We have learned how to create a web application using JSF in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>. We will use much of that knowledge in this section.</p>
<p class="calibre3">As mentioned at the beginning of this chapter, JPA is an ORM framework, which is now part of the JEE specification. At the time of writing, it is in version 2.2. We will learn a lot about JPA as we develop our application.</p>
<p class="calibre3">Create the Maven project called <kbd class="calibre13">CourseManagementJPA</kbd> with group ID <kbd class="calibre13">packt.book.jee_eclipse</kbd> and artifact ID <kbd class="calibre13">CourseManagementJPA</kbd>. Eclipse JEE has great tools for creating applications using JPA, but you need to convert your project to a JPA project. We will see how to do this later in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating user interfaces for adding courses using JSF</h1>
                
            
            <article>
                
<p class="calibre3">Before we write any data access code using JPA, let's first create the user interface using JSF. As we have learned in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>, we need to add Maven dependencies for JSF. Add the following dependencies in <kbd class="calibre13">pom.xml</kbd>:</p>
<pre class="calibre25">  &lt;dependencies&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt; 
      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; 
      &lt;version&gt;3.1.0&lt;/version&gt; 
      &lt;scope&gt;provided&lt;/scope&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;com.sun.faces&lt;/groupId&gt; 
      &lt;artifactId&gt;jsf-api&lt;/artifactId&gt; 
      &lt;version&gt;2.2.16&lt;/version&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;com.sun.faces&lt;/groupId&gt; 
      &lt;artifactId&gt;jsf-impl&lt;/artifactId&gt; 
      &lt;version&gt;2.2.16&lt;/version&gt; 
    &lt;/dependency&gt; 
  &lt;/dependencies&gt; </pre>
<div class="packt_tip">When you run the application later, i<span class="calibre23">f Tomcat throws an exception for not finding <kbd class="calibre48">javax.faces.webapp.FacesServlet</kbd> then you may have to download <kbd class="calibre48">jsf-api-2.2.16.jar</kbd> (</span><a href="http://central.maven.org/maven2/com/sun/faces/jsf-api/2.2.16/jsf-api-2.2.16.jar" class="calibre17">http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar</a><span class="calibre23">), and <kbd class="calibre48">jsf-impl-2.2.16.jar</kbd> (</span><a href="http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar" class="calibre17">http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar</a><span class="calibre23"><span class="calibre23">), and copy them to the <kbd class="calibre48">&lt;tomcat-install-folder&gt;/lib</kbd> folder. Set scopes for these two libraries as provided: </span></span><kbd class="calibre48"><span class="calibre23">&lt;</span><span class="calibre23">scope</span><span class="calibre23">&gt;</span><span class="calibre23">provided</span><span class="calibre23">&lt;/</span><span class="calibre23">scope</span><span class="calibre23">&gt;</span></kbd> in <kbd class="calibre48">pom.xml</kbd>. <span class="calibre23">Then clean the project (<span class="calibre23">Run As</span></span> | <span class="calibre23"><span class="calibre23">Maven Clean</span>) and install it again (<span class="calibre23">Run As</span></span> | <span class="calibre23"><span class="calibre23">Maven Install</span>).</span></div>
<p class="calibre3">We need to add <kbd class="calibre13">web.xml</kbd>, add a declaration for the JSF servlet in it, and add the servlet mapping. Eclipse provides you a very easy way to add <kbd class="calibre13">web.xml</kbd> (which should be in the <kbd class="calibre13">WEB-INF</kbd> folder). Right-click on the project and select the <span class="calibre12">Java EE Tools</span> | <span class="calibre12">Generate Deployment Descriptor Stub</span> menu. This creates the <kbd class="calibre13">WEB-INF</kbd> folder under <kbd class="calibre13">src/main/webapp</kbd> and creates <kbd class="calibre13">web.xml</kbd> in the <kbd class="calibre13">WEB-INF</kbd> folder with the default content. Now, add the following servlet and mapping:</p>
<pre class="calibre25">  &lt;servlet&gt; 
    &lt;servlet-name&gt;JSFServlet&lt;/servlet-name&gt; 
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt; 
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 
  &lt;/servlet&gt; 
  &lt;servlet-mapping&gt; 
    &lt;servlet-name&gt;JSFServlet&lt;/servlet-name&gt; 
    &lt;url-pattern&gt;*.xhtml&lt;/url-pattern&gt; 
  &lt;/servlet-mapping&gt; </pre>
<p class="calibre3">Let's now create JavaBeans for <kbd class="calibre13">Course</kbd>, <kbd class="calibre13">Teacher</kbd>, <kbd class="calibre13">Student</kbd>, and <kbd class="calibre13">Person</kbd>, just as we created them in the previous example for JDBC. Create a <kbd class="calibre13">packt.book.jee.eclipse.ch4.jpa.bean</kbd> package and create the following JavaBeans.</p>
<p class="calibre3">Here is the source code of the <kbd class="calibre13">Course</kbd> bean (in <kbd class="calibre13">Course.java</kbd>):</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.jpa.bean; 
 
import java.io.Serializable; 
import javax.faces.bean.ManagedBean; 
import javax.faces.bean.RequestScoped; 
 
@ManagedBean (name="course") 
@RequestScoped 
public class Course implements Serializable { 
  private static final long serialVersionUID = 1L; 
 
  private int id; 
  private String name; 
  private int credits; 
  private Teacher teacher; 
 
  public int getId() { 
    return id; 
  } 
  public void setId(int id) { 
    this.id = id; 
  } 
  public String getName() { 
    return name; 
  } 
  public void setName(String name) { 
    this.name = name; 
  } 
  public int getCredits() { 
    return credits; 
  } 
  public void setCredits(int credits) { 
    this.credits = credits; 
  } 
  public boolean isValidCourse() { 
    return name != null &amp;&amp; credits != 0; 
  } 
  public Teacher getTeacher() { 
    return teacher; 
  } 
  public void setTeacher(Teacher teacher) { 
    this.teacher = teacher; 
  } 
} </pre>
<p class="calibre3">Here is the source code of the <kbd class="calibre13">Person</kbd> bean (in <kbd class="calibre13">Person.java</kbd>):</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.jpa.bean; 
 
import java.io.Serializable; 
 
public class Person implements Serializable{ 
  private static final long serialVersionUID = 1L; 
 
  private int id; 
  private String firstName; 
  private String lastName; 
 
  public int getId() { 
    return id; 
  } 
  public void setId(int id) { 
    this.id = id; 
  } 
  public String getFirstName() { 
    return firstName; 
  } 
  public void setFirstName(String firstName) { 
    this.firstName = firstName; 
  } 
  public String getLastName() { 
    return lastName; 
  } 
  public void setLastName(String lastName) { 
    this.lastName = lastName; 
  } 
} </pre>
<p class="calibre3">Here is the source code of the <kbd class="calibre13">Student</kbd> bean (in <kbd class="calibre13">Student.java</kbd>):</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.jpa.bean; 
 
import javax.faces.bean.ManagedBean; 
import javax.faces.bean.RequestScoped; 
import java.util.Date; 
 
 
@ManagedBean (name="student") 
@RequestScoped 
public class Student extends Person { 
  private static final long serialVersionUID = 1L; 
 
  private Date enrolledsince; 
 
  public Date getEnrolledsince() { 
    return enrolledsince; 
  } 
 
  public void setEnrolledsince(Date enrolledsince) { 
    this.enrolledsince = enrolledsince; 
  } 
} </pre>
<p class="calibre3">And, finally, here is the source code of the <kbd class="calibre13">Teacher</kbd> bean (in <kbd class="calibre13">Teacher.java</kbd>):</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.jpa.bean; 
 
import javax.faces.bean.ManagedBean; 
import javax.faces.bean.RequestScoped; 
 
@ManagedBean (name="teacher") 
@RequestScoped 
public class Teacher extends Person { 
  private static final long serialVersionUID = 1L; 
 
  private String designation; 
 
  public String getDesignation() { 
    return designation; 
  } 
 
  public void setDesignation(String designation) { 
    this.designation = designation; 
  } 
  public boolean isValidTeacher() { 
    return getFirstName() != null; 
  } 
} </pre>
<div class="packt_infobox"><br class="calibre26"/>
All are JSF managed beans in <kbd class="calibre48">RequestScope</kbd>. Refer to the JSF discussion in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre17"><span class="calibre23">Chapter 2</span></a>, <em class="calibre129">Creating a Simple JEE Web Application</em>, for more about managed beans and scopes.</div>
<p class="calibre3">These beans are now ready to use in JSF pages. Create a JSF page and name it <kbd class="calibre13">addCourse.xhtml</kbd> and add the following content:</p>
<pre class="calibre25">&lt;html  
     
    &gt; 
 
  &lt;h2&gt;Add Course:&lt;/h2&gt; 
  &lt;h:form&gt; 
    &lt;h:outputLabel value="Name:" for="name"/&gt; 
      &lt;h:inputText value="#{course.name}" id="name"/&gt; &lt;br/&gt; 
    &lt;h:outputLabel value="Credits:" for="credits"/&gt; 
      &lt;h:inputText value="#{course.credits}" id="credits"/&gt; 
    &lt;br/&gt; 
    &lt;h:commandButton value="Add" action=" <br class="title-page-name"/>     #{courseServiceBean.addCourse} "/&gt; 
  &lt;/h:form&gt; 
 
&lt;/html&gt; </pre>
<p class="calibre3">The page uses JSF tags and managed beans to get and set values. Notice the value of the <kbd class="calibre13">action</kbd> attribute of the <kbd class="calibre13">h:commandButton</kbd> tag—it is the <kbd class="calibre13">courseServiceBean.addCourse</kbd> method, which will be called when the <span class="calibre12">Add</span> button is clicked. In the application that we created using JDBC, we wrote code to interact with DAOs in the JavaBeans. For example, the <kbd class="calibre13">Course</kbd> bean had the <kbd class="calibre13">addCourse</kbd> method. However, in the JPA project we will handle it differently. We will create service bean classes (they are also managed beans, just like <kbd class="calibre13">Course</kbd>) to interact with the data access objects and have the <kbd class="calibre13">Course</kbd> bean contain only the values set by the user.</p>
<p class="calibre3">Create a package named <kbd class="calibre13">packt.book.jee.eclipse.ch4.jpa.service_bean</kbd>. Create the class named <kbd class="calibre13">CourseServiceBean</kbd> in this package with the following code:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.jpa.service_bean; 
 
import javax.faces.bean.ManagedBean; 
import javax.faces.bean.ManagedProperty; 
import javax.faces.bean.RequestScoped; 
 
import packt.book.jee.eclipse.ch4.jpa.bean.Course; 
 
@ManagedBean(name="courseServiceBean") 
@RequestScoped 
public class CourseServiceBean { 
  @ManagedProperty(value="#{course}") 
  private Course course; 
 
  private String errMsg= null; 
 
  public Course getCourse() { 
    return course; 
  } 
 
  public void setCourse(Course course) { 
    this.course = course; 
  } 
 
  public String getErrMsg() { 
    return errMsg; 
  } 
 
  public void setErrMsg(String errMsg) { 
    this.errMsg = errMsg; 
  } 
 
  public String addCourse() { 
    return "listCourse"; 
  } 
} </pre>
<p class="calibre3"><kbd class="calibre13">CourseServiceBean</kbd> is a managed bean and it contains the <kbd class="calibre13">errMsg</kbd> field (to store any error message during the processing of requests), the <kbd class="calibre13">addCourse</kbd> method, and the <kbd class="calibre13">course</kbd> field (which is annotated with <kbd class="calibre13">@ManagedProperty</kbd>).</p>
<p class="calibre3">The <kbd class="calibre13">ManagedProperty</kbd> annotation tells the JSF implementation to inject another bean (specified as the <kbd class="calibre13">value</kbd> attribute) in the current bean. Here, we expect <kbd class="calibre13">CourseServiceBean</kbd> to have access to the <kbd class="calibre13">course</kbd> bean at runtime, without instantiating it. This is part of the <strong class="calibre5">dependency injection</strong> (<strong class="calibre5">DI</strong>) framework supported by Java EE. We will learn more about the DI framework in Java EE in later chapters. The <kbd class="calibre13">addCourse</kbd> function doesn't do much at this point, it just returns the <kbd class="calibre13">"listCourse"</kbd> string. If you want to execute <kbd class="calibre13">addCourse.xhtml</kbd> at this point, create a <kbd class="calibre13">listCourse.xml</kbd> file with some placeholder content and test <kbd class="calibre13">addCourse.xhtml</kbd>. We will add more content to <kbd class="calibre13">listCourse.xml</kbd> later in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">JPA concepts</h1>
                
            
            <article>
                
<p class="calibre3">JPA is an ORM framework in JEE. It provides a set of APIs that the JPA implementation providers are expected to implement. There are many JPA providers, such as <strong class="calibre5">EclipseLink</strong> (<a href="https://eclipse.org/eclipselink/" class="calibre9"><span>https://eclipse.org/eclipselink/</span></a>), <strong class="calibre5">Hibernate JPA</strong> (<a href="http://hibernate.org/orm/" class="calibre9"><span>http://hibernate.org/orm/</span></a>), and <strong class="calibre5">OpenJPA</strong> (<a href="http://openjpa.apache.org/" class="calibre9"><span>http://openjpa.apache.org/</span></a>). Before we start writing the persistence code using JPA, it is important to understand basic concepts of JPA.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Entity</h1>
                
            
            <article>
                
<p class="calibre3">Entity represents a single object instance that is typically related to one table. Any <strong class="calibre5">Plain Old Java Object</strong> (<strong class="calibre5">POJO</strong>) can be converted to an entity by annotating the class with <kbd class="calibre13">@Entity</kbd>. Members of the class are mapped to columns of a table in the database. Entity classes are simple Java classes, so they can extend or include other Java classes or even another JPA entity. We will see an example of this in our application. You can also specify validation rules for members of the Entity class; for example, you can mark a member as not null using the <kbd class="calibre13">@NotNull</kbd> annotation. These annotations are provided by Java EE Bean Validation APIs. See <a href="https://javaee.github.io/tutorial/bean-validation002.html#GIRCZ" class="calibre9">https://javaee.github.io/tutorial/bean-validation002.html#GIRCZ</a> for a list of validation annotations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">EntityManager</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">EntityManager</kbd> provides the persistence context in which the entities exist. The persistence context also allows you to manage transactions. Using <kbd class="calibre13">EntityManager</kbd> APIs, you can perform query and write operations on entities. The entity manager can be web-container-managed (in which case an instance of <kbd class="calibre13">EntityManager</kbd> is injected by the container), or application-managed. In this chapter, we are going to look at application-managed entity managers. We will visit container-managed entity managers in <a target="_blank" href="part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre21">Creating JEE Applications with EJB</em>, when we learn about EJBs. The persistence unit of the entity manager defines the database connectivity information and groups entities that become part of the persistence unit. It is defined in the configuration file called <kbd class="calibre13">persistence.xml</kbd> and is expected to be in <kbd class="calibre13">META-INF</kbd> in the class path.</p>
<p class="calibre3"><kbd class="calibre13">EntityManager</kbd> has its own persistence context, which is a cache of entities. Updates to entities are first done in the cache and then pushed to the database when a transaction is committed or when the data is explicitly pushed to the database.</p>
<p class="calibre3">When an application is managing <kbd class="calibre13">EntityManager</kbd>, it is advisable to have only one instance of <kbd class="calibre13">EntityManager</kbd> for a persistence unit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">EntityManagerFactory</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">EntityManagerFactory</kbd> creates <kbd class="calibre13">EntityManager</kbd>. <kbd class="calibre13">EntityManagerFactory</kbd> itself is obtained by calling a static <kbd class="calibre13">Persistence.createEntityManagerFactory</kbd> method. An argument to this function is a <kbd class="calibre13">persistence-unit</kbd> name that you have specified in <kbd class="calibre13">persistence.xml</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a JPA application</h1>
                
            
            <article>
                
<p class="calibre3">The following are the typical steps in creating a JPA application:</p>
<ol class="calibre14">
<li value="1" class="calibre11">Create a database schema (tables and relationships). Optionally, you can create tables and relationships from JPA entities. We will see an example of this. However, it should be mentioned here that although creating tables from JPA entities is fine for development, it is not recommended in the production environment; doing so may result in a non-optimized database model.</li>
<li value="2" class="calibre11">Create <kbd class="calibre13">persistence.xml</kbd> and specify the database configurations.</li>
<li value="3" class="calibre11">Create entities and relationships.</li>
<li value="4" class="calibre11">Get an instance of <kbd class="calibre13">EntityManagerFactory</kbd> by calling <kbd class="calibre13">Persistence.createEntityManagerFactory</kbd>.</li>
<li value="5" class="calibre11">Create an instance of <kbd class="calibre13">EntityManager</kbd> from <kbd class="calibre13">EntityManagerFactory</kbd>.</li>
<li value="6" class="calibre11">Start a transaction on <kbd class="calibre13">EntityManager</kbd> if you are performing <kbd class="calibre13">insert</kbd> or <kbd class="calibre13">update</kbd> operations on the entity.</li>
<li value="7" class="calibre11">Perform operations on the entity.</li>
<li value="8" class="calibre11">Commit the transaction.</li>
</ol>
<p class="calibre3">Here is an example snippet:</p>
<pre class="calibre25">EntityManagerFactory factory = <br class="title-page-name"/> Persistance.Persistence.createEntityManagerFactory("course_management") 
EntityManager entityManager = factory.createEntityManager(); 
EntityTransaction txn = entityManager.getTransaction(); 
txn.begin(); 
entityManager. persist(course); 
txn.commit(); </pre>
<p class="calibre3">You can find a description of JPA annotations at <a href="http://www.eclipse.org/eclipselink/documentation/2.7/jpa/extensions/annotations_ref.htm" class="calibre9">http://www.eclipse.org/eclipselink/documentation/2.7/jpa/extensions/annotations_ref.htm</a>.<br class="calibre6"/>
JPA tools in Eclipse EE make adding many of the annotations very easy, as we will see in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a new MySQL schema</h1>
                
            
            <article>
                
<p class="calibre3">For this example, we will create a separate MySQL schema (we won't use the same schema that we created for the JDBC application, although it is possible to do so). Open MySQL Workbench and connect to your MySQL database (see <a target="_blank" href="part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre21">Introducing JEE and Eclipse</em>, if you do not know how to connect to the MySQL database from MySQL Workbench).</p>
<p class="mce-root">Right-click in the <span class="calibre12">Schema</span> window and select <span class="calibre12">Create Schema...</span>:</p>
<div class="mce-root1"><img src="../images/00111.jpeg" class="calibre130"/></div>
<div class="packt_figure1">Figure 4.19: Creating a new MySQL schema</div>
<p class="calibre3">Name the new schema <kbd class="calibre13">course_management_jpa</kbd> and click <span class="calibre12">Apply</span>. We are going to use this schema for the JPA application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up a Maven dependency for JPA</h1>
                
            
            <article>
                
<p class="calibre3">In this example, we will use the EclipseLink (<a href="https://eclipse.org/eclipselink/" class="calibre9"><span>https://eclipse.org/eclipselink/</span></a>) JPA implementation. We will use the MySQL JDBC driver and Bean Validation framework for validating members of entities. Finally, we will use Java annotations provided by JSR0250. So, let's add Maven dependencies for all these:</p>
<pre class="calibre25">      &lt;dependency&gt; 
        &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; 
        &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; 
        &lt;version&gt;2.5.2&lt;/version&gt; 
      &lt;/dependency&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;mysql&lt;/groupId&gt; 
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; 
        &lt;version&gt;5.1.34&lt;/version&gt; 
      &lt;/dependency&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;javax.validation&lt;/groupId&gt; 
        &lt;artifactId&gt;validation-api&lt;/artifactId&gt; 
        &lt;version&gt;1.1.0.Final&lt;/version&gt; 
      &lt;/dependency&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;javax.annotation&lt;/groupId&gt; 
        &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; 
        &lt;version&gt;1.0&lt;/version&gt; 
      &lt;/dependency&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting a project into a JPA project</h1>
                
            
            <article>
                
<p class="calibre3">Many JPA tools become active in Eclipse JEE only if the project is a JPA project. Although we have created a Maven project, it is easy to add an Eclipse JPA facet to it:</p>
<ol class="calibre14">
<li class="calibre11" value="1"><span>Right-click on the project and select</span> <span>Configure</span> <span>|</span> <span>Convert to JPA Project</span><span>:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00112.jpeg" class="calibre131"/></div>
<div class="packt_figure1">Figure 4.20: Addding a JPA facet to a project</div>
<ol start="2" class="calibre14">
<li value="2" class="calibre11">Make sure JPA is selected.</li>
<li value="3" class="calibre11">On the next page, select <span>EclipseLink 2.5.x</span> as the platform.</li>
<li value="4" class="calibre11">For the JPA implementation type, select <span>Disable Library Configuration</span>.</li>
</ol>
<ol start="5" class="calibre14">
<li value="5" class="calibre11">The drop-down list for <span>Connection</span> <span>lists any connections you might have configured in </span><span>Data Source Explorer</span><span>. For now, do not select any connection. At the bottom of the page, select the </span><span>Discover annotated classes automatically</span> <span>option:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00113.jpeg" class="calibre132"/></div>
<div class="packt_figure1">Figure 4.21: Configuring a JPA facet </div>
<ol start="6" class="calibre14">
<li value="6" class="calibre11">Click <span>Finish</span>.</li>
<li value="7" class="calibre11">Notice that the <span>JPA Content</span> group is created under the project and <kbd class="calibre13">persistence.xml</kbd> is created in it. Open <kbd class="calibre13">persistence.xml</kbd> in the editor.</li>
<li value="8" class="calibre11">Click on the <span>Connection</span> tab and change <span>Transaction type</span> to <span>Resource Local</span>. We have selected <span>Resource Local</span> because, in this chapter, we are going to manage <kbd class="calibre13">EntityManager</kbd>. If you want the JEE container to manage <kbd class="calibre13">EntityManager</kbd>, then you should set <span>Transaction type</span> to <span>JTA</span>. We will see an example of the JTA transaction type in <a target="_blank" href="part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre2">Creating JEE Application with EJB</em>.</li>
<li value="9" class="calibre11">Enter EclipseLink connection pool attributes as shown in the following screenshot and save the file:</li>
</ol>
<div class="packt_figure2"><img src="../images/00114.jpeg" class="calibre133"/></div>
<div class="packt_figure1">Figure 4.22: Setting up Persistence Unit Connection</div>
<ol start="10" class="calibre14">
<li value="10" class="calibre11">Next, click on the <span>Schema Generation</span> tab. Here, we will set the options to generate database tables and relationships from entities. Select the options as shown in the following screenshot:</li>
</ol>
<div class="mce-root1"><img src="../images/00115.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 4.23: Setting up Schema Generation options of Persistence Unit</div>
<p class="calibre3">Here is the content of the <kbd class="calibre13">persistence.xml</kbd> file after setting the preceding options:</p>
<pre class="calibre25">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;persistence version="2.1"   xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"&gt; 
  &lt;persistence-unit name="CourseManagementJPA" transaction-type="RESOURCE_LOCAL"&gt; 
    &lt;properties&gt; 
      &lt;property name="javax.persistence.jdbc.driver" <br class="title-page-name"/>       value="com.mysql.jdbc.Driver"/&gt;      &lt;property name="javax.persistence.jdbc.url" <br class="title-page-name"/>       value="jdbc:mysql://localhost/course_management_jpa"/&gt; 
      &lt;property name="javax.persistence.jdbc.user" value="root"/&gt; 
      &lt;property name="javax.persistence.schema- <br class="title-page-name"/>       generation.database.action" value="create"/&gt;      &lt;property name="javax.persistence.schema- <br class="title-page-name"/>       generation.scripts.action" value="create"/&gt; 
&lt;property name="eclipselink.ddl-generation" value="create- tables"/&gt; 
      &lt;property name="eclipselink.ddl-generation.output-mode" value="both"/&gt; 
    &lt;/properties&gt; 
  &lt;/persistence-unit&gt; 
&lt;/persistence&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating entities</h1>
                
            
            <article>
                
<p class="calibre3">We have already created JavaBeans for <kbd class="calibre13">Course</kbd>, <kbd class="calibre13">Person</kbd>, <kbd class="calibre13">Student</kbd>, and <kbd class="calibre13">Teacher</kbd>. We will now convert them to JPA entities using the <kbd class="calibre13">@Entity</kbd> annotation. Open <kbd class="calibre13">Course.java</kbd> and add the following annotations:</p>
<pre class="calibre25">@ManagedBean (name="course") 
@RequestScoped 
@Entity 
public class Course implements Serializable </pre>
<p class="calibre3">The same bean can act as a managed bean for JSF and an entity for JPA. Note that if the name of the class is different from the table name in the database, you will need to specify a <kbd class="calibre13">name</kbd> attribute of the <kbd class="calibre13">@Entity</kbd> annotation. For example, if our <kbd class="calibre13">Course</kbd> table were called <kbd class="calibre13">SchoolCourse</kbd>, then the entity declaration would be as follows:</p>
<pre class="calibre25">@Entity(name="SchoolCourse") </pre>
<p class="calibre3">To specify the primary key of the <kbd class="calibre13">Entity</kbd>, use the <kbd class="calibre13">@Id</kbd> annotation. In the <kbd class="calibre13">Course</kbd> table, <kbd class="calibre13">id</kbd> is the primary key and is autogenerated. To indicate autogeneration of the value, use the <kbd class="calibre13">@GeneratedValue</kbd> annotation. Use the <kbd class="calibre13">@column</kbd> annotation to indicate that the member variable corresponds to a column in the table. So, the annotations for <kbd class="calibre13">id</kbd> are as follows:</p>
<pre class="calibre25">@Id 
@GeneratedValue(strategy=GenerationType.IDENTITY) 
@Column(name="id") 
private int id; </pre>
<p class="calibre3">You can specify validations for a column using Bean Validation framework annotations, as mentioned earlier. For example, the course name should not be null:</p>
<pre class="calibre25">@NotNull 
@Column(name="name") 
private String name; </pre>
<p class="calibre3">Furthermore, the minimum value of credits should be <kbd class="calibre13">1</kbd>:</p>
<pre class="calibre25">@Min(1) 
@Column(name="credits") 
private int credits;</pre>
<div class="packt_infobox"><br class="calibre26"/>
In the preceding examples, the <kbd class="calibre48">@Column</kbd> annotation is not required to specify the name of the column if the field name is the same as the column name.</div>
<p class="calibre3">If you are using JPA entities to create tables and want to exactly specify the type of columns, then you can use the <kbd class="calibre13">columnDefinition</kbd> attribute of the <kbd class="calibre13">@Column</kbd> annotation; for example, to specify a column of type <kbd class="calibre13">varchar</kbd> with length <kbd class="calibre13">20</kbd>, you could use <kbd class="calibre13">@Column(columnDefinition="VARCHAR(20)")</kbd>.</p>
<div class="packt_tip"><br class="calibre26"/>
Refer to <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html" class="calibre17">https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html</a> to see all the attributes of the <kbd class="calibre48">@Column</kbd> annotation.</div>
<p class="calibre3">We will add more annotations to <kbd class="calibre13">Course Entity</kbd> as needed later. For now, let's turn our attention to the <kbd class="calibre13">Person</kbd> class. This class is the parent class of the <kbd class="calibre13">Student</kbd> and <kbd class="calibre13">Teacher</kbd> classes. However, in the database, there is no <kbd class="calibre13">Person</kbd> table and all the fields of <kbd class="calibre13">Person</kbd> and <kbd class="calibre13">Student</kbd> are in the <kbd class="calibre13">Student</kbd> table; and the same for the <kbd class="calibre13">Teacher</kbd> table. So, how do we model this in JPA? Well, JPA supports inheritance of entities and provides control over how they should be mapped to database tables. Open the <kbd class="calibre13">Person</kbd> class and add the following annotations:</p>
<pre class="calibre25">@Entity 
@Inheritance(strategy=TABLE_PER_CLASS) 
public abstract class Person implements Serializable { ... </pre>
<p class="calibre3">We are not only identifying the <kbd class="calibre13">Person</kbd> class as <kbd class="calibre13">Entity</kbd>, but we are also indicating that it is used for inheritance (using <kbd class="calibre13">@Inheritance</kbd>). The inheritance strategy decides how tables are mapped to classes. There are three possible strategies:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">SINGLE_TABLE</kbd>: In this case, fields of parent and child classes would be mapped to the table of the parent class. If we use this strategy, then the fields of <kbd class="calibre13">Person</kbd>, <kbd class="calibre13">Student</kbd>, and <kbd class="calibre13">Teacher</kbd> will be mapped to the table for the <kbd class="calibre13">Person</kbd> entity.</li>
<li class="calibre11"><kbd class="calibre13">TABLE_PER_CLASS</kbd>: In this case, each concrete class (non-abstract class) is mapped to a table in the database. All fields of the parent class are also mapped to the table for the child class. For example, all fields of <kbd class="calibre13">Person</kbd> and <kbd class="calibre13">Student</kbd> will be mapped to columns in the <kbd class="calibre13">Student</kbd> table. Since <kbd class="calibre13">Person</kbd> is marked as abstract, no table will be mapped by the <kbd class="calibre13">Person</kbd> class. It exists only to provide inheritance support in the application.</li>
<li class="calibre11"><kbd class="calibre13">JOINED</kbd>: In this case, the parent and its children are mapped to separate tables. For example, <kbd class="calibre13">Person</kbd> will be mapped to the <kbd class="calibre13">Person</kbd> table, and <kbd class="calibre13">Student</kbd> and <kbd class="calibre13">Teacher</kbd> will be mapped to the corresponding tables in the database.</li>
</ul>
<p class="calibre3">As per the schema that we created for the JDBC application, we have <kbd class="calibre13">Student</kbd> and <kbd class="calibre13">Teacher</kbd> tables with all the required columns and there is no <kbd class="calibre13">Person</kbd> table. Therefore, we have selected the <kbd class="calibre13">TABLE_PER_CLASS</kbd> strategy here.</p>
<div class="packt_infobox"><br class="calibre26"/>
See more information about entity inheritance in JPA at <a href="https://javaee.github.io/tutorial/persistence-intro003.html#BNBQN" class="calibre17">https://javaee.github.io/tutorial/persistence-intro003.html#BNBQN</a>.</div>
<p class="calibre3">The fields <kbd class="calibre13">id</kbd>, <kbd class="calibre13">firstName</kbd>, and <kbd class="calibre13">lastName</kbd> in the <kbd class="calibre13">Person</kbd> table are shared by <kbd class="calibre13">Student</kbd> and <kbd class="calibre13">Teacher</kbd>. Therefore, we need to mark them as columns in the tables and set the primary key. So, add the following annotations to the fields in the <kbd class="calibre13">Person</kbd> class:</p>
<pre class="calibre25">  @Id 
  @GeneratedValue(strategy=GenerationType.IDENTITY) 
  @Column(name="id") 
  private int id; 
 
  @Column(name = "first_name") 
  @NotNull 
  private String firstName; 
 
  @Column(name = "last_name") 
  private String lastName; </pre>
<p class="calibre3">Here, column names in the table do not match class fields. Therefore, we have to specify the name attribute in <kbd class="calibre13">@Column</kbd> annotations.</p>
<p class="calibre3">Let's now mark the <kbd class="calibre13">Student</kbd> class as <kbd class="calibre13">Entity</kbd>:</p>
<pre class="calibre25">@Entity 
@ManagedBean (name="student") 
@RequestScoped 
public class Student extends Person implements Serializable</pre>
<p class="calibre3">The <kbd class="calibre13">Student</kbd> class has a <kbd class="calibre13">Date</kbd> field called <kbd class="calibre13">enrolledSince</kbd>, which is of the <kbd class="calibre13">java.util.Date</kbd> type. However, JDBC and JPA use the <kbd class="calibre13">java.sql.Date</kbd> type. If you want JPA to automatically convert <kbd class="calibre13">java.sql.Date</kbd> to <kbd class="calibre13">java.util.Date</kbd>, then you need to mark the field with the <kbd class="calibre13">@Temporal</kbd> annotation:</p>
<pre class="calibre25">@Temporal(DATE) 
@Column(name="enrolled_since") 
private Date enrolledSince; </pre>
<p class="calibre3">Open the <kbd class="calibre13">Teacher</kbd> class and add the <kbd class="calibre13">@Entity</kbd> annotation to it:</p>
<pre class="calibre25">@Entity 
@ManagedBean (name="teacher") 
@RequestScoped 
public class Teacher extends Person implements Serializable </pre>
<p class="calibre3">Then, map the <kbd class="calibre13">designation</kbd> field in the class:</p>
<pre class="calibre25">@NotNull 
@Column(name="designation") 
private String designation; </pre>
<p class="calibre3">We have now added annotations for all tables and their fields that do not participate in table relationships. We will now model the relationships between tables in our classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring entity relationships</h1>
                
            
            <article>
                
<p class="calibre3">First, we will model the relationship between <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd>. There is a one-to-many relationship between them: one teacher may teach a number of courses. Open <kbd class="calibre13">Course.java</kbd> in the editor. Open the JPA perspective in Eclipse JEE (<span class="calibre12">Window</span> | <span class="calibre12">Open Perspective</span> | <span class="calibre12">JPA</span> menu).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring many-to-one relationships</h1>
                
            
            <article>
                
<p class="calibre3">With <kbd class="calibre13">Course.java</kbd> open in the editor, click on the <span class="calibre12">JPA Details</span> tab in the <span class="calibre12"><span class="calibre12">lower </span></span>window (just below the editor window). In <kbd class="calibre13">Course.java</kbd>, click on the <kbd class="calibre13">teacher</kbd> member variable. The <span class="calibre12">JPA Details</span> tab shows the details of this attribute:</p>
<div class="mce-root1"><img src="../images/00116.jpeg" class="calibre134"/></div>
<div class="packt_figure1">Figure 4.24: JPA details of an entity attribute</div>
<p class="calibre3"><span class="calibre12">Target entity</span> is auto-selected (as <kbd class="calibre13">Teacher</kbd>) because we have marked <kbd class="calibre13">Teacher</kbd> as an entity and the type of the <kbd class="calibre13">teacher</kbd> field is <kbd class="calibre13">Teacher</kbd>.</p>
<p class="calibre3">However, Eclipse has assumed a one-to-one relationship between <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd>, which is not correct. There is a many-to-one relationship between <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd>. To change this, click on the (<span class="calibre12">one_to_one</span>) hyperlink at the top of the <span class="calibre12">JPA Details</span> view and select the <span class="calibre12">Many To One</span> in <span class="calibre12">Mapping Type Selection</span> dialog box.</p>
<p class="calibre3">Select only <span class="calibre12">Merge</span> and <span class="calibre12">Refresh</span> cascade options; otherwise, duplicate entries will be added in the <kbd class="calibre13">Teacher</kbd> table for every <kbd class="calibre13">Teacher</kbd> that you selected for a <kbd class="calibre13">Course</kbd>.</p>
<div class="packt_tip"><br class="calibre26"/>
See <a href="https://javaee.github.io/tutorial/persistence-intro002.html#BNBQH" class="calibre17">https://javaee.github.io/tutorial/persistence-intro002.html#BNBQH</a> for more details on entity relationships and cascade options.</div>
<p class="calibre3">When you select <span class="calibre12">Merge</span> and <span class="calibre12">Refresh</span> cascade options, the <kbd class="calibre13">cascade</kbd> attribute added to the annotation is added to the <kbd class="calibre13">teacher</kbd> field in the <kbd class="calibre13">Course</kbd> entity:</p>
<pre class="calibre25">  @ManyToOne(cascade = { MERGE, REFRESH }) 
  private Teacher teacher; </pre>
<p class="mce-root">Scroll down the <span class="calibre12">JPA Details</span> page to see <span class="calibre12">Joining Strategy</span>. This determines how columns in <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd> tables are joined:</p>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00117.jpeg" class="calibre135"/></div>
<div class="packt_figure1">Figure 4.25: Editing Joining Strategy in an entity relationship</div>
<p class="mce-root">Note that the default joining strategy is that the <kbd class="calibre13">teacher_id</kbd> column in the <kbd class="calibre13">Course</kbd> table maps to the <kbd class="calibre13">id</kbd> column in the <kbd class="calibre13">Teacher</kbd> table. Eclipse has just guessed <kbd class="calibre13">teacher_id</kbd> (the appended <kbd class="calibre13">id</kbd> to the <kbd class="calibre13">teacher</kbd> field in the <kbd class="calibre13">Course</kbd> entity), but if we had a different join column in the <kbd class="calibre13">Course</kbd> table, for example, <kbd class="calibre13">teacherId</kbd>, then we would need to override the default join columns. Click on the <span class="calibre12">Override default</span> checkbox and then on the <span class="calibre12">Edit</span> button on the right-hand side of the textbox:<br class="calibre6"/>
<br class="calibre6"/>
<img src="../images/00118.jpeg" class="calibre136"/></p>
<div class="packt_figure1">Figure 4.26: Editing Join Column</div>
<p class="calibre3">In our case, the default options match the table columns, so we will keep them unchanged. When you select the <span class="calibre12">Override default</span> checkbox, the <kbd class="calibre13">@JoinColumn</kbd> annotation is added to the <kbd class="calibre13">teacher</kbd> field in the <kbd class="calibre13">Course</kbd> entity:</p>
<pre class="calibre25">  @JoinColumn(name = "teacher_id", referencedColumnName = "id") 
  @ManyToOne(cascade = { MERGE, REFRESH }) 
  private Teacher teacher; </pre>
<p class="calibre3">All the required annotations for the <kbd class="calibre13">teacher</kbd> field are now added.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring many-to-many relationships</h1>
                
            
            <article>
                
<p class="calibre3">We will now configure <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Student</kbd> entities for a many-to-many relationship (a course can have many students, and one student can take many courses).</p>
<p class="calibre3">Many-to-many relations could be unidirectional or bidirectional. For example, you may only want to track students enrolled in the courses (so the <kbd class="calibre13">Course</kbd> entity will have a list of students) and not students taking the courses (the <kbd class="calibre13">Student</kbd> entity does not keep a list of courses). This is an unidirectional relationship where only the <kbd class="calibre13">Course</kbd> entity knows about the students, but the <kbd class="calibre13">Student</kbd> entity does not know about the courses).</p>
<p class="calibre3">In a bidirectional relationship, each entity knows about the other one. Therefore, the <kbd class="calibre13">Course</kbd> entity will keep a list of students and the <kbd class="calibre13">Student</kbd> entity will keep a list of courses. We will configure the bidirectional relationship in this example.</p>
<p class="calibre3">A many-to-many relationship also has one owning side and the other inverse side. You can mark either entity in the relationship as the owning entity. From the configuration point of view, the inverse side is marked by the <kbd class="calibre13">mappedBy</kbd> attribute to the <kbd class="calibre13">@ManyToMany</kbd> annotation.</p>
<p class="calibre3">In our application, we will make <kbd class="calibre13">Student</kbd> as the owning side of the relationship and <kbd class="calibre13">Course</kbd> as the inverse side. A many-to-many relationship in the database needs a join table, which is configured in the owning entity using the <kbd class="calibre13">@JoinTable</kbd> annotation.</p>
<p class="calibre3">We will first configure a many-to-many relationship in the <kbd class="calibre13">Course</kbd> entity. Add a member variable in <kbd class="calibre13">Course</kbd> to hold a list of <kbd class="calibre13">Student</kbd> entities and add the getter and the setter for it:</p>
<pre class="calibre25">private List&lt;Student&gt; students; 
public List&lt;Student&gt; getStudents() { 
  return students; 
} 
public void setStudents(List&lt;Student&gt; students) { 
  this.students = students; 
} </pre>
<p class="mce-root">Then, click on the <kbd class="calibre13">students</kbd> field (added previously) and notice the settings in the <span class="calibre12">JPA Details</span> view:</p>
<div class="mce-root1"><img src="../images/00119.jpeg" class="calibre91"/></div>
<div class="packt_figure1">Figure 4.27: Default JPA details for the students field in Course Entity</div>
<p class="mce-root">Because the <kbd class="calibre13">students</kbd> field is a list of <kbd class="calibre13">Student</kbd> entities, Eclipse has assumed a one-to-many relationship (see the link at the top of the <span class="calibre12">JPA Details</span> view). We need to change this. Click on the <span class="calibre12">one_to_many</span> link and select <span class="calibre12">Many To Many</span>.</p>
<p class="mce-root">Check the <span class="calibre12">Merge</span> and <span class="calibre12">Refresh</span> cascade options. Since we are putting a <kbd class="calibre13">Course</kbd> entity on the inverse side of the relationship, select <span class="calibre12">Mapped By</span> as <span class="calibre12">Joining Strategy</span>. Enter <kbd class="calibre13">courses</kbd> in the <span class="calibre12">Attributes</span> text field. The compiler will show an error for this because we don't have a <kbd class="calibre13">courses</kbd> field in the <kbd class="calibre13">Student</kbd> entity yet. We will fix this shortly. The JPA settings for the <kbd class="calibre13">students</kbd> field should be as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00120.jpeg" class="calibre137"/></div>
<div class="packt_figure1">Figure 4.28: Modified JPA settings for the students field in Course Entity</div>
<p class="calibre3">Annotations for the <kbd class="calibre13">students</kbd> field in the <kbd class="calibre13">Course</kbd> entity should be as follows:</p>
<pre class="calibre25">@ManyToMany(cascade = { MERGE, REFRESH }, mappedBy = "courses") 
private List&lt;Student&gt; students; </pre>
<p class="calibre3">Open <kbd class="calibre13">Student.java</kbd> in the editor. Add the <kbd class="calibre13">courses</kbd> field and the getter and the setter for it. Click on the <kbd class="calibre13">courses</kbd> field in the file and change the relationship from <span class="calibre12">one-to-many</span> to <span class="calibre12">many-to-many</span> in <span class="calibre12">JPA Details</span> view (as described previously for the <kbd class="calibre13">students</kbd> field in the <kbd class="calibre13">Course</kbd> entity). Select the <span class="calibre12">Merge</span> and <span class="calibre12">Refresh</span> cascade options. In the <span class="calibre12">Joining Strategy</span> section, make sure that the <span class="calibre12">Join table</span> option is selected. Eclipse creates the default join table by concatenating the owning table and the inverse table, separated by an underscore (in this case <kbd class="calibre13">Student_Course</kbd>). Change this to <span class="calibre12">Course_Student</span> to make it consistent with the schema that we created for the JDBC application.</p>
<p class="calibre3">In the <span class="calibre12">Join columns</span> section, select the <span class="calibre12">Override default</span> checkbox. Eclipse has named the join columns <kbd class="calibre13">students_id-&gt;id</kbd>, but in the <span class="calibre12">Course_Student</span> table we created in the JDBC application, we had a column named <kbd class="calibre13">student_id</kbd>. So, click the <span class="calibre12">Edit</span> button and change the name to <span class="calibre12">student_id</span>.</p>
<p class="mce-root">Similarly, change <span class="calibre12">Inverse join columns</span> from <kbd class="calibre13">courses_id-&gt;id</kbd> to <kbd class="calibre13">course_id-&gt;id</kbd>. After these changes, the <span class="calibre12">JPA Details</span> for the <kbd class="calibre13">courses</kbd> field should be as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00121.jpeg" class="calibre138"/></div>
<div class="packt_figure1">Figure 4.29: JPA Details for the courses field in Student entity</div>
<p class="calibre3">The previous settings create the following annotations for the <kbd class="calibre13">courses</kbd> field:</p>
<pre class="calibre25">@ManyToMany(cascade = { MERGE, REFRESH }) 
@JoinTable(name = "Course_Student", joinColumns = @JoinColumn(name = "student_id", referencedColumnName = "id"), inverseJoinColumns = <br class="title-page-name"/> @JoinColumn(name = "course_id", referencedColumnName = "id")) 
 
List&lt;Course&gt; courses; </pre>
<p class="calibre3">We have set all the entity relationships required for our application. Download the accompanying code for this chapter to see the complete source code for <kbd class="calibre13">Course</kbd>, <kbd class="calibre13">Student</kbd>, and <kbd class="calibre13">Teacher</kbd> entities.</p>
<p class="mce-root">We need to add the entities we created previously in <kbd class="calibre13">persistence.xml</kbd>. Open the file and make sure that the <span class="calibre12">General</span> tab is open. In the <span class="calibre12">Managed Classes</span> session, click the <span class="calibre12">Add</span> button. Type the name of the entity you want to add (for example, <kbd class="calibre13">Student</kbd>) and select the class from the list. Add all the four entities we have created:</p>
<div class="cdpalignleft"><img src="../images/00122.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 4.30: Add entities in persistence.xml</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating database tables from entities</h1>
                
            
            <article>
                
<p class="calibre3">Follow these steps to create database tables from entities and relationships that we have modeled:</p>
<ol class="calibre14">
<li class="calibre11" value="1"><span>Right-click on the project and select</span> <span>JPA Tool</span> <span>|</span> <span>Generate Tables from Entities</span><span>:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00123.jpeg" class="calibre139"/></div>
<div class="packt_figure1">Figure 4.31: JPA Details for the courses field in Student entity</div>
<ol start="2" class="calibre14">
<li class="calibre11" value="2"><span>Because we haven't configured any schema for our JPA project, the </span><span>Schema</span> <span>drop-down will be empty. Click the </span><span>Add a connection to JPA project</span> <span>link:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00124.jpeg" class="calibre140"/></div>
<div class="packt_figure1">Figure 4.32: JPA project properties</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Click the <span>Add connection</span> link and create a connection to the <kbd class="calibre13">course_management_jpa</kbd> schema we created earlier. We have already seen how to create a connection to the MySQL schema in the <em class="calibre2">Using Eclipse Data Source Explorer</em> section of this chapter.</li>
<li value="4" class="calibre11">Select <kbd class="calibre13">course_management_jpa</kbd> <span>in the drop-down list shown in</span> <em class="calibre2">Figure 4.31</em> <span>and click</span> <span>Next</span><span>:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00125.jpeg" class="calibre141"/></div>
<div class="packt_figure1">Figure 4.33: Schema Generation from entities</div>
<ol start="5" class="calibre14">
<li value="5" class="calibre11">Click <span>Finish</span>.</li>
</ol>
<p class="calibre3">Eclipse generates DDL scripts for creating tables and relationships and executes these scripts in the selected schema. Once the script is run successfully, open the <span class="calibre12">Data Source Explorer</span> view (see the <em class="calibre21">Using Eclipse Data Source Explorer </em>section of this chapter) and browse tables in <span class="calibre12">course_management_jpa</span> connection. Make sure that tables and fields are created according to the entities we have created:</p>
<p class="mce-root3"><img src="../images/00126.jpeg" class="calibre142"/></p>
<div class="packt_figure1">Figure 4.34: Tables created from JPA entities</div>
<p class="calibre3">This feature of Eclipse and JPA makes it very easy to update the database as you modify your entities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using JPA APIs to manage data</h1>
                
            
            <article>
                
<p class="calibre3">We will now create classes that use JPA APIs to manage data for our course management <span class="calibre12">application</span>. We will create service classes for <span class="calibre12">Course</span>, <span class="calibre12">Teacher</span>, and <span class="calibre12">Student</span> entities and add methods that directly access the database through JPA APIs.</p>
<p class="calibre3">As mentioned in the <em class="calibre21">JPA concepts</em> section, it is a good practice to cache an instance of <kbd class="calibre13">EntityManagerFactory</kbd> in our application. Furthermore, managed beans of JSF act as a link between the UI and the backend code, and as a conduit to transfer data between the UI and the data access objects. Therefore, they must have an instance of the data access objects (which use JPA to access data from the database). To cache an instance of <kbd class="calibre13">EntityManagerFactory</kbd>, we will create another managed bean, whose only job is to make the <kbd class="calibre13">EntityManagerFactory</kbd> instance available to other managed beans.</p>
<p class="calibre3">Create an <kbd class="calibre13">EntityManagerFactoryBean</kbd> class in the <kbd class="calibre13">packt.book.jee.eclipse.ch4.jpa.service_bean</kbd> package. This package contains all the managed beans. <kbd class="calibre13">EntityManagerFactoryBean</kbd> creates an instance of <kbd class="calibre13">EntityManagerFactory</kbd> in the constructor and provides a getter method:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.jpa.service_bean; 
 
import javax.faces.bean.ApplicationScoped; 
import javax.faces.bean.ManagedBean; 
import javax.persistence.EntityManagerFactory; 
import javax.persistence.Persistence; 
 
//Load this bean eagerly, i.e., before any request is made 
@ManagedBean(name="emFactoryBean", eager=true) 
@ApplicationScoped 
public class EntityManagerFactoryBean { 
 
  private EntityManagerFactory entityManagerFactory; 
 
  public EntityManagerFactoryBean() { 
    entityManagerFactory = <br class="title-page-name"/> Persistence.createEntityManagerFactory("CourseManagementJPA"); 
  } 
 
  public EntityManagerFactory getEntityManagerFactory() { 
    return entityManagerFactory; 
  } 
 
} </pre>
<p class="calibre3">Note the argument passed in the following:</p>
<pre class="calibre25">entityManagerFactory = <br class="title-page-name"/> Persistence.createEntityManagerFactory("CourseManagementJPA");</pre>
<p class="calibre3">It is the name of the persistence unit in <kbd class="calibre13">persistence.xml</kbd>.</p>
<p class="calibre3">Now let's create service classes that actually use the JPA APIs to access database tables.</p>
<p class="calibre3">Create a package called <kbd class="calibre13">packt.book.jee.eclipse.ch4.jpa.service</kbd>. Create the class named <kbd class="calibre13">CourseService</kbd>. Every service class will need access to <kbd class="calibre13">EntityManagerFactory</kbd>. So, create a private member variable as follows:</p>
<pre class="calibre25">private EntityManagerFactory factory; </pre>
<p class="calibre3">The constructor takes an instance of <kbd class="calibre13">EntityManagerFactoryBean</kbd> and gets the reference of <kbd class="calibre13">EntityManagerFactory</kbd> from it:</p>
<pre class="calibre25">public CourseService(EntityManagerFactoryBean factoryBean) { 
  this.factory = factoryBean.getEntityManagerFactory(); 
} </pre>
<p class="calibre3">Let's now add a function to get all <kbd class="calibre13">courses</kbd> from the database:</p>
<pre class="calibre25">public List&lt;Course&gt; getCourses() { 
  EntityManager em = factory.createEntityManager(); 
  CriteriaBuilder cb = em.getCriteriaBuilder(); 
  CriteriaQuery&lt;Course&gt; cq = cb.createQuery(Course.class); 
  TypedQuery&lt;Course&gt; tq = em.createQuery(cq); 
  List&lt;Course&gt; courses = tq.getResultList(); 
  em.close(); 
  return courses; 
} </pre>
<p class="calibre3">Note how <kbd class="calibre13">CriteriaBuilder</kbd>, <kbd class="calibre13">CriteriaQuery</kbd>, and <kbd class="calibre13">TypesQuery</kbd> are used to get all the courses. It is a type-safe way to execute the query.</p>
<div class="packt_tip"><br class="calibre26"/>
See <a href="https://javaee.github.io/tutorial/persistence-criteria.html#GJITV" class="calibre17">https://javaee.github.io/tutorial/persistence-criteria.html#GJITV</a> for detailed discussion on how to use the JPA criteria APIs.</div>
<p class="calibre3">We could have done the same thing using <strong class="calibre5">Java Persistence Query Language</strong> (<strong class="calibre5">JQL</strong>)—<a href="http://www.oracle.com/technetwork/articles/vasiliev-jpql-087123.html" class="calibre9"><span>http://www.oracle.com/technetwork/articles/vasiliev-jpql-087123.html</span></a>—but it is not type-safe. However, here is an example of using JQL to write the <kbd class="calibre13">getCourses</kbd> function:</p>
<pre class="calibre25">public List&lt;Course&gt; getCourses() { 
  EntityManager em = factory.createEntityManager(); 
  List&lt;Course&gt; courses = em.createQuery("select crs from Course crs").getResultList(); 
  em.close(); 
  return courses; 
} </pre>
<p class="calibre3">Add a method to insert the course into the database:</p>
<pre class="calibre25">public void addCourse (Course course) { 
  EntityManager em = factory.createEntityManager(); 
  EntityTransaction txn = em.getTransaction(); 
  txn.begin(); 
  em.persist(course); 
  txn.commit(); 
} </pre>
<p class="calibre3">The code is quite simple. We get the entity manager and then start a transaction, because it is an <kbd class="calibre13">update</kbd> operation. Then, we call the <kbd class="calibre13">persist</kbd> method on <kbd class="calibre13">EntityManager</kbd> by passing an instance of <kbd class="calibre13">Course</kbd> to save. Then, we commit the transaction. The methods to update and delete are also simple. Here is the entire source code of <kbd class="calibre13">CourseService</kbd>:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch4.jpa.service; 
 
// imports skipped
 
import packt.book.jee.eclipse.ch4.jpa.bean.Course; 
import packt.book.jee.eclipse.ch4.jpa.service_bean.EntityManagerFactoryBean; 
 
public class CourseService { 
  private EntityManagerFactory factory; 
 
  public CourseService(EntityManagerFactoryBean factoryBean) { 
    factory = factoryBean.getEntityManagerFactory(); 
  } 
 
  public List&lt;Course&gt; getCourses() { 
    EntityManager em = factory.createEntityManager(); 
    CriteriaBuilder cb = em.getCriteriaBuilder(); 
    CriteriaQuery&lt;Course&gt; cq = cb.createQuery(Course.class); 
    TypedQuery&lt;Course&gt; tq = em.createQuery(cq); 
    List&lt;Course&gt; courses = tq.getResultList(); 
    em.close(); 
    return courses; 
  } 
 
public void addCourse (Course course) { 
    EntityManager em = factory.createEntityManager(); 
    EntityTransaction txn = em.getTransaction(); 
    txn.begin(); 
    em.persist(course); 
    txn.commit(); 
} 
 
  public void updateCourse (Course course) { 
    EntityManager em = factory.createEntityManager(); 
    EntityTransaction txn = em.getTransaction(); 
    txn.begin(); 
    em.merge(course); 
    txn.commit(); 
  } 
 
  public Course getCourse (int id) { 
    EntityManager em = factory.createEntityManager(); 
    return em.find(Course.class, id); 
  } 
 
  public void deleteCourse (Course course) { 
    EntityManager em = factory.createEntityManager(); 
    EntityTransaction txn = em.getTransaction(); 
    txn.begin(); 
    Course mergedCourse = em.find(Course.class, course.getId()); 
    em.remove(mergedCourse); 
    txn.commit(); 
  } 
} </pre>
<p class="calibre3">Let's now create <kbd class="calibre13">StudentService</kbd> and <kbd class="calibre13">TeacherService</kbd> classes with the following methods:</p>
<pre class="calibre25">public class StudentService { 
  private EntityManagerFactory factory; 
 
  public StudentService (EntityManagerFactoryBean factoryBean) { 
    factory = factoryBean.getEntityManagerFactory(); 
  } 
 
  public void addStudent (Student student) { 
    EntityManager em = factory.createEntityManager(); 
    EntityTransaction txn = em.getTransaction(); 
    txn.begin(); 
    em.persist(student); 
    txn.commit(); 
  } 
 
  public List&lt;Student&gt; getStudents() { 
    EntityManager em = factory.createEntityManager(); 
    CriteriaBuilder cb = em.getCriteriaBuilder(); 
    CriteriaQuery&lt;Student&gt; cq = cb.createQuery(Student.class); 
    TypedQuery&lt;Student&gt; tq = em.createQuery(cq); 
    List&lt;Student&gt; students = tq.getResultList(); 
    em.close(); 
    return students; 
  } 
 
} 
 
public class TeacherService { 
  private EntityManagerFactory factory; 
 
  public TeacherService (EntityManagerFactoryBean factoryBean) { 
    factory = factoryBean.getEntityManagerFactory(); 
  } 
 
  public void addTeacher (Teacher teacher) { 
    EntityManager em = factory.createEntityManager(); 
    EntityTransaction txn = em.getTransaction(); 
    txn.begin(); 
    em.persist(teacher); 
    txn.commit(); 
  } 
 
  public List&lt;Teacher&gt; getTeacher() { 
    EntityManager em = factory.createEntityManager(); 
    CriteriaBuilder cb = em.getCriteriaBuilder(); 
    CriteriaQuery&lt;Teacher&gt; cq = cb.createQuery(Teacher.class); 
    TypedQuery&lt;Teacher&gt; tq = em.createQuery(cq); 
    List&lt;Teacher&gt; teachers = tq.getResultList(); 
    em.close(); 
    return teachers; 
  } 
 
  public Teacher getTeacher (int id) { 
    EntityManager em = factory.createEntityManager(); 
    return em.find(Teacher.class, id); 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Wiring user interface with JPA service classes</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have all data access classes ready, we need to connect the user interface that we have created for adding courses, <kbd class="calibre13">addCourse.xhtml</kbd>, to pass data and get data from the JPA service classes. As mentioned previously, we are going to do this using managed beans, in this case, <kbd class="calibre13">CourseServiceBean</kbd>.</p>
<p class="calibre3"><kbd class="calibre13">CourseServiceBean</kbd> will need to create an instance of <kbd class="calibre13">CourseService</kbd> and call the <kbd class="calibre13">addCourse</kbd> method. Open <kbd class="calibre13">CourseServiceBean</kbd> and create a member variable as follows:</p>
<pre class="calibre25">private CourseService courseService ; </pre>
<p class="calibre3">We also need an instance of the <kbd class="calibre13">EntityManagerFactoryBean</kbd> managed bean that we created earlier:</p>
<pre class="calibre25">@ManagedProperty(value="#{emFactoryBean}") 
private EntityManagerFactoryBean factoryBean; </pre>
<p class="calibre3">The <kbd class="calibre13">factoryBean</kbd> instance is injected by the JSF runtime and is available only after the managed bean is completely constructed. However, for this bean to be injected, we need to provide a setter method. Therefore, add a setter method for <kbd class="calibre13">factoryBean</kbd>. We can have JSF call a method of our bean after it is fully constructed by annotating the method with <kbd class="calibre13">@PostConstruct</kbd>. So, let's create a method called <kbd class="calibre13">postConstruct</kbd>:</p>
<pre class="calibre25">@PostConstruct 
public void init() { 
  courseService = new CourseService(factoryBean); 
} </pre>
<p class="calibre3">Then, modify the <kbd class="calibre13">addCourse</kbd> method to call our service method:</p>
<pre class="calibre25">public String addCourse() { 
  courseService.addCourse(course); 
  return "listCourse"; 
} </pre>
<p class="calibre3">Since the <kbd class="calibre13">listCourse.xhtml</kbd> page will need to get a list of courses, let's also add the <kbd class="calibre13">getCourses</kbd> method in <kbd class="calibre13">CourseServiceBean</kbd>:</p>
<pre class="calibre25">public List&lt;Course&gt; getCourses() { 
  return courseService.getCourses(); 
} </pre>
<p class="calibre3">Here is <kbd class="calibre13">CourseServiceBean</kbd> after the preceding changes:</p>
<pre class="calibre25">@ManagedBean(name="courseServiceBean") 
@RequestScoped 
public class CourseServiceBean { 
 
  private CourseService courseService ; 
 
  @ManagedProperty(value="#{emFactoryBean}") 
  private EntityManagerFactoryBean factoryBean; 
 
  @ManagedProperty(value="#{course}") 
  private Course course; 
 
  private String errMsg= null; 
 
  @PostConstruct 
  public void init() { 
    courseService = new CourseService(factoryBean); 
  } 
 
  public void setFactoryBean(EntityManagerFactoryBean factoryBean) <br class="title-page-name"/>   { 
    this.factoryBean = factoryBean; 
  } 
 
  public Course getCourse() { 
    return course; 
  } 
 
  public void setCourse(Course course) { 
    this.course = course; 
  } 
 
  public String getErrMsg() { 
    return errMsg; 
  } 
 
  public void setErrMsg(String errMsg) { 
    this.errMsg = errMsg; 
  } 
 
  public String addCourse() { 
    courseService.addCourse(course); 
    return "listCourse"; 
  } 
 
  public List&lt;Course&gt; getCourses() { 
    return courseService.getCourses(); 
  } 
 
} </pre>
<p class="calibre3">Finally, we will write the code to display a list of courses in <kbd class="calibre13">listCourse.xhtml</kbd>:</p>
<pre class="calibre25">&lt;html  
     
     
    &gt; 
 
    &lt;h2&gt;Courses:&lt;/h2&gt; 
    &lt;h:form&gt; 
      &lt;h:messages style="color:red"/&gt; 
    &lt;h:dataTable value="#{courseServiceBean.courses}" <br class="title-page-name"/>     var="course"&gt; 
      &lt;h:column&gt; 
        &lt;f:facet name="header"&gt;ID&lt;/f:facet&gt; 
        &lt;h:outputText value="#{course.id}"/&gt; 
      &lt;/h:column&gt; 
      &lt;h:column&gt; 
        &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt; 
        &lt;h:outputText value="#{course.name}"/&gt; 
      &lt;/h:column&gt; 
      &lt;h:column&gt; 
        &lt;f:facet name="header"&gt;Credits&lt;/f:facet&gt; 
        &lt;h:outputText value="#{course.credits}" <br class="title-page-name"/>         style="float:right" /&gt; 
      &lt;/h:column&gt; 
    &lt;/h:dataTable&gt; 
  &lt;/h:form&gt; 
 
  &lt;h:panelGroup rendered="#{courseServiceBean.courses.size() == <br class="title-page-name"/>   0}"&gt; 
    &lt;h3&gt;No courses found&lt;/h3&gt; 
  &lt;/h:panelGroup&gt; 
 
  &lt;c:if test="#{courseServiceBean.courses.size() &gt; 0}"&gt; 
    &lt;b&gt;Total number of courses 
      &lt;h:outputText value="#{courseServiceBean.courses.size()}"/&gt; 
    &lt;/b&gt; 
  &lt;/c:if&gt; 
  &lt;p/&gt; 
  &lt;h:button value="Add" outcome="addCourse"/&gt; 
&lt;/html&gt; </pre>
<p class="calibre3">Because of space constraints, we will not discuss how to add functionality to delete/update courses, or to create a course with the <kbd class="calibre13">Teacher</kbd> field selected. Please download the source code for the examples discussed in this chapter to see completed projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">In this chapter, we learned how to build web applications that require accessing data from a relational database. First, we built a simple <em class="calibre21">Course Management</em> application using JDBC and JSTL, and then, the same application was built using JPA and JSF.</p>
<p class="calibre3">JPA is preferred to JDBC because you end up writing a lot less code. The code to map object data to relational data is created for you by the JPA implementation. However, JDBC is still being used in many web applications because it is simpler to use. Although JPA has a moderate learning curve, JPA tools in Eclipse EE can make using JPA APIs a bit easier, particularly configuring entities, relationships, and <kbd class="calibre13">persistence.xml</kbd>.</p>
<p class="calibre3">In the next chapter, we will deviate a bit from our discussion on JEE and see how to write and run unit tests for Java applications. We will also see how to measure code coverage after running the unit tests.</p>


            </article>

            
        </section>
    </body></html>