- en: Chapter 5. Configuring a WildFly Domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have looked at the core configuration of the server, we can move
    on to the domain configuration. Shaping a server domain is a key task for administrators
    who want to efficiently coordinate a set of application servers. In this chapter,
    we will describe all the steps necessary to create and configure a domain of WildFly
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see shortly, the configuration of subsystems does not vary between
    standalone and domain configuration. To work with domains, we also need to learn
    about the domain controller and host controller configurations. These are responsible
    for handling and coordinating the lifecycle of applications across several servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the WildFly domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure the domain components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The criteria to choose between a domain and a standalone server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing WildFly domain mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the WildFly domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of a domain mode might be perceived as a little difficult to understand.
    The reason for this is that in the Java EE paradigm, one is used to dealing with
    servers rather than domains.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, a domain is a group of WildFly servers managed by one of the servers.
    The server managing the domain is called the domain controller. This group is
    under one administration—it is the administrative unit. It's important to understand
    that the concept of a domain does not interfere with the capabilities delivered
    by the managed servers. For example, you might set up a domain of application
    server nodes running in a cluster, providing load balancing and high availability.
    However, you can also achieve the same outcome with a set of standalone application
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: What differentiates these two scenarios is that when running in a domain, you
    can efficiently manage your set of servers from a single, centralized unit. On
    the other hand, managing a set of standalone instances often requires sophisticated
    multiserver management capabilities that are significantly more complex, error-prone,
    and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the process point of view, a domain is made up of four elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain** **controller**: The domain controller is the management control
    point of your domain. An AS instance running in the domain mode has, at the most,
    one process instance acting as a domain controller. The domain controller holds
    a centralized configuration that is shared by the node instances belonging to
    the domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host** **controller**: This is a process responsible for coordinating the
    life cycle of server processes and the distribution of deployments, from the domain
    controller to the server instances, with the domain controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process** **controller**: This is a very lightweight process whose primary
    function is to spawn server and host controller processes, and manage their input/output
    streams. This also allows the host controller to be patched and restarted without
    impacting the associated servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application** **server** **nodes**: These are regular Java processes that
    map to instances of the application server. Each server node, in turn, belongs
    to a domain group. Domain groups will be explained in detail when we discuss the
    domain configuration file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to understand how to configure these components, we will first look
    at the basic domain configuration. This configuration is provided with the application
    server default distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the default domain configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Out of the box, the default domain configuration (`domain.xml`) includes a
    basic configuration made up of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: One process controller that starts the other JVM processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One host controller that acts as the domain controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three server nodes, with the first two being part of the main server group and
    the third one (inactive) as part of the other server group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A server group is a group of servers that have the same configuration and are
    managed as one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image reinforces these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the default domain configuration](img/6232OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use the `VisualVM` utility to have a look at the low-level details of
    your domain from the point of view of the JVM. You can see from the following
    screenshot that four JVM processes are spawned. The process controller is started
    first, which, in turn, launches the host controller process and the two server
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the default domain configuration](img/6232OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**VisualVM** is a Java Virtual Machine monitoring tool that is included in
    the default Java SE distribution. You can find it in your `JAVA_HOME/bin` folder.
    Simply launch `jvisualvm.exe` if you are on Windows, or `jvisualvm` if you are
    on Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note from the preceding screenshot is that with the basic
    domain setup, the host controller also acts as the domain controller, that is,
    the host controller holds the centralized configuration of the domain. This means
    that the host controller and the domain controller share the same JVM process.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed a basic introduction to the application server domain, we will
    now cover all the details concerning its configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up and stopping a domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting up a WildFly domain is simply a matter of running the `JBOSS_HOME\bin\domain.sh`
    script (`JBOSS_HOME\bin\domain.bat` on Windows). In a matter of seconds, your
    domain will be up and running. Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up and stopping a domain](img/6232OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to stop the application server domain, you can either use the *Ctrl*
    + *C* shortcut in the same window in which you started the domain, or you can
    use the command-line client and issue the `shutdown` command to the host controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unix/Linux users can issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows users can issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default host name is `master`, and it is defined in the `host.xml`, file
    which is located in the `JBOSS_HOME\domain\configuration` folder. We will learn
    more about it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Once the domain starts, several log files are created within the `JBOSS_HOME\domain\log`
    directory. The host controller activity is written to the `host-controller.log`
    file, while the process controller logs are written to the `process-controller.log`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the main advantages of setting up a WildFly domain is the control over,
    and management of, the server configurations and deployments from a single centralized
    point. The main domain configuration consists of the following two files found
    in the `JBOSS_HOME\domain\configuration` folder, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`domain.xml`: This file describes the capabilities of your domain servers and
    defines the server groups that are part of the domain. While this file can be
    found on each host, only the `domain.xml` file found on the domain controller
    is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host.xml`: This file is present on each host where the domain is installed
    and specifies the elements specific to the servers running on the host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the default configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to use configuration files other than the default files that
    are provided in a vanilla install. You can use your own custom configuration files
    by adding the following parameter to your shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Windows users use the same parameter, but obviously use the `domain.bat` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that if you don't provide any path to your custom configuration file,
    it's assumed to be relative to the `jboss.server.config.dir` directory. Otherwise,
    you need to provide an absolute path to your file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the domain.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `domain.xml` file contains the domain subsystems'' configuration that is
    shared by all the servers in the domain. The content of the file follows the structure
    of the standalone file, with an obvious and important difference—a domain can
    have several profiles defined in it. By default, four profiles are defined: a
    default profile, a full profile, a ha profile, and lastly, a full-ha profile,
    with the last two being used for clustered domains. You could also, however, define
    your own custom profile, such as a messaging profile, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the domain.xml file](img/6232OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing from one profile to another is the recommended way to expand or narrow
    the capabilities of the servers running in your domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each WildFly domain can be further split into server groups, with each one
    bound to a different profile. The concept of server groups can be seen as a set
    of servers managed as a single unit by the domain. You can actually use server
    groups for fine-grained configuration of nodes; for example, each server group
    is able to define its own settings, such as customized JVM settings, socket bindings
    interfaces, and deployed applications. The following figure illustrates some common
    attributes that can be applied to servers within a server group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the domain.xml file](img/6232OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, here is a more complete server group definition that is bound
    to the `default` profile. This server group defines a web application named `sample.war`,
    which is made available to all servers within the group. It also defines a customized
    JVM configuration and some system properties (loaded at boot time), and binds
    its services to the `standard-sockets` definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the host.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other domain configuration file is named `host.xml`, which is found in
    the `JBOSS_HOME\domain\configuration` folder. This file basically defines and
    configures the server nodes that are running on a host as part of a domain. The
    term "host" used here denotes a physical or virtual host. Within each host is
    a portion of the servers from the domain. Each host can have zero or more server
    instances. The following figure clarifies these details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the host.xml file](img/6232OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, a domain can contain several hosts (**host1**, **host2**) and
    also several groups (**main server group**, **other server group**). However,
    while a **server group** is a logical association of server nodes (which can be
    located anywhere), a **host** refers to a set of nodes that are located on the
    same physical or virtual machine. Having provided our definition of hosts, we
    now look into the host configuration file, which allows you to shape the following
    set of core domain elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The management interfaces used to control the domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain controller definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network interfaces where services are bound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The defined JVM's configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The servers that are part of the domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will see each element of the `host.xml` file in detail
    and learn how to configure it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the management interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The management interface includes the definition of the native **command-line**
    **interface** (**CLI**) and `http` interface that are used to manage the domain.
    The following example has been taken from the `host.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the default configuration, both services are bound to the `management`
    network interfaces. The CLI and administrative interface listen on port `9990`.
    The `native` interface configuration remains should you, for some reason, want
    to revert back to JBoss AS 7 settings and run on port number `9999`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the network interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just mentioned `network` interfaces. As you can guess from its name,
    a **network interface** refers to one network address or a set of network addresses.
    By default, the server contains three network interface definitions, namely, **management**,
    **public**, and **unsecure**, all of which are bound to the loopback address (`127.0.0.1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'By changing the `inet-address` value of your network interface, you can configure
    the listening addresses of your application server. For example, if we want to
    bind the `management` interfaces to the loopback address (`127.0.0.1`), and the
    `public` interface to the address `192.168.1.1`, you can simply use the following
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also update these properties via the command line by running the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, this means that the `management` interfaces (the `http` admin
    console and the CLI) will be bound to the loopback address, while application-related
    services (bound to the `public` interface) will be bound to the IP address `192.168.1.1`.
    The following configuration is taken from the `domain.xml` file. Here, you can
    see how it uses the `public` interface defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the domain controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the domain controller is located on the same machine where you
    started your domain. Have a look at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, however, configure your host to use a domain controller located on
    a remote host in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This doesn't work if the management interface is bound to `localhost`. Ensure
    that you update the management interface correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the domain controller on a remote host means that the local configuration
    (`domain.xml`) will not be used, and that all server nodes on that host will use
    the centralized remote configuration. You need authorization to access the domain
    controller. We will cover the details of this in the domain example toward the
    end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the JVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the key aspects of the domain configuration is the definition of JVM
    arguments for a given host. The JVM''s elements are defined in the `host.xml`
    file. Here, you can define JVM settings and associate them with a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, there is no element available to configure Java 8 Metaspace properties.
    To configure these, you need to add them as `option` elements. To set the initial
    size, use `-XX:MetaspaceSize=256m`, and to set the maximum size, use `-XX:MaxMetaspaceSize=256m`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This JVM definition can then be used as part of your server group configuration
    by referencing the `jvm` name property in your `server-group` configuration. Also
    note that any JVM definitions within the `server-group` overrides those in the
    `jvms` definition. For example, the `main-server-group` (`domain.xml`) server
    group uses the `default` JVM for all server nodes, but redefines the `heap max-size`
    and `size` values. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The defined JVMs can be also be associated with a single server, thus overriding
    the server group definition. For example, here, `server-one` (defined in `host.xml`)
    inherits the `default` JVM configuration but then overrides the minimum (512 MB)
    and maximum heap size (1 GB):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Adding JVM options to a server definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to further specialize your JVM configuration, for example, by adding
    nonstandard options to the virtual machine, you can use the `jvm-options` element
    (`host.xml`). In this example, we add the concurrent, low-pause garbage collector
    to the `default` JVM options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Order of precedence between elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we showed you how to use the `default` JVM definition
    in the different configuration files (`host.xml` and `domain.xml`). As a matter
    of fact, the JVM definition is a typical example of a configuration that overlaps
    between files, which means that the JVM can be configured at any one of the following
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Host level**: This configuration will apply to all servers that are defined
    in `host.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-group level**: This configuration applies to all servers that are
    part of the group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server level**: This configuration is used just for a single host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, so good. However, what happens if we define an element with the same
    name at multiple levels? The application server resolves this by letting most
    specific elements override their parent configuration. In other words, if you
    define a generic JVM at the host level, it is overridden by the same JVM at the
    server-group level. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you also define it at the server level, then that is the final choice for
    that server. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure describes the elements that can be defined (and possibly
    overridden) at different configuration levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Order of precedence between elements](img/6232OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this list also includes some elements, such as the `<path>`
    element, the `<interface>` element, and the `<system-properties>` element, which
    we have discussed in [Chapter 2](ch02.html "Chapter 2. Configuring the Core WildFly
    Subsystems"), *Configuring the Core WildFly Subsystems*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring server nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last element of the host configuration includes the list of server nodes
    that are part of the domain. Configuring a server requires, at minimum, the name
    of the server and the group to which the server belongs. Have a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This server definition relies largely on default attributes for the application
    server nodes. You can, however, highly customize your servers by adding specific
    paths, socket-binding interfaces, system properties, and JVMs. Have a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you want to know all the applicable attributes of the server nodes' configuration,
    we suggest that you have a look at the `jboss-as-config_2_1.xsd` schema, which
    is located in the `JBOSS_HOME/docs/schema` folder of your server distribution.
    In Eclipse, you can right-click on the schema file and then click on **Generate**
    | **XML File**.
  prefs: []
  type: TYPE_NORMAL
- en: Applying domain configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common misconception among users who are new to the concept of a domain is
    that a domain is pretty much the equivalent of a cluster of nodes, so it can be
    used to achieve important features, such as load balancing and high availability.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand that a domain is not pertinent to the functionalities
    that your application delivers—a domain is designed around the concept of server
    management. Thus, you can use it to manage both clustered applications and applications
    that are not intended to run in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand it better, let''s give an example. Let''s consider that your
    server topology consists of multiple servers, and that you have defined a datasource
    that will be used by your application. So, whether or not you use a cluster, you
    need to configure your datasource across all your standalone servers'' configurations
    (this means adding the definition of the datasource in every `standalone.xml`)
    file. In this case, the advantage of using a domain is evident: the datasource
    definition is contained just in the domain controller that provides a central
    point through which users can keep configurations consistent. It also has the
    benefit of being able to roll out configuration changes to the servers in a coordinated
    fashion. One other important aspect of a domain is the ability to provide a more
    fine-grained configuration than clustering is able to. For example, you can define
    server groups, each one with its own custom configuration. In order to achieve
    the same thing with a clustered configuration, you have to manage each machine''s
    standalone configuration and adapt it to your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: However, domain and clustering are not mutually exclusive scenarios, but are
    often part of a larger picture. For example, using a domain can further enhance
    the efficiency of a cluster in advanced configurations where you need to manage
    starting and stopping multiple AS instances. At the same time, clustering provides
    typical load balancing and high-availability features, which are not integrated
    into domain management.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are situations where using a domain may not prove to
    be that useful. For example, it's possible that your system administrators have
    bought or developed their own sophisticated multiserver management tools that
    can do more or less the same things that a domain configuration is able to do.
    In this situation, it may not be desirable to switch out what is already configured
    ad hoc.
  prefs: []
  type: TYPE_NORMAL
- en: Another classic example where a domain is not needed is the development phase,
    where you don't gain anything from a domain installation. Rather, it may add an
    unneeded additional complexity to your architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the standalone mode is the only choice available in some scenarios.
    For example, if you are running the application server in the embedded mode, then
    the choice of a domain is incompatible. For example, when using an Arquillian
    project, you can test your Enterprise projects using an embedded container, which
    is managed by Arquillian using a standalone configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Summing it up, since the individual server configuration does not vary when
    running the domain mode or the standalone mode, you can easily develop your application
    in the standalone mode and then switch to the domain mode when you are about to
    roll out the production application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our very own domain configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now provide a detailed example of a domain configuration. In this example,
    we include two separate host controller configurations, each one with a list of
    three nodes. You need two separate installations of WildFly 8, which can be executed
    on either two different machines or on the same machine. When running on the same
    machine, it's practical to assign a virtual IP address to your machines so that
    you don't have any port conflict in your domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows our domain project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our very own domain configuration](img/6232OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing we need to do is bind the network interfaces to a valid `inet`
    address, both for the public and management interfaces. So, assuming that the
    first domain installation (master) will be bound to the `inet` address `192.168.1.1`,
    open the `host.xml` file and change it accordingly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second domain installation (slave), change the `inet` address to `192.168.1.2`
    in `host.xml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing to do is define a unique host name for each installation. So,
    for the first `host.xml` file, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second file, simply use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the most important step is to choose where the domain controller is located.
    As we have shown earlier in the image, the domain controller will be located in
    the first installation (master), so in the `host.xml` file, you should contain
    the default content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, looking at the other installation (slave), point to the domain controller
    that is running on host `192.168.1.1` (master), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Authentication is required for the slave to connect to the domain controller,
    so next we will add a user to the installation housing the master domain. To do
    this, you need to run the `add-user` script in the `bin` directory of your WildFly
    installation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: When asked **What type of user do you wish to add?**, enter `a` (management
    user).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When asked for a username, enter `slave`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When asked for a password, enter `password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When asked **What groups do you want this user to belong to?**, leave it blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked if this is correct. Type `yes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, and most importantly, you will be asked if you want this new user to
    be used for one AS process to connect to another AS process. You need to type
    `yes` again. This will cause XML to be printed out, which we will use in the slave
    configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Creating our very own domain configuration](img/6232OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, on the slave server, we need to add the `secret value` (printed out
    to the console) within the `server-identities` element in the `host.xml` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The domain configuration is now complete. Let's start up the installation containing
    the domain controller (master) and then the second installation (slave) using
    the `domain.bat/domain.sh` scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is correctly configured, you will see the slave host registered
    on the domain controller (master), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our very own domain configuration](img/6232OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's have a look at the domain from the management console. The management
    interfaces are discussed in detail in the next chapter, but we need to briefly
    look at them for the purpose of showing our domain example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, you need to create one management user to be able to log in to the
    management console. For now, you can just use the username and password you created
    for the slave server, but in production, you would most likely create a different
    management user.
  prefs: []
  type: TYPE_NORMAL
- en: If you point the browser to the management interface of your master server (`http://192.168.1.1:9990`),
    you will not be able to access the management interface of your slave servers.
  prefs: []
  type: TYPE_NORMAL
- en: From the main page of the management console, there are a couple of options
    in which to look at your domain configuration. At this point, we are interested
    in looking at the host controllers that make up the domain. So, in the top menu
    bar, select the **Domain** menu. From here, you can select the host you are interested
    in from the combobox located on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, you can find all servers grouped by the host, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our very own domain configuration](img/6232OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, select **Runtime** from the menu. From here, you can view the status of
    each server, group them by server-group, and start/stop each node. For example,
    as per the default configuration, each distribution contains three nodes: two
    are activated at startup, while the third one is started on demand. Hover your
    mouse over each node, and options will appear allowing you to start/stop the single
    node. You can also start/stop an entire server-group. Also, note that there is
    an option to change the host currently being viewed, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our very own domain configuration](img/6232OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It should be clear now that each host has its own list of nodes, all of which
    are part of the domain. Also, remember that each host depends on the configuration
    defined in the `profiles` section of `domain.xml` that contains the domain profile
    used by your domain. As mentioned earlier, one of the most evident advantages
    of a domain over individual installation is the ability to centralize the services'
    configuration as well as the deployed resources.
  prefs: []
  type: TYPE_NORMAL
- en: From within the web console, you can also deploy applications or install modules
    such as JDBC drivers. In the next chapter, we will discuss in depth how to deploy
    and install a module to a domain. The main difference between the domain mode
    and the standalone mode is that once the datasource is added to the domain controller
    (`master`), its definition becomes part of the default profile, and every host
    that connects to the domain inherits its configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our very own domain configuration](img/6232OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Changing the domain configuration at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have modified the configuration files before starting the domain,
    but it is also possible to change the configuration on the fly while the domain
    is running. These changes will be made active without the need to restart the
    server, as they are done via the management console. For example, you may need
    to create, on the fly, a new server group and associate some servers and applications
    with it. It could be that one of your production applications has an issue that
    needs to be fixed. You could try to reproduce the issue on a development environment,
    but your results may not always be accurate since development and production often
    use different database and class versions.
  prefs: []
  type: TYPE_NORMAL
- en: So, one way you can quickly resolve the issue is by creating a new server group,
    associating one or more servers with it, and then deploying and testing the application
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done using the admin console (or the CLI) in a matter of minutes.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser, and navigate to the admin console. Then, select the **Domain**
    menu option at the top. From there, choose the **Server Groups** tab in the left-hand
    side column. This interface lets you add server groups by clicking on the **Add**
    button, as shown in the following screenshot:![Changing the domain configuration
    at runtime](img/6232OS_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, choose a meaningful name for your group, for example, `staging-server-group`,
    and select a **Profile** and **Socket Binding** configuration on which the new
    group will be based, as follows:![Changing the domain configuration at runtime](img/6232OS_05_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it's time to associate one or more servers with the new group. Click on
    the **Server Configuration** menu on the left-hand side, and then click the **Add**
    button. Have a look at the following screenshot:![Changing the domain configuration
    at runtime](img/6232OS_05_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This pops up a dialog box that asks you for the new server name and the associated
    server group. In this example, we are going to call it `testServer`. Then, associate
    it with the `staging-server-group` with a port offset of `750` (in practice, every
    service is bound to a port of default port address (+ `750`)). Have a look at
    the following screenshot:![Changing the domain configuration at runtime](img/6232OS_05_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have set up a new server group and assigned one or more servers to
    it, you can deploy your applications to the server group. Deployment of applications
    can be done from the **Runtime** page. Click on **Manage Deployments** on the
    left-hand side, which shows you what applications, if any, are deployed. Have
    a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the domain configuration at runtime](img/6232OS_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From here, you can add and remove deployments to your groups, which we will
    cover in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the WildFly domain setup and configuration.
    By configuring a server domain, you can manage your servers from a single centralized
    point, which is desirable when you have to administer a large set of server nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every domain is composed of four main elements: the domain controller, the
    host controller, the process controller, and the server.'
  prefs: []
  type: TYPE_NORMAL
- en: The domain controller handles the domain configuration, while the host controller
    coordinates the life cycle of server processes and the distribution of deployments.
    The process controller handles the domain server processes and manages their I/O
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: Every domain is made up of one or more server groups, which allows fine-grained
    configuration of the domain. Each server group can define its own JVM attributes,
    socket binding interfaces, and system properties, which are loaded at startup.
    You can also deploy applications to each of the nodes within the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Server groups are defined in the `domain.xml` configuration file, along with
    the enterprise services enabled for the domain.
  prefs: []
  type: TYPE_NORMAL
- en: The composition of server groups is contained in the `host.xml` file. This file
    also contains the location of the domain controller, the default JVMs, and `network`
    and `management` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to cover application deployment in detail in the next chapter,
    *Application Structure and Deployment*.
  prefs: []
  type: TYPE_NORMAL
