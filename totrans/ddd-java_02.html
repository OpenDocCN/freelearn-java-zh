<html><head></head><body>
		<div id="_idContainer038">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: The Rationale for Domain-Driven Design</h1>
			<p class="author-quote">The being cannot be termed rational or virtuous, who obeys any authority, but that of reason.</p>
			<p class="author-quote">— Mary Wollstonecraft</p>
			<p>According to the <strong class="bold">Project Management Institute’s</strong> (<strong class="bold">PMI’s</strong>) <em class="italic">Pulse of the Profession</em> report published<a id="_idIndexMarker000"/> in February 2020, only 77% of all projects meet their intended goals—and even this is true only in the most mature organizations. For less mature organizations, this number falls to just 56%; that is, approximately one in every two projects does not meet its intended goals. Furthermore, approximately one in every five projects is declared an outright failure. At the same time, we also seem to be embarking on our most ambitious and complex projects.</p>
			<p>In this chapter, we will examine the main causes of project failure and look at how applying <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>) provides a set of guidelines and techniques to improve the odds of success in our favor. While Eric Evans wrote his classic book on the subject way back in 2003, we look at why that work is still extremely relevant in today’s times.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding why software projects fail</li>
				<li>Characteristics of modern systems and dealing with complexity</li>
				<li>Introduction to DDD</li>
				<li>Reviewing why DDD is relevant today</li>
			</ul>
			<p>By the end of this chapter, you will have gained a basic understanding of DDD and why you should strongly consider applying the tenets of DDD when architecting/implementing modern software applications, especially the more complex ones.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Why do software projects fail?</h1>
			<p class="author-quote">Failure is simply the opportunity to begin again, this time more intelligently.</p>
			<p class="author-quote">— Henry Ford</p>
			<p>According to<a id="_idIndexMarker001"/> the project success report published in the <em class="italic">Project Management Journal</em> of the PMI, the following six factors need to be true for a project to be deemed successful:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B16716_01_Table_01.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 – Project success factors</p>
			<p>With all of these criteria being applied to assess project success, a large percentage of projects fail for<a id="_idIndexMarker002"/> one reason or another. Let’s examine some of the top reasons in more detail.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Inaccurate requirements</h2>
			<p>PMI’s <em class="italic">Pulse of the Profession</em> report <a id="_idIndexMarker003"/>from 2017 highlights a very stark fact—a vast majority of projects fail due to inaccurate or misinterpreted requirements. It follows that it is impossible to build something that clients can use, they are happy with, and that makes them more effective at their jobs if the wrong thing gets built—even much less for the project to be built on time and within budget.</p>
			<p>IT teams, especially in large organizations, are staffed with mono-skilled roles, such as UX designer, developer, tester, architect, business analyst, project manager, product owner, and business sponsor. In a lot of cases, these people are parts of distinct organization units/departments—each with its own set of priorities and motivations. To make matters even worse, the geographical separation between these people only keeps increasing. The need to keep costs down and the recent COVID-19 ecosystem does not help matters either.</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B16716_Figure_1.1.jpg" alt="Figure 1.1 – Silo mentality and the loss of information fidelity&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Silo mentality and the loss of information fidelity</p>
			<p>All this results in a <a id="_idIndexMarker004"/>loss in fidelity of information at every stage in the assembly line, which then results in misconceptions, inaccuracies, delays, and eventually failure!</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Too much architecture</h2>
			<p>Writing complex <a id="_idIndexMarker005"/>software is quite a task. You cannot just hope to sit down and start typing code—although that approach might work in some trivial cases. Before translating business ideas into working software, a thorough understanding of the problem at hand is necessary. For example, it is not possible (or is at least extremely hard) to build credit card software without understanding how credit cards work in the first place. To communicate your understanding of a problem, it is not uncommon to create software models of the problem before writing code. This model or collection of models represents the understanding of the problem and the architecture of the solution.</p>
			<p>Efforts to create a perfect model of the problem—one that is accurate in a very broad context—are not dissimilar to the proverbial holy grail quest. Those accountable for producing the architecture can get stuck in analysis paralysis and/or big design upfront, producing artifacts that are one or more of too high level, wishful, gold-plated, buzzword-driven, or disconnected from the real world—while not solving any real business problems. This kind of lock-in can be especially detrimental during the early phases of the project when the knowledge levels of team members are still up and coming. Needless to say, projects adopting such approaches find it hard to reach success consistently.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">For a more<a id="_idIndexMarker006"/> comprehensive list of modeling anti-patterns, refer to Scott W. Ambler’s website (<a href="http://agilemodeling.com/essays/enterpriseModelingAntiPatterns.htm">http://agilemodeling.com/essays/enterpriseModelingAntiPatterns.htm</a>) and book, <em class="italic">Agile Modeling: Effective Practices for eXtreme Programming and the Unified Process</em>, dedicated to the subject.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Too little architecture</h2>
			<p>Agile software <a id="_idIndexMarker007"/>delivery methods manifested themselves in the late 90s and early 2000s in response to heavyweight processes collectively known as <em class="italic">waterfall</em>. These processes seemed to favor big design upfront and abstract ivory tower thinking based on wishful, ideal-world scenarios. This was based on the premise that thinking things out well in advance ends up saving serious development headaches later on as the project progresses.</p>
			<p>In contrast, agile methods seem to favor a much more nimble and iterative approach to software development with a high focus on working software over other artifacts, such as documentation. Most teams these days claim to practice some form of iterative software development. However, with this obsession to claim conformance to a specific family of agile methodologies as opposed to the underlying principles, a lot of teams misconstrue having just enough architecture with having no perceptible architecture. This results in a situation where adding new features or enhancing existing ones takes a lot longer than what it previously used to—which then accelerates the devolution of the solution to become the dreaded big ball of mud (<a href="http://www.laputan.org/mud/mud.html#BigBallOfMud">http://www.laputan.org/mud/mud.html#BigBallOfMud</a>).</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Excessive incidental complexity</h2>
			<p>Mike Cohn<a id="_idIndexMarker008"/> popularized the notion of the test pyramid, where he talks about how a large number of unit tests should form the foundation of a sound testing strategy—with numbers decreasing significantly as you move up the pyramid. The rationale here is that as you move up the pyramid, the cost of upkeep goes up copiously while the speed of execution slows down manifold. In reality, though, a lot of teams seem to adopt a strategy that is the exact opposite of this—known as the testing ice cream cone, as depicted here:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B16716_Figure_1.2.jpg" alt="Figure 1.2 – Testing strategy: expectation versus reality&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Testing strategy: expectation versus reality</p>
			<p>The testing ice cream cone is a classic case of what Fred Brooks calls incidental complexity in his seminal paper titled <em class="italic">No Silver Bullet—Essence and Accident in Software Engineering</em> (<a href="http://worrydream.com/refs/Brooks-NoSilverBullet.pdf">http://worrydream.com/refs/Brooks-NoSilverBullet.pdf</a>). All software has some amount of essential complexity that is inherent to the problem being solved. This is especially true when creating solutions for non-trivial problems. However, incidental or accidental complexity is not directly attributable to the problem itself—but is caused by the limitations of the people involved, their skill levels, the tools, and/or abstractions being used. Not keeping tabs on incidental complexity causes teams to veer away from focusing on the real problems, solving which provide the most value. It naturally follows that such teams minimize their odds of success appreciably.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Uncontrolled technical debt</h2>
			<p>Financial debt is<a id="_idIndexMarker009"/> the act of borrowing money from an outside party to quickly finance the operations of a business—with the promise to repay the principal plus the agreed-upon rate of interest in a timely manner. Under the right circumstances, this can accelerate the growth of a business considerably while allowing the owner to retain ownership, reduced taxes, and lower interest rates. On the other hand, the inability to pay back this debt on time can adversely affect credit rating, result in higher interest rates, cash flow difficulties, and other restrictions.</p>
			<p>Technical debt is what results when development teams take arguably suboptimal actions to expedite the delivery of a set of features or projects. For a period of time, just like borrowed money allows you to do things sooner than you could otherwise, technical debt can result in short-term speed. In the long term, however, software teams will have to dedicate a lot more time and effort toward simply managing complexity as opposed to thinking about producing architecturally sound solutions. This can result in a vicious negative cycle, as illustrated in the following diagram:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B16716_Figure_1.3.jpg" alt="Figure 1.3 – Technical debt: implications&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Technical debt: implications</p>
			<p>In a recent McKinsey survey (<a href="https://www.mckinsey.com/business-functions/mckinsey-digital/our-insights/tech-debt-reclaiming-tech-equity">https://www.mckinsey.com/business-functions/mckinsey-digital/our-insights/tech-debt-reclaiming-tech-equity</a>) sent out to CIOs, around 60% reported that the amount of technical debt increased over the past 3 years. At the same time, over 90% of CIOs allocated less than a fifth of their tech budget toward paying it off. Martin Fowler explores (<a href="https://martinfowler.com/articles/is-quality-worth-cost.html#WeAreUsedToATrade-offBetweenQualityAndCost">https://martinfowler.com/articles/is-quality-worth-cost.html#WeAreUsedToATrade-offBetweenQualityAndCost</a>) the deep correlation between high software quality (or the lack thereof) and the ability to enhance software predictably. While carrying a certain amount of technical debt is inevitable and part of doing business, not having a plan to systematically pay off this debt can have significantly <a id="_idIndexMarker010"/>detrimental effects on team productivity and the ability to deliver value.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Ignoring non-functional requirements</h2>
			<p>Stakeholders<a id="_idIndexMarker011"/> often want software teams to spend the majority (if not all) of their time working on features that provide enhanced functionality. This is understandable given that such features provide the highest ROI. These features are called functional requirements.</p>
			<p>Non-functional requirements (also sometimes known as cross-functional requirements), on <a id="_idIndexMarker012"/>the other hand, are those aspects of the system that do not affect functionality directly but have a profound effect on the efficacy of those using and maintaining these systems. There are many kinds of NFRs. A partial list of common NFRs is depicted in the following figure:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B16716_Figure_1.4.jpg" alt="Figure 1.4 – NFRs&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – NFRs</p>
			<p>Very rarely do users explicitly request NFRs, but they almost always expect these features to be part of any system they use. Oftentimes, systems may continue to function without NFRs being met, but not without having an adverse impact on the <em class="italic">quality</em> of the user experience. For example, the home page of a website that loads in under 1 second under low load and takes upward of 30 seconds under higher loads may not be usable during those times of stress. Needless to say, not treating NFRs with the same amount of rigor as explicit, value-adding functional features can lead to unusable systems—and <a id="_idIndexMarker013"/>subsequently failure.</p>
			<p>In this section, we examined some common reasons why software projects to fail. Is it possible to improve our odds? Before we do that, let’s look at the nature of modern software systems and how we can deal with the ensuing complexity.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Modern systems and dealing with complexity</h1>
			<p class="author-quote">We cannot solve our problems with the same level of thinking that created them.</p>
			<p class="author-quote">— Albert Einstein</p>
			<p>As we saw in <a id="_idIndexMarker014"/>the previous section, there<a id="_idIndexMarker015"/> are several reasons why software endeavors fail. In this section, we will try to understand how software gets built, what the currently prevailing realities are, and what adjustments we need to make in order to cope.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>How software gets built</h2>
			<p>Building successful <a id="_idIndexMarker016"/>software is an iterative process of constantly refining knowledge and expressing it in the form of models. We have attempted to capture the essence of the process at a high level here:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B16716_Figure_1.5.jpg" alt="Figure 1.5 – Building software is a continuous refinement of knowledge and models&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Building software is a continuous refinement of knowledge and models</p>
			<p>Before we express a solution in working code, it is necessary to understand <em class="italic">what</em> the problem entails, <em class="italic">why</em> the problem is important to solve, and finally, <em class="italic">how</em> it can be solved. Irrespective of the methodology used (waterfall, agile, and/or anything in between), the process of building software is one where we need to constantly use our knowledge to<a id="_idIndexMarker017"/> refine mental/conceptual models to be able to create valuable solutions.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Complexity is inevitable</h2>
			<p>We find ourselves <a id="_idIndexMarker018"/>in the midst of the fourth industrial revolution, where<a id="_idIndexMarker019"/> the world is becoming more and more digital—with technology being a significant driver of value for businesses. There have been exponential advances in computing technology, as illustrated by Moore’s law:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B16716_Figure_1.6.jpg" alt="Figure 1.6 – Moore’s law&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Moore’s law</p>
			<p>This has also coincided with the rise of the internet.</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B16716_Figure_1.7.jpg" alt="Figure 1.7 – Global internet traffic&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Global internet traffic</p>
			<p>This has meant<a id="_idIndexMarker020"/> that companies are being required to modernize their <a id="_idIndexMarker021"/>software systems much more rapidly than they ever have. Along with all this, the onset of commodity computing services, such as the public cloud, has led to a move away from expensive centralized computing systems to more distributed computing ecosystems. As we attempt to build our most complex solutions, monoliths are being replaced by an environment of distributed, collaborating microservices. Modern philosophies and practices, such as automated testing, architecture fitness functions, continuous integration, continuous delivery, DevOps, security automation, and infrastructure as code, to name a few, are disrupting the way we deliver software solutions.</p>
			<p>All these advances introduce their own share of complexity. Instead of attempting to control the amount of complexity, there is a need to embrace and cope with it.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Optimizing the feedback loop</h2>
			<p>As we enter an <a id="_idIndexMarker022"/>age of encountering our most complex business<a id="_idIndexMarker023"/> problems, we need to embrace new ways of thinking, development philosophy, and an arsenal of techniques to iteratively evolve mature software solutions that will stand the test of time. We need better ways of communicating, analyzing problems, arriving at a collective understanding, creating and modeling abstractions, and then implementing and enhancing the solution.</p>
			<p>To state the obvious—we’re all building software with seemingly brilliant business ideas on one side and our ever-demanding customers on the other, as shown here:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B16716_Figure_1.8.jpg" alt="Figure 1.8 – The software delivery continuum&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – The software delivery continuum</p>
			<p>In between, we have two chasms to cross—the <em class="italic">delivery pipeline</em> and the <em class="italic">feedback pipeline</em>. The delivery pipeline enables us to put software in the hands of our customers, whereas the feedback pipeline allows us to adjust and adapt. As we can see, this is a continuum. If we are to build better, more valuable software, this continuum, this potentially infinite loop, has to be optimized!</p>
			<p>To optimize this loop, we need three characteristics to be present: we need to be fast, we need to be reliable, and we need to do this over and over again. In other words, we need to be rapid, reliable, and repeatable—all at the same time! Take any one of these away and it just won’t sustain.</p>
			<p>DDD promises to provide answers on how to do this in a systematic manner. In the upcoming section, and indeed the rest of this book, we will examine what DDD is and why it is indispensable when working to provide solutions for non-trivial problems in today’s world<a id="_idIndexMarker024"/> of massively distributed teams and <a id="_idIndexMarker025"/>applications.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>What is DDD?</h1>
			<p class="author-quote">Life is really simple, but we insist on making it complicated.</p>
			<p class="author-quote">— Confucius</p>
			<p>In the previous<a id="_idIndexMarker026"/> section, we saw how a myriad of reasons, coupled with system complexity, gets in the way of software project success. The idea of DDD, originally conceived by Eric Evans in his 2003 book, is an approach to software development that focuses on expressing software solutions in the form of a model that closely embodies the core of the problem being solved. It provides a set of principles and systematic techniques to analyze, architect, and implement software solutions in a manner that enhances the chances of success.</p>
			<p>While Evans’ work is indeed seminal, ground-breaking, and way ahead of its time, it is not prescriptive at all. This is a strength in that it has enabled the evolution of DDD beyond what Evans had originally conceived at the time. On the other hand, it also makes it extremely hard to define what DDD actually encompasses, making practical application a challenge. In this section, we will look at some foundational terms and concepts behind DDD. Elaboration and practical application of these concepts will happen in upcoming chapters of this book.</p>
			<p>When encountering a complex business problem, DDD suggests doing the following:</p>
			<ul>
				<li><strong class="bold">Understand the problem</strong>: To<a id="_idIndexMarker027"/> have a deep, shared understanding of the problem, it is necessary for business and technology experts to collaborate closely. Here, we collectively understand what the problem is and why it is valuable to solve. This is termed the <strong class="bold">domain</strong> of <a id="_idIndexMarker028"/>the problem.</li>
				<li><strong class="bold">Break down the problem into more manageable parts</strong>: To keep complexity at manageable levels, break down complex problems into smaller, independently solvable parts. These parts are termed <strong class="bold">subdomains</strong>. It may be necessary to further break down subdomains where the subdomain is still too complex. Assign explicit boundaries to limit the functionality of each subdomain. This boundary is termed the <strong class="bold">bounded context</strong> for that subdomain. It may also be convenient to think of the subdomain as a concept that makes more sense to the domain experts (in the problem space), whereas the bounded context is a concept that makes more sense to the technology experts (in the solution space).</li>
				<li>For each of these bounded contexts, do the following:<ul><li><strong class="bold">Agree on a shared language</strong>: Formalize the understanding by establishing a shared language that is applicable unambiguously within the bounds of the subdomain. This shared language is termed the ubiquitous language of the domain.</li><li><strong class="bold">Express understanding in shared models</strong>: In order to produce working software, express the ubiquitous language in the form of shared models. This model is termed the <strong class="bold">domain model</strong>. There may exist multiple variations<a id="_idIndexMarker029"/> of<a id="_idIndexMarker030"/> this model, each meant to clarify a specific aspect of the solution, for example, a process model, a sequence diagram, working code, and a deployment topology.</li><li><strong class="bold">Embrace the incidental complexity of the problem</strong>: It is important to note that it is not possible to shy away from the essential complexity of a given problem. By breaking down the problem into subdomains and bounded contexts, we are attempting to distribute it (more or less) evenly across more manageable parts.</li><li><strong class="bold">Continuously evolve for greater insight</strong>: It is important to understand that the previous steps are not a one-time activity. Businesses, technologies, processes, and our understanding of these evolve, so it is important for our shared understanding to remain in sync with these models through continuous refactoring.</li></ul></li>
			</ul>
			<p>A pictorial representation of the essence of DDD is expressed here:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B16716_Figure_1.9.jpg" alt="Figure 1.9 – Essence of DDD&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Essence of DDD</p>
			<p>We appreciate that <a id="_idIndexMarker031"/>this is quite a whirlwind introduction to the subject of DDD.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Understanding the problem using strategic design</h2>
			<p>In this section, let’s <a id="_idIndexMarker032"/>demystify some commonly used concepts and terms when working with DDD. First and foremost, we need to understand what we mean by the first <em class="italic">D</em> — <strong class="bold">domain</strong>.</p>
			<h3>What is a domain?</h3>
			<p>The foundational<a id="_idIndexMarker033"/> concept when working with DDD is the notion of a domain. But what exactly is a domain? The word domain, which has its <em class="italic">origins</em> in the 1600s from the old French word <em class="italic">domaine</em> (power) and the Latin word <em class="italic">dominium</em> (property, right of ownership) is a rather confusing word. Depending on who, when, where, and how it is used, it can mean different things.</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B16716_Figure_1.10.jpg" alt="Figure 1.10 – The meaning of domain changes with context&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – The meaning of domain changes with context</p>
			<p>In the context of a business, however, the word domain covers the overall scope of its primary activity—the service it provides to its customers. This is also referred to as the <strong class="bold">problem domain</strong>. For<a id="_idIndexMarker034"/> example, Tesla operates in the domain of electric vehicles, Netflix provides online movies and shows, and McDonald’s provides fast food. Some companies such as Amazon provide services in more than one domain—online retail and cloud computing, among others. The domain of a business (at least the successful ones) almost always<a id="_idIndexMarker035"/> encompasses fairly complex and abstract concepts. To cope with this complexity, it is usual to decompose these domains into more manageable pieces called subdomains. Let’s understand subdomains in more detail next.</p>
			<h3>What is a subdomain?</h3>
			<p>In its essence, DDD provides<a id="_idIndexMarker036"/> means to tackle complexity. Engineers do this by breaking down complex problems into more manageable ones called <strong class="bold">subdomains</strong>. This facilitates better understanding and makes it easier to arrive at a solution. For example, the online retail domain may be divided into subdomains such as product, inventory, rewards, shopping cart, order management, payments, and shipping, as shown in the following figure:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B16716_Figure_1.11.jpg" alt="Figure 1.11 – Subdomains in the retail&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – Subdomains in the retail</p>
			<p>In certain <a id="_idIndexMarker037"/>businesses, subdomains themselves may turn out to become very complex on their own and may require further decomposition. For instance, in the retail example, it may be required to break the products subdomain into further constituent subdomains, such as catalog, search, recommendations, and reviews, as shown here:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B16716_Figure_1.12.jpg" alt="Figure 1.12 – Subdomains in the products subdomain&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Subdomains in the products subdomain</p>
			<p>Further breakdown of subdomains may be needed until we reach a level of manageable complexity. Domain decomposition is an important aspect of DDD. Let’s look at the types of<a id="_idIndexMarker038"/> subdomains to understand this better.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The terms domain and subdomain tend to get used interchangeably quite often. This can be confusing to the casual onlooker. Given that subdomains tend to be quite complex and hierarchical, a subdomain can be a domain in its own right.</p>
			<h4>Types of subdomains</h4>
			<p>Breaking down a <a id="_idIndexMarker039"/>complex domain into more manageable subdomains is a great thing to do. However, not all subdomains are created equal. With any business, the following three types of subdomains are going to be encountered:</p>
			<ul>
				<li><strong class="bold">Core</strong>: The main focus area for the business. This is what provides the biggest differentiation and value. It is, therefore, natural to want to place the most focus on the core subdomain. In the retail example, shopping carts and orders might be the biggest differentiation—and hence may form the core subdomains for that business venture. It is prudent to implement core subdomains in-house, given that it is something that businesses will desire to have the most control over. In the online retail example, the business may want to focus on providing an enriched experience for placing online orders. This will make the <em class="italic">online orders</em> and <em class="italic">shopping cart</em> part of the core subdomain.</li>
				<li><strong class="bold">Supporting</strong>: Like with every great movie, where it is not possible to create a masterpiece without a solid supporting cast, so it is with supporting or auxiliary subdomains. Supporting subdomains are usually very important and very much required but may not be the primary focus of running the business. These supporting subdomains, while necessary to run the business, do not usually offer a significant competitive advantage. Hence, it might even be fine to completely outsource this work or use an off-the-shelf solution as is or with minor tweaks. For <a id="_idIndexMarker040"/>the retail example, assuming that online ordering is the primary focus of this business, catalog management may be a supporting subdomain.</li>
				<li><strong class="bold">Generic</strong>: When working with business applications, you are required to provide a set of capabilities <em class="italic">not</em> directly related to the problem being solved. Consequently, it might suffice to just make use of an off-the-shelf solution. For the retail example, the identity, auditing, and activity tracking subdomains might fall in that category.</li>
			</ul>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It is important to note that the notion of core versus supporting versus generic subdomains is very context-specific. What is core for one business may be supporting or generic for another. Identifying and distilling the core domain requires a deep understanding and experience of what problem is being attempted to be solved.</p>
			<p>Given that the core subdomain establishes most of the business differentiation, it will be prudent to devote the most amount of energy toward maintaining that differentiation. This is illustrated in the core domain chart here:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B16716_Figure_1.13.jpg" alt="Figure 1.13 – Importance of subdomains&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – Importance of subdomains</p>
			<p>Over time, it is only natural that competitors will attempt to emulate your successes. Newer, more efficient methods will arise, reducing the complexity involved and disrupting your core. This may cause the notion of what is currently core to shift and become a supporting<a id="_idIndexMarker041"/> or generic capability, as depicted here:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B16716_Figure_1.14.jpg" alt="Figure 1.14 – Core domain erosion&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – Core domain erosion</p>
			<p>To continue running a successful operation, it is required to constantly innovate at the core. For example, when AWS started the cloud computing business, it only provided simple infrastructure (IaaS) solutions. However, as competitors such as Microsoft and Google started to catch up, AWS has had to provide several additional value-added services (for <a id="_idIndexMarker042"/>example, PaaS and SaaS).</p>
			<p>As is evident, this is not just an engineering problem. It requires a deep understanding of the underlying business. That’s where domain experts can play a significant role.</p>
			<h3>Domain and technical experts</h3>
			<p>Any modern software team requires expertise in<a id="_idIndexMarker043"/> at least two areas—the functionality of the domain and the art of translating it into high-quality software. In most organizations, these exist as at least two distinct groups of people:</p>
			<ul>
				<li><strong class="bold">Domain experts</strong>: Those<a id="_idIndexMarker044"/> who have a deep and intimate understanding of the domain. Domain experts are <strong class="bold">subject-matter experts</strong> (<strong class="bold">SMEs</strong>) who<a id="_idIndexMarker045"/> have a very strong grasp of the business. Domain experts may have varying degrees of expertise. Some SMEs may choose to specialize in specific subdomains, while others may have a broader understanding of how the overall business works.</li>
				<li><strong class="bold">Technical experts</strong>: On the<a id="_idIndexMarker046"/> other hand, enjoy solving specific, quantifiable computer science problems. Often, technical experts do not feel it is worth their while to understand the context of the business they work in. Rather, they seem overly eager to only enhance their technical skills that are a continuation of their learnings in academia.</li>
			</ul>
			<p>While the domain experts specify the <em class="italic">why</em> and the <em class="italic">what</em>, technical experts (software engineers) largely help realize the <em class="italic">how</em>. Strong collaboration and synergy between both groups are essential to ensure sustained high performance and success.</p>
			<h3>A divide originating in language</h3>
			<p>While strong <a id="_idIndexMarker047"/>collaboration<a id="_idIndexMarker048"/> between these groups is necessary, it is important to appreciate that these groups of people seem to have distinct motivations and differences in thinking. Seemingly, this may appear to be restricted to simple things such as differences in their day-to-day language. However, deeper analysis usually reveals a much larger divide in aspects such as goals and motivations. This is illustrated in the figure here:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B16716_Figure_1.15.jpg" alt="Figure 1.15 – Divide originating in language&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – Divide originating in language</p>
			<p>But this is a <a id="_idIndexMarker049"/>book<a id="_idIndexMarker050"/> primarily focused on technical experts. Our point is that it is not possible to be successful by just working on technically challenging problems without gaining a sound understanding of the underlying business context.</p>
			<p>Every decision we take regarding the organization, be it requirements, architecture, or code, has business and user consequences. In order to conceive, architect, design, build and evolve software effectively, our decisions need to aid in creating the optimal business impact. As mentioned, this can only be achieved if we have a clear understanding of the problem we intend to solve. This leads us to the realization that there exist two distinct <em class="italic">domains</em> when arriving at the solution for a problem.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The use of the word domain in this context is done so in an abstract sense—not to be confused <a id="_idIndexMarker051"/>with <a id="_idIndexMarker052"/>the concept of the business domain introduced earlier. </p>
			<h3>Problem domain</h3>
			<p>This is a term that <a id="_idIndexMarker053"/>is used to capture information that simply defines the problem while consciously avoiding any details of the solution. It includes details such as <em class="italic">why</em> we are trying to solve the problem, <em class="italic">what</em> we are trying to achieve, and <em class="italic">how</em> it needs to be solved. It is important to note that the <em class="italic">why</em>, <em class="italic">what</em>, and <em class="italic">how</em> are from the perspective of the customers/stakeholders, not from the perspective of the engineers providing software solutions to the problem.</p>
			<p>Consider the example of a retail bank that already provides a checking account capability for their customers. They want access to more liquid funds. They need to encourage customers to maintain higher account balances to achieve that. They are looking to introduce a new product called the <em class="italic">premium checking account</em> with additional features such as higher interest rates, overdraft protection, and no-charge ATM access. The problem domain expressed in the form of why, what, and how is shown here:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B16716_01_Table_02.jpg" alt="Table 1.2 – Problem domain: why, what, and how&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.2 – Problem domain: why, what, and how</p>
			<p>Now that we have <a id="_idIndexMarker054"/>defined the problem and the motivations surrounding it, let’s examine how it can inform the solution.</p>
			<h3>Solution domain</h3>
			<p>A term used to<a id="_idIndexMarker055"/> describe the environment in which the solution is developed. In other words, the process of translating requirements into working software (this includes design, development, testing, and deployment). Here, the emphasis is on the <em class="italic">how</em> of the problem being solved from a software implementation perspective. However, it is very difficult to arrive at a solution without having an appreciation of the why and the what.</p>
			<p>Building on the previous premium checking account example, the code-level solution for this problem may look something like this:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/ch1-1.jpg" alt=""/>
				</div>
			</div>
			<p>This likely appears<a id="_idIndexMarker056"/> like a significant leap from a problem domain description, and indeed it is. Before a solution like this can be arrived at, there may need to exist multiple levels of refinement of the problem. This process of refinement is usually messy and may lead to inaccuracies in the understanding of the problem, resulting in a solution that may be good (for example, one that is sound from an engineering, software architecture standpoint) but not one that solves the problem at hand. Let’s look at how we can continuously refine our understanding by closing the problem and solution domain gap.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Promoting a shared understanding using a ubiquitous language</h2>
			<p>Previously, we <a id="_idIndexMarker057"/>saw how organizational silos could result in valuable information getting diluted. At a credit card company I used to work with, the words plastic, payment instrument, account, <strong class="bold">PAN</strong> (<strong class="bold">Primary Account Number</strong>), <strong class="bold">BIN</strong> (<strong class="bold">Bank Identification Number</strong>), and<a id="_idIndexMarker058"/> card<a id="_idIndexMarker059"/> were all used by different team members to mean the exact same thing—the <em class="italic">credit card</em>—when working in the same area of the application. On the other hand, a term such as <em class="italic">user</em> would be used to sometimes mean a customer, a relationship manager, or a technical customer support employee. To make matters worse, a lot of these muddled use of terms got implemented in code as well. While this might feel like a trivial thing, it had far-reaching consequences. Product experts, architects, and developers all came and went, each regressively contributing to more confusion, muddled designs, implementation, and technical debt with every new enhancement—accelerating the journey toward the dreaded, unmaintainable big ball of mud (<a href="http://www.laputan.org/mud/">http://www.laputan.org/mud/</a>).</p>
			<p>DDD advocates breaking down these artificial barriers and putting the domain experts and the developers on the same level footing by working collaboratively toward creating what DDD calls a <em class="italic">ubiquitous language</em>—a shared vocabulary of terms, words, and phrases to continuously enhance the collective understanding of the entire team. This phraseology is then used actively in every aspect of the solution: the everyday vocabulary, the designs, the code—in short, by <em class="italic">everyone</em> and <em class="italic">everywhere</em>. Consistent use of the common, ubiquitous language helps reinforce a shared understanding and produce solutions that better reflect the mental model of the domain experts.</p>
			<h3>Evolving a domain model and a solution</h3>
			<p>The ubiquitous<a id="_idIndexMarker060"/> language<a id="_idIndexMarker061"/> helps establish a consistent, albeit informal, lingo among team members. To enhance understanding, this can be further refined into a formal set of abstractions—a <em class="italic">domain model</em> to represent the solution in software. When a problem is presented to us, we subconsciously attempt to form mental representations of potential solutions. Furthermore, the type and nature of these representations (models) may differ wildly based on factors such as our understanding of the problem, our backgrounds, and experiences. This implies that it is natural for these models to be different. For example, the same problem can be thought of differently by various team members, as shown here:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B16716_Figure_1.16.jpg" alt="Figure 1.16 – Multiple models to represent the solution &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – Multiple models to represent the solution </p>
			<p>As illustrated<a id="_idIndexMarker062"/> here, the<a id="_idIndexMarker063"/> business expert may think of a process model, whereas the test engineer may think of exceptions and boundary conditions to arrive at a test strategy and so on.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><em class="italic">Figure 1.16</em> depicts the existence of multiple models. There may be several other perspectives, for example, a customer experience model and an information security model, which are not depicted.</p>
			<p>Care should be taken to retain focus on solving the business problem at hand at all times. Teams will be better served if they expend the same amount of effort modeling business logic as the technical aspects of the solution. To keep accidental complexity in check, it will be best to isolate the infrastructure aspects of the solution from this model. These models can take several forms, including conversations, whiteboard sessions, documentation, diagrams, tests, and other forms of architecture fitness functions. It is also important to note that this is <em class="italic">not</em> a one-time activity. As the business evolves, the domain model and the solution will need to keep up. This can only be achieved through <a id="_idIndexMarker064"/>close <a id="_idIndexMarker065"/>collaboration between the domain experts and the developers at all times.</p>
			<h3>Scope of domain models and the bounded context</h3>
			<p>When creating <a id="_idIndexMarker066"/>domain <a id="_idIndexMarker067"/>models, one of the dilemmas is in deciding how to restrict the scope of these models. You can attempt to create a single domain model that acts as a solution for the entire problem. On the other hand, we may go the route of creating extremely fine-grained models that cannot exist meaningfully without having a strong dependency on others. There are pros and cons in going each way. Whatever be the case, each solution has a scope—bounds to which it is confined. This boundary<a id="_idIndexMarker068"/> is termed a <strong class="bold">bounded context</strong>.</p>
			<p>There seems to exist a lot of confusion between the terms subdomains and bounded contexts. What is the difference? It turns out that subdomains are problem space concepts, whereas bounded contexts are solution space concepts. This is best explained through the use of an example. Let’s consider the example of a fictitious Acme bank that provides two products: credit cards and retail bank. This may decompose to the following subdomains depicted here:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B16716_Figure_1.17.jpg" alt="Figure 1.17 – Banking subdomains at Acme bank&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.17 – Banking subdomains at Acme bank</p>
			<p>When creating a solution for the problem, many possible solution options exist. We have depicted a few options here:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B16716_Figure_1.18.jpg" alt="Figure 1.18 – Bounded context options at Acme bank&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.18 – Bounded context options at Acme bank</p>
			<p>These are just a <a id="_idIndexMarker069"/>few<a id="_idIndexMarker070"/> examples of decomposition patterns to create bounded contexts. The exact set of patterns you may choose to use may vary depending on currently prevailing realities, such as the following:</p>
			<ul>
				<li>Current organizational structures</li>
				<li>Domain experts’ responsibilities</li>
				<li>Key activities and pivotal events</li>
				<li>Existing applications</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Conway’s law</strong> asserts that<a id="_idIndexMarker071"/> organizations are constrained to produce application designs that are copies of their communication structures. Your current organizational structures may not be optimally aligned to your desired solution approach. The inverse Conway maneuver may be applied to achieve isomorphism with the business architecture. Whatever the method used to decompose a problem into a set of bounded contexts, care should be taken to make sure that the coupling between them is kept as low as possible.</p>
			<p>While bounded<a id="_idIndexMarker072"/> contexts <a id="_idIndexMarker073"/>ideally need to be as independent as possible, they may still need to communicate with each other. When using DDD, the system as a whole can be represented as a set of bounded contexts that have relationships with each other. These relationships define how these bounded contexts can integrate with each <a id="_idIndexMarker074"/>other and are called <strong class="bold">context maps</strong>. A sample context map is shown here:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B16716_Figure_1.19.jpg" alt="Figure 1.19 – Sample context map for Acme bank&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.19 – Sample context map for Acme bank</p>
			<p>The context<a id="_idIndexMarker075"/> map shows the bounded contexts and the relationship between them. These relationships can be a lot more nuanced than what is depicted here. We will discuss context maps<a id="_idIndexMarker076"/> and<a id="_idIndexMarker077"/> communication patterns in <em class="italic">Chapter 9</em>, <em class="italic">Integrating with External Systems</em>.</p>
			<p>We have now covered a catalog of concepts that are core to the strategic design tenets of DDD. Let’s look at some tools that can help expedite this process.</p>
			<p>In subsequent chapters, we will reinforce all the concepts introduced here in a lot more detail.</p>
			<p>In the next section, we will look at why the ideas of DDD, introduced all those years ago, are still very relevant. We will see why, if anything, they are becoming even more relevant now than ever.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Implementing the solution using tactical design</h2>
			<p>In the previous<a id="_idIndexMarker078"/> section, we saw how we can arrive at a shared understanding of the problem using strategic design tools. We need to use this understanding to create a solution. DDD’s tactical design aspects, tools, and techniques help translate this understanding into working software. Let’s look at these aspects in detail. In <em class="italic">Part 2</em> of the book, we will apply these to solve a real-world problem.</p>
			<p>It is convenient to think of the tactical design aspects, as depicted in this figure:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B16716_Figure_1.20.jpg" alt="Figure 1.20 – The elements of DDD’s tactical design&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.20 – The elements of DDD’s tactical design</p>
			<p>Let’s look at the<a id="_idIndexMarker079"/> definitions of these elements.</p>
			<h3>Value objects</h3>
			<p>Value objects are<a id="_idIndexMarker080"/> immutable objects that <a id="_idIndexMarker081"/>encapsulate the data and behavior of one or more related attributes. It may be convenient to think of value objects as named primitives. For example, consider a <strong class="source-inline">MonetaryAmount</strong> value object. A simple implementation can contain two attributes—an amount and a currency code. This allows encapsulation of behavior, such as adding two <strong class="source-inline">MonetaryAmount</strong> objects safely, as shown here:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B16716_Figure_1.21.jpg" alt="Figure 1.21 – A simple MonetaryAmount value object&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.21 – A simple MonetaryAmount value object</p>
			<p>The effective use of value objects helps protect from the primitive obsession with anti-patterns while increasing clarity. It also allows composing higher-level abstractions using one or more valuable objects. It is important to note that value objects do not have the notion of identity. That is, two values with the same value are treated equally. So, two <strong class="source-inline">MonetaryAmount</strong> objects with the same amount and currency code will be considered equal. Also, it is important to make value objects immutable. A need to change any of the attributes should result in the creation of a new attribute.</p>
			<p>It is easy to dismiss value objects as a mere engineering technique, but the consequences of (not) using them can be far-reaching. In the <strong class="source-inline">MonetaryAmount</strong> example, it is possible for the <em class="italic">amount</em> and <em class="italic">currency code</em> to exist as independent attributes. However, the use of <strong class="source-inline">MonetaryAmount</strong> enforces the notion of the <em class="italic">ubiquitous language</em>. Hence, we recommend the use of value objects as a default instead of using primitives.</p>
			<p>Critics may be <a id="_idIndexMarker082"/>quick to point out problems such <a id="_idIndexMarker083"/>as class explosion and performance issues. But in our experience, the benefits usually outweigh the costs. But it may be necessary to re-examine this approach if problems occur.</p>
			<h3>Entities</h3>
			<p>An entity is an<a id="_idIndexMarker084"/> object <a id="_idIndexMarker085"/>with a <em class="italic">unique identity</em> and <em class="italic">encapsulates</em> the data and behavior of its attributes. It may be convenient to view entities as a collection of other entities and value objects that need to be grouped together. A very simple example of an entity is shown here:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B16716_Figure_1.22.jpg" alt="Figure 1.22 – A simple depiction of a Transaction entity&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.22 – A simple depiction of a Transaction entity</p>
			<p>In contrast to a value object, entities have the notion of a unique identifier. This means that two <strong class="source-inline">Transaction</strong> entities with the same underlying values but a different <strong class="bold">identifier</strong> (<strong class="bold">id</strong>) value will be considered different. On the other hand, two entity instances with the same value for the identifier are considered equal. Furthermore, unlike value objects, entities are mutable. That is, their attributes can and will change over time.</p>
			<p>The concept of value objects and entities depends on the context within which they are used. In an order management system, the <em class="italic">address</em> may be implemented as a value object in the <em class="italic">e-commerce</em> bounded context, whereas it may be needed to be implemented as an entity in the <em class="italic">order fulfillment</em> bounded context.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It is common to collectively refer to entities and value objects as <em class="italic">domain objects</em>. </p>
			<h3>Aggregates</h3>
			<p>As seen<a id="_idIndexMarker086"/> previously, entities <a id="_idIndexMarker087"/>are hierarchical in that they can be composed of one more child. Fundamentally, an aggregate has the following qualities:</p>
			<ul>
				<li>Is an entity usually composed of other child entities and value objects</li>
				<li>Encapsulates access to child entities by exposing behavior (usually <a id="_idIndexMarker088"/>referred to as <em class="italic">commands</em><em class="italic">)</em></li>
				<li>Is a boundary that is used to enforce business invariants (rules) consistently</li>
				<li>Is an entry point to get things done within a bounded context</li>
			</ul>
			<p>Consider the example of a <strong class="source-inline">CheckingAccount</strong> aggregate:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B16716_Figure_1.23.jpg" alt="Figure 1.23 – A simple depiction of a CheckingAccount aggregate&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.23 – A simple depiction of a CheckingAccount aggregate</p>
			<p>Note how <strong class="source-inline">CheckingAccount</strong> is composed of the <strong class="source-inline">AccountHolder</strong> and <strong class="source-inline">Transaction</strong> entities, among<a id="_idIndexMarker089"/> other things. In this example, let’s<a id="_idIndexMarker090"/> assume that the overdraft feature (ability to hold a negative account balance) is only <a id="_idIndexMarker091"/>available for <strong class="bold">high-net-worth individuals</strong> (<strong class="bold">HNI</strong>). Any attempt to change <strong class="source-inline">currentBalance</strong> needs to occur in the form of a unique <strong class="source-inline">Transaction</strong> for audit purposes—irrespective of its outcome. For this reason, the <strong class="source-inline">CheckingAccount</strong> aggregate makes use of the <strong class="source-inline">Transaction</strong> entity. Although <strong class="source-inline">Transaction</strong> has <strong class="source-inline">approve</strong> and <strong class="source-inline">reject</strong> methods as part of its interface, only the aggregate has access to these methods. In this way, the aggregate enforces the business invariant while maintaining high levels of encapsulation. A potential implementation of the <strong class="source-inline">tryWithdraw</strong> method is shown here:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/ch1-2.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li>The <strong class="source-inline">CheckingAccount</strong> aggregate is composed of child entities and value objects.</li>
				<li>The <strong class="source-inline">tryWithdraw</strong> method acts as a consistency boundary for the operation. Irrespective of the outcome (approved or rejected), the system will remain in a consistent state. In other words, the <strong class="source-inline">currentBalance</strong> can change only within the confines of the <strong class="source-inline">CheckingAccount</strong> aggregate.</li>
				<li>The aggregate enforces the appropriate business invariant (rule) to allow overdrafts only for HNIs.</li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Aggregates are also referred to as aggregate roots, that is, the object that is at the root of the entity hierarchy. We use these terms synonymously in this book.</p>
			<h3>Domain events</h3>
			<p>As mentioned previously, aggregates<a id="_idIndexMarker092"/> dictate how<a id="_idIndexMarker093"/> and when state changes occur. Other parts of the system may be interested in knowing about the occurrence of changes that are significant to the business, for example, an order is placed or payment is received. <em class="italic">Domain events</em> are the means to convey that something significant to the business has occurred. It is important to differentiate between system events and domain events. For example, in the context of a retail bank, a <em class="italic">row was saved</em> in the database or a <em class="italic">server ran out of disk space</em> may classify as system events, whereas a <em class="italic">deposit was made</em> to a checking account and <em class="italic">fraudulent activity was detected</em> on a transaction could be classified as domain events. In other words, domain events are things that <em class="italic">domain experts care about</em>.</p>
			<p>It may be prudent to make use of domain events to reduce the amount of coupling between bounded contexts, making it a critical building block of DDD.</p>
			<h3>Repositories</h3>
			<p>Most<a id="_idIndexMarker094"/> businesses<a id="_idIndexMarker095"/> require the durability of data. For this reason, the aggregate state needs to be persisted and retrieved when needed. Repositories are objects that enable persisting and loading <em class="italic">aggregate</em> instances. This is well documented in Martin Fowler’s <em class="italic">Patterns of Enterprise Application Architecture</em> book as part of the <em class="italic">repository</em> (<a href="https://martinfowler.com/eaaCatalog/repository.html">https://martinfowler.com/eaaCatalog/repository.html</a>) pattern. It is pertinent to note that we are referring to aggregate repositories here, not just any entity repository. The singular purpose of this repository is to load a <em class="italic">single instance</em> of an aggregate using its identifier. It is important to note that this repository does not support finding aggregate instances using any other means. This is because business operations happen as part of manipulating a single instance of the aggregate within its bounded context.</p>
			<h3>Factories</h3>
			<p>In order to <a id="_idIndexMarker096"/>work <a id="_idIndexMarker097"/>with aggregates and value objects, instances of these need to be constructed. In simple cases, it might suffice to use a constructor to do so. However, aggregate and value object instances can become quite complex depending on the amount of state they encapsulate. In such cases, it may be prudent to consider delegating object construction responsibilities to a <em class="italic">factory</em> external to the aggregate/value object. We make use of the static factory method, builder, and dependency injection quite commonly in our day-to-day work. Joshua Bloch <a id="_idIndexMarker098"/>discusses several <a id="_idIndexMarker099"/>variations of this pattern in <a href="B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Where and How Does DDD Fit?</em>.</p>
			<h3>Services</h3>
			<p>When working <a id="_idIndexMarker100"/>within the confines of a single bounded context, the public interface (commands) of the aggregate provides a natural API. However, more complex business operations may require interacting with multiple bounded contexts and aggregates. In other words, we may find ourselves in situations where certain business operations do not fit naturally with any single aggregate. Even if interactions are limited to a single bounded context, there may be a need to expose that functionality in an implementation-neutral manner. In such cases, you may consider the use of objects<a id="_idIndexMarker101"/> called <em class="italic">services</em>. Services come in at least three<a id="_idIndexMarker102"/> flavors:</p>
			<ul>
				<li><strong class="bold">Domain services</strong>: To enable<a id="_idIndexMarker103"/> coordinating <a id="_idIndexMarker104"/>operations among more than one aggregate – for example, transferring money between two checking accounts at a retail bank.</li>
				<li><strong class="bold">Infrastructure services</strong>: To<a id="_idIndexMarker105"/> enable interactions <a id="_idIndexMarker106"/>with a utility that is not core to the business – for example, logging and sending emails at the retail bank.</li>
				<li><strong class="bold">Application services</strong>: To<a id="_idIndexMarker107"/> enable coordination <a id="_idIndexMarker108"/>between domain services, infrastructure services, and other application services – for example, sending email notifications after a successful inter-account money transfer.</li>
			</ul>
			<p>Services can also be stateful or stateless. It is best to allow aggregates to manage state, making use of repositories, while allowing services to coordinate and/or orchestrate business flows. In complex cases, there may be a need to manage the state of the flow itself. We will look at more concrete examples in <em class="italic">Part 2</em> of this book.</p>
			<p>It may become tempting to implement business logic almost exclusively using services—inadvertently leading<a id="_idIndexMarker109"/> to the anemic domain model anti-pattern (<a href="https://martinfowler.com/bliki/AnemicDomainModel.html">https://martinfowler.com/bliki/AnemicDomainModel.html</a>). It is worthwhile striving to encapsulate business logic within the confines of aggregates as a default.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Why is DDD relevant? Why now?</h1>
			<p class="author-quote">He who has a why to live for can bear almost any how.</p>
			<p class="author-quote">— Friedrich Nietzsche</p>
			<p>In a lot of ways, DDD <a id="_idIndexMarker110"/>was way ahead of its time when Eric Evans introduced the concepts and principles back in 2003. DDD seems to have gone from strength to strength. In this section, we will examine why DDD is even more relevant today than it was when Eric Evans wrote his book on the subject way back in 2003.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Rise of open source</h2>
			<p>Eric Evans, during <a id="_idIndexMarker111"/>his keynote address at the Explore DDD conference in 2017, lamented how difficult it was to implement even the simplest concepts, such as immutability in value objects, when his book had released. In contrast, though, nowadays, it’s simply a matter of importing <a id="_idIndexMarker112"/>mature, well-documented, tested libraries, such as Project Lombok (<a href="https://projectlombok.org/">https://projectlombok.org/</a>) or Immutables (<a href="https://immutables.github.io/">https://immutables.github.io/</a>), to<a id="_idIndexMarker113"/> be productive, literally in a matter of minutes. To say that open source software has revolutionized the software industry would be an <a id="_idIndexMarker114"/>understatement! At the time of writing, the public Maven repository (<a href="https://mvnrepository.com">https://mvnrepository.com</a>) indexes no less than a staggering <strong class="bold">18.3 million artifacts</strong> in a large assortment of popular categories ranging from databases and language runtimes to test frameworks, and many, many more, as shown in the following chart:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B16716_Figure_1.24.jpg" alt="Figure 1.24 – Open source Java over the years (source: https://mvnrepository.com/)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.24 – Open source Java over the years (source: <a href="https://mvnrepository.com/">https://mvnrepository.com/</a>)</p>
			<p>Java stalwarts such as the Spring Framework and more recent innovations such as Spring Boot and Quarkus make it a no-brainer to create production-grade applications literally in a matter of minutes. Furthermore, frameworks such as Axon and Lagom, among others, make it relatively simple to implement advanced architecture patterns such are CQRS and<a id="_idIndexMarker115"/> event sourcing, which is very complementary to implementing DDD-based solutions.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Advances in technology</h2>
			<p>DDD by no<a id="_idIndexMarker116"/> means is just about technology; it could not be completely agnostic to the choices available at the time. 2003 was the heyday of heavyweight and ceremony-heavy frameworks, such <a id="_idIndexMarker117"/>as <strong class="bold">Java 2 Enterprise Edition</strong> (<strong class="bold">J2EE</strong>), <strong class="bold">Enterprise JavaBeans</strong> (<strong class="bold">EJB</strong>), SQL <a id="_idIndexMarker118"/>databases, and <strong class="bold">object relational mappers</strong> (<strong class="bold">ORMs</strong>)—with not much choice beyond that when it <a id="_idIndexMarker119"/>came to enterprise tools and patterns to <a id="_idIndexMarker120"/>build complex software, at least out in the public domain. The software world has evolved and come a very long way from there. In fact, modern game-changers such as Ruby on Rails and the public cloud were just getting released. In contrast, though, we now have no shortage of application frameworks, NoSQL databases, and programmatic APIs to create infrastructure components with a lot more releasing with monotonous regularity.</p>
			<p>All these innovations allow for rapid experimentation, continuous learning, and iteration at pace. These game-changing advances in technology have also coincided with the exponential rise of the internet and e-commerce as viable means to carry out successful businesses. In fact, the impact of the internet is so pervasive that it is almost inconceivable to launch businesses without a digital component being an integral component. Finally, the consumerization and wide-scale penetration of smartphones, IoT devices, and social media have meant that data is being produced at rates inconceivable as recent as a decade ago. This means that we are building for and solving the most <a id="_idIndexMarker121"/>complicated problems by several orders of magnitude.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Rise of distributed computing</h2>
			<p>There was a <a id="_idIndexMarker122"/>time when building large monoliths was very much the default. But an exponential rise in computing technology, the public cloud (IaaS, PaaS, SaaS, and FaaS), big data storage, and processing volumes, which has coincided with an arguable slowdown in the ability to continue creating faster CPUs, has meant a turn toward more decentralized methods of solving problems.</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B16716_Figure_1.25.jpg" alt="Figure 1.25 – Global information storage capacity&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.25 – Global information storage capacity</p>
			<p>DDD, with its emphasis on dealing with complexity by breaking unwieldy monoliths into more manageable units in the form of subdomains and bounded contexts, fits naturally into this style of programming. Hence, it is no surprise to see a renewed interest in adopting DDD<a id="_idIndexMarker123"/> principles and techniques when crafting modern solutions. To quote Eric Evans, it is no surprise that DDD is even more relevant now than when it was originally conceived!</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Summary</h1>
			<p>In this chapter, we examined some common reasons why software projects fail. We saw how inaccurate or misinterpreted requirements, architecture (or the lack thereof), and excessive technical debt can get in the way of meeting business goals and success.</p>
			<p>We looked at the basic building blocks of DDD, such as domains, subdomains, ubiquitous language, domain models, bounded contexts, and context maps. We also examined why the principles and techniques of DDD are still very much relevant in the modern age of microservices and serverless. You should now be able to appreciate the basic terms of DDD and understand why it is important in today’s context.</p>
			<p>In the next chapter, we will take a closer look at the real-world mechanics of DDD. We will delve deeper into the strategic and tactical design elements of DDD and look at how using these can help form the basis for better communication and create more robust designs.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Further reading</h1>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B16716_01_Table_03a.jpg" alt=""/>
				</div>
			</div>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B16716_01_Table_03b.jpg" alt=""/>
				</div>
			</div>
		</div>
	</body></html>