- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Adding Service Discovery Using Netflix Eureka
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Netflix Eureka添加服务发现
- en: In this chapter, we will learn how to use Netflix Eureka as a discovery service
    for microservices based on Spring Boot. To allow our microservices to communicate
    with Netflix Eureka, we will use the Spring Cloud module for Netflix Eureka clients.
    Before we delve into the details, we will elaborate on why a discovery service
    is needed and why a DNS server isn’t sufficient.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何基于Spring Boot使用Netflix Eureka作为微服务的发现服务。为了使我们的微服务能够与Netflix Eureka通信，我们将使用Spring
    Cloud模块中的Netflix Eureka客户端。在我们深入细节之前，我们将详细阐述为什么需要一个发现服务以及为什么DNS服务器不足以满足需求。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to service discovery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现简介
- en: Setting up a Netflix Eureka server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Netflix Eureka服务器
- en: Connecting microservices to a Netflix Eureka server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微服务连接到Netflix Eureka服务器
- en: Setting up the configuration for development use
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发使用的配置
- en: Trying out Netflix Eureka as a discovery service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用Netflix Eureka作为发现服务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第21章*，*使用macOS的安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第22章*，*使用WSL 2和Ubuntu的Microsoft Windows安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter09`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例均来自`$BOOK_HOME/Chapter09`的源代码。
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to add Netflix Eureka as a discovery service to the
    microservices landscape, you can compare it with the source code for *Chapter
    7*, *Developing Reactive Microservices*. You can use your favorite `diff` tool
    and compare the two folders, that is, `$BOOK_HOME/Chapter07` and `$BOOK_HOME/Chapter09`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章源代码中应用的变化，即查看将Netflix Eureka作为发现服务添加到微服务领域的具体步骤，你可以将其与*第7章*，*开发响应式微服务*的源代码进行比较。你可以使用你喜欢的`diff`工具比较两个文件夹，即`$BOOK_HOME/Chapter07`和`$BOOK_HOME/Chapter09`。
- en: Introducing service discovery
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍服务发现
- en: Service discovery is probably the most important support function required to
    make a landscape of cooperating microservices production-ready. Netflix Eureka
    was the first discovery server supported by Spring Cloud.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现可能是使协作微服务领域生产就绪所需的最重要支持功能。Netflix Eureka是Spring Cloud支持的第一个发现服务器。
- en: We are strictly speaking about a *service* for *service discovery*, but instead
    of referring to it as a *service discovery service*, it will simply be referred
    to as a *discovery service*. When referring to an actual implementation of *service
    discovery*, like Netflix Eureka, the term *discovery server* will be used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们严格来说是在讨论*服务发现*的*服务*，但不会将其称为*服务发现服务*，而会简单地称为*发现服务*。当提到像Netflix Eureka这样的实际*服务发现*实现时，将使用*发现服务器*这个术语。
- en: We will see how easy it is to register microservices with Netflix Eureka when
    using Spring Cloud. We will also learn how a client can use Spring Cloud LoadBalancer
    to send HTTP requests to one of the instances registered in Netflix Eureka. Finally,
    we will try scaling the microservices up and down, together with running some
    disruptive tests to see how Netflix Eureka can handle different types of fault
    scenarios.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到在使用Spring Cloud时，将微服务注册到Netflix Eureka是多么容易。我们还将学习客户端如何使用Spring Cloud LoadBalancer向Netflix
    Eureka中注册的实例之一发送HTTP请求。最后，我们将尝试对微服务进行扩缩容，并运行一些破坏性测试以查看Netflix Eureka如何处理不同类型的故障场景。
- en: 'Before we jump into the implementation details, we will look at the following
    topics:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现细节之前，我们将探讨以下主题：
- en: The problem with DNS-based service discovery
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于DNS的服务发现的问题
- en: Challenges with service discovery
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现面临的挑战
- en: Service discovery with Netflix Eureka in Spring Cloud
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spring Cloud中使用Netflix Eureka进行服务发现
- en: The problem with DNS-based service discovery
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于DNS的服务发现的问题
- en: Why can’t we simply start new instances of a microservice and rely on round-robin
    DNS?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能简单地启动新的微服务实例并依赖轮询DNS？
- en: The idea behind round-robin DNS is that each instance of a microservice registers
    its IP address under the same name in a DNS server. When a client asks for IP
    addresses for the DNS name, the DNS server will return a list of IP addresses
    for the registered instances. The client can use this list of IP addresses to
    send requests to the microservice instances in a round-robin fashion, using the
    IP addresses one after another.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询DNS背后的想法是，微服务的每个实例都在DNS服务器下以相同的名称注册其IP地址。当客户端请求DNS名称的IP地址时，DNS服务器将返回注册实例的IP地址列表。客户端可以使用这个IP地址列表以轮询的方式向微服务实例发送请求，依次使用IP地址。
- en: 'Let’s try it out and see what happens! Follow these steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看会发生什么！按照以下步骤操作：
- en: 'Assuming that you have followed the instructions from *Chapter 7*, *Developing
    Reactive Microservices*, start the system landscape and insert some test data
    with the following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你已经遵循了*第7章*，*开发反应式微服务*中的说明，启动系统景观并使用以下命令插入一些测试数据：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Scale up the `review` microservice to two instances:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`review`微服务扩展到两个实例：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Ask the composite product service for the IP addresses it finds for the `review`
    microservice:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向复合产品服务请求它找到的`review`微服务的IP地址：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Expect an answer like the following:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期得到如下回答：
- en: '![A picture containing text  Description automatically generated](img/B19825_09_01.png)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![包含文本的图片，描述自动生成](img/B19825_09_01.png)'
- en: 'Figure 9.1: Review microservice IP addresses'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.1：检查微服务IP地址
- en: Great, the composite product service sees two IP addresses – in my case, `192.168.96.9`
    and `192.168.96.8` – one for each instance of the `review` microservice!
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了，复合产品服务看到了两个IP地址——在我的情况下，是`192.168.96.9`和`192.168.96.8`——每个`review`微服务实例一个！
- en: 'If you want to, you can verify that these are the correct IP addresses by using
    the following commands. The commands ask each instance of the `review` microservice
    for its IP address:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想的话，可以使用以下命令验证这些确实是正确的IP地址。这些命令会请求`review`微服务的每个实例的IP地址：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last line in the output from each command should contain one of the IP
    addresses, as shown in the preceding code. For example:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个命令输出的最后一行应包含一个IP地址，如前述代码所示。例如：
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B19825_09_02.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，描述自动生成，中等置信度](img/B19825_09_02.png)'
- en: 'Figure 9.2: IP address output'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：IP地址输出
- en: 'Now, let’s try out a couple of calls to the `product-composite` service and
    see whether it uses both instances of the `review` microservice:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试调用`product-composite`服务，看看它是否使用了`review`微服务的两个实例：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unfortunately, we will only get responses from one of the microservice instances,
    as in this example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们只会从微服务实例中的一个得到响应，就像这个例子一样：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_09_03.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，描述自动生成](img/B19825_09_03.png)'
- en: 'Figure 9.3: Response from one review instance only'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：仅一个审查实例的响应
- en: That was disappointing!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这真令人失望！
- en: Okay, so what is going on here?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里发生了什么？
- en: A DNS client asks a DNS server to resolve a DNS name and receives a list of
    IP addresses. Next, the DNS client tries out the received IP addresses one by
    one until it finds one that works, in most cases the first one in the list. A
    DNS client typically holds on to a working IP address; it does not apply a round-robin
    approach per request. Added to this, neither a typical DNS server implementation
    nor the DNS protocol itself is well suited for handling volatile microservice
    instances that come and go all the time. Because of this, even though DNS-based
    round-robin is appealing in theory, it is not very practical to use for the service
    discovery of microservice instances.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: DNS客户端会请求DNS服务器解析DNS名称，并接收一个IP地址列表。接下来，DNS客户端会逐个尝试接收到的IP地址，直到找到一个可以工作的地址，在大多数情况下是列表中的第一个。DNS客户端通常会保留一个可以工作的IP地址；它不会为每个请求应用轮询方法。此外，典型的DNS服务器实现以及DNS协议本身都不太适合处理经常来来去去的易变微服务实例。正因为如此，尽管基于DNS的轮询在理论上很有吸引力，但在实际中并不实用，用于微服务实例的服务发现。
- en: 'Before we move on and learn how to handle service discovery in a better way,
    let’s shut down the system landscape:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续学习如何更好地处理服务发现之前，让我们关闭系统景观：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Challenges with service discovery
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务发现挑战
- en: So, we need something a bit more powerful than a plain DNS to keep track of
    available microservice instances!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要比普通的DNS更强大的东西来跟踪可用的微服务实例！
- en: 'We must take the following into consideration when we’re keeping track of many
    small moving parts, that is, microservice instances:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们跟踪许多小部件时，我们必须考虑以下因素，即微服务实例：
- en: New instances can start up at any point in time.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新实例可以在任何时间点启动。
- en: Existing instances can stop responding and eventually crash at any point in
    time.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的实例可能在任何时间点停止响应并最终崩溃。
- en: Some of the failing instances might be okay after a while and should start to
    receive traffic again, while others will not and should be removed from the service
    registry.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些失败的实例可能过一段时间后可以恢复正常，并开始再次接收流量，而另一些则不会，应该从服务注册表中移除。
- en: Some microservice instances might take some time to start up; that is, just
    because they can receive HTTP requests doesn’t mean that traffic should be routed
    to them.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些微服务实例可能需要一些时间才能启动；也就是说，仅仅因为它们可以接收HTTP请求，并不意味着流量应该被路由到它们。
- en: Unintended network partitioning and other network-related errors can occur at
    any time.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不预期的网络分区和其他与网络相关的错误可能随时发生。
- en: Building a robust and resilient discovery server is not an easy task, to say
    the least. Let’s see how we can use Netflix Eureka to handle these challenges!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 至少可以说，构建一个强大且弹性的发现服务器不是一件容易的任务。让我们看看我们如何使用Netflix Eureka来处理这些挑战！
- en: Service discovery with Netflix Eureka in Spring Cloud
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Cloud中使用Netflix Eureka进行服务发现
- en: Netflix Eureka implements client-side service discovery, meaning that the clients
    run software that talks to the discovery server, Netflix Eureka, to get information
    about the available microservice instances.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka实现了客户端服务发现，这意味着客户端运行与发现服务器Netflix Eureka通信的软件，以获取有关可用微服务实例的信息。
- en: 'This is illustrated in the following diagram:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下图中得到说明：
- en: '![Diagram  Description automatically generated](img/B19825_09_04.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_09_04.png)'
- en: 'Figure 9.4: Discovery server diagram'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：发现服务器图
- en: 'The process is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 流程如下：
- en: Whenever a microservice instance starts up – for example, the **Review** service
    – it registers itself to one of the Eureka servers.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当微服务实例启动时——例如，**Review**服务——它会将自己注册到Eureka服务器之一。
- en: On a regular basis, each microservice instance sends a heartbeat message to
    the Eureka server, telling it that the microservice instance is okay and is ready
    to receive requests.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定期地，每个微服务实例都会向Eureka服务器发送心跳消息，告诉它微服务实例一切正常，并准备好接收请求。
- en: Clients – for example, the **Product Composite** service – use a client library
    that regularly asks the Eureka service for information about available services.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端——例如，**产品组合**服务——使用一个客户端库，该库定期向Eureka服务请求有关可用服务的信息。
- en: When the client needs to send a request to another microservice, it already
    has a list of available instances in its client library and can pick one of them
    without asking the discovery server. Typically, available instances are chosen
    in a round-robin fashion; that is, they are called one after another before the
    first one is called once more.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端需要向另一个微服务发送请求时，它已经在客户端库中有一个可用实例的列表，并且可以在不询问发现服务器的情况下选择其中一个。通常，可用实例是按轮询方式选择的；也就是说，在第一个实例再次被调用之前，它们一个接一个地被调用。
- en: In *Chapter 17*, *Implementing Kubernetes Features to Simplify the System Landscape*,
    we will look at an alternative approach to providing a discovery service using
    the **server-side service** concept in Kubernetes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17章中，我们将探讨使用Kubernetes中的**服务器端服务**概念提供发现服务的替代方法。
- en: Spring Cloud comes with an abstraction of how to communicate with a discovery
    service such as Netflix Eureka and provides an interface called `DiscoveryClient`.
    This can be used to interact with a discovery service to get information regarding
    available services and instances. Implementations of the `DiscoveryClient` interface
    are also capable of automatically registering a Spring Boot application with the
    discovery server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud提供了一种与发现服务（如Netflix Eureka）通信的抽象，并提供了一个名为`DiscoveryClient`的接口。这可以用来与发现服务交互，获取有关可用服务和实例的信息。`DiscoveryClient`接口的实现也能够自动将Spring
    Boot应用程序注册到发现服务器。
- en: Spring Boot can find implementations of the `DiscoveryClient` interface automatically
    during startup, so we only need to bring in a dependency on the corresponding
    implementation to connect to a discovery server. In the case of Netflix Eureka,
    the dependency that’s used by our microservices is `spring-cloud-starter-netflix-eureka-client`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 在启动期间可以自动找到 `DiscoveryClient` 接口的实现，因此我们只需要引入相应实现的依赖来连接到发现服务器。在
    Netflix Eureka 的情况下，我们微服务使用的依赖项是 `spring-cloud-starter-netflix-eureka-client`。
- en: Spring Cloud also has `DiscoveryClient` implementations that support the use
    of either Apache ZooKeeper or HashiCorp Consul as a discovery server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 还提供了 `DiscoveryClient` 实现的支持，这些实现支持使用 Apache ZooKeeper 或 HashiCorp
    Consul 作为发现服务器。
- en: Spring Cloud also comes with an abstraction – the `LoadBalancerClient` interface
    – for clients that want to make requests through a load balancer to registered
    instances in the discovery service. The standard reactive HTTP client, `WebClient`,
    can be configured to use the `LoadBalancerClient` implementation. By adding the
    `@LoadBalanced` annotation to a `@Bean` declaration that returns a `WebClient.Builder`
    object, a `LoadBalancerClient` implementation will be injected into the `Builder`
    instance as an `ExchangeFilterFunction`. Later in this chapter, in the *Connecting
    microservices to a Netflix Eureka server* section, we will look at some source
    code examples of how this can be used.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 还为想要通过负载均衡器向发现服务中注册的实例发送请求的客户端提供了一个抽象——`LoadBalancerClient` 接口。标准的反应式
    HTTP 客户端 `WebClient` 可以配置为使用 `LoadBalancerClient` 实现。通过将 `@LoadBalanced` 注解添加到返回
    `WebClient.Builder` 对象的 `@Bean` 声明中，将 `LoadBalancerClient` 实现注入到 `Builder` 实例作为
    `ExchangeFilterFunction`。在本章的 *将微服务连接到 Netflix Eureka 服务器* 部分，我们将会看到一些如何使用它的源代码示例。
- en: In summary, Spring Cloud makes it very easy to use Netflix Eureka as a discovery
    service. With this introduction to service discovery and its challenges, as well
    as how Netflix Eureka can be used together with Spring Cloud, we are ready to
    learn how to set up a Netflix Eureka server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Spring Cloud 使得使用 Netflix Eureka 作为发现服务变得非常简单。通过本节对服务发现及其挑战的介绍，以及如何将 Netflix
    Eureka 与 Spring Cloud 结合使用，我们准备好学习如何设置 Netflix Eureka 服务器。
- en: Setting up a Netflix Eureka server
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Netflix Eureka 服务器
- en: 'In this section, we will learn how to set up a Netflix Eureka server for service
    discovery. Setting up a Netflix Eureka server using Spring Cloud is really easy
    – just follow these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何设置 Netflix Eureka 服务器以进行服务发现。使用 Spring Cloud 设置 Netflix Eureka 服务器非常简单——只需遵循以下步骤：
- en: Create a Spring Boot project using Spring Initializr, as described in *Chapter
    3*, *Creating a Set of Cooperating Microservices*, in the *Using Spring Initializr
    to generate skeleton code* section.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Spring Initializr 创建一个 Spring Boot 项目，如 *第 3 章* 中所述，*创建一组协作微服务*，在 *使用 Spring
    Initializr 生成骨架代码* 部分中描述。
- en: Add a dependency to `spring-cloud-starter-netflix-eureka-server`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 `spring-cloud-starter-netflix-eureka-server` 的依赖。
- en: Add the `@EnableEurekaServer` annotation to the application class.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `@EnableEurekaServer` 注解添加到应用程序类中。
- en: Add a Dockerfile, similar to the Dockerfiles that are used for our microservices,
    with the exception that we export the default Eureka port, `8761`, instead of
    the default port for our microservices, `8080`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 Dockerfile，类似于我们用于微服务的 Dockerfile，只是我们导出默认的 Eureka 端口 `8761`，而不是微服务的默认端口
    `8080`。
- en: 'Add the Eureka server to our three Docker Compose files, that is, `docker-compose.yml`,
    `docker-compose-partitions.yml`, and `docker-compose-kafka.yml`, like this:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Eureka 服务器添加到我们的三个 Docker Compose 文件中，即 `docker-compose.yml`、`docker-compose-partitions.yml`
    和 `docker-compose-kafka.yml`，如下所示：
- en: '[PRE6]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, add some configuration. Please see the *Setting up the configuration
    for development use* section in this chapter, where we will go through the configuration
    for both the Eureka server and our microservices.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一些配置。请参阅本章中 *设置开发使用的配置* 部分，其中我们将介绍 Eureka 服务器和我们的微服务的配置。
- en: That’s all it takes!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！
- en: The application class contains a workaround for a bug described in [https://github.com/spring-cloud/spring-cloud-netflix/issues/4145](https://github.com/spring-cloud/spring-cloud-netflix/issues/4145).
    It affects the Spring Cloud version, 2022.0.1, used in this book. See the class
    `CustomErrorController` in `EurekaServerApplication.java`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序类包含一个针对在 [https://github.com/spring-cloud/spring-cloud-netflix/issues/4145](https://github.com/spring-cloud/spring-cloud-netflix/issues/4145)
    中描述的错误的解决方案。它影响了本书中使用的 Spring Cloud 版本，2022.0.1。请参阅 `EurekaServerApplication.java`
    中的 `CustomErrorController` 类。
- en: You can find the source code for the Eureka server in the `$BOOK_HOME/Chapter09/spring-cloud/eureka-server`
    folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`$BOOK_HOME/Chapter09/spring-cloud/eureka-server`文件夹中找到Eureka服务器的源代码。
- en: Now that we have set up a Netflix Eureka server for service discovery, we are
    ready to learn how to connect microservices to it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为服务发现设置了一个Netflix Eureka服务器，我们准备好学习如何将微服务连接到它了。
- en: Connecting microservices to a Netflix Eureka server
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务连接到Netflix Eureka服务器
- en: In this section, we will learn how to connect microservice instances to a Netflix
    Eureka server. We will learn both how microservice instances register themselves
    to the Eureka server during their startup and how clients can use the Eureka server
    to find the microservice instances they want to call.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将微服务实例连接到Netflix Eureka服务器。我们将学习微服务实例在启动期间如何将自己注册到Eureka服务器，以及客户端如何使用Eureka服务器来查找他们想要调用的微服务实例。
- en: 'To be able to register a microservice instance in the Eureka server, we need
    to do the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在Eureka服务器中注册微服务实例，我们需要执行以下操作：
- en: 'Add a dependency to `spring-cloud-starter-netflix-eureka-client` in the build
    file, `build.gradle`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建文件`build.gradle`中添加对`spring-cloud-starter-netflix-eureka-client`的依赖：
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When running tests on a single microservice, we don’t want to depend on having
    the Eureka server up and running. Therefore, we will disable the use of Netflix
    Eureka in all Spring Boot tests, that is, JUnit tests annotated with `@SpringBootTest`.
    This can be done by adding the `eureka.client.enabled` property and setting it
    to `false` in the annotation, like so:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对单个微服务进行测试时，我们不希望依赖于Eureka服务器正在运行。因此，我们将禁用所有Spring Boot测试中Netflix Eureka的使用，即带有`@SpringBootTest`注解的JUnit测试。这可以通过在注解中添加`eureka.client.enabled`属性并将其设置为`false`来实现，如下所示：
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, add some configuration. Please go to the *Setting up the configuration
    for development use* section, where we will go through the configuration for both
    the Eureka server and our microservices.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一些配置。请转到*设置开发使用的配置*部分，我们将介绍Eureka服务器和我们的微服务的配置。
- en: 'There is one property in the configuration that is extra important: `spring.application.name`.
    It is used to give each microservice a virtual hostname, a name used by the Eureka
    service to identify each microservice. Eureka clients will use this virtual hostname
    in the URLs that are used to make HTTP calls to the microservice, as we will see
    as we proceed.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中有一个属性非常重要：`spring.application.name`。它用于为每个微服务提供一个虚拟主机名，这是Eureka服务用来识别每个微服务的名称。Eureka客户端将使用这个虚拟主机名在用于向微服务发起HTTP调用的URL中，正如我们接下来将要看到的。
- en: 'To be able to look up available microservice instances through the Eureka server
    in the `product-composite` microservice, we also need to do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在`product-composite`微服务中通过Eureka服务器查找可用的微服务实例，我们还需要执行以下操作：
- en: 'Add a Spring bean in the main application class, `ProductCompositeServiceApplication`,
    which creates a load balancer-aware `WebClient` builder:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主应用程序类`ProductCompositeServiceApplication`中添加一个Spring bean，该bean创建一个负载均衡器感知的`WebClient`
    builder：
- en: '[PRE9]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more information on how to use a `WebClient` instance as a load balancer
    client, see [https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#webclinet-loadbalancer-client](https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#webclinet-loadbalancer-client).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何将`WebClient`实例用作负载均衡器客户端的更多信息，请参阅[https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#webclinet-loadbalancer-client](https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#webclinet-loadbalancer-client)。
- en: 'The `WebClient`-builder bean can be used by the integration class, `ProductCompositeIntegration`,
    by injecting it into the constructor:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebClient`-builder bean可以通过集成类`ProductCompositeIntegration`使用，通过将其注入构造函数中：'
- en: '[PRE10]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The constructor uses the injected builder to create the `webClient`.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数使用注入的builder来创建`webClient`。
- en: Once a `WebClient` is built, it is immutable. This means that it can be reused
    by concurrent requests without risking them stepping on each other’s toes.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦构建了`WebClient`，它就是不可变的。这意味着它可以被并发请求重用，而不会相互干扰。
- en: 'We can now get rid of our hardcoded configuration of available microservices
    in `application.yml`. It looks like this:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以丢弃`application.yml`中硬编码的可用微服务配置。它看起来像这样：
- en: '[PRE11]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The corresponding code in the integration class, `ProductCompositeIntegration`,
    that handled the hardcoded configuration is simplified and replaced by a declaration
    of the base URLs to the APIs of the core microservices. This is shown in the following
    code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理硬编码配置的集成类`ProductCompositeIntegration`中的相应代码被简化，并替换为对核心微服务API的基础URL的声明。这将在以下代码中展示：
- en: '[PRE12]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The hostnames in the preceding URLs are not actual DNS names. Instead, they
    are the virtual hostnames that are used by the microservices when they register
    themselves to the Eureka server, in other words, the values of the `spring.application.name`
    property.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述URL中的主机名不是实际的DNS名称。相反，它们是微服务在将自己注册到Eureka服务器时使用的虚拟主机名，换句话说，是`spring.application.name`属性的值。
- en: Now that we’ve seen how to connect microservice instances to a Netflix Eureka
    server, we can move on and learn how to configure the Eureka server and the microservice
    instances that connect to it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何将微服务实例连接到Netflix Eureka服务器，我们可以继续学习如何配置Eureka服务器及其连接到的微服务实例。
- en: Setting up the configuration for development use
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发使用的配置
- en: 'Now, it’s time for the trickiest part of setting up Netflix Eureka as a discovery
    service: setting up a working configuration for both the Eureka server and its
    clients, our microservice instances.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是设置Netflix Eureka作为发现服务中最棘手的部分：为Eureka服务器及其客户端（我们的微服务实例）设置一个有效的配置。
- en: Netflix Eureka is a highly configurable discovery server that can be set up
    for a number of different use cases, and it provides robust, resilient, and fault-tolerant
    runtime characteristics. One downside of this flexibility and robustness is that
    it has an almost overwhelming number of configuration options.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka是一个高度可配置的发现服务器，可以根据多种不同的用例进行设置，并提供强大、健壮和容错运行时特性。这种灵活性和健壮性的一个缺点是它几乎有压倒性的配置选项数量。
- en: Fortunately, Netflix Eureka comes with good default values for most of the configurable
    parameters – at least when it comes to using them in a production environment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Netflix Eureka为大多数可配置参数提供了良好的默认值——至少在使用它们的生产环境时是这样的。
- en: When it comes to using Netflix Eureka during development, the default values
    cause long startup times. For example, it can take a long time for a client to
    make an initial successful call to a microservice instance that is registered
    in the Eureka server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到在开发中使用Netflix Eureka时，默认值会导致启动时间过长。例如，客户端向注册在Eureka服务器中的微服务实例发起初始成功的调用可能需要很长时间。
- en: Up to two minutes of waiting time can be experienced when using the default
    configuration values. This waiting time is added to the time it takes for the
    Eureka service and the microservices to start up. The reason for this waiting
    time is that the involved processes need to synchronize registration information
    with each other. The microservice instances need to register with the Eureka server,
    and the client needs to gather information from the Eureka server. This communication
    is mainly based on heartbeats, which happen every 30 seconds by default. A couple
    of caches are also involved, which slows down the propagation of updates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认配置值时，可能会遇到长达两分钟的等待时间。这个等待时间加在了Eureka服务和微服务启动所需的时间上。这种等待时间的原因是涉及到的进程需要相互同步注册信息。微服务实例需要向Eureka服务器注册，客户端需要从Eureka服务器收集信息。这种通信主要基于心跳，默认情况下每30秒发生一次。还有一些缓存也参与其中，这会减慢更新传播的速度。
- en: We will use a configuration that minimizes this waiting time, which is useful
    during development. In production environments, the default values should be used
    as a starting point!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种配置来最小化这种等待时间，这在开发期间非常有用。在生产环境中，应该将默认值作为起点！
- en: We will only use one Netflix Eureka server instance, which is okay in a development
    environment. In a production environment, you should always use two or more instances
    to ensure high availability for the Netflix Eureka server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用一个Netflix Eureka服务器实例，这在开发环境中是可以的。在生产环境中，你应该始终使用两个或更多实例以确保Netflix Eureka服务器的高可用性。
- en: Let’s start to learn what types of configuration parameters we need to know
    about.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习我们需要了解哪些类型的配置参数。
- en: Eureka configuration parameters
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eureka配置参数
- en: 'The configuration parameters for Eureka are divided into three groups:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka的配置参数分为三个组：
- en: Parameters for the Eureka server, prefixed with `eureka.server`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`eureka.server`为前缀的Eureka服务器参数。
- en: Parameters for Eureka clients, prefixed with `eureka.client`. This is for clients
    who want to communicate with a Eureka server.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`eureka.client`为前缀的Eureka客户端参数。这是供想要与Eureka服务器通信的客户端使用的。
- en: Parameters for Eureka instances, prefixed with `eureka.instance`. This is for
    the microservice instances that want to register themselves in the Eureka server.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`eureka.instance`为前缀的Eureka实例参数。这是供想要在Eureka服务器中注册自己的微服务实例使用的。
- en: 'Some of the available parameters are described in the Spring Cloud Netflix
    documentation: [https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/](https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可用的参数在Spring Cloud Netflix文档中有描述：[https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/](https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/)。
- en: 'For an extensive list of available parameters, I recommend reading the source
    code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可用的参数的详尽列表，我建议阅读源代码：
- en: For Eureka server parameters, look at the `org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean`
    class for default values and the `com.netflix.eureka.EurekaServerConfig` interface
    for the relevant documentation.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Eureka服务器参数，查看`org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean`类以获取默认值，以及查看`com.netflix.eureka.EurekaServerConfig`接口以获取相关文档。
- en: For Eureka client parameters, look at the `org.springframework.cloud.netflix.eureka.EurekaClientConfigBean`
    class for the default values and documentation.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Eureka客户端参数，查看`org.springframework.cloud.netflix.eureka.EurekaClientConfigBean`类以获取默认值和文档。
- en: For Eureka instance parameters, look at the `org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean`
    class for default values and documentation.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Eureka实例参数，查看`org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean`类以获取默认值和文档。
- en: Let’s start to learn about configuration parameters for the Eureka server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始了解Eureka服务器的配置参数。
- en: Configuring the Eureka server
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Eureka服务器
- en: 'To configure the Eureka server for use in a development environment, the following
    configuration can be used:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要在开发环境中配置Eureka服务器，可以使用以下配置：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first part of the configuration, for a Eureka `instance` and `client`, is
    a standard configuration for a standalone Eureka server. For details, see the
    Spring Cloud documentation, which we referred to previously. The last two parameters
    used for the Eureka server, `waitTimeInMsWhenSyncEmpty` and `response-cache-update-interval-ms`,
    are used to minimize the startup time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的第一部分，对于Eureka `instance`和`client`，是独立Eureka服务器的标准配置。有关详细信息，请参阅我们之前提到的Spring
    Cloud文档。用于Eureka服务器的最后两个参数`waitTimeInMsWhenSyncEmpty`和`response-cache-update-interval-ms`用于最小化启动时间。
- en: With the Eureka server configured, we are ready to see how clients to the Eureka
    server, that is, the microservice instances, can be configured.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了Eureka服务器后，我们就可以看到Eureka服务器的客户端，即微服务实例，如何进行配置。
- en: Configuring clients to the Eureka server
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Eureka服务器的客户端
- en: 'To be able to connect to the Eureka server, the microservices have the following
    configuration:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够连接到Eureka服务器，微服务有以下配置：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `eureka.client.serviceUrl.defaultZone` parameter is used to find the Eureka
    server, using the hostname `localhost` when running without Docker and the hostname
    `eureka` when running as containers in Docker. The other parameters are used to
    minimize the startup time and the time it takes to deregister a microservice instance
    that is stopped.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`eureka.client.serviceUrl.defaultZone`参数用于查找Eureka服务器，在没有Docker运行时使用主机名`localhost`，在Docker容器中运行时使用主机名`eureka`。其他参数用于最小化启动时间和停止的微服务实例注销所需的时间。'
- en: Now, we have everything in place that’s required to actually try out the discovery
    service using the Netflix Eureka server together with our microservices.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用Netflix Eureka服务器和我们的微服务来实际尝试使用发现服务了。
- en: Trying out the discovery service
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用发现服务
- en: 'With all of the details in place, we are ready to try out Netflix Eureka:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有细节都准备就绪后，我们就可以尝试使用Netflix Eureka了：
- en: 'First, build the Docker images with the following commands:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建Docker镜像：
- en: '[PRE15]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, start the system landscape and run the usual tests with the following
    command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令启动系统景观并运行常规测试：
- en: '[PRE16]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Expect an output similar to what we have seen in previous chapters:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出将与我们在前几章中看到的结果类似：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_09_05.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，自动生成文本描述](img/B19825_09_05.png)'
- en: 'Figure 9.5: Successful test output'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：成功的测试输出
- en: With the system landscape up and running, we can start by testing how to scale
    up the number of instances for one of the microservices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 系统景观启动并运行后，我们可以开始测试如何增加一个微服务的实例数量。
- en: Scaling up
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展
- en: 'Run the following commands to try out scaling up a service:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来尝试扩展服务：
- en: 'Launch two extra `review` microservice instances:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动两个额外的 `review` 微服务实例：
- en: '[PRE17]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the preceding command, we ask Docker Compose to run three instances of
    the `review` service. Since one instance is already running, two new instances
    will be started up.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们要求 Docker Compose 运行三个 `review` 服务实例。由于一个实例已经在运行，因此将启动两个新实例。
- en: Once the new instances are up and running, browse to `http://localhost:8761/`
    and expect something like the following:![Graphical user interface, website  Description
    automatically generated](img/B19825_09_06.png)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦新实例启动并运行，请浏览到 `http://localhost:8761/` 并预期如下：![图形用户界面，网站描述自动生成](img/B19825_09_06.png)
- en: 'Figure 9.6: Viewing instances registered with Eureka'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.6：查看已注册到 Eureka 的实例
- en: Verify that you can see three `review` instances in the Netflix Eureka web UI,
    as shown in the preceding screenshot.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证你能否在 Netflix Eureka 网页 UI 中看到三个 `review` 实例，如前面的截图所示。
- en: 'One way of knowing when the new instances are up and running is to run this
    command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 知道新实例何时启动并运行的一种方法就是运行以下命令：
- en: '[PRE18]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Expect output that looks as follows:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_09_07.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/B19825_09_07.png)'
- en: 'Figure 9.7: New review instances'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：新的 review 实例
- en: 'We can also use a REST API that the Eureka service exposes. To get a list of
    instance IDs, we can issue a `curl` command, like this:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用 Eureka 服务公开的 REST API。要获取实例 ID 列表，我们可以发出一个 `curl` 命令，如下所示：
- en: '[PRE19]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Expect a response that looks similar to the following:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期将收到类似以下响应：
- en: '![Text  Description automatically generated](img/B19825_09_08.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_09_08.png)'
- en: 'Figure 9.8: List of microservice instance IDs'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：微服务实例 ID 列表
- en: 'If you look into the test script, `test-em-all.bash`, you will find new tests
    that verify that we can reach Eureka’s REST API and that it reports four instances:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你查看测试脚本 `test-em-all.bash`，你会找到新的测试，以验证我们能否到达 Eureka 的 REST API，并且它报告了四个实例：
- en: '[PRE20]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have all of the instances up and running, let’s try out the client-side
    load balancer by making some requests and focusing on the address of the `review`
    service in the responses, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经启动并运行了所有实例，让我们通过发送一些请求并关注响应中 `review` 服务的地址来尝试客户端负载均衡器，如下所示：
- en: '[PRE21]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Expect responses similar to the following:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期将收到类似以下响应：
- en: '![Text  Description automatically generated](img/B19825_09_09.png)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_09_09.png)'
- en: 'Figure 9.9: Review service addresses'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.9：Review 服务地址
- en: Note that the address of the `review` service changes in each response; the
    load balancer uses round-robin logic to call the available `review` instances,
    one at a time!
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，每次响应中 `review` 服务的地址都会改变；负载均衡器使用轮询逻辑逐个调用可用的 `review` 实例！
- en: 'We can also take a look into the `review` instance’s log records with the following
    command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令查看 `review` 实例的日志记录：
- en: '[PRE22]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will see output that looks similar to the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下输出的内容：
- en: '![Text  Description automatically generated](img/B19825_09_10.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_09_10.png)'
- en: 'Figure 9.10: Review instance log records'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10：Review 实例日志记录
- en: In the preceding output, we can see how the three review microservice instances,
    `review_2`, `review_3`, and `review_1`, in turn have responded to the requests.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到三个 review 微服务实例，`review_2`、`review_3` 和 `review_1` 如何依次响应请求。
- en: We can also try to scale down the instances, which we will do next.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试缩小实例，我们将在下一步进行。
- en: Scaling down
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放
- en: 'Let’s also see what happens if we lose one instance of the `review` microservice.
    Run the following commands:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们丢失一个 `review` 微服务实例会发生什么。运行以下命令：
- en: 'We can simulate one instance stopping unexpectedly by running the following
    command:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来模拟一个实例意外停止：
- en: '[PRE23]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After the shutdown of the `review` instance, there is a short time period during
    which calls to the API might fail. This is caused by the time it takes for information
    regarding the lost instance to propagate to the client, the `product-composite`
    service. During this time frame, the client-side load balancer might choose the
    instance that no longer exists. To prevent this from occurring, resilience mechanisms
    such as timeouts and retries can be used. In *Chapter 13*, *Improving Resilience
    Using Resilience4j*, we will see how this can be applied. For now, let’s specify
    a timeout on our `curl` command, using the `-m 2` option to specify that we will
    wait no longer than two seconds for a response:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `review` 实例关闭后，会有一个短暂的时间段，在此期间调用 API 可能会失败。这是由于关于丢失实例的信息传播到客户端、`product-composite`
    服务所需的时间造成的。在此时间段内，客户端负载均衡器可能会选择不再存在的实例。为了防止这种情况发生，可以使用诸如超时和重试等弹性机制。在 *第 13 章*，*使用
    Resilience4j 提高弹性* 中，我们将看到如何应用这些机制。现在，让我们在我们的 `curl` 命令上指定一个超时，使用 `-m 2` 选项指定我们最多等待两秒钟的响应：
- en: '[PRE24]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If a timeout occurs, that is, the client-side load balancer tries to call an
    instance that no longer exists, the following response is expected from `curl`:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果发生超时，即客户端负载均衡器尝试调用一个不再存在的实例，那么从 `curl` 预期得到的响应如下：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_09_11.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B19825_09_11.png)'
- en: 'Figure 9.11: Response from curl if a timeout occurs'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11：发生超时时 curl 的响应
- en: 'Besides that, we should expect normal responses from the two remaining instances;
    that is, the `serviceAddresses.rev` field should contain the addresses of the
    two instances, as in the following:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还应期望从剩余的两个实例得到正常响应；也就是说，`serviceAddresses.rev` 字段应包含两个实例的地址，如下所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_09_12.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_09_12.png)'
- en: 'Figure 9.12: Normal responses from remaining instances'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12：剩余实例的正常响应
- en: In the preceding sample output, we can see that two different container names
    and IP addresses are reported. This means that the requests have been served by
    the two remaining microservice instances.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例输出中，我们可以看到报告了两个不同的容器名称和 IP 地址。这意味着请求是由剩余的两个微服务实例处理的。
- en: 'After trying out the scaling down of microservice instances, we can try out
    something that is a bit more disruptive: stopping the Eureka server and seeing
    what happens when the discovery server is temporarily unavailable.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试了微服务实例的缩放之后，我们可以尝试一些更具破坏性的操作：停止 Eureka 服务器并查看当发现服务器暂时不可用时会发生什么。
- en: Disruptive tests with the Eureka server
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Eureka 服务器进行破坏性测试
- en: Let’s bring some disorder to our Eureka server and see how the system landscape
    manages it!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Eureka 服务器上制造一些混乱，看看系统景观是如何处理它的！
- en: To start with, what happens if we crash the Eureka server?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们崩溃 Eureka 服务器会发生什么？
- en: As long as clients have read the information regarding available microservice
    instances from the Eureka server before it is stopped, the clients will be fine
    since they cache the information locally. However, new instances will not be made
    available to clients, and they will not be notified if any running instances are
    terminated. So, calls to instances that are no longer running will cause failures.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 只要客户端在停止之前已从 Eureka 服务器读取有关可用微服务实例的信息，客户端就会没事，因为它们已经将信息本地缓存。然而，新实例不会提供给客户端，并且如果任何运行中的实例被终止，它们也不会得到通知。因此，调用不再运行的实例将导致失败。
- en: Let’s try this out!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个！
- en: Stopping the Eureka server
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 停止 Eureka 服务器
- en: 'To simulate a Eureka server crash, follow these steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟 Eureka 服务器崩溃，请按照以下步骤操作：
- en: 'First, stop the Eureka server and keep the two `review` instances up and running:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，停止 Eureka 服务器并保持两个 `review` 实例运行：
- en: '[PRE25]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Try a couple of calls to the API and extract the service address of the `review`
    service:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试几次调用 API 并提取 `review` 服务的服务地址：
- en: '[PRE26]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The response will – just like before we stopped the Eureka server – contain
    the addresses of the two `review` instances, like so:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应将——就像我们在停止 Eureka 服务器之前一样——包含两个 `review` 实例的地址，如下所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_09_13.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_09_13.png)'
- en: 'Figure 9.13: Response with two review instance addresses'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13：包含两个 review 实例地址的响应
- en: This shows that the client can make calls to existing instances, even though
    the Eureka server is no longer running.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明客户端即使 Eureka 服务器不再运行，也可以调用现有实例。
- en: Starting up an extra instance of the product service
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动产品服务的额外实例
- en: 'As a final test of the effects of a crashed Eureka server, let’s see what happens
    if we start up a new instance of the `product` microservice. Perform the following
    steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对崩溃的 Eureka 服务器影响的最终测试，让我们看看如果我们启动 `product` 微服务的新实例会发生什么。执行以下步骤：
- en: 'Let’s try starting a new instance of the `product` service:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试启动 `product` 服务的新的实例：
- en: '[PRE27]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Call the API a couple of times and extract the address of the `product` service
    with the following command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 API 几次，并使用以下命令提取 `product` 服务的地址：
- en: '[PRE28]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since no Eureka server is running, the client will not be notified of the new
    `product` instance, and so all calls will go to the first instance, as in the
    following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有 Eureka 服务器运行，客户端将不会通知新的 `product` 实例，因此所有调用都将转到第一个实例，如下例所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_09_14.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_09_14.png)'
- en: 'Figure 9.14: Address of the first product instance only'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14：仅第一个产品实例的地址
- en: We have seen some of the most important aspects of not having a Netflix Eureka
    server up and running. Let’s conclude the section on disruptive tests by starting
    up the Netflix Eureka server again and seeing how the system landscape handles
    self-healing, that is, resilience.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了没有 Netflix Eureka 服务器运行的一些最重要的方面。让我们通过再次启动 Netflix Eureka 服务器来总结破坏性测试部分，并看看系统景观如何处理自我修复，即弹性。
- en: Starting up the Eureka server again
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次启动 Eureka 服务器
- en: 'In this section, we will wrap up the disruptive tests by starting up the Eureka
    server again. We will also verify that the system landscape self-heals, which
    means the new instance of the `product` microservice gets registered with the
    Netflix Eureka server and the client gets updated by the Eureka server. Perform
    the following steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过再次启动 Eureka 服务器来总结破坏性测试。我们还将验证系统景观是否能够自我修复，这意味着 `product` 微服务的新实例将注册到
    Netflix Eureka 服务器，并且客户端将通过 Eureka 服务器进行更新。执行以下步骤：
- en: 'Start the Eureka server with the following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动 Eureka 服务器：
- en: '[PRE29]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Make the following call a couple of times to extract the addresses of the product
    and the `review` service:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令调用几次以提取产品和 `review` 服务的地址：
- en: '[PRE30]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Verify that the following happens:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证以下情况发生：
- en: All calls go to the remaining `review` instance, demonstrating that the client
    has detected that the second `review` instance is gone.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有调用都转到剩余的 `review` 实例，这表明客户端已经检测到第二个 `review` 实例已消失。
- en: Calls to the `product` service are load-balanced over the two `product` instances,
    demonstrating the client has detected that there are two `product` instances available.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `product` 服务的调用在两个 `product` 实例之间进行负载均衡，这表明客户端已经检测到有两个 `product` 实例可用。
- en: 'The response should contain the same address for the `review` instance and
    two different addresses for the two `product` instances, as shown in the following
    two examples:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应应包含 `review` 实例的相同地址和两个不同的 `product` 实例地址，如下两个示例所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_09_15.png)'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_09_15.png)'
- en: 'Figure 9.15: Product and review addresses'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.15：产品和评论地址
- en: 'This is the second response:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是第二个响应：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_09_16.png)'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_09_16.png)'
- en: 'Figure 9.16: Product and review addresses'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.16：产品和评论地址
- en: The IP addresses `192.168.128.4` and `192.168.128.10` belong to the two `product`
    instances. `192.168.128.8` is the IP address of the single remaining `review`
    instance.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IP 地址 `192.168.128.4` 和 `192.168.128.10` 属于两个 `product` 实例。`192.168.128.8` 是唯一剩余的
    `review` 实例的 IP 地址。
- en: 'To summarize, the Eureka server provides a very robust and resilient implementation
    of a discovery service. If even higher availability is desired, multiple Eureka
    servers can be launched and configured to communicate with each other. Details
    on how to set up multiple Eureka servers can be found in the Spring Cloud documentation:
    [https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/#spring-cloud-eureka-server-peer-awareness](https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/#spring-cloud-eureka-server-peer-awareness).'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结来说，Eureka 服务器提供了一个非常健壮和弹性的服务发现实现。如果需要更高的可用性，可以启动多个 Eureka 服务器，并配置它们相互通信。有关如何设置多个
    Eureka 服务器的详细信息，请参阅 Spring Cloud 文档：[https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/#spring-cloud-eureka-server-peer-awareness](https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/#spring-cloud-eureka-server-peer-awareness)。
- en: 'Finally, shut down the system landscape with this command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令关闭系统环境：
- en: '[PRE31]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This completes the tests of the discovery server, Netflix Eureka, where we have
    learned how to scale up and scale down microservice instances and what happens
    if a Netflix Eureka server crashes and later on comes back online.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对服务发现服务器 Netflix Eureka 的测试，我们学习了如何扩展和缩减微服务实例，以及如果 Netflix Eureka 服务器崩溃后再次上线会发生什么。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use Netflix Eureka for service discovery.
    First, we looked into the shortcomings of a simple DNS-based service discovery
    solution and the challenges that a robust and resilient service discovery solution
    must be able to handle.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Netflix Eureka 进行服务发现。首先，我们探讨了简单基于 DNS 的服务发现解决方案的不足，以及一个健壮和弹性的服务发现解决方案必须能够处理挑战。
- en: Netflix Eureka is a very capable service discovery solution that provides robust,
    resilient, and fault-tolerant runtime characteristics. However, it can be challenging
    to configure correctly, especially for a smooth developer experience. With Spring
    Cloud, it becomes easy to set up a Netflix Eureka server and adapt Spring Boot-based
    microservices, both so that they can register themselves to Eureka during startup
    and, when acting as a client to other microservices, to keep track of available
    microservice instances.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka 是一个非常强大的服务发现解决方案，它提供了健壮、弹性和容错运行时特性。然而，正确配置可能具有挑战性，特别是为了提供流畅的开发者体验。使用
    Spring Cloud，设置 Netflix Eureka 服务器和适配基于 Spring Boot 的微服务变得容易，这样它们就可以在启动时将自己注册到
    Eureka，并且当作为其他微服务的客户端时，可以跟踪可用的微服务实例。
- en: With a discovery server in place, it’s time to see how we can handle external
    traffic using Spring Cloud Gateway as an edge server. Head over to the next chapter
    to find out how!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了服务发现服务器之后，是时候看看我们如何使用 Spring Cloud Gateway 作为边缘服务器来处理外部流量了。翻到下一章，看看如何操作！
- en: Questions
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is required to turn a Spring Boot application created with Spring Initializr
    into a fully fledged Netflix Eureka server?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将使用 Spring Initializr 创建的 Spring Boot 应用程序转换为完整的 Netflix Eureka 服务器，需要什么？
- en: What is required to make a Spring Boot-based microservice register itself automatically
    as a startup service with Netflix Eureka?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使基于 Spring Boot 的微服务自动注册为 Netflix Eureka 的启动服务，需要什么？
- en: What is required to make it possible for a Spring Boot-based microservice to
    call another microservice that is registered in a Netflix Eureka server?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使基于 Spring Boot 的微服务能够调用在 Netflix Eureka 服务器中注册的另一个微服务，需要什么？
- en: Let’s assume that you have a Netflix Eureka server up and running, along with
    one instance of microservice *A* and two instances of microservice *B*. All microservice
    instances register themselves with the Netflix Eureka server. Microservice *A*
    makes HTTP requests to microservice *B* based on the information it gets from
    the Eureka server. What will happen if, in turn, the following happens?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你已经有一个 Netflix Eureka 服务器正在运行，以及一个微服务 *A* 的实例和两个微服务 *B* 的实例。所有微服务实例都向 Netflix
    Eureka 服务器注册自己。微服务 *A* 根据从 Eureka 服务器获得的信息向微服务 *B* 发送 HTTP 请求。如果以下情况发生，会发生什么？
- en: The Netflix Eureka server crashes
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Netflix Eureka 服务器崩溃
- en: One of the instances of microservice *B* crashes
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务 *B* 的一个实例崩溃
- en: A new instance of microservice *A* starts up
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的微服务 *A* 实例启动
- en: A new instance of microservice *B* starts up
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的微服务 *B* 实例启动
- en: The Netflix Eureka server starts up again
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Netflix Eureka 服务器再次启动
