["```java\n    $ scala\n    ```", "```java\n    scala> val listOfStrings = \"str1\" :: (\"str2\" :: (\"str3\" :: Nil))\n    listOfStrings: List[String] = List(str1, str2, str3)\n    ```", "```java\n    scala> val listOfStrings = \"str1\" :: \"str2\" :: \"str3\" :: Nil\n    listOfStrings: List[String] = List(str1, str2, str3)\n    ```", "```java\n    scala> val listOfStrings = List(\"str1\", \"str2\", \"str3\")\n    listOfStrings: List[String] = List(str1, str2, str3)\n    ```", "```java\ndef evenInts(l: List[Int]): List[Int]\n\n```", "```java\ndef evenInts(l: List[Int]): List[Int] = {\n  if (l.isEmpty) l\n  else if (l.head % 2 == 0) l.head :: evenInts(l.tail)\n  else evenInts(l.tail)\n}\n```", "```java\nval l = List(1, 2, 3, 4, 5)\nList(a, b, c, d, e) = l\nval h :: t = l\n```", "```java\n    def evenInts(l: List[Int]): List[Int] = l match {\n      case h :: t if h % 2 == 0 => h :: evenInts(t)\n      case _ :: t => evenInts(t)\n      case Nil => Nil\n    }\n    ```", "```java\nscala> val a = List(1, 2, 3)\na: List[Int] = List(1, 2, 3)\n\nscala> val b = List(4, 5, 6)\nb: List[Int] = List(4, 5, 6)\nscala> val c = a ::: b\nc: List[Int] = List(1, 2, 3, 4, 5, 6)\n\nscala> val d = b :+ 7\nd: List[Int] = List(4, 5, 6, 7)\n```", "```java\nscala> val a = List(1, 2, 3, 4, 5)\na: List[Int] = List(1, 2, 3, 4, 5)\n\nscala> val b = a.take(2)\nb: List[Int] = List(1, 2)\n\nscala> val c = a.drop(2)\nc: List[Int] = List(3, 4, 5)\n```", "```java\nscala> val a = List(1, 2, 3, 4, 5)\na: List[Int] = List(1, 2, 3, 4, 5)\n\nscala> a.apply(2)\nres0: Int = 3\n```", "```java\nscala> a(2)\nres1: Int = 3\n```", "```java\nscala> val a = List(1, 2, 3, 4, 5)\na: List[Int] = List(1, 2, 3, 4, 5)\n\nscala> a.toString\nres0: String = List(1, 2, 3, 4, 5)\n```", "```java\nscala> a.mkString(\"[\", \", \", \"]\")\nres1: String = [1, 2, 3, 4, 5]\nscala> a.mkString(\", \")\nres2: String = 1, 2, 3, 4, 5\n\nscala> a.mkString\nres3: String = 12345\n```", "```java\ndef foreach[U](f: Elem => U)\n```", "```java\nscala> def f(i: Int) = i * 2\nf: (i: Int)Int\n\nscala> val l = List(1, 2, 3, 4).map(f)\nl: List[Int] = List(2, 4, 6, 8)\n\nscala> val a = Array(1, 2, 3, 4).map(f)\na: Array[Int] = Array(2, 4, 6, 8)\n```", "```java\nscala> def f(v: Int): List[Int] = if (v == 0) Nil else 1 :: f(v - 1)\nf: (v: Int)List[Int]\n\nscala> val l = List(1, 2, 3, 4).map(f)\nl: List[List[Int]] = List(List(1), List(1, 1), List(1, 1, 1), List(1, 1, 1, 1))\n\nscala> val ll = List(1, 2, 3, 4).flatMap(f)\nll: List[Int] = List(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)\n```", "```java\ndef add(a: Int, b: Int) = a + b\ndef sum(l: List[Int]) = l.foldLeft(0)(add)\nval res = sum(List(1, 2, 3, 4))\n// Returns 10\n```", "```java\ndef iterator: Iterator[A]\n```", "```java\nlazy val fibIterator: Iterator[BigInt]\nlazy val fibStream: Stream[BigInt]\n```", "```java\nlazy val fibStream: Stream[BigInt] = BigInt(0) #:: BigInt(1) #:: \nfibStream.zip(fibStream.tail).map { n => n._1 + n._2 }\nlazy val fibIterator = new Iterator[BigInt] {\n  var v1 = 0\n  var v2 = 1\n  val hasNext = true\n  def next = {\n    val res = v1\n    v1 = v2\n    v2 = res + v1\n    res\n  }\n}\n```", "```java\nscala> val tup = (1, \"str\", 2.0)\ntup: (Int, String, Double) = (1,str,2.0)\n\nscala> val (a, b, c) = tup\na: Int = 1\nb: String = str\nc: Double = 2.0\n\nscala> tup._1\nres0: Int = 1\n\nscala> tup._2\nres1: String = str\n\nscala> tup._3\nres2: Double = 2.0\n\nscala> val pair = 1 -> \"str\"\npair: (Int, String) = (1,str)\n```", "```java\nscala> import scala.collection.mutable\nimport scala.collection.mutable\n\nscala> val m = Map(1 -> 2, 3 -> 4)\nm: scala.collection.immutable.Map[Int,Int] = Map(1 -> 2, 3 -> 4)\n\nscala> val mm = mutable.Map(1 -> 2, 3 -> 4)\nmm: scala.collection.mutable.Map[Int,Int] = Map(1 -> 2, 3 -> 4)\n\nscala> mm.update(3, 5)\n\nscala> mm\nres1: scala.collection.mutable.Map[Int,Int] = Map(1 -> 2, 3 -> 5)\n\nscala> m.update(3, 5)\n<console>:14: error: value update is not a member of scala.collection.immutable.Map[Int,Int]\n       m.update(3, 5)\n         ^\n\nscala> m.updated(3, 5)\nres3: scala.collection.immutable.Map[Int,Int] = Map(1 -> 2, 3 -> 5)\n\nscala> m\nres4: scala.collection.immutable.Map[Int,Int] = Map(1 -> 2, 3 -> 4)\n```", "```java\n    def path(from: Int, to: Int, graph: Map[Int, List[Int]]): List[Int] = {\n      def paths(from: Int): Stream[List[Int]] = ???\n      paths(from).dropWhile(_.head != to).head.reverse\n    }\n    ```", "```java\n    type HanoiState = (List[Int], List[Int], List[Int])\n    def nextHanoi(current: HanoiState): List[HanoiState]\n    ```", "```java\n    def genericPath[A](from: A, to: A, nextStates: A => List[A]): List[A] = {\n     def paths(current: A): Stream[List[A]] = ???\n      paths(from).dropWhile(_.head != to).head.reverse\n    }\n    ```", "```java\n    val start = (List(1, 2, 3), Nil, Nil)\n    val end = (Nil, Nil, List(1, 2, 3))\n    genericPath(start, end, nextHanoi)\n    ```", "```java\n    // Does not avoid already visited nodes\n    def path(from: Int, to: Int, graph: Map[Int, List[Int]]): List[Int] = {\n      def paths(current: Int): Stream[List[Int]] = {\n        def bfs(current: Stream[List[Int]]): Stream[List[Int]] = {\n          if (current.isEmpty) current\n          else current.head #:: bfs(current.tail #::: graph(current.head.head).map(_ :: current.head).toStream)\n        }\n\n        bfs(Stream(List(current)))\n      }\n\n      paths(from).dropWhile(_.head != to).head.reverse\n    }\n\n    type HanoiState = (List[Int], List[Int], List[Int])\n\n    def nextHanoi(current: HanoiState): List[HanoiState] = {\n      def setPile(state: HanoiState, i: Int, newPile: List[Int]): HanoiState = i match {\n    …\n    …\n     genericPath(start, end, nextHanoi).size\n    ```"]