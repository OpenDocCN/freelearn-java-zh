<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Java EE and Modern Architectural Methodologies</h1>
                </header>
            
            <article>
                
<p class="western">In this chapter, we will give users an overview of the current state of <strong>Java</strong> <span><strong>Enterprise Edition</strong></span> (<span><strong>EE</strong></span>) and its relevance in modern architectural methodologies, that is, <strong>microservices</strong> and <strong>cloud computing</strong>. We will introduce the tools that will be used throughout the book and the application that we will be developing.</p>
<p><span>Let's start by recalling a few basic facts about Java EE.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java EE</h1>
                </header>
            
            <article>
                
<p>Before sketching the Java EE architecture, let's take a quick look at the process through which the standard is created.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java Community Process</h1>
                </header>
            
            <article>
                
<p>Java EE is a standard designed for building enterprise applications with the Java programming language. <span>It contains a number of specifications, which define functionalities required by implementations of the standard.</span></p>
<p>Specifications that constitute Java EE are developed in an open, community-based process. Both organizations and individual users can join it and take part in the development.</p>
<p>As a standard, Java EE may possess multiple implementations. A vendor who is willing to create a product that is Java EE-certified has to pass a technology compliance test, which guarantees that the product is in alignment with the standard.</p>
<p>The standard provides the contract between enterprise application developers and the vendors of standard implementations. An application developer can be sure that their application will be supported and portable, as there are a number of standard implementations; they are not dependent on one vendor. Application developers are free to migrate their applications between different standard implementations.</p>
<p>It is also important to note that the standard does not determine the details of server implementation. As a result, vendors have to compete to provide the most efficient, robust, and easy-to-use implementation.</p>
<p>To sum up, the Java EE standard provides enterprise application developers with an ability to write supported and portable applications. Furthermore, the community-based specification development process and competition between vendors help the standard to evolve and allows users to choose the best implementation for their needs.</p>
<p>On the flip side, the fact that Java EE is a standard implementation result in a slower evolution and decision-making process than alternative frameworks. In a world in which technology is being developed rapidly, this becomes a bigger problem. As a result, recently, an effort has been made to refactor the way in which standards and specifications are created. Java EE is currently transforming into EE4J, a standard developed under Eclipse Foundation's governance. We will return to this topic in the final <a href="9920ab21-5983-4d44-b8e5-0d08bb4e0717.xhtml">Chapter 12</a>: <em>Future Directions</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The basic architecture of Java EE applications</h1>
                </header>
            
            <article>
                
<p>Java EE applications are written in the Java language and run on <strong>Java virtual machine</strong> (<strong>JVM</strong>). On top of the standard Java SE functionality, the Java EE implementation provider implements a number of services, which can be used by those applications. Examples of such services may be security, transactions, or dependency injection.</p>
<p>Applications don't interact with enterprise services directly. Instead, the specifications define the <strong>component</strong> and <strong>containers</strong> concepts. Components are software units written in the Java language and configured and built in a similar way to standard Java classes. The difference is that metatada provided with the component allows it to be run using a runtime provided by the Java EE implementation. Such a runtime, which may differ for the different types of component, is called a container. The container is responsible for providing access to all enterprise services required by the component.</p>
<p>As an example, let's take a look at the following component:</p>
<pre><span>package </span>org.tadamski.examples.javaee<span>;<br/></span><span><br/></span><span>import </span>org.tadamski.examples.java.ee.model.Foo<span>;<br/></span><span><br/></span><span>import </span>javax.ejb.<span>Stateless</span><span>;<br/></span><span>import </span>javax.enterprise.event.Event<span>;<br/></span><span>import </span>javax.inject.<span>Inject</span><span>;<br/></span><span>import </span>javax.persistence.EntityManager<span>;</span><span><br/></span><span><br/>//1<br/></span><span>@Stateless<br/></span><span>public class </span>FooDaoBean implements FooDao {<br/><span><br/>    //2<br/></span><span>    </span><span>@Inject<br/></span><span>    </span><span>private </span>EntityManager <span>em</span><span>;<br/></span><span><br/></span><span><br/></span><span>    public void save</span>(Foo foo) <span>throws </span>Exception {<br/>        //3<span><br/></span><span>        </span><span>em</span>.persist(foo)<span>;</span><span><br/></span><span>    </span>}<br/>}</pre>
<p>The preceding script presents an <kbd>ejb</kbd> component (1), that is, <kbd>FooDaoBean</kbd>, which is responsible for saving objects of the <kbd>Foo</kbd> <span>type</span> into the database.</p>
<p>The <kbd>ejb</kbd> container in which this component will run will be responsible for pooling instances of this component and managing the lifecycle for all of them. Furthermore, this concrete component takes advantage of the number of enterprise services: dependency injection (2), ORM persistence (3), and transactions (the default for this kind of component).</p>
<p>In general, the goal of the Java EE runtime is to take care of all technical aspects of enterprise applications so that the application developer can concentrate on writing business code. The preceding example demonstrates how it is realized in Java EE: the application developer writes their code using POJOs with minimal configuration (provided mostly by annotations). The code written by an application developer implements business functionalities declaratively, informing middleware about its technical requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The scope of the Java EE standard</h1>
                </header>
            
            <article>
                
<p>Traditionally, business applications written in the Java EE technology were based on a three-tier architectures, web, business, and enterprise information system tier:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3e5671a2-6106-4f18-8d30-56a4d9ff3c12.png" style=""/></div>
<p>Application server implements web and business tiers. It can be accessed by various types of clients</p>
<p>Web components, such as <strong>Servlets</strong>, JSPs, or JAX-RS, allow for the implementation of the web layer. They are able to respond to the HTTP requests from different kinds of clients. For example, JSF may be used to create web user interfaces in a convenient way, whereas the JAX-RS API allows for the implementation of RESTful services.</p>
<p>The business layer is implemented by EJBs, pooled POJO-based components that allow for the easy implementation of transactional operations and that can provide a wide array of capabilities such as security, database, external system integration, remote access, or dependency injection.</p>
<p>Although the bird's-eye view architecture is quite straightforward, it is very elastic and allows for the implementation of a wide array of enterprise applications. Moreover, the standard has evolved throughout the years, providing tools for a wide array enterprise usage.</p>
<div class="CDPAlignCenter CDPAlign"/>
<p>If you take a look at Java EE specification (Further Reading, link 1) you will be able to see all the specifications that are part of the standard. The shared amount of them may be intimidating at first slight. It should be noted that, in most cases, you will have to deal with only a subset of those. On the other hand, when your applications require any kind of enterprise functionality, it is highly probable that the needed tool is already there for you—integrated with the whole platform and easy to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation of Java EE standard</h1>
                </header>
            
            <article>
                
<p>Java EE standard implementations are runtimes that allow us to run the components and provide them with the services specified in the Java EE standard. Such runtimes are called <strong>application servers</strong>.</p>
<p>Application developers create components based on the specification. Those components are assembled into archives, which can be deployed on application servers.</p>
<p>Application servers allow for the deployment of a number of applications. Furthermore, as hinted at the beginning of this chapter, an application can change the server implementation and deploy archives using the application server from the other vendor:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/aae33ada-0215-43cb-9b91-de56f42051c3.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Current development trends</h1>
                </header>
            
            <article>
                
<p>The way applications are developed evolves over time. Let's sketch concepts that have had a big impact on software development in recent years: cloud computing and microservices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloud computing</h1>
                </header>
            
            <article>
                
<p>Cloud computing is an infrastructure that makes it possible to automatically provision computing resources on demand. The types of resource provided depend on the contract between the cloud provider and the customer—the cloud provider can provide software services, such as email or disk storage, platforms for software development, access to virtual machines, or infrastructure for running software applications.</p>
<p>The resources are provided dynamically and rapidly using the internet, and, as a result, the customer is able to use (and pay) for resources that they currently use. The cloud provider, on the other hand, can take advantage of economies of scale: specialization and optimal resource usage will result in quality improvements and cost optimization.</p>
<p>So, how does interaction with cloud computing infrastructures look from the developer's point of view? During the development, the cloud provider provides a platform that contains a number of tools: it enables developers to run multiple application frameworks, standalone services, and databases among others. It provides functionalities and tools needed by those applications: scaling, networking, security, and communication. Furthermore, as hinted earlier, a user pays only for the resources used; cloud infrastructure will adjust the resources provided based on the load used by your application.</p>
<p>The preceding description sounds promising, but it immediately raises a number of questions, such as how are the resources provisioned and scaled, what kinds of tools can I use, and what are the APIs for the tools provided.</p>
<p>One of the goals of this book <span>is to provide you with all this information throughout</span>. For the purpose of this introductory chapter, it is enough to acknowledge the most important information: cloud computing infrastructures will enable us to develop and deploy <span>with a wide array of tools using computing resources provided on demand.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservices</h1>
                </header>
            
            <article>
                
<p>Microservices architecture is a software development methodology that advocates creating an application from loosely coupled services that cooperate together.</p>
<p>Such an architecture was researched and advertised for a long period of time: Some time ago, a lot of attention was given to <strong>Service-Oriented Architecture</strong> (<strong>SOA</strong>). Even earlier, <strong>CORBA</strong>, the standard for distributed computing, was designed. Furthermore, building your applications with loosely coupled, highly cohesive services is a good software practice, and it can (and should) also be applied in a traditional monolithic application. Why has the new concept been created then, and what distinguishes it?</p>
<p>In recent years, a number of companies building large distributed systems have found it harder to build and maintain their systems using the traditional monolithic software architectures and decided to refactor their systems to loosely coupled modular distributed systems. Looking at the experience of those companies that succeeded in doing so, we were able to gather common architectural patterns in the systems that they built. This gave birth to the microservice architecture concept. Put in another way, microservices can be thought of as a software architecture that is another iteration of distributed computing systems, whose characteristics were derived from practical experience. As a result, instead of providing a definition of microservice architectures to which all aspiring implementors have to adhere, it is easier to provide a common set of characteristics that microservice systems share (Further Reading, link 2). Let's do it now.</p>
<p>Microservices are built as standalone services that are independently deployable. From the technical point of view, it means that they run in different processes and communicate through the network using their APIs. Each of the services can be started, stopped, and updated independently. Each service is responsible for its own data and can modify the data of other services using <span>only</span> their API.</p>
<p>The system is decomposed into microservices around business functionalities. Each microservices is built by one, small team that consists of all necessary technical specialists. For example, in a store application, there may be a review service. The review service team may consist of programmers, database engineers, testers, and domain experts. The team is responsible for every aspect of this service—from getting customer feedback to database administration.</p>
<p>As you can see, instead of advertising a set of <span>recommended</span> characteristics that the applications should adhere to, successful microservice practitioners have created a technological environment that enforces modularity and loose coupling.</p>
<p>So, if you successfully implement a microservice architecture, what benefits will you obtain?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages of implementing microservices</h1>
                </header>
            
            <article>
                
<p>The first thing that is straightforward but should be emphasized is that if you successfully create a system whose architectural characteristics-force modularity and loose coupling, you will obtain a highly modular system as ad hoc fixes and extensions won't compromise and effectively abandon the boundaries between services throughout the development process.</p>
<p>Because of the modular characteristics of developed applications, components that constitute them may be developed more effectively: As there is a small, cross-sectional team working on each service, its members can concentrate on their own area of work relatively independently of other teams. As the practice suggests, as the team grows communication starts to inhibit work more and more. The small, focused team knows the domain well, and they also know each other well, can communicate immediately, and move the work forward.</p>
<p>Also, crucial is the fact that the service can be deployed independently of other services. A successful microservices architecture does not have the concept of big system release in which all teams gather their recent updates together and create a major release of the whole system. Instead, all teams are able to release and deploy their new functionalities independently of other services. There is no synchronization between the teams, and if there is a new version of a service that can be released, the service's team can just independently design to do it. Such a characteristic is a catalyst for Continous Integration. The team is able to build the pipeline so that each code triggers a test, review, and deploy process.</p>
<p>The characteristics described in the preceding paragraph—small, focused teams and independent and automated build and deployment processess<span>—</span>lead to very important characteristics of the successful microservices-based system: an ability to implement required changes very fast. This is crucial, as it allows for immediate responses to customer needs. This tightens the feedback loop between the customer and developer and allows the system to quickly evolve to meet the customer needs.</p>
<p>Last but not least, we should mention the direct technical consequences. Microservices can be scaled more effectively: When scaling a traditional monolith application, we need to replicate a number of application servers effectively, replicating all the functionalities implemented in the application. Scaling microservices can be more fine-grained; we are able to replicate only the services that need more instances across different servers.</p>
<p>Furthermore, microservices architecture tends to improve the availability: if a review service is down, the rest of the store can work regardless of it. Such a situation is obviously far from ideal but way better than a shutdown of the whole system.</p>
<p>In the preceding paragraph, we mentioned that the preceding characteristics apply to successful microservices implementation. As it turns out, creating such systems is not simple. Let's learn why.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Challenges of implementing microservices</h1>
                </header>
            
            <article>
                
<p>The challenges that encompass implementing microservice architecture can be summarized in one phrase: distributed system.</p>
<p>Is the functionality that you will implement will use a bunch of services throughout a network. You will have to deal with network delays and failures. What if the response is not immediate? Is the target service down or busy? How should we find out, and what we should do about it?</p>
<p>Should the data belong to one microservice? Easier said than done. We can make the database underlying the service consistent, but how do we propagate this information to other services that rely on this data?</p>
<p>Also, it is nice that each team can work independently, but what if we really need to implement cross-service functionality? That can become a pain: a cross-team endeavor that may introduce large architectural changes and substantially impact the whole architecture.</p>
<p>Let's assume that we managed to deal with the preceding problems and have a running system. What happens when an error occurs? We will have to analyze logs scattered around a number of services, also tracing network interactions between all of them.</p>
<p>So, how should you decide whether the microservice architecture is suitable for your application?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to adopt the microservice architecture</h1>
                </header>
            
            <article>
                
<p>Microservices should primarily be considered for systems in which managing the traditional monolithic application has become too complex to develop and maintain. If you are developing a small application, additional complexity, described in the preceding paragraph, may outweigh the modularity benefits and inhibit, instead of amplifying, your development process.</p>
<p>It has been suggested (<em>Further Reading</em>, link 3) that microservices architecture should be an evolution of the monolith application. Most systems should start as a monolith, and the transition to microservices should only be considered when the system grows to the extent that it becomes too hard to develop and maintain.</p>
<p>Last but not least, if the system is badly designed, the transition to microservices won't magically solve its problems. To put it more bluntly, distributing a messy system will result in an even greater mess. As we have already mentioned, microservices should be considered as a solution when the complexity of the system requires imposing modularity and not as a magical fix for badly written software.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservices and the cloud</h1>
                </header>
            
            <article>
                
<p>In order to implement a successful microservices architecture, we will need to automate as much of the infrastructure as possible. Eventually, we will be dealing with a system containing a large number of independent services running somewhere across the network. Maintaining such systems manually is virtually impossible.</p>
<p>We will like each service to be automatically built, tested, scaled, and monitored. The cloud infrastructure is a natural microservices environment, which allows you to achieve that. Each service can be run and scaled on resources provided on demand, and the tools available will allow us to build, test, and connect the services in a fault-tolerant way.</p>
<p>You will learn about all of those in this book.</p>
<p>It's time to look how Java EE can fit into the cloud-microservices picture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java EE microservices</h1>
                </header>
            
            <article>
                
<p>As mentioned in <em>The basic architecture of Java EE applications</em> section, traditionally, in Java EE, you were creating JARs with your applications and deploying them on an application server. With microservices, we will like to transform the same kind of JARs into runnable services:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eab1f248-568f-4adb-afc4-d9588e6b76b3.png" style=""/></div>
<p>In a traditional scenario, the application server has to support all the APIs specified in the standard.</p>
<p>In a microservices scenario, we will like to transform each JAR, which is an implementation of a microservice, into a runnable JAR. This can be done by creating a runtime for the given microservice and assembling this runtime and the service's archive into a runnable JAR. Since the assembled runtime will be used by only one service, we don't have to include all the Java EE modules in it. The tool that builds your microservices will have to analyze your service's archive and create a runtime, which contains only those functionalities that are required by it.</p>
<p>We have already sketched how we can use Java EE as a base for microservices architecture, but what are the benefits that you will achieve by doing so? Firstly, you will be able to take advantage of proven technologies and your experience with them immediately. Moreover, there is a portability aspect. As we covered in the preceding section, you are encouraged to start with monolithic applications and refactor it microservices, if necessary. Owing to the common set of technologies used and the standard archive format that is used in both scenarios, you can easily migrate between the two, creating an elastic architecture that can be changed and refactored when necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The goal of the book</h1>
                </header>
            
            <article>
                
<p>As you are going to learn in this book, you are able to use your existing Java EE knowledge to create microservices architecture. This knowledge will not be sufficient though, because, as we mentioned in the <em>Microservices</em> section, this kind of architecture introduces its own complexity, which has to be handled.</p>
<p>The goal of this book is to fill this knowledge gap by providing you with a practical, hands-on introduction to the development of microservice-based applications running on cloud infrastructures. This book makes an assumption that you are familiar with Java EE and the traditional way of developing Java EE applications. It will complement this knowledge with the information about a concrete set of tools that will allow you to immediately take advantage of both cloud computing and microservices.</p>
<p>We will like to emphasize that this book does not advertise any particular methodology, and, as we mentioned in the <em>Microservices</em> section, any architecture decision should be made with regard to the concrete project, taking into consideration all the advantages and disadvantages. Our goal is to provide you with a set of tools so that if you decide to make such a transition, you will immediately know what to do.</p>
<p>Throughout the book, we will develop a sample application, which will serve as a base for all our examples. Let's learn more about it now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pet store application</h1>
                </header>
            
            <article>
                
<p>Computer programming books often start with the <kbd>Hello World</kbd> application. Similarly, books describing a framework often develop a pet store application. We will follow this tradition. The pet store that we will develop will be a simple application that will allow you to browse the catalog of pets, add some of them to your cart, and finalize the payment.</p>
<p>During the development of the application, we will be concentrating on cloud and microservice aspects. The service code is simple and uses basic Java EE technologies so that the reader can concentrate on what is being taught in this book: cloud integration and microservices development.</p>
<p>Let's take the bird's-eye view of the application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/363032cd-f01c-4d94-bc80-801c788730c8.png" style=""/></div>
<p>The backend services (red), gateways (yellow), and security server (blue) are deployed in a cloud. The UI application (green) is deployed outside the cloud.</p>
<p>The gateway services are responsible for providing APIs for different users. The customer gateway provides an API for customers, which is used by petstore-ui—web-client implementing the store interface. The customer gateway orchestrates invocations to the underlying base services and is accessible from outside the cloud.</p>
<p>The security service is responsible for the authentication and authorization of access to different parts of the API. It is used by all other components. The security service is accessible from outside the cloud.</p>
<p>The core functionalities are implemented by backend services. Backend services are not accessible from the gateway service. Let's take a look at their functions:</p>
<ul>
<li>Catalog service: Provides information about pets available in the store</li>
<li>Pricing service: Responsible for providing the price of a given pet</li>
<li>Cart service: Responsible for keeping information about the cart of a given customer</li>
</ul>
<p>We will develop the application step by step throughout the book. The application is attached to the book, and as a result, you could work with it immediately while learning various concepts described in the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The technologies used</h1>
                </header>
            
            <article>
                
<p>We will convert our traditional Java EE JARs into runnable ones using WildFly Swarm—the tool that we will introduce in <a href="c00cfc93-f395-446e-9132-242f02216783.xhtml">Chapter 2</a>, <em>Get Familiar with WildFly Swarm</em>. WildFly Swarm is able to wrap our application into a JAR containing a minimal number of libraries needed for it, effectively creating microservices from a deployable JAR. We will cover how Swarm does it in <a href="dd01a81c-3ad7-4b3b-80fa-a8af1b89581c.xhtml">Chapter 3</a>, <em>Right-Size Your Applications</em>, and how to configure the created services in <a href="d76eaa85-5053-41f6-bcd1-307db5a17f60.xhtml">Chapter 4</a>, <em>Tuning the Configuration of Your Services</em>.</p>
<p>After services are written, we have to write tests for them. We will use the Arquillian library to do it. We will discuss how to use it in <a href="c1be724d-e5fd-4c33-bd27-c04887d5cc8e.xhtml">Chapter 5</a>, <em>Testing Your Services with Arquillian</em>.</p>
<p>We will deploy the created services in cloud using OpenShift. In <a href="461aee71-984a-4158-addc-fc49341d3455.xhtml">Chapter 6</a>, <em>Deploying Applications on the Cloud with OpenShift</em>, we will give you a theoretical introduction to the platform, the API, and tools that it provides. In <a href="d8bc5d6c-476e-45cf-b282-67388834947a.xhtml">Chapter 7</a>, <em>Configuring Persistent Storage for your Applications</em>, we will discuss how to configure persistent storage for our applications on OpenShift and how to scale and connect our services.</p>
<p>Creating and deploying applications in cloud is not enough for them to be ready for production. We still need to secure them, monitor them, and take care of network failures.</p>
<p>To provide security, we will take advantage of the Keycloak server. In order to take care of network failures, we will use the Hystrix library. In order to provide monitoring.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter was intended to give you an overview of what you can expect from reading this book.</p>
<p>We have recalled basic information about Java EE and the traditional way in which it was used to develop enterprise application. Later, we introduced modern trends in software development: cloud computing and microservices architecture.</p>
<p>Then, we introduced the pet store—the sample application that we are going to develop throughout the book.</p>
<p>Finally, we introduced all the technologies and tools used throughout the book, such as WildFly Swarm, OpenShift, Hystrix, Jenkins, and Keycloak.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="http://www.oracle.com/technetwork/java/javaee/overview/index.html">http://www.oracle.com/technetwork/java/javaee/overview/index.html</a></li>
<li><a href="https://www.youtube.com/watch?v=wgdBVIX9ifA">https://www.youtube.com/watch?v=wgdBVIX9ifA</a></li>
<li><a href="https://martinfowler.com/bliki/MonolithFirst.html">https://martinfowler.com/bliki/MonolithFirst.html</a></li>
</ol>


            </article>

            
        </section>
    </body></html>