<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Online Shopping - Persistence</h1>
                </header>
            
            <article>
                
<p>In the next four chapters, we will write a project using the most common libraries and framework from the Scala ecosystem.</p>
<p>We are going to implement the cart management of an online shopping website, from the front-end to the database.</p>
<p>Starting from the database, we are going to implement a persistence layer. The responsibility of this layer is to persist in a relational database the content of the cart, for that purpose we are going to use a relational persistence framework named Slick.</p>
<p>Then, we are going to spend times to define an API to access the database, this API will use RESTfull web services architecture and JSON as message protocol. The API will be fully documented and testable from a generated website.</p>
<p>Finally, we are going to implement the user interface layer. With this interface, the user can add products into its cart, remove products and update the quantity of a particular product in the cart. Scala.js is used to implement this interface.</p>
<p>In this chapter, we will explain how to persist data in a relational database. The data will be the contents of a cart for a shopping website.</p>
<p>If we want to build a robust website accepting lots of simultaneous connection, special care is needed to have all of the layers of the solution to scale with the demand.</p>
<p>At the level of the persistence layer, a key point to scale would be to not overuse the system resources, more precisely the threads, each time data is written into the database. Indeed, if each request to the database is blocking a thread, the limit of concurrent connections will be reached quickly.</p>
<p>For that purpose, we will use an asynchronous framework called Slick to perform database actions.</p>
<p>In order to use the Slick framework, an introduction to Scala <kbd>Future</kbd> will be necessary. <kbd>Future</kbd> is one of the basic tools to handle asynchronous code in Scala.</p>
<p>As we rarely host a website at home, we are going to deploy this layer, and later the whole website, to the internet by using a cloud service provider named Heroku. This means that the shopping cart will be accessible from all over the world. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li><span>Creating the project</span></li>
<li>Persistence</li>
<li>Deploying the application</li>
<li>Heroku configuration</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the project</h1>
                </header>
            
            <article>
                
<p>To facilitate the project creation, we are providing a template which generates the skeleton of the project. For that purpose,<span> </span><a href="http://www.foundweekends.org/giter8/">Gitter8</a> will help us to generate the complete project based on a template hosted in Git.</p>
<p>We are not going to directly use the command line of Gitter8. We are instead going to use the integration with sbt to generate the project.</p>
<p>The template can be found on Github at <a href="https://github.com/scala-fundamentals/scala-play.g8.git">GitHub - scala-fundamentals/scala-play.g8: Template used for the online shopping</a>. This template has been forked from <a href="https://github.com/vmunier/play-scalajs.g8.">https://github.com/vmunier/play-scalajs.g8.</a><span> </span>We essentially changed the framework test from Specs2 to ScalaTest and added all the dependencies needed for our shopping project.</p>
<p>To create the project, enter the following in your console:</p>
<pre>sbt new scala-fundamentals/scala-play.g8 --name=shopping --organization=io.fscala</pre>
<p>This will create a new folder with all the files and folders needed for our project.</p>
<p>You can now import this project in IntelliJ, click on <span class="packt_screen">Import Project</span> select <span class="packt_screen">sbt</span> on the first dialogue box:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/634469b6-44c4-4e79-87bd-0a7946c7b245.png" style="width:32.00em;height:25.92em;"/></p>
<p>Click on <span class="packt_screen">Next</span>, on the next dialogue box, please check the option Use <span class="packt_screen">sbt shell for build and import (requires sbt 0.13.5+)</span> as shown in the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c0776ff8-31c5-42dd-b214-149b8232ba1a.png" style="width:51.25em;height:50.42em;"/></p>
<p>That's it, we are ready for the implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Persistence</h1>
                </header>
            
            <article>
                
<p>In the context of the online shopping project, we are going to create a simple data model with only two tables—the cart and product tables. The product represents what we would like to sell. It has a name, a code, a description, and a price.</p>
<p>The cart what a customer is about to buy. It has an ID, which is autoincremented for any new cart created, and a user, representing the user identification. For the purpose of this book, we are going to use the username sent during the login process. The cart also has a quantity and a code, representing a link to the product table.</p>
<p>The following diagram is a representation of our <span>model:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ffbc423a-10d7-4796-a141-9f8d8f924663.png" style="width:39.08em;height:12.08em;"/></p>
<p>For the purposes of this book, we will choose a database that requires no administration, is fast, with a small footprint, and can be deployed quickly and smoothly. The H2 database fulfills all of these requirements.</p>
<p>To access our data, we would like to take advantage of the Scala language to statically check our code at compile time. The Slick library is perfect for this task.</p>
<p>Slick can generate SQL for multiple databases, and it supports the following RDBMS (with the respective JDBC driver versions):</p>
<table border="1" style="border-collapse: collapse">
<tbody>
<tr>
<td>
<p>Database</p>
</td>
<td>
<p>JDBC Driver</p>
</td>
</tr>
<tr>
<td>
<p>SQLServer 2008, 2012, 2014</p>
</td>
<td>
<p>jTDS - SQL Server and Sybase JDBC driver (<a href="https://sourceforge.net/projects/jtds/">https://sourceforge.net/projects/jtds/</a>) and Microsoft JDBC Driver 6.0 for SQL Server (<a href="https://www.microsoft.com/en-gb/download/details.aspx?id=11774">https://www.microsoft.com/en-gb/download/details.aspx?id=11774</a>)</p>
</td>
</tr>
<tr>
<td>
<p>Oracle 11g</p>
</td>
<td>
<p><a href="http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html">http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html</a></p>
</td>
</tr>
<tr>
<td>
<p>DB2 10.5</p>
</td>
<td>
<p><a href="http://www-01.ibm.com/support/docview.wss?uid=swg21363866">http://www-01.ibm.com/support/docview.wss?uid=swg21363866</a></p>
</td>
</tr>
<tr>
<td>
<p>MySQL</p>
</td>
<td>
<p><kbd>mysql-connector-java:5.1.23</kbd> ( <a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a>)</p>
</td>
</tr>
<tr>
<td>
<p>PostgreSQL</p>
</td>
<td>
<p>PostgreSQL JDBC Driver: <kbd>9.1-901.jdbc4</kbd> (<a href="https://jdbc.postgresql.org">https://jdbc.postgresql.org</a>)</p>
</td>
</tr>
<tr>
<td>
<p>SQLite</p>
</td>
<td>
<p><kbd>sqlite-jdbc:3.8.7</kbd> (<a href="https://bitbucket.org/xerial/sqlite-jdbc/downloads/">https://bitbucket.org/xerial/sqlite-jdbc/downloads/</a>)</p>
</td>
</tr>
<tr>
<td>
<p>Derby/JavaDB</p>
</td>
<td>
<p><kbd>derby:10.9.1.0</kbd> (<a href="https://db.apache.org/derby/derby_downloads.html">https://db.apache.org/derby/derby_downloads.html</a>)</p>
</td>
</tr>
<tr>
<td>
<p>HSQLDB/HyperSQL</p>
</td>
<td>
<p><kbd>hsqldb:2.2.8</kbd> (<a href="https://sourceforge.net/projects/hsqldb/">https://sourceforge.net/projects/hsqldb/</a>)</p>
</td>
</tr>
<tr>
<td>
<p>H2</p>
</td>
<td>
<p><kbd>com.h2database.h2:1.4.187</kbd> (<a href="http://h2database.com/html/download.html">http://h2database.com/html/download.html</a>)</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Slick</h1>
                </header>
            
            <article>
                
<p>What do we need to set up Slick? I<span>n the</span> <kbd>build.sbt</kbd><span> file f</span>rom the project generated on<span> the <em>Developing a full project</em> chapter,</span> the requested libraries are set in the server section. Slick is well integrated with Play, and the full list of dependencies is as follows:</p>
<pre>libraryDependencies ++= Seq(
  "com.typesafe.play" %% "play-slick" % "3.0.0",
  "com.typesafe.play" %% "play-slick-evolutions" % "3.0.0",
  "com.h2database" % "h2" % "1.4.196"
)</pre>
<p>We added Slick dependencies, as well as the Evolution module. Evolution is a module that simplifies schema management; we will come back to that later.</p>
<p>We had to add the JDBC driver as well; this is due to the fact that Slick does not come bundled with all of the drivers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the database</h1>
                </header>
            
            <article>
                
<p>The database setup is done in the <kbd>conf/application.conf</kbd> file. When a database is needed, it must be configured in this file. Slick provides a default configuration, named <kbd>default</kbd>. For a new database, replace this name with the name of your database.</p>
<p>We will enable <kbd>evolution</kbd> and tell it to automatically run the scripts for database creation and deletion.</p>
<p>In our case, the entry looks as follows:</p>
<pre># Default database configuration
slick.dbs.default.profile="slick.jdbc.H2Profile$"
slick.dbs.default.db.driver="org.h2.Driver"
slick.dbs.default.db.url="jdbc:h2:mem:shopping"

play.evolutions.enabled=true
play.evolutions.db.default.autoApply=true</pre>
<p> The complete configuration option can be found in the Play Framework documentation (<a href="https://www.playframework.com/documentation/2.6.x/PlaySlick">https://www.playframework.com/documentation/2.6.x/PlaySlick</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database test</h1>
                </header>
            
            <article>
                
<p>Before we get started, we should check that the database created by <kbd>evolution</kbd> is correct, and we should define the expected behaviors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Product test</h1>
                </header>
            
            <article>
                
<p>We should also verify that three product rows are inserted when the application is started.</p>
<p class="mce-root">Create a test class, named <kbd>ProductDaoSpec</kbd>, which extends <kbd>PlaySpec</kbd>. Now, <kbd>PlaySpec</kbd> is the integration of ScalaTest in Play. The <kbd>ProductDaoSpec</kbd> class also needs to extend the <kbd>GuiceOneAppPerSuite</kbd> trait. This trait adds a new instance of the <kbd>Application</kbd> object to the ScalaTest suite:</p>
<pre>class<span> </span>ProductDaoSpec <span>extends </span>PlaySpec <span>with </span>ScalaFutures <span>with </span>GuiceOneAppPerSuite {<br/>  <span>"ProductDao" </span>should {<br/>    <span>"Have default rows on database creation" </span>in {<br/>      <span>val </span>app2dao = Application.<span>instanceCache</span>[ProductDao]<br/>      <span>val </span>dao: ProductDao = app2dao(<span>app</span>)<br/><br/>      <span>val </span>expected = <span>Set</span>(<br/>        <span>Product</span>(<span>"PEPPER"</span><span>, </span><span>"ALD2"</span><span>, </span><span>"PEPPER is a robot moving with wheels <br/>        and with a screen as human interaction"</span><span>, </span><span>7000</span>)<span>,<br/></span><span>        </span><span>Product</span>(<span>"NAO"</span><span>, </span><span>"ALD1"</span><span>, </span><span>"NAO is an humanoid robot."</span><span>, </span><span>3500</span>)<span>,<br/></span><span>        </span><span>Product</span>(<span>"BEOBOT"</span><span>, </span><span>"BEO1"</span><span>, </span><span>"Beobot is a multipurpose robot."</span><span>, <br/>        </span><span>159.0</span>)<br/>      )<br/><br/>      dao.all().futureValue should <span>contain </span>theSameElementsAs (expected)<br/>    }<br/>  }<br/>}</pre>
<p>Play provides a helper method to create an instance in the cache. As you can see, <kbd>app2dao</kbd> can create an instance of <kbd>ProductDao</kbd>, which was the type parameter passed to <kbd>instanceCache</kbd>.</p>
<div class="packt_tip">The matcher on the <kbd>Set</kbd> is not strict, and it does not take into account the order of the rows received. If you would like to be stricter, ScalaTest provides the <kbd>theSameElementsInOrderAs</kbd> matcher, which checks the order of the elements in the collection. </div>
<p>As the <kbd>dao.all()</kbd> function returns <kbd>Future</kbd>, ScalaTest provides the <kbd>.futureValue</kbd> helper to wait on <kbd>Future</kbd> to finish before testing the value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cart test</h1>
                </header>
            
            <article>
                
<p>What about the cart? We would like to make sure that the cart is empty when the application is run so that we can add items to it. </p>
<p>Just like we did for the product, we will create a class named <kbd>CartDaoSpec</kbd>. The test looks as follows:</p>
<pre>class CartDaoSpec extends PlaySpec with ScalaFutures with GuiceOneAppPerSuite {<br/><br/>  "CartDao" should {<br/>    val app2dao = Application.instanceCache[CartDao]<br/>    <br/>    "<strong>be empty on database creation</strong>" in {<br/>      val dao: CartDao = app2dao(app)<br/>      dao.all().futureValue shouldBe empty<br/>    }<br/><br/>    "<strong>accept to add new cart</strong>" in {<br/>      val dao: CartDao = app2dao(app)<br/>      val user = "userAdd"<br/><br/>      val expected = Set(<br/>        Cart(user, "ALD1", 1),<br/>        Cart(user, "BEO1", 5)<br/>      )<br/>      val noise = Set(<br/>        Cart("userNoise", "ALD2", 10)<br/>      )<br/>      val allCarts = expected ++ noise<br/><br/>      val insertFutures = allCarts.map(dao.insert)<br/><br/>      whenReady(Future.sequence(insertFutures)) { _ =&gt;<br/>        dao.cart4(user).futureValue should contain theSameElementsAs expected<br/>        dao.all().futureValue.size should equal(allCarts.size)<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p>The <kbd>be empty on database creation</kbd> test makes sure that no carts exist upon creation of the application, and <kbd>accept to add new cart</kbd> makes sure that we can insert products into a specific cart; when the cart is read back, only the product of that cart is returned. This is tested by the fact that we are adding a new product to the cart of <kbd>user2</kbd>, instead of <kbd>user1</kbd>.</p>
<p>For consistency, we would like to have a constraint on the database where we only have a unique tuple <kbd>user</kbd> and <kbd>productCode</kbd>. In case we do not have a unique pair, we should expect an error to be thrown from the database saying that the cart already exists:</p>
<pre>"error thrown when adding a cart with same user and productCode" in {<br/>  val dao: CartDao = app2dao(app)<br/>  val user = "userAdd"<br/>  val expected = Set(<br/>    Cart(user, "ALD1", 1),<br/>    Cart(user, "BEO1", 5)<br/>  )<br/>  val noise = Set(<br/>    Cart(user, "ALD1", 10)<br/>  )<br/>  val allCarts = expected ++ noise<br/>  val insertFutures = allCarts.map(dao.insert)<br/>  recoverToSucceededIf[org.h2.jdbc.JdbcSQLException]{<br/>    Future.sequence(insertFutures)<br/>  }<br/>}</pre>
<p>In <kbd>expected.map(dao.insert(_)) ++ noise.map(dao.insert(_))</kbd> , we are creating a <kbd>Set</kbd> of <kbd>Future</kbd> by adding the Futures from the expected cart insertion and the noise cart insertion.</p>
<p>To test if an error is thrown, ScalaTest provides the <kbd>recoverToSucceededIf[T]</kbd> function that tests if the <kbd>Future</kbd> passed as a parameter throws the type <kbd>[T]</kbd> error.</p>
<p>We would also like to test whether we can remove an item from the cart.</p>
<p>The following code will perform this test:</p>
<pre>"accept to remove a product from a cart" in {<br/>  val dao: CartDao = app2dao(app)<br/>  val user = "userRmv"<br/>  val initial = Vector(<br/>    Cart(user, "ALD1", 1),<br/>    Cart(user, "BEO1", 5)<br/>  )<br/>  val expected = Vector(Cart(user, "ALD1", 1))<br/><br/>  whenReady(Future.sequence(initial.map(dao.insert(_)))) { _ =&gt;<br/>    dao.remove(ProductInCart(user, "BEO1")).futureValue<br/>    dao.cart4(user).futureValue should contain theSameElementsAs <br/>      (expected)<br/>  }<br/>}</pre>
<p>First, we add an initial cart with two products, and then, we remove one product from the cart. Notice that we introduced a new class, named <kbd>ProductInCart</kbd>, which represents a product in a cart.</p>
<p>To be complete, our <kbd>CartDao</kbd> should accept updating the product quantity in a cart; this is represented by the following code:</p>
<pre>"accept to update quantities of an item in a cart" in {<br/>  val dao: CartDao = app2dao(app)<br/>  val user = "userUpd"<br/>  val initial = Vector(Cart(user, "ALD1", 1))<br/>  val expected = Vector(Cart(user, "ALD1", 5))<br/><br/>  whenReady(Future.sequence(initial.map(dao.insert(_)))) { _ =&gt;<br/>    dao.update(Cart(user, "ALD1", 5)).futureValue<br/>    dao.cart4(user).futureValue should contain theSameElementsAs <br/>      (expected)<br/>  }<br/>}</pre>
<p>In this test, we first set the cart for <kbd>userUpd</kbd> with a quantity of <kbd>1</kbd> unit of <kbd>ALD1</kbd>, and then update it with a quantity of <kbd>5</kbd> units of <kbd>ALD1</kbd>.</p>
<p>Of course, as there is no implementation, the test does not even compile; it is time to create the database and implement the <strong>Data Access Objects</strong> (<strong>DAO</strong>). Before going further, notice the piece of code with <kbd>.futureValue</kbd>. This is the perfect time to explain what Futures are all about.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Future</h1>
                </header>
            
            <article>
                
<p>As you can see in the test code, <kbd>wsClient.url(testURL).get()</kbd> returns <kbd>Future</kbd>; more precisely, it returns <kbd>Future</kbd> of <kbd>Response</kbd> (<kbd>Future[Response]</kbd>).</p>
<p><kbd>Future</kbd> represents a piece of code executed asynchronously. The code starts its execution upon the creation of <kbd>Future</kbd>, without knowing when it will finish its execution.</p>
<p>So far, so good; but how can we get the result?</p>
<p>Before we answer this question, there are some important points to understand. What is the purpose of writing asynchronous code?</p>
<p>We write it to improve performance. Indeed, if the code is run in parallel, we can take advantage of the multiple cores that are available on modern CPUs. This is all fine, but in my program, I cannot parallelize every piece of code. Some pieces are dependent on values coming from others.</p>
<p>Wouldn't it be nice if I could compose my code in such a way that as soon as a value is finished being evaluated, the program goes ahead and uses that variable? That is the exact purpose of <kbd>Future</kbd>. You can compose pieces of asynchronous code together; the result of the composition is another <kbd>Future</kbd>, which can be composed with another <kbd>Future</kbd>, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a concrete value</h1>
                </header>
            
            <article>
                
<p>OK, we can compose Futures to have new Futures but, at some point, we will need to have a concrete value instead of <kbd>Future</kbd>.</p>
<p>When we asked to get the response of a REST call, we receive <kbd>Future</kbd> from the function. The particularity of <kbd>Future</kbd> is that we do not know when it is going to finish so in our test we need to wait until we get the <span>concrete</span> value of <kbd>Future</kbd>.</p>
<p>To get a concrete value, you can either wait for <kbd>Future</kbd> to complete or provide a callback. Let us go into the details of both cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Waiting on a Future</h1>
                </header>
            
            <article>
                
<p>The <kbd>Await.result</kbd> method is waiting for the result to be available. We have the possibility to give a timeout to the method so that it does not block forever.</p>
<p>The signature is as follows:</p>
<pre>Await.result(awaitable: Awaitable[T], atMost: Duration)</pre>
<p>The first parameter waits for <kbd>Awaitable</kbd> (<kbd>Future</kbd> extends <kbd>Awaitable</kbd>), and the second is <kbd>Duration</kbd>. <kbd>Duration</kbd> is the time to wait before throwing <kbd>TimeoutException</kbd>.</p>
<p>This is a pretty convenient method to get the value in our test.</p>
<div class="packt_tip">If you add <kbd>import scala.concurrent.duration._</kbd> in the import section, you can use a <strong>Domain Specific Language</strong> (<strong>DSL</strong>) to express the duration in plain English, as follows:<br/>
<kbd>1 second</kbd><br/>
<kbd>2 minutes</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Callback</h1>
                </header>
            
            <article>
                
<p>Another way to get the result is to use a callback function. In this case, we stay asynchronous to get the value. The syntax is as follows:</p>
<pre>Import scala.concurrent.{Await, Future}
import scala.util.{Failure, Success}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._

val f: Future[String] = Future {
  Thread.sleep(1000)
  “Finished”
}
f.onComplete {
  case Success(value) =&gt; println(value)
  case Failure(e) =&gt; e.printStackTrace()
}</pre>
<p>First, <kbd>Future</kbd> is created and assigned to <kbd>f</kbd>; then, we handle the success case, and then, the failure case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composing Futures</h1>
                </header>
            
            <article>
                
<p>You have learned how to get a concrete value out of <kbd>Future</kbd>; you will now learn how to compose multiple Futures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using for-comprehension</h1>
                </header>
            
            <article>
                
<p><kbd>Future</kbd> has a <kbd>map</kbd> and a <kbd>flatMap</kbd> method. Therefore, as we saw in <a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml">Chapter 3</a>, <em>Handling Errors</em>, for <kbd>Either</kbd>, we can use <kbd>Future</kbd> in a <kbd>for</kbd>-comprehension. For instance, we can define three Futures, as follows:</p>
<pre>val f1 = Future {1}
val f2 = Future {2}
val f3 = Future {3}</pre>
<p>The Futures are simply successfully returning an integer. If we would like to sum up all of the integers we could write the following:</p>
<pre>val res = for {
  v1 &lt;- f1
  v2 &lt;- f2
  v3 &lt;- f3
  } yield (v1 + v2 + v3)</pre>
<p>The <kbd>res</kbd> variable will be <kbd>Future[Int]</kbd>; hence, we can call <kbd>Await</kbd> to get the final value:</p>
<pre>val response = Await.result(res, 1 second)</pre>
<p>The response would be <kbd>6</kbd>, in our case.</p>
<p>You just learned that inside the <kbd>for</kbd>-comprehension, the value from <kbd>Future</kbd> can be used and can be composed with other values. But there is more; you can also add an <kbd>if</kbd> condition inside, acting as a filter. Suppose that we would like to check that the three numbers from the previous example, when added together, are greater than five. If this is the case, then it should return a tuple with the three numbers; otherwise, it should return a failure. We can first define a function that takes an undefined number of parameters and returns their <kbd>sum</kbd>, as follows:</p>
<pre>def sum(v: Int*) = v.sum</pre>
<div class="packt_tip">You can define multiple parameters by adding <kbd>*</kbd> after the type in the parameter definition; this is called a <strong>variadic </strong>or <kbd>varargs</kbd> function.</div>
<p>The <kbd>for</kbd>-comprehension, with our filter, will look as follows:</p>
<pre>val minExpected = 5

val res = for {
  v1 &lt;- f1
  v2 &lt;- f2
  v3 &lt;- f3
  if (sum(v1, v2, v3) &gt; minExpected)
} yield (v1, v2, v3)</pre>
<p>We can employ what we learned in the previous section, and use a callback to get the value, as follows:</p>
<pre>res.onComplete {
  case Success(result) =&gt; println(s"The result is $result")
  case Failure(e) =&gt; println("The sum is not big enough")
}</pre>
<p>The following code will be printed in the console:</p>
<pre><strong>The result is (1,2,3)</strong></pre>
<p>However, if you set <kbd>minExpected</kbd> to <kbd>7</kbd>, you should obtain the following:</p>
<pre><strong>The sum is not big enough</strong></pre>
<p>In fact, <kbd>Future</kbd> is a failure; its representation is as follows:</p>
<pre>Future(Failure(java.util.NoSuchElementException: Future.filter predicate is not satisfied))</pre>
<p>One last thing—I am sure that you noticed the following in the first piece of code that we imported:</p>
<pre>import scala.concurrent.ExecutionContext.Implicits.global</pre>
<p>What is this strange import? It is the execution context, which will be covered in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Execution context</h1>
                </header>
            
            <article>
                
<p>When we create a <kbd>Future</kbd>, the code is executed asynchronously on the JVM, but what is used to execute that code? In fact, the only way to execute code in parallel is to use threads. A naive approach would be to suggest: I should just create a new thread each time I would like to execute a new piece of code. However, that is a really bad idea. First, the number of threads is limited by the operating system; you cannot spawn as many threads as you want. Secondly, you could face thread starvation (<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html">https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html</a>); this happens when your CPU spends all of its time switching contexts between threads, instead of executing real code.</p>
<p>OK, but how can you manage the thread creation? That is the purpose of the execution context. You can set the policy that you wish to manage your threads. Scala provides a default policy that creates and manages a pool of threads; the number of threads is automatically defined by the number of processors available to the JVM.</p>
<p>So, by importing <kbd>scala.concurrent.ExecutionContext.Implicits.global</kbd>, you are just saying that you would like to use the default policy to manage your thread, which should be fine for the majority of your code. You might need to define your own <kbd>ExecutionContext</kbd>, if, for example, you are creating <kbd>Future</kbd> that gets data from a legacy software blocking the call.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rounding up Futures</h1>
                </header>
            
            <article>
                
<p><span>The basic operations on <kbd>Future</kbd> are</span> <kbd>map</kbd> <span>and</span> <kbd>flatMap</kbd><span>. In fact, when we use the</span> <kbd>for</kbd>-<span>comprehension, under the hood, the compiler transforms our loop with</span> <kbd>map</kbd> <span>and</span> <kbd>flatMap</kbd><span>.</span></p>
<p>Futures are very important in Scala; we have only learned the basics of Futures; just enough to understand the code i<span>n this book. Let's stop here and go back to our shopping cart.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database creation</h1>
                </header>
            
            <article>
                
<p>Before discussing Futures, we were writing tests to check <kbd>Cart</kbd> and the <kbd>Product</kbd> behavior. But, as the classes were not defined, the code was not even compiling. Let's start to create the database and then implement the DAO.</p>
<p>We can use Evolution to automatically create the database each time the server starts for the first time.</p>
<p>To do so, we need to add a script named <kbd>1.sql</kbd> in <kbd>conf/evolutions/default/</kbd>, where <kbd>default</kbd> is the database name used in the <kbd>configuration</kbd> file. This file is an SQL file, with a couple of tags to handle the creation and destruction of the database upon application start and stop, respectively.</p>
<p>We will start with the creation of the product table; the script is as follows:</p>
<pre># --- !Ups
CREATE TABLE IF NOT EXISTS PUBLIC.PRODUCTS (
  name VARCHAR(100) NOT NULL,
  code VARCHAR(255) NOT NULL,
  description VARCHAR(1000) NOT NULL,
  price INT NOT NULL,
  PRIMARY KEY(code)
);</pre>
<p>In this script, we can add some default data upon database creation; this data will be used in our tests defined earlier:</p>
<pre>INSERT INTO PUBLIC.PRODUCTS (name,code, description, price) VALUES ('NAO','ALD1','NAO is an humanoid robot.', 3500);
INSERT INTO PUBLIC.PRODUCTS (name,code, description, price) VALUES ('PEPER','ALD2','PEPPER is a robot moving with wheels and with a screen as human interaction',7000);
INSERT INTO PUBLIC.PRODUCTS (name,code, description, price) VALUES ('BEOBOT','BEO1','Beobot is a multipurpose robot.',159);</pre>
<p>The next step is to add the cart table, as follows:</p>
<pre>CREATE TABLE IF NOT EXISTS PUBLIC.CART (
  id BIGINT AUTO_INCREMENT,
  user VARCHAR(255) NOT NULL,
  code VARCHAR(255) NOT NULL,
  qty INT NOT NULL,
  PRIMARY KEY(id),<br/><span>  CONSTRAINT </span>UC_CART <span>UNIQUE </span>(<span>user</span><span>,</span>code)<br/>);</pre>
<p>We just created the table. Notice that we added a constraint to the cart table; we would like to have a unique row with the same <kbd>user</kbd> and <kbd>productCode</kbd>.</p>
<p>We explained how table creation and data insertion is done, and we can now concentrate on when and how this script is executed.</p>
<p class="mce-root">The following line, with a special meaning, can be seen in the script:</p>
<pre># --- !Ups</pre>
<p>This instruction tells Play Evolution how to create the database upon application start.</p>
<p>We can also tell Play how to clean up the database when the application stops. The instruction is as follows:</p>
<pre># --- !Downs</pre>
<p>In our case, when the application quits, we just delete the tables. In fact, as our database is in the memory, we don't really have to delete the table; this is just to illustrate the point:</p>
<pre># --- !Downs
DROP TABLE PRODUCTS;
DROP TABLE CART;</pre>
<p>You can now start the Play application. As soon as you browse <kbd>index.html</kbd> (<kbd>http://localhost:9000/index.html</kbd>), you'll notice Play asking for permission to execute the script.</p>
<p>Click on <span class="packt_screen">Apply this script now</span><span class="packt_screen">!</span></p>
<div class="packt_tip">If you make a mistake in the script, Play Evolution will notify you of an error and will provide a <span class="packt_screen">Mark it resolved</span> button after the error is fixed.</div>
<p>The database is now ready to be exploited. Let's create the Slick schemas and the data access layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data Access Object creation</h1>
                </header>
            
            <article>
                
<p>To access our database, we need to define the schema for Slick to perform queries against the database and wrap everything in a data access class.</p>
<p>The <kbd>ProductsDao</kbd> class is as follows:</p>
<pre>class ProductsDao @Inject()(protected val dbConfigProvider: DatabaseConfigProvider)(implicit executionContext: ExecutionContext) extends HasDatabaseConfigProvider[JdbcProfile] {

  import profile.api._

  def all(): Future[Seq[Product]] = db.run(products.result)

  def insert(product: Product): Future[Unit] = db.run(products <br/>    insertOrUpdate product).map { _ =&gt; () }

  private class ProductsTable(tag: Tag) extends Table[Product](tag, <br/>    "PRODUCTS") {
    def name = column[String]("NAME")

    def code = column[String]("CODE")

    def description = column[String]("DESCRIPTION")

    def price = column[Double]("PRICE")

    override def * = (name, code, description, price) &lt;&gt;     <br/>    (Product.tupled, Product.unapply)
  }

  private val products = TableQuery[ProductsTable]
}</pre>
<p>The schema of our database is expressed with a private class, named <kbd>ProductsTable</kbd>. This class is a type definition of our table; each column (<kbd>name</kbd>, <kbd>code</kbd>, and <kbd>description</kbd>) is defined by using the <kbd>column</kbd> parameterized method. The name of the column in the database is defined by the parameter.</p>
<div class="packt_tip">H2 is case sensitive by default, and it converts all of the column names to uppercase. If you change the case of the column name in the <kbd>ProductTable</kbd> definition, you will get an error saying that the column does not exist. You can change the case of a selected text in IntelliJ by hitting the keys <em>cmd</em> + <em>Shift</em> + <em>U</em>.</div>
<p>The link between this schema and our object model is established with the parameterized type of the extended <kbd>Table</kbd>. In our case, the <kbd>Product</kbd> class is as follows:</p>
<pre>case class Product(name: String,
                   code : String,
                   description : String,
                   price: Double)</pre>
<p>This case class is defined in the <kbd>Models.scala</kbd> file, located in the <kbd>models</kbd> package.</p>
<p>Another interesting value is <kbd>TableQuery[ProductsTable]</kbd>, assigned to <kbd>products</kbd>. This is an object used to create queries against this table; for example, to create the query to add a product into the table, the syntax is <kbd>products += product</kbd> (with <kbd>product</kbd> being a new <kbd>product</kbd> instance).</p>
<p>To execute a query against the database, you will need the following two things:</p>
<ul>
<li>First, you will need the query; this is built by <kbd>products</kbd> (a query object generated by the <kbd>TableQuery</kbd> macro). You can build a query such as <kbd>products.result</kbd> to get all of the rows of the table, or <kbd>products.filter(_.price &gt; 10.0)</kbd> to get all of the products with a price higher than <kbd>10.0</kbd>.</li>
<li>Secondly, once you have built your query, you will need to execute it to get a materialized value. This is done by using the <kbd>db</kbd> variable defined in the <kbd>HasDatabaseConfigProvider</kbd> class. For example, to get all of the rows of the table, you can use <kbd>db.run(products.result)</kbd>.</li>
</ul>
<p>For <kbd>products</kbd>, we only have the possibility to query all of the products and add a new <kbd>Product</kbd> to the table. This is represented by the <kbd>all()</kbd> and <kbd>insert(product: Product)</kbd> methods. In the <kbd>insert</kbd> method, after executing the query, we map the result by using <kbd>.map { _ =&gt; () } </kbd>; this is just to return <kbd>Unit</kbd> for the execution of the side effect.</p>
<p>You will have noticed that the return type of all of the methods is <kbd>Future</kbd>; this means that the code is executed by Slick completely asynchronously.</p>
<p>For the cart, the code should be more involved; indeed, we need to create a cart, add a product to it, remove a product, and even update the quantity for a product, as follows:</p>
<pre>class CartsDao @Inject()(protected val dbConfigProvider: DatabaseConfigProvider)(implicit executionContext: ExecutionContext) extends HasDatabaseConfigProvider[JdbcProfile] {

  import profile.api._


  def cart4(usr : String): Future[Seq[Cart]] = <br/>    db.run(carts.filter(_.user === usr).result)

  def insert(cart: Cart): Future[_] = db.run(carts += cart)

  def remove(cart: ProductInCart): Future[Int] = <br/>    db.run(carts.filter(c =&gt; matchKey(c, cart)).delete)<br/><br/>  def update(cart: Cart): Future[Int] = {<br/>    val q = for {<br/>      c &lt;- carts if matchKey(c, cart)<br/>    } yield c.quantity<br/>    db.run(q.update(cart.quantity))<br/>  }<br/><br/>  private def matchKey(c: CartTable, cart: CartKey): Rep[Boolean] = {<br/>    c.user === cart.user &amp;&amp; c.productCode === cart.productCode<br/>  }

  def all(): Future[Seq[Cart]] = db.run(carts.result)

  private class CartsTable(tag: Tag) extends Table[Cart](tag, "CART") {

    def user = column[String]("USER")

    def productCode = column[String]("CODE")

    def quantity = column[Int]("QTY")

    override def * = <br/>      (user, productCode, quantity) &lt;&gt; (Cart.tupled, Cart.unapply)
  }

  private val carts = TableQuery[CartsTable]

}</pre>
<p>The model of our cart is defined by the following class:</p>
<pre>abstract class CartKey {<br/>  def user: String<br/>  def productCode: String<br/>}<br/><br/>case class ProductInCart(user:String, productCode: String) extends CartKey<br/><br/>case class Cart(user:String, productCode: String, quantity: Int) extends CartKey</pre>
<p>In the queries, the operators are the same as the ones used in Scala, except that, for the equivalence, you will need to use the <kbd>===</kbd> operator.</p>
<p>We can spend a little bit of time on the <kbd>update</kbd> method. A<span>s explained in the</span> <em>Future</em> <span>section, </span>you can use a <kbd>for</kbd>-comprehension to build your query. In our case, we would like to update the quantity of a product in the cart for a specific user. We use <kbd>for</kbd>-comprehension to select the cart based on the user, and then update the quantity of the product using the quantity of the cart received as a parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the test</h1>
                </header>
            
            <article>
                
<p>We have now created the database using Evolution, configured Slick, and implemented the data access objects to access the tables.</p>
<p>Let's execute the tests we wrote at the beginning; they should compile and should all be successful.</p>
<p>Run <kbd>DatabaseSpec</kbd> to be sure, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ad0b0d3f-4b0b-4c91-860c-9cb60c239412.png" style="width:41.50em;height:17.75em;"/></p>
<p>Our persistence layer is now ready to be used. We can deploy this layer on the cloud to make sure the deployment is working smoothly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying the application</h1>
                </header>
            
            <article>
                
<p>The server is running fine on our localhost, as this application is not doing much. This is the perfect time to perform all of the steps to deploy it. With each new feature, we are going to deploy it and get used to this process. This way, we can tackle the deployment issues little by little, instead of solving everything in one shot, usually under stress.</p>
<p>We have decided to deploy this application on Heroku.</p>
<p>Heroku is a <strong>P</strong>latform as a Service (<strong>PaaS</strong>) that supports multiple languages, including Scala. Thanks to its simplicity and versatility, the deployment process is simple and smooth.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up an account</h1>
                </header>
            
            <article>
                
<p>The first thing to do is create an account on the Heroku platform. Heroku provides a free account, which is perfect for our usage.</p>
<p>Go to the website (<a href="https://www.heroku.com/">https://www.heroku.com/</a>) and sign up for a free account. You will receive an email from Heroku to validate your account and set up a password. As soon as you set up your password, you will land on a page to create a new application; this is exactly what we want to do.</p>
<p>Click on the <span class="packt_screen">Create New App</span> button and pick an application name. This name needs to be unique, as it will be used in the URL to reach the application on the internet. I am using <kbd>shopping-fs</kbd>; feel free to pick the name you wish. The name should be unique. If it is not, an error will tell you to change the name.</p>
<p>Select the region closest to your location, and click on the <span class="packt_screen">C</span><span class="packt_screen">reate App</span> button. The creation of the application is instantaneous, and you will be redirected directly to your <span class="packt_screen">Dashboard</span>, under the <span class="packt_screen">Deploy</span> tab.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying your application</h1>
                </header>
            
            <article>
                
<p>On the Heroku website, under the <span class="packt_screen">Deploy</span> tab, at the bottom, you will see the instructions to deploy your application. The first thing to do is install the Heroku CLI; follow this link (<a href="https://devcenter.heroku.com/articles/heroku-cli">https://devcenter.heroku.com/articles/heroku-cli</a>) and pick your operating system to install the Heroku CLI.</p>
<p>Once the CLI has been installed, go to IntelliJ and click on the <span class="packt_screen">Terminal</span> tab located at the bottom of the window. IntelliJ will set the current path of the Terminal to the root path of the current project.</p>
<p>From inside the Terminal, log in to Heroku by using the following command:</p>
<pre><strong>heroku login</strong></pre>
<p>Type in your email address and password to log in.</p>
<div class="packt_tip">If you are on macOS and are using Keychain Access to generate and save the password, for some reason, the password generated upon sign up is not saved on Keychain. If this is the case, just log out from the Heroku dashboard, and, on the login form, click on <span class="packt_screen">F</span><span class="packt_screen">orgot Password</span>. You'll receive an email to change your password. On that page, you can use the password generation, and Keychain will remember it!</div>
<p>Once you have logged in, initialize Git with the following command:</p>
<pre><strong>git init</strong></pre>
<p>Then, you will need to add the Heroku reference to Git, as follows:</p>
<pre><strong>heroku git:remote -a shopping-fs</strong></pre>
<p>Replace <kbd>shopping-fs</kbd> with the application name that you picked previously.</p>
<p>You should see the following printed in your console:</p>
<pre><strong>set git remote heroku to https://git.heroku.com/shopping-fs.git</strong></pre>
<p>Let's add the file and commit it locally in Git, as follows:</p>
<pre><strong>git add . git commit -am 'Initial commit'</strong></pre>
<p>The final step is to deploy it with the following command:</p>
<pre><strong>git push heroku master</strong></pre>
<p>The deployment is executed on the Heroku server, and the log of the server is printed to your local console.</p>
<p>The process takes a little bit of time. Finally, you should see the following in the log:</p>
<pre><strong>..........</strong><br/><strong>remote: -----&gt; Launching... remote: Released v4 remote:https://shopping-fs.herokuapp.com/ deployed to Heroku remote:</strong></pre>
<p>That's it; your application has been compiled, packaged, and executed in the server.</p>
<p>Let's browse <a href="https://shopping-fs.herokuapp.com/">https://shopping-fs.herokuapp.com/</a> to confirm it. The following page should appear:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cef031e8-e566-4715-ac40-c19f2afbf963.png" style="width:40.58em;height:12.83em;"/></p>
<p>Congratulations! You have deployed your application on the internet. Notice that your application can be reached for free on a secure HTTP protocol, with valid certificates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Heroku configuration</h1>
                </header>
            
            <article>
                
<p>How does Heroku know how to execute the application?</p>
<p>Heroku knows how to execute the application by reading the instructions from a file named <kbd>Procfile</kbd>, located at the root of the project; the content is as follows:</p>
<pre>web: server/target/universal/stage/bin/server -Dhttp.port=$PORT -Dconfig.file=server/conf/heroku.conf</pre>
<p>The first indication in the line is the type of application. This can be anything. The <kbd>web</kbd> value is a special type, telling Heroku that this process only receives requests from HTTP.</p>
<p>The second part is the path to the executable. In fact, the SBT project creates this executable for us during the build process.</p>
<p>The last part is a list of properties for the Play application, namely</p>
<ul>
<li><kbd>-Dhttp.port</kbd>, which sets the port to listen to by using the Heroku variable, <kbd>$PORT</kbd></li>
<li><kbd>-Dconfig.file</kbd>, which set the configuration file path to be used by the application.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we tackled the persistence layer. We created a simple model based on two tables, Cart and Product. We <span>used an in-memory database named H2. </span>We configured a framework named Slick to asynchrony access data from H2 and added a script to create the table and insert data on it. We went through the mechanism used by Play Evolution to create the database.</p>
<p>Tests have been written to define the behaviors of the cart and the product objects. As the data queries are done asynchrony, we spent time understanding how to deal with <kbd>Future</kbd>. Finally, we deployed this layer in the cloud using a cloud application service named Heroku.</p>
<p>In the next chapter, we are going to define a RESTful API to expose the data persisted in this chapter.</p>


            </article>

            
        </section>
    </body></html>