<html><head></head><body>
		<div id="_idContainer114">
			<h1 id="_idParaDest-331"><em class="italic"><a id="_idTextAnchor330"/>Chapter 17</em>: Multitenancy in jOOQ</h1>
			<p>Sometimes, our applications need to operate in a multitenant environment, that is, in an environment that operates on multiple tenants (different databases, different tables, or generally speaking, different instances that are logically isolated, but physically integrated). In this chapter, we will cover some common use cases of integrating jOOQ in a multitenant environment based on the following agenda:</p>
			<ul>
				<li>Connecting to a separate database per role/login via the <strong class="source-inline">RenderMapping</strong> API</li>
				<li>Connecting to a separate database per role/login via a connection switch</li>
				<li>Generating code for two schemas of the same vendor</li>
				<li>Generating code for two schemas of different vendors</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor331"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter17">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter17</a>.</p>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor332"/>Connecting to a separate database per role/login via the RenderMapping API</h1>
			<p>Connecting to a separate database per role/login is a classical use case of multitenancy. Commonly, you <a id="_idIndexMarker1708"/>have a pillar database (let's call it the <strong class="source-inline">development</strong> database) and several other databases <a id="_idIndexMarker1709"/>with the same schema (let's call them the <strong class="source-inline">stage</strong> database and the <strong class="source-inline">test</strong> database). All three databases belong to the same vendor (here, MySQL) and have the same schema, but they hold data for different roles, accounts, organizations, partners, and so on of the application.</p>
			<p>For simplicity, the <strong class="source-inline">development</strong> database has a single table named <strong class="source-inline">product</strong>. This database is used for generating jOOQ artifacts, but we want to execute the queries depending on the current role (currently logged in user) against the <strong class="source-inline">stage</strong> or <strong class="source-inline">test</strong> databases.</p>
			<p>The key to such implementation relies on juggling with the jOOQ <strong class="source-inline">RenderMapping</strong> API. jOOQ allows us to specify at runtime an input schema (for instance, <strong class="source-inline">development</strong>) and an output schema (for instance, <strong class="source-inline">stage</strong>), and, in queries, it will render the <a id="_idIndexMarker1710"/>output <a id="_idIndexMarker1711"/>schema. The climax of the code relies on these settings, as you can see here (the authentication is specific to the Spring Security API):</p>
			<pre class="source-code">Authentication auth = SecurityContextHolder</pre>
			<pre class="source-code">  .getContext().getAuthentication();</pre>
			<pre class="source-code">String authority = auth.getAuthorities().iterator()</pre>
			<pre class="source-code">  .next().getAuthority();</pre>
			<pre class="source-code">String database = authority.substring(5).toLowerCase();</pre>
			<pre class="source-code">ctx.configuration().derive(new Settings()</pre>
			<pre class="source-code">    .withRenderMapping(new RenderMapping()</pre>
			<pre class="source-code">      .withSchemata(</pre>
			<pre class="source-code">        new MappedSchema().withInput("development")</pre>
			<pre class="source-code">                          .withOutput(database)))).dsl()</pre>
			<pre class="source-code">   .insertInto(PRODUCT, PRODUCT.PRODUCT_NAME, </pre>
			<pre class="source-code">               PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">   .values("Product", 100)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Depending on the role of the currently authenticated user, jOOQ renders the expected database name (for instance, <strong class="source-inline">`stage`.`product`</strong> or <strong class="source-inline">`test`.`product`</strong>). Basically, each user has a role (for instance, <strong class="source-inline">ROLE_STAGE</strong> or <strong class="source-inline">ROLE_TEST</strong>; for simplicity, a user has a single role), and we extract the output database name by removing <strong class="source-inline">ROLE_</strong> and lowercase the remaining text; by convention, the extracted text represents the name of the database as well. Of course, you can use the username, organization name, or whatever convention makes sense in your case. </p>
			<p>You can test this example in the application named <em class="italic">MT</em> for MySQL.</p>
			<p>The <strong class="source-inline">withInput()</strong> method takes the complete name of the input schema. If you want to match <a id="_idIndexMarker1712"/>the name <a id="_idIndexMarker1713"/>of the input schema against a regular expression, then instead of <strong class="source-inline">withInput()</strong>, use <strong class="source-inline">withInputExpression(Pattern.compile("reg_exp"))</strong> (for instance, <strong class="source-inline">("development_(.*)")</strong>).</p>
			<p>If you are in a database that supports catalogs (for instance, SQL Server), then simply use <strong class="source-inline">MappedCatalog()</strong> and <strong class="source-inline">withCatalogs()</strong>, as in the following example:</p>
			<pre class="source-code">String catalog = …;</pre>
			<pre class="source-code">Settings settings = new Settings()</pre>
			<pre class="source-code">    .withRenderMapping(new RenderMapping()</pre>
			<pre class="source-code">    .withCatalogs(new MappedCatalog()</pre>
			<pre class="source-code">    .withInput("development")</pre>
			<pre class="source-code">    .withOutput(catalog))</pre>
			<pre class="source-code">    .withSchemata(…); // optional, if you need schema as well</pre>
			<p>If you don't need a runtime schema and instead need to hardwire mappings at code generation time (jOOQ will always render at runtime, conforming to these settings), then, for Maven, use the following:</p>
			<pre class="source-code">&lt;database&gt;</pre>
			<pre class="source-code">  &lt;schemata&gt;</pre>
			<pre class="source-code">    &lt;schema&gt;</pre>
			<pre class="source-code">     &lt;inputSchema&gt;…&lt;/inputSchema&gt;</pre>
			<pre class="source-code">     &lt;outputSchema&gt;…&lt;/outputSchema&gt;</pre>
			<pre class="source-code">    &lt;/schema&gt;</pre>
			<pre class="source-code">  &lt;/schemata&gt;</pre>
			<pre class="source-code">&lt;/database&gt;</pre>
			<p>For Gradle, use the following:</p>
			<pre class="source-code">database {</pre>
			<pre class="source-code">  schemata {</pre>
			<pre class="source-code">    schema {</pre>
			<pre class="source-code">     inputSchema = '…'</pre>
			<pre class="source-code">     outputSchema = '…'</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Use <a id="_idIndexMarker1714"/>the following <a id="_idIndexMarker1715"/>for programmatic:</p>
			<pre class="source-code">new org.jooq.meta.jaxb.Configuration()</pre>
			<pre class="source-code">  .withGenerator(new Generator()</pre>
			<pre class="source-code">    .withDatabase(new Database()</pre>
			<pre class="source-code">      .withSchemata(</pre>
			<pre class="source-code">        new SchemaMappingType()</pre>
			<pre class="source-code">          .withInputSchema("...")</pre>
			<pre class="source-code">          .withOutputSchema("...")</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">  )</pre>
			<p>You can see such an example in <em class="italic">MTM</em> for MySQL. As you'll see, all accounts/roles act against the database that was hardwired at code generation time (the <strong class="source-inline">stage</strong> database).</p>
			<p>If you are using a database that supports catalogs (for instance, SQL Server), then simply rely on <strong class="source-inline">&lt;catalogs&gt;</strong>, <strong class="source-inline">&lt;catalog&gt;</strong>, <strong class="source-inline">&lt;inputCatalog&gt;</strong>, and <strong class="source-inline">&lt;outputCatalog&gt;</strong>. For Maven, use the following:</p>
			<pre class="source-code">&lt;database&gt;</pre>
			<pre class="source-code">  &lt;catalogs&gt;</pre>
			<pre class="source-code">    &lt;catalog&gt;          </pre>
			<pre class="source-code">     &lt;inputCatalog&gt;…&lt;/inputCatalog&gt;    </pre>
			<pre class="source-code">     &lt;outputCatalog&gt;…&lt;/outputCatalog&gt;</pre>
			<pre class="source-code">       </pre>
			<pre class="source-code">     &lt;!-- Optionally, if you need schema mapping --&gt;</pre>
			<pre class="source-code">     &lt;schemata&gt;</pre>
			<pre class="source-code">     &lt;/schemata&gt;</pre>
			<pre class="source-code">   &lt;/catalog&gt;</pre>
			<pre class="source-code"> &lt;/catalogs&gt;</pre>
			<pre class="source-code">&lt;/database&gt;</pre>
			<p>For Gradle, use <a id="_idIndexMarker1716"/>the <a id="_idIndexMarker1717"/>following:</p>
			<pre class="source-code">database {</pre>
			<pre class="source-code">  catalogs {</pre>
			<pre class="source-code">   catalog {</pre>
			<pre class="source-code">    inputCatalog = '…'</pre>
			<pre class="source-code">    outputCatalog = '…'</pre>
			<pre class="source-code">    // Optionally, if you need schema mapping</pre>
			<pre class="source-code">    schemata {}</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>For programmatic, use the following:</p>
			<pre class="source-code">new org.jooq.meta.jaxb.Configuration()</pre>
			<pre class="source-code">  .withGenerator(new Generator()</pre>
			<pre class="source-code">    .withDatabase(new Database()</pre>
			<pre class="source-code">      .withCatalogs(</pre>
			<pre class="source-code">        new CatalogMappingType()</pre>
			<pre class="source-code">          .withInputCatalog("...")</pre>
			<pre class="source-code">          .withOutputCatalog("...")</pre>
			<pre class="source-code">          // Optionally, if you need schema mapping</pre>
			<pre class="source-code">          .withSchemata()</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">  )</pre>
			<p>So far, the <strong class="source-inline">development</strong> database has a single table named <strong class="source-inline">product</strong>. This table has the same <a id="_idIndexMarker1718"/>name in the <strong class="source-inline">stage</strong> and <strong class="source-inline">test</strong> databases but let's assume that we decide to call it <strong class="source-inline">product_dev</strong> in <a id="_idIndexMarker1719"/>the <strong class="source-inline">development</strong> database, <strong class="source-inline">product_stage</strong> in the <strong class="source-inline">stage</strong> database, and <strong class="source-inline">product_test</strong> in the <strong class="source-inline">test</strong> database. In this case, even if jOOQ renders the database name per role correctly, it doesn't render the table's names correctly. Fortunately, jOOQ allows us to configure this aspect via <strong class="source-inline">withTables()</strong> and <strong class="source-inline">MappedTable()</strong>, as follows:</p>
			<pre class="source-code">ctx.configuration().derive(new Settings()</pre>
			<pre class="source-code">    .withRenderMapping(new RenderMapping()</pre>
			<pre class="source-code">      .withSchemata(</pre>
			<pre class="source-code">        new MappedSchema().withInput("development")</pre>
			<pre class="source-code">                          .withOutput(database)</pre>
			<pre class="source-code">      <strong class="bold">.withTables(</strong></pre>
			<pre class="source-code"><strong class="bold">        new MappedTable().withInput("product_dev")</strong></pre>
			<pre class="source-code"><strong class="bold">           .withOutput("product_" + database))))</strong>).dsl()</pre>
			<pre class="source-code">   .insertInto(PRODUCT_DEV, PRODUCT_DEV.PRODUCT_NAME,  </pre>
			<pre class="source-code">               PRODUCT_DEV.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">   .values("Product", 100)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>You can <a id="_idIndexMarker1720"/>check out this <a id="_idIndexMarker1721"/>example in the application named <em class="italic">MTT</em> for MySQL.</p>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor333"/>Connecting to a separate database per role/login via a connection switch</h1>
			<p>Another quick solution for connecting to a separate database per role/login consists of switching <a id="_idIndexMarker1722"/>to the proper <a id="_idIndexMarker1723"/>connection at runtime. In order to accomplish this task, we have to suppress the jOOQ default behavior of rendering the schema/catalog name. This way, we don't risk connecting to database <strong class="source-inline">A</strong> but get database <strong class="source-inline">B</strong> rendered in front of our tables, and so on. In other words, we need unqualified names.</p>
			<p>jOOQ allows us to turn off rendering the schema/catalog name via the <strong class="source-inline">withRenderSchema(false)</strong> and <strong class="source-inline">withRenderCatalog(false)</strong> settings. The following example connects to the database having the same name as the role of the logged in user and suppresses rendering the schema/catalog names:</p>
			<pre class="source-code">Authentication auth = SecurityContextHolder</pre>
			<pre class="source-code">     .getContext().getAuthentication();</pre>
			<pre class="source-code">if (auth != null &amp;&amp; auth.isAuthenticated()) {</pre>
			<pre class="source-code">   String authority = auth.getAuthorities()</pre>
			<pre class="source-code">     .iterator().next().getAuthority();</pre>
			<pre class="source-code">   String database = authority.substring(5).toLowerCase();</pre>
			<pre class="source-code">   DSL.using(</pre>
			<pre class="source-code">    "jdbc:mysql://localhost:3306/" + database, </pre>
			<pre class="source-code">        "root", "root")</pre>
			<pre class="source-code">      .configuration().derive(new Settings()</pre>
			<pre class="source-code">         .withRenderCatalog(Boolean.FALSE)</pre>
			<pre class="source-code">         .withRenderSchema(Boolean.FALSE))</pre>
			<pre class="source-code">         .dsl()</pre>
			<pre class="source-code">      .insertInto(PRODUCT, PRODUCT.PRODUCT_NAME, </pre>
			<pre class="source-code">           PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">      .values("Product", 100)</pre>
			<pre class="source-code">      .execute();</pre>
			<pre class="source-code">}</pre>
			<p>You can <a id="_idIndexMarker1724"/>check out <a id="_idIndexMarker1725"/>this example in the application named <em class="italic">MTC</em> for MySQL.</p>
			<p>Alternatively, we can instruct jOOQ to remove any schema references from the generated code via the <strong class="source-inline">outputSchemaToDefault</strong> flag. For Maven, use the following:</p>
			<pre class="source-code">&lt;outputSchemaToDefault&gt;true&lt;/outputSchemaToDefault&gt;</pre>
			<p>For Gradle, use the following:</p>
			<pre class="source-code">outputSchemaToDefault = true</pre>
			<p>Since there <a id="_idIndexMarker1726"/>are no more <a id="_idIndexMarker1727"/>schema references in the generated code, the generated classes can run on all your schemas:</p>
			<pre class="source-code">String database = …;</pre>
			<pre class="source-code">DSL.using(</pre>
			<pre class="source-code">  "jdbc:mysql://localhost:3306/" + database, </pre>
			<pre class="source-code">      "root", "root")  </pre>
			<pre class="source-code">  .insertInto(PRODUCT, PRODUCT.PRODUCT_NAME, </pre>
			<pre class="source-code">              PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">  .values("Product", 100)</pre>
			<pre class="source-code">  .execute();</pre>
			<p>You can test this example in the application named <em class="italic">MTCO</em> for MySQL.</p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor334"/>Generating code for two schemas of the same vendor</h1>
			<p>Consider two schemas of the same vendor named <strong class="source-inline">db1</strong> and <strong class="source-inline">db2</strong>. In the first schema (<strong class="source-inline">db1</strong>), we <a id="_idIndexMarker1728"/>have a table named <strong class="source-inline">productline</strong>, and in the second schema (<strong class="source-inline">db2</strong>), we have a table named <strong class="source-inline">product</strong>. Our goal is to generate the jOOQ artifacts (to run the jOOQ Code Generator) for these two schemas of the same vendor (here, MySQL) and to execute queries against one or another, and even join these two tables.</p>
			<p>Basically, as long as we don't specify any input schema, jOOQ generates code for all the schemas it can find. But since we want to instruct jOOQ to work only on the <strong class="source-inline">db1</strong> and <strong class="source-inline">db2</strong> schemas, we can do it as follows (here, for Maven):</p>
			<pre class="source-code">&lt;database&gt;</pre>
			<pre class="source-code"> &lt;schemata&gt;</pre>
			<pre class="source-code">   &lt;schema&gt;</pre>
			<pre class="source-code">    &lt;inputSchema&gt;db1&lt;/inputSchema&gt;</pre>
			<pre class="source-code">   &lt;/schema&gt;</pre>
			<pre class="source-code">   &lt;schema&gt;</pre>
			<pre class="source-code">    &lt;inputSchema&gt;db2&lt;/inputSchema&gt;</pre>
			<pre class="source-code">   &lt;/schema&gt;</pre>
			<pre class="source-code"> &lt;/schemata&gt;</pre>
			<pre class="source-code">&lt;/database&gt;</pre>
			<p>I am sure you have enough experience now to intuit how to write this for Gradle or programmatic, so I'll skip those examples.</p>
			<p>Once we run the jOOQ Code Generator, we are ready to execute queries, as follows:</p>
			<pre class="source-code">ctx.select().from(DB1.PRODUCTLINE).fetch();</pre>
			<pre class="source-code">ctx.select().from(DB2.PRODUCT).fetch();</pre>
			<p>Or, here is <a id="_idIndexMarker1729"/>a join between <strong class="source-inline">PRODUCTLINE</strong> and <strong class="source-inline">PRODUCT</strong>:</p>
			<pre class="source-code">ctx.select(DB1.PRODUCTLINE.PRODUCT_LINE,</pre>
			<pre class="source-code">   DB2.PRODUCT.PRODUCT_ID, DB2.PRODUCT.PRODUCT_NAME,   </pre>
			<pre class="source-code">   DB2.PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">   .from(DB1.PRODUCTLINE)</pre>
			<pre class="source-code">   .join(DB2.PRODUCT)</pre>
			<pre class="source-code">   .on(DB1.PRODUCTLINE.PRODUCT_LINE</pre>
			<pre class="source-code">     .eq(DB2.PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p><strong class="source-inline">DB1</strong> and <strong class="source-inline">DB2</strong> were <a id="_idIndexMarker1730"/>statically imported, as follows:</p>
			<pre class="source-code">import static jooq.generated.db1.Db1.DB1;</pre>
			<pre class="source-code">import static jooq.generated.db2.Db2.DB2;</pre>
			<p>The complete example is available in the application named <em class="italic">MTJ</em> for MySQL.</p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor335"/>Generating code for two schemas of different vendors</h1>
			<p>Consider two schemas of different vendors – for instance, our <strong class="source-inline">classicmodels</strong> schema <a id="_idIndexMarker1731"/>for MySQL and PostgreSQL. Our goal is to generate the jOOQ artifacts for both schemas and execute queries against one or another. </p>
			<p>Considering a Maven-based application, we can accomplish this task by using two <strong class="source-inline">&lt;execution&gt;</strong> entries, for the <strong class="source-inline">flyway-maven-plugin</strong> plugin and the <strong class="source-inline">jooq-codegen-maven</strong> plugin. Here is the skeleton code for <strong class="source-inline">jooq-codegen-maven</strong> (the complete code is available in the bundled code):</p>
			<pre class="source-code">&lt;plugin&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;org.jooq&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt; </pre>
			<pre class="source-code">  &lt;executions&gt;</pre>
			<pre class="source-code">    &lt;execution&gt;</pre>
			<pre class="source-code">      &lt;id&gt;generate-mysql&lt;/id&gt;</pre>
			<pre class="source-code">      &lt;phase&gt;generate-sources&lt;/phase&gt;</pre>
			<pre class="source-code">      &lt;goals&gt;</pre>
			<pre class="source-code">        &lt;goal&gt;generate&lt;/goal&gt;</pre>
			<pre class="source-code">      &lt;/goals&gt;                                  </pre>
			<pre class="source-code">      &lt;configuration xmlns="... jooq-codegen-3.16.0.xsd"&gt;     </pre>
			<pre class="source-code">        ... &lt;!-- MySQL schema configuration --&gt;</pre>
			<pre class="source-code">      &lt;/configuration&gt;</pre>
			<pre class="source-code">    &lt;/execution&gt;</pre>
			<pre class="source-code">    &lt;execution&gt;</pre>
			<pre class="source-code">      &lt;id&gt;generate-postgresql&lt;/id&gt;</pre>
			<pre class="source-code">      &lt;phase&gt;generate-sources&lt;/phase&gt;</pre>
			<pre class="source-code">      &lt;goals&gt;</pre>
			<pre class="source-code">        &lt;goal&gt;generate&lt;/goal&gt;</pre>
			<pre class="source-code">      &lt;/goals&gt;                    </pre>
			<pre class="source-code">      &lt;configuration xmlns="...jooq-codegen-3.16.0.xsd"&gt;   </pre>
			<pre class="source-code">        ... &lt;!-- PostgreSQL schema configuration --&gt;</pre>
			<pre class="source-code">      &lt;/configuration&gt;</pre>
			<pre class="source-code">    &lt;/execution&gt;</pre>
			<pre class="source-code">  &lt;/executions&gt; </pre>
			<pre class="source-code">&lt;/plugin&gt;</pre>
			<p>Next, jOOQ generates <a id="_idIndexMarker1732"/>artifacts for both vendors and we can switch between connections and tables, as follows:</p>
			<pre class="source-code">DSL.using(</pre>
			<pre class="source-code"> "jdbc:mysql://localhost:3306/classicmodels", </pre>
			<pre class="source-code">    "root", "root")</pre>
			<pre class="source-code">   .select().from(mysql.jooq.generated.tables.Product.PRODUCT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">DSL.using(</pre>
			<pre class="source-code"> "jdbc:postgresql://localhost:5432/classicmodels", </pre>
			<pre class="source-code">         "postgres", "root")</pre>
			<pre class="source-code">   .select().from(</pre>
			<pre class="source-code">           postgresql.jooq.generated.tables.Product.PRODUCT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Or, considering <a id="_idIndexMarker1733"/>that we have already programmatically configured our <strong class="source-inline">DataSource</strong> objects, we can configure two <strong class="source-inline">DSLContext</strong> as well (the complete code is available in the bundled code):</p>
			<pre class="source-code">@Bean(name="mysqlDSLContext")</pre>
			<pre class="source-code">public DSLContext mysqlDSLContext(@Qualifier("configMySql") </pre>
			<pre class="source-code">         DataSourceProperties properties) {</pre>
			<pre class="source-code">  return DSL.using(</pre>
			<pre class="source-code">    properties.getUrl(), properties.getUsername(), </pre>
			<pre class="source-code">    properties.getPassword());</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">@Bean(name="postgresqlDSLContext")</pre>
			<pre class="source-code">public DSLContext postgresqlDSLContext(</pre>
			<pre class="source-code">    @Qualifier("configPostgreSql") </pre>
			<pre class="source-code">       DataSourceProperties properties) {</pre>
			<pre class="source-code">  return DSL.using(</pre>
			<pre class="source-code">    properties.getUrl(), properties.getUsername(), </pre>
			<pre class="source-code">    properties.getPassword());</pre>
			<pre class="source-code">}</pre>
			<p>You can also inject these two <strong class="source-inline">DSLContext</strong> and use the one you want:</p>
			<pre class="source-code">private final DSLContext mysqlCtx;</pre>
			<pre class="source-code">private final DSLContext postgresqlCtx;</pre>
			<pre class="source-code">public ClassicModelsRepository(</pre>
			<pre class="source-code"> @Qualifier("mysqlDSLContext") DSLContext mysqlCtx, </pre>
			<pre class="source-code"> @Qualifier("postgresqlDSLContext") DSLContext postgresqlCtx){</pre>
			<pre class="source-code">     this.mysqlCtx = mysqlCtx;</pre>
			<pre class="source-code">     this.postgresqlCtx = postgresqlCtx;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">…</pre>
			<pre class="source-code">mysqlCtx.select().from(</pre>
			<pre class="source-code">  mysql.jooq.generated.tables.Product.PRODUCT).fetch();</pre>
			<pre class="source-code">     </pre>
			<pre class="source-code">postgresqlCtx.select().from(</pre>
			<pre class="source-code">  postgresql.jooq.generated.tables.Product.PRODUCT).fetch();</pre>
			<p>The complete <a id="_idIndexMarker1734"/>code is named <em class="italic">MT2DB</em>. If you want to generate the artifacts for only one vendor depending on the active profile, then you'll love the <em class="italic">MP</em> application.</p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor336"/>Summary</h1>
			<p>Multitenancy is not a regular task but it is good to know that jOOQ is quite versatile and allows us to configure multiple databases/schemas in seconds. Moreover, as you just saw, the jOOQ + Spring Boot combo is a perfect match for accomplishing multitenancy tasks. </p>
			<p>In the next chapter, we talk about jOOQ SPI.</p>
		</div>
	</body></html>