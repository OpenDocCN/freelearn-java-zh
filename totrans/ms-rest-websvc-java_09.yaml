- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Your RESTful API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the part of the book that talks about software security, within the
    larger field of cybersecurity, which is what you, as a software engineer, are
    most responsible for. This may seem a little different from what you have read
    so far because it’s not always seen as a core responsibility of a software engineer.
    That is a sad misconception. With the digitization of our society, software security
    is no longer just the domain of cybersecurity experts; it’s an integral part of
    software development and should be a major concern at all levels of development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding security can be complex, so let’s start with a mental image.
    Metaphors help simplify abstract concepts, and one of the most common metaphors
    in cybersecurity is the onion. If you’ve read about security before, you’ve likely
    encountered this idea: security is built in layers, just like an onion, with each
    layer adding a protective barrier.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: While useful, this metaphor has its flaws. It suggests that every layer is uniform
    when, in reality, cybersecurity defenses vary significantly. A more accurate comparison
    is a fortress under siege, where different layers of defense respond to different
    threats. Long-range artillery targets distant attackers, walls hold back intruders,
    and hand-to-hand combat is the last line of defense. Likewise, in security, each
    layer serves a distinct purpose, using different tools and techniques to protect
    against specific risks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: But what does this mean for you, the software engineer? Security isn’t just
    about protecting systems—it’s about safeguarding user data, ensuring reliability,
    and preventing costly breaches that can damage both a company’s reputation and
    its bottom line. Vulnerabilities in your code can be exploited to steal sensitive
    information, disrupt services, or even compromise entire networks. As software
    engineers, we are the first line of defense. Writing secure code, enforcing proper
    access controls, and understanding common attack vectors are not optional skills—they
    are essential responsibilities. In this chapter, we’ll explore the layers of security
    you are responsible for and how to integrate security into your development process
    effectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of an HTTP API call
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP API Security Top 10 overview
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Common Vulnerabilities and Exposures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies to manage CVEs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of an HTTP API call
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all API calls today are made over HTTP. So, let’s take a look at what
    happens during such a call and many of the components that participate in it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A typical secure API call over HTTP](img/B21843_07_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A typical secure API call over HTTP
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting the communication
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the protocol is called HTTP and we usually say it is an HTTP call or
    an HTTP connection, the fact is that all modern API calls are made over HTTPS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The “ *S* ” at the end stands for “ *secure* ,” indicating that the HTTP communication
    is encrypted using **Transport Layer Security** ( **TLS** ). TLS operates at the
    transport layer (Layer 4 in the OSI model), encrypting data between the client
    and server to prevent eavesdropping and tampering. Using TLS in an HTTP call ensures
    that only the intended receiver can read the message correctly, practically eliminating
    man-in-the-middle attacks because even if a message is intercepted, it cannot
    be decrypted and read.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTPS call will therefore enforce the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Data confidentiality** : All data transmitted over the network is encrypted
    and meaningless without the correct set of keys'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data integrity** : Ensures the data hasn’t been altered during transition'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server authentication** : Validates the server’s identity to the client'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three features of HTTPS (HTTP over TLS) communication are implemented using
    cryptographic algorithms to perform encryption and create digital signatures and
    secure digests (hashes) of the transferred data. How the cryptographic algorithms
    are used and how their inputs and outputs are transferred over the network are
    specified by the particular TLS protocol version used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Some of the algorithms and protocols used in the past are considered vulnerable
    given the current scientific knowledge and computing power available. The set
    of algorithms that are considered safe keeps evolving. There are already algorithms
    available today that are expected to stay safe when we reach the quantum computing
    era.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Always use strong cryptographic algorithms and protocols when implementing HTTPS
    for your APIs. Avoid deprecated protocols such as SSL and old versions of TLS.
    Encryption algorithms are constantly evolving, and old ones have become obsolete
    due to the ease with which they are broken. Create and enforce a policy to review
    your encryption selections frequently and update your TLS certificates. We will
    discuss this later.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In modern organizations (mid-size and up), it is unlikely that a software engineer
    will be responsible for any TLS implementations, but it is important to have a
    general idea of how HTTPS works and its implications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: An essential element used in HTTPS communication is the use of public key cryptography.
    The public part of the public-private key pair is part of a TLS certificate. TLS
    certificates have a life cycle from issue to expiry or invalidation. Hence, we
    need to manage these certificates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Managing your HTTPS certificates
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the consequences of using HTTPS/TLS encryption is the need for certificate
    management. Managing security certificates is a complex and crucial part of any
    API-based application. Effective certificate management involves handling renewals
    and expirations, and ensuring certificates are correctly configured to prevent
    service interruptions. Additionally, automated tools for certificate life cycle
    management can help streamline compliance, especially in environments with frequent
    communication between APIs or external services. This is such a significant problem
    that many groups have tried to create mechanisms to mitigate it. Let’s Encrypt
    ( [https://letsencrypt.org/](https://letsencrypt.org/) ) has achieved great success,
    having been used even in some large corporations. Most cloud providers also have
    some form of automatic certificate management, such as AWS Certificate Manager
    ( [https://aws.amazon.com/certificate-manager/](https://aws.amazon.com/certificate-manager/)
    ).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The first line of defense – Web Application Firewall (WAF)
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A WAF acts as a barrier between the client and your server, filtering out malicious
    traffic and offering a first layer of protection against common web exploits such
    as SQL injection and **Cross-Site Scripting** ( **XSS** ). This is not usually
    controlled by software engineers, but it is important to know about it as the
    WAF can cause some interference on HTTP traffic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the functions of a WAF:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic monitoring** : Inspects incoming requests for suspicious patterns'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule-based filtering** : Blocks traffic based on predefined security rules'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anomaly detection** : Identifies unusual behavior that may indicate an attack'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regularly updating WAF rules is essential to ensure that it can adapt to new
    and emerging threats. Additionally, it’s important to customize these rules to
    align with the specific needs and architecture of your application, ensuring optimal
    protection. Monitoring WAF logs consistently provides valuable security insights,
    helping to identify patterns, anomalies, or potential attacks, thereby enabling
    proactive defenses.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: API gateways
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An API gateway is usually the entry point for all client requests, handling
    tasks such as request routing, composition, and protocol translation. In terms
    of security, an API gateway frequently performs many important tasks:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**TLS termination** : Decrypts incoming HTTPS traffic'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication** : Validates credentials and permissions'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiting and throttling** : Controls the number of requests to prevent
    abuse'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An API gateway centralizes security policies, allowing consistent enforcement
    across all services. It simplifies client interactions with APIs by providing
    a single entry point that manages tasks such as routing and authentication. Additionally,
    it enhances performance by enabling caching and load balancing, ensuring efficient
    resource utilization and improved response times.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Load balancers
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Load balancers distribute incoming network traffic across multiple servers
    to ensure availability and reliability. While not directly involved in security
    logic, they contribute to overall security in the following ways:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器通过将进入的网络流量分配到多个服务器上来确保可用性和可靠性。虽然它们不直接参与安全逻辑，但以下方式有助于整体安全：
- en: '**Health monitoring** : Removing unhealthy servers from the pool.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康监控**：从池中移除不健康的服务器。'
- en: '**TLS termination** : Also handling TLS encryption to reduce server load and
    system complexity if an API gateway is not present.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLS终止**：如果API网关不存在，处理TLS加密以减少服务器负载和系统复杂性。'
- en: '**Mitigating Denial of Service (DoS)** : Distributing the load helps to mitigate
    DoS attacks. This is often the last resort in a DoS attack. It would be expected
    that the WAF and the API gateway would have minimized the impact of an attack
    at this point.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解拒绝服务（DoS）攻击**：通过分配负载有助于缓解DoS攻击。这通常是DoS攻击的最后一招。预计WAF和API网关会在这个阶段最大限度地减少攻击的影响。'
- en: When to decrypt the call – TLS termination
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解密通话的时机——TLS终止
- en: If a secure call is encrypted, it needs to be decrypted at some point so that
    its content can be interpreted and processed. That is called **TLS termination**
    . It refers to the process of decrypting an HTTPS connection and converting it
    back to a clear-text HTTP communication. This typically occurs at the network’s
    edge, such as within an API gateway, a load balancer, or a reverse proxy server.
    By terminating the TLS encryption at a single point, organizations can offload
    the computational overhead associated with encryption and decryption from backend
    servers. This process usually happens only once during the life cycle of an API
    call, ensuring that data remains encrypted while traversing insecure networks
    but can be processed more efficiently within trusted internal networks. TLS termination
    enhances performance and simplifies certificate management without compromising
    the security of data in transit over public channels. It is important to be aware
    of when the TLS termination happens, especially when troubleshooting some problems
    with an API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个安全通话被加密，它需要在某个时刻被解密，以便其内容可以被解释和处理。这被称为**TLS终止**。它指的是解密HTTPS连接并将其转换回明文HTTP通信的过程。这通常发生在网络的边缘，例如在API网关、负载均衡器或反向代理服务器内部。通过在单个点终止TLS加密，组织可以将与加密和解密相关的计算开销从后端服务器卸载。这个过程通常在API调用的生命周期中只发生一次，确保数据在穿越不安全网络时保持加密状态，但可以在受信任的内部网络中更有效地处理。TLS终止提高了性能，简化了证书管理，同时不会损害通过公共通道传输的数据的安全性。了解TLS终止发生的时间很重要，尤其是在调试API时遇到一些问题时。
- en: All the security elements that we have briefly discussed so far are undeniably
    very important, but in modern mid-size and larger organizations, they are usually
    not the direct responsibility of the software engineer. Other professionals oversee
    them, and therefore they are not the focus of this chapter. In contrast, the following
    security elements are very much the responsibility of the software engineer and
    we all should have a clear understanding of them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止简要讨论的所有安全元素无疑是至关重要的，但在现代中型和大型组织中，它们通常不是软件工程师的直接责任。其他专业人员负责它们，因此它们不是本章的重点。相比之下，以下安全元素在很大程度上是软件工程师的责任，我们都应该对它们有清晰的理解。
- en: As we have discussed, securing API communications is a multi-layered process
    involving various tools and technologies, each playing a distinct role in protecting
    data in transit. From the encryption provided by HTTPS and TLS to the filtering
    and monitoring capabilities of WAFs, every layer contributes to a robust defense
    against cyber threats. TLS termination and certificate management further underscore
    the importance of maintaining both performance and security in modern API ecosystems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的那样，确保API通信的安全性是一个多层次的流程，涉及各种工具和技术，每个层次都在保护传输中的数据方面发挥着独特的作用。从HTTPS和TLS提供的加密到WAF的过滤和监控能力，每一层都对抵御网络威胁的强大防御做出了贡献。TLS终止和证书管理进一步强调了在现代API生态系统中维护性能和安全的必要性。
- en: While these responsibilities are often overseen by dedicated teams in large
    organizations, it is essential for software engineers to understand how these
    components work and their implications. Having this foundational knowledge allows
    better collaboration with security teams and DevOps engineers to troubleshoot
    issues effectively when they arise and to make better decisions during design
    and development. With security threats constantly evolving, maintaining an awareness
    of these practices ensures APIs remain resilient and reliable, forming a secure
    backbone for any application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the foundational process of verifying the identity of a user,
    device, or other entity attempting to access your API. Authentication is a crucial
    element in security because it ensures that only legitimate and recognized parties
    can interact with your services. Without proper authentication mechanisms, APIs
    become vulnerable to unauthorized access, data breaches, and malicious activities
    that can compromise system integrity and user data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The primary goal of authentication is to establish the identity of the client
    requesting access. By confirming it, the API can enforce access controls, apply
    rate limiting, and provide personalized experiences where appropriate. Moreover,
    robust authentication mechanisms are essential for compliance with legal and regulatory
    requirements, such as the GDPR, HIPAA, LGPD, and other data protection laws.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Different authentication methods can be employed depending on the level of security
    required, the nature of the application, and user experience considerations. Next,
    we will break down some of the most common methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Password-based authentication
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Password-based authentication is the most traditional and is still one of the
    most widely used methods of authentication. Users provide a username and password,
    which are then verified against credentials stored on the server. By its nature,
    this method is mostly used when a person is authenticating with a system. It is
    hardly ever used in any form of machine-to-machine interaction.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the user attempts to log in, they send their credentials, typically a username
    and password, to a security service API. Upon receiving the credentials, the server
    hashes the password and compares it with the stored hash in its database. If the
    credentials match, the user is successfully authenticated, and the server generates
    an authentication token, such as a session cookie or a **JSON Web Token** ( **JWT**
    ), to facilitate future requests without the need for repeated credential submission.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Passwords should never be stored in plaintext; instead, they must always be
    hashed using a secure algorithm. The hashing process is only as good as the algorithm
    used. Two modern and widely used ones are *Bcrypt* and *Argon2* . A deeper discussion
    on hashing algorithms is not in the scope of this chapter, but it is highly recommended
    to look at how they work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is brute-force attacks. It’s important to implement account
    lockout mechanisms after a certain number of failed login attempts. Additionally,
    users should be required to create strong passwords by enforcing password policies
    that include minimum length requirements, the use of special characters, and the
    avoidance of common or easily guessable words.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the advantages of password-based authentication:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Simple to implement
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy for users to understand
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are the disadvantages:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Passwords can be easily stolen or guessed, especially if they are weak
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires robust security measures such as rate limiting and password resets
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password reuse across different services makes accounts more vulnerable
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token-based authentication
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Token-based authentication relies on the use of tokens—small pieces of data
    passed between the client and server to verify identity. A widely adopted token
    format is JWT, and this is the format we will discuss.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand how a JWT works, specifically the lifespan of
    a token.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: JWT life cycle and utilization
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The user logs in with their credentials, and the server generates a token (often
    a JWT) containing encoded information about the user.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will create and sign the JWT, ensuring its integrity, and send it
    back to the client. The internal mechanism of signing and creating a JWT is beyond
    the scope of this book. See this article for a more complete discussion: [https://www.freecodecamp.org/news/how-to-sign-and-validate-json-web-tokens/](https://www.freecodecamp.org/news/how-to-sign-and-validate-json-web-tokens/)
    .'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: From that moment on, the client will include the JWT in the header of all future
    API requests, typically in a pre-defined header defined by the API development
    team.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The server validates the token on each request without needing to check the
    user credentials again.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: One important point to understand is that all tokens (JWT or not) must be temporary.
    They must expire at clear and well-defined intervals. As a software engineer working
    on the API layer, you usually don’t have to do anything special to handle this,
    but frontend applications will have to define a token renewal strategy, and you
    may have to collaborate and support such tasks.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Structure of a JWT
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JWT is an encrypted record that follows a well-defined structure. So, let’s
    look inside a JWT and discuss its structure.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A good tool for viewing and manipulating JWTs can be found at [https://jwt.io/#debugger-io](https://jwt.io/#debugger-io)
    .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Example JWT](img/B21843_07_2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Example JWT
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT consists of three distinct parts separated by a dot: the header, payload,
    and signature. As an API developer, your focus will be on the payload, as it contains
    claims (fields) about the user (e.g., user ID, permissions). The signature ensures
    the token hasn’t been tampered with.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Once decrypted, the data inside a JWT looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Field** | **Description** | **Example Value** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| Header | `alg` | Algorithm used to sign or encrypt the token | `"HS256"`
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| Header | `typ` | Type of token | `"JWT"` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| Header | `cty` | Content type of the JWT payload | `"JWT"` or `"application/json"`
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| Header | `kid` | Key ID used to identify the key used in signature | `"abc123"`
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| Payload | `iss` | Issuer of the token | `"auth.example.com"` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| Payload | `sub` | Subject of the token (usually a user ID) | `"1234567890"`
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| Payload | `aud` | Audience for which the token is intended | `"example.com"`
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| Payload | `exp` | Expiration time (in Unix time) | `1516239022` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| Payload | `nbf` | Not valid before this time (in Unix time) | `1516239022`
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| Payload | `iat` | Issued at time (in Unix time) | `1516239022` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| Payload | `jti` | JWT ID; a unique identifier for the token | `"unique-token-id-123"`
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| Payload | `name` | User’s full name | `"John Doe"` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| Payload | `email` | User’s email address | `"john.doe@example.com"` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| Payload | `role` | Roles or permissions assigned to the user | `"admin"`
    or `["admin", "user"]` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| Signature | N/A | Digital signature for verifying the token’s integrity |
    (Result of cryptographic operation) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – An example JWT
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The header can be customized to adjust to the needs of each organization. But
    at a minimum, you should see `"alg"` and `"typ"` entries present.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The payload is also mostly defined by the organization. Each entry in the payload
    is called a **claim** and is used to identify the users, their roles, unique information,
    and any other data element that can be used by the APIs to best control access
    to the data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Special attention should be given to the three time-based claims – `exp` , `nbf`
    , and `iat` . They are crucial to verify whether the JWT is valid at the time
    of execution of the API. Ideally, they should not be omitted, although `"nbf"`
    is sometimes not defined. In that case, it is assumed that the JWT is valid from
    the moment it is created ( `"iat"` ).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are three classifications for claims:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**Registered claims** : Predefined claims widely used in the industry, such
    as `iss` , `exp` , and `sub`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public claims** : Custom claims agreed upon by parties using the JWT'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private claims** : Custom claims used in contexts specific to your application'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statelessness
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the key benefits of token-based authentication is that the server doesn’t
    need to store session state validation information. All necessary information
    is contained in the token itself and is sent over in each call.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, it is necessary to store session state on the server side, but no
    credentials or user identification should be stored, only references to the tokens
    used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JWTs are part of a general security strategy, and as such should be treated
    as data to be secured in themselves. Therefore, here are some specific security
    concerns about the JWTs:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Always use HTTPS to transmit tokens, as tokens are susceptible to interception
    in plaintext
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set token expiration times to limit the window of vulnerability
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use short-lived tokens with refresh tokens to minimize the risk of token theft
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely store tokens on the client side, avoiding local storage if possible
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the advantages of a JWT strategy:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Stateless authentication scales well in distributed systems
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no need to store session information on the server
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows granular control over access rights using token claims
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And these are some disadvantages:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Tokens, if stolen, can be used to impersonate the user
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing token expiration and secure refresh cycles will add complexity to the
    application, both the frontend and the backend
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caveats
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One problem that sometimes happens is JWT inflation, where the organization
    keeps adding more claims or long lists of values to claims to the point that the
    JWT grows beyond the limits defined on the server. Even if the JWT specs do not
    define an upper limit, remember that the token will be sent over as part of the
    HTTP header, and there is always a limit for them. If you start receiving **HTTP
    413 Content Too Large** errors, one possible culprit could be the size of your
    JWT.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In summary, using JWTs to manage authentication and authorization is a well-established
    strategy that has good industry support and relies upon solid technologies. However,
    a large portion of its effectiveness is due to how it is used by the application.
    It is your responsibility as the software engineer to make sure good and well-managed
    policies are put in place.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Multi-factor authentication
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Multi-factor authentication** ( **MFA** ) adds an additional layer of security
    by requiring the user to provide more than one form of identification. This typically
    includes something they know (e.g., password), something they have (e.g., mobile
    phone or security token), or something they are (e.g., fingerprint or face recognition).
    This is mostly a client-side strategy and has little effect on API development,
    but it is important for backend engineers to understand its general concepts.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: MFA is part of the authentication dialog, so, after a user has successfully
    entered their password, they are prompted to provide a second factor, such as
    a code generated by a mobile app (e.g., Google Authenticator) or sent via SMS.
    The server then verifies the second factor before granting access, usually by
    generating a JWT to be used by the client when accessing the APIs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: What can be used in MFA?
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generally speaking, there are three types of MFA:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**Something you know** : A password, PIN, or answer to a security question'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Something you have** : A physical device such as a phone or hardware token
    that generates a temporary passcode'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Something you are** : Biometric data such as a fingerprint, facial recognition,
    or iris scan'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security considerations
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s see what we should consider with regard to security when using MFA:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: MFA drastically reduces the likelihood of account compromise, even if a password
    is stolen.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time-based one-time passwords** ( **TOTPs** ) are commonly used for MFA.
    Ensure that those tokens are properly time-synchronized and expire after a short
    period.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS-based MFA is vulnerable to SIM swapping and should be avoided where possible.
    Use app-based authenticators or hardware tokens instead.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at the advantages of MFA:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: It significantly enhances security by requiring multiple forms of verification
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It protects against common attacks such as password phishing and brute-force
    attacks
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And let’s see some of the disadvantages:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: It can be cumbersome for users, especially in environments with frequent logins
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires infrastructure to support the second factor, such as maintaining
    SMS gateways or integrating with an authenticator app
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Biometric authentication
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Biometric authentication uses physical characteristics like fingerprints, facial
    recognition, or voice to verify a user’s identity. With the increasing availability
    of biometric sensors on mobile devices and laptops, it’s becoming a more common
    method of authentication.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how it works:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The user’s biometric data (fingerprint, face scan, etc.) is captured and stored
    securely on the device.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user attempts to authenticate, the API compares the captured data with
    the stored biometric template to verify their identity.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are some common biometric authentication methods:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**Fingerprint scanning** : Used extensively on mobile devices'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facial recognition** : Built into many smartphones and laptops'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Voice recognition** : Sometimes used for telephonic authentication'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see some of the security considerations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Biometric data is unique to each user, making it difficult to forge
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store biometric data locally, not on the server, to prevent mass breaches
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure biometric systems have fallback options (such as passwords) for cases
    where biometrics fail (e.g., injury or hardware malfunction)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some advantages of biometric authentication:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: It provides a high level of security
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is convenient for users—there’s no need to remember passwords
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of the disadvantages:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Biometric data is irreversible—once compromised, it cannot be changed
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are potential privacy concerns around the collection and storage of biometric
    data
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is less reliable in certain conditions (e.g., wet fingerprints or poor lighting
    for facial recognition)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right authentication method depends on the application’s requirements
    and the sensitivity of the data it handles. While password-based authentication
    remains prevalent, more secure methods, such as token-based authentication, MFA,
    and biometric authentication, are rapidly gaining ground. Combining these methods,
    such as using MFA in conjunction with JWTs, can provide a robust and flexible
    authentication mechanism for APIs, ensuring the security of both users and data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have your API guarded against unknown users by authentication, the
    next step is to apply authorization mechanisms. This is where the system determines
    whether an authenticated entity (user, device, or service) has permission to access
    a specific resource or perform a particular action. While authentication verifies
    identity, authorization governs access, ensuring that the authenticated entity
    only has access to the resources and operations for which they have been granted
    permission.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In API security, proper authorization is essential for enforcing business rules,
    safeguarding sensitive data, and ensuring that each user or service only performs
    the actions and accesses the information they are allowed to. So, let’s look at
    the different techniques we can use to implement authorization.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common authorization mechanisms is **role-based access control**
    ( **RBAC** ). RBAC works by assigning predefined roles to users or entities and
    associating permissions with those roles. Each role is granted access to specific
    API endpoints or functionalities, depending on the application’s security requirements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how RBAC works:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Users are assigned one or more roles, such as admin, user, or editor.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API endpoints or resources are protected by role checks. For example, only users
    with the admin role might have access to the /admin endpoints.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an API request is made, the server checks the user’s assigned roles against
    the roles required for the requested resource.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some of the advantages of RBAC:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: It simplifies permission management by grouping permissions into roles
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to implement and scale, particularly in enterprise applications where
    roles can be defined centrally
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is fully supported by many solutions, such as the claims in JWT
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of the disadvantages:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: It can be inflexible in complex systems where fine-grained access control is
    required, leading to role explosion or data leaks
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can cause unexpected exposure in complex systems, as roles may be inconsistent
    or incompatible with each other
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute-based access control
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Attribute-based access control** ( **ABAC** ) provides more granular control
    than RBAC by using attributes (user attributes, environment attributes, resource
    attributes, etc.) to determine access rights. Attributes are metadata that describe
    entities or actions and are evaluated against policies to decide whether access
    is allowed.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how ABAC works:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Policies are written to define the conditions under which access is granted.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes such as user role, time of request, resource type, or location are
    considered.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access decisions are made dynamically, based on real-time evaluation of attributes
    and policies.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some of the advantages of using ABAC:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: It provides flexibility by allowing fine-grained control based on dynamic conditions
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is scalable for complex systems in which RBAC would become difficult to manage
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are some disadvantages:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: It is more complex to implement and manage than RBAC.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can result in performance overhead due to real-time policy evaluations.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can cause unexpected security issues due to mismanaged attributes. For example,
    an employee changes positions in the company but the system still allows them
    to see data from the previous job.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OAuth 2.0 is one of the most widely used authorization frameworks for APIs.
    It allows a user to grant a third-party application limited access to their resources
    without exposing their credentials. OAuth 2.0 is commonly used for delegating
    access to APIs and provides a standardized method for authorization across web,
    mobile, and cloud applications.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how OAuth 2.0 works:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The user authenticates with an identity provider (e.g., Google, Facebook) and
    grants permission to a third-party application.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third-party application receives an access token, which it uses to make
    authorized API requests on behalf of the user.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The access token contains scopes, which define the level of access the third-party
    application has (e.g., read-only, write).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see some security considerations:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Always use HTTPS to transmit OAuth tokens
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use short-lived access tokens and refresh tokens to minimize risk in case of
    token theft
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement token revocation mechanisms to invalidate tokens if necessary
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the advantages of using Oauth2.0:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: It allows delegated access without sharing user credentials
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has been widely adopted, providing standardization across many services
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are some disadvantages:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: It requires the implementation of secure token storage and transmission mechanisms
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can add complexity, especially when managing refresh tokens and token expiration
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JWT for authorization
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JWTs, which were discussed in the *Authentication* section, also play a key
    role in authorization. After authentication, a JWT can be issued containing claims
    that specify the user’s roles or permissions. These claims can then be used by
    the API to enforce access controls.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how JWT authorization works:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The user is authenticated, and a JWT is issued containing claims such as user
    roles or permissions.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client includes the JWT in the authorization header in future API requests.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server decodes the JWT and checks the claims to determine whether the user
    is authorized to access the requested resource.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JWTs allow stateless authorization, meaning the server doesn’t need to maintain
    session state because the necessary authorization information is embedded in the
    token itself.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some of the advantages of using JWT authorization:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: It scales well in distributed systems by eliminating the need for server-side
    session storage
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables fine-grained control using claims inside the JWT
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As for disadvantages, it requires careful management of token expiration and
    revocation to prevent unauthorized access. This is the biggest drawback of JWT
    and any other attribute-based authorization. It is important to ensure the claims
    in the JWT reflect the actual roles of this user. Once again, the case of an employee
    changing positions in the company comes to mind, potentially causing data access
    violations.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Fine-grained access control
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some systems, the level of access control required goes beyond the basic
    capabilities of RBAC or even ABAC. **Fine-grained access control** ( **FGAC**
    ) allows more nuanced control over access to resources, based on attributes such
    as user identity, resource ownership, and contextual data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: These levels of FGAC are usually found in complex business domains; healthcare
    and finance are two very common cases. Healthcare, being a highly regulated industry,
    has many different rules that need to be applied to any data access.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of FGAC:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: A user can access only their own profile data, not other users’ data
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service can only modify resources that it has created
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to sensitive resources might be restricted based on location, time of
    day, or other contextual information
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A customer on a healthcare insurance system can see all payments made to their
    account but can only see claims payments for their claims and other dependents
    that they are legally allowed to
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a closer look at that last example, as it illustrates the challenges
    of FGAC.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '*Case* : A client is required to keep their ex-spouse on their healthcare policy
    for a specified time. During this time, the main client cannot see any of the
    spouse’s medical information, but can see the costs associated with their treatment.
    There are several challenges in this case. Where do we look for the mandatory
    amount of time to keep the spouse on the policy? How do we isolate the spouse’s
    data in a family request? How do we allow some financial data to be exposed but
    not medical information?'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Those are not simple questions to answer and may make that piece of the system
    more complex than it would be otherwise.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This case requires careful design and policy enforcement. It could increase
    the complexity of the application, particularly in large systems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for API authorization
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In summary, here are some guidelines to make sure your API is as secure as
    you can make it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '**Use the principle of least privilege** : Only grant users and services the
    minimal permissions necessary to perform their tasks'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement layered authorization mechanisms** : Combine RBAC with ABAC or
    OAuth for more flexible and secure access control'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regularly audit permissions** : Periodically review and update roles, permissions,
    and access policies to ensure they align with current business needs'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure tokens** : Always use secure storage and transmission methods for
    tokens (e.g., OAuth tokens, JWTs) to prevent unauthorized access'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization, when designed and implemented effectively, ensures that your
    API remains secure, responsive, and compliant with regulatory requirements. By
    choosing the right authorization strategy—whether RBAC, ABAC, OAuth, or JWT-based—you
    can tailor access control to your system’s specific needs while protecting data
    and ensuring users can only perform the actions they are entitled to.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: OWASP API Security Top 10 overview
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OWASP** stands for **Open Web Application Security Project** , a non-profit
    organization that focuses on web application security. They do a phenomenal job
    at documenting known security issues and helping developers and organizations
    to secure web applications. One of the main contributions is the **OWASP API Security
    Top 10** , which identifies the most critical security risks for APIs.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: OWASP is a crucial resource for all software engineers, and you should periodically
    look at the published lists of concerns and new security white papers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'The most recent list was published in 2023 and can be found here: [https://owasp.org/API-Security/editions/2023/en/0x11-t10/](https://owasp.org/API-Security/editions/2023/en/0x11-t10/)
    .'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: API1:2023 - Broken Object Level Authorization
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API2:2023 - Broken Authentication
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API3:2023 - Broken Object Property Level Authorization
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API4:2023 - Unrestricted Resource Consumption
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API5:2023 - Broken Function Level Authorization
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API6:2023 - Unrestricted Access to Sensitive Business Flows
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API7:2023 - Server Side Request Forgery
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API8:2023 - Security Misconfiguration
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API9:2023 - Improper Inventory Management
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API10:2023 - Unsafe Consumption of APIs
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, all the top OWASP concerns are the topics we have been discussing
    in this chapter so far. It is important to be well acquainted with the OWASP list
    as it evolves, so visit frequently the OWASP Top Ten API Security Risks at the
    link provided previously.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Common Vulnerabilities and Exposures
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The phrase “our society runs on software” is not new and describes most modern
    societies, and consequently, software security has emerged as a core concern for
    governments and organizations worldwide. Cyber threats are evolving at an unprecedented
    pace, and vulnerabilities in software can lead to significant financial losses,
    reputational damage, and legal repercussions. In the same week as this chapter
    was written, the largest DDoS attack in history targeted Cloudflare (you can find
    a detailed discussion here: [https://www.linkedin.com/pulse/cloudflare-mitigates-historic-world-record-56-tbps-hoccc/](https://www.linkedin.com/pulse/cloudflare-mitigates-historic-world-record-56-tbps-hoccc/)
    ). It is suspected that the scale of this attack was achieved by exploiting vulnerabilities
    in many IoT devices, but the details are still being discovered. Therefore, for
    Java software engineers, understanding and managing these vulnerabilities is fundamental
    for developing secure and robust applications.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: One of the fundamental aspects of software security is the identification and
    mitigation of known vulnerabilities, commonly referred to as **Common Vulnerabilities
    and Exposures** ( **CVEs** ). This chapter aims to provide an in-depth exploration
    of CVEs from the perspective of a professional Java software engineer. We will
    delve into the definition of CVEs, the mechanisms used to discover and document
    them, and their structural composition. Additionally, we will highlight the best
    resources for tracking CVEs and discuss software scanners that help identify these
    vulnerabilities.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will examine effective strategies for managing CVEs, including
    continuous dependency upgrades, dependency management practices, proactive dependency
    updates, and reactive upgrades based on scan reports. By understanding and implementing
    these strategies, software engineers can enhance the security posture of their
    applications and contribute to a safer digital ecosystem.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: What are CVEs?
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CVE system is a standardized method for identifying and cataloging security
    vulnerabilities and exposures in software and firmware. Managed by the MITRE Corporation,
    CVE provides a unique identifier for each disclosed vulnerability, allowing consistent
    references across various security tools, databases, and communications. A CVE
    entry typically includes an identification number, a brief description of the
    vulnerability, and references to related advisories, reports, and patches.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'For Java software engineers, CVEs are particularly significant due to the widespread
    use of Java libraries and frameworks, which can introduce vulnerabilities into
    applications if not properly managed. Understanding CVEs enables developers to
    do the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify vulnerabilities** : Recognize known security issues in the libraries
    and components they use'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assess impact** : Evaluate the potential impact of a vulnerability on their
    applications'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement mitigations** : Apply patches or updates to address vulnerabilities
    promptly'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintain compliance** : Adhere to security policies and regulatory requirements
    by managing known vulnerabilities'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are CVEs found and documented?
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The discovery of vulnerabilities is a collaborative effort involving security
    researchers, developers, and automated tools. The following are common mechanisms
    for finding vulnerabilities:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '**Security research** : Security professionals and researchers actively analyze
    software to identify potential vulnerabilities. This process may involve the following:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code auditing** : Manually reviewing source code for insecure coding practices'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Penetration testing** : Simulating attacks to find weaknesses in running
    applications'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuzz testing** : Providing invalid or random data to programs to trigger
    unexpected behavior'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bug bounty programs** : Many organizations offer bug bounty programs, incentivizing
    independent researchers to find and report vulnerabilities. These programs help
    uncover issues that might be missed by internal teams.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated scanning tools** : Tools such as static code analyzers and **dynamic
    application security testing** ( **DAST** ) tools automatically scan code bases
    and running applications for known vulnerability patterns.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User and developer reports** : End-users and developers may encounter security
    issues during regular use or development activities and report them to the maintainers
    or security teams.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation process
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once a vulnerability is discovered, documenting it involves several steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability disclosure** : The finder reports the vulnerability to the
    software vendor or maintainers, following responsible disclosure practices to
    allow time for a fix before public disclosure.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CVE assignment** : An authorized **CVE Numbering Authority** ( **CNA** )
    assigns a unique CVE identifier to the vulnerability. This identifier allows consistent
    tracking and reference.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description and analysis** : A detailed description of the vulnerability
    is created, including the following:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summary** : A brief overview of the issue'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical details** : In-depth information about the vulnerability, including
    affected versions and components'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impact assessment** : The potential risks and consequences if the vulnerability
    is exploited'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publishing** : The CVE entry is published in the CVE database and shared
    with various security databases such as the **National Vulnerability Database**
    ( **NVD** ). Vendors may also release security advisories and patches.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure of a CVE
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A CVE entry consists of several key components that provide essential information
    about the vulnerability:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**CVE identifier** : A unique identifier in the format CVE-YYYY-NNNN, where
    YYYY is the year the CVE ID was assigned or made public and NNNN is a sequential
    number, for example, CVE-2023-12345.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description** : A concise summary of the vulnerability, including the following:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type of vulnerability** : Such as buffer overflow or injection flaw'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Affected products** : Specific software, versions, and components impacted'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impact** : The potential effects of exploitation, such as unauthorized access
    or denial of service'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**References** : Links to additional information, including the following:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor advisories** : Official statements or patches from the software vendor'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Bulletins** : Reports from security organizations'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical Analysis** : In-depth articles or reports analyzing the vulnerability'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, when imported into the NVD, additional metadata is added (if available):'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CVSS scores** : The **Common Vulnerability Scoring System** ( **CVSS** )
    provides a quantitative measure of the severity of the vulnerability.'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impact metrics** : Details about confidentiality, integrity, and availability
    impacts.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Affected configurations** : Specific environments or configurations that
    are vulnerable.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to understand that documenting a CVE is a process, and a CVE that affects
    your code may have been identified, but no current solution is yet available.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Best resources to track CVEs
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Staying informed about the latest vulnerabilities is essential for proactive
    security management. The following are some of the best resources for tracking
    CVEs. You should bookmark each of them and become familiar with their structure
    and searching capabilities:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: NVD
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Managed by the **National Institute of Standards and Technology** ( **NIST**
    ), the NVD provides comprehensive information about CVEs, including detailed analyses,
    CVSS scores, and impact metrics. It is the main resource for CVEs:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[https://nvd.nist.gov/](https://nvd.nist.gov/ )'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: MITRE CVE list
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'The official CVE list is maintained by MITRE. It provides basic information
    about each CVE, including descriptions and references. Frequently, the information
    here is easier to navigate than the NVD:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cve.mitre.org/](https://cve.mitre.org/ )'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Security advisories from vendors
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Software vendors often publish their own security advisories and patches. Monitoring
    these sources ensures you receive vendor-specific information promptly. There
    are many such resources, but for a Java software engineer, Oracle and Apache are
    two of the most important:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**Oracle Java SE Critical Patch Updates** : [https://www.oracle.com/security-alerts/](https://www.oracle.com/security-alerts/
    )'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Security** : [https://apache.org/security/](https://apache.org/security/
    )'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VulDB** : [https://vuldb.com/](https://vuldb.com/ )'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These databases aggregate vulnerability information from various sources and
    often provide additional context and analysis. Not all current vulnerabilities
    may be available there yet.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Software scanners that help to identify CVEs
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Software scanners are tools that have been designed to automatically detect
    vulnerabilities within code bases, applications, or systems. For Java developers,
    these tools are invaluable in identifying CVEs associated with dependencies and
    code. They work in a few different forms and, depending on the project, you may
    have to use more than one to cover your code.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '**Static Application Security Testing (SAST) tools** : These tools analyze
    source code for security vulnerabilities without executing the code. Examples
    are SonarQube and Checkmarx'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software Composition Analysis (SCA)** : These tools identify open source
    components and dependencies in your application and check for known vulnerabilities.
    Examples include OWASP Dependency-Check, Snyk, Black Duck, and WhiteSource.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Application Security Testing (DAST)** : These tools analyze running
    applications to detect vulnerabilities by simulating attacks. Examples include
    OWASP ZAP and Burp Suite.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How these tools work
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: As CVEs are security problems with external dependencies, how can the scanners
    look at your code and find the issues?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: First, the scanner analyzes project files, such as `pom.xml` for Maven and `build.gradle`
    for Gradle, to identify all direct and transitive dependencies. It then extracts
    the version numbers of each dependency and compares them against a vulnerability
    database containing CVE information. Based on this comparison, the scanner generates
    a detailed report highlighting any vulnerable dependencies, classifying them by
    severity levels according to CVSS scores. Additionally, it provides upgrade recommendations,
    suggesting versions that resolve the identified vulnerabilities.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to integrate the dependency scanners into the development workflow.
    Some scanners provide plugins for **Integrated Development Environments** ( **IDEs**
    ) such as Eclipse and IntelliJ IDEA, allowing developers to detect vulnerabilities
    directly within their coding environment. Additionally, scanners can be incorporated
    into **Continuous Integration/Continuous Deployment** ( **CI/CD** ) pipelines,
    automating vulnerability detection during the build process. To enhance security
    monitoring, they can also be configured to send automated alerts whenever new
    vulnerabilities are identified. By identifying and addressing security issues
    early in the development cycle, these integrations enhance agility and help shorten
    the **Software Development Life Cycle** ( **SDLC** ), reducing delays caused by
    late-stage security fixes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Popular scanners for Java
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always a little dangerous to publish lists of software tools in a printed
    format as some projects may disappear or become obsolete over time, but as of
    April 2025, these are the most widely used tools for identifying vulnerabilities
    in Java projects:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**OWASP Dependency-Check** : This open-source tool identifies a project’s dependencies
    and checks whether there are any known, publicly disclosed vulnerabilities (CVEs)
    associated with the scanned dependencies. It supports projects that use Maven,
    Gradle, and Ant and can be integrated into most build tools and CI/CD solutions.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snyk** : This is a commercial tool that provides vulnerability scanning and
    remediation for open source dependencies. It provides real-time scanning, allowing
    the continuous monitoring of dependencies. It also proposes code fixes automatically
    with suggestions directly in pull requests. Plugins are available for most popular
    IDEs (such as IntelliJ and VS Code).'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Black Duck** : This is a comprehensive SCA tool that scans for open source
    vulnerabilities and license compliance. It enforces policies regarding the use
    of open source components in the system and generates in-depth analysis of vulnerabilities
    and risks.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies to manage CVEs
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All these tools are very important and are a crucial part of managing the CVEs
    in your project. But how can we manage this workload, and what considerations
    are needed?
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The effective management of CVEs involves not just detection but also strategic
    planning and processes to mitigate risks.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: One important point to understand is that writing secure software is expensive,
    and managing CVEs in particular has become a hard and expensive part of software
    security. It is not uncommon for teams to allocate 15% to 20% of their capacity
    to security.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let’s look at a couple of strategies that help Java developers
    maintain secure applications.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Continuous upgrade dependencies
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regularly updating dependencies to their latest versions ensures that applications
    benefit from security patches and improvements made by library maintainers.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: This is a proactive approach to CVEs. By always keeping your dependencies up
    to date, you guarantee that any security update will be implemented and used in
    your code as soon as it is available.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various ways to implement continuous upgrades:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated updates** : Use tools such as Dependabot to automatically create
    pull requests for dependency updates'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular maintenance schedule** : Establish a routine (e.g., weekly or monthly)
    to review and update dependencies'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing** : Implement comprehensive automated tests to ensure that updates
    do not introduce regressions'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring release notes** : Keep track of dependency release notes for any
    security-related updates'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the benefits of continuous upgrades:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Security** : It reduces the window of exposure to known vulnerabilities'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature enhancements** : It provides access to new features and performance
    improvements'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community support** : It aligns with the active versions supported by the
    community'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Costs and requirements
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main cost with this approach is the time that must be invested in keeping
    the code base current. Remember, you will be changing dependencies in your code,
    and the API you are calling may have changed, sometimes in ways that are not immediately
    obvious, forcing you and your team to refactor portions of your code that would
    not need any change otherwise.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: To be able to make so many potential breaking changes so frequently, it is necessary
    to have a comprehensive set of automated tests that can give the developer team
    the confidence to make those changes in the first place.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The time to add the tools and integrate them with the specific ticketing system
    used in your organization is another cost that needs to be considered. The initial
    investment can be quite large for legacy code bases with not enough test coverage
    and automated build pipelines.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know that CVEs are caused by the dependencies we as software engineers
    add to the code base, what can we do to limit our exposure to them?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, a proper policy for the management of dependencies is crucial to control
    the quality, security, and performance of your application. The goal here is to
    prevent exposure to CVEs as much as possible.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, software engineers add dependencies to projects without analyzing
    the consequences. To be honest, this happens more often than we’d like to admit!
    Having a policy in place that will require validation of the need for this new
    dependency and a discussion about more secure and better-maintained alternatives
    can significantly help with security vulnerabilities. To avoid introducing unnecessary
    risks, it is important to follow these best practices when adding and managing
    dependencies:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimal dependencies** : Include only necessary dependencies to reduce the
    attack surface. The introduction of new dependencies must be discussed with the
    team and its implications must be identified.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version pinning** : Specify exact versions of dependencies to ensure consistent
    builds. Avoid having dependencies on the “latest” version.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use trusted sources** : Retrieve dependencies from reputable repositories
    (e.g., Maven Central). Choose packages and libraries that are actively maintained
    and have a good history of security updates.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitive dependency control** : Monitor and manage transitive dependencies
    brought in by direct dependencies.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**License compliance** : Ensure that the licenses of dependencies are compatible
    with your project.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Proactive dependency upgrade
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As much as we may want to avoid dependencies, it is nearly impossible to build
    a modern API system without them. So, proactively upgrading dependencies before
    vulnerabilities are disclosed or before they become outdated is a good way to
    keep your system CVE-free. To achieve this, it is necessary to do the following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '**Stay informed** : Subscribe to mailing lists and monitor updates from dependency
    maintainers'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run beta tests** : Test new versions in a controlled environment before full
    integration'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contribute to dependencies** : Engage with open source projects you use the
    most to understand upcoming changes'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automate the scanning** : Use tools that notify you about new releases of
    dependencies'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing all of this, you will stay ahead of most CVEs, which reduces the likelihood
    of being affected by new vulnerabilities. As secondary gains, these policies eliminate
    large jumps in dependency versions that may require significant refactoring of
    your own code and all the performance improvements and optimizations of newer
    versions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The drawback is the cost. Implementing these proactive policies can cause frequent
    disruptions that can be hard to justify to business owners and investors because
    there are no new features being created by all the work.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Reactive upgrade based on scan results
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the process of upgrading dependencies in response to vulnerability
    reports from scanners or security advisories. This is probably the most common
    process used by development teams. To effectively manage upgrades based on scan
    results, the teams should follow the following steps:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '**Scan regularly** : Use automated scanners to detect vulnerabilities in dependencies'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assess severity** : Prioritize vulnerabilities based on severity and impact'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan remediation** : Schedule upgrades or apply patches for affected dependencies'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation** : Test the application after upgrades to ensure functionality
    is intact'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation** : Keep records of vulnerabilities found and actions taken'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk management** : Balance the urgency of upgrades with the potential impact
    on the application'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication** : Coordinate with stakeholders to schedule necessary updates'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fallback plans** : Have strategies in place in case an upgrade introduces
    issues'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is nothing inherently negative about this process, but there are risks
    that need to be understood.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to have too many CVEs to mitigate at the same time. When the team
    decides to delay the security tasks, they can accumulate just before a release.
    This is a very common case and can cause important delays to a release.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ever-evolving landscape of cybersecurity necessitates that Java software
    engineers remain vigilant and proactive in managing vulnerabilities within their
    applications. CVEs play a critical role in identifying and communicating known
    security issues, and understanding how to find, document, and remediate them is
    essential.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging tools such as vulnerability scanners and implementing strategies
    such as continuous dependency upgrades, proactive updates, and reactive measures
    based on scan reports, developers can significantly enhance the security posture
    of their applications. Effective dependency management further reduces risks by
    controlling the components integrated into the software.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Staying informed through reputable sources such as the NVD and vendor advisories
    ensures that developers are aware of the latest threats and can act promptly.
    Integrating security practices into the development life cycle transforms security
    from a reactive afterthought into a proactive cornerstone of software development.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: In summary, managing CVEs is a multifaceted process that requires diligence,
    strategic planning, and the right tools. By embracing these practices, Java software
    engineers can contribute to creating more secure applications, protecting both
    their organizations and the end-users who rely on their software. In the next
    chapter, we will look at how generative AI can revolutionize the way we write
    tests for APIs, providing insights and techniques
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
