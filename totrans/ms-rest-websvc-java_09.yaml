- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Your RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the part of the book that talks about software security, within the
    larger field of cybersecurity, which is what you, as a software engineer, are
    most responsible for. This may seem a little different from what you have read
    so far because it’s not always seen as a core responsibility of a software engineer.
    That is a sad misconception. With the digitization of our society, software security
    is no longer just the domain of cybersecurity experts; it’s an integral part of
    software development and should be a major concern at all levels of development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding security can be complex, so let’s start with a mental image.
    Metaphors help simplify abstract concepts, and one of the most common metaphors
    in cybersecurity is the onion. If you’ve read about security before, you’ve likely
    encountered this idea: security is built in layers, just like an onion, with each
    layer adding a protective barrier.'
  prefs: []
  type: TYPE_NORMAL
- en: While useful, this metaphor has its flaws. It suggests that every layer is uniform
    when, in reality, cybersecurity defenses vary significantly. A more accurate comparison
    is a fortress under siege, where different layers of defense respond to different
    threats. Long-range artillery targets distant attackers, walls hold back intruders,
    and hand-to-hand combat is the last line of defense. Likewise, in security, each
    layer serves a distinct purpose, using different tools and techniques to protect
    against specific risks.
  prefs: []
  type: TYPE_NORMAL
- en: But what does this mean for you, the software engineer? Security isn’t just
    about protecting systems—it’s about safeguarding user data, ensuring reliability,
    and preventing costly breaches that can damage both a company’s reputation and
    its bottom line. Vulnerabilities in your code can be exploited to steal sensitive
    information, disrupt services, or even compromise entire networks. As software
    engineers, we are the first line of defense. Writing secure code, enforcing proper
    access controls, and understanding common attack vectors are not optional skills—they
    are essential responsibilities. In this chapter, we’ll explore the layers of security
    you are responsible for and how to integrate security into your development process
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of an HTTP API call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP API Security Top 10 overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Common Vulnerabilities and Exposures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies to manage CVEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of an HTTP API call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all API calls today are made over HTTP. So, let’s take a look at what
    happens during such a call and many of the components that participate in it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A typical secure API call over HTTP](img/B21843_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A typical secure API call over HTTP
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting the communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the protocol is called HTTP and we usually say it is an HTTP call or
    an HTTP connection, the fact is that all modern API calls are made over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: The “ *S* ” at the end stands for “ *secure* ,” indicating that the HTTP communication
    is encrypted using **Transport Layer Security** ( **TLS** ). TLS operates at the
    transport layer (Layer 4 in the OSI model), encrypting data between the client
    and server to prevent eavesdropping and tampering. Using TLS in an HTTP call ensures
    that only the intended receiver can read the message correctly, practically eliminating
    man-in-the-middle attacks because even if a message is intercepted, it cannot
    be decrypted and read.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTPS call will therefore enforce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data confidentiality** : All data transmitted over the network is encrypted
    and meaningless without the correct set of keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data integrity** : Ensures the data hasn’t been altered during transition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server authentication** : Validates the server’s identity to the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three features of HTTPS (HTTP over TLS) communication are implemented using
    cryptographic algorithms to perform encryption and create digital signatures and
    secure digests (hashes) of the transferred data. How the cryptographic algorithms
    are used and how their inputs and outputs are transferred over the network are
    specified by the particular TLS protocol version used.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the algorithms and protocols used in the past are considered vulnerable
    given the current scientific knowledge and computing power available. The set
    of algorithms that are considered safe keeps evolving. There are already algorithms
    available today that are expected to stay safe when we reach the quantum computing
    era.
  prefs: []
  type: TYPE_NORMAL
- en: Always use strong cryptographic algorithms and protocols when implementing HTTPS
    for your APIs. Avoid deprecated protocols such as SSL and old versions of TLS.
    Encryption algorithms are constantly evolving, and old ones have become obsolete
    due to the ease with which they are broken. Create and enforce a policy to review
    your encryption selections frequently and update your TLS certificates. We will
    discuss this later.
  prefs: []
  type: TYPE_NORMAL
- en: In modern organizations (mid-size and up), it is unlikely that a software engineer
    will be responsible for any TLS implementations, but it is important to have a
    general idea of how HTTPS works and its implications.
  prefs: []
  type: TYPE_NORMAL
- en: An essential element used in HTTPS communication is the use of public key cryptography.
    The public part of the public-private key pair is part of a TLS certificate. TLS
    certificates have a life cycle from issue to expiry or invalidation. Hence, we
    need to manage these certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Managing your HTTPS certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the consequences of using HTTPS/TLS encryption is the need for certificate
    management. Managing security certificates is a complex and crucial part of any
    API-based application. Effective certificate management involves handling renewals
    and expirations, and ensuring certificates are correctly configured to prevent
    service interruptions. Additionally, automated tools for certificate life cycle
    management can help streamline compliance, especially in environments with frequent
    communication between APIs or external services. This is such a significant problem
    that many groups have tried to create mechanisms to mitigate it. Let’s Encrypt
    ( [https://letsencrypt.org/](https://letsencrypt.org/) ) has achieved great success,
    having been used even in some large corporations. Most cloud providers also have
    some form of automatic certificate management, such as AWS Certificate Manager
    ( [https://aws.amazon.com/certificate-manager/](https://aws.amazon.com/certificate-manager/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: The first line of defense – Web Application Firewall (WAF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A WAF acts as a barrier between the client and your server, filtering out malicious
    traffic and offering a first layer of protection against common web exploits such
    as SQL injection and **Cross-Site Scripting** ( **XSS** ). This is not usually
    controlled by software engineers, but it is important to know about it as the
    WAF can cause some interference on HTTP traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the functions of a WAF:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic monitoring** : Inspects incoming requests for suspicious patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule-based filtering** : Blocks traffic based on predefined security rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anomaly detection** : Identifies unusual behavior that may indicate an attack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regularly updating WAF rules is essential to ensure that it can adapt to new
    and emerging threats. Additionally, it’s important to customize these rules to
    align with the specific needs and architecture of your application, ensuring optimal
    protection. Monitoring WAF logs consistently provides valuable security insights,
    helping to identify patterns, anomalies, or potential attacks, thereby enabling
    proactive defenses.
  prefs: []
  type: TYPE_NORMAL
- en: API gateways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An API gateway is usually the entry point for all client requests, handling
    tasks such as request routing, composition, and protocol translation. In terms
    of security, an API gateway frequently performs many important tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TLS termination** : Decrypts incoming HTTPS traffic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication** : Validates credentials and permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiting and throttling** : Controls the number of requests to prevent
    abuse'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An API gateway centralizes security policies, allowing consistent enforcement
    across all services. It simplifies client interactions with APIs by providing
    a single entry point that manages tasks such as routing and authentication. Additionally,
    it enhances performance by enabling caching and load balancing, ensuring efficient
    resource utilization and improved response times.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Load balancers distribute incoming network traffic across multiple servers
    to ensure availability and reliability. While not directly involved in security
    logic, they contribute to overall security in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Health monitoring** : Removing unhealthy servers from the pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TLS termination** : Also handling TLS encryption to reduce server load and
    system complexity if an API gateway is not present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigating Denial of Service (DoS)** : Distributing the load helps to mitigate
    DoS attacks. This is often the last resort in a DoS attack. It would be expected
    that the WAF and the API gateway would have minimized the impact of an attack
    at this point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to decrypt the call – TLS termination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a secure call is encrypted, it needs to be decrypted at some point so that
    its content can be interpreted and processed. That is called **TLS termination**
    . It refers to the process of decrypting an HTTPS connection and converting it
    back to a clear-text HTTP communication. This typically occurs at the network’s
    edge, such as within an API gateway, a load balancer, or a reverse proxy server.
    By terminating the TLS encryption at a single point, organizations can offload
    the computational overhead associated with encryption and decryption from backend
    servers. This process usually happens only once during the life cycle of an API
    call, ensuring that data remains encrypted while traversing insecure networks
    but can be processed more efficiently within trusted internal networks. TLS termination
    enhances performance and simplifies certificate management without compromising
    the security of data in transit over public channels. It is important to be aware
    of when the TLS termination happens, especially when troubleshooting some problems
    with an API.
  prefs: []
  type: TYPE_NORMAL
- en: All the security elements that we have briefly discussed so far are undeniably
    very important, but in modern mid-size and larger organizations, they are usually
    not the direct responsibility of the software engineer. Other professionals oversee
    them, and therefore they are not the focus of this chapter. In contrast, the following
    security elements are very much the responsibility of the software engineer and
    we all should have a clear understanding of them.
  prefs: []
  type: TYPE_NORMAL
- en: As we have discussed, securing API communications is a multi-layered process
    involving various tools and technologies, each playing a distinct role in protecting
    data in transit. From the encryption provided by HTTPS and TLS to the filtering
    and monitoring capabilities of WAFs, every layer contributes to a robust defense
    against cyber threats. TLS termination and certificate management further underscore
    the importance of maintaining both performance and security in modern API ecosystems.
  prefs: []
  type: TYPE_NORMAL
- en: While these responsibilities are often overseen by dedicated teams in large
    organizations, it is essential for software engineers to understand how these
    components work and their implications. Having this foundational knowledge allows
    better collaboration with security teams and DevOps engineers to troubleshoot
    issues effectively when they arise and to make better decisions during design
    and development. With security threats constantly evolving, maintaining an awareness
    of these practices ensures APIs remain resilient and reliable, forming a secure
    backbone for any application.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the foundational process of verifying the identity of a user,
    device, or other entity attempting to access your API. Authentication is a crucial
    element in security because it ensures that only legitimate and recognized parties
    can interact with your services. Without proper authentication mechanisms, APIs
    become vulnerable to unauthorized access, data breaches, and malicious activities
    that can compromise system integrity and user data.
  prefs: []
  type: TYPE_NORMAL
- en: The primary goal of authentication is to establish the identity of the client
    requesting access. By confirming it, the API can enforce access controls, apply
    rate limiting, and provide personalized experiences where appropriate. Moreover,
    robust authentication mechanisms are essential for compliance with legal and regulatory
    requirements, such as the GDPR, HIPAA, LGPD, and other data protection laws.
  prefs: []
  type: TYPE_NORMAL
- en: Different authentication methods can be employed depending on the level of security
    required, the nature of the application, and user experience considerations. Next,
    we will break down some of the most common methods.
  prefs: []
  type: TYPE_NORMAL
- en: Password-based authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Password-based authentication is the most traditional and is still one of the
    most widely used methods of authentication. Users provide a username and password,
    which are then verified against credentials stored on the server. By its nature,
    this method is mostly used when a person is authenticating with a system. It is
    hardly ever used in any form of machine-to-machine interaction.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the user attempts to log in, they send their credentials, typically a username
    and password, to a security service API. Upon receiving the credentials, the server
    hashes the password and compares it with the stored hash in its database. If the
    credentials match, the user is successfully authenticated, and the server generates
    an authentication token, such as a session cookie or a **JSON Web Token** ( **JWT**
    ), to facilitate future requests without the need for repeated credential submission.
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Passwords should never be stored in plaintext; instead, they must always be
    hashed using a secure algorithm. The hashing process is only as good as the algorithm
    used. Two modern and widely used ones are *Bcrypt* and *Argon2* . A deeper discussion
    on hashing algorithms is not in the scope of this chapter, but it is highly recommended
    to look at how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is brute-force attacks. It’s important to implement account
    lockout mechanisms after a certain number of failed login attempts. Additionally,
    users should be required to create strong passwords by enforcing password policies
    that include minimum length requirements, the use of special characters, and the
    avoidance of common or easily guessable words.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the advantages of password-based authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy for users to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Passwords can be easily stolen or guessed, especially if they are weak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires robust security measures such as rate limiting and password resets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password reuse across different services makes accounts more vulnerable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token-based authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Token-based authentication relies on the use of tokens—small pieces of data
    passed between the client and server to verify identity. A widely adopted token
    format is JWT, and this is the format we will discuss.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand how a JWT works, specifically the lifespan of
    a token.
  prefs: []
  type: TYPE_NORMAL
- en: JWT life cycle and utilization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The user logs in with their credentials, and the server generates a token (often
    a JWT) containing encoded information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will create and sign the JWT, ensuring its integrity, and send it
    back to the client. The internal mechanism of signing and creating a JWT is beyond
    the scope of this book. See this article for a more complete discussion: [https://www.freecodecamp.org/news/how-to-sign-and-validate-json-web-tokens/](https://www.freecodecamp.org/news/how-to-sign-and-validate-json-web-tokens/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: From that moment on, the client will include the JWT in the header of all future
    API requests, typically in a pre-defined header defined by the API development
    team.
  prefs: []
  type: TYPE_NORMAL
- en: The server validates the token on each request without needing to check the
    user credentials again.
  prefs: []
  type: TYPE_NORMAL
- en: One important point to understand is that all tokens (JWT or not) must be temporary.
    They must expire at clear and well-defined intervals. As a software engineer working
    on the API layer, you usually don’t have to do anything special to handle this,
    but frontend applications will have to define a token renewal strategy, and you
    may have to collaborate and support such tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of a JWT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JWT is an encrypted record that follows a well-defined structure. So, let’s
    look inside a JWT and discuss its structure.
  prefs: []
  type: TYPE_NORMAL
- en: A good tool for viewing and manipulating JWTs can be found at [https://jwt.io/#debugger-io](https://jwt.io/#debugger-io)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Example JWT](img/B21843_07_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Example JWT
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT consists of three distinct parts separated by a dot: the header, payload,
    and signature. As an API developer, your focus will be on the payload, as it contains
    claims (fields) about the user (e.g., user ID, permissions). The signature ensures
    the token hasn’t been tampered with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once decrypted, the data inside a JWT looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Field** | **Description** | **Example Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Header | `alg` | Algorithm used to sign or encrypt the token | `"HS256"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Header | `typ` | Type of token | `"JWT"` |'
  prefs: []
  type: TYPE_TB
- en: '| Header | `cty` | Content type of the JWT payload | `"JWT"` or `"application/json"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Header | `kid` | Key ID used to identify the key used in signature | `"abc123"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `iss` | Issuer of the token | `"auth.example.com"` |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `sub` | Subject of the token (usually a user ID) | `"1234567890"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `aud` | Audience for which the token is intended | `"example.com"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `exp` | Expiration time (in Unix time) | `1516239022` |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `nbf` | Not valid before this time (in Unix time) | `1516239022`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `iat` | Issued at time (in Unix time) | `1516239022` |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `jti` | JWT ID; a unique identifier for the token | `"unique-token-id-123"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `name` | User’s full name | `"John Doe"` |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `email` | User’s email address | `"john.doe@example.com"` |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `role` | Roles or permissions assigned to the user | `"admin"`
    or `["admin", "user"]` |'
  prefs: []
  type: TYPE_TB
- en: '| Signature | N/A | Digital signature for verifying the token’s integrity |
    (Result of cryptographic operation) |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – An example JWT
  prefs: []
  type: TYPE_NORMAL
- en: The header can be customized to adjust to the needs of each organization. But
    at a minimum, you should see `"alg"` and `"typ"` entries present.
  prefs: []
  type: TYPE_NORMAL
- en: The payload is also mostly defined by the organization. Each entry in the payload
    is called a **claim** and is used to identify the users, their roles, unique information,
    and any other data element that can be used by the APIs to best control access
    to the data.
  prefs: []
  type: TYPE_NORMAL
- en: Special attention should be given to the three time-based claims – `exp` , `nbf`
    , and `iat` . They are crucial to verify whether the JWT is valid at the time
    of execution of the API. Ideally, they should not be omitted, although `"nbf"`
    is sometimes not defined. In that case, it is assumed that the JWT is valid from
    the moment it is created ( `"iat"` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are three classifications for claims:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registered claims** : Predefined claims widely used in the industry, such
    as `iss` , `exp` , and `sub`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public claims** : Custom claims agreed upon by parties using the JWT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private claims** : Custom claims used in contexts specific to your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the key benefits of token-based authentication is that the server doesn’t
    need to store session state validation information. All necessary information
    is contained in the token itself and is sent over in each call.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, it is necessary to store session state on the server side, but no
    credentials or user identification should be stored, only references to the tokens
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JWTs are part of a general security strategy, and as such should be treated
    as data to be secured in themselves. Therefore, here are some specific security
    concerns about the JWTs:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use HTTPS to transmit tokens, as tokens are susceptible to interception
    in plaintext
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set token expiration times to limit the window of vulnerability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use short-lived tokens with refresh tokens to minimize the risk of token theft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely store tokens on the client side, avoiding local storage if possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the advantages of a JWT strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Stateless authentication scales well in distributed systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no need to store session information on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows granular control over access rights using token claims
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And these are some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Tokens, if stolen, can be used to impersonate the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing token expiration and secure refresh cycles will add complexity to the
    application, both the frontend and the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caveats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One problem that sometimes happens is JWT inflation, where the organization
    keeps adding more claims or long lists of values to claims to the point that the
    JWT grows beyond the limits defined on the server. Even if the JWT specs do not
    define an upper limit, remember that the token will be sent over as part of the
    HTTP header, and there is always a limit for them. If you start receiving **HTTP
    413 Content Too Large** errors, one possible culprit could be the size of your
    JWT.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, using JWTs to manage authentication and authorization is a well-established
    strategy that has good industry support and relies upon solid technologies. However,
    a large portion of its effectiveness is due to how it is used by the application.
    It is your responsibility as the software engineer to make sure good and well-managed
    policies are put in place.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-factor authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Multi-factor authentication** ( **MFA** ) adds an additional layer of security
    by requiring the user to provide more than one form of identification. This typically
    includes something they know (e.g., password), something they have (e.g., mobile
    phone or security token), or something they are (e.g., fingerprint or face recognition).
    This is mostly a client-side strategy and has little effect on API development,
    but it is important for backend engineers to understand its general concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: MFA is part of the authentication dialog, so, after a user has successfully
    entered their password, they are prompted to provide a second factor, such as
    a code generated by a mobile app (e.g., Google Authenticator) or sent via SMS.
    The server then verifies the second factor before granting access, usually by
    generating a JWT to be used by the client when accessing the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: What can be used in MFA?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generally speaking, there are three types of MFA:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Something you know** : A password, PIN, or answer to a security question'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Something you have** : A physical device such as a phone or hardware token
    that generates a temporary passcode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Something you are** : Biometric data such as a fingerprint, facial recognition,
    or iris scan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s see what we should consider with regard to security when using MFA:'
  prefs: []
  type: TYPE_NORMAL
- en: MFA drastically reduces the likelihood of account compromise, even if a password
    is stolen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time-based one-time passwords** ( **TOTPs** ) are commonly used for MFA.
    Ensure that those tokens are properly time-synchronized and expire after a short
    period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS-based MFA is vulnerable to SIM swapping and should be avoided where possible.
    Use app-based authenticators or hardware tokens instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at the advantages of MFA:'
  prefs: []
  type: TYPE_NORMAL
- en: It significantly enhances security by requiring multiple forms of verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It protects against common attacks such as password phishing and brute-force
    attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And let’s see some of the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be cumbersome for users, especially in environments with frequent logins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires infrastructure to support the second factor, such as maintaining
    SMS gateways or integrating with an authenticator app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Biometric authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Biometric authentication uses physical characteristics like fingerprints, facial
    recognition, or voice to verify a user’s identity. With the increasing availability
    of biometric sensors on mobile devices and laptops, it’s becoming a more common
    method of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: The user’s biometric data (fingerprint, face scan, etc.) is captured and stored
    securely on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user attempts to authenticate, the API compares the captured data with
    the stored biometric template to verify their identity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are some common biometric authentication methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fingerprint scanning** : Used extensively on mobile devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facial recognition** : Built into many smartphones and laptops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Voice recognition** : Sometimes used for telephonic authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see some of the security considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Biometric data is unique to each user, making it difficult to forge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store biometric data locally, not on the server, to prevent mass breaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure biometric systems have fallback options (such as passwords) for cases
    where biometrics fail (e.g., injury or hardware malfunction)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some advantages of biometric authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a high level of security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is convenient for users—there’s no need to remember passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Biometric data is irreversible—once compromised, it cannot be changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are potential privacy concerns around the collection and storage of biometric
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is less reliable in certain conditions (e.g., wet fingerprints or poor lighting
    for facial recognition)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right authentication method depends on the application’s requirements
    and the sensitivity of the data it handles. While password-based authentication
    remains prevalent, more secure methods, such as token-based authentication, MFA,
    and biometric authentication, are rapidly gaining ground. Combining these methods,
    such as using MFA in conjunction with JWTs, can provide a robust and flexible
    authentication mechanism for APIs, ensuring the security of both users and data.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have your API guarded against unknown users by authentication, the
    next step is to apply authorization mechanisms. This is where the system determines
    whether an authenticated entity (user, device, or service) has permission to access
    a specific resource or perform a particular action. While authentication verifies
    identity, authorization governs access, ensuring that the authenticated entity
    only has access to the resources and operations for which they have been granted
    permission.
  prefs: []
  type: TYPE_NORMAL
- en: In API security, proper authorization is essential for enforcing business rules,
    safeguarding sensitive data, and ensuring that each user or service only performs
    the actions and accesses the information they are allowed to. So, let’s look at
    the different techniques we can use to implement authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common authorization mechanisms is **role-based access control**
    ( **RBAC** ). RBAC works by assigning predefined roles to users or entities and
    associating permissions with those roles. Each role is granted access to specific
    API endpoints or functionalities, depending on the application’s security requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how RBAC works:'
  prefs: []
  type: TYPE_NORMAL
- en: Users are assigned one or more roles, such as admin, user, or editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API endpoints or resources are protected by role checks. For example, only users
    with the admin role might have access to the /admin endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an API request is made, the server checks the user’s assigned roles against
    the roles required for the requested resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some of the advantages of RBAC:'
  prefs: []
  type: TYPE_NORMAL
- en: It simplifies permission management by grouping permissions into roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to implement and scale, particularly in enterprise applications where
    roles can be defined centrally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is fully supported by many solutions, such as the claims in JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be inflexible in complex systems where fine-grained access control is
    required, leading to role explosion or data leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can cause unexpected exposure in complex systems, as roles may be inconsistent
    or incompatible with each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute-based access control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Attribute-based access control** ( **ABAC** ) provides more granular control
    than RBAC by using attributes (user attributes, environment attributes, resource
    attributes, etc.) to determine access rights. Attributes are metadata that describe
    entities or actions and are evaluated against policies to decide whether access
    is allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how ABAC works:'
  prefs: []
  type: TYPE_NORMAL
- en: Policies are written to define the conditions under which access is granted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes such as user role, time of request, resource type, or location are
    considered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access decisions are made dynamically, based on real-time evaluation of attributes
    and policies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some of the advantages of using ABAC:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides flexibility by allowing fine-grained control based on dynamic conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is scalable for complex systems in which RBAC would become difficult to manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It is more complex to implement and manage than RBAC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can result in performance overhead due to real-time policy evaluations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can cause unexpected security issues due to mismanaged attributes. For example,
    an employee changes positions in the company but the system still allows them
    to see data from the previous job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OAuth 2.0 is one of the most widely used authorization frameworks for APIs.
    It allows a user to grant a third-party application limited access to their resources
    without exposing their credentials. OAuth 2.0 is commonly used for delegating
    access to APIs and provides a standardized method for authorization across web,
    mobile, and cloud applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how OAuth 2.0 works:'
  prefs: []
  type: TYPE_NORMAL
- en: The user authenticates with an identity provider (e.g., Google, Facebook) and
    grants permission to a third-party application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third-party application receives an access token, which it uses to make
    authorized API requests on behalf of the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The access token contains scopes, which define the level of access the third-party
    application has (e.g., read-only, write).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see some security considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use HTTPS to transmit OAuth tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use short-lived access tokens and refresh tokens to minimize risk in case of
    token theft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement token revocation mechanisms to invalidate tokens if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the advantages of using Oauth2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows delegated access without sharing user credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has been widely adopted, providing standardization across many services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires the implementation of secure token storage and transmission mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can add complexity, especially when managing refresh tokens and token expiration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JWT for authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JWTs, which were discussed in the *Authentication* section, also play a key
    role in authorization. After authentication, a JWT can be issued containing claims
    that specify the user’s roles or permissions. These claims can then be used by
    the API to enforce access controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how JWT authorization works:'
  prefs: []
  type: TYPE_NORMAL
- en: The user is authenticated, and a JWT is issued containing claims such as user
    roles or permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client includes the JWT in the authorization header in future API requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server decodes the JWT and checks the claims to determine whether the user
    is authorized to access the requested resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JWTs allow stateless authorization, meaning the server doesn’t need to maintain
    session state because the necessary authorization information is embedded in the
    token itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some of the advantages of using JWT authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: It scales well in distributed systems by eliminating the need for server-side
    session storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables fine-grained control using claims inside the JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As for disadvantages, it requires careful management of token expiration and
    revocation to prevent unauthorized access. This is the biggest drawback of JWT
    and any other attribute-based authorization. It is important to ensure the claims
    in the JWT reflect the actual roles of this user. Once again, the case of an employee
    changing positions in the company comes to mind, potentially causing data access
    violations.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-grained access control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some systems, the level of access control required goes beyond the basic
    capabilities of RBAC or even ABAC. **Fine-grained access control** ( **FGAC**
    ) allows more nuanced control over access to resources, based on attributes such
    as user identity, resource ownership, and contextual data.
  prefs: []
  type: TYPE_NORMAL
- en: These levels of FGAC are usually found in complex business domains; healthcare
    and finance are two very common cases. Healthcare, being a highly regulated industry,
    has many different rules that need to be applied to any data access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of FGAC:'
  prefs: []
  type: TYPE_NORMAL
- en: A user can access only their own profile data, not other users’ data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service can only modify resources that it has created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to sensitive resources might be restricted based on location, time of
    day, or other contextual information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A customer on a healthcare insurance system can see all payments made to their
    account but can only see claims payments for their claims and other dependents
    that they are legally allowed to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a closer look at that last example, as it illustrates the challenges
    of FGAC.
  prefs: []
  type: TYPE_NORMAL
- en: '*Case* : A client is required to keep their ex-spouse on their healthcare policy
    for a specified time. During this time, the main client cannot see any of the
    spouse’s medical information, but can see the costs associated with their treatment.
    There are several challenges in this case. Where do we look for the mandatory
    amount of time to keep the spouse on the policy? How do we isolate the spouse’s
    data in a family request? How do we allow some financial data to be exposed but
    not medical information?'
  prefs: []
  type: TYPE_NORMAL
- en: Those are not simple questions to answer and may make that piece of the system
    more complex than it would be otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: This case requires careful design and policy enforcement. It could increase
    the complexity of the application, particularly in large systems.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for API authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In summary, here are some guidelines to make sure your API is as secure as
    you can make it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use the principle of least privilege** : Only grant users and services the
    minimal permissions necessary to perform their tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement layered authorization mechanisms** : Combine RBAC with ABAC or
    OAuth for more flexible and secure access control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regularly audit permissions** : Periodically review and update roles, permissions,
    and access policies to ensure they align with current business needs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure tokens** : Always use secure storage and transmission methods for
    tokens (e.g., OAuth tokens, JWTs) to prevent unauthorized access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization, when designed and implemented effectively, ensures that your
    API remains secure, responsive, and compliant with regulatory requirements. By
    choosing the right authorization strategy—whether RBAC, ABAC, OAuth, or JWT-based—you
    can tailor access control to your system’s specific needs while protecting data
    and ensuring users can only perform the actions they are entitled to.
  prefs: []
  type: TYPE_NORMAL
- en: OWASP API Security Top 10 overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OWASP** stands for **Open Web Application Security Project** , a non-profit
    organization that focuses on web application security. They do a phenomenal job
    at documenting known security issues and helping developers and organizations
    to secure web applications. One of the main contributions is the **OWASP API Security
    Top 10** , which identifies the most critical security risks for APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP is a crucial resource for all software engineers, and you should periodically
    look at the published lists of concerns and new security white papers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most recent list was published in 2023 and can be found here: [https://owasp.org/API-Security/editions/2023/en/0x11-t10/](https://owasp.org/API-Security/editions/2023/en/0x11-t10/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: API1:2023 - Broken Object Level Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API2:2023 - Broken Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API3:2023 - Broken Object Property Level Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API4:2023 - Unrestricted Resource Consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API5:2023 - Broken Function Level Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API6:2023 - Unrestricted Access to Sensitive Business Flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API7:2023 - Server Side Request Forgery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API8:2023 - Security Misconfiguration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API9:2023 - Improper Inventory Management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API10:2023 - Unsafe Consumption of APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, all the top OWASP concerns are the topics we have been discussing
    in this chapter so far. It is important to be well acquainted with the OWASP list
    as it evolves, so visit frequently the OWASP Top Ten API Security Risks at the
    link provided previously.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Common Vulnerabilities and Exposures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The phrase “our society runs on software” is not new and describes most modern
    societies, and consequently, software security has emerged as a core concern for
    governments and organizations worldwide. Cyber threats are evolving at an unprecedented
    pace, and vulnerabilities in software can lead to significant financial losses,
    reputational damage, and legal repercussions. In the same week as this chapter
    was written, the largest DDoS attack in history targeted Cloudflare (you can find
    a detailed discussion here: [https://www.linkedin.com/pulse/cloudflare-mitigates-historic-world-record-56-tbps-hoccc/](https://www.linkedin.com/pulse/cloudflare-mitigates-historic-world-record-56-tbps-hoccc/)
    ). It is suspected that the scale of this attack was achieved by exploiting vulnerabilities
    in many IoT devices, but the details are still being discovered. Therefore, for
    Java software engineers, understanding and managing these vulnerabilities is fundamental
    for developing secure and robust applications.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the fundamental aspects of software security is the identification and
    mitigation of known vulnerabilities, commonly referred to as **Common Vulnerabilities
    and Exposures** ( **CVEs** ). This chapter aims to provide an in-depth exploration
    of CVEs from the perspective of a professional Java software engineer. We will
    delve into the definition of CVEs, the mechanisms used to discover and document
    them, and their structural composition. Additionally, we will highlight the best
    resources for tracking CVEs and discuss software scanners that help identify these
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will examine effective strategies for managing CVEs, including
    continuous dependency upgrades, dependency management practices, proactive dependency
    updates, and reactive upgrades based on scan reports. By understanding and implementing
    these strategies, software engineers can enhance the security posture of their
    applications and contribute to a safer digital ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: What are CVEs?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CVE system is a standardized method for identifying and cataloging security
    vulnerabilities and exposures in software and firmware. Managed by the MITRE Corporation,
    CVE provides a unique identifier for each disclosed vulnerability, allowing consistent
    references across various security tools, databases, and communications. A CVE
    entry typically includes an identification number, a brief description of the
    vulnerability, and references to related advisories, reports, and patches.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Java software engineers, CVEs are particularly significant due to the widespread
    use of Java libraries and frameworks, which can introduce vulnerabilities into
    applications if not properly managed. Understanding CVEs enables developers to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify vulnerabilities** : Recognize known security issues in the libraries
    and components they use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assess impact** : Evaluate the potential impact of a vulnerability on their
    applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement mitigations** : Apply patches or updates to address vulnerabilities
    promptly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintain compliance** : Adhere to security policies and regulatory requirements
    by managing known vulnerabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are CVEs found and documented?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The discovery of vulnerabilities is a collaborative effort involving security
    researchers, developers, and automated tools. The following are common mechanisms
    for finding vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security research** : Security professionals and researchers actively analyze
    software to identify potential vulnerabilities. This process may involve the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code auditing** : Manually reviewing source code for insecure coding practices'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Penetration testing** : Simulating attacks to find weaknesses in running
    applications'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuzz testing** : Providing invalid or random data to programs to trigger
    unexpected behavior'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bug bounty programs** : Many organizations offer bug bounty programs, incentivizing
    independent researchers to find and report vulnerabilities. These programs help
    uncover issues that might be missed by internal teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated scanning tools** : Tools such as static code analyzers and **dynamic
    application security testing** ( **DAST** ) tools automatically scan code bases
    and running applications for known vulnerability patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User and developer reports** : End-users and developers may encounter security
    issues during regular use or development activities and report them to the maintainers
    or security teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once a vulnerability is discovered, documenting it involves several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability disclosure** : The finder reports the vulnerability to the
    software vendor or maintainers, following responsible disclosure practices to
    allow time for a fix before public disclosure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CVE assignment** : An authorized **CVE Numbering Authority** ( **CNA** )
    assigns a unique CVE identifier to the vulnerability. This identifier allows consistent
    tracking and reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description and analysis** : A detailed description of the vulnerability
    is created, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summary** : A brief overview of the issue'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical details** : In-depth information about the vulnerability, including
    affected versions and components'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impact assessment** : The potential risks and consequences if the vulnerability
    is exploited'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publishing** : The CVE entry is published in the CVE database and shared
    with various security databases such as the **National Vulnerability Database**
    ( **NVD** ). Vendors may also release security advisories and patches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure of a CVE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A CVE entry consists of several key components that provide essential information
    about the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CVE identifier** : A unique identifier in the format CVE-YYYY-NNNN, where
    YYYY is the year the CVE ID was assigned or made public and NNNN is a sequential
    number, for example, CVE-2023-12345.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description** : A concise summary of the vulnerability, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type of vulnerability** : Such as buffer overflow or injection flaw'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Affected products** : Specific software, versions, and components impacted'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impact** : The potential effects of exploitation, such as unauthorized access
    or denial of service'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**References** : Links to additional information, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor advisories** : Official statements or patches from the software vendor'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Bulletins** : Reports from security organizations'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical Analysis** : In-depth articles or reports analyzing the vulnerability'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, when imported into the NVD, additional metadata is added (if available):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CVSS scores** : The **Common Vulnerability Scoring System** ( **CVSS** )
    provides a quantitative measure of the severity of the vulnerability.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impact metrics** : Details about confidentiality, integrity, and availability
    impacts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Affected configurations** : Specific environments or configurations that
    are vulnerable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to understand that documenting a CVE is a process, and a CVE that affects
    your code may have been identified, but no current solution is yet available.
  prefs: []
  type: TYPE_NORMAL
- en: Best resources to track CVEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Staying informed about the latest vulnerabilities is essential for proactive
    security management. The following are some of the best resources for tracking
    CVEs. You should bookmark each of them and become familiar with their structure
    and searching capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: NVD
  prefs: []
  type: TYPE_NORMAL
- en: 'Managed by the **National Institute of Standards and Technology** ( **NIST**
    ), the NVD provides comprehensive information about CVEs, including detailed analyses,
    CVSS scores, and impact metrics. It is the main resource for CVEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://nvd.nist.gov/](https://nvd.nist.gov/ )'
  prefs: []
  type: TYPE_NORMAL
- en: MITRE CVE list
  prefs: []
  type: TYPE_NORMAL
- en: 'The official CVE list is maintained by MITRE. It provides basic information
    about each CVE, including descriptions and references. Frequently, the information
    here is easier to navigate than the NVD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cve.mitre.org/](https://cve.mitre.org/ )'
  prefs: []
  type: TYPE_NORMAL
- en: Security advisories from vendors
  prefs: []
  type: TYPE_NORMAL
- en: 'Software vendors often publish their own security advisories and patches. Monitoring
    these sources ensures you receive vendor-specific information promptly. There
    are many such resources, but for a Java software engineer, Oracle and Apache are
    two of the most important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oracle Java SE Critical Patch Updates** : [https://www.oracle.com/security-alerts/](https://www.oracle.com/security-alerts/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Security** : [https://apache.org/security/](https://apache.org/security/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VulDB** : [https://vuldb.com/](https://vuldb.com/ )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These databases aggregate vulnerability information from various sources and
    often provide additional context and analysis. Not all current vulnerabilities
    may be available there yet.
  prefs: []
  type: TYPE_NORMAL
- en: Software scanners that help to identify CVEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Software scanners are tools that have been designed to automatically detect
    vulnerabilities within code bases, applications, or systems. For Java developers,
    these tools are invaluable in identifying CVEs associated with dependencies and
    code. They work in a few different forms and, depending on the project, you may
    have to use more than one to cover your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Static Application Security Testing (SAST) tools** : These tools analyze
    source code for security vulnerabilities without executing the code. Examples
    are SonarQube and Checkmarx'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software Composition Analysis (SCA)** : These tools identify open source
    components and dependencies in your application and check for known vulnerabilities.
    Examples include OWASP Dependency-Check, Snyk, Black Duck, and WhiteSource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Application Security Testing (DAST)** : These tools analyze running
    applications to detect vulnerabilities by simulating attacks. Examples include
    OWASP ZAP and Burp Suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How these tools work
  prefs: []
  type: TYPE_NORMAL
- en: As CVEs are security problems with external dependencies, how can the scanners
    look at your code and find the issues?
  prefs: []
  type: TYPE_NORMAL
- en: First, the scanner analyzes project files, such as `pom.xml` for Maven and `build.gradle`
    for Gradle, to identify all direct and transitive dependencies. It then extracts
    the version numbers of each dependency and compares them against a vulnerability
    database containing CVE information. Based on this comparison, the scanner generates
    a detailed report highlighting any vulnerable dependencies, classifying them by
    severity levels according to CVSS scores. Additionally, it provides upgrade recommendations,
    suggesting versions that resolve the identified vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to integrate the dependency scanners into the development workflow.
    Some scanners provide plugins for **Integrated Development Environments** ( **IDEs**
    ) such as Eclipse and IntelliJ IDEA, allowing developers to detect vulnerabilities
    directly within their coding environment. Additionally, scanners can be incorporated
    into **Continuous Integration/Continuous Deployment** ( **CI/CD** ) pipelines,
    automating vulnerability detection during the build process. To enhance security
    monitoring, they can also be configured to send automated alerts whenever new
    vulnerabilities are identified. By identifying and addressing security issues
    early in the development cycle, these integrations enhance agility and help shorten
    the **Software Development Life Cycle** ( **SDLC** ), reducing delays caused by
    late-stage security fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Popular scanners for Java
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always a little dangerous to publish lists of software tools in a printed
    format as some projects may disappear or become obsolete over time, but as of
    April 2025, these are the most widely used tools for identifying vulnerabilities
    in Java projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OWASP Dependency-Check** : This open-source tool identifies a project’s dependencies
    and checks whether there are any known, publicly disclosed vulnerabilities (CVEs)
    associated with the scanned dependencies. It supports projects that use Maven,
    Gradle, and Ant and can be integrated into most build tools and CI/CD solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snyk** : This is a commercial tool that provides vulnerability scanning and
    remediation for open source dependencies. It provides real-time scanning, allowing
    the continuous monitoring of dependencies. It also proposes code fixes automatically
    with suggestions directly in pull requests. Plugins are available for most popular
    IDEs (such as IntelliJ and VS Code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Black Duck** : This is a comprehensive SCA tool that scans for open source
    vulnerabilities and license compliance. It enforces policies regarding the use
    of open source components in the system and generates in-depth analysis of vulnerabilities
    and risks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies to manage CVEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All these tools are very important and are a crucial part of managing the CVEs
    in your project. But how can we manage this workload, and what considerations
    are needed?
  prefs: []
  type: TYPE_NORMAL
- en: The effective management of CVEs involves not just detection but also strategic
    planning and processes to mitigate risks.
  prefs: []
  type: TYPE_NORMAL
- en: One important point to understand is that writing secure software is expensive,
    and managing CVEs in particular has become a hard and expensive part of software
    security. It is not uncommon for teams to allocate 15% to 20% of their capacity
    to security.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let’s look at a couple of strategies that help Java developers
    maintain secure applications.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous upgrade dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regularly updating dependencies to their latest versions ensures that applications
    benefit from security patches and improvements made by library maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: This is a proactive approach to CVEs. By always keeping your dependencies up
    to date, you guarantee that any security update will be implemented and used in
    your code as soon as it is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various ways to implement continuous upgrades:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated updates** : Use tools such as Dependabot to automatically create
    pull requests for dependency updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular maintenance schedule** : Establish a routine (e.g., weekly or monthly)
    to review and update dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing** : Implement comprehensive automated tests to ensure that updates
    do not introduce regressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring release notes** : Keep track of dependency release notes for any
    security-related updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the benefits of continuous upgrades:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security** : It reduces the window of exposure to known vulnerabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature enhancements** : It provides access to new features and performance
    improvements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community support** : It aligns with the active versions supported by the
    community'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Costs and requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main cost with this approach is the time that must be invested in keeping
    the code base current. Remember, you will be changing dependencies in your code,
    and the API you are calling may have changed, sometimes in ways that are not immediately
    obvious, forcing you and your team to refactor portions of your code that would
    not need any change otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to make so many potential breaking changes so frequently, it is necessary
    to have a comprehensive set of automated tests that can give the developer team
    the confidence to make those changes in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: The time to add the tools and integrate them with the specific ticketing system
    used in your organization is another cost that needs to be considered. The initial
    investment can be quite large for legacy code bases with not enough test coverage
    and automated build pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know that CVEs are caused by the dependencies we as software engineers
    add to the code base, what can we do to limit our exposure to them?
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, a proper policy for the management of dependencies is crucial to control
    the quality, security, and performance of your application. The goal here is to
    prevent exposure to CVEs as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, software engineers add dependencies to projects without analyzing
    the consequences. To be honest, this happens more often than we’d like to admit!
    Having a policy in place that will require validation of the need for this new
    dependency and a discussion about more secure and better-maintained alternatives
    can significantly help with security vulnerabilities. To avoid introducing unnecessary
    risks, it is important to follow these best practices when adding and managing
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimal dependencies** : Include only necessary dependencies to reduce the
    attack surface. The introduction of new dependencies must be discussed with the
    team and its implications must be identified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version pinning** : Specify exact versions of dependencies to ensure consistent
    builds. Avoid having dependencies on the “latest” version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use trusted sources** : Retrieve dependencies from reputable repositories
    (e.g., Maven Central). Choose packages and libraries that are actively maintained
    and have a good history of security updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitive dependency control** : Monitor and manage transitive dependencies
    brought in by direct dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**License compliance** : Ensure that the licenses of dependencies are compatible
    with your project.'
  prefs: []
  type: TYPE_NORMAL
- en: Proactive dependency upgrade
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As much as we may want to avoid dependencies, it is nearly impossible to build
    a modern API system without them. So, proactively upgrading dependencies before
    vulnerabilities are disclosed or before they become outdated is a good way to
    keep your system CVE-free. To achieve this, it is necessary to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stay informed** : Subscribe to mailing lists and monitor updates from dependency
    maintainers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run beta tests** : Test new versions in a controlled environment before full
    integration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contribute to dependencies** : Engage with open source projects you use the
    most to understand upcoming changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automate the scanning** : Use tools that notify you about new releases of
    dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing all of this, you will stay ahead of most CVEs, which reduces the likelihood
    of being affected by new vulnerabilities. As secondary gains, these policies eliminate
    large jumps in dependency versions that may require significant refactoring of
    your own code and all the performance improvements and optimizations of newer
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback is the cost. Implementing these proactive policies can cause frequent
    disruptions that can be hard to justify to business owners and investors because
    there are no new features being created by all the work.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive upgrade based on scan results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the process of upgrading dependencies in response to vulnerability
    reports from scanners or security advisories. This is probably the most common
    process used by development teams. To effectively manage upgrades based on scan
    results, the teams should follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scan regularly** : Use automated scanners to detect vulnerabilities in dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assess severity** : Prioritize vulnerabilities based on severity and impact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan remediation** : Schedule upgrades or apply patches for affected dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation** : Test the application after upgrades to ensure functionality
    is intact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation** : Keep records of vulnerabilities found and actions taken'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk management** : Balance the urgency of upgrades with the potential impact
    on the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication** : Coordinate with stakeholders to schedule necessary updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fallback plans** : Have strategies in place in case an upgrade introduces
    issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is nothing inherently negative about this process, but there are risks
    that need to be understood.
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to have too many CVEs to mitigate at the same time. When the team
    decides to delay the security tasks, they can accumulate just before a release.
    This is a very common case and can cause important delays to a release.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ever-evolving landscape of cybersecurity necessitates that Java software
    engineers remain vigilant and proactive in managing vulnerabilities within their
    applications. CVEs play a critical role in identifying and communicating known
    security issues, and understanding how to find, document, and remediate them is
    essential.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging tools such as vulnerability scanners and implementing strategies
    such as continuous dependency upgrades, proactive updates, and reactive measures
    based on scan reports, developers can significantly enhance the security posture
    of their applications. Effective dependency management further reduces risks by
    controlling the components integrated into the software.
  prefs: []
  type: TYPE_NORMAL
- en: Staying informed through reputable sources such as the NVD and vendor advisories
    ensures that developers are aware of the latest threats and can act promptly.
    Integrating security practices into the development life cycle transforms security
    from a reactive afterthought into a proactive cornerstone of software development.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, managing CVEs is a multifaceted process that requires diligence,
    strategic planning, and the right tools. By embracing these practices, Java software
    engineers can contribute to creating more secure applications, protecting both
    their organizations and the end-users who rely on their software. In the next
    chapter, we will look at how generative AI can revolutionize the way we write
    tests for APIs, providing insights and techniques
  prefs: []
  type: TYPE_NORMAL
