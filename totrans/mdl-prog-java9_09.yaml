- en: Module Design Patterns and Strategies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块设计模式和策略
- en: 'In the previous few chapters, we did a deep dive into several modularity features
    in Java 9 that enable you to build Java applications with modules. You''ve learned
    how to use the dependency declarations and services to establish module dependencies.
    You''ve also learned how to use jlink to build modular runtimes that can be distributed.
    In this chapter, we''ll look at a slightly less objective concern--how to build
    good applications with modules in Java. Now that you''ve acquired the knowledge
    to create and use modules, what are the recommended ways to do that? What are
    the best practices and patterns that you should use? Here''s what we''ll cover
    in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们深入探讨了Java 9中的几个模块化特性，这些特性使您能够使用模块构建Java应用程序。您已经学习了如何使用依赖声明和服务来建立模块依赖关系。您还学习了如何使用jlink构建可分发的模块化运行时。在本章中，我们将探讨一个稍微不那么客观的问题——如何在Java中使用模块构建良好的应用程序。现在您已经掌握了创建和使用模块的知识，那么推荐的实现方式有哪些？您应该使用哪些最佳实践和模式？以下是本章我们将涵盖的内容：
- en: Understanding how to design modules--what a module should ideally be and where
    module boundaries should be drawn
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何设计模块——一个模块理想上应该是什么样子，以及模块边界应该在哪里划分
- en: Understanding how to design good APIs for those modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何为这些模块设计良好的API
- en: Learning about several best practices to create modules, as well as patterns,
    to use the module system effectively
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解创建模块以及使用模块系统有效性的几个最佳实践
- en: Many of the patterns discussed in this chapter come with usable code examples,
    available in the folder `09-module-patterns`. Each example has been carefully
    crafted to help explain the pattern being discussed with minimal information overhead.
    Feel free to use and experiment with these code examples as you explore these
    patterns. Also, remember to revisit this chapter during your Java 9 modularity
    journey to brush up your knowledge of these patterns. It's often the case that
    rereading and thinking about design patterns at any time offers new perspectives
    to the challenges you have going on at that time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的许多模式都附带可用的代码示例，这些示例位于文件夹`09-module-patterns`中。每个示例都经过精心制作，旨在以最小的信息开销帮助解释正在讨论的模式。在探索这些模式时，请随意使用和实验这些代码示例。此外，记得在您的Java
    9模块化之旅中重新阅读本章，以巩固对这些模式的了解。通常情况下，在任何时候重新阅读和思考设计模式都会为当时面临的挑战提供新的视角。
- en: Let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Designing modules
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模块
- en: Over the years, the first step in designing a Java application has usually involved
    the design of the packages and classes, as well as the interactions between them.
    It also perhaps involved designing some shared libraries. For instance, you'd
    move reusable code into a separate project and bundle it into your application
    as a JAR file. With Java 9 modules, you now have a new aspect to consider that
    significantly impacts the design process. Irrespective of whether you are creating
    a new application from scratch or you are migrating an existing classpath application
    into a modular application, there are some common questions you'll need to answer--How
    do you come up with a modular design? How do you choose what a module should be?
    How much code and functionality should be in a module? Where do you draw module
    boundaries in specific scenarios? For example, a question you might often run
    into is--Given a functionality or a set of classes and packages, should they belong
    to *Module A* or *Module B*? And how do you achieve good design principles for
    modules such as reusability, extensibility and maintainability?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，设计Java应用程序的第一步通常涉及包和类的设计，以及它们之间的交互。也许还涉及设计一些共享库。例如，您会将可重用代码移动到单独的项目中，并将其打包成JAR文件添加到您的应用程序中。随着Java
    9模块的出现，您现在需要考虑一个新的方面，这将对设计过程产生重大影响。无论您是从头创建新应用程序还是将现有的类路径应用程序迁移到模块化应用程序，您都需要回答一些共同的问题——您如何提出模块化设计？您如何选择模块应该包含什么？一个模块应该包含多少代码和功能？在特定场景中，您在哪里划分模块边界？例如，您可能会遇到的一个问题是——给定一个功能或一组类和包，它们应该属于*模块A*还是*模块B*？您如何实现模块如可重用性、可扩展性和可维护性的良好设计原则？
- en: As with most software design challenges, there are no right answers that apply
    for all scenarios. In fact, some of the -ility factors pull against each other,
    and most designs involve making a calculated trade-off. However, having some guidelines
    and best practices should get us started with tackling these challenges that can
    then be refined and tweaked as per specific use cases.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数软件设计挑战一样，没有适用于所有场景的正确答案。事实上，一些-ility因素相互对立，大多数设计都涉及到做出权衡。然而，有一些指导和最佳实践应该能帮助我们开始应对这些挑战，然后可以根据具体用例进行细化和调整。
- en: Among the first steps in designing and building a modular application, it helps
    to have a high level idea of what the modules and APIs will be. For simple projects,
    it can be tempting to just fire off the IDE and start coding. But for anything
    serious, it helps to spend some time and design a rough picture of the modules
    involved, their public APIs and their dependencies on each other before you start
    coding. Let's start looking at some principles and factors to keep in mind when
    designing modules and deciding what it should do.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和构建模块化应用程序的第一步中，对模块和API有一个高层次的想法是有帮助的。对于简单的项目，直接打开IDE开始编码可能很有吸引力。但对于任何严肃的项目，花些时间设计一个涉及模块的粗略图，它们的公共API以及它们之间的依赖关系，在开始编码之前是有帮助的。让我们开始看看在设计模块和决定它们应该做什么时需要考虑的一些原则和因素。
- en: Scoping
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: Perhaps the most obvious way of deciding what makes a module is based on what
    it is about. In other words, its *scope*. If you were to break down any reasonably
    complex application, you'd immediately come up with high level functional areas
    that begin to separate out from each other. For instance, a banking application
    might have account related functionality that's separate from credit functionality
    and so on. In the case of existing Java applications, these different concerns
    might already be under different top-level packages. In the case of new applications,
    the various aspects of the business problem can give us clues. Distinct business
    areas stand out to form an initial high level classification, which can then perhaps
    be broken down into further chunks. So, in our banking example, account functionality
    might be split into savings and checking account functionality, account transfer
    related code, bill pay, and so on. This way of using the business concern to break
    down the application problem domain is a good strategy to get to smaller units
    that can then be good candidates for modules. You'll likely have to go through
    several levels of breaking down the scope until you arrive at a level where each
    unit feels like they could be separate modules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 决定一个模块是什么的最明显的方法可能是基于它的内容。换句话说，它的*范围*。如果你要分解任何合理复杂的应用程序，你会立即想到一些高级功能区域，它们开始相互分离。例如，一个银行应用程序可能有一个与账户相关的功能，与信用功能等其他功能分开。在现有的Java应用程序中，这些不同的关注点可能已经属于不同的顶级包。在新的应用程序中，商业问题的各个方面可以给我们提供线索。不同的商业领域突出形成初始的高级分类，然后可能进一步分解成更小的部分。因此，在我们的银行示例中，账户功能可能被分为储蓄账户和支票账户功能、账户转账相关代码、账单支付等。这种使用业务关注点来分解应用程序问题域的方法是一种很好的策略，可以将应用程序分解成更小的单元，这些单元可能是模块的良好候选者。你可能需要通过几个级别的分解范围，直到你到达每个单元感觉可以单独成为模块的水平。
- en: Note that, while this is a good strategy to start breaking the problem in a
    top-down manner, it doesn't help you decide when to stop breaking things down!
    How do you know if your modules are too big? Or too fragmented? You'll have to
    look at other factors in this section to help make that decision.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然这是一种从上到下开始分解问题的好策略，但它并不能帮助你决定何时停止分解！你如何知道你的模块是否太大？或者太碎片化？你必须查看本节中的其他因素来帮助做出这个决定。
- en: Team structure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队结构
- en: There's a popular adage in software design called **Conway's Law**, which suggests
    that the design of software in any organization is influenced by the structure
    of teams in the organization and the way they communicate with each other. It
    makes perfect sense if you think about it. Software development teams often tend
    to work on isolated libraries and code bases (or at least, code *areas*) that
    *talk* to other libraries and code bases developed by other teams. In a sense,
    there's almost a one-to-one mapping between teams and the set of code assets they
    work on. This can be a valuable factor that influences where module boundaries
    are drawn and how modules designs begin to separate from one another. Each team
    works on one or more modules, and so all the code that a given team would work
    on becomes a part of their set of modules.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计中有一种流行的谚语称为**康威定律**，它表明任何组织的软件设计都受到该组织团队结构以及他们相互沟通方式的影响。如果你这么想，这完全是有道理的。软件开发团队往往倾向于在隔离的库和代码库（或者至少，代码*区域*）上工作，这些库和代码库与其他团队开发的库和代码库进行“交流”。从某种意义上说，团队和他们工作的代码资产集之间存在几乎一对一的映射。这可以是一个有价值的因素，影响模块边界的划分以及模块设计如何开始相互分离。每个团队负责一个或多个模块，因此一个团队会工作的所有代码都成为他们模块集的一部分。
- en: This is useful for a variety of reasons. Teams can work on their code and ship
    out functionality independent of other teams. They are assigned *ownership* of
    modules, so they can handle bug fixes or code maintenance. Additionally, when
    starting out a new project, when two teams need to work on modules where one depends
    on the other, both teams can together come up with an *API contract* that they
    agree with. Then, each team can work on their modules separately and in parallel,
    although the dependent modules are not yet available.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这对各种原因都很有用。团队可以在他们的代码上工作，并独立地发布功能。他们被分配了模块的*所有权*，因此可以处理错误修复或代码维护。此外，当开始一个新的项目时，当两个团队需要在一个团队依赖另一个团队的模块上工作时，两个团队可以共同制定一个他们同意的*API合约*。然后，每个团队可以分别和并行地工作在他们自己的模块上，尽管依赖的模块尚未可用。
- en: Reusability
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用性
- en: 'One of the tenets of modularity is reusability. We earlier used the analogy
    of building blocks to describe modules. The idea of plugging in reusable modules
    together to create different applications is very powerful indeed! In order to
    make modules reusable, they should ideally have the following characteristics:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的一个原则是可重用性。我们之前用积木的比喻来描述模块。将可重用模块组合起来创建不同应用的想法确实非常强大！为了使模块可重用，它们理想上应该具有以下特征：
- en: They should have some specialized and limited responsibility. A module that
    does too many things is hard to reuse effectively.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该有一些专业和有限的职责。一个做太多事情的模块很难有效地重用。
- en: They should be independent--If a module depends on a whole lot of other modules
    to function, it becomes harder to reuse the module itself.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该是独立的--如果一个模块依赖于许多其他模块才能运行，那么重用该模块本身就会变得更加困难。
- en: It should be configurable--If the module is tweak-able and can be made to work
    for different use cases, it makes the module more amenable to reuse.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是可配置的--如果模块可以调整并能够适应不同的用例，这将使模块更容易重用。
- en: 'These characteristics do come with some trade-offs though! Here are a couple
    of them:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性确实带来了一些权衡！以下是一些例子：
- en: Having smaller *specialized* or *single purpose* modules sometimes results in
    very small and fragmented modules, often requiring multiple modules to get anything
    done.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有更小、更专业的或单一用途的模块有时会导致非常小且碎片化的模块，通常需要多个模块才能完成任何工作。
- en: Configurable APIs in modules often results in more complicated APIs, since the
    consumers have to deal with more knobs and levers to tweak and operate in order
    to work with your module. One way to get around this problem is to provide sensible
    defaults and provide configuration just as an override.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块中的可配置API通常会导致更复杂的API，因为消费者必须处理更多的旋钮和杠杆来调整和操作，以便与您的模块一起工作。解决这个问题的方法之一是提供合理的默认值，并提供配置作为覆盖。
- en: Modularizing by concerns
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按关注点进行模块化
- en: 'When designing modules, it''ll be quickly apparent to you that not all modules
    are alike. Modules can be classified into multiple different types depending on
    various characteristics. One such classification can be achieved by their functionality
    or the concerns they address. At the highest level, you can classify modules into
    two different types:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模块时，你会很快发现并非所有模块都相同。模块可以根据各种特征被分类为多种不同类型。一种分类方法可以根据其功能或解决的问题进行分类。在最高层次上，你可以将模块分为两种不同类型：
- en: '**Vertical concerns**: Business and application specific functionality. Solves
    a specific problem in the business domain. For example, the accounts module in
    a banking application.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纵向关注点**：业务和应用特定的功能。解决业务域中的特定问题。例如，银行应用程序中的账户模块。'
- en: '**Horizontal concerns**: Crosscutting functionalities that are not business
    or application specific. Instead, they provide low level functionality or framework
    that''s business-agnostic. For example, logging or security modules.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**横向关注点**：非业务或应用程序特定的交叉功能。相反，它们提供低级功能或与业务无关的框架。例如，日志或安全模块。'
- en: When designing modules, a good rule to try and follow is to not mix these two
    concerns. If you design modules specifically for one of the two concerns, it improves
    clarity and reuse. For example, in the address book application, the module `packt.sortutil`
    provided generic sorting ability while being completely agnostic of what it's
    sorting, thereby addresses a horizontal concern. The module `packt.addressbook`
    deals with specific address book application functionality, thereby addressing
    a vertical concern.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模块时，一个值得尝试遵循的好规则是不要混合这两个关注点。如果你专门为这两个关注点之一设计模块，这将提高清晰度和重用性。例如，在地址簿应用程序中，`packt.sortutil`
    模块提供了通用的排序能力，同时对其排序内容完全不知情，从而解决了横向关注点。`packt.addressbook` 模块处理特定的地址簿应用程序功能，从而解决了纵向关注点。
- en: As you can imagine, the type of module influences its design. For instance,
    reusability wouldn't likely be a primary focus when designing a module addressing
    a vertical concern, but it's vital when designing a module with cross-cutting
    concerns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，模块的类型会影响其设计。例如，当设计解决纵向关注点的模块时，重用性可能不是主要关注点，但在设计具有交叉关注点的模块时，它是至关重要的。
- en: Modularizing by layers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层次化模块化
- en: Another useful factor that can help us draw module boundaries is application
    layers. A typical application involves layers or tiers of functionality like the
    UI layer, business layer, data layer, and so on. That's a great way to draw some
    initial module boundaries before then looking at other categories to modularize
    further. A module should ideally not be a part of multiple application tiers.
    Sometimes, different tiers are deployed on different physical hardware. So, having
    tier separations guide module boundaries make logistical sense as well when it
    comes to deployments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有助于我们确定模块边界的有用因素是应用程序层。一个典型的应用程序涉及功能层或级别，如UI层、业务层、数据层等。在查看其他类别以进一步模块化之前，这是一种绘制一些初始模块边界的好方法。理想情况下，模块不应是多个应用程序层的组成部分。有时，不同的层部署在不同的物理硬件上。因此，在部署时，具有层分离来指导模块边界在物流上也是有意义的。
- en: Modularizing by change patterns
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过变更模式进行模块化
- en: An approach that I've found helpful to verify module boundaries is analyzing
    patterns of new feature additions to your application. If most of the typical
    changes you make to your code base involves having to modify multiple modules,
    that might be a clue that your modules are too fragmented or the separation of
    modules could be better. It's OK if you are modifying multiple low-level modules
    (that is, with horizontal concerns) for an average code change or enhancement.
    But if each change or enhancement to your application requires you to modify too
    many modules with vertical concerns, you might want to re-look at the module boundaries
    and see if those different modules contain code that should ideally be together
    in the same module.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现分析应用程序新功能添加的模式有助于验证模块边界。如果你对代码库所做的典型更改大多需要修改多个模块，这可能是一个线索，表明你的模块过于碎片化，或者模块的分离可以更好。如果你在平均代码更改或增强时需要修改多个低级模块（即具有横向关注点的模块），这是可以接受的。但是，如果你的应用程序的每个更改或增强都需要你修改具有纵向关注点的多个模块，你可能需要重新审视模块边界，看看这些不同的模块是否包含应该理想地放在同一模块中的代码。
- en: Designing API
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计API
- en: We've looked at some guidelines and tips for drawing module boundaries and creating
    modules. How about the process of creating APIs? This might seem obvious, but
    the standard best practice of a separate public API and private implementation
    still applies here.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了一些关于绘制模块边界和创建模块的指南和技巧。那么创建 API 的过程呢？这可能会显得很明显，但分离公共 API 和私有实现的最佳实践仍然适用。
- en: 'The goal when designing the module API is to expose a standard, consistent,
    and possibly unchanging programming interface as the **public** API of the module.
    The details of implementation that are internal to the module should be encapsulated.
    This is, in principle, no different from method and member variable encapsulation
    for classes. Design a public API for your modules that you want the consumers
    to work with. The implementation details are hidden in encapsulated packages and
    serve two purposes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模块 API 的目标是公开一个标准、一致且可能不会改变的编程接口，作为模块的 **公共** API。模块内部实现的细节应该被封装。在原则上，这与类的方法和成员变量封装没有区别。为你的模块设计一个公共
    API，让消费者可以与之交互。实现细节隐藏在封装的包中，并有两个目的：
- en: To reduce and simplify effort for the consumer so that they don't have to know
    the internals
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少和简化消费者的工作量，使他们不必了解内部细节
- en: To allow the module to change and evolve the implementation without having an
    impact on the consumers of the module
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许模块在不影响模块消费者的情况下更改和演进实现
- en: Java modules coding patterns and strategies
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 模块编码模式和策略
- en: We've so far looked at some general higher level, almost common-sensical patterns,
    that apply to modularity in Java. Now let's dive into code. Let's look at some
    code patterns and strategies that can help you as you as you start designing modules
    and their APIs. Each of these strategies are presented with explanation about
    the pattern, why and when you should consider using them. Many of them have accompanying
    code examples for you to refer to. Some of these might be obvious. In fact, we've
    even applied some of the patterns when building the sample address book application
    we've worked on in this book. I hope this consolidated list provides you with
    a good reference to these patterns when designing and building modular applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止已经查看了一些适用于 Java 模块化的通用高级、几乎是常识性的模式。现在让我们深入代码。让我们看看一些代码模式和策略，这些可以帮助你在开始设计模块及其
    API 时。每个策略都附有关于模式的解释，以及为什么和何时应该考虑使用它们。其中许多都有伴随的代码示例供你参考。其中一些可能很明显。事实上，我们在构建本书中工作的示例地址簿应用程序时也应用了一些模式。我希望这个综合列表为你提供了在设计构建模块化应用程序时参考这些模式的好参考。
- en: Pattern 1 - Public interface, private implementation, and factory class
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 1 - 公共接口、私有实现和工厂类
- en: Separate the public API from the internal encapsulated implementation (we've
    already seen this strategy implemented in the sorting utility module of the address
    book viewer application earlier in the book). Also, expose a factory API method
    that creates new instances of the interface.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将公共 API 与内部封装的实现分离（我们已经在本书早期关于地址簿查看器应用程序的排序实用模块中看到了这种策略的实施）。此外，公开一个工厂 API 方法，该方法创建接口的新实例。
- en: 'Here''s how it works:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: The exported types are interfaces or abstract classes that are as lightweight
    as possible.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出的类型是尽可能轻量级的接口或抽象类。
- en: The classes that contain the actual logic implement the interfaces in the exported
    packages. These types are not exported. Thus, all the implementation details are
    safely hidden away.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含实际逻辑的类实现了导出包中的接口。这些类型没有被导出。因此，所有实现细节都安全地隐藏起来。
- en: There are factory classes in the exposed packages that form the APIs. These
    create a new instance of the right implementation class. The return types of these
    factory APIs deal with interfaces only.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在公开的包中存在工厂类，这些类构成了 API。它们创建正确的实现类的新实例。这些工厂 API 的返回类型仅处理接口。
- en: Example
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'A sample implementation of this pattern is available in the folder `09-module-patterns/01-seperate-interface-impl`.
    The module `pattern.one` has the interface `PublicInterface` exposed in the `pattern.one.external`
    package, while the implementation classes `PrivateImplA` and `PrivateImplB` are
    in the encapsulated `pattern.one.internal` package:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的示例实现可在文件夹 `09-module-patterns/01-seperate-interface-impl` 中找到。模块 `pattern.one`
    在 `pattern.one.external` 包中公开了接口 `PublicInterface`，而实现类 `PrivateImplA` 和 `PrivateImplB`
    则在封装的 `pattern.one.internal` 包中：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''d like the consuming modules to access the private instances through the
    public interface type. To facilitate this, there''s a factory class `Factory`
    exposed by the module. This class has a public method `getApiInstance` that takes
    in an argument and then based on the value, returns the right implementation class.
    In the sample code, there''s a simple `boolean` flag that affects whether one
    implementation instance is returned over another, but in a real-world module,
    this selection criteria would be more meaningful to what''s returned, as this
    is how the consumer picks the right API instance based on their requirements.
    The return type of the factory method is an instance of the public interface.
    Thus, the consumer module doesn''t know about the implementation details:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望消费模块通过公共接口类型访问私有实例。为此，模块提供了一个名为`Factory`的工厂类。这个类有一个公共方法`getApiInstance`，它接受一个参数并根据该值返回正确的实现类。在示例代码中，有一个简单的`boolean`标志，它影响是否返回一个实现实例而不是另一个，但在实际模块中，这个选择标准对返回的内容更有意义，因为消费者正是根据他们的需求选择正确的API实例。工厂方法的返回类型是公共接口的实例。因此，消费模块不知道实现细节：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Benefits:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Hides the details from the consumer so that they don't have to know the internals
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏了细节，以便消费者不必了解内部情况
- en: Allows you to change the implementation or add new implementation types without
    the consumers having to change the way they interact with the module
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在不改变消费者与模块交互方式的情况下更改实现或添加新的实现类型。
- en: Pattern 2 - Services for multiple dynamic implementations
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式2 - 多个动态实现的服务
- en: An alternative way to abstract implementation types is to use them as services.
    This is an extension of the previous pattern, but while ensuring more loosely
    coupled and dynamic implementations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象实现类型的一个替代方法是使用它们作为服务。这是对之前模式的扩展，但同时也确保了更松散耦合和动态的实现。
- en: 'Here''s how it works:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的工作原理：
- en: There's a service interface module that exposes the service interface type.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个服务接口模块，它公开了服务接口类型。
- en: One or more *service* implementation modules provide implementations for that
    service using the `provides` clause in the module definition.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个服务实现模块使用模块定义中的`provides`子句为该服务提供实现。
- en: The consumer module does not directly depend on the implementation modules.
    It `requires` only the service interface module and declares that it `uses` the
    service.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者模块不直接依赖于实现模块。它`requires`只服务接口模块，并声明它`uses`服务。
- en: Code in the consumer module looks up service instances using the `ServiceLoader`
    API.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者模块使用`ServiceLoader` API查找服务实例。
- en: Example
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'The sample code implementation is available at  `09-module-patterns/02-services`.
    The `pattern.two.service` module exports the `PublicInterface`. It doesn''t contain
    any implementation classes of its own:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码实现可在`09-module-patterns/02-services`处找到。`pattern.two.service`模块导出`PublicInterface`。它不包含任何自己的实现类：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Two implementation modules `pattern.two.implA` and `pattern.two.implB` both
    contain implementations of the service that are declared using `provides` in the
    module declaration. Both implementation modules `require` the service module `pattern.two.service`
    to access the interface. Here''s how the module definition for one of the implementation
    modules looks like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 两个实现模块`pattern.two.implA`和`pattern.two.implB`都包含使用模块声明中的`provides`声明的服务实现。这两个实现模块都`require`服务模块`pattern.two.service`以访问接口。以下是其中一个实现模块的模块定义：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The consumer module also depends on the service interface module, and *not*
    on the implementation modules. The `uses` clause in the module definition indicates
    that the module will need to look up the service:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者模块也依赖于服务接口模块，而不是实现模块。模块定义中的`uses`子句表明模块将需要查找服务：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Benefits:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Provides an additional layer of abstraction between the service consumer and
    provider logic.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务消费者和提供者逻辑之间提供了一层额外的抽象。
- en: Completely loose coupling between consumer and implementation modules. There's
    no hard-wired `requires` dependency on the implementation modules.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者模块与实现模块之间完全松散耦合。没有对实现模块的硬编码`requires`依赖。
- en: Flexibility in the implementation options available. Modules can be dropped
    in the module path at runtime, and as long as they implement and provide the service
    interface, they can be plugged in to the application.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现选项中的灵活性。模块可以在运行时添加到模块路径中，只要它们实现了并提供服务接口，就可以将其连接到应用程序。
- en: Pattern 3 - Optional dependencies
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 3 - 可选依赖
- en: We've seen how Java did not have an option for reliable configuration up until
    Java 9\. You could add or remove certain classes and JARs from the classpath before
    running and the application would still execute (or at least, starts executing)!
    There are some utility libraries and frameworks in Java that have made good use
    of this flexibility.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，直到 Java 9，Java 没有可靠的配置选项。你可以在运行之前添加或删除某些类和 JAR 文件到类路径中，应用程序仍然可以执行（或者至少，开始执行）！Java
    中有一些实用库和框架很好地利用了这种灵活性。
- en: Consider the Spring Framework. Spring is a popular application framework that
    uses and orchestrates functionality across a lot of other dependent libraries
    and frameworks by scanning the classpath for available libraries that it can work
    with. If you'd like Spring to use some of these supported libraries, just dropping
    certain necessary jars into the classpath is enough for Spring to pick it up and
    use its functionality. And if you don't, the Spring framework can still function
    without them, albeit without the optional functionality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Spring 框架为例。Spring 是一个流行的应用程序框架，它通过扫描类路径中可用的库来使用和编排许多其他依赖库和框架的功能。如果你想让 Spring
    使用这些支持的库，只需将某些必要的 JAR 文件添加到类路径中就足够 Spring 检测并使用其功能。如果不使用，Spring 框架仍然可以工作，尽管没有可选功能。
- en: This flexibility plays an important role in the ease of use of these frameworks.
    Now, with Java 9 and strict requirements for module dependencies, wouldn't we
    be losing this flexibility? There's no optionally dropping jars into the classpath
    anymore! Things are much more strict and controlled now. Every module that a given
    module needs should be explicitly specified with a `requires` clause in the module
    definition. Given this new state of affairs, how could you build such modules
    that are optional and with *drop-in* flexibility?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性在框架的易用性中起着重要作用。现在，随着 Java 9 和对模块依赖的严格要求，我们不会失去这种灵活性吗？现在不再可以随意将 JAR 文件添加到类路径中！事情现在变得更加严格和受控。给定模块需要的每个模块都应该在模块定义中使用
    `requires` 子句明确指定。考虑到这种新的情况，你该如何构建这样的模块，它们是可选的并且具有 *即插即用* 的灵活性？
- en: 'The answer is optional dependencies. In Java 9, you can specify a given module
    dependency as optional by using the `requires static` qualifier. The syntax is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是可选依赖。在 Java 9 中，你可以使用 `requires static` 修饰符指定一个给定的模块依赖为可选。语法是：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `static` qualifier tells the module system that the module `required` is
    optional. The module should still be available at compile time (because `javac`
    needs to compile the code and references after all!). But it is optional at runtime.
    If the module isn't available during runtime, `java` won't complain about the
    module's unavailability like it would with the `requires` only clause. It proceeds
    with execution assuming you know what you are doing. This new feature enables
    you to have modules with a bunch of `require static` optional dependencies, which
    can be freely dropped into the module path.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 修饰符告诉模块系统被 `required` 的模块是可选的。模块在编译时仍然应该可用（因为 `javac` 需要编译代码和引用！）。但在运行时它是可选的。如果在运行时模块不可用，`java`
    不会像只有 `requires` 子句那样对模块的不可用性进行抱怨。它会继续执行，假设你知道你在做什么。这个新特性使你能够拥有带有许多 `require static`
    可选依赖的模块，这些模块可以自由地添加到模块路径中。'
- en: 'Here''s how it works:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何工作的：
- en: When you have a module that optionally depends on one or more modules, use the
    `requires static` clause to establish optional dependency in the module definition.
    If *module A* optionally requires *module B*, you specify `requires static B`
    in module A's definition.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你有一个模块可选地依赖于一个或多个模块时，使用 `requires static` 子句在模块定义中建立可选依赖。如果 *模块 A* 可选地需要 *模块
    B*，你应在模块 A 的定义中指定 `requires static B`。
- en: During development and compile time, you don't *have* to do anything different.
    You could use the exported types from the optional dependencies just like a regular
    `requires` dependency. As always, the module(s) with the optional dependency needs
    to be available at compile time for the code to compile.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发和编译时间，你不需要做任何不同的事情。你可以像使用常规 `requires` 依赖项一样使用可选依赖项导出的类型。始终如一，带有可选依赖项的模块需要在编译时可用，以便代码可以编译。
- en: At runtime however, things are different. This time, you can execute your application
    irrespective of whether the module with the optional dependency is available or
    not. If the module is available, it gets picked up fine. But if it isn't, you
    get a `NoClassDefFound` error. While it's not mandatory, it's a good idea to write
    code to handle this error scenario, in case the module you optionally require
    isn't available.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，在运行时，情况就不同了。这次，无论带有可选依赖项的模块是否可用，你都可以执行你的应用程序。如果模块可用，它会被正常选中。但如果它不可用，你会得到一个
    `NoClassDefFound` 错误。虽然这不是强制性的，但编写代码来处理这种错误场景是个好主意，以防你可选需要的模块不可用。
- en: Example
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider the sample code at `09-module-patterns/03-optional-dependencies`.
    The `pattern.three` is a module that optionally requires `pattern.three.optlib`.
    It uses the optional library if available, but the module is perfectly happy if
    it isn''t available at runtime. To establish this optional nature of this dependency,
    `pattern.three` uses the `requires static` clause:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在 `09-module-patterns/03-optional-dependencies` 中的示例代码。`pattern.three` 是一个可选需要
    `pattern.three.optlib` 的模块。如果可用，它将使用可选库，但如果在运行时不可用，模块也会非常高兴。为了建立这种依赖项的可选性质，`pattern.three`
    使用了 `requires static` 子句：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `pattern.three.optlib` has a simple library class that prints a message
    to the console. Nothing surprising here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`pattern.three.optlib` 有一个简单的库类，它会向控制台打印一条消息。这里没有什么令人惊讶的：'
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, the code in the module `pattern.three` can directly import and use the
    exported types of the optional module (in this case, `LibImpl`). But this is not
    a good idea. By specifying that a dependency is optional, you are essentially
    asking the platform to let go of its reliable configuration guarantee and to *not*
    check and ensure that the module is available. This opens the possibility that
    this dependency is not satisfied at runtime. For this reason, it's the responsibility
    of the module now to be able to handle both the presence and absence of the module.
    Rather than have the `NoClassDefFound` error thrown to the user, we can be smart
    about using the optional types only if they are available. We can use the `Class.forName`
    API to examine if the class does exist.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，模块 `pattern.three` 中的代码可以直接导入和使用可选模块（在这种情况下，`LibImpl`）导出的类型。但这不是一个好主意。通过指定一个依赖项是可选的，你实际上是在要求平台放弃其可靠的配置保证，并且不要检查和确保模块可用。这打开了这种依赖项在运行时不满足的可能性。因此，现在模块有责任能够处理模块的存在和不存在。我们不必将
    `NoClassDefFound` 错误抛给用户，我们可以聪明地使用可选类型，如果它们可用的话。我们可以使用 `Class.forName` API 来检查类是否存在。
- en: 'This is the code in the `Util` class in module `pattern.three`. This is one
    way to reflect and use the types from optional dependencies:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模块 `pattern.three` 中 `Util` 类的代码。这是从可选依赖中反射和使用类型的一种方法：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As with the previous examples, we have a `consumer` module that requires `pattern.three`
    and has a `Main` type that calls the module's API. Before executing the application,
    here's another important thing for you to know about optional dependencies. They
    don't get picked up in the module resolution process! So, we'll have to explicitly
    add the module to the execution process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，我们有一个 `consumer` 模块，它需要 `pattern.three` 并有一个 `Main` 类型，该类型调用模块的 API。在执行应用程序之前，这里还有关于可选依赖的另一件重要的事情需要你知道。它们在模块解析过程中不会被选中！因此，我们必须显式地将模块添加到执行过程中。
- en: In [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb), *Understanding
    Linking and Using* *jlink*, we discussed the module resolution process and how
    the Java Platform resolves the tree of dependencies by recursively fetching all
    dependent modules that are required in the module definition. It doesn't do that
    for optional dependencies! During the module resolution process, if the runtime
    encounters the `requires static` dependency, it does not resolve that module and
    its dependencies. These optional modules could be compiled and ready, sitting
    in the module path along with the other modules, but the runtime still doesn't
    see it. This brings up an interesting problem. How does the Java runtime know
    that these optional modules exist in the module path if it doesn't even look it
    up?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb)中，我们讨论了模块解析过程以及Java平台如何通过递归获取模块定义中所需的所有依赖模块的树结构。它不会对可选依赖项做这件事！在模块解析过程中，如果运行时遇到`requires
    static`依赖项，它不会解析那个模块及其依赖项。这些可选模块可能已经编译并准备好，与其他模块一起位于模块路径中，但运行时仍然看不到它们。这引发了一个有趣的问题。如果运行时不查找，Java运行时如何知道这些可选模块存在于模块路径中呢？
- en: The solution is to add the modules manually into the module resolution process.
    Remember the `--add-modules` option we passed to `jlink` in [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Understanding Linking and Using* *jlink*? We used that flag to have `jlink` include
    modules to the resolution process. The `java` command too has that flag available
    to include modules. So, to have the runtime *see* and use the optional modules,
    we'll need to add it using the `--add-modules` flag.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将模块手动添加到模块解析过程中。记得我们在[第8章](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb)中传递给`jlink`的`--add-modules`选项吗？我们使用那个标志让`jlink`将模块包含到解析过程中。`java`命令也有那个标志，可以用来包含模块。因此，为了让运行时*看到*并使用可选模块，我们需要使用`--add-modules`标志。
- en: 'You can compile the example code with the `javac` command as usual. No changes
    here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`javac`命令像往常一样编译示例代码。这里没有变化：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When running, however, you need to add all the modules that are optional dependencies
    using the `--add-modules` flag. Here, `pattern.three.optlib` is the optional dependency.
    So, here''s the command you use to execute the `Main` class in the `consumer`
    module and the resulting output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在运行时，你需要使用`--add-modules`标志添加所有可选依赖项的模块。在这里，`pattern.three.optlib`是可选依赖项。因此，以下是执行`consumer`模块中的`Main`类的命令以及相应的输出：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Try removing the compiled `pattern.three.optlib` module from the `out` directory
    and run it again without the `-add-modules` option:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从`out`目录中移除编译好的`pattern.three.optlib`模块，然后不带`-add-modules`选项再次运行：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time, you get the *fallback* code executed because the necessary class
    isn't available. The important distinction here is that the code still runs. It
    wouldn't have if the dependency wasn't optional.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，由于必要的类不可用，执行了*回退*代码。这里的重要区别是代码仍然可以运行。如果依赖项不是可选的，它就不会运行。
- en: 'The `--add-modules` parameter is sensitive to the order, in that it should
    appear *before* the `-m` parameter. So, the following command will not work:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`--add-modules`参数对顺序很敏感，它应该出现在`-m`参数之前。因此，以下命令将不会工作：'
- en: '`java --module-path out -m consumer/app.Main --add-modules out/pattern.three.optlib
    # Doesn''t work`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`java --module-path out -m consumer/app.Main --add-modules out/pattern.three.optlib
    # 不起作用`'
- en: 'Benefits:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Allows you to create libraries that are *plug-and-play*. You can create a *main*
    library module that depends on additional modules optionally, thereby providing
    runtime flexibility in the modules and functionality that are actually a part
    of the execution.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你创建*即插即用*的库。你可以创建一个*主*库模块，它可选地依赖于其他模块，从而在模块和功能方面提供运行时灵活性，这些模块和功能实际上是执行的一部分。
- en: Pattern 4 - Optional dependencies using services
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 4 - 使用服务处理可选依赖项
- en: While reading about optional module dependencies, a thought might have occurred
    to you--how about using services? We've learned in [Chapter 7](part0110.html#38STS0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Services*, about how using services in Java modules provides a flexible
    and loosely coupled way of having modules work with each other. With services,
    you don't have to specify a readability relationship with `requires`. Modules
    that provide services are optional, not just in runtime, but also during compile
    time! So aren't services already better than optional dependencies?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读关于可选模块依赖关系时，你可能会有一个想法——使用服务怎么样？我们在[第7章](part0110.html#38STS0-ed2405f4162b4f86b565edd6b6d679fb)，“介绍服务”，中学习了如何在Java模块中使用服务提供一种灵活且松散耦合的方式，使模块能够相互协作。使用服务，你不必使用`requires`指定可读性关系。提供服务的模块在运行时是可选的，甚至在编译时也是可选的！所以服务难道不是已经比可选依赖更好了吗？
- en: The simple answer is yes. Services are definitely the preferred way of decoupling
    modules and removing *hard* dependencies. This is what we'll examine in this pattern.
    However, they do have a problem and won't work as well as you'd imagine. Let's
    explore why.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的答案是肯定的。服务无疑是解耦模块和移除*硬依赖*的首选方式。这正是我们将要在这个模式中探讨的。然而，它们确实存在一个问题，并且不会像你想象的那样工作得很好。让我们来看看原因。
- en: 'Here''s how it works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: When using services, you typically achieve abstraction by creating two types--the
    interface (which *is* the service) and the implementations of the interface (which
    are the providers of the service). You don't *have* to do this, of course. You
    can have a Java class itself be the service type. But what we are discussing now
    applies to that too.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用服务时，你通常通过创建两种类型来实现抽象——接口（即服务）和接口的实现（即服务的提供者）。当然，你不必这样做。Java类本身也可以是服务类型。但我们现在讨论的也适用于这种情况。
- en: 'Given two modules A and B, if you''d like module A to optionally depend on
    B, you could use the previous pattern and use `requires static B` in the module
    definition of A. However, if you''d like to use services, you''ll need to assign
    one or more Java interfaces or classes as *service types*. The `module A` needs
    to specify that it `uses` these types:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个模块A和B，如果你想使模块A可选地依赖于B，你可以使用之前的模式，并在A的模块定义中使用`requires static B`。然而，如果你想使用服务，你需要指定一个或多个Java接口或类作为*服务类型*。`模块A`需要指定它`使用`这些类型：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And `module B` needs to `provide` the services:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 而`模块B`需要`提供`服务：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, B is technically optional. The application can run irrespective of whether
    module B exists in the module path or not! Seems simple enough, doesn't it? But
    there's a catch! Which module should the service type reside in? Is it module
    A or module B? It cannot be module B, because in that case, module A would need
    to *require* module B to access the service type in B, which defeats the whole
    purpose of making B optional! It could reside in module A, but now module B should
    depend on module A to access the service type. Thus module B `requires` A and
    module A `exports` the package containing the service type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，B在技术上来说是可选的。应用程序可以在模块路径中是否存在模块B的情况下运行！看起来很简单，不是吗？但有一个陷阱！服务类型应该放在哪个模块中？是模块A还是模块B？它不能放在模块B中，因为在这种情况下，模块A将需要*要求*模块B来访问B中的服务类型，这违背了使B可选的整个目的！它可以放在模块A中，但现在模块B应该依赖于模块A来访问服务类型。因此，模块B
    `需要` A，而模块A `导出` 包含服务类型的包。
- en: But wait! Our original goal was to make module A optionally depend on B. What
    we've ended up with now is module B depending on A! That seems the wrong way around,
    but if you think about the service dynamic, A is still using the implementation
    provided by B, and B is only dependent on A to get the service type. It is still
    confusing and it's not obvious what's going on just by looking at the module definitions.
    One way to solve the problem is to move the service types to a third `module C`
    which is required by both A and B. Now both A and B have access to the service
    types, and thus, are fully decoupled. This option might not always be feasible,
    and it is awkward to have a separate module just to solve this problem. But when
    it *is* possible, this approach of using services is one of the best ways to achieve
    flexibility and the *drop-anything-you-need* mechanism that exists with some libraries
    and frameworks in Java 8 and earlier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！我们的原始目标是让模块A可选地依赖于B。现在我们得到的却是模块B依赖于A！这似乎是反过来的，但如果您考虑服务动态，A仍然在使用B提供的实现，而B只是依赖于A来获取服务类型。这仍然很令人困惑，仅通过查看模块定义并不能明显看出发生了什么。解决这个问题的方法之一是将服务类型移动到一个第三方的`模块C`，这个模块同时被A和B所依赖。现在A和B都可以访问服务类型，因此它们是完全解耦的。这种方案可能并不总是可行，而且仅仅为了解决这个问题而创建一个单独的模块显得有些尴尬。但是，当它确实可行时，这种使用服务的方法是实现灵活性和Java
    8及更早版本中一些库和框架所具有的`drop-anything-you-need`机制的最佳方法之一。
- en: Example
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: Look at the sample code at `09-module-patterns/04-optional-dependencies-with-services`.We
    have two modules, `pattern.four` and `pattern.four.optlib`. We want `pattern.four`
    to optionally depend on `pattern.four.optlib` using the services pattern we've
    seen so far.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看`09-module-patterns/04-optional-dependencies-with-services`目录下的示例代码。我们有两个模块，`pattern.four`和`pattern.four.optlib`。我们希望`pattern.four`能够使用我们之前看到的模式，可选地依赖于`pattern.four.optlib`。
- en: 'The module `pattern.four` contains a service type `LibInterface` that it exports.
    It also declares that it uses provider implementations of `LibInterface`, which
    is what essentially makes `LibInterface` a service type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`pattern.four`包含一个导出的服务类型`LibInterface`。它还声明它使用`LibInterface`的提供者实现，这本质上使得`LibInterface`成为一个服务类型：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The module `pattern.four.optlib` provides an implementation of the `LibInterface`
    service type. It also depends on `pattern.four` to access the service type in
    the first place. This is the seemingly inverted relationship we discussed earlier:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`pattern.four.optlib`提供了`LibInterface`服务类型的实现。它还依赖于`pattern.four`以首先访问服务类型。这正是我们之前讨论的看似颠倒的关系：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There''s a class `LibImpl` in `pattern.four.optlib` that implements `LibInterface`
    as declared in the preceding module definition:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pattern.four.optlib`中有一个名为`LibImpl`的类，它实现了在前面模块定义中声明的`LibInterface`接口：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The module `pattern.four` is now totally unaware of `pattern.four.optlib`.
    It uses the `ServiceLoader` API to get any available instances, and if the optional
    module is available, it''s happy to use it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，模块`pattern.four`对`pattern.four.optlib`一无所知。它使用`ServiceLoader` API来获取任何可用的实例，如果可选模块可用，它将乐意使用它：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Benefits:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Extends the *plug-and-play* concept that the previous pattern solved and adds
    a new level of decoupling. Modules can be optional both at compile time and runtime!
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展了之前模式解决的`即插即用`概念，并增加了新的解耦层次。模块在编译时和运行时都可以是可选的！
- en: Extends the one-to-one dependency of `requires static` with the services providing
    one-to-many dependency. There could be multiple modules providing services that
    are optionally picked up by the module using the services.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展了`requires static`的一对一依赖关系，通过服务提供一对多依赖关系。可能有多个模块提供服务，这些服务可以被使用服务的模块可选地获取。
- en: Pattern 6 - Bundle model classes as separate sharable modules
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式6 - 将模型类作为独立的可共享模块捆绑
- en: It's common for many enterprise applications to deal with multiple layers and
    tiers. They usually need to communicate and share data among them, and a frequently
    used pattern is to exchange data using model objects or **Data Transfer Objects**
    (**DTOs**). They are an example of code that needs to be shared across multiple
    layers and modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业应用程序通常需要处理多层和层。它们通常需要在这些层之间进行通信和共享数据，一个常用的模式是使用模型对象或**数据传输对象**（**DTOs**）来交换数据。它们是需要跨多个层和模块共享的代码的例子。
- en: A good pattern to follow is to create separate modules just for the model (or
    DTO) classes. These modules can then be read by any module that needs access to
    those types. This could be a lightweight module containing just the model classes
    and not much else.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是为模型（或 DTO）类创建单独的模块。然后，任何需要访问这些类型的模块都可以读取这些模块。这可能是一个只包含模型类而没有其他内容的轻量级模块。
- en: Pattern 7 - Open modules for reflection
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 7 - 开放模块以进行反思
- en: Reflection is an important feature in the Java programming language, allowing
    the ability to inspect and modify types dynamically at runtime. This is another
    feature that has been put to good use by frameworks such as Spring, Hibernate,
    and others. These frameworks use reflection to examine your classes for annotations
    and interface implementations to infer information about how to treat your code.
    You might use reflection in your own code to achieve this dynamic functionality.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是 Java 编程语言中的一个重要特性，允许在运行时动态地检查和修改类型。这是另一个被 Spring、Hibernate 等框架以及其他框架充分利用的特性。这些框架使用反射来检查你的类以查找注解和接口实现，以推断如何处理你的代码。你可能在自己的代码中使用反射来实现这种动态功能。
- en: How does reflection fit into the concepts of modularity we've learned so far?
    Like we've seen before, the default behavior of strong encapsulation that protects
    types in a module from static access offers similar protection for reflective
    access as well. A Java type can be accessed through reflection if it's in a module
    that exports it, and the type calling the reflection API is in a module that reads
    the other module.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 反射如何融入我们迄今为止所学的模块化概念？就像我们之前看到的那样，强封装的默认行为保护模块中的类型免受静态访问，同时也为反射访问提供了类似的保护。如果一个
    Java 类型在一个导出它的模块中，并且调用反射 API 的类型在读取其他模块的模块中，那么这个类型可以通过反射访问。
- en: This results in a potential problem because of how reflection has been traditionally
    used in Java, especially in many of the frameworks like we've mentioned earlier.
    Frameworks like Spring expect to scan through your entire code base looking for
    classes that are annotated with certain key annotations. A lot of reflection API
    usage in Java code bases over the years have been implemented with an implicit
    understanding that the classes being reflected on are available for them to access.
    Once you move those types into modules, all the encapsulated types are effectively
    sealed off and not available for reflection. One easy solution is to expose everything!
    So, every module exposes all types that need to be accessed reflectively. But
    this is not a good idea because of the concept of the module API we've discussed
    earlier. The type that a module exposes using the `exports` clause is the module
    API. By exposing an otherwise private type just because it contains an annotation
    for the Spring framework, Hibernate, JPA, or any other such framework that uses
    reflection, we are adversely impacting the API of the module and the purpose of
    string encapsulation is defeated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了由于反射在 Java 中传统使用方式的问题，尤其是在我们之前提到的许多框架中。例如，Spring 框架期望扫描整个代码库以查找带有特定关键注解的类。多年来，Java
    代码库中大量的反射 API 使用都是基于一个隐含的理解，即被反射的类对他们来说是可访问的。一旦你将这些类型移动到模块中，所有封装的类型实际上都被封闭起来，无法用于反射。一个简单的解决方案是暴露一切！所以，每个模块都暴露了所有需要通过反射访问的类型。但这不是一个好主意，因为我们之前讨论的模块
    API 概念。一个模块使用 `exports` 子句暴露的类型是模块 API。仅仅因为一个类型包含 Spring 框架、Hibernate、JPA 或任何其他使用反射的类似框架的注解，就将其暴露出来，这会不利于模块的
    API，并且违反了封装的目的。
- en: To address this issue and to still provide an option of using reflection with
    such frameworks, the platform has introduced a concept called **open modules**.
    These are a type of Java modules that still encapsulate types like we are familiar
    with, but with one major difference. The encapsulated types in these open modules
    are available for reflective access at runtime, without you having to allow compile-time
    access that an `exports` declaration would have provided.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，并且仍然提供使用这些框架进行反射的选项，平台引入了一个称为 **开放模块** 的概念。这些是类似于我们熟悉的 Java 模块，但有一个主要区别。这些开放模块中的封装类型在运行时可用于反射访问，而无需允许
    `exports` 声明提供的编译时访问。
- en: 'How do you make a Java module an *open module*? Very simple. Just add the `open`
    keyword in front of the module definition in `module-info.java`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将一个 Java 模块变成一个 *开放模块*？非常简单。只需在 `module-info.java` 中模块定义前添加 `open` 关键字：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this, the contents of the module are still encapsulated (except for any
    packages that you `export` in the module definition). But all the packages in
    the module are now available for access at runtime using reflection by any module
    that reads this module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，模块的内容仍然是封装的（除了在模块定义中导出的任何包之外）。但现在，模块中的所有包都可通过任何读取此模块的模块在运行时使用反射进行访问。
- en: Remember that the `open` keyword doesn't make the module open for reflective
    access for all modules. A module that needs to access any such types using reflection
    will still need to *read* the module that contains the type using the `requires` keyword.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`open`关键字不会使模块对所有模块都开放以进行反射访问。需要使用反射访问任何此类类型的模块仍然需要使用`requires`关键字来读取包含该类型的模块。
- en: 'Not only entire modules, but even individual packages can be marked as open
    with the  `opens` keyword followed by the specific package you''d like to open
    for reflection. This provides more fine-grained control when you know that there
    are only certain classes in the module that need to be reflected upon:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅整个模块，甚至单个包也可以使用`opens`关键字标记为开放，后跟你希望对反射开放的特定包。当你知道模块中只有某些类需要被反射时，这提供了更细粒度的控制：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, the package `package.one` is available for reflection
    by all modules that read module `modulename`. The package `package.two` is available
    for reflective access only by module `anothermodule`, if it chooses to *require*
    it. And package `package.three` is available for both reflective and compile-time
    access because it is exported.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，包`package.one`对所有读取`modulename`模块的模块都可用于反射。包`package.two`仅对选择`require`它的`anothermodule`模块可用于反射访问。而包`package.three`既可用于反射访问也可用于编译时访问，因为它被导出了。
- en: Example
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: In the sample code at `09-module-patterns/06-open-modules`, the module `pattern.six`
    contains the type `Contact.java` in the package `pattern.six.internal`. Let's
    assume we'd like for this class to be internal to the module and not exposed.
    However, we'd like to be able to access the `Contact` class reflectively from
    another module `consumer`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`09-module-patterns/06-open-modules`的示例代码中，模块`pattern.six`在其`pattern.six.internal`包中包含类型`Contact.java`。让我们假设我们希望这个类在模块内部是内部的，而不是公开的。然而，我们希望能够从另一个模块`consumer`反射地访问`Contact`类。
- en: 'Here''s the code in the `consumer` module that is doing reflection:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`consumer`模块中执行反射的代码：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The consumer module establishes a dependency on the module `pattern.six` first:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者模块首先建立对模块`pattern.six`的依赖关系：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But that's not enough! The module `pattern.six` should either export the type
    or declare that it's an open module.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够！模块`pattern.six`应该导出类型或声明它是一个开放模块。
- en: 'Here''s how the module definition for `pattern.six` looks like:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`pattern.six`模块定义的示例：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the contents of the module aren't technically exported, so the types
    in the module are still encapsulated for static access. However, since the module
    is open, the types are available for reflection. Running `Main` in the `consumer`
    module should work now.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模块的内容实际上并没有被导出，所以模块中的类型在静态访问方面仍然是封装的。然而，由于模块是开放的，类型对于反射是可用的。现在在`consumer`模块中运行`Main`应该可以工作。
- en: 'Benefits:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Allows selective exposing types for reflection only.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许选择性地仅对反射暴露类型。
- en: Useful for situations where the types need to be *scanned* for annotations and
    implementations by application frameworks and libraries that use that approach.
    For example, packages in modules containing Spring or Hibernate annotations can
    be declared as open to make them accessible by such frameworks. You can now do
    that while still maintaining encapsulation for traditional access.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要应用程序框架和库使用该方法对类型进行扫描以获取注解和实现的情况下很有用。例如，包含Spring或Hibernate注解的模块中的包可以声明为开放，以便它们可以通过这样的框架访问。你现在可以这样做，同时仍然保持传统访问的封装。
- en: Remember that with the `open` and `opens` declarations, you are technically
    letting go of strict encapsulation by allowing packages to be accessed reflectively.
    This is still a good option, and at least, much better than exporting packages,
    when all you want to enable is reflective access. The intent is made clear to
    the consumers of your module.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用`open`和`opens`声明，你实际上是通过允许包被反射访问而放弃了严格的封装。这仍然是一个好选择，至少，当你的目的是仅启用反射访问时，它比导出包要好得多。你的模块消费者的意图是明确的。
- en: Pattern 8 - Use tooling for version control
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式8 - 使用工具进行版本控制
- en: As discussed in [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),
    *Handling Inter-Module Dependencies*, one important feature of most module systems
    is conspicuously absent in Java modularity--that of module versioning and version
    management. If you've dealt with build and packaging tools in the Java ecosystem
    such as Maven and Gradle, you might have come across the fact that all their library
    artifacts have version numbers associated with them. With Maven or Gradle, when
    you establish a dependency on another artifact or library module (and I'm using
    the word module loosely here), you not only have to specify its name and coordinates,
    you also have to specify its version number.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[第3章](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb)中讨论的*处理模块间依赖性*，Java模块化中明显缺少了大多数模块系统的一个重要特性——模块版本化和版本管理。如果你在Java生态系统中的构建和打包工具（如Maven和Gradle）方面有所处理，你可能已经遇到过这样一个事实：所有这些库工件都与版本号相关联。使用Maven或Gradle时，当你对另一个工件或库模块（我在这里使用“模块”一词较为宽松）建立依赖关系时，你不仅必须指定其名称和坐标，还必须指定其版本号。
- en: With Java module dependencies, there's no way to specify version-based dependency.
    The `requires` syntax, `requires <module-name>;` just accepts the module name,
    and not the version. For example, you can specify that your module depends on
    the `google.guava` module. But you cannot specify that it depends on version `1.5.2`
    of `google.guava`. The Java Platform Module System specification clearly states
    that versioning isn't one of the goals of the module specification. The idea is
    to leverage the existing build tools and containers to solve this problem, which
    they have already done in earlier versions of Java.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java模块依赖中，无法指定基于版本的依赖。`requires`语法，`requires <module-name>;`仅接受模块名称，而不接受版本。例如，你可以指定你的模块依赖于`google.guava`模块。但你不能指定它依赖于`google.guava`的版本`1.5.2`。Java平台模块系统规范明确指出，版本化不是模块规范的目标之一。其想法是利用现有的构建工具和容器来解决这个问题，它们已经在Java的早期版本中做到了这一点。
- en: 'If you are not familiar with what the build tools such as Maven or Gradle do,
    their job in *pulling in* dependencies can be classified into two parts. I am
    simplifying, of course, but at a high level, these tools do the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对构建工具（如Maven或Gradle）所做的工作不熟悉，它们在*引入*依赖关系方面的任务可以分为两部分。当然，我在这里简化了，但从高层次来看，这些工具执行以下操作：
- en: Provide a way for each project to specify what other libraries they are dependent
    on.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个项目提供一种指定它们所依赖的其他库的方法。
- en: Pull in those libraries during build and adding the JARs to the classpath so
    that the project that needs them has the necessary libraries available to use.
    These JARs are typically downloaded from a central repository based on the dependencies
    and version numbers specified.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建过程中引入这些库，并将JAR文件添加到类路径中，以便需要它们的项自有必要的库可用。这些JAR文件通常根据指定的依赖关系和版本号从中央仓库下载。
- en: 'Because tools such as Maven and Gradle does #2 above, it is essential for them
    to have all the details--not only which library to download, but also which version
    of the library to download. Remember, it needs to download the right jar from
    a repository with thousands of libraries with multiple versions of each. The Java
    module system does #1 but not #2, but not for the purposes of fetching or downloading
    artifacts from somewhere. It just assumes the modules are already there! This
    is why versions do not apply here. The version of the module you have in the module
    path is the version that will be used.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于像Maven和Gradle这样的工具执行了上述第2点，因此它们必须拥有所有详细信息——不仅要知道下载哪个库，还要知道下载哪个版本的库。记住，它需要从包含数千个库且每个库有多个版本的仓库中下载正确的JAR文件。Java模块系统执行第1点但不执行第2点，但不是为了从某处检索或下载工件的目的。它只是假设模块已经存在！这就是为什么版本在这里不适用。模块路径中你拥有的模块版本就是将使用的版本。
- en: This is where something like Maven fundamentally differs from JPMS. The build
    tools deal with build artifacts--downloading and assembling packaged jar file
    distributables. A Java module is not a build-time artifact, but a compile time
    and runtime artifact. Maven concerns with making sure the right dependencies are
    assembled. The Java Module system is concerned with compile and runtime integrity
    of binaries that have already been assembled.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Maven与JPMS根本不同的地方。构建工具处理构建工件——下载和组装打包的JAR文件分发物。Java模块不是一个构建时工件，而是一个编译时和运行时工件。Maven关注确保正确的依赖关系被组装。Java模块系统关注于已组装的二进制文件的编译和运行时完整性。
- en: This allows the option of using build tools such as Maven or Gradle to download
    the right versions of modular JAR files and dependencies, thereby leaving the
    fully prepared set of modules available in the module path for the module system
    to then take over and use.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许使用 Maven 或 Gradle 等构建工具下载正确的模块 JAR 文件和依赖项，从而在模块路径中留下完全准备好的模块集，然后模块系统接管并使用它们。
- en: We'll look at Maven integration with Java 9 modular applications in much more
    detail in [Chapter 12](part0187.html#5IAP60-ed2405f4162b4f86b565edd6b6d679fb),
    *Using Build Tools and Testing Java Modules*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 12 章[使用构建工具和测试 Java 模块](part0187.html#5IAP60-ed2405f4162b4f86b565edd6b6d679fb)中更详细地探讨
    Maven 与 Java 9 模块化应用程序的集成。
- en: Do not use version numbers in your module names. It is very tempting to create
    multiple modules with the version numbers trailing the names--with module names
    such as `my.module.v1`, `my.module.v2`, and so on. This is not recommended because
    this does not provide any indication about the relationship and the similarities
    between two different versions of the same module, and is essentially a *hack*
    to get versioning to work with Java modules. A much better way is to let a build
    system bring in the right version of modules as discussed, and the platform does
    not have to deal with versioning.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在模块名称中使用版本号。创建多个带有版本号后缀的模块（如 `my.module.v1`、`my.module.v2` 等）非常有诱惑力。这不被推荐，因为这并不能提供关于两个不同版本相同模块之间关系和相似性的任何指示，本质上是一种为了使版本控制与
    Java 模块一起工作而进行的 *hack*。一个更好的方法是通过构建系统引入正确的模块版本，正如之前讨论的那样，平台无需处理版本控制。
- en: Pattern 9 - Design for changes
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 9 - 设计以适应变化
- en: As with building any API, you have to keep your users in mind when you'll eventually
    plan to change it. Thus, you'll have to keep possible future changes in mind when
    you design it! The exported packages in your module are the public API, so your
    users could be accessing any of them. This means that changing any types in the
    exported packages of your module will need to be approached with caution, as it
    could potentially break any consumers of your module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像构建任何 API 一样，当你最终计划更改它时，你必须考虑到你的用户。因此，在设计时你必须考虑到可能未来的更改！你模块中的导出包是公共 API，所以你的用户可能访问其中的任何一个。这意味着，改变你模块中导出包中的任何类型都需要谨慎行事，因为它可能会破坏你模块的任何消费者。
- en: Of course, this depends on the change itself. If you are adding a new type to
    an exported package, or are adding new member variables or methods to existing
    exported types, the changes are still backward compatible. But if you want to
    remove member variables from exported types or change method signatures, you end
    up breaking code that uses those APIs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这取决于变化本身。如果你正在向导出的包中添加新类型，或者正在向现有的导出类型添加新的成员变量或方法，这些更改仍然是向后兼容的。但如果你想要从导出类型中删除成员变量或更改方法签名，最终会导致使用这些
    API 的代码出现错误。
- en: 'Here are some guidelines that help minimize possible changes to module APIs:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有助于最小化模块 API 可能更改的指南：
- en: Keep the exported types as lightweight as possible. We've already seen how you
    can expose interface types that are backed by encapsulated implementation types.
    Having lesser moving parts in exposed types makes them less likely to change in
    future.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能保持导出的类型尽可能轻量。我们已经看到你可以如何暴露由封装的实现类型支持的接口类型。在暴露的类型中拥有较少的可移动部分，使得它们在未来不太可能发生变化。
- en: When you plan to make backward incompatible changes, plan to give your module
    consumers a heads up. This could be in the form of the `@Deprecated` annotation
    on the methods that you plan to remove, for example. If possible, try to provide
    both the old and new APIs together (with clear deprecation notices on the old
    APIs) so that the consumers of your module have enough time to switch their code
    to use your new APIs.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你计划进行向后不兼容的更改时，你应该提前通知你的模块消费者。这可能是在你计划删除的方法上使用 `@Deprecated` 注解的形式。如果可能的话，尝试同时提供旧的和新的
    API（在旧 API 上有明确的弃用通知），这样你的模块消费者就有足够的时间将他们的代码切换到使用你的新 API。
- en: 'The  `@Deprecated` annotation in Java 9 can be used on a module declaration
    too! This is very handy when you want to mark a complete module for deprecation.
    Here''s an example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中的 `@Deprecated` 注解也可以用于模块声明！当你想标记一个完整的模块为弃用时，这非常方便。以下是一个示例：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This marks the module as deprecated from Java 9 onward, and also that it could
    be a removed in any future release. If any module tries to use your module with
    a  `requires`, the compiler will issue a warning about the deprecation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着从Java 9开始，该模块已被标记为弃用，并且它可能在任何未来的版本中被移除。如果任何模块尝试使用你的模块并带有`requires`，编译器将发出关于弃用的警告。
- en: Pattern 10 - Protect against dependency leakage
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式10 - 防止依赖泄露
- en: In [Chapter 5](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb), *Using
    Platform APIs*, we've looked at how dependent types can be leaked by an API and
    it may not be very obvious it's doing so. The best practice to follow is to make
    the usage of your module as lightweight as possible. Ideally, using your module
    should be as simple as adding a `requires` clause for the module and then just
    using it!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb)，“使用平台API”，我们探讨了依赖类型是如何通过API泄露的，并且可能并不明显它在这样做。最佳实践是尽可能使你的模块使用尽可能轻量。理想情况下，使用你的模块应该像添加一个模块的`requires`子句然后直接使用它一样简单！
- en: 'Here are some guidelines to follow:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些遵循的指南：
- en: Make sure your module is self-sufficient. You shouldn't need to depend on another
    module to use it.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的模块是自给自足的。你不应该需要依赖另一个模块来使用它。
- en: If your module's APIs need to return types that are a part of another module,
    try to encapsulate them into types that are exposed in your own module. If your
    APIs could throw exceptions that are a part of another module, try to catch them
    and re-throw custom exceptions that are exposed by your module.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的模块的API需要返回属于另一个模块的类型，尽量将它们封装成你自己的模块中暴露的类型。如果你的API可能会抛出属于另一个模块的异常，尽量捕获它们并重新抛出由你的模块暴露的自定义异常。
- en: If using your module's APIs requires usage of types in other modules and cannot
    be wrapped like mentioned previously, make sure those modules have transitive
    dependency so that the consumers of your module automatically get them.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用你的模块的API需要使用其他模块中的类型，并且无法像之前提到的那样封装，确保那些模块有传递依赖，这样你的模块的消费者会自动获得它们。
- en: As the third guideline implies, sometimes you may want to enable transitive
    dependencies and allow types from other modules to be a part of your module's
    APIs. As with most best practices, you will need to examine this on a case-by-case
    basis as there is no right answer that applies in all situations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如第三条指南所暗示的，有时你可能想启用传递依赖，并允许其他模块的类型成为你模块API的一部分。与大多数最佳实践一样，你需要根据具体情况逐一检查，因为没有适用于所有情况的正确答案。
- en: 'A note of caution, however. Once you establish a transitive dependency in your
    module on another module, it is very easy for those types to creep into your APIs.
    For example, let''s say you are working on module **A** that exposes a bunch of
    different APIs. Assume that the usage of one of those APIs requires a type from
    module **B** and it just cannot be avoided. The solution is to have a transitive
    dependency on module **B**, so that any consumer of your module also gets the
    type from **B**:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个注意事项。一旦你在你的模块中建立了对另一个模块的传递依赖，这些类型很容易悄悄进入你的API。例如，假设你正在开发模块**A**，该模块暴露了一组不同的API。假设使用其中一个API需要来自模块**B**的类型，并且这种情况无法避免。解决方案是对模块**B**有传递依赖，这样任何使用你的模块的消费者也会得到来自**B**的类型：
- en: '![](img/00081.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: Now, once the transitive dependency is established, you can very easily build
    new APIs in module **A** that also require types from **B**. **B** is transitive
    anyway, so the consumer already has access to those types. So, there's no need
    to prevent that or wrap those types from **B** anymore, is there? Well, this is
    a slippery slope! The more types of a transitive module you use, the more coupled
    that module becomes to your own. It's harder to decouple it if you choose to refactor
    module **A** in the future, perhaps to remove the dependency on **B**. This is
    why I would still recommend wrapping types and preventing leakage of dependent
    types in your APIs even if those types are transitively available to the consuming
    module. The primary goal in designing a module should be to establish a purpose
    and an API for a module, and not to blindly add whatever  `requires` declarations
    it takes just to get things to work!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦建立了传递依赖，你就可以非常容易地在模块 **A** 中构建新的 API，这些 API 也需要来自 **B** 的类型。**B** 本身就是传递的，所以消费者已经可以访问这些类型。所以，没有必要阻止它或包装来自
    **B** 的这些类型，对吧？嗯，这是一个滑稽的斜坡！你使用的传递模块的类型越多，该模块与你的耦合度就越高。如果你将来选择重构模块 **A**，可能要移除对
    **B** 的依赖，那么解耦它就会更难。这就是为什么即使这些类型对消费模块是传递可用的，我仍然建议在 API 中包装类型并防止依赖类型的泄漏。设计模块的主要目标应该是为模块建立一个目的和
    API，而不是盲目地添加任何 `requires` 声明，只是为了让事情工作！
- en: Pattern 11 - Aggregator and facade modules
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 11 - 聚合器和外观模块
- en: We've looked at aggregator modules in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Readability, and Accessibility*. Aggregator modules allows
    us to create modules that consolidate a set of libraries that are commonly used
    so that the consumers can require just one aggregator module rather than the more
    tedious process of finding the right list of modules to require. Using aggregator
    modules is a good pattern to use when you have multiple modules in your application
    that need a standard set of dependencies to be *required*. This not only makes
    the process of establishing dependencies on new modules easier, it also allows
    you to change and update that list of dependencies in one place and have it reflected
    across all other modules in your application or organization.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 6 章](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb)中讨论了聚合器模块，*模块解析、可读性和可访问性*。聚合器模块允许我们创建模块，这些模块可以整合一组常用的库，使得消费者只需要求一个聚合器模块，而不是更繁琐的过程去找到正确的模块列表来要求。当你的应用程序中有多个模块需要一组标准的依赖项时，使用聚合器模块是一个很好的模式。这不仅使得在新的模块上建立依赖项的过程变得更容易，还允许你在一个地方更改和更新依赖项列表，并使其反映在你应用程序或组织中的所有其他模块。
- en: 'Following is an example aggregator module that provides transitive dependency
    on three other modules:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个提供对三个其他模块的传递依赖的示例聚合器模块：
- en: '![](img/00082.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00082.jpeg)'
- en: There's another pattern that's closely related that I like to call *facade modules*.
    These are an extension of aggregator modules in that they do offer dependencies
    to a group of modules using transitive dependencies, but they might also contain
    logic that deals with types from multiple modules. While aggregator modules just
    do transitive dependencies and do not necessarily contain logic of their own,
    the *facade module* might contain logic to do things like choose an API from one
    of the modules based on certain criteria, co-ordinate and synchronize calls across
    multiple module APIs, and so on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个与之密切相关且我喜欢称之为*外观模块*的模式。这些是聚合器模块的扩展，因为它们确实通过传递依赖为多个模块提供依赖项，但它们也可能包含处理来自多个模块的类型逻辑。虽然聚合器模块只做传递依赖且不一定包含自己的逻辑，但*外观模块*可能包含逻辑来执行诸如根据某些标准从模块中选择一个
    API、协调和同步多个模块 API 的调用等操作。
- en: Both aggregator and facade modules are designed for special use cases and act
    as *wrappers* around the underlying modules. Since they perform consolidation
    of modules for this reason, they may not offer the best reuse opportunities. But
    that's OK! Like we've discussed before, the best modules to facilitate reuse are
    simple single-purpose modules. However, aggregator and facade modules provide
    a middle ground between extremely fragmented modules that are pain to use and
    specialized modules that are easier to use but lack flexibility. A very handy
    pattern to use in such cases, when you are trying to strike that balance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模块和外观模块都是为了特定的用例而设计的，它们作为底层模块的*包装器*。由于它们出于这个原因对模块进行了整合，因此可能不会提供最佳的复用机会。但没关系！就像我们之前讨论的那样，最佳的模块是简单且单一用途的模块。然而，代理模块和外观模块在难以使用的极度碎片化模块和易于使用但缺乏灵活性的专用模块之间提供了一个折中方案。在这种情况下，当你试图达到这种平衡时，这是一个非常实用的模式。
- en: Example
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'In the sample code at `09-module-patterns/09-aggregator-and-facade-modules`,
    the module `pattern.nine.facade` acts as an aggregator and facade module that
    consolidates two separate modules--`module.one` and `module.two`. It has a transitive
    dependency on both those modules, so any module that reads `pattern.nine.facade`
    also automatically reads those two modules:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`09-module-patterns/09-aggregator-and-facade-modules`的示例代码中，模块`pattern.nine.facade`作为一个聚合器和外观模块，整合了两个独立的模块--`module.one`和`module.two`。它对这两个模块都有传递依赖关系，所以任何读取`pattern.nine.facade`的模块也会自动读取这两个模块：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Not only does the module do that, it also has a thin *facade* API. There''s
    a class it exports--`FacadeApi` that has an example method to illustrate how a
    method can *choose* between two implementations. Here, the method chooses one
    of two implementations based on an input String value. But you can easily imagine
    facade APIs written in such a module that offer help around business rules or
    logic of your application that affects which libraries are used:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 模块不仅做到了这一点，它还有一个薄的*外观* API。它导出了一个类--`FacadeApi`，有一个示例方法来说明一个方法如何*选择*两种实现之一。在这里，方法根据输入的字符串值选择两种实现之一。但你可以很容易地想象出在这样一个模块中编写的提供有关业务规则或逻辑的API，这些规则或逻辑影响应用程序使用哪些库：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, the `consumer` module that reads `pattern.nine.facade` has two options.
    It can either access the library modules directly (And it can because of the transitive
    dependencies--it transitively reads both `module.one` and `module.two`). Or, it
    can call the API through the facade method to get help on which one to call. Both
    work perfectly fine, as you can see in the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，读取`pattern.nine.facade`的`consumer`模块有两个选择。它可以直接访问库模块（它之所以可以这样做，是因为传递依赖关系--它传递性地读取了`module.one`和`module.two`）。或者，它可以通过外观方法调用API来获得有关调用哪个模块的帮助。两者都工作得很好，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/00083.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00083.jpeg)'
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've looked at some guidelines and best practices to create
    modules and identify module boundaries. When creating a new application or when
    migrating an existing legacy application to Java modules, it's always a good idea
    to have a map of the modules and their interactions designed in advance. We've
    looked at some best practices that let you figure out what a module should be
    made of and what would cause you to segregate logic into separate modules.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了创建模块和识别模块边界的一些指南和最佳实践。在创建新应用程序或迁移现有遗留应用程序到Java模块时，提前设计模块及其交互的映射总是一个好主意。我们查看了一些最佳实践，这些实践可以帮助你确定模块应该由什么组成，以及什么会导致你将逻辑分离到单独的模块中。
- en: We then looked at a list of best practices and ideas to use in your code. Many
    of the best practices discussed previously come with simplified code examples.
    Each example is intentionally bare-bone with code that demonstrates just the pattern
    being discussed and little else, so that you can easily pick any of them up and
    tweak them further or apply them in your own code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后查看了一组最佳实践和想法，这些可以在你的代码中使用。之前讨论的许多最佳实践都伴随着简化的代码示例。每个示例都是故意简化，只包含展示正在讨论的模式的相关代码，几乎没有其他内容，这样你就可以轻松地选择任何一个并进一步调整它们或在你的代码中应用它们。
- en: Now that we have these patterns in your tool belt, let's tackle a major challenge
    that Java developers will face when moving to Java 9, migration of existing code.
    There have been years and years of Java development and tons of legacy code of
    various complexities that has been built using earlier versions of Java. How do
    we approach moving them to take advantage of Java modules? Before that, would
    they even work with Java 9? Let's begin to answer those questions, as well as
    understand what it takes to get your code read for such a migration in the next
    chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了这些工具包中的模式，让我们来应对Java开发者们在迁移到Java 9时将面临的一个主要挑战，即现有代码的迁移。多年来，Java一直在发展，并且积累了大量使用早期Java版本构建的、各种复杂性的遗留代码。我们如何着手迁移它们以利用Java模块的优势呢？在此之前，它们甚至能在Java
    9上运行吗？让我们开始回答这些问题，并在下一章中了解为了使代码准备好这样的迁移需要做些什么。
