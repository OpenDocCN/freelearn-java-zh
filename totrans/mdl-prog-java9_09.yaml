- en: Module Design Patterns and Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous few chapters, we did a deep dive into several modularity features
    in Java 9 that enable you to build Java applications with modules. You''ve learned
    how to use the dependency declarations and services to establish module dependencies.
    You''ve also learned how to use jlink to build modular runtimes that can be distributed.
    In this chapter, we''ll look at a slightly less objective concern--how to build
    good applications with modules in Java. Now that you''ve acquired the knowledge
    to create and use modules, what are the recommended ways to do that? What are
    the best practices and patterns that you should use? Here''s what we''ll cover
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to design modules--what a module should ideally be and where
    module boundaries should be drawn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to design good APIs for those modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about several best practices to create modules, as well as patterns,
    to use the module system effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the patterns discussed in this chapter come with usable code examples,
    available in the folderÂ `09-module-patterns`. Each example has been carefully
    crafted to help explain the pattern being discussed with minimal information overhead.
    Feel free to use and experiment with these code examples as you explore these
    patterns. Also, remember to revisit this chapter during your Java 9 modularity
    journey to brush up your knowledge of these patterns. It's often the case that
    rereading and thinking about design patterns at any time offers new perspectives
    to the challenges you have going on at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Designing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, the first step in designing a Java application has usually involved
    the design of the packages and classes, as well as the interactions between them.
    It also perhaps involved designing some shared libraries. For instance, you'd
    move reusable code into a separate project and bundle it into your application
    as a JAR file. With Java 9 modules, you now have a new aspect to consider that
    significantly impacts the design process. Irrespective of whether you are creating
    a new application from scratch or you are migrating an existing classpath application
    into a modular application, there are some common questions you'll need to answer--How
    do you come up with a modular design? How do you choose what a module should be?
    How much code and functionality should be in a module? Where do you draw module
    boundaries in specific scenarios? For example, a question you might often run
    into is--Given a functionality or a set of classes and packages, should they belong
    to *Module A* or *Module B*? And how do you achieve good design principles for
    modules such as reusability, extensibility and maintainability?
  prefs: []
  type: TYPE_NORMAL
- en: As with most software design challenges, there are no right answers that apply
    for all scenarios. In fact, some of the -ility factors pull against each other,
    and most designs involve making a calculated trade-off. However, having some guidelines
    and best practices should get us started with tackling these challenges that can
    then be refined and tweaked as per specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Among the first steps in designing and building a modular application, it helps
    to have a high level idea of what the modules and APIs will be. For simple projects,
    it can be tempting to just fire off the IDE and start coding. But for anything
    serious, it helps to spend some time and design a rough picture of the modules
    involved, their public APIs and their dependencies on each other before you start
    coding. Let's start looking at some principles and factors to keep in mind when
    designing modules and deciding what it should do.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most obvious way of deciding what makes a module is based on what
    it is about. In other words, its *scope*. If you were to break down any reasonably
    complex application, you'd immediately come up with high level functional areas
    that begin to separate out from each other. For instance, a banking application
    might have account related functionality that's separate from credit functionality
    and so on. In the case of existing Java applications, these different concerns
    might already be under different top-level packages. In the case of new applications,
    the various aspects of the business problem can give us clues. Distinct business
    areas stand out to form an initial high level classification, which can then perhaps
    be broken down into further chunks. So, in our banking example, account functionality
    might be split into savings and checking account functionality, account transfer
    related code, bill pay, and so on. This way of using the business concern to break
    down the application problem domain is a good strategy to get to smaller units
    that can then be good candidates for modules. You'll likely have to go through
    several levels of breaking down the scope until you arrive at a level where each
    unit feels like they could be separate modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, while this is a good strategy to start breaking the problem in a
    top-down manner, it doesn't help you decide when to stop breaking things down!
    How do you know if your modules are too big? Or too fragmented? You'll have to
    look at other factors in this section to help make that decision.
  prefs: []
  type: TYPE_NORMAL
- en: Team structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a popular adage in software design called **Conway's Law**, which suggests
    that the design of software in any organization is influenced by the structure
    of teams in the organization and the way they communicate with each other. It
    makes perfect sense if you think about it. Software development teams often tend
    to work on isolated libraries and code bases (or at least, code *areas*) that
    *talk* to other libraries and code bases developed by other teams. In a sense,
    there's almost a one-to-one mapping between teams and the set of code assets they
    work on. This can be a valuable factor that influences where module boundaries
    are drawn and how modules designs begin to separate from one another. Each team
    works on one or more modules, and so all the code that a given team would work
    on becomes a part of their set of modules.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for a variety of reasons. Teams can work on their code and ship
    out functionality independent of other teams. They are assigned *ownership* of
    modules, so they can handle bug fixes or code maintenance. Additionally, when
    starting out a new project, when two teams need to work on modules where one depends
    on the other, both teams can together come up with an *API contract* that they
    agree with. Then, each team can work on their modules separately and in parallel,
    although the dependent modules are not yet available.
  prefs: []
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the tenets of modularity is reusability. We earlier used the analogy
    of building blocks to describe modules. The idea of plugging in reusable modules
    together to create different applications is very powerful indeed! In order to
    make modules reusable, they should ideally have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: They should have some specialized and limited responsibility. A module that
    does too many things is hard to reuse effectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They should be independent--If a module depends on a whole lot of other modules
    to function, it becomes harder to reuse the module itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be configurable--If the module is tweak-able and can be made to work
    for different use cases, it makes the module more amenable to reuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These characteristics do come with some trade-offs though! Here are a couple
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Having smaller *specialized* or *single purpose* modules sometimes results in
    very small and fragmented modules, often requiring multiple modules to get anything
    done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable APIs in modules often results in more complicated APIs, since the
    consumers have to deal with more knobs and levers to tweak and operate in order
    to work with your module. One way to get around this problem is to provide sensible
    defaults and provide configuration just as an override.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularizing by concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When designing modules, it''ll be quickly apparent to you that not all modules
    are alike. Modules can be classified into multiple different types depending on
    various characteristics. One such classification can be achieved by their functionality
    or the concerns they address. At the highest level, you can classify modules into
    two different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical concerns**: Business and application specific functionality. Solves
    a specific problem in the business domain. For example, the accounts module in
    a banking application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal concerns**: Crosscutting functionalities that are not business
    or application specific. Instead, they provide low level functionality or framework
    that''s business-agnostic. For example, logging or security modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When designing modules, a good rule to try and follow is to not mix these two
    concerns. If you design modules specifically for one of the two concerns, it improves
    clarity and reuse. For example, in the address book application, the module `packt.sortutil`
    provided generic sorting ability while being completely agnostic of what it's
    sorting, thereby addresses a horizontal concern. The module `packt.addressbook`
    deals with specific address book application functionality, thereby addressing
    a vertical concern.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, the type of module influences its design. For instance,
    reusability wouldn't likely be a primary focus when designing a module addressing
    a vertical concern, but it's vital when designing a module with cross-cutting
    concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing by layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful factor that can help us draw module boundaries is application
    layers. A typical application involves layers or tiers of functionality like the
    UI layer, business layer, data layer, and so on. That's a great way to draw some
    initial module boundaries before then looking at other categories to modularize
    further. A module should ideally not be a part of multiple application tiers.
    Sometimes, different tiers are deployed on different physical hardware. So, having
    tier separations guide module boundaries make logistical sense as well when it
    comes to deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing by change patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An approach that I've found helpful to verify module boundaries is analyzing
    patterns of new feature additions to your application. If most of the typical
    changes you make to your code base involves having to modify multiple modules,
    that might be a clue that your modules are too fragmented or the separation of
    modules could be better. It's OK if you are modifying multiple low-level modules
    (that is, with horizontal concerns) for an average code change or enhancement.
    But if each change or enhancement to your application requires you to modify too
    many modules with vertical concerns, you might want to re-look at the module boundaries
    and see if those different modules contain code that should ideally be together
    in the same module.
  prefs: []
  type: TYPE_NORMAL
- en: Designing API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at some guidelines and tips for drawing module boundaries and creating
    modules. How about the process of creating APIs? This might seem obvious, but
    the standard best practice of a separate public API and private implementation
    still applies here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal when designing the module API is to expose a standard, consistent,
    and possibly unchanging programming interface as the **public** API of the module.
    The details of implementation that are internal to the module should be encapsulated.
    This is, in principle, no different from method and member variable encapsulation
    for classes. Design a public API for your modules that you want the consumers
    to work with. The implementation details are hidden in encapsulated packages and
    serve two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To reduce and simplify effort for the consumer so that they don't have to know
    the internals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow the module to change and evolve the implementation without having an
    impact on the consumers of the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java modules coding patterns and strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've so far looked at some general higher level, almost common-sensical patterns,
    that apply to modularity in Java. Now let's dive into code. Let's look at some
    code patterns and strategies that can help you as you as you start designing modules
    and their APIs. Each of these strategies are presented with explanation about
    the pattern, why and when you should consider using them. Many of them have accompanying
    code examples for you to refer to. Some of these might be obvious. In fact, we've
    even applied some of the patterns when building the sample address book application
    we've worked on in this book. I hope this consolidated list provides you with
    a good reference to these patterns when designing and building modular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern 1 - Public interface, private implementation, and factory class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Separate the public API from the internal encapsulated implementation (we've
    already seen this strategy implemented in the sorting utility module of the address
    book viewer application earlier in the book). Also, expose a factory API method
    that creates new instances of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: The exported types are interfaces or abstract classes that are as lightweight
    as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes that contain the actual logic implement the interfaces in the exported
    packages. These types are not exported. Thus, all the implementation details are
    safely hidden away.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are factory classes in the exposed packages that form the APIs. These
    create a new instance of the right implementation class. The return types of these
    factory APIs deal with interfaces only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A sample implementation of this pattern is available in the folderÂ `09-module-patterns/01-seperate-interface-impl`.
    The module `pattern.one` has the interface `PublicInterface` exposed in the `pattern.one.external`
    package, while the implementation classes `PrivateImplA` and `PrivateImplB` are
    in the encapsulated `pattern.one.internal` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d like the consuming modules to access the private instances through the
    public interface type. To facilitate this, there''s a factory class `Factory`
    exposed by the module. This class has a public method `getApiInstance` that takes
    in an argument and then based on the value, returns the right implementation class.
    In the sample code, there''s a simple `boolean` flag that affects whether one
    implementation instance is returned over another, but in a real-world module,
    this selection criteria would be more meaningful to what''s returned, as this
    is how the consumer picks the right API instance based on their requirements.
    The return type of the factory method is an instance of the public interface.
    Thus, the consumer module doesn''t know about the implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Hides the details from the consumer so that they don't have to know the internals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to change the implementation or add new implementation types without
    the consumers having to change the way they interact with the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern 2 - Services for multiple dynamic implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative way to abstract implementation types is to use them as services.
    This is an extension of the previous pattern, but while ensuring more loosely
    coupled and dynamic implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: There's a service interface module that exposes the service interface type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more *service* implementation modules provide implementations for that
    service using the `provides` clause in the module definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The consumer module does not directly depend on the implementation modules.
    It `requires` only the service interface module and declares that it `uses` the
    service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code in the consumer module looks up service instances using the `ServiceLoader`
    API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sample code implementation is available atÂ  `09-module-patterns/02-services`.
    The `pattern.two.service` module exports the `PublicInterface`. It doesn''t contain
    any implementation classes of its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Two implementation modules `pattern.two.implA` and `pattern.two.implB` both
    contain implementations of the service that are declared using `provides` in the
    module declaration. Both implementation modules `require` the service module `pattern.two.service`
    to access the interface. Here''s how the module definition for one of the implementation
    modules looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The consumer module also depends on the service interface module, and *not*
    on the implementation modules. The `uses` clause in the module definition indicates
    that the module will need to look up the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides an additional layer of abstraction between the service consumer and
    provider logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completely loose coupling between consumer and implementation modules. There's
    no hard-wired `requires` dependency on the implementation modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility in the implementation options available. Modules can be dropped
    in the module path at runtime, and as long as they implement and provide the service
    interface, they can be plugged in to the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern 3 - Optional dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how Java did not have an option for reliable configuration up until
    Java 9\. You could add or remove certain classes and JARs from the classpath before
    running and the application would still execute (or at least, starts executing)!
    There are some utility libraries and frameworks in Java that have made good use
    of this flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the Spring Framework. Spring is a popular application framework that
    uses and orchestrates functionality across a lot of other dependent libraries
    and frameworks by scanning the classpath for available libraries that it can work
    with. If you'd like Spring to use some of these supported libraries, just dropping
    certain necessary jars into the classpath is enough for Spring to pick it up and
    use its functionality. And if you don't, the Spring framework can still function
    without them, albeit without the optional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This flexibility plays an important role in the ease of use of these frameworks.
    Now, with Java 9 and strict requirements for module dependencies, wouldn't we
    be losing this flexibility? There's no optionally dropping jars into the classpath
    anymore! Things are much more strict and controlled now. Every module that a given
    module needs should be explicitly specified with a `requires` clause in the module
    definition. Given this new state of affairs, how could you build such modules
    that are optional and with *drop-in* flexibility?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is optional dependencies. In Java 9, you can specify a given module
    dependency as optional by using the `requires static` qualifier. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `static` qualifier tells the module system that the module `required` is
    optional. The module should still be available at compile time (because `javac`
    needs to compile the code and references after all!). But it is optional at runtime.
    If the module isn't available during runtime, `java` won't complain about the
    module's unavailability like it would with the `requires` only clause. It proceeds
    with execution assuming you know what you are doing. This new feature enables
    you to have modules with a bunch of `require static` optional dependencies, which
    can be freely dropped into the module path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: When you have a module that optionally depends on one or more modules, use the
    `requires static` clause to establish optional dependency in the module definition.
    If *module A* optionally requires *module B*, you specify `requires static B`
    in module A's definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During development and compile time, you don't *have* to do anything different.
    You could use the exported types from the optional dependencies just like a regular
    `requires` dependency. As always, the module(s) with the optional dependency needs
    to be available at compile time for the code to compile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At runtime however, things are different. This time, you can execute your application
    irrespective of whether the module with the optional dependency is available or
    not. If the module is available, it gets picked up fine. But if it isn't, you
    get a `NoClassDefFound` error. While it's not mandatory, it's a good idea to write
    code to handle this error scenario, in case the module you optionally require
    isn't available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the sample code atÂ `09-module-patterns/03-optional-dependencies`.
    The `pattern.three` is a module that optionally requires `pattern.three.optlib`.
    It uses the optional library if available, but the module is perfectly happy if
    it isn''t available at runtime. To establish this optional nature of this dependency,
    `pattern.three` uses the `requires static` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pattern.three.optlib` has a simple library class that prints a message
    to the console. Nothing surprising here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, the code in the module `pattern.three` can directly import and use the
    exported types of the optional module (in this case, `LibImpl`). But this is not
    a good idea. By specifying that a dependency is optional, you are essentially
    asking the platform to let go of its reliable configuration guarantee and to *not*
    check and ensure that the module is available. This opens the possibility that
    this dependency is not satisfied at runtime. For this reason, it's the responsibility
    of the module now to be able to handle both the presence and absence of the module.
    Rather than have the `NoClassDefFound` error thrown to the user, we can be smart
    about using the optional types only if they are available. We can use the `Class.forName`
    API to examine if the class does exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code in the `Util` class in module `pattern.three`. This is one
    way to reflect and use the types from optional dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous examples, we have a `consumer` module that requires `pattern.three`
    and has a `Main` type that calls the module's API. Before executing the application,
    here's another important thing for you to know about optional dependencies. They
    don't get picked up in the module resolution process! So, we'll have to explicitly
    add the module to the execution process.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb), *Understanding
    Linking and Using* *jlink*, we discussed the module resolution process and how
    the Java Platform resolves the tree of dependencies by recursively fetching all
    dependent modules that are required in the module definition. It doesn't do that
    for optional dependencies! During the module resolution process, if the runtime
    encounters theÂ `requires static`Â dependency, it does not resolve that module and
    its dependencies. These optional modules could be compiled and ready, sitting
    in the module path along with the other modules, but the runtime still doesn't
    see it. This brings up an interesting problem. How does the Java runtime know
    that these optional modules exist in the module path if it doesn't even look it
    up?
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to add the modules manually into the module resolution process.
    Remember theÂ `--add-modules`Â option we passed toÂ `jlink`Â in [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Understanding Linking and Using*Â *jlink*? We used that flag to haveÂ `jlink`Â include
    modules to the resolution process. TheÂ `java`Â command too has that flag available
    to include modules. So, to have the runtime *see* and use the optional modules,
    we'll need to add it using theÂ `--add-modules`Â flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compile the example code with the `javac` command as usual. No changes
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When running, however, you need to add all the modules that are optional dependencies
    using the `--add-modules` flag. Here, `pattern.three.optlib` is the optional dependency.
    So, here''s the command you use to execute the `Main` class in the `consumer`
    module and the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Try removing the compiled `pattern.three.optlib` module from the `out` directory
    and run it again without the `-add-modules` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This time, you get the *fallback* code executed because the necessary class
    isn't available. The important distinction here is that the code still runs. It
    wouldn't have if the dependency wasn't optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'TheÂ `--add-modules`Â parameter is sensitive to the order, in that it should
    appear *before* theÂ `-m`Â parameter. So, the following command will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java --module-path out -m consumer/app.Main --add-modules out/pattern.three.optlib
    # Doesn''t work`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to create libraries that are *plug-and-play*. You can create a *main*
    library module that depends on additional modules optionally, thereby providing
    runtime flexibility in the modules and functionality that are actually a part
    of the execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern 4 - Optional dependencies using services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While reading about optional module dependencies, a thought might have occurred
    to you--how about using services? We've learned in [Chapter 7](part0110.html#38STS0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Services*, about how using services in Java modules provides a flexible
    and loosely coupled way of having modules work with each other. With services,
    you don't have to specify a readability relationship with `requires`. Modules
    that provide services are optional, not just in runtime, but also during compile
    time! So aren't services already better than optional dependencies?
  prefs: []
  type: TYPE_NORMAL
- en: The simple answer is yes. Services are definitely the preferred way of decoupling
    modules and removing *hard* dependencies. This is what we'll examine in this pattern.
    However, they do have a problem and won't work as well as you'd imagine. Let's
    explore why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: When using services, you typically achieve abstraction by creating two types--the
    interface (which *is* the service) and the implementations of the interface (which
    are the providers of the service). You don't *have* to do this, of course. You
    can have a Java class itself be the service type. But what we are discussing now
    applies to that too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given two modules A and B, if you''d like module A to optionally depend on
    B, you could use the previous pattern and use `requires static B` in the module
    definition of A. However, if you''d like to use services, you''ll need to assign
    one or more Java interfaces or classes as *service types*. The `module A` needs
    to specify that it `uses` these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And `module B` needs to `provide` the services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, B is technically optional. The application can run irrespective of whether
    module B exists in the module path or not! Seems simple enough, doesn't it? But
    there's a catch! Which module should the service type reside in? Is it module
    A or module B? It cannot be module B, because in that case, module A would need
    to *require* module B to access the service type in B, which defeats the whole
    purpose of making B optional! It could reside in module A, but now module B should
    depend on module A to access the service type. Thus module B `requires` A and
    module A `exports` the package containing the service type.
  prefs: []
  type: TYPE_NORMAL
- en: But wait! Our original goal was to make module A optionally depend on B. What
    we've ended up with now is module B depending on A! That seems the wrong way around,
    but if you think about the service dynamic, A is still using the implementation
    provided by B, and B is only dependent on A to get the service type. It is still
    confusing and it's not obvious what's going on just by looking at the module definitions.
    One way to solve the problem is to move the service types to a third `module C`
    which is required by both A and B. Now both A and B have access to the service
    types, and thus, are fully decoupled. This option might not always be feasible,
    and it is awkward to have a separate module just to solve this problem. But when
    it *is* possible, this approach of using services is one of the best ways to achieve
    flexibility and theÂ *drop-anything-you-need*Â mechanism that exists with some libraries
    and frameworks in Java 8 and earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at the sample code at `09-module-patterns/04-optional-dependencies-with-services`.We
    have two modules, `pattern.four` and `pattern.four.optlib`. We want `pattern.four`
    to optionally depend on `pattern.four.optlib` using the services pattern we've
    seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module `pattern.four` contains a service type `LibInterface` that it exports.
    It also declares that it uses provider implementations of `LibInterface`, which
    is what essentially makes `LibInterface` a service type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The module `pattern.four.optlib` provides an implementation of the `LibInterface`
    service type. It also depends on `pattern.four` to access the service type in
    the first place. This is the seemingly inverted relationship we discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a class `LibImpl` in `pattern.four.optlib` that implementsÂ `LibInterface`
    as declared in the preceding module definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The module `pattern.four` is now totally unaware of `pattern.four.optlib`.
    It uses the `ServiceLoader` API to get any available instances, and if the optional
    module is available, it''s happy to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Extends the *plug-and-play*Â concept that the previous pattern solved and adds
    a new level of decoupling. Modules can be optional both at compile time and runtime!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extends the one-to-one dependency of `requires static` with the services providing
    one-to-many dependency. There could be multiple modules providing services that
    are optionally picked up by the module using the services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern 6 - Bundle model classes as separate sharable modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's common for many enterprise applications to deal with multiple layers and
    tiers. They usually need to communicate and share data among them, and a frequently
    used pattern is to exchange data using model objects or **Data Transfer Objects**
    (**DTOs**). They are an example of code that needs to be shared across multiple
    layers and modules.
  prefs: []
  type: TYPE_NORMAL
- en: A good pattern to follow is to create separate modules just for the model (or
    DTO) classes. These modules can then be read by any module that needs access to
    those types. This could be a lightweight module containing just the model classes
    and not much else.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern 7 - Open modules for reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection is an important feature in the Java programming language, allowing
    the ability to inspect and modify types dynamically at runtime. This is another
    feature that has been put to good use by frameworks such as Spring, Hibernate,
    and others. These frameworks use reflection to examine your classes for annotations
    and interface implementations to infer information about how to treat your code.
    You might use reflection in your own code to achieve this dynamic functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How does reflection fit into the concepts of modularity we've learned so far?
    Like we've seen before, the default behavior of strong encapsulation that protects
    types in a module from static access offers similar protection for reflective
    access as well. A Java type can be accessed through reflection if it's in a module
    that exports it, and the type calling the reflection API is in a module that reads
    the other module.
  prefs: []
  type: TYPE_NORMAL
- en: This results in a potential problem because of how reflection has been traditionally
    used in Java, especially in many of the frameworks like we've mentioned earlier.
    Frameworks like Spring expect to scan through your entire code base looking for
    classes that are annotated with certain key annotations. A lot of reflection API
    usage in Java code bases over the years have been implemented with an implicit
    understanding that the classes being reflected on are available for them to access.
    Once you move those types into modules, all the encapsulated types are effectively
    sealed off and not available for reflection. One easy solution is to expose everything!
    So, every module exposes all types that need to be accessed reflectively. But
    this is not a good idea because of the concept of the module API we've discussed
    earlier. The type that a module exposes using the `exports` clause is the module
    API. By exposing an otherwise private type just because it contains an annotation
    for the Spring framework, Hibernate, JPA, or any other such framework that uses
    reflection, we are adversely impacting the API of the module and the purpose of
    string encapsulation is defeated.
  prefs: []
  type: TYPE_NORMAL
- en: To address this issue and to still provide an option of using reflection with
    such frameworks, the platform has introduced a concept called **open modules**.
    These are a type of Java modules that still encapsulate types like we are familiar
    with, but with one major difference. The encapsulated types in these open modules
    are available for reflective access at runtime, without you having to allow compile-time
    access that an `exports` declaration would have provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you make a Java module an *open module*? Very simple. Just add the `open`
    keyword in front of the module definition in `module-info.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this, the contents of the module are still encapsulated (except for any
    packages that you `export` in the module definition). But all the packages in
    the module are now available for access at runtime using reflection by any module
    that reads this module.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that theÂ `open`Â keyword doesn't make the module open for reflective
    access for all modules. A module that needs to access any such types using reflection
    will still need to *read* the module that contains the type using theÂ `requires`Â keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only entire modules, but even individual packages can be marked as open
    with theÂ Â `opens` keyword followed by the specific package you''d like to open
    for reflection. This provides more fine-grained control when you know that there
    are only certain classes in the module that need to be reflected upon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the package `package.one` is available for reflection
    by all modules that read module `modulename`. The package `package.two` is available
    for reflective access only by module `anothermodule`, if it chooses to *require*
    it. And package `package.three` is available for both reflective and compile-time
    access because it is exported.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the sample code at `09-module-patterns/06-open-modules`, the module `pattern.six`
    contains the type `Contact.java` in the package `pattern.six.internal`. Let's
    assume we'd like for this class to be internal to the module and not exposed.
    However, we'd like to be able to access the `Contact` class reflectively from
    another module `consumer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code in the `consumer` module that is doing reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The consumer module establishes a dependency on the module `pattern.six` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But that's not enough! The module `pattern.six` should either export the type
    or declare that it's an open module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the module definition for `pattern.six` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the contents of the module aren't technically exported, so the types
    in the module are still encapsulated for static access. However, since the module
    is open, the types are available for reflection. Running `Main` in the `consumer`
    module should work now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows selective exposing types for reflection only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful for situations where the types need to be *scanned* for annotations and
    implementations by application frameworks and libraries that use that approach.
    For example, packages in modules containing Spring or Hibernate annotations can
    be declared as open to make them accessible by such frameworks. You can now do
    that while still maintaining encapsulation for traditional access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that with theÂ `open` andÂ `opens` declarations, you are technically
    letting go of strict encapsulation by allowing packages to be accessed reflectively.
    This is still a good option, and at least, much better than exporting packages,
    when all you want to enable is reflective access. The intent is made clear to
    the consumers of your module.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern 8 - Use tooling for version control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),
    *Handling Inter-Module Dependencies*, one important feature of most module systems
    is conspicuously absent in Java modularity--that of module versioning and version
    management. If you've dealt with build and packaging tools in the Java ecosystem
    such as Maven and Gradle, you might have come across the fact that all their library
    artifacts have version numbers associated with them. With Maven or Gradle, when
    you establish a dependency on another artifact or library module (and I'm using
    the word module loosely here), you not only have to specify its name and coordinates,
    you also have to specify its version number.
  prefs: []
  type: TYPE_NORMAL
- en: With Java module dependencies, there's no way to specify version-based dependency.
    The `requires` syntax, `requires <module-name>;` just accepts the module name,
    and not the version. For example, you can specify that your module depends on
    the `google.guava` module. But you cannot specify that it depends on version `1.5.2`
    of `google.guava`. The Java Platform Module System specification clearly states
    that versioning isn't one of the goals of the module specification. The idea is
    to leverage the existing build tools and containers to solve this problem, which
    they have already done in earlier versions of Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with what the build tools such as Maven or Gradle do,
    their job in *pulling in* dependencies can be classified into two parts. I am
    simplifying, of course, but at a high level, these tools do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a way for each project to specify what other libraries they are dependent
    on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull in those libraries during build and adding the JARs to the classpath so
    that the project that needs them has the necessary libraries available to use.
    These JARs are typically downloaded from a central repository based on the dependencies
    and version numbers specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because tools such as Maven and Gradle does #2 above, it is essential for them
    to have all the details--not only which library to download, but also which version
    of the library to download. Remember, it needs to download the right jar from
    a repository with thousands of libraries with multiple versions of each. The Java
    module system does #1 but not #2, but not for the purposes of fetching or downloading
    artifacts from somewhere. It just assumes the modules are already there! This
    is why versions do not apply here. The version of the module you have in the module
    path is the version that will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where something like Maven fundamentally differs from JPMS. The build
    tools deal with build artifacts--downloading and assembling packaged jar file
    distributables. A Java module is not a build-time artifact, but a compile time
    and runtime artifact. Maven concerns with making sure the right dependencies are
    assembled. The Java Module system is concerned with compile and runtime integrity
    of binaries that have already been assembled.
  prefs: []
  type: TYPE_NORMAL
- en: This allows the option of using build tools such as Maven or Gradle to download
    the right versions of modular JAR files and dependencies, thereby leaving the
    fully prepared set of modules available in the module path for the module system
    to then take over and use.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at Maven integration with Java 9 modular applications in much more
    detail in [Chapter 12](part0187.html#5IAP60-ed2405f4162b4f86b565edd6b6d679fb),
    *Using Build Tools and Testing Java Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use version numbers in your module names. It is very tempting to create
    multiple modules with the version numbers trailing the names--with module names
    such asÂ `my.module.v1`,Â `my.module.v2`,Â and so on. This is not recommended because
    this does not provide any indication about the relationship and the similarities
    between two different versions of the same module, and is essentially a *hack*
    to get versioning to work with Java modules. A much better way is to let a build
    system bring in the right version of modules as discussed, and the platform does
    not have to deal with versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern 9 - Design for changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with building any API, you have to keep your users in mind when you'll eventually
    plan to change it. Thus, you'll have to keep possible future changes in mind when
    you design it! The exported packages in your module are the public API, so your
    users could be accessing any of them. This means that changing any types in the
    exported packages of your module will need to be approached with caution, as it
    could potentially break any consumers of your module.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this depends on the change itself. If you are adding a new type to
    an exported package, or are adding new member variables or methods to existing
    exported types, the changes are still backward compatible. But if you want to
    remove member variables from exported types or change method signatures, you end
    up breaking code that uses those APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some guidelines that help minimize possible changes to module APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the exported types as lightweight as possible. We've already seen how you
    can expose interface types that are backed by encapsulated implementation types.
    Having lesser moving parts in exposed types makes them less likely to change in
    future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you plan to make backward incompatible changes, plan to give your module
    consumers a heads up. This could be in the form of the `@Deprecated` annotation
    on the methods that you plan to remove, for example. If possible, try to provide
    both the old and new APIs together (with clear deprecation notices on the old
    APIs) so that the consumers of your module have enough time to switch their code
    to use your new APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TheÂ  `@Deprecated` annotation in Java 9 can be used on a module declaration
    too! This is very handy when you want to mark a complete module for deprecation.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This marks the module as deprecated from Java 9 onward, and also that it could
    be a removed in any future release. If any module tries to use your module with
    aÂ  `requires`, the compiler will issue a warning about the deprecation.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern 10 - Protect against dependency leakage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb), *Using
    Platform APIs*, we've looked at how dependent types can be leaked by an API and
    it may not be very obvious it's doing so. The best practice to follow is to make
    the usage of your module as lightweight as possible. Ideally, using your module
    should be as simple as adding a `requires` clause for the module and then just
    using it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some guidelines to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your module is self-sufficient. You shouldn't need to depend on another
    module to use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your module's APIs need to return types that are a part of another module,
    try to encapsulate them into types that are exposed in your own module. If your
    APIs could throw exceptions that are a part of another module, try to catch them
    and re-throw custom exceptions that are exposed by your module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If using your module's APIs requires usage of types in other modules and cannot
    be wrapped like mentioned previously, make sure those modules have transitive
    dependency so that the consumers of your module automatically get them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the third guideline implies, sometimes you may want to enable transitive
    dependencies and allow types from other modules to be a part of your module's
    APIs. As with most best practices, you will need to examine this on a case-by-case
    basis as there is no right answer that applies in all situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'A note of caution, however. Once you establish a transitive dependency in your
    module on another module, it is very easy for those types to creep into your APIs.
    For example, let''s say you are working on module **A** that exposes a bunch of
    different APIs. Assume that the usage of one of those APIs requires a type from
    module **B** and it just cannot be avoided. The solution is to have a transitive
    dependency on module **B**, so that any consumer of your module also gets the
    type from **B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, once the transitive dependency is established, you can very easily build
    new APIs in module **A** that also require types from **B**. **B** is transitive
    anyway, so the consumer already has access to those types. So, there's no need
    to prevent that or wrap those types from **B** anymore, is there? Well, this is
    a slippery slope! The more types of a transitive module you use, the more coupled
    that module becomes to your own. It's harder to decouple it if you choose to refactor
    module **A** in the future, perhaps to remove the dependency on **B**. This is
    why I would still recommend wrapping types and preventing leakage of dependent
    types in your APIs even if those types are transitively available to the consuming
    module. The primary goal in designing a module should be to establish a purpose
    and an API for a module, and not to blindly add whateverÂ  `requires` declarations
    it takes just to get things to work!
  prefs: []
  type: TYPE_NORMAL
- en: Pattern 11 - Aggregator and facade modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at aggregator modules in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Readability, and Accessibility*. Aggregator modules allows
    us to create modules that consolidate a set of libraries that are commonly used
    so that the consumers can require just one aggregator module rather than the more
    tedious process of finding the right list of modules to require. Using aggregator
    modules is a good pattern to use when you have multiple modules in your application
    that need a standard set of dependencies to be *required*. This not only makes
    the process of establishing dependencies on new modules easier, it also allows
    you to change and update that list of dependencies in one place and have it reflected
    across all other modules in your application or organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example aggregator module that provides transitive dependency
    on three other modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's another pattern that's closely related that I like to call *facade modules*.
    These are an extension of aggregator modules in that they do offer dependencies
    to a group of modules using transitive dependencies, but they might also contain
    logic that deals with types from multiple modules. While aggregator modules just
    do transitive dependencies and do not necessarily contain logic of their own,
    the *facade module* might contain logic to do things like choose an API from one
    of the modules based on certain criteria, co-ordinate and synchronize calls across
    multiple module APIs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Both aggregator and facade modules are designed for special use cases and act
    as *wrappers* around the underlying modules. Since they perform consolidation
    of modules for this reason, they may not offer the best reuse opportunities. But
    that's OK! Like we've discussed before, the best modules to facilitate reuse are
    simple single-purpose modules. However, aggregator and facade modules provide
    a middle ground between extremely fragmented modules that are pain to use and
    specialized modules that are easier to use but lack flexibility. A very handy
    pattern to use in such cases, when you are trying to strike that balance.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the sample code atÂ `09-module-patterns/09-aggregator-and-facade-modules`,
    the module `pattern.nine.facade` acts as an aggregator and facade module that
    consolidates two separate modules--`module.one` and `module.two`. It has a transitive
    dependency on both those modules, so any module that reads `pattern.nine.facade`
    also automatically reads those two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only does the module do that, it also has a thin *facade* API. There''s
    a class it exports--`FacadeApi` that has an example method to illustrate how a
    method can *choose* between two implementations. Here, the method chooses one
    of two implementations based on an input String value. But you can easily imagine
    facade APIs written in such a module that offer help around business rules or
    logic of your application that affects which libraries are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `consumer` module that reads `pattern.nine.facade` has two options.
    It can either access the library modules directly (And it can because of the transitive
    dependencies--it transitively reads both `module.one` and `module.two`). Or, it
    can call the API through the facade method to get help on which one to call. Both
    work perfectly fine, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at some guidelines and best practices to create
    modules and identify module boundaries. When creating a new application or when
    migrating an existing legacy application to Java modules, it's always a good idea
    to have a map of the modules and their interactions designed in advance. We've
    looked at some best practices that let you figure out what a module should be
    made of and what would cause you to segregate logic into separate modules.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at a list of best practices and ideas to use in your code. Many
    of the best practices discussed previously come with simplified code examples.
    Each example is intentionally bare-bone with code that demonstrates just the pattern
    being discussed and little else, so that you can easily pick any of them up and
    tweak them further or apply them in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these patterns in your tool belt, let's tackle a major challenge
    that Java developers will face when moving to Java 9, migration of existing code.
    There have been years and years of Java development and tons of legacy code of
    various complexities that has been built using earlier versions of Java. How do
    we approach moving them to take advantage of Java modules? Before that, would
    they even work with Java 9? Let's begin to answer those questions, as well as
    understand what it takes to get your code read for such a migration in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
