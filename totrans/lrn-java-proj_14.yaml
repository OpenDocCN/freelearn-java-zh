- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Lambda Expressions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: In this chapter, we will cover lambda expressions, which is one of my favorite
    features. Introduced in Java 8, lambda expressions (*lambdas*) brought functional
    programming to Java. First, we will define a *functional interface* and its relationship
    with lambdas. We will demonstrate both custom and API-based lambda expressions.
    We will also explain the concept of “final or effectively final” concerning local
    variables used inside a lambda expression.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍lambda表达式，这是我最喜欢的特性之一。Java 8引入的lambda表达式（*lambdas*）将函数式编程带到了Java。首先，我们将定义*功能接口*及其与lambda的关系。我们将演示自定义和基于API的lambda表达式。我们还将解释关于lambda表达式内部使用的局部变量的“final或实际上是final”的概念。
- en: After that, we will cover method references. We will discuss and present example
    code showing bound, unbound, static, and constructor method references. Lastly,
    we will explain the critical nature of context in understanding method references.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将介绍方法引用。我们将讨论并展示绑定、未绑定、静态和构造方法引用的示例代码。最后，我们将解释上下文在理解方法引用中的关键作用。
- en: 'This chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Understanding lambda expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解lambda表达式
- en: Exploring functional interfaces from the API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API探索功能接口
- en: Mastering method references
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握方法引用
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch14](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch14).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch14](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch14)。
- en: Understanding lambda expressions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解lambda表达式
- en: 'Lambda expressions save on keystrokes and therefore make your code more concise
    and hence, more readable and maintainable. For this to work, the compiler has
    to be able to generate the code that you no longer type in. This brings us to
    our first topic: functional interfaces. To understand lambdas, we must first understand
    functional interfaces.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式节省了按键次数，因此使你的代码更加简洁，从而更易于阅读和维护。为了实现这一点，编译器必须能够生成你不再输入的代码。这把我们带到了我们的第一个主题：功能接口。为了理解lambda表达式，我们首先必须理解功能接口。
- en: Functional Interfaces
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能接口
- en: Recall that an interface has `default`, `static`, `private`, and `abstract`
    methods. A concrete (non-abstract) class that implements an interface must provide
    code for all of the `abstract` methods. *A functional interface is an interface
    with just one abstract method* – `default`, `static`, and `private` methods do
    not count. Neither do any methods inherited from `Object`. This one `abstract`
    method is known as the *functional method*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，接口有`default`、`static`、`private`和`abstract`方法。实现接口的具体（非抽象）类必须为所有`abstract`方法提供代码。*功能接口是一个只有一个抽象方法的接口*
    – `default`、`static`和`private`方法不计入。也不计入从`Object`继承的任何方法。这个唯一的`abstract`方法被称为*功能方法*。
- en: Lambda expressions
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: '*A lambda expression is an instance of a class that implements a functional
    interface.* The lambda is boiled down to its bare essentials. Lambdas look a lot
    like methods (and indeed in some quarters are called “anonymous methods”). However,
    a lambda is an instance with everything, but the method stripped away.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*lambda表达式是实现功能接口的类的实例*。lambda被简化为其基本要素。lambda看起来很像方法（实际上在某些领域被称为“匿名方法”）。然而，lambda是一个实例，除了方法之外，其他所有东西都有。'
- en: 'Let’s start with a sample functional interface and how a regular class would
    implement it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从示例功能接口及其常规类的实现开始：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let us examine the lambda version which does the same thing:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下执行相同操作的lambda版本：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding two lines of code can appear in any method. The first line declares/defines
    the lambda and the second line executes it. Note that, when defining the lambda,
    there is no mention of a class implementing the functional interface `SampleFI`
    and also, there is no mention of the functional method `m()`. In fact, in the
    lambda declaration, the `()` is the parameter list for `m()`, which takes in nothing;
    the `->` token separates the method header from the method body and the `System.out.println("m()")`
    is the code for the method `m()`. Don’t worry, we will explain lambda syntax in
    detail very shortly with further code examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行代码可以出现在任何方法中。第一行声明/定义了lambda表达式，第二行执行它。请注意，在定义lambda时，没有提到实现功能接口`SampleFI`的类，也没有提到功能方法`m()`。实际上，在lambda声明中，`()`是`m()`方法的参数列表，它不接受任何参数；`->`符号将方法头与方法体分开，`System.out.println("m()")`是方法`m()`的代码。别担心，我们很快会用更多的代码示例详细解释lambda语法。
- en: 'Bear in mind that lambdas save us from typing unnecessary code. For this to
    happen, the compiler must generate the (missing) code for us in the background.
    That is why lambdas are only applicable to functional interfaces – the compiler
    can infer a lot from the interface definition, due to the presence of only one
    `abstract` method. The compiler sees the one `abstract` method and knows immediately
    the signature required in the lambda. So, to recap:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，lambda表达式可以节省我们编写不必要的代码。为了实现这一点，编译器必须在后台为我们生成（缺失的）代码。这就是为什么lambda表达式只适用于功能接口——由于只有一个`abstract`方法的存在，编译器可以从接口定义中推断出很多信息。编译器看到这个`abstract`方法，就会立即知道lambda所需的签名。所以，为了总结：
- en: Lambdas make your code more concise
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda使你的代码更简洁
- en: Lambdas only work with functional interfaces
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式只与功能接口一起使用
- en: A lambda expression is an instance of a class that implements a functional interface
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式是实现功能接口的类的实例
- en: Now let us look at some examples.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些例子。
- en: Lambda expressions – example 1
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda表达式 – 示例1
- en: '*Figure 14**.1* presents a custom lambda with an associated functional interface:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.1* 展示了一个与相关功能接口关联的自定义lambda表达式：'
- en: '![ Figure 14.1 – A functional interface with a lambda expression](img/B19793_14_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 带有lambda表达式的功能接口](img/B19793_14_01.jpg)'
- en: Figure 14.1 – A functional interface with a lambda expression
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 带有lambda表达式的功能接口
- en: In this figure, we define a functional interface `SomeFunctionalInterface`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们定义了一个功能接口`SomeFunctionalInterface`。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It has one `abstract` method, named `m()`. As coded, this functional interface,
    `SomeFunctionalInterface`, can now be used in lambda expressions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个名为`m()`的`abstract`方法。按照代码编写，这个功能接口`SomeFunctionalInterface`现在可以用于lambda表达式。
- en: 'Lines 11-13 define the first lambda expression, namely `lambda1`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第11-13行定义了第一个lambda表达式，即`lambda1`：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The reference type is of the `SomeFunctionalInterface` type, our functional
    interface type. The `lambda1` reference is assigned (to refer to) the instance
    of the class that implements `SomeFunctionalInterface`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型是`SomeFunctionalInterface`类型，我们的功能接口类型。`lambda1`引用被分配（以引用）实现`SomeFunctionalInterface`的类的实例。
- en: On the right-hand side of the assignment are round brackets, `()`. These are
    for the `m()` method in the interface, `SomeFunctionalInterface`. No parameters
    have been defined in the method declaration in the interface, so there are no
    parameters being passed in. As there are no parameters, `()` is required. Note
    that there is no need to mention the method name – this is because, as `SomeFunctionalInterface`
    is a functional interface, the compiler knows the only `abstract` method is `m()`.
    And as `m()` defines no parameters, the lambda header is simply `()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值的右侧是圆括号`()`。这些是为接口中的`m()`方法，即`SomeFunctionalInterface`。在接口的方法声明中没有定义任何参数，因此没有传递任何参数。由于没有参数，所以需要`()`。请注意，没有必要提到方法名——这是因为，由于`SomeFunctionalInterface`是一个功能接口，编译器知道唯一的`abstract`方法是`m()`。而且由于`m()`没有定义参数，lambda头只是`()`。
- en: The arrow token, `->`, separates the method header (the parameters coming in,
    if any) from the method body. In this instance, the method body is a block of
    code; in other words, there are curly braces `{}`, as there would be in a normal
    method. Once you specify a block of code, the usual rules with a block are followed
    – meaning, the compiler backs off and does nothing for you. For example, if you
    wanted to `return` something from the block, you must do this yourself. In the
    next example, we will see that the compiler will do the `return` for you, provided
    you do not use a code block.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头符号 `->` 将方法头（如果有参数传入）与方法体分开。在这个例子中，方法体是一段代码块；换句话说，就像在普通方法中一样，有花括号 `{}`。一旦指定了一个代码块，就遵循通常的代码块规则——这意味着编译器会退后一步，不会为你做任何事情。例如，如果你想从代码块中返回某个值，你必须自己这样做。在下一个例子中，我们将看到，如果你不使用代码块，编译器会为你执行
    `return`。
- en: The lambda in this example is simply outputting `"First lambda!"` to the screen.
    The semi-colon on line 13 is the normal end of statement token. Lines 11-13 simply
    *define* the lambda. No code has been executed at this point.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的lambda只是将 `"First lambda!"` 输出到屏幕上。第13行的分号是正常的语句结束标记。第11-13行只是 *定义* lambda。到目前为止还没有执行任何代码。
- en: Line 15, `lambda1.m()` executes the lambda referred to by `lambda1`, resulting
    in `"First lambda!"` being output to the screen.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第15行，`lambda1.m()` 执行了由 `lambda1` 指向的lambda表达式，导致屏幕上输出 `"First lambda!"`。
- en: 'Line 17 defines a similar lambda except that it is even more concise:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第17行定义了一个类似的lambda，但它更加简洁：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This lambda, `lambda2`, takes advantage of the fact that the compiler can do
    even more work for us. If you have only one statement to execute, then, as with
    other constructs such as loops, a set of curly braces is not necessary. As we
    are only executing `System.out.println()`, we do not need the curly braces, `{}`.
    The semi-colon at the end of line 17 is actually for the end of the assignment
    statement and not the end of `System.out.println()`. In other words, the semi-colon
    at the end of line 17 is the same semi-colon at the end of line 13 (and not the
    semi-colon at the end of line 12).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda，`lambda2`，利用了编译器可以为我们做更多工作的特点。如果你只有一个要执行的语句，那么，就像循环等其他结构一样，不需要花括号 `{}`。因为我们只执行
    `System.out.println()`，所以我们不需要花括号。第17行末尾的分号实际上是赋值语句的结束，而不是 `System.out.println()`
    的结束。换句话说，第17行末尾的分号与第13行末尾的分号相同（而不是第12行末尾的分号）。
- en: Again, line 17 only defines the lambda and no code has been executed. Line 18,
    `lambda2.m()` executes the lambda, resulting in `"Second lambda!"` being output
    to the screen.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，第17行只定义了lambda，没有执行任何代码。第18行，`lambda2.m()` 执行了lambda，导致屏幕上输出 `"Second lambda!"`。
- en: Note, the `@FunctionalInterface` annotation (line 3 in *Figure 14**.1*). This
    annotation ensures that the interface defines only one `abstract` method. Although
    optional, it is good practice to use it, as it highlights to other developers
    our intention with this interface. In addition, use of this annotation enables
    the compiler to step in if we fail to provide exactly one `abstract` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`@FunctionalInterface` 注解（*图14*.1中的第3行）。这个注解确保接口只定义了一个 `abstract` 方法。尽管这个注解是可选的，但使用它是良好的实践，因为它向其他开发者表明了我们使用这个接口的意图。此外，使用这个注解允许编译器在我们未能提供确切的一个
    `abstract` 方法时介入。
- en: Let’s look at another example. This time, the functional method will accept
    a parameter and return a value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。这次，功能方法将接受一个参数并返回一个值。
- en: Lambda expressions – example 2
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda表达式——示例2
- en: '*Figure 14**.2* presents an example that will enable us to discuss further
    nuances:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14*.2 展示了一个示例，这将使我们能够进一步讨论细微差别：'
- en: '![Figure 14.2 - A more complex functional interface with a lambda expression](img/B19793_14_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 - 带有lambda表达式的更复杂功能接口](img/B19793_14_02.jpg)'
- en: Figure 14.2 - A more complex functional interface with a lambda expression
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 - 带有lambda表达式的更复杂功能接口
- en: In this figure, the `Evaluate` function interface is generically typed for `<T>`.
    This means that we can use it for various types, such as `Integer` (line 12) and
    `String` (line 16). The `check` functional method (line 8) takes in a parameter
    of type `T`, namely `t`, and returns a `boolean` value. This particular functional
    interface is very similar to one we will look at later from the Java API, namely
    `Predicate`. By way of contrast, the first lambda (line 12) is coded quite differently
    from the second lambda (line 16).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`Evaluate`函数接口泛型类型为`<T>`。这意味着我们可以为各种类型使用它，例如`Integer`（第12行）和`String`（第16行）。`check`功能方法（第8行）接受一个类型为`T`的参数，即`t`，并返回一个`boolean`值。这个特定的功能接口与我们稍后将在Java
    API中看到的非常相似，即`Predicate`。相比之下，第一个lambda（第12行）的编码与第二个lambda（第16行）的编码相当不同。
- en: On line 12, we declare an `Evaluate` reference, namely `isItPositive`, that
    is typed for integers only. With lambdas, context is key. As we have typed `isItPositive`
    for `Integer`, this means that the identifier, `n`, in round brackets is of the
    `Integer` type! We have explicitly specified the type for `n` in this example,
    but this is not necessary since the compiler can figure it out from the context.
    In other words, we could have just used `(n)` or simply `n` in the lambda and
    it would have worked. We just left it as `(Integer n)` so that the relationship
    between the lambda (line 12) and the `check(T t)` functional method (line 8) is
    clearer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12行，我们声明了一个`Evaluate`引用，即`isItPositive`，它仅用于整数。使用lambda表达式时，上下文至关重要。由于我们将`isItPositive`的类型指定为`Integer`，这意味着括号中的标识符`n`是`Integer`类型！我们在本例中明确指定了`n`的类型，但这是不必要的，因为编译器可以从上下文中推断出来。换句话说，我们本可以使用`(n)`或简单地使用`n`在lambda表达式中，它也会正常工作。我们只是将其留为`(Integer
    n)`，以便lambda表达式（第12行）和`check(T t)`功能方法（第8行）之间的关系更清晰。
- en: The right-hand side of `=` on line 12 we have `(Integer n) -> {return n>0;}`.
    This is the code for the `check(T t)` method in the class implementing `Evaluate`.
    Therefore, one parameter is required, typed for `Integer` due to the `Evaluate<`*Integer*`>`
    declaration, and a `boolean` value must be returned.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第12行的`=`右侧我们有`(Integer n) -> {return n>0;}`。这是实现`Evaluate`类的`check(T t)`方法的代码。因此，需要一个参数，由于`Evaluate<`*Integer*`>`声明，参数类型为`Integer`，并且必须返回一个`boolean`类型的值。
- en: We have the `->` token again to separate the method header from the method body.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`->`符号来区分方法头和方法体。
- en: On line 12, as with all lambdas, the right-hand side of the `->` token is the
    method body. In this case, we have `{return n>0;}`. As we have used curly braces,
    we must follow regular syntax rules when inside a code block. Given that the `check(T
    t)` method has a `boolean` return type, we must return a `boolean` value from
    the code block. Also, the `return` statement requires a closing semi-colon as
    usual. The overall assignment statement requires a closing semi-colon also. This
    is why there are two semi-colons near the end (line 12). What we are saying in
    this lambda is that if the `Integer` type passed in is greater than 0, we return
    `true`; otherwise, we return `false`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12行，与所有lambda表达式一样，`->`符号的右侧是方法体。在这种情况下，我们有`{return n>0;}`。由于我们使用了花括号，我们必须在代码块内部遵循常规语法规则。鉴于`check(T
    t)`方法返回类型为`boolean`，我们必须从代码块中返回一个`boolean`值。此外，`return`语句需要像往常一样有一个分号作为结束符。整个赋值语句也需要一个分号作为结束符。这就是为什么在行尾附近有两个分号（第12行）。在这个lambda表达式中，我们说的是，如果传入的`Integer`类型大于0，我们返回`true`；否则，返回`false`。
- en: Line 13, `isItPositive.check(-1)` executes the lambda, passing in `-1`, which
    returns `false`. Line 14, `isItPositive.check(+1)` also executes the lambda, this
    time passing in `+1`, which returns `true`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第13行，`isItPositive.check(-1)` 执行了lambda表达式，传入`-1`，返回`false`。第14行，`isItPositive.check(+1)`
    同样执行了lambda表达式，这次传入`+1`，返回`true`。
- en: 'Line 16 is: `Evaluate<String> isMale = s -> s.startsWith("Mr.");`. This defines
    an `Evaluate` lambda, typed for `String`, referred to by the `isMale` reference.
    As we typed the lambda for `String`, the parameter this time coming in, namely
    `s`, is of type `String`. Remember, what we are defining on line 16 is effectively
    the code for the `check(T t)` method. Notice that this time, we have not specified
    the type for `s` as the compiler figures it out from the context (`Evaluate<String>`).
    Also, as there is just one parameter and we have not specified the type, we can
    leave out the round brackets, `()`. However, as we have seen already, if you have
    no parameters at all, you must specify `()`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16 行是：`Evaluate<String> isMale = s -> s.startsWith("Mr.");`。这定义了一个 `Evaluate`
    lambda，类型为 `String`，通过 `isMale` 引用。因为我们为 `String` 类型的 lambda 编写了代码，所以这次传入的参数 `s`
    是 `String` 类型。记住，我们在第 16 行定义的是 `check(T t)` 方法的代码。注意，这次我们没有指定 `s` 的类型，因为编译器可以从上下文中推断出来（`Evaluate<String>`）。另外，由于只有一个参数且我们没有指定类型，我们可以省略圆括号，`()`。然而，正如我们已经看到的，如果你没有任何参数，你必须指定
    `()`。
- en: Also, on line 16, note that as we have not used a code block, we do not need
    an explicit `return` statement as the compiler will do that for us. As `s` is
    a `String`, we can call `String` methods; which is why we have no issue calling
    `startsWith("Mr.")`. The semi-colon at the end of the line is for the overall
    assignment statement and not for the lambda (as none is required). In this lambda,
    we just evaluate the string passed in to see if it begins with “Mr.” and if it
    does, `true` is returned; otherwise, `false` is returned.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在第 16 行，请注意，由于我们没有使用代码块，我们不需要显式的 `return` 语句，因为编译器会为我们完成这个工作。由于 `s` 是 `String`
    类型，我们可以调用 `String` 方法；这就是为什么我们可以没有问题地调用 `startsWith("Mr.")`。行尾的分号是用于整个赋值语句的，而不是用于
    lambda（因为不需要）。在这个 lambda 中，我们只是评估传入的字符串是否以“Mr.”开头，如果是，则返回 `true`；否则，返回 `false`。
- en: With the lambda now defined, we can execute it. Line 17, `isMale.check("Mr.
    Sean Kennedy")` returns `true` and line 18, `isMale.check("Ms. Maaike van Putten")`
    returns `false`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在lambda已经定义，我们可以执行它。第 17 行，`isMale.check("Mr. Sean Kennedy")` 返回 `true`，第 18
    行，`isMale.check("Ms. Maaike van Putten")` 返回 `false`。
- en: 'As you can see, the compiler infers a lot, saving us a lot of typing. It takes
    a while to get used to lambdas but once you do, you will love them. *Table 14.1*
    summarizes the syntax:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，编译器推断了很多，这为我们节省了很多打字。适应 lambda 需要一段时间，但一旦适应了，你就会爱上它们。*表 14.1* 总结了语法：
- en: '| **Functional Interface** | **Sample** **Lambda Expressions** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **功能接口** | **示例 Lambda 表达式** |'
- en: '| `interface FI{``void m();``}` | `FI fi1 = () ->` `System.out.println("lambda");``fi1.m();
    //` `outputs "lambda"``FI fi2 = () -> { System.out.println("lambda"); } ;``fi2.m();
    //` `outputs "lambda"` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `interface FI{``void m();``}` | `FI fi1 = () ->` `System.out.println("lambda");``fi1.m();
    //` `outputs "lambda"``FI fi2 = () -> { System.out.println("lambda"); } ;``fi2.m();
    //` `outputs "lambda"` |'
- en: '| `interface FI{``int` `m(int x);``}` | `FI fi3 = (int x) -> { return x *`
    `x;};``System.out.println(fi3.m(5)); //` `25``FI fi4 = x -> x *` `x;``System.out.println(fi4.m(6));
    //` `36` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `interface FI{``int` `m(int x);``}` | `FI fi3 = (int x) -> { return x *`
    `x;};``System.out.println(fi3.m(5)); //` `25``FI fi4 = x -> x *` `x;``System.out.println(fi4.m(6));
    //` `36` |'
- en: '| `interface FI{``String m(String a,` `String b);``}` | `FI fi5 = (s1, s2)
    -> s1 +` `s2;``// next line returns ''``Sean Kennedy''``System.out.println(fi5.m("Sean",
    "` `Kennedy"));``FI fi6 = (String s1 , String s2) -> {return s1 +` `s2; };``//
    next line returns ''``Sean Kennedy''``System.out.println(fi6.m("Sean", "` `Kennedy"));`
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `interface FI{``String m(String a,` `String b);``}` | `FI fi5 = (s1, s2)
    -> s1 +` `s2;``// 下一行返回 ''``Sean Kennedy''``System.out.println(fi5.m("Sean", "`
    `Kennedy"));``FI fi6 = (String s1 , String s2) -> {return s1 +` `s2; };``// 下一行返回
    ''``Sean Kennedy''``System.out.println(fi6.m("Sean", "` `Kennedy"));` |'
- en: Table 14.1 – Examples of functional interfaces and associated lambda expressions
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.1 – 功能接口及其相关 lambda 表达式的示例
- en: The longer syntax, with the parameter types, code blocks, and `return` statements,
    is syntactically similar to regular methods (except the method name is omitted).
    The shorter, more concise syntax, demonstrates just how much the compiler can
    infer from the surrounding context. This is possible as there is only one `abstract`
    method in a functional interface. Lambdas cannot and do not work with interfaces
    that have more than one `abstract` method. As interfaces can inherit from each
    other, be wary of inheriting an `abstract` method and then trying to define your
    own – that will not work for lambdas.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 较长的语法，包括参数类型、代码块和 `return` 语句，在语法上与常规方法类似（除了方法名被省略）。较短的、更简洁的语法展示了编译器可以从周围上下文中推断出多少。这是可能的，因为函数式接口中只有一个
    `abstract` 方法。Lambda 不能也不适用于具有多个 `abstract` 方法的接口。由于接口可以相互继承，所以要小心继承一个 `abstract`
    方法然后尝试定义自己的——这对 Lambda 是不起作用的。
- en: Now that we understand functional interfaces and how to implement them using
    lambda expressions, let’s examine why local variables must be `final` or “effectively
    final.”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了函数式接口以及如何使用 Lambda 表达式实现它们，让我们来探讨为什么局部变量必须是 `final` 或“实际上最终”。
- en: final or effectively final
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: final 或实际上最终
- en: Recall that by declaring a variable `final`, you are making it a constant, which
    means that the value of the variable, once assigned, cannot be changed. “Effectively
    final” means that even though the `final` keyword is not used in the variable
    declaration, the compiler makes it *effectively final* by ensuring that if you
    try to change its value, you get a compiler error. Note that this rule of `final`
    or “effectively final” relates only to local variables and does not apply to instance
    or class variables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，通过声明一个变量 `final`，你正在将其声明为一个常量，这意味着变量的值一旦赋值后就不能更改。“实际上最终”意味着尽管在变量声明中没有使用
    `final` 关键字，但编译器通过确保如果你尝试更改其值，你会得到编译器错误来使其成为“实际上最终”。请注意，这个 `final` 或“实际上最终”的规则仅适用于局部变量，不适用于实例或类变量。
- en: '*Figure 14**.3* presents code demonstrating the use of `final` or “effectively
    final”. We will first explain the code and then explain why the local variable
    is “effectively final.”'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14**.3* 展示了使用 `final` 或“实际上最终”的代码示例。我们首先解释代码，然后解释为什么局部变量是“实际上最终”的。'
- en: '![Figure 14.3 – “final” or “effectively final” code example](img/B19793_14_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – “final”或“实际上最终”代码示例](img/B19793_14_03.jpg)'
- en: Figure 14.3 – “final” or “effectively final” code example
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – “final”或“实际上最终”代码示例
- en: In this figure, the algorithm removes any names from the list that begin with
    `"Mr."`. Lines 9-11 declare and populate an `ArrayList` list.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，算法从列表中删除了以 `"Mr."` 开头的任何名称。第 9-11 行声明并填充了一个 `ArrayList` 列表。
- en: Line 13 declares a local `String` variable named `title`. This variable is used
    in the lambda (line 21) and therefore, as it is not explicitly declared `final`,
    it is “effectively final.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 行声明了一个名为 `title` 的局部 `String` 变量。这个变量在 Lambda（第 21 行）中使用，因此，由于它没有明确声明为
    `final`，它是“实际上最终”的。
- en: Lines 14-15 declare and change a local `int` variable, `y`. As `y` is not used
    in the lambda expression, this is fine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第 14-15 行声明并更改了一个局部 `int` 变量 `y`。由于 `y` 在 Lambda 表达式中没有使用，这是可以的。
- en: 'Lines 19-22 present the lambda expression:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第 19-22 行展示了 Lambda 表达式：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The lambda is a `Predicate`, typed for `String`. `Predicate` is an API functional
    interface, which we will discuss in detail in the next section. The functional
    method for `Predicate` is `boolean test(T t)`. As we have typed the `Predicate`
    for `String`, both `T` and consequently `str` are `String`’s. The lambda returns
    `true` or `false` depending on whether `str` begins with `"Mr."`, thereby matching
    the return type of the `test` functional method. This is an important point –
    the lambda has taken a snapshot of the value in the local variable `title`; which
    is `"Mr."`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 是一个 `Predicate`，其类型为 `String`。`Predicate` 是一个 API 函数式接口，我们将在下一节中详细讨论。`Predicate`
    的函数式方法是 `boolean test(T t)`。由于我们已经将 `Predicate` 类型化为 `String`，因此 `T` 以及随之而来的 `str`
    都是 `String` 类型。Lambda 返回 `true` 或 `false`，这取决于 `str` 是否以 `"Mr."` 开头，从而匹配 `test`
    函数式方法的返回类型。这是一个重要的点——Lambda 已经捕捉了局部变量 `title` 中的值；即 `"Mr."`。
- en: Both lines 27 and 30 invoke `filterData(people, lambda)`. This is one of the
    real advantages of lambdas – they can be passed around! But remember, the value
    of `title` in the lambda is `"Mr."`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第 27 行和第 30 行都调用了 `filterData(people, lambda)`。这是 Lambda 的一个真正优点——它们可以被传递！但记住，Lambda
    中的 `title` 值是 `"Mr."`。
- en: 'Lines 32-34 show the `filterData()` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第 32-34 行显示了 `filterData()` 方法：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The lambda is passed to the `default` method, `removeIf(Predicate)`, which is
    inherited from `Collection`. `Collection` is a parent interface of `List`. `removeIf(Predicate)`
    removes all elements from the list that satisfy the predicate (lambda) passed
    in. In this example, any names that begin with `"Mr."` are removed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 被传递到从 `Collection` 继承的 `default` 方法 `removeIf(Predicate)`。`Collection`
    是 `List` 的父接口。`removeIf(Predicate)` 从列表中删除所有满足传入的谓词（lambda）的元素。在这个例子中，任何以 `"Mr."`
    开头的名字都被删除。
- en: Now, you can see why the value of `title` (line 13) must never be allowed to
    change – the lambda uses `"Mr."` (line 21). If we were allowed to change `title`,
    either in the lambda (line 20) or in the method (lines 26 or 29), then the value
    of `title` in the method and the value of `title` in the lambda would not match!
    This must not happen. Therefore, any changes to `title`, either in the method
    or in the lambda, are prohibited. This is why lines 20, 26, and 29 are all commented
    out. Uncommenting any of them results in a compiler error.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到为什么 `title`（第 13 行）的值绝对不能改变——lambda 使用了 `"Mr."`（第 21 行）。如果我们允许在 lambda（第
    20 行）或方法（第 26 行或第 29 行）中更改 `title`，那么方法中的 `title` 值和 lambda 中的 `title` 值就不会匹配！这种情况绝对不能发生。因此，无论是方法还是
    lambda 中的 `title` 任何更改都是被禁止的。这就是为什么第 20 行、第 26 行和第 29 行都被注释出来的原因。取消注释任何一行都会导致编译器错误。
- en: Exploring functional interfaces from the API
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 API 中的函数式接口
- en: Now, let’s examine some popular functional interfaces defined in the API. Interestingly,
    the two sorting interfaces from [*Chapter 13*](B19793_13.xhtml#_idTextAnchor317),
    namely `Comparator` and `Comparable`, are both functional interfaces. `Comparable`
    defines one `abstract` method, namely `int compareTo(T o)`, and `Comparator` defines
    two `abstract` methods, namely `int compare(T o1, T o2)` and `boolean equals(Object
    o)`. Remember, however, that methods inherited from `Object` do not count when
    you’re deciding if an interface is a functional interface or not. As `boolean
    equals(Object o)` is inherited from `Object`, this means that `Comparator` is
    a functional interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查 API 中定义的一些流行的函数式接口。有趣的是，来自[*第 13 章*](B19793_13.xhtml#_idTextAnchor317)的两个排序接口
    `Comparator` 和 `Comparable` 都是函数式接口。`Comparable` 定义了一个 `abstract` 方法，即 `int compareTo(T
    o)`，而 `Comparator` 定义了两个 `abstract` 方法，即 `int compare(T o1, T o2)` 和 `boolean
    equals(Object o)`。然而，请记住，从 `Object` 继承的方法在您决定一个接口是否是函数式接口时不计算在内。由于 `boolean equals(Object
    o)` 是从 `Object` 继承的，这意味着 `Comparator` 是一个函数式接口。
- en: 'In this section, we will concentrate on the functional interfaces defined in
    the `java.util.function` package ([https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html)).
    This package has a large number of general-purpose functional interfaces that
    are used by the JDK and are available to us also. *Table 14.2* presents the most
    commonly used ones. Please refer to the API for further details. We will examine
    these functional interfaces and their lambda expressions in code shortly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将集中讨论在 `java.util.function` 包中定义的函数式接口([https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html))。此包包含大量通用函数式接口，这些接口由
    JDK 使用，也对我们可用。*表 14.2* 展示了最常用的几个。请参考 API 获取更多详细信息。我们将很快检查这些函数式接口及其 lambda 表达式：
- en: '| **Functional Interface** | **Functional Method** | **Description** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **函数式接口** | **函数式方法** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Predicate<T>` | `boolean` `test(T t)` | Useful for testing |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `Predicate<T>` | `boolean test(T t)` | 适用于测试 |'
- en: '| `BiPredicate<T, U>` | `boolean test(T t,` `U u)` | This is a two-arity (two
    parameters) specialization of `Predicate` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `BiPredicate<T, U>` | `boolean test(T t, U u)` | 这是 `Predicate` 的双参数特殊化 |'
- en: '| `Supplier<T>` | `T get()` | Useful for when you want values without providing
    input |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Supplier<T>` | `T get()` | 适用于您想要值而不提供输入时 |'
- en: '| `Consumer<T>` | `void` `accept(T t)` | Useful for when you pass in input
    but do not care about a return value |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Consumer<T>` | `void accept(T t)` | 适用于您传入输入但不关心返回值时 |'
- en: '| `BiConsumer<T, U>` | `void accept(T t,` `U u)` | This is a two-arity specialization
    of `Consumer` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `BiConsumer<T, U>` | `void accept(T t, U u)` | 这是 `Consumer` 的双参数特殊化 |'
- en: '| `Function<T, R>` | `R` `apply(T t)` | Transforms the input into an output
    (types can be different) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `Function<T, R>` | `R apply(T t)` | 将输入转换为输出（类型可以不同） |'
- en: '| `BiFunction<T,` `U, R>` | `R apply(T t,` `U u)` | This is a two-arity specialization
    of `Function` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `BiFunction<T, U, R>` | `R apply(T t, U u)` | 这是 `Function` 的双参数特殊化 |'
- en: '| `UnaryOperator<T>` | `T` `apply(T t)` | The same as `Function` except the
    types are the same |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `UnaryOperator<T>` | `T apply(T t)` | 与 `Function` 相同，但类型相同 |'
- en: '| `BinaryOperator<T>` | `T apply(T t1,` `T t2`) | The same as `BiFunction`
    except the types are all the same |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `BinaryOperator<T>` | `T apply(T t, T t2)` | 与 `BiFunction` 相同，但类型都是相同的 |'
- en: Table 14.2 – Popular functional interfaces in the API
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.2 – API 中流行的函数式接口
- en: Now, let’s examine each of the preceding functional interfaces and their associated
    lambdas in code. Let’s start with `Predicate` and `BiPredicate`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查前面提到的每个函数式接口及其相关的代码中的 lambda 表达式。让我们从 `Predicate` 和 `BiPredicate` 开始。
- en: Predicate and BiPredicate
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谓词和双谓词
- en: 'A predicate is a boolean-valued function (a function that will return `boolean`).
    *Figure 14**.4* presents `Predicate` and `BiPredicate`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词是一个布尔值函数（一个将返回 `boolean` 的函数）。*图 14.4* 展示了 `Predicate` 和 `BiPredicate`：
- en: '![Figure 14.4 – Predicate and BiPredicate in code](img/B19793_14_04.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 代码中的谓词和双谓词](img/B19793_14_04.jpg)'
- en: Figure 14.4 – Predicate and BiPredicate in code
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 代码中的谓词和双谓词
- en: In this figure, we would first like to discuss the relationship in the API between
    the generic types of functional interfaces and their functional methods. Understanding
    this relationship is key to understanding the examples and creating the context
    used by the compiler. This context will be very important when we discuss method
    references later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们首先想讨论 API 中函数式接口的泛型类型与其函数式方法之间的关系。理解这种关系对于理解示例和创建编译器使用的上下文至关重要。当我们讨论方法引用时，这个上下文将非常重要。
- en: As the comments on lines 32-33 indicate, there is a direct relationship between
    the generic types and both the parameter and return types used by the functional
    method. In this case, `Predicate` is generically typed for `T` (line 32), and
    the functional methods input parameter is also typed for `T` (line 33). Therefore,
    if we type our `Predicate` for `Integer`, then the parameter in the functional
    method will be `Integer`. We cannot pass `Cat`, `Dog`, `String`, or any other
    type as an argument. Now, let’s look at the example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 32-33 行的注释所示，泛型类型与函数式方法使用的参数和返回类型之间存在直接关系。在这种情况下，`Predicate` 的泛型类型为 `T`（第
    32 行），函数式方法的输入参数也针对 `T` 类型化（第 33 行）。因此，如果我们为 `Predicate` 类型化为 `Integer`，那么函数式方法中的参数将是
    `Integer`。我们不能传递 `Cat`、`Dog`、`String` 或任何其他类型作为参数。现在，让我们看看例子。
- en: Line 34 defines a `Predicate`, generically typed for `String`, namely `isCityInName`.
    `cityName -> cityName.contains("City")` is the code for the `boolean test(T t)`
    functional method. As the generic type is `String`, `T` is now `String` for this
    functional method, meaning that the parameter type is `String`. Thus, the `cityName`
    variable on line 34 represents a `String` variable. This is why the compiler has
    no issue with `cityName.contains("City")` in the lambda expression. As `cityName.contains("City")`
    is a simple expression, we do not need `{}` or a `return` statement – the compiler
    will fill all that in for us. Bear in mind that the expression we use must return
    a `boolean` value as the `boolean test(T t)` functional method returns `boolean`.
    The `String` method, `boolean contains(CharSequnce)`, does exactly that, so we
    are fine. So, with our lambda expression defined, let’s execute it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第 34 行定义了一个 `Predicate`，泛型类型为 `String`，即 `isCityInName`。`cityName -> cityName.contains("City")`
    是 `boolean test(T t)` 函数式方法的代码。由于泛型类型是 `String`，`T` 在这个函数式方法中现在是 `String`，这意味着参数类型是
    `String`。因此，第 34 行的 `cityName` 变量代表一个 `String` 变量。这就是为什么编译器在 lambda 表达式中对 `cityName.contains("City")`
    没有问题。由于 `cityName.contains("City")` 是一个简单的表达式，我们不需要 `{}` 或 `return` 语句——编译器会为我们填写所有这些。请注意，我们使用的表达式必须返回一个
    `boolean` 值，因为 `boolean test(T t)` 函数式方法返回 `boolean`。`String` 方法 `boolean contains(CharSequnce)`
    正好做到这一点，所以我们没问题。因此，在我们的 lambda 表达式定义之后，让我们执行它。
- en: Line 35 executes the `isCityInName` lambda defined on line 34\. Note that the
    method that’s invoked using the `isCityInName` reference is the `boolean test(T
    t)` functional method. As we have generically typed `isCityInName` to `String`,
    the argument we pass must be a `String` argument. This is what we do, passing
    in `"Vatican City"`. This means that the `cityName` parameter in our lambda (line
    34) becomes `"Vatican City"` and thus the code in the `boolean test(T t)` method
    becomes `"Vatican City".contains("City")`. Consequently, line 35 outputs `true`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第35行执行了第34行定义的`isCityInName` lambda。请注意，使用`isCityInName`引用调用的方法是`boolean test(T
    t)`函数式方法。由于我们将`isCityInName`泛型化为`String`，我们传入的参数必须是`String`类型的参数。这正是我们所做的，传入`"Vatican
    City"`。这意味着我们的lambda（第34行）中的`cityName`参数变为`"Vatican City"`，因此`boolean test(T t)`方法中的代码变为`"Vatican
    City".contains("City")`。因此，第35行输出`true`。
- en: Line 39 defines a `BiPredicate`, generically typed for `String, Integer`; namely
    `checkStringLength` Again, the comments (lines 37-38), demonstrate the close relationship
    between the functional interface’s generic types and the parameters for the functional
    method. `BiPredicate` is simply an extension of `Predicate` except that there
    are now two (input) parameters for the functional method, instead of one. The
    functional method name is still `test` and the return type is again `boolean`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第39行定义了一个泛型为`String, Integer`的`BiPredicate`，即`checkStringLength`。同样，注释（第37-38行）展示了函数式接口的泛型类型与函数式方法参数之间的紧密关系。`BiPredicate`只是`Predicate`的扩展，除了函数式方法现在有两个（输入）参数，而不是一个。函数式方法名称仍然是`test`，返回类型仍然是`boolean`。
- en: As `checkStringLength` is defined as `BiPredicate<String, Integer>`, the signature
    for the functional method is now `boolean test(String str, Integer len)`. The
    lambda then checks if the length of the string passed in as the first parameter,
    is equal to the number passed in as the second parameter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`checkStringLength`被定义为`BiPredicate<String, Integer>`，函数式方法的签名现在是`boolean
    test(String str, Integer len)`。然后lambda检查作为第一个参数传入的字符串的长度是否等于作为第二个参数传入的数字。
- en: On line 40, we test `BiPredicate`, passing in `"Vatican City"` and `8` in that
    order. The lambda returns `false` as the length of the `"Vatican City"` string
    is `12` (and not `8`).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在第40行，我们测试`BiPredicate`，按照顺序传入`"Vatican City"`和`8`。由于`"Vatican City"`字符串的长度是`12`（而不是`8`），lambda返回`false`。
- en: 'As discussed earlier, both `Predicate` and `BiPredicate` are generically typed
    for `T`. This means that their functional method consumes a type, `T`, such as
    `String`, `Integer`, and so forth. This is in contrast to predicates that consume
    primitives. The following table, *Table 14.3*, presents the functional interfaces
    defined in the API for predicates that wish to consume primitives:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Predicate`和`BiPredicate`都对`T`进行了泛型化。这意味着它们的函数式方法消耗一个类型`T`，例如`String`、`Integer`等。这与消耗原始类型的谓词形成对比。以下表格，*表14.3*，展示了API中为希望消耗原始类型的谓词定义的函数式接口：
- en: '| **Functional Interface** | **Functional Method** | **Example** |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **功能接口** | **功能方法** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `DoublePredicate` | `boolean` `test(double value)` | `DoublePredicate p1
    = d -> d >` `0;` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `DoublePredicate` | `boolean test(double value)` | `DoublePredicate p1 =
    d -> d > 0;` |'
- en: '| `IntPredicate` | `boolean` `test(int value)` | `IntPredicate p2 = i -> i
    >` `0;` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `IntPredicate` | `boolean test(int value)` | `IntPredicate p2 = i -> i >
    0;` |'
- en: '| `LongPredicate` | `boolean` `test(long value)` | `LongPredicate p3 = lg ->
    lg >` `0;` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `LongPredicate` | `boolean test(long value)` | `LongPredicate p3 = lg ->
    lg > 0;` |'
- en: Table 14.3 – Primitive testing specializations of Predicate in the API
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.3 – API中Predicate的原始测试特殊化
- en: As can be seen from the table, there are no generic types, such as `<T>` in
    the names of the functional interfaces. The functional methods have primitive
    parameters (instead of generic types). As we are dealing with primitives, the
    lambdas cannot invoke methods on the arguments (as primitives are just simple
    types and have no methods).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从表中可以看出，函数式接口的名称中没有泛型类型，例如`<T>`。函数式方法具有原始参数（而不是泛型类型）。由于我们处理的是原始类型，lambda不能在参数上调用方法（因为原始类型只是简单类型，没有方法）。
- en: Now, let’s discuss the `Supplier` functional interface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论`Supplier`函数式接口。
- en: Supplier
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Supplier
- en: '*Figure 14**.5* presents code that demonstrates `Supplier`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.5* 展示了演示`Supplier`的代码：'
- en: '![Figure 14.5 – Supplier in code](img/B19793_14_05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 代码中的Supplier](img/B19793_14_05.jpg)'
- en: Figure 14.5 – Supplier in code
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 代码中的Supplier
- en: The `Supplier` functional interface is very useful when you want a new object.
    The generic type determines the result supplied. In other words, line 47 types
    `supSB` for `StringBuilder`, where the functional method, `get()`, returns `StringBuilder`.
    Line 47 also demonstrates that if you have no parameters at all, you must specify
    the round brackets, `()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要一个新对象时，`Supplier`函数式接口非常有用。泛型类型决定了提供的结果。换句话说，第47行将`supSB`类型化为`StringBuilder`，其中函数式方法`get()`返回`StringBuilder`。第47行还演示了如果没有参数，你必须指定圆括号`()`。
- en: Line 48 executes the lambda expression defined on line 47\. Note that we chain
    `append("SK")` onto the return of the `get()` method. This will only work if the
    `get()` method returns a `StringBuilder` object, which it does.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第48行执行了第47行定义的lambda表达式。请注意，我们将`append("SK")`链接到`get()`方法的返回值。这只有在`get()`方法返回`StringBuilder`对象时才能工作，它确实是这样。
- en: Line 50 defines a `Supplier` functional interface, typed for `LocalTime`, called
    `supTime`. The lambda returns the local time. Line 51 executes it by invoking
    the functional method for `Supplier`, namely `T get()`. The output from a sample
    run is included in a comment on the right-hand side.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第50行定义了一个针对`LocalTime`的`Supplier`函数式接口，称为`supTime`。lambda表达式返回本地时间。第51行通过调用`Supplier`的函数式方法`T
    get()`来执行它。一个示例运行的输出包含在右侧的注释中。
- en: Line 53 defines a `Supplier` functional interface typed for `Double` called
    `sRandom`, which returns a random number. `Math.random()` returns a `double` value
    greater than or equal to 0.0 and less than 1.0\. Line 54 executes it with sample
    output in a comment on the right.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第53行定义了一个针对`Double`的`Supplier`函数式接口，称为`sRandom`，它返回一个随机数。`Math.random()`返回一个大于或等于0.0且小于1.0的`double`值。第54行通过右侧的注释中的示例输出来执行它。
- en: 'The generically typed `Supplier` functional interface also has variants to
    cater to primitives. *Table 14.4* shows these:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型的`Supplier`函数式接口也有针对原始类型的变体。*表14.4*展示了这些：
- en: '| **Functional Interface** | **Functional Method** | **Example** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **函数式接口** | **函数式方法** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `BooleanSupplier` | `boolean getAsBoolean()` | `BooleanSupplier bS = () ->`
    `LocalDate.now().isLeapYear();` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `BooleanSupplier` | `boolean getAsBoolean()` | `BooleanSupplier bS = () ->`
    `LocalDate.now().isLeapYear();` |'
- en: '| `System.out.println(bS.getAsBoolean());` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `System.out.println(bS.getAsBoolean());` |'
- en: '| `DoubleSupplier` | `double getAsDouble()` | `DoubleSupplier dS = () ->` `Math.random();`
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `DoubleSupplier` | `double getAsDouble()` | `DoubleSupplier dS = () ->` `Math.random();`
    |'
- en: '| `System.out.println(dS.getAsDouble());` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `System.out.println(dS.getAsDouble());` |'
- en: '| `IntSupplier` | `int getAsInt()` | `IntSupplier iS = () -> (``int)(Math.random()*20);`
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `IntSupplier` | `int getAsInt()` | `IntSupplier iS = () -> (``int)(Math.random()*20);`
    |'
- en: '| `System.out.println(iS.getAsInt());` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `System.out.println(iS.getAsInt());` |'
- en: '| `LongSupplier` | `long getAsLong()` | `LongSupplier lgS = () -> (``long)(Math.random()*100);`
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `LongSupplier` | `long getAsLong()` | `LongSupplier lgS = () -> (``long)(Math.random()*100);`
    |'
- en: '| `System.out.println(lgS.getAsLong());` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `System.out.println(lgS.getAsLong());` |'
- en: Table 14.4 – Primitive-producing specializations of Supplier in the API
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.4 – API中供应商的原始生成专业化
- en: In this table, the functional interface name identifies the primitive type being
    generated. For example, `BooleanSupplier` produces a `boolean` primitive type.
    The functional method follows accordingly; for example, `BooleanSupplier` has
    a `boolean getAsBoolean()` method. The other functional interfaces follow a similar
    pattern.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，函数式接口的名称标识了生成的原始类型。例如，`BooleanSupplier`生成一个`boolean`原始类型。相应的函数式方法也遵循类似模式；例如，`BooleanSupplier`有一个`boolean
    getAsBoolean()`方法。其他函数式接口也遵循类似的模式。
- en: Now, let’s discuss the `Consumer` and `BiConsumer` functional interfaces.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论`Consumer`和`BiConsumer`函数式接口。
- en: Consumer and BiConsumer
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Consumer和BiConsumer
- en: 'We will start with `Consumer`, which, as per the API, “*represents an operation
    that takes in a single input and returns no result.*” *Figure 14**.6* presents
    code demonstrating the use of `Consumer`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`Consumer`开始，根据API，“*它表示一个接受单个输入但不返回结果的运算操作。*”图14.6*展示了使用`Consumer`的代码示例：
- en: '![Figure 14.6 – Consumer in code](img/B19793_14_06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 代码中的Consumer](img/B19793_14_06.jpg)'
- en: Figure 14.6 – Consumer in code
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 代码中的Consumer
- en: 'In this figure, line 67 (a comment) outlines that the `void accept(T t)` functional
    method does exactly as per the API: it takes in a single input and returns nothing
    (`void`). Consumers are very useful for outputting collections. In this example,
    `Consumer` (line 68) takes in a `String`, `s`, and echoes it to the standard output
    (the screen). We execute the lambda (line 69), passing in the string we want displayed.
    So, the `"To be or not to be, that is the question"` string is the argument to
    the `void accept(T t)` functional method. Here, the `s` parameter (line 68) takes
    on the string value, which is then output.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第67行（注释）说明了`void accept(T t)`这个功能方法确实按照API的要求执行：接受一个输入并返回空（`void`）。消费者对于输出集合非常有用。在这个例子中，`Consumer`（第68行）接受一个`String`类型的`s`，并将其回显到标准输出（屏幕）。我们执行lambda（第69行），传入我们想要显示的字符串。因此，`"To
    be or not to be, that is the question"`这个字符串是`void accept(T t)`这个功能方法的参数。在这里，`s`参数（第68行）接受字符串值，然后输出。
- en: The Iterable interface
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Iterable接口
- en: The `Iterable` interface is inherited by many other popular interfaces, such
    as `List` and `Set`, and consequently, implemented by a large number of classes.
    Before Java 8, interfaces only had `abstract` methods – there were no `default`,
    `static`, or `private` methods (they all came in later releases of Java). This
    meant that if you changed an interface (method signature or added a new method),
    the existing code base would break. One of the main reasons for introducing `default`
    methods was for the Java designers to introduce the `default` method, `forEach(Consumer<?
    super T> action)`, into `Iterable` without breaking the existing code base. The
    default implementation is to execute the `Consumer` lambda on each element in
    the collection.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable`接口被许多其他流行的接口继承，如`List`和`Set`，因此由大量类实现。在Java 8之前，接口只有`abstract`方法——没有`default`、`static`或`private`方法（它们都是在后来的Java版本中引入的）。这意味着如果你更改接口（方法签名或添加新方法），现有的代码库就会崩溃。引入`default`方法的主要原因之一是Java设计者希望在不会破坏现有代码库的情况下，将`default`方法`forEach(Consumer<?
    super T> action)`引入`Iterable`。默认实现是在集合中的每个元素上执行`Consumer` lambda。'
- en: Now, let’s examine how the Java API utilizes consumers. Line 71 declares an
    `ArrayList` of strings, namely `names`. Line 72 adds `"Maaike"` and `"Sean"` to
    the list.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Java API是如何使用消费者的。第71行声明了一个字符串`ArrayList`，名为`names`。第72行将`"Maaike"`和`"Sean"`添加到列表中。
- en: 'Line 73 is very interesting. We execute the `forEach()` method on the list,
    passing in the consumer lambda, `printC`, that was created on line 68\. The `forEach()`
    method loops through each `String` in the list and invokes the `Consumer` lambda,
    `printC`, on each `String`. In effect, the following happens in the background:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第73行非常有趣。我们在列表上执行`forEach()`方法，传入在第68行创建的消费者lambda，`printC`。`forEach()`方法遍历列表中的每个`String`，并对每个`String`调用`Consumer`
    lambda，`printC`。实际上，在后台发生以下操作：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s look at an example of a `BiConsumer` interface in action. *Figure
    14**.7* presents an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`BiConsumer`接口在实际中的应用示例。*图14**.7*展示了这样一个例子：
- en: '![Figure 14.7 – BiConsumer in code](img/B19793_14_07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7 – 代码中的BiConsumer](img/B19793_14_07.jpg)'
- en: Figure 14.7 – BiConsumer in code
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 – 代码中的BiConsumer
- en: In this figure, on line 75, we declare a `Map<String, String>`, namely `mapCapitalCities`,
    implemented by a `HashMap`. Both the key and the value in the map are strings.
    The `BiConsumer` `biCon` is declared on lines 80-81\. The functional method, `void
    accept(T t, U u)`, requires two parameters – we have called them `key` and `value`.
    Both are strings due to the context (the declaration of `biCon`). The lambda on
    line 81, is simply inserting the `key` and `value` into the map. This is known
    as a “side effect” (see the callout). Lines 82-83 populate the map using the lambda
    and line 84 outputs the map.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第75行，我们声明了一个`Map<String, String>`，名为`mapCapitalCities`，由`HashMap`实现。地图中的键和值都是字符串。`BiConsumer`
    `biCon`在第80-81行声明。功能方法`void accept(T t, U u)`需要两个参数——我们称它们为`key`和`value`。由于上下文（`biCon`的声明），两者都是字符串。第81行的lambda只是将`key`和`value`插入到地图中。这被称为“副作用”（见说明）。第82-83行使用lambda填充地图，第84行输出地图。
- en: Side effects
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用
- en: 'In Java, lambda expressions are considered a functional style of programming.
    While functional programming is outside the scope of this book, functions adhering
    to the functional programming style should not generate side effects. A side effect
    is a change to the program state not reflected in the function’s output. `Consumer`s,
    unlike most other functional interfaces in Java, are expected to operate via side
    effects (as the return type for the functional methods is `void`). For further
    detail please see: [https://en.wikipedia.org/wiki/Functional_programming](https://en.wikipedia.org/wiki/Functional_programming)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，lambda表达式被认为是函数式编程风格。虽然函数式编程超出了本书的范围，但遵循函数式编程风格的函数不应产生副作用。副作用是对程序状态的改变，这种改变没有反映在函数的输出中。`Consumer`
    与Java中大多数其他函数式接口不同，预期通过副作用来操作（因为函数式方法的返回类型是 `void`）。有关更多详细信息，请参阅：[https://en.wikipedia.org/wiki/Functional_programming](https://en.wikipedia.org/wiki/Functional_programming)
- en: 'Is there a `forEach()` method for `Map`? Thankfully, there is. It is a `default`
    method defined in the `Map` interface and its signature is `default void forEach(BiConsumer<?
    super K, ? super V) action)`. Lines 86-88 set up the lambda expression to output
    the decorated string, stating that `key` is the capital of `value` (depending
    on the key/value pairs). Line 89 executes `forEach()`, passing in our `BiConsumer`.
    The `forEach()` method loops through each entry in the map and invokes the `BiConsumer`
    lambda, `mapPrint`, on each entry. In effect, the following happens in the background:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Map` 有没有 `forEach()` 方法？幸运的是，有。这是一个在 `Map` 接口中定义的 `default` 方法，其签名是 `default
    void forEach(BiConsumer<? super K, ? super V) action)`。第86-88行设置了lambda表达式以输出装饰后的字符串，指出
    `key` 是 `value` 的首都（取决于键/值对）。第89行执行 `forEach()`，传入我们的 `BiConsumer`。`forEach()`
    方法遍历映射中的每个条目，并对每个条目调用 `BiConsumer` lambda，`mapPrint`。实际上，在后台发生以下操作：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The generically typed `Consumer` functional interface also has variants to
    cater for primitives. *Table 14.5* shows these:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型的 `Consumer` 函数式接口也有针对原始类型的变体。*表14.5* 展示了这些：
- en: '| **Functional Interface** | **Functional Method** | **Example** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **函数式接口** | **函数式方法** | **示例** |'
- en: '| `DoubleConsumer` | `void` `accept(double value)` | `DoubleConsumer dc = d
    ->` `System.out.println(d);` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `DoubleConsumer` | `void` `accept(double value)` | `DoubleConsumer dc = d
    ->` `System.out.println(d);` |'
- en: '| `dc.accept(2.4);` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `dc.accept(2.4);` |'
- en: '| `IntConsumer` | `void` `accept(int value)` | `IntConsumer ic = i ->` `System.out.println(i);`
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `IntConsumer` | `void` `accept(int value)` | `IntConsumer ic = i ->` `System.out.println(i);`
    |'
- en: '| `ic.accept(2);` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `ic.accept(2);` |'
- en: '| `LongConsumer` | `void` `accept(long value)` | `LongConsumer lc = lg ->`
    `System.out.println(lg);` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `LongConsumer` | `void` `accept(long value)` | `LongConsumer lc = lg ->`
    `System.out.println(lg);` |'
- en: '| `lc.accept(8L);` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `lc.accept(8L);` |'
- en: Table 14.5 – Primitive-accepting specializations of Consumer in the API
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.5 – API中Consumer的原始接受特殊化
- en: Again, the primitive name is embedded into the functional interface name. Note
    that the parameter type passed into the `accept()` functional method is a primitive
    each time
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，原始名称嵌入到了函数式接口名称中。请注意，每次传递给 `accept()` 函数式方法的参数类型都是原始类型
- en: Now, let’s discuss the `Function` and `BiFunction` functional interfaces.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论 `Function` 和 `BiFunction` 函数式接口。
- en: Function and BiFunction
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Function 和 BiFunction
- en: 'A function accepts one argument and produces a result. *Figure 14**.8* presents
    some code demonstrating the use of both `Function` and `BiFunction`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数接受一个参数并产生一个结果。*图14**.8* 展示了一些代码，演示了如何使用 `Function` 和 `BiFunction`：
- en: '![Figure 14.8 – Function and BiFunction in code](img/B19793_14_08.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – 代码中的 Function 和 BiFunction](img/B19793_14_08.jpg)'
- en: Figure 14.8 – Function and BiFunction in code
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 代码中的 Function 和 BiFunction
- en: In this figure, the comments on lines 101-102 show how the `Function` functional
    interface and its functional method appear in the API. `Function` is generically
    typed, with the first type, `T`, representing the input type and the second type,
    `R`, representing the output type. What this means is that, when, on line 103,
    we declare `Function<String, Integer>`, the functional method is `Integer apply(String
    s)`. This is reflected in the lambda expression on line 103, where we accept a
    string, `s`, and return its length. Note that the string’s `length()` method returns
    an `int` type but Java will auto-box this to an `Integer` type for us.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第 101-102 行的注释显示了 `Function` 函数式接口及其函数方法在 API 中的出现。`Function` 是泛型类型的，第一个类型
    `T` 代表输入类型，第二个类型 `R` 代表输出类型。这意味着，当我们在第 103 行声明 `Function<String, Integer>` 时，函数方法是
    `Integer apply(String s)`。这反映在第 103 行的 Lambda 表达式中，我们接受一个字符串 `s` 并返回其长度。请注意，字符串的
    `length()` 方法返回一个 `int` 类型的值，但 Java 会自动装箱为我们返回一个 `Integer` 类型的值。
- en: Line 104 executes the lambda, passing in `"London"`, which returns `6`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第 104 行执行了 Lambda 表达式，传入 `"London"`，返回 `6`。
- en: The `BiFunction` functional interface represents a function that accepts two
    arguments and produces a result. The comments on lines 106-107 shows its signature
    in the API, namely `BiFunction<T, U, R>`, and that of its functional method, which
    is `R apply(T t, U u)`. Therefore, the first two types are inputs and the last
    type is the output type.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`BiFunction` 函数式接口表示一个接受两个参数并产生结果的函数。第 106-107 行的注释显示了其在 API 中的签名，即 `BiFunction<T,
    U, R>`，以及其函数方法的签名，即 `R apply(T t, U u)`。因此，前两种类型是输入类型，最后一种类型是输出类型。'
- en: Lines 108-109 define a `BiFunction` interface where we are accepting in two
    `String`s and returning an `Integer` type. The lambda implementing it takes in
    two `String` parameters, namely `s1` and `s2`, and returns the sum of their lengths.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第 108-109 行定义了一个 `BiFunction` 接口，其中我们接受两个 `String` 类型的参数并返回一个 `Integer` 类型的结果。实现它的
    Lambda 表达式接受两个 `String` 参数，即 `s1` 和 `s2`，并返回它们长度的总和。
- en: Line 111 invokes the lambda while passing in the `"William"` and `"Shakespeare"`
    strings. Their lengths are `7` and `11`, respectively, resulting in `18` being
    returned by the lambda.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第 111 行调用 Lambda 表达式，传入 `"William"` 和 `"Shakespeare"` 字符串。它们的长度分别是 `7` 和 `11`，Lambda
    表达式返回 `18`。
- en: Lines 113-114 define a `BiFunction` interface where we are accepting in two
    `String`s again, but this time, we return a `String`. The lambda (line 114) simply
    concatenates the second `String` onto the first `String` and returns the result.
    Line 116 executes the lambda while passing in the same two strings, `"William"`
    and `"Shakespeare"`. This time, the result is the concatenation of the two, which
    is `"``William Shakespeare"`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第 113-114 行定义了一个 `BiFunction` 接口，其中我们再次接受两个 `String` 类型的参数，但这次返回一个 `String`
    类型的结果。Lambda 表达式（第 114 行）简单地将第二个 `String` 连接到第一个 `String` 上并返回结果。第 116 行执行了 Lambda
    表达式，同时传入相同的两个字符串，`"William"` 和 `"Shakespeare"`。这次，结果是两个字符串的连接，即 `"William Shakespeare"`。
- en: 'The generically typed `Function` functional interface also has variants to
    cater to primitives. *Table 14.6* presents a subset of them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型的 `Function` 函数式接口也有针对原始类型的变体。*表 14.6* 展示了其中的一部分：
- en: '| **Functional Interface** | **Functional Method** | **Example** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **函数式接口** | **函数方法** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `DoubleFunction<R>` | `R` `apply(double value)` | `DoubleFunction<String>
    df = (double dbl) -> "" +` `Math.pow(dbl, 2);` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `DoubleFunction<R>` | `R` `apply(double value)` | `DoubleFunction<String>
    df = (double dbl) -> "" + Math.pow(dbl, 2);` |'
- en: '| `df.apply(2.0); // "``4.0"` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `df.apply(2.0); // "4.0"` |'
- en: '| `DoubleToIntFunction` | `int` `applyAsInt(double value)` | `DoubleToIntFunction
    dtoif = dbl -> (``int)Math.round(dbl);` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `DoubleToIntFunction` | `int` `applyAsInt(double value)` | `DoubleToIntFunction
    dtoif = dbl -> (int)Math.round(dbl);` |'
- en: '| `dtoif.applyAsInt(4.2);// 4` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `dtoif.applyAsInt(4.2);// 4` |'
- en: '| `DoubleToLongFunction` | `long` `applyAsLong(double value)` | `DoubleToLongFunction
    dtolf = (dbl) ->` `Math.round(dbl);` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `DoubleToLongFunction` | `long` `applyAsLong(double value)` | `DoubleToLongFunction
    dtolf = (dbl) -> Math.round(dbl);` |'
- en: '| `dtolf.applyAsLong(4.0);// 4` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `dtolf.applyAsLong(4.0);// 4` |'
- en: Table 14.6 – Double (primitive) specializations of Function in the API
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.6 – API 中 Function 的双精度（原始类型）特殊化
- en: There are many more functional interfaces than those presented in *Table 14.6*.
    Please refer to the API for further details. They can be daunting but remember
    that there is a pattern in the functional interface names and their associated
    functional method names. This helps in understanding what they do.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: API 中比 *表 14.6* 展示的函数式接口要多得多。请参阅 API 获取更多详细信息。它们可能令人望而生畏，但请记住，函数式接口名称及其关联的函数方法名称中存在一种模式。这有助于理解它们的功能。
- en: For example, in *Table 14.6*, the `double` primitive type is catered for with
    `DoubleFunction<R>`, `DoubleToIntFunction`, and `DoubleToLongFunction`. There
    are corresponding functional interfaces for `int` and `long`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 *表 14.6* 中，`double` 原始类型由 `DoubleFunction<R>`、`DoubleToIntFunction` 和 `DoubleToLongFunction`
    提供。对于 `int` 和 `long` 也有相应的函数式接口。
- en: The `int` functional interfaces are `IntFunction<R>`, `IntToDoubleFunction`,
    and `IntToLongFunction`. These `int`-related functional interfaces do the same
    thing as their `double` counterparts (as outlined in *Table 14.6*), except the
    input is `int` and not `double`. The relevant functional method names will depend
    on the result type. For example, the functional method for `IntToDoubleFunction`
    will be `double` `applyAsDouble(int value)`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 函数式接口是 `IntFunction<R>`、`IntToDoubleFunction` 和 `IntToLongFunction`。这些与
    `int` 相关的函数式接口与它们的 `double` 对应者（如 *表 14.6* 中概述的）做相同的事情，除了输入是 `int` 而不是 `double`。相关的函数方法名称将取决于结果类型。例如，`IntToDoubleFunction`
    的函数方法将是 `double applyAsDouble(int value)`。'
- en: The same is true for the `long` primitive. The `long` functional interfaces
    are `LongFunction<R>`, `LongToDoubleFunction`, and `LongToIntFunction`. Their
    functional method names follow the same pattern as `int` and `double`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `long` 原始类型也是同样的情况。`long` 函数式接口是 `LongFunction<R>`、`LongToDoubleFunction`
    和 `LongToIntFunction`。它们的函数方法名称遵循与 `int` 和 `double` 相同的模式。
- en: Let’s finish our discussion on functional interfaces by examining `UnaryOperator`
    and `BinaryOperator`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查 `UnaryOperator` 和 `BinaryOperator` 来完成对函数式接口的讨论。
- en: UnaryOperator and BinaryOperator
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UnaryOperator 和 BinaryOperator
- en: Both of these functional interfaces are specializations of other interfaces.
    Let’s discuss `UnaryOperator` first.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数式接口都是其他接口的特殊化。我们先来讨论 `UnaryOperator`。
- en: UnaryOperator
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UnaryOperator
- en: In the API, the `Function` functional interface is defined as `Function<T, R>`.
    `T` represents the input to the function and `R` represents the output from the
    function. The fact that the letters are different is important. This means that,
    while the types can of course be the same, they can also, and often are, different.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 中，`Function` 函数式接口定义为 `Function<T, R>`。`T` 代表函数的输入，`R` 代表函数的输出。字母不同是很重要的。这意味着，虽然类型当然可以是相同的，但它们也可以，并且通常是不同的。
- en: '`UnaryOperator` is a specialization of `Function` where both the input and
    output types are the same. In the API, `UnaryOperator` is defined as `UnaryOperator<T>
    extends Function<T, T>` and its functional method is `T` `apply(T t)`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnaryOperator` 是 `Function` 的一个特殊化，其中输入和输出类型都是相同的。在 API 中，`UnaryOperator`
    定义为 `UnaryOperator<T> extends Function<T, T>`，其函数式方法是 `T apply(T t)`。'
- en: '*Figure 14**.9* presents an example in code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14.9* 展示了一个代码示例：'
- en: '![Figure 14.9 – UnaryOperator in code](img/B19793_14_09.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9 – 代码中的 UnaryOperator](img/B19793_14_09.jpg)'
- en: Figure 14.9 – UnaryOperator in code
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 – 代码中的 UnaryOperator
- en: In this figure, line 128 defines a `UnaryOperator` typed for `String`. This
    means that both the input and output are now strings. The `name` identifier is
    a `String` and we are just pre-pending `"My name is "` to `name`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第 128 行定义了一个针对 `String` 类型的 `UnaryOperator`。这意味着输入和输出现在都是字符串。`name` 标识符是一个
    `String`，我们只是在 `name` 前面添加 `"My name is "`。
- en: Line 130 executes the lambda by passing in `"Sean"`. The return `String` of
    `"My name is Sean"` is output to the screen.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第 130 行通过传入 `"Sean"` 来执行 lambda 表达式。返回的 `String` 类型的 `"My name is Sean"` 输出到屏幕上。
- en: Now, let’s examine `BinaryOperator`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查 `BinaryOperator`。
- en: BinaryOperator
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BinaryOperator
- en: The `BinaryOperator` functional interface is to `BiFunction` what `UnaryOperator`
    is to `Function`. In other words, `BiFunction` allows us to specify two input
    parameters and an output result, all of which could be different types. `BinaryOperator`,
    which `extends` `BiFunction`, mandates that the two input types and the output
    type must be the same.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryOperator` 函数式接口相当于 `BiFunction` 相当于 `Function`。换句话说，`BiFunction` 允许我们指定两个输入参数和一个输出结果，所有这些都可以是不同类型。`BinaryOperator`，它扩展了
    `BiFunction`，要求两个输入类型和输出类型必须相同。'
- en: In the API, `BinaryOperator` is defined as `BinaryOperator<T> extends BiFunction<T,
    T, T>`, and its functional method is `T apply(T t1,` `T t2)`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 中，`BinaryOperator` 定义为 `BinaryOperator<T> extends BiFunction<T, T, T>`，其函数式方法是
    `T apply(T t1, T t2)`。
- en: '*Figure 14**.10* presents an example in code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14.10* 展示了一个代码示例：'
- en: '![Figure 14.10 – BinaryOperator in code](img/B19793_14_10.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10 – 代码中的 BinaryOperator](img/B19793_14_10.jpg)'
- en: Figure 14.10 – BinaryOperator in code
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – 代码中的 BinaryOperator
- en: In this figure, line 134 defines a `BinaryOperator` typed for `String`. This
    means that both the input parameters and the result are now strings. The `s1`
    and `s2` identifiers are strings and we are just returning the result of concatenating
    `s2` onto `s1`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第134行定义了一个针对`String`类型的`BinaryOperator`。这意味着输入参数和结果现在都是字符串。`s1`和`s2`标识符是字符串，我们只是将`s2`连接到`s1`上。
- en: Line 136 executes the lambda by passing in `"William"` and `"Shakespeare"`.
    The return `String` of `"William Shakespeare"` is output to the screen.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第136行通过传递`"William"`和`"Shakespeare"`来执行lambda表达式。返回的`String` `"William Shakespeare"`被输出到屏幕上。
- en: Mastering method references
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握方法引用
- en: Now, let’s move on to another important topic concerning lambda expressions,
    and that is method references. As concise as lambdas are, in certain situations,
    they can be even more concise! This is where method references apply. If all your
    lambda does is call one method, then this is an opportunity for a method reference.
    In addition, if a lambda parameter is simply passed to a method, then the redundancy
    of specifying the variable twice can also be removed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论另一个关于lambda表达式的重要主题，那就是方法引用。尽管lambda表达式已经很简洁，但在某些情况下，它们甚至可以更简洁！这就是方法引用适用的地方。如果你的lambda表达式只是调用一个方法，那么这就是使用方法引用的机会。此外，如果一个lambda参数只是传递给一个方法，那么指定变量的冗余也可以被移除。
- en: 'Let’s look at an example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code, we declare a list of strings by invoking the `Arrays.asList()`
    method. The first `forEach(Consumer)` shows how to output the list using a lambda
    expression. Recall that the functional method of `Consumer` is `void` `accept(T
    t)`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们通过调用`Arrays.asList()`方法声明了一个字符串列表。第一个`forEach(Consumer)`展示了如何使用lambda表达式输出列表。回想一下，`Consumer`的功能方法是`void
    accept(T t)`。
- en: The second `forEach(Consumer)` shows the method reference syntax. Note the double-colon
    operator, `::` (or method reference operator), and the fact that there are no
    round brackets, `()`, after the method name, as in `println`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`forEach(Consumer)`展示了方法引用的语法。注意双冒号操作符`::`（或方法引用操作符），以及方法名后面没有圆括号`()`，就像`println`一样。
- en: Keep in mind at all times that the code has to be generated at some point. If
    we have all the code specified, then the compiler has nothing to do. However,
    if we have availed of lambdas and/or method references, the compiler must step
    in and generate the omitted code. The compiler can only do so when it understands
    the *context*. This is crucial to making sense of method references given that
    there is so much code omitted. Moreover, the functional interface, with its functional
    method, is critical for providing context.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 时刻记住代码最终必须生成。如果我们已经指定了所有代码，那么编译器就没有事情可做。然而，如果我们使用了lambda表达式和/或方法引用，编译器就必须介入并生成省略的代码。编译器只有在理解了*上下文*的情况下才能这样做。这对于理解省略了大量代码的方法引用至关重要。此外，具有功能方法的函数式接口对于提供上下文至关重要。
- en: 'There are four different types of method references:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用有四种不同类型：
- en: Bound
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定
- en: Unbound
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未绑定
- en: Static
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态
- en: Constructor
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: These are best explained with examples in code. Regarding the examples, to make
    them easier to understand, we have coded both the lambda and method reference
    versions for each example. The lambda variables use the `"L"` suffix and the method
    reference variables use the `"MR"` suffix. In addition, in the comments, just
    before each example, are the signatures of the functional interfaces and their
    associated functional methods.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容最好通过代码示例来解释。关于示例，为了使它们更容易理解，我们为每个示例都编写了lambda表达式和方法引用版本。lambda变量使用`"L"`后缀，方法引用变量使用`"MR"`后缀。此外，在每个示例之前的注释中，都有函数式接口及其相关功能方法的签名。
- en: 'Now, let’s start with the first method reference type: bound method references.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从第一种方法引用类型：绑定方法引用开始。
- en: Bound method references
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定方法引用
- en: 'Bound references get their name from the fact that the reference is bound to
    an instance of a particular object. A bound method reference is sometimes referred
    to as a “reference to an instance of a particular object.” Let’s use an example
    to explain this further. *Figure 14**.11* presents a bound method reference example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定引用之所以得名，是因为引用绑定到特定对象的实例上。绑定方法引用有时被称为“特定对象的引用”。让我们用一个例子来进一步解释这一点。*图14.11*展示了绑定方法引用的例子：
- en: '![Figure 14.11 – Bound method reference example](img/B19793_14_11.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图14.11 – 绑定方法引用示例](img/B19793_14_11.jpg)'
- en: Figure 14.11 – Bound method reference example
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 – 绑定方法引用示例
- en: In this figure, line 21 declares a `String` variable called `name`, initialized
    to `"Mr. Joe Bloggs"`. Lines 22-23 outline the `Supplier` functional interface
    and the signature of its functional method, `T get()`, in the API. Line 24 declares
    a `Supplier` lambda that converts `name` into lowercase. This is the same `name`
    variable declared on line 21\. Hence, this lambda is *bound* to the `name` variable
    at compile time. As the lambda is simply calling one method, this is an opportunity
    to introduce a method reference.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第21行声明了一个名为`name`的`String`变量，初始化为`"Mr. Joe Bloggs"`。第22-23行概述了`Supplier`功能接口及其功能方法的签名`T
    get()`在API中。第24行声明了一个将`name`转换为小写的`Supplier` lambda表达式。这个lambda表达式与第21行声明的`name`变量相同。因此，这个lambda在编译时绑定到`name`变量。由于lambda只是调用一个方法，这是一个引入方法引用的机会。
- en: Given the lambda on line 24, line 25 outlines the equivalent method reference.
    Note the use of the `name` variable; the method reference operator `::` and the
    omission of the round brackets `()` after the method name. Also, note that `name`
    is a `String` and that the `toLowerCase()` method is a method in the `String`
    class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 给定第24行的lambda表达式，第25行概述了等效的方法引用。注意`name`变量的使用；方法引用操作符`::`以及方法名之后省略的圆括号`()`。此外，注意`name`是一个`String`，而`toLowerCase()`方法是`String`类中的一个方法。
- en: Lines 28 and 29 execute the lambda and method reference versions, respectively,
    returning `"mr. joe bloggs"` on both occasions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行和第29行分别执行了lambda表达式和方法引用版本，两种情况下都返回了`"mr. joe bloggs"`。
- en: The first example in *Figure 14**.11* is using the `Supplier` functional interface,
    which did not require an input parameter. What if we wanted to pass in a value?
    A `Supplier` functional interface will not work as its functional method is `T
    get()`, which does not accept parameters. However, a `Predicate` will work as
    its functional method, `boolean test(T t)`, does accept an input parameter. The
    second example in *Figure 14**.11* shows this in action.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14**.11*中的第一个示例使用了`Supplier`功能接口，它不需要输入参数。如果我们想传递一个值呢？`Supplier`功能接口将不起作用，因为它的功能方法是`T
    get()`，不接受参数。然而，`Predicate`将起作用，因为它的功能方法`boolean test(T t)`接受输入参数。*图14**.11*中的第二个示例展示了这一点。'
- en: Line 37 is the lambda version. As `Predicate` is typed for `String`, `title`
    is a `String`. Again, we bind to `name` and execute the `String` method, `startsWith()`,
    passing in the input parameter. We can see the redundancy in the lambda given
    that `title` is mentioned twice. Couple this with the fact that the lambda is
    simply calling one method, we have another opportunity to introduce a method reference.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第37行是lambda版本。由于`Predicate`被指定为`String`类型，`title`是一个`String`。再次，我们将`name`绑定并执行`String`方法`startsWith()`，传递输入参数。我们可以看到lambda中的冗余，因为`title`被提到了两次。结合lambda只是调用一个方法的事实，我们又有机会引入方法引用。
- en: Line 38 is the method reference version of the lambda on line 37\. This method
    reference requires a bit more explanation however because, in the `String` class,
    the `startsWith()` method is overloaded. The overloaded versions are `boolean
    startsWith(String, int)` and `boolean startsWith(String)`. How does the compiler
    decide which version of `startsWith()` to use? This is where context is important!
    We are defining a `Predicate` and the functional method for `Predicate` is `boolean
    test(T t)` - given that this method accepts just one parameter, the compiler selects
    the `startsWith()` method with one parameter, namely `boolean startsWith(String)`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第38行是第37行lambda表达式的等效方法引用版本。然而，这个方法引用需要更多的解释，因为在`String`类中，`startsWith()`方法是重载的。重载版本有`boolean
    startsWith(String, int)`和`boolean startsWith(String)`。编译器是如何决定使用哪个版本的`startsWith()`呢？这就是上下文重要性的地方！我们正在定义一个`Predicate`，`Predicate`的功能方法是`boolean
    test(T t)` - 由于这个方法只接受一个参数，编译器选择了一个参数的方法`startsWith(String)`。
- en: Line 40 executes the lambda version, passing in `"Mr."` This results in the
    lambda executing `"Mr. Joe Bloggs".startsWith("Mr.")`, which is true.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第40行执行了lambda版本，传递了`"Mr."`。这导致lambda执行`"Mr. Joe Bloggs".startsWith("Mr.")`，结果是true。
- en: Line 41 executes the method reference version, passing in `"Ms."`. As the compiler
    translates the method reference into a lambda in the background, this results
    in the lambda executing `"Mr. Joe Bloggs".startsWith("Ms.")`, which is false.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第41行执行了方法引用版本，传递了`"Ms."`。由于编译器将方法引用在后台转换为lambda表达式，这导致lambda执行`"Mr. Joe Bloggs".startsWith("Ms.")`，结果是false。
- en: Now, we will examine unbound method references.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查未绑定方法引用。
- en: Unbound method references
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未绑定方法引用
- en: 'Unbound method references do not bind to a variable. Instead, the instance
    to use is provided at runtime. An unbound method reference is sometimes referred
    to as a “reference to an instance of an arbitrary object of a particular type.”
    *Figure 14**.12* present an example in code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 未绑定方法引用不会绑定到变量。相反，在运行时提供要使用的实例。未绑定方法引用有时被称为“特定类型的任意对象的实例的引用”。*图14.12*展示了代码中的示例：
- en: '![Figure 14.12 – Unbound method reference example](img/B19793_14_12.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图14.12 – 未绑定方法引用示例](img/B19793_14_12.jpg)'
- en: Figure 14.12 – Unbound method reference example
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12 – 未绑定方法引用示例
- en: In this figure, we define a lambda on line 48\. This lambda is of the `Function<String,
    String>` type, meaning that the functional method is `String apply(String)`. Thus,
    `s` is a `String` and we can invoke the `String` method, `toUpperCase()`. Note
    that `s` is not a variable from the method’s scope. In *Figure 4**.11*, we were
    bound to the `name` variable declared in the method. Now, however, `s` has the
    scope of the lambda expression only. This means that the method reference is *unbound*.
    The lambda parameter, `s`, will be bound to at runtime (when the `apply()` method
    is called), as on line 51.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们在第48行定义了一个lambda表达式。这个lambda表达式是`Function<String, String>`类型，这意味着功能方法是`String
    apply(String)`。因此，`s`是一个`String`，我们可以调用`String`方法`toUpperCase()`。请注意，`s`不是方法作用域中的变量。在*图4.11*中，我们绑定到了方法中声明的`name`变量。然而，现在`s`只有lambda表达式的范围。这意味着方法引用是*未绑定的*。lambda参数`s`将在运行时（当`apply()`方法被调用时）绑定，就像第51行所示。
- en: As the lambda has just one method call and there is redundancy with `s` on both
    sides of the `->` token, we can use a method reference. Line 49 represents the
    method reference version of the lambda on line 48\. Note the use of the method
    reference operator `::` and the absence of `()` after the method name, `toLowerCase`.
    As `toLowerCase` is a `String` method, `String` precedes the `::` operator in
    the method reference. The method reference on line 49 is semantically equivalent
    to the lambda on line 48.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于lambda表达式只有一个方法调用，并且在`->`符号的两侧都有`s`的冗余，我们可以使用方法引用。第49行表示第48行的lambda表达式的引用版本。注意方法引用操作符`::`的使用以及方法名`toLowerCase`后面的括号`()`的缺失。由于`toLowerCase`是`String`方法，所以在方法引用中`String`位于`::`操作符之前。第49行的方法引用在语义上等同于第48行的lambda表达式。
- en: Line 57 declares a `BiFunction` lambda. Recall that `BiFunction` takes in two
    inputs and returns a result. In this case, all are `String` types. The parameters
    that are passed in are concatenated and returned. Again, we have only one method
    call in the lambda and redundancy of variables, so we can code a method reference.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第57行声明了一个`BiFunction` lambda。回想一下，`BiFunction`接受两个输入并返回一个结果。在这种情况下，所有都是`String`类型。传入的参数将被连接并返回。再次强调，我们在lambda表达式中只有一个方法调用和变量的冗余，所以我们可以编写一个方法引用。
- en: Line 58 represents the method reference version of the lambda on line 57\. Again,
    context is going to be key in figuring out the method reference. `BiFunction<String,
    String, String>` and `String::concat` inform the compiler that this is an unbound
    method reference that will take in two `String` arguments and concatenate them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第58行表示第57行的lambda表达式的引用版本。再次强调，上下文将是确定方法引用的关键。`BiFunction<String, String, String>`和`String::concat`通知编译器这是一个未绑定方法引用，它将接受两个`String`参数并将它们连接起来。
- en: 'There is one other bit of information implied here – the first argument provided
    in the `apply()` method call is the instance to be used for the `concat()` method;
    the second argument is to be passed into the `concat()` method as an argument.
    What this means is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里隐含的另一条信息是 – 在`apply()`方法调用中提供的第一个参数是要用于`concat()`方法的实例；第二个参数是要传递给`concat()`方法作为参数。这意味着如下：
- en: '[PRE10]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This translates into the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以转换为以下内容：
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This can be seen on lines 62 and 63\. The execution of the method reference
    on line 63 translates into the code in comments on line 62\. Both the lambda and
    method reference invocations (lines 59 and 63, respectively) result in `"Sean
    Kennedy"` being returned.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在第62行和第63行中看到。第63行的方法引用执行转换为第62行注释中的代码。lambda和方法的引用调用（分别在第59行和第63行）都返回`"Sean
    Kennedy"`。
- en: Now, let’s explore static method references.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨静态方法引用。
- en: Static method references
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法引用
- en: 'A `static` method reference is also considered unbound as we do not bind to
    a variable from the outer scope. The method being invoked is `static`, hence the
    name. Let’s examine a `static` method reference in code. *Figure 14**.13* shows
    such an example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`static`方法引用也被认为是未绑定的，因为我们没有绑定到外部作用域的变量。被调用的方法是`static`的，因此得名。让我们通过代码来检查一个`static`方法引用。*图14.13*展示了这样的一个示例：
- en: '![Figure 14.13 – Static method reference example](img/B19793_14_13.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图14.13 – 静态方法引用示例](img/B19793_14_13.jpg)'
- en: Figure 14.13 – Static method reference example
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 – 静态方法引用示例
- en: In this figure, we define a `Consumer` lambda (line 110) that takes in a `List<Integer>`
    list. As we know, `Consumer`s take in one argument and do not return anything.
    The side effect is to call the `static` `Collections` method, `sort`, passing
    in the list to be sorted. As our lambda has just one method call and we have redundancy
    (`list` on both sides of the `->` token), we can re-write the lambda even more
    concisely as a method reference.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们定义了一个`Consumer` lambda（第110行），它接受一个`List<Integer>`列表。正如我们所知，`Consumer`接受一个参数而不返回任何内容。副作用是调用`static`的`Collections`方法`sort`，传递要排序的列表。由于我们的lambda只有一个方法调用，并且存在冗余（`->`标记两边的`list`），我们可以将lambda重写得更简洁，作为一个方法引用。
- en: Line 111 is the method reference version of the lambda that was coded on line
    110\. The `Collections.sort()` method is overloaded – one version is `sort(List)`
    and the other is `sort(List, Comparator)`. Context decides which one the compiler
    selects. As the `Consumer` lambda’s functional method is `void accept(T t)`, which
    takes just one parameter, the `sort()` with one parameter, namely `sort(List)`,
    is used.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第111行是第110行编写的lambda表达式的引用版本。`Collections.sort()`方法被重载了——一个版本是`sort(List)`，另一个版本是`sort(List,
    Comparator)`。上下文决定了编译器选择哪一个。由于`Consumer` lambda的函数式方法是`void accept(T t)`，它只接受一个参数，因此使用了一个参数的`sort()`，即`sort(List)`。
- en: Line 113 generates a `List<Integer>` using the `Arrays.asList()` method. Lines
    114 and 115 execute and output the lambda version.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第113行使用`Arrays.asList()`方法生成一个`List<Integer>`。第114和115行执行并输出lambda版本。
- en: Line 117 re-generates a `List<Integer>`, again using the `Arrays.asList()` method.
    Lines 118 and 119 execute and output the method reference version.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第117行再次使用`Arrays.asList()`方法重新生成一个`List<Integer>`。第118和119行执行并输出方法引用版本。
- en: Our last method reference type is constructor method references. Let’s discuss
    them now.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的方法引用类型是构造方法引用。现在让我们来讨论它们。
- en: Constructor method references
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造方法引用
- en: 'Constructor method references are a special type of method reference in that,
    rather than calling a (regular) method, the `new` keyword is used and an object
    is instantiated. Suppliers are a natural fit for constructor method references.
    *Figure 14**.14* presents an example in code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 构造方法引用是一种特殊的方法引用类型，因为它不是调用一个（常规）方法，而是使用`new`关键字并实例化一个对象。供应商是构造方法引用的天然选择。*图14.14*展示了代码中的示例：
- en: '![Figure 14.14 – Constructor method reference example](img/B19793_14_14.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图14.14 – 构造方法引用示例](img/B19793_14_14.jpg)'
- en: Figure 14.14 – Constructor method reference example
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14 – 构造方法引用示例
- en: In this figure, line 75 defines a `Supplier<StringBuilder>` lambda. The `Supplier`
    lambda’s functional method is `T get()`, so we do not pass anything in. As we
    typed `sbL` for `StringBuilder`, the lambda code is `new StringBuilder()`. As
    we have only one method invocation in the lambda, a method reference version can
    be coded.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第75行定义了一个`Supplier<StringBuilder>` lambda。`Supplier` lambda的函数式方法是`T get()`，所以我们什么也没有传递。由于我们为`StringBuilder`输入了`sbL`，lambda代码是`new
    StringBuilder()`。由于lambda中只有一个方法调用，我们可以编写一个方法引用版本。
- en: The method reference on line 76 is the constructor method reference equivalent
    of the lambda defined on line 75\. Note the use of the `new` keyword after the
    `::` operator in the syntax.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 第76行的方法引用是第75行定义的lambda表达式的构造方法引用等价物。注意在语法中`::`操作符后面的`new`关键字的使用。
- en: Lines 77 and 78 invoke the lambda and method references, respectively. In addition,
    the `StringBuilder` objects that were created are populated and output.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第77和78行分别调用了lambda和方法引用。此外，创建的`StringBuilder`对象被填充并输出。
- en: As stated already, `Supplier` is a perfect fit for constructor method references.
    But what if you wanted to pass an argument in? Suppliers do not accept parameters
    (`T get()`). We need a functional interface that will accept a parameter and return
    a result. `Function` will do nicely for this use case.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Supplier`是构造方法引用的完美匹配。但如果你想要传递一个参数怎么办？`Supplier`不接受参数（`T get()`）。我们需要一个接受参数并返回结果的函数式接口。`Function`在这个用例中会很合适。
- en: The second example in *Figure 14**.14* presents a `Function`-based constructor
    method reference. The `ArrayList` constructor is overloaded – one of the versions
    accepts an `int` type, which is used to specify the initial capacity.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.14*中的第二个例子展示了基于`Function`的构造方法引用。`ArrayList`构造函数是重载的——其中一个版本接受`int`类型，用于指定初始容量。'
- en: Line 84 defines a `Function`-based lambda, which accepts an `Integer` type and
    returns a `List<String>` list. The lambda takes an `Integer` type, `x`, and constructs
    an `ArrayList` with an initial capacity of `x`. The value of `x` will be obtained
    from the lambda invocation (for example, 100 on line 86).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第84行定义了一个基于`Function`的lambda，它接受`Integer`类型并返回一个`List<String>`列表。lambda接受一个`Integer`类型的`x`，并构造一个初始容量为`x`的`ArrayList`。`x`的值将从lambda调用中获取（例如，第86行的100）。
- en: As we have only one method call in the lambda and as `x` is replicated on both
    sides of the `->` token (redundancy), we can write an equivalent method reference.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于lambda中只有一个方法调用，并且`x`在`->`符号的两侧重复（冗余），我们可以编写一个等效的方法引用。
- en: Line 85 is the method reference equivalent of the lambda that was coded on line
    84\. `ArrayList` is specified to indicate which implementation of `List` we want
    to return. The `::new` syntax is unique to constructor method references. Line
    89 shows how the method reference is executed – invoke the `apply()` method while
    passing in 200 in this example.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第85行是第84行编写的lambda表达式的等效方法引用。`ArrayList`被指定以表明我们想要返回哪种`List`的实现。`::new`语法是构造方法引用特有的。第89行显示了方法引用的执行方式——在这个例子中，传递200调用`apply()`方法。
- en: That concludes our discussion on the four different types of method references.
    However, before we leave method references, we would like to discuss an example
    outlining just how important context is when trying to understand method references.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对四种不同类型的方法引用的讨论。然而，在我们离开方法引用之前，我们想讨论一个例子，说明在尝试理解方法引用时上下文是多么重要。
- en: Method references and context
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法引用和上下文
- en: 'This example will present three lambdas with their corresponding method references.
    *Figure 14**.15* shows the code example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将展示三个lambda及其对应的方法引用。*图14.15*显示了代码示例：
- en: '![Figure 14.15 – Method references and context](img/B19793_14_15.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图14.15 – 方法引用和上下文](img/B19793_14_15.jpg)'
- en: Figure 14.15 – Method references and context
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15 – 方法引用和上下文
- en: In this figure, lines 7-11 define a class called `Person`. Line 8 defines a
    `static` `howMany()` method that returns the number of objects in the `Person`
    array. Recall that `varargs` is represented by `…` and within the method, it is
    treated as an array (hence the `length` property). Given that the `people` parameter
    is a `varargs` parameter, we can invoke `howMany()` with 0 or more arguments.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第7-11行定义了一个名为`Person`的类。第8行定义了一个`static`的`howMany()`方法，它返回`Person`数组中的对象数量。回想一下，`varargs`用`…`表示，在方法内部，它被当作数组处理（因此有`length`属性）。由于`people`参数是一个`varargs`参数，我们可以用0个或多个参数调用`howMany()`。
- en: The first scenario is calling `howMany()` with no `Person` object at all and
    getting back the count of objects passed, which will be 0\. `Supplier` fits nicely
    as we will not be passing anything into the lambda, but will be getting back an
    `Integer` result. Line 15 is the lambda for this scenario. We accept in nothing
    and return an `Integer` count, which is the count of the number of `Person` objects
    passed to `howMany()`. This is, of course, `0`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景是没有任何`Person`对象调用`howMany()`并返回传递的对象计数，这将是一个0。`Supplier`非常适合，因为我们不会向lambda传递任何东西，但会得到一个`Integer`结果。第15行是这个场景的lambda。我们不传递任何东西，返回一个`Integer`计数，这是传递给`howMany()`的`Person`对象的数量。当然，这是`0`。
- en: Line 16 is the method reference equivalent for the lambda on line 15\. We will
    return to discuss this shortly.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第16行是第15行lambda表达式的等效方法引用。我们很快就会回到这个话题进行讨论。
- en: The second scenario is calling `howMany()` with one `Person` object and getting
    back the count of objects passed, which will be `1`. `Function` fits nicely as
    we will be passing in one `Person` object to the lambda and receiving the `Integer`
    count. Line 21 is the lambda for this scenario. We accept one `Person` and return
    an `Integer`, representing the number of `Person` objects passed to `howMany()`.
    This is `1`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是使用一个 `Person` 对象调用 `howMany()` 并返回传递的对象数量，这将会是 `1`。`Function` 适配得很好，因为我们将会向
    lambda 函数传递一个 `Person` 对象并接收 `Integer` 类型的计数。第 21 行是这个场景的 lambda 表达式。我们接受一个 `Person`
    对象并返回一个 `Integer`，代表传递给 `howMany()` 的 `Person` 对象数量。这是 `1`。
- en: Line 22 is the method reference equivalent for the lambda on line 21\. Again,
    we will return to discuss this shortly.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第 22 行是第 21 行 lambda 表达式的等价方法引用。我们很快会回到这个话题进行讨论。
- en: The third scenario is calling `howMany()` with two `Person` objects and getting
    back the count of objects passed, which will be `2`. `BiFunction` fits nicely
    as we will be passing in two `Person` objects to the lambda and receiving the
    `Integer` count. Line 27 is the lambda for this scenario. We accept two `Person`
    objects and return an `Integer` representing the number of `Person` objects passed
    to `howMany()`. This is `2`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况是使用两个 `Person` 对象调用 `howMany()` 并返回传递的对象数量，这将会是 `2`。`BiFunction` 适配得很好，因为我们将会向
    lambda 函数传递两个 `Person` 对象并接收 `Integer` 类型的计数。第 27 行是这个场景的 lambda 表达式。我们接受两个 `Person`
    对象并返回一个 `Integer`，代表传递给 `howMany()` 的 `Person` 对象数量。这是 `2`。
- en: Line 28 is the method reference equivalent for the lambda on line 27.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第 28 行是第 27 行 lambda 表达式的等价方法引用。
- en: 'Now, let’s discuss the method references (lines 16, 22, and 28). Notice how
    they are all the same! Again, this is where context is key. The compiler can generate
    the relevant lambdas based on the functional interfaces and the generic types
    specified. Here’s an example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论方法引用（第 16、22 和 28 行）。注意它们都是相同的！再次强调，这是上下文至关重要的地方。编译器可以根据指定的功能接口和泛型类型生成相关的
    lambda 表达式。以下是一个示例：
- en: '[PRE12]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Firstly, as `howMany()` is a `static` method in `Person`, the compiler knows
    that the lambda will be `Person.howMany()`. But how many objects should be passed?
    As it is a `Supplier` interface, whose functional method is `T get()`, the compiler
    knows there will be no parameter input, so it knows to pass nothing to `howMany()`.
    Concerning what to return, `Supplier` is typed for `Integer`, which matches the
    return type for `howMany()`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于 `howMany()` 是 `Person` 类中的 `static` 方法，编译器知道 lambda 将会是 `Person.howMany()`。但是应该传递多少个对象呢？由于它是一个
    `Supplier` 接口，其功能方法是 `T get()`，编译器知道不会有参数输入，因此它知道不需要向 `howMany()` 传递任何内容。至于返回值，`Supplier`
    被指定为 `Integer` 类型，这与 `howMany()` 方法的返回类型相匹配。
- en: 'What if we want to pass one object to `howMany()`? Let’s examine the second
    method reference:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向 `howMany()` 函数传递一个对象，让我们检查第二个方法引用：
- en: '[PRE13]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The one difference here is that we are declaring a `Function` as opposed to
    the previous `Supplier`. `Function`s take in one parameter and return a result.
    We know `Integer` must be the return type, as that is the return type of `howMany()`.
    So, what the compiler does here is take the input and pass it to the `howMany()`
    method. The equivalent lambda (line 21) shows what is happening in the background.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个区别是我们声明了一个 `Function` 而不是之前的 `Supplier`。`Function` 接受一个参数并返回一个结果。我们知道返回类型必须是
    `Integer`，因为那是 `howMany()` 方法的返回类型。所以，编译器在这里所做的就是接收输入并将其传递给 `howMany()` 方法。等价的
    lambda（第 21 行）显示了背后的操作。
- en: 'Lastly, what if we want to pass in two objects to `howMany()`? The last method
    reference demonstrates how to do this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想向 `howMany()` 函数传递两个对象，会怎样呢？最后一个方法引用示例展示了如何做到这一点：
- en: '[PRE14]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The compiler sees `BiFunction` and realizes that `BiFunction` requires two inputs,
    so it will pass the two inputs to `howMany()`. And of course, this particular
    `BiFunction` return type of `Integer` matches the return type of the method `howMany()`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器看到 `BiFunction` 并意识到 `BiFunction` 需要两个输入，因此它将两个输入传递给 `howMany()`。当然，这个特定的
    `BiFunction` 返回类型 `Integer` 与 `howMany()` 方法的返回类型相匹配。
- en: So, we have three equivalent method references that map to three different lambdas
    because of the three different contexts. Method references can be tricky. Check
    the context and if possible, map the method reference to its equivalent lambda
    expression. Once in lambda form, it is easier to interpret.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于有三个不同的上下文，我们有了三个等价的方法引用映射到三个不同的 lambda 表达式。方法引用可能会有些棘手。检查上下文，并在可能的情况下，将方法引用映射到其等价的
    lambda 表达式。一旦转换为 lambda 形式，就更容易理解了。
- en: That completes our discussion on method references and concludes [*Chapter 14*](B19793_14.xhtml#_idTextAnchor355).
    Now, let’s put that knowledge into practice to reinforce the concepts we’ve learned.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对方法引用的讨论，并结束了[第 14 章](B19793_14.xhtml#_idTextAnchor355)。现在，让我们将所学知识付诸实践，以巩固我们学到的概念。
- en: Exercises
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Dinosaur care tasks are often very similar, but not identical. To make our code
    cleaner, we can use lambda expressions. Create a custom functional interface called
    `DinosaurHandler` with a method called `handle(Dinosaur dinosaur)`. Implement
    it in a lambda expression that sets a dinosaur to be asleep or awake (first, add
    a property to your `Dinosaur` class if needed).
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恐龙养护任务通常非常相似，但并不完全相同。为了使我们的代码更简洁，我们可以使用 Lambda 表达式。创建一个名为 `DinosaurHandler`
    的自定义函数式接口，其中有一个名为 `handle(Dinosaur dinosaur)` 的方法。在 Lambda 表达式中实现它，该表达式将恐龙设置为睡眠或清醒（首先，如果需要，请向您的
    `Dinosaur` 类添加一个属性）。
- en: 'Lambda expressions are extremely useful with the `java.util.function` interfaces.
    Let’s use them to manage dinosaurs:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 表达式与 `java.util.function` 接口结合使用非常有效。让我们使用它们来管理恐龙：
- en: Write a `Predicate<Dinosaur>` lambda that checks if a dinosaur is a carnivore
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个检查恐龙是否为肉食性的 `Predicate<Dinosaur>` Lambda 表达式
- en: Write a `Supplier<Dinosaur>` lambda that returns a new dinosaur
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个返回新恐龙的 `Supplier<Dinosaur>` Lambda 表达式
- en: Write a `Consumer<Dinosaur>` lambda that prints a dinosaur’s name
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个打印恐龙名称的 `Consumer<Dinosaur>` Lambda 表达式
- en: Write a `Function<Dinosaur, String>` lambda that returns a dinosaur’s diet
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个返回恐龙饮食的 `Function<Dinosaur, String>` Lambda 表达式
- en: Lambda expressions have specific rules about variable usage. We’re going to
    create an example of a lambda expression that modifies an “effectively final”
    variable. Add a variable that tracks the number of dinosaurs and create a lambda
    expression that increases this count.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 表达式在变量使用方面有特定的规则。我们将创建一个 Lambda 表达式的示例，该表达式修改一个“有效最终”变量。添加一个跟踪恐龙数量的变量，并创建一个
    Lambda 表达式来增加这个计数。
- en: 'Method references can make our code more readable. Write examples of using
    method references in the context of your park:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法引用可以使我们的代码更易读。请编写在您的公园环境中使用方法引用的示例：
- en: '`System.out::println` to print dinosaur names.'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `System.out::println` 打印恐龙名称。
- en: '`Dinosaur::getName` (assume the `Dinosaur` class has a `getName()` method)
    to get the name of each dinosaur.'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Dinosaur::getName`（假设 `Dinosaur` 类有一个 `getName()` 方法）来获取每个恐龙的名称。
- en: '`Collections::sort` to sort a list of dinosaur names.'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Collections::sort` 对恐龙名称列表进行排序。
- en: '`Dinosaur::new` to create a new dinosaur (assume the `Dinosaur` class has an
    appropriate constructor)'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Dinosaur::new` 创建一个新的恐龙（假设 `Dinosaur` 类有一个合适的构造函数）
- en: Project – agile dinosaur care system
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 - 灵活的恐龙养护系统
- en: Our park is growing, and so are the tasks that need to be accomplished. Lambda
    expressions can simplify our code and improve the efficiency of operations. Let’s
    integrate them into our system!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的公园正在发展，需要完成的工作也在增加。Lambda 表达式可以简化我们的代码并提高操作效率。让我们将它们集成到我们的系统中！
- en: Incorporate lambda expressions into your “dinosaur care system” for sorting,
    filtering, and performing actions on collections of dinosaurs. Furthermore, design
    a notification system using method references to alert park staff about various
    events, enhancing communication and responsiveness within our park.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Lambda 表达式纳入您的“恐龙养护系统”，用于排序、过滤和对恐龙集合执行操作。此外，设计一个使用方法引用的通知系统，以提醒公园工作人员各种事件，增强我们公园内的沟通和响应能力。
- en: 'Here are the steps. We assume certain methods exist. You’ll have to create
    those methods according to your `Dinosaur` class’s design:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是步骤。我们假设某些方法存在。您必须根据您的 `Dinosaur` 类的设计创建这些方法：
- en: '`Dinosaur` class defined with properties such as `name`, `species`, `healthStatus`,
    and so on. You’ll also want to have a `DinosaurCareSystem` class where the main
    functionalities of handling dinosaurs are implemented.'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义具有 `name`、`species`、`healthStatus` 等属性的 `Dinosaur` 类。您还希望有一个 `DinosaurCareSystem`
    类，其中实现了处理恐龙的主要功能。
- en: '`Dinosaur` objects and you want to sort them by their name. Use the `sort`
    method of the `List` interface with a lambda expression. Here’s an example: `dinosaurs.sort((d1,
    d2) >` `d1.getName().compareTo(d2.getName()))`.'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想要按名称对 `Dinosaur` 对象进行排序。使用 `List` 接口的 `sort` 方法和一个 Lambda 表达式。以下是一个示例：`dinosaurs.sort((d1,
    d2) -> d1.getName().compareTo(d2.getName()))`。
- en: '`List<Dinosaur> illDinosaurs = dinosaurs.stream().filter(d >` `d.isIll()).collect(Collectors.toList())`.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List<Dinosaur> illDinosaurs = dinosaurs.stream().filter(d -> d.isIll()).collect(Collectors.toList())`。'
- en: '`DinosaurCareSystem` class, create a method called `sendNotification(String
    message)`. Then in another method where you are checking dinosaur health status,
    for example, use a method reference to call `sendNotification` each time a dinosaur
    is found to be ill. The code may look something like this: `dinosaurs.stream().filter(Dinosaur::isIll).forEach(d
    > sendNotification(d.getName() + "` `is ill."))`.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DinosaurCareSystem`类中，创建一个名为`sendNotification(String message)`的方法。然后在另一个方法中，例如检查恐龙健康状况时，每次发现恐龙生病，就使用方法引用调用`sendNotification`。代码可能看起来像这样：`dinosaurs.stream().filter(Dinosaur::isIll).forEach(d
    -> sendNotification(d.getName() + " is ill."))`.
- en: '`healthboosting` program. With lambdas, you can do this directly on the list:
    `dinosaurs.forEach(d >` `d.increaseHealth(10))`.'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`healthboosting`程序。使用lambda表达式，你可以在列表上直接这样做：`dinosaurs.forEach(d -> d.increaseHealth(10))`.'
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned that lambda expressions make your code more concise.
    We saw that a functional interface is an interface with just one `abstract` method.
    Lambda expressions are classes that implement functional interfaces with everything
    but the bare minimum remaining.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到lambda表达式可以使你的代码更加简洁。我们看到了功能接口是一个只有一个`abstract`方法的面接口。lambda表达式是实现功能接口的类，除了最基本的部分之外，其他都实现了。
- en: The terms `final` and “effectively final” refer to local variables used inside
    lambda expressions. Any non-`final` local variable used by a lambda must not change
    its value, either in the method or the lambda itself. The compiler enforces this,
    thus making the local variable “effectively final.” This is to ensure that the
    method’s view of the local variables value is consistent with the lambda’s view
    (of the local variable’s value). This does not apply to instance or `static` variables
    or local variables *not* used inside lambdas.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 术语`final`和“effectively final”指的是在lambda表达式中使用的局部变量。任何被lambda使用的非`final`局部变量都不应改变其值，无论是在方法中还是在lambda表达式中本身。编译器强制执行此规则，从而使局部变量“实际上”是final的。这是为了确保方法对局部变量值的看法与lambda对局部变量值的看法一致。这不适用于实例或`static`变量，或者不在lambda内部使用的局部变量。
- en: We took a deep dive into functional interfaces from the API. We examined predicates
    (which test a condition), such as `Predicate<T>` and `BiPredicate<T, U>`, plus
    their primitive consuming counterparts, `DoublePredicate`, `IntPredicate`, and
    `LongPredicate`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从API深入研究了功能接口。我们研究了断言（测试条件），例如`Predicate<T>`和`BiPredicate<T, U>`，以及它们的原始消耗对应物，`DoublePredicate`、`IntPredicate`和`LongPredicate`。
- en: We also examined `Supplier<T>` (which gives you something) and its primitive
    consuming specializations, which are `BooleanSupplier`, `DoubleSupplier`, `IntSupplier`,
    and `LongSupplier`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了`Supplier<T>`（提供某些东西）及其原始消耗的特化，分别是`BooleanSupplier`、`DoubleSupplier`、`IntSupplier`和`LongSupplier`。
- en: We explored consumers (which take but do not give back), `Consumer<T>` and `BiConsumer<T,
    U>`, and their primitive consuming specializations, `DoubleConsumer`, `IntConsumer`,
    and `LongConsumer`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了消费者（只接收但不返回），`Consumer<T>`和`BiConsumer<T, U>`，以及它们的原始消耗特化，`DoubleConsumer`、`IntConsumer`和`LongConsumer`。
- en: We also looked at functions (which both take and give back), `Function<T, R>`
    and `BiFunction<T, U, R>`, and their primitive consuming counterparts.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了函数（既接收又返回），`Function<T, R>`和`BiFunction<T, U, R>`，以及它们的原始消耗对应物。
- en: Lastly, we examined variations of functions. `UnaryOperator<T>` is a variation
    of `Function`, where both the input and output types are the same. Similarly,
    `BinaryOperator<T>` is a variation of `BiFunction`, where the two input types
    and the output type are all the same.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了函数的变体。`UnaryOperator<T>`是`Function`的一种变体，其中输入和输出类型都是相同的。同样，`BinaryOperator<T>`是`BiFunction`的一种变体，其中两个输入类型和输出类型都是相同的。
- en: To make your code even more concise, in certain situations, you can use method
    references instead of lambda expressions. If your lambda is just invoking one
    method and there is redundancy concerning parameters, a method reference can be
    written.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的代码更加简洁，在某些情况下，你可以使用方法引用而不是lambda表达式。如果你的lambda只是调用一个方法，并且有关参数存在冗余，则可以编写方法引用。
- en: 'There are four different types of method references: bound, unbound, static,
    and constructor. A bound method reference is bound to an existing variable in
    the method, outside of the lambda’s scope. An unbound method reference relies
    on the instance to be passed at runtime. A static method reference is also considered
    unbound and executes a `static` method. Lastly, a constructor method reference
    creates objects using the `::``new` syntax.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用有四种不同类型：绑定、未绑定、静态和构造器。绑定方法引用绑定到方法中的现有变量，该变量位于 lambda 的作用域之外。未绑定方法引用依赖于在运行时传递的实例。静态方法引用也被视为未绑定，并执行一个
    `static` 方法。最后，构造器方法引用使用 `::``new` 语法创建对象。
- en: We also had a look at the importance of context in understanding method references.
    We saw an example where the same method reference was generating three different
    lambdas (in the background) due to the three different contexts.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了在理解方法引用时上下文的重要性。我们看到了一个例子，由于三个不同的上下文，同一个方法引用在后台生成了三个不同的 lambda 表达式。
- en: That completes our discussion on lambda expressions. They will be very important
    as we move on to our next two Stream-related chapters.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对 lambda 表达式的讨论。随着我们继续学习与 Stream 相关的下一章，它们将变得非常重要。
