- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover lambda expressions, which is one of my favorite
    features. Introduced in Java 8, lambda expressions (*lambdas*) brought functional
    programming to Java. First, we will define a *functional interface* and its relationship
    with lambdas. We will demonstrate both custom and API-based lambda expressions.
    We will also explain the concept of “final or effectively final” concerning local
    variables used inside a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will cover method references. We will discuss and present example
    code showing bound, unbound, static, and constructor method references. Lastly,
    we will explain the critical nature of context in understanding method references.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring functional interfaces from the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch14](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch14).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambda expressions save on keystrokes and therefore make your code more concise
    and hence, more readable and maintainable. For this to work, the compiler has
    to be able to generate the code that you no longer type in. This brings us to
    our first topic: functional interfaces. To understand lambdas, we must first understand
    functional interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that an interface has `default`, `static`, `private`, and `abstract`
    methods. A concrete (non-abstract) class that implements an interface must provide
    code for all of the `abstract` methods. *A functional interface is an interface
    with just one abstract method* – `default`, `static`, and `private` methods do
    not count. Neither do any methods inherited from `Object`. This one `abstract`
    method is known as the *functional method*.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*A lambda expression is an instance of a class that implements a functional
    interface.* The lambda is boiled down to its bare essentials. Lambdas look a lot
    like methods (and indeed in some quarters are called “anonymous methods”). However,
    a lambda is an instance with everything, but the method stripped away.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a sample functional interface and how a regular class would
    implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us examine the lambda version which does the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding two lines of code can appear in any method. The first line declares/defines
    the lambda and the second line executes it. Note that, when defining the lambda,
    there is no mention of a class implementing the functional interface `SampleFI`
    and also, there is no mention of the functional method `m()`. In fact, in the
    lambda declaration, the `()` is the parameter list for `m()`, which takes in nothing;
    the `->` token separates the method header from the method body and the `System.out.println("m()")`
    is the code for the method `m()`. Don’t worry, we will explain lambda syntax in
    detail very shortly with further code examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that lambdas save us from typing unnecessary code. For this to
    happen, the compiler must generate the (missing) code for us in the background.
    That is why lambdas are only applicable to functional interfaces – the compiler
    can infer a lot from the interface definition, due to the presence of only one
    `abstract` method. The compiler sees the one `abstract` method and knows immediately
    the signature required in the lambda. So, to recap:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas make your code more concise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambdas only work with functional interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lambda expression is an instance of a class that implements a functional interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let us look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions – example 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 14**.1* presents a custom lambda with an associated functional interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 14.1 – A functional interface with a lambda expression](img/B19793_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – A functional interface with a lambda expression
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we define a functional interface `SomeFunctionalInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It has one `abstract` method, named `m()`. As coded, this functional interface,
    `SomeFunctionalInterface`, can now be used in lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 11-13 define the first lambda expression, namely `lambda1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The reference type is of the `SomeFunctionalInterface` type, our functional
    interface type. The `lambda1` reference is assigned (to refer to) the instance
    of the class that implements `SomeFunctionalInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side of the assignment are round brackets, `()`. These are
    for the `m()` method in the interface, `SomeFunctionalInterface`. No parameters
    have been defined in the method declaration in the interface, so there are no
    parameters being passed in. As there are no parameters, `()` is required. Note
    that there is no need to mention the method name – this is because, as `SomeFunctionalInterface`
    is a functional interface, the compiler knows the only `abstract` method is `m()`.
    And as `m()` defines no parameters, the lambda header is simply `()`.
  prefs: []
  type: TYPE_NORMAL
- en: The arrow token, `->`, separates the method header (the parameters coming in,
    if any) from the method body. In this instance, the method body is a block of
    code; in other words, there are curly braces `{}`, as there would be in a normal
    method. Once you specify a block of code, the usual rules with a block are followed
    – meaning, the compiler backs off and does nothing for you. For example, if you
    wanted to `return` something from the block, you must do this yourself. In the
    next example, we will see that the compiler will do the `return` for you, provided
    you do not use a code block.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda in this example is simply outputting `"First lambda!"` to the screen.
    The semi-colon on line 13 is the normal end of statement token. Lines 11-13 simply
    *define* the lambda. No code has been executed at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Line 15, `lambda1.m()` executes the lambda referred to by `lambda1`, resulting
    in `"First lambda!"` being output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 17 defines a similar lambda except that it is even more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This lambda, `lambda2`, takes advantage of the fact that the compiler can do
    even more work for us. If you have only one statement to execute, then, as with
    other constructs such as loops, a set of curly braces is not necessary. As we
    are only executing `System.out.println()`, we do not need the curly braces, `{}`.
    The semi-colon at the end of line 17 is actually for the end of the assignment
    statement and not the end of `System.out.println()`. In other words, the semi-colon
    at the end of line 17 is the same semi-colon at the end of line 13 (and not the
    semi-colon at the end of line 12).
  prefs: []
  type: TYPE_NORMAL
- en: Again, line 17 only defines the lambda and no code has been executed. Line 18,
    `lambda2.m()` executes the lambda, resulting in `"Second lambda!"` being output
    to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note, the `@FunctionalInterface` annotation (line 3 in *Figure 14**.1*). This
    annotation ensures that the interface defines only one `abstract` method. Although
    optional, it is good practice to use it, as it highlights to other developers
    our intention with this interface. In addition, use of this annotation enables
    the compiler to step in if we fail to provide exactly one `abstract` method.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another example. This time, the functional method will accept
    a parameter and return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions – example 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 14**.2* presents an example that will enable us to discuss further
    nuances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 - A more complex functional interface with a lambda expression](img/B19793_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 - A more complex functional interface with a lambda expression
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the `Evaluate` function interface is generically typed for `<T>`.
    This means that we can use it for various types, such as `Integer` (line 12) and
    `String` (line 16). The `check` functional method (line 8) takes in a parameter
    of type `T`, namely `t`, and returns a `boolean` value. This particular functional
    interface is very similar to one we will look at later from the Java API, namely
    `Predicate`. By way of contrast, the first lambda (line 12) is coded quite differently
    from the second lambda (line 16).
  prefs: []
  type: TYPE_NORMAL
- en: On line 12, we declare an `Evaluate` reference, namely `isItPositive`, that
    is typed for integers only. With lambdas, context is key. As we have typed `isItPositive`
    for `Integer`, this means that the identifier, `n`, in round brackets is of the
    `Integer` type! We have explicitly specified the type for `n` in this example,
    but this is not necessary since the compiler can figure it out from the context.
    In other words, we could have just used `(n)` or simply `n` in the lambda and
    it would have worked. We just left it as `(Integer n)` so that the relationship
    between the lambda (line 12) and the `check(T t)` functional method (line 8) is
    clearer.
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand side of `=` on line 12 we have `(Integer n) -> {return n>0;}`.
    This is the code for the `check(T t)` method in the class implementing `Evaluate`.
    Therefore, one parameter is required, typed for `Integer` due to the `Evaluate<`*Integer*`>`
    declaration, and a `boolean` value must be returned.
  prefs: []
  type: TYPE_NORMAL
- en: We have the `->` token again to separate the method header from the method body.
  prefs: []
  type: TYPE_NORMAL
- en: On line 12, as with all lambdas, the right-hand side of the `->` token is the
    method body. In this case, we have `{return n>0;}`. As we have used curly braces,
    we must follow regular syntax rules when inside a code block. Given that the `check(T
    t)` method has a `boolean` return type, we must return a `boolean` value from
    the code block. Also, the `return` statement requires a closing semi-colon as
    usual. The overall assignment statement requires a closing semi-colon also. This
    is why there are two semi-colons near the end (line 12). What we are saying in
    this lambda is that if the `Integer` type passed in is greater than 0, we return
    `true`; otherwise, we return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 13, `isItPositive.check(-1)` executes the lambda, passing in `-1`, which
    returns `false`. Line 14, `isItPositive.check(+1)` also executes the lambda, this
    time passing in `+1`, which returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 16 is: `Evaluate<String> isMale = s -> s.startsWith("Mr.");`. This defines
    an `Evaluate` lambda, typed for `String`, referred to by the `isMale` reference.
    As we typed the lambda for `String`, the parameter this time coming in, namely
    `s`, is of type `String`. Remember, what we are defining on line 16 is effectively
    the code for the `check(T t)` method. Notice that this time, we have not specified
    the type for `s` as the compiler figures it out from the context (`Evaluate<String>`).
    Also, as there is just one parameter and we have not specified the type, we can
    leave out the round brackets, `()`. However, as we have seen already, if you have
    no parameters at all, you must specify `()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, on line 16, note that as we have not used a code block, we do not need
    an explicit `return` statement as the compiler will do that for us. As `s` is
    a `String`, we can call `String` methods; which is why we have no issue calling
    `startsWith("Mr.")`. The semi-colon at the end of the line is for the overall
    assignment statement and not for the lambda (as none is required). In this lambda,
    we just evaluate the string passed in to see if it begins with “Mr.” and if it
    does, `true` is returned; otherwise, `false` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: With the lambda now defined, we can execute it. Line 17, `isMale.check("Mr.
    Sean Kennedy")` returns `true` and line 18, `isMale.check("Ms. Maaike van Putten")`
    returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the compiler infers a lot, saving us a lot of typing. It takes
    a while to get used to lambdas but once you do, you will love them. *Table 14.1*
    summarizes the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functional Interface** | **Sample** **Lambda Expressions** |'
  prefs: []
  type: TYPE_TB
- en: '| `interface FI{``void m();``}` | `FI fi1 = () ->` `System.out.println("lambda");``fi1.m();
    //` `outputs "lambda"``FI fi2 = () -> { System.out.println("lambda"); } ;``fi2.m();
    //` `outputs "lambda"` |'
  prefs: []
  type: TYPE_TB
- en: '| `interface FI{``int` `m(int x);``}` | `FI fi3 = (int x) -> { return x *`
    `x;};``System.out.println(fi3.m(5)); //` `25``FI fi4 = x -> x *` `x;``System.out.println(fi4.m(6));
    //` `36` |'
  prefs: []
  type: TYPE_TB
- en: '| `interface FI{``String m(String a,` `String b);``}` | `FI fi5 = (s1, s2)
    -> s1 +` `s2;``// next line returns ''``Sean Kennedy''``System.out.println(fi5.m("Sean",
    "` `Kennedy"));``FI fi6 = (String s1 , String s2) -> {return s1 +` `s2; };``//
    next line returns ''``Sean Kennedy''``System.out.println(fi6.m("Sean", "` `Kennedy"));`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 14.1 – Examples of functional interfaces and associated lambda expressions
  prefs: []
  type: TYPE_NORMAL
- en: The longer syntax, with the parameter types, code blocks, and `return` statements,
    is syntactically similar to regular methods (except the method name is omitted).
    The shorter, more concise syntax, demonstrates just how much the compiler can
    infer from the surrounding context. This is possible as there is only one `abstract`
    method in a functional interface. Lambdas cannot and do not work with interfaces
    that have more than one `abstract` method. As interfaces can inherit from each
    other, be wary of inheriting an `abstract` method and then trying to define your
    own – that will not work for lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand functional interfaces and how to implement them using
    lambda expressions, let’s examine why local variables must be `final` or “effectively
    final.”
  prefs: []
  type: TYPE_NORMAL
- en: final or effectively final
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that by declaring a variable `final`, you are making it a constant, which
    means that the value of the variable, once assigned, cannot be changed. “Effectively
    final” means that even though the `final` keyword is not used in the variable
    declaration, the compiler makes it *effectively final* by ensuring that if you
    try to change its value, you get a compiler error. Note that this rule of `final`
    or “effectively final” relates only to local variables and does not apply to instance
    or class variables.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.3* presents code demonstrating the use of `final` or “effectively
    final”. We will first explain the code and then explain why the local variable
    is “effectively final.”'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – “final” or “effectively final” code example](img/B19793_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – “final” or “effectively final” code example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the algorithm removes any names from the list that begin with
    `"Mr."`. Lines 9-11 declare and populate an `ArrayList` list.
  prefs: []
  type: TYPE_NORMAL
- en: Line 13 declares a local `String` variable named `title`. This variable is used
    in the lambda (line 21) and therefore, as it is not explicitly declared `final`,
    it is “effectively final.”
  prefs: []
  type: TYPE_NORMAL
- en: Lines 14-15 declare and change a local `int` variable, `y`. As `y` is not used
    in the lambda expression, this is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 19-22 present the lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The lambda is a `Predicate`, typed for `String`. `Predicate` is an API functional
    interface, which we will discuss in detail in the next section. The functional
    method for `Predicate` is `boolean test(T t)`. As we have typed the `Predicate`
    for `String`, both `T` and consequently `str` are `String`’s. The lambda returns
    `true` or `false` depending on whether `str` begins with `"Mr."`, thereby matching
    the return type of the `test` functional method. This is an important point –
    the lambda has taken a snapshot of the value in the local variable `title`; which
    is `"Mr."`.
  prefs: []
  type: TYPE_NORMAL
- en: Both lines 27 and 30 invoke `filterData(people, lambda)`. This is one of the
    real advantages of lambdas – they can be passed around! But remember, the value
    of `title` in the lambda is `"Mr."`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 32-34 show the `filterData()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The lambda is passed to the `default` method, `removeIf(Predicate)`, which is
    inherited from `Collection`. `Collection` is a parent interface of `List`. `removeIf(Predicate)`
    removes all elements from the list that satisfy the predicate (lambda) passed
    in. In this example, any names that begin with `"Mr."` are removed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can see why the value of `title` (line 13) must never be allowed to
    change – the lambda uses `"Mr."` (line 21). If we were allowed to change `title`,
    either in the lambda (line 20) or in the method (lines 26 or 29), then the value
    of `title` in the method and the value of `title` in the lambda would not match!
    This must not happen. Therefore, any changes to `title`, either in the method
    or in the lambda, are prohibited. This is why lines 20, 26, and 29 are all commented
    out. Uncommenting any of them results in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring functional interfaces from the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s examine some popular functional interfaces defined in the API. Interestingly,
    the two sorting interfaces from [*Chapter 13*](B19793_13.xhtml#_idTextAnchor317),
    namely `Comparator` and `Comparable`, are both functional interfaces. `Comparable`
    defines one `abstract` method, namely `int compareTo(T o)`, and `Comparator` defines
    two `abstract` methods, namely `int compare(T o1, T o2)` and `boolean equals(Object
    o)`. Remember, however, that methods inherited from `Object` do not count when
    you’re deciding if an interface is a functional interface or not. As `boolean
    equals(Object o)` is inherited from `Object`, this means that `Comparator` is
    a functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will concentrate on the functional interfaces defined in
    the `java.util.function` package ([https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html)).
    This package has a large number of general-purpose functional interfaces that
    are used by the JDK and are available to us also. *Table 14.2* presents the most
    commonly used ones. Please refer to the API for further details. We will examine
    these functional interfaces and their lambda expressions in code shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functional Interface** | **Functional Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Predicate<T>` | `boolean` `test(T t)` | Useful for testing |'
  prefs: []
  type: TYPE_TB
- en: '| `BiPredicate<T, U>` | `boolean test(T t,` `U u)` | This is a two-arity (two
    parameters) specialization of `Predicate` |'
  prefs: []
  type: TYPE_TB
- en: '| `Supplier<T>` | `T get()` | Useful for when you want values without providing
    input |'
  prefs: []
  type: TYPE_TB
- en: '| `Consumer<T>` | `void` `accept(T t)` | Useful for when you pass in input
    but do not care about a return value |'
  prefs: []
  type: TYPE_TB
- en: '| `BiConsumer<T, U>` | `void accept(T t,` `U u)` | This is a two-arity specialization
    of `Consumer` |'
  prefs: []
  type: TYPE_TB
- en: '| `Function<T, R>` | `R` `apply(T t)` | Transforms the input into an output
    (types can be different) |'
  prefs: []
  type: TYPE_TB
- en: '| `BiFunction<T,` `U, R>` | `R apply(T t,` `U u)` | This is a two-arity specialization
    of `Function` |'
  prefs: []
  type: TYPE_TB
- en: '| `UnaryOperator<T>` | `T` `apply(T t)` | The same as `Function` except the
    types are the same |'
  prefs: []
  type: TYPE_TB
- en: '| `BinaryOperator<T>` | `T apply(T t1,` `T t2`) | The same as `BiFunction`
    except the types are all the same |'
  prefs: []
  type: TYPE_TB
- en: Table 14.2 – Popular functional interfaces in the API
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine each of the preceding functional interfaces and their associated
    lambdas in code. Let’s start with `Predicate` and `BiPredicate`.
  prefs: []
  type: TYPE_NORMAL
- en: Predicate and BiPredicate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A predicate is a boolean-valued function (a function that will return `boolean`).
    *Figure 14**.4* presents `Predicate` and `BiPredicate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Predicate and BiPredicate in code](img/B19793_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Predicate and BiPredicate in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we would first like to discuss the relationship in the API between
    the generic types of functional interfaces and their functional methods. Understanding
    this relationship is key to understanding the examples and creating the context
    used by the compiler. This context will be very important when we discuss method
    references later.
  prefs: []
  type: TYPE_NORMAL
- en: As the comments on lines 32-33 indicate, there is a direct relationship between
    the generic types and both the parameter and return types used by the functional
    method. In this case, `Predicate` is generically typed for `T` (line 32), and
    the functional methods input parameter is also typed for `T` (line 33). Therefore,
    if we type our `Predicate` for `Integer`, then the parameter in the functional
    method will be `Integer`. We cannot pass `Cat`, `Dog`, `String`, or any other
    type as an argument. Now, let’s look at the example.
  prefs: []
  type: TYPE_NORMAL
- en: Line 34 defines a `Predicate`, generically typed for `String`, namely `isCityInName`.
    `cityName -> cityName.contains("City")` is the code for the `boolean test(T t)`
    functional method. As the generic type is `String`, `T` is now `String` for this
    functional method, meaning that the parameter type is `String`. Thus, the `cityName`
    variable on line 34 represents a `String` variable. This is why the compiler has
    no issue with `cityName.contains("City")` in the lambda expression. As `cityName.contains("City")`
    is a simple expression, we do not need `{}` or a `return` statement – the compiler
    will fill all that in for us. Bear in mind that the expression we use must return
    a `boolean` value as the `boolean test(T t)` functional method returns `boolean`.
    The `String` method, `boolean contains(CharSequnce)`, does exactly that, so we
    are fine. So, with our lambda expression defined, let’s execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Line 35 executes the `isCityInName` lambda defined on line 34\. Note that the
    method that’s invoked using the `isCityInName` reference is the `boolean test(T
    t)` functional method. As we have generically typed `isCityInName` to `String`,
    the argument we pass must be a `String` argument. This is what we do, passing
    in `"Vatican City"`. This means that the `cityName` parameter in our lambda (line
    34) becomes `"Vatican City"` and thus the code in the `boolean test(T t)` method
    becomes `"Vatican City".contains("City")`. Consequently, line 35 outputs `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 39 defines a `BiPredicate`, generically typed for `String, Integer`; namely
    `checkStringLength` Again, the comments (lines 37-38), demonstrate the close relationship
    between the functional interface’s generic types and the parameters for the functional
    method. `BiPredicate` is simply an extension of `Predicate` except that there
    are now two (input) parameters for the functional method, instead of one. The
    functional method name is still `test` and the return type is again `boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: As `checkStringLength` is defined as `BiPredicate<String, Integer>`, the signature
    for the functional method is now `boolean test(String str, Integer len)`. The
    lambda then checks if the length of the string passed in as the first parameter,
    is equal to the number passed in as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: On line 40, we test `BiPredicate`, passing in `"Vatican City"` and `8` in that
    order. The lambda returns `false` as the length of the `"Vatican City"` string
    is `12` (and not `8`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed earlier, both `Predicate` and `BiPredicate` are generically typed
    for `T`. This means that their functional method consumes a type, `T`, such as
    `String`, `Integer`, and so forth. This is in contrast to predicates that consume
    primitives. The following table, *Table 14.3*, presents the functional interfaces
    defined in the API for predicates that wish to consume primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functional Interface** | **Functional Method** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DoublePredicate` | `boolean` `test(double value)` | `DoublePredicate p1
    = d -> d >` `0;` |'
  prefs: []
  type: TYPE_TB
- en: '| `IntPredicate` | `boolean` `test(int value)` | `IntPredicate p2 = i -> i
    >` `0;` |'
  prefs: []
  type: TYPE_TB
- en: '| `LongPredicate` | `boolean` `test(long value)` | `LongPredicate p3 = lg ->
    lg >` `0;` |'
  prefs: []
  type: TYPE_TB
- en: Table 14.3 – Primitive testing specializations of Predicate in the API
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the table, there are no generic types, such as `<T>` in
    the names of the functional interfaces. The functional methods have primitive
    parameters (instead of generic types). As we are dealing with primitives, the
    lambdas cannot invoke methods on the arguments (as primitives are just simple
    types and have no methods).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the `Supplier` functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: Supplier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 14**.5* presents code that demonstrates `Supplier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Supplier in code](img/B19793_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Supplier in code
  prefs: []
  type: TYPE_NORMAL
- en: The `Supplier` functional interface is very useful when you want a new object.
    The generic type determines the result supplied. In other words, line 47 types
    `supSB` for `StringBuilder`, where the functional method, `get()`, returns `StringBuilder`.
    Line 47 also demonstrates that if you have no parameters at all, you must specify
    the round brackets, `()`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 48 executes the lambda expression defined on line 47\. Note that we chain
    `append("SK")` onto the return of the `get()` method. This will only work if the
    `get()` method returns a `StringBuilder` object, which it does.
  prefs: []
  type: TYPE_NORMAL
- en: Line 50 defines a `Supplier` functional interface, typed for `LocalTime`, called
    `supTime`. The lambda returns the local time. Line 51 executes it by invoking
    the functional method for `Supplier`, namely `T get()`. The output from a sample
    run is included in a comment on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Line 53 defines a `Supplier` functional interface typed for `Double` called
    `sRandom`, which returns a random number. `Math.random()` returns a `double` value
    greater than or equal to 0.0 and less than 1.0\. Line 54 executes it with sample
    output in a comment on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generically typed `Supplier` functional interface also has variants to
    cater to primitives. *Table 14.4* shows these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functional Interface** | **Functional Method** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BooleanSupplier` | `boolean getAsBoolean()` | `BooleanSupplier bS = () ->`
    `LocalDate.now().isLeapYear();` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.out.println(bS.getAsBoolean());` |'
  prefs: []
  type: TYPE_TB
- en: '| `DoubleSupplier` | `double getAsDouble()` | `DoubleSupplier dS = () ->` `Math.random();`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.out.println(dS.getAsDouble());` |'
  prefs: []
  type: TYPE_TB
- en: '| `IntSupplier` | `int getAsInt()` | `IntSupplier iS = () -> (``int)(Math.random()*20);`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.out.println(iS.getAsInt());` |'
  prefs: []
  type: TYPE_TB
- en: '| `LongSupplier` | `long getAsLong()` | `LongSupplier lgS = () -> (``long)(Math.random()*100);`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.out.println(lgS.getAsLong());` |'
  prefs: []
  type: TYPE_TB
- en: Table 14.4 – Primitive-producing specializations of Supplier in the API
  prefs: []
  type: TYPE_NORMAL
- en: In this table, the functional interface name identifies the primitive type being
    generated. For example, `BooleanSupplier` produces a `boolean` primitive type.
    The functional method follows accordingly; for example, `BooleanSupplier` has
    a `boolean getAsBoolean()` method. The other functional interfaces follow a similar
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the `Consumer` and `BiConsumer` functional interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Consumer and BiConsumer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with `Consumer`, which, as per the API, “*represents an operation
    that takes in a single input and returns no result.*” *Figure 14**.6* presents
    code demonstrating the use of `Consumer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Consumer in code](img/B19793_14_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Consumer in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, line 67 (a comment) outlines that the `void accept(T t)` functional
    method does exactly as per the API: it takes in a single input and returns nothing
    (`void`). Consumers are very useful for outputting collections. In this example,
    `Consumer` (line 68) takes in a `String`, `s`, and echoes it to the standard output
    (the screen). We execute the lambda (line 69), passing in the string we want displayed.
    So, the `"To be or not to be, that is the question"` string is the argument to
    the `void accept(T t)` functional method. Here, the `s` parameter (line 68) takes
    on the string value, which is then output.'
  prefs: []
  type: TYPE_NORMAL
- en: The Iterable interface
  prefs: []
  type: TYPE_NORMAL
- en: The `Iterable` interface is inherited by many other popular interfaces, such
    as `List` and `Set`, and consequently, implemented by a large number of classes.
    Before Java 8, interfaces only had `abstract` methods – there were no `default`,
    `static`, or `private` methods (they all came in later releases of Java). This
    meant that if you changed an interface (method signature or added a new method),
    the existing code base would break. One of the main reasons for introducing `default`
    methods was for the Java designers to introduce the `default` method, `forEach(Consumer<?
    super T> action)`, into `Iterable` without breaking the existing code base. The
    default implementation is to execute the `Consumer` lambda on each element in
    the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine how the Java API utilizes consumers. Line 71 declares an
    `ArrayList` of strings, namely `names`. Line 72 adds `"Maaike"` and `"Sean"` to
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 73 is very interesting. We execute the `forEach()` method on the list,
    passing in the consumer lambda, `printC`, that was created on line 68\. The `forEach()`
    method loops through each `String` in the list and invokes the `Consumer` lambda,
    `printC`, on each `String`. In effect, the following happens in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at an example of a `BiConsumer` interface in action. *Figure
    14**.7* presents an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – BiConsumer in code](img/B19793_14_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – BiConsumer in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, on line 75, we declare a `Map<String, String>`, namely `mapCapitalCities`,
    implemented by a `HashMap`. Both the key and the value in the map are strings.
    The `BiConsumer` `biCon` is declared on lines 80-81\. The functional method, `void
    accept(T t, U u)`, requires two parameters – we have called them `key` and `value`.
    Both are strings due to the context (the declaration of `biCon`). The lambda on
    line 81, is simply inserting the `key` and `value` into the map. This is known
    as a “side effect” (see the callout). Lines 82-83 populate the map using the lambda
    and line 84 outputs the map.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, lambda expressions are considered a functional style of programming.
    While functional programming is outside the scope of this book, functions adhering
    to the functional programming style should not generate side effects. A side effect
    is a change to the program state not reflected in the function’s output. `Consumer`s,
    unlike most other functional interfaces in Java, are expected to operate via side
    effects (as the return type for the functional methods is `void`). For further
    detail please see: [https://en.wikipedia.org/wiki/Functional_programming](https://en.wikipedia.org/wiki/Functional_programming)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there a `forEach()` method for `Map`? Thankfully, there is. It is a `default`
    method defined in the `Map` interface and its signature is `default void forEach(BiConsumer<?
    super K, ? super V) action)`. Lines 86-88 set up the lambda expression to output
    the decorated string, stating that `key` is the capital of `value` (depending
    on the key/value pairs). Line 89 executes `forEach()`, passing in our `BiConsumer`.
    The `forEach()` method loops through each entry in the map and invokes the `BiConsumer`
    lambda, `mapPrint`, on each entry. In effect, the following happens in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The generically typed `Consumer` functional interface also has variants to
    cater for primitives. *Table 14.5* shows these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functional Interface** | **Functional Method** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `DoubleConsumer` | `void` `accept(double value)` | `DoubleConsumer dc = d
    ->` `System.out.println(d);` |'
  prefs: []
  type: TYPE_TB
- en: '| `dc.accept(2.4);` |'
  prefs: []
  type: TYPE_TB
- en: '| `IntConsumer` | `void` `accept(int value)` | `IntConsumer ic = i ->` `System.out.println(i);`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ic.accept(2);` |'
  prefs: []
  type: TYPE_TB
- en: '| `LongConsumer` | `void` `accept(long value)` | `LongConsumer lc = lg ->`
    `System.out.println(lg);` |'
  prefs: []
  type: TYPE_TB
- en: '| `lc.accept(8L);` |'
  prefs: []
  type: TYPE_TB
- en: Table 14.5 – Primitive-accepting specializations of Consumer in the API
  prefs: []
  type: TYPE_NORMAL
- en: Again, the primitive name is embedded into the functional interface name. Note
    that the parameter type passed into the `accept()` functional method is a primitive
    each time
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the `Function` and `BiFunction` functional interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Function and BiFunction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function accepts one argument and produces a result. *Figure 14**.8* presents
    some code demonstrating the use of both `Function` and `BiFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Function and BiFunction in code](img/B19793_14_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Function and BiFunction in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the comments on lines 101-102 show how the `Function` functional
    interface and its functional method appear in the API. `Function` is generically
    typed, with the first type, `T`, representing the input type and the second type,
    `R`, representing the output type. What this means is that, when, on line 103,
    we declare `Function<String, Integer>`, the functional method is `Integer apply(String
    s)`. This is reflected in the lambda expression on line 103, where we accept a
    string, `s`, and return its length. Note that the string’s `length()` method returns
    an `int` type but Java will auto-box this to an `Integer` type for us.
  prefs: []
  type: TYPE_NORMAL
- en: Line 104 executes the lambda, passing in `"London"`, which returns `6`.
  prefs: []
  type: TYPE_NORMAL
- en: The `BiFunction` functional interface represents a function that accepts two
    arguments and produces a result. The comments on lines 106-107 shows its signature
    in the API, namely `BiFunction<T, U, R>`, and that of its functional method, which
    is `R apply(T t, U u)`. Therefore, the first two types are inputs and the last
    type is the output type.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 108-109 define a `BiFunction` interface where we are accepting in two
    `String`s and returning an `Integer` type. The lambda implementing it takes in
    two `String` parameters, namely `s1` and `s2`, and returns the sum of their lengths.
  prefs: []
  type: TYPE_NORMAL
- en: Line 111 invokes the lambda while passing in the `"William"` and `"Shakespeare"`
    strings. Their lengths are `7` and `11`, respectively, resulting in `18` being
    returned by the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 113-114 define a `BiFunction` interface where we are accepting in two
    `String`s again, but this time, we return a `String`. The lambda (line 114) simply
    concatenates the second `String` onto the first `String` and returns the result.
    Line 116 executes the lambda while passing in the same two strings, `"William"`
    and `"Shakespeare"`. This time, the result is the concatenation of the two, which
    is `"``William Shakespeare"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generically typed `Function` functional interface also has variants to
    cater to primitives. *Table 14.6* presents a subset of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functional Interface** | **Functional Method** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DoubleFunction<R>` | `R` `apply(double value)` | `DoubleFunction<String>
    df = (double dbl) -> "" +` `Math.pow(dbl, 2);` |'
  prefs: []
  type: TYPE_TB
- en: '| `df.apply(2.0); // "``4.0"` |'
  prefs: []
  type: TYPE_TB
- en: '| `DoubleToIntFunction` | `int` `applyAsInt(double value)` | `DoubleToIntFunction
    dtoif = dbl -> (``int)Math.round(dbl);` |'
  prefs: []
  type: TYPE_TB
- en: '| `dtoif.applyAsInt(4.2);// 4` |'
  prefs: []
  type: TYPE_TB
- en: '| `DoubleToLongFunction` | `long` `applyAsLong(double value)` | `DoubleToLongFunction
    dtolf = (dbl) ->` `Math.round(dbl);` |'
  prefs: []
  type: TYPE_TB
- en: '| `dtolf.applyAsLong(4.0);// 4` |'
  prefs: []
  type: TYPE_TB
- en: Table 14.6 – Double (primitive) specializations of Function in the API
  prefs: []
  type: TYPE_NORMAL
- en: There are many more functional interfaces than those presented in *Table 14.6*.
    Please refer to the API for further details. They can be daunting but remember
    that there is a pattern in the functional interface names and their associated
    functional method names. This helps in understanding what they do.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in *Table 14.6*, the `double` primitive type is catered for with
    `DoubleFunction<R>`, `DoubleToIntFunction`, and `DoubleToLongFunction`. There
    are corresponding functional interfaces for `int` and `long`.
  prefs: []
  type: TYPE_NORMAL
- en: The `int` functional interfaces are `IntFunction<R>`, `IntToDoubleFunction`,
    and `IntToLongFunction`. These `int`-related functional interfaces do the same
    thing as their `double` counterparts (as outlined in *Table 14.6*), except the
    input is `int` and not `double`. The relevant functional method names will depend
    on the result type. For example, the functional method for `IntToDoubleFunction`
    will be `double` `applyAsDouble(int value)`.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for the `long` primitive. The `long` functional interfaces
    are `LongFunction<R>`, `LongToDoubleFunction`, and `LongToIntFunction`. Their
    functional method names follow the same pattern as `int` and `double`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish our discussion on functional interfaces by examining `UnaryOperator`
    and `BinaryOperator`.
  prefs: []
  type: TYPE_NORMAL
- en: UnaryOperator and BinaryOperator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both of these functional interfaces are specializations of other interfaces.
    Let’s discuss `UnaryOperator` first.
  prefs: []
  type: TYPE_NORMAL
- en: UnaryOperator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the API, the `Function` functional interface is defined as `Function<T, R>`.
    `T` represents the input to the function and `R` represents the output from the
    function. The fact that the letters are different is important. This means that,
    while the types can of course be the same, they can also, and often are, different.
  prefs: []
  type: TYPE_NORMAL
- en: '`UnaryOperator` is a specialization of `Function` where both the input and
    output types are the same. In the API, `UnaryOperator` is defined as `UnaryOperator<T>
    extends Function<T, T>` and its functional method is `T` `apply(T t)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.9* presents an example in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9 – UnaryOperator in code](img/B19793_14_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – UnaryOperator in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 128 defines a `UnaryOperator` typed for `String`. This
    means that both the input and output are now strings. The `name` identifier is
    a `String` and we are just pre-pending `"My name is "` to `name`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 130 executes the lambda by passing in `"Sean"`. The return `String` of
    `"My name is Sean"` is output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine `BinaryOperator`.
  prefs: []
  type: TYPE_NORMAL
- en: BinaryOperator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `BinaryOperator` functional interface is to `BiFunction` what `UnaryOperator`
    is to `Function`. In other words, `BiFunction` allows us to specify two input
    parameters and an output result, all of which could be different types. `BinaryOperator`,
    which `extends` `BiFunction`, mandates that the two input types and the output
    type must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: In the API, `BinaryOperator` is defined as `BinaryOperator<T> extends BiFunction<T,
    T, T>`, and its functional method is `T apply(T t1,` `T t2)`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14**.10* presents an example in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – BinaryOperator in code](img/B19793_14_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – BinaryOperator in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 134 defines a `BinaryOperator` typed for `String`. This
    means that both the input parameters and the result are now strings. The `s1`
    and `s2` identifiers are strings and we are just returning the result of concatenating
    `s2` onto `s1`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 136 executes the lambda by passing in `"William"` and `"Shakespeare"`.
    The return `String` of `"William Shakespeare"` is output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering method references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s move on to another important topic concerning lambda expressions,
    and that is method references. As concise as lambdas are, in certain situations,
    they can be even more concise! This is where method references apply. If all your
    lambda does is call one method, then this is an opportunity for a method reference.
    In addition, if a lambda parameter is simply passed to a method, then the redundancy
    of specifying the variable twice can also be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we declare a list of strings by invoking the `Arrays.asList()`
    method. The first `forEach(Consumer)` shows how to output the list using a lambda
    expression. Recall that the functional method of `Consumer` is `void` `accept(T
    t)`.
  prefs: []
  type: TYPE_NORMAL
- en: The second `forEach(Consumer)` shows the method reference syntax. Note the double-colon
    operator, `::` (or method reference operator), and the fact that there are no
    round brackets, `()`, after the method name, as in `println`.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind at all times that the code has to be generated at some point. If
    we have all the code specified, then the compiler has nothing to do. However,
    if we have availed of lambdas and/or method references, the compiler must step
    in and generate the omitted code. The compiler can only do so when it understands
    the *context*. This is crucial to making sense of method references given that
    there is so much code omitted. Moreover, the functional interface, with its functional
    method, is critical for providing context.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four different types of method references:'
  prefs: []
  type: TYPE_NORMAL
- en: Bound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are best explained with examples in code. Regarding the examples, to make
    them easier to understand, we have coded both the lambda and method reference
    versions for each example. The lambda variables use the `"L"` suffix and the method
    reference variables use the `"MR"` suffix. In addition, in the comments, just
    before each example, are the signatures of the functional interfaces and their
    associated functional methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start with the first method reference type: bound method references.'
  prefs: []
  type: TYPE_NORMAL
- en: Bound method references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bound references get their name from the fact that the reference is bound to
    an instance of a particular object. A bound method reference is sometimes referred
    to as a “reference to an instance of a particular object.” Let’s use an example
    to explain this further. *Figure 14**.11* presents a bound method reference example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Bound method reference example](img/B19793_14_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.11 – Bound method reference example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 21 declares a `String` variable called `name`, initialized
    to `"Mr. Joe Bloggs"`. Lines 22-23 outline the `Supplier` functional interface
    and the signature of its functional method, `T get()`, in the API. Line 24 declares
    a `Supplier` lambda that converts `name` into lowercase. This is the same `name`
    variable declared on line 21\. Hence, this lambda is *bound* to the `name` variable
    at compile time. As the lambda is simply calling one method, this is an opportunity
    to introduce a method reference.
  prefs: []
  type: TYPE_NORMAL
- en: Given the lambda on line 24, line 25 outlines the equivalent method reference.
    Note the use of the `name` variable; the method reference operator `::` and the
    omission of the round brackets `()` after the method name. Also, note that `name`
    is a `String` and that the `toLowerCase()` method is a method in the `String`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 28 and 29 execute the lambda and method reference versions, respectively,
    returning `"mr. joe bloggs"` on both occasions.
  prefs: []
  type: TYPE_NORMAL
- en: The first example in *Figure 14**.11* is using the `Supplier` functional interface,
    which did not require an input parameter. What if we wanted to pass in a value?
    A `Supplier` functional interface will not work as its functional method is `T
    get()`, which does not accept parameters. However, a `Predicate` will work as
    its functional method, `boolean test(T t)`, does accept an input parameter. The
    second example in *Figure 14**.11* shows this in action.
  prefs: []
  type: TYPE_NORMAL
- en: Line 37 is the lambda version. As `Predicate` is typed for `String`, `title`
    is a `String`. Again, we bind to `name` and execute the `String` method, `startsWith()`,
    passing in the input parameter. We can see the redundancy in the lambda given
    that `title` is mentioned twice. Couple this with the fact that the lambda is
    simply calling one method, we have another opportunity to introduce a method reference.
  prefs: []
  type: TYPE_NORMAL
- en: Line 38 is the method reference version of the lambda on line 37\. This method
    reference requires a bit more explanation however because, in the `String` class,
    the `startsWith()` method is overloaded. The overloaded versions are `boolean
    startsWith(String, int)` and `boolean startsWith(String)`. How does the compiler
    decide which version of `startsWith()` to use? This is where context is important!
    We are defining a `Predicate` and the functional method for `Predicate` is `boolean
    test(T t)` - given that this method accepts just one parameter, the compiler selects
    the `startsWith()` method with one parameter, namely `boolean startsWith(String)`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 40 executes the lambda version, passing in `"Mr."` This results in the
    lambda executing `"Mr. Joe Bloggs".startsWith("Mr.")`, which is true.
  prefs: []
  type: TYPE_NORMAL
- en: Line 41 executes the method reference version, passing in `"Ms."`. As the compiler
    translates the method reference into a lambda in the background, this results
    in the lambda executing `"Mr. Joe Bloggs".startsWith("Ms.")`, which is false.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will examine unbound method references.
  prefs: []
  type: TYPE_NORMAL
- en: Unbound method references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unbound method references do not bind to a variable. Instead, the instance
    to use is provided at runtime. An unbound method reference is sometimes referred
    to as a “reference to an instance of an arbitrary object of a particular type.”
    *Figure 14**.12* present an example in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12 – Unbound method reference example](img/B19793_14_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.12 – Unbound method reference example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we define a lambda on line 48\. This lambda is of the `Function<String,
    String>` type, meaning that the functional method is `String apply(String)`. Thus,
    `s` is a `String` and we can invoke the `String` method, `toUpperCase()`. Note
    that `s` is not a variable from the method’s scope. In *Figure 4**.11*, we were
    bound to the `name` variable declared in the method. Now, however, `s` has the
    scope of the lambda expression only. This means that the method reference is *unbound*.
    The lambda parameter, `s`, will be bound to at runtime (when the `apply()` method
    is called), as on line 51.
  prefs: []
  type: TYPE_NORMAL
- en: As the lambda has just one method call and there is redundancy with `s` on both
    sides of the `->` token, we can use a method reference. Line 49 represents the
    method reference version of the lambda on line 48\. Note the use of the method
    reference operator `::` and the absence of `()` after the method name, `toLowerCase`.
    As `toLowerCase` is a `String` method, `String` precedes the `::` operator in
    the method reference. The method reference on line 49 is semantically equivalent
    to the lambda on line 48.
  prefs: []
  type: TYPE_NORMAL
- en: Line 57 declares a `BiFunction` lambda. Recall that `BiFunction` takes in two
    inputs and returns a result. In this case, all are `String` types. The parameters
    that are passed in are concatenated and returned. Again, we have only one method
    call in the lambda and redundancy of variables, so we can code a method reference.
  prefs: []
  type: TYPE_NORMAL
- en: Line 58 represents the method reference version of the lambda on line 57\. Again,
    context is going to be key in figuring out the method reference. `BiFunction<String,
    String, String>` and `String::concat` inform the compiler that this is an unbound
    method reference that will take in two `String` arguments and concatenate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one other bit of information implied here – the first argument provided
    in the `apply()` method call is the instance to be used for the `concat()` method;
    the second argument is to be passed into the `concat()` method as an argument.
    What this means is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This can be seen on lines 62 and 63\. The execution of the method reference
    on line 63 translates into the code in comments on line 62\. Both the lambda and
    method reference invocations (lines 59 and 63, respectively) result in `"Sean
    Kennedy"` being returned.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore static method references.
  prefs: []
  type: TYPE_NORMAL
- en: Static method references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `static` method reference is also considered unbound as we do not bind to
    a variable from the outer scope. The method being invoked is `static`, hence the
    name. Let’s examine a `static` method reference in code. *Figure 14**.13* shows
    such an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13 – Static method reference example](img/B19793_14_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.13 – Static method reference example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we define a `Consumer` lambda (line 110) that takes in a `List<Integer>`
    list. As we know, `Consumer`s take in one argument and do not return anything.
    The side effect is to call the `static` `Collections` method, `sort`, passing
    in the list to be sorted. As our lambda has just one method call and we have redundancy
    (`list` on both sides of the `->` token), we can re-write the lambda even more
    concisely as a method reference.
  prefs: []
  type: TYPE_NORMAL
- en: Line 111 is the method reference version of the lambda that was coded on line
    110\. The `Collections.sort()` method is overloaded – one version is `sort(List)`
    and the other is `sort(List, Comparator)`. Context decides which one the compiler
    selects. As the `Consumer` lambda’s functional method is `void accept(T t)`, which
    takes just one parameter, the `sort()` with one parameter, namely `sort(List)`,
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: Line 113 generates a `List<Integer>` using the `Arrays.asList()` method. Lines
    114 and 115 execute and output the lambda version.
  prefs: []
  type: TYPE_NORMAL
- en: Line 117 re-generates a `List<Integer>`, again using the `Arrays.asList()` method.
    Lines 118 and 119 execute and output the method reference version.
  prefs: []
  type: TYPE_NORMAL
- en: Our last method reference type is constructor method references. Let’s discuss
    them now.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor method references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constructor method references are a special type of method reference in that,
    rather than calling a (regular) method, the `new` keyword is used and an object
    is instantiated. Suppliers are a natural fit for constructor method references.
    *Figure 14**.14* presents an example in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14 – Constructor method reference example](img/B19793_14_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.14 – Constructor method reference example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 75 defines a `Supplier<StringBuilder>` lambda. The `Supplier`
    lambda’s functional method is `T get()`, so we do not pass anything in. As we
    typed `sbL` for `StringBuilder`, the lambda code is `new StringBuilder()`. As
    we have only one method invocation in the lambda, a method reference version can
    be coded.
  prefs: []
  type: TYPE_NORMAL
- en: The method reference on line 76 is the constructor method reference equivalent
    of the lambda defined on line 75\. Note the use of the `new` keyword after the
    `::` operator in the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 77 and 78 invoke the lambda and method references, respectively. In addition,
    the `StringBuilder` objects that were created are populated and output.
  prefs: []
  type: TYPE_NORMAL
- en: As stated already, `Supplier` is a perfect fit for constructor method references.
    But what if you wanted to pass an argument in? Suppliers do not accept parameters
    (`T get()`). We need a functional interface that will accept a parameter and return
    a result. `Function` will do nicely for this use case.
  prefs: []
  type: TYPE_NORMAL
- en: The second example in *Figure 14**.14* presents a `Function`-based constructor
    method reference. The `ArrayList` constructor is overloaded – one of the versions
    accepts an `int` type, which is used to specify the initial capacity.
  prefs: []
  type: TYPE_NORMAL
- en: Line 84 defines a `Function`-based lambda, which accepts an `Integer` type and
    returns a `List<String>` list. The lambda takes an `Integer` type, `x`, and constructs
    an `ArrayList` with an initial capacity of `x`. The value of `x` will be obtained
    from the lambda invocation (for example, 100 on line 86).
  prefs: []
  type: TYPE_NORMAL
- en: As we have only one method call in the lambda and as `x` is replicated on both
    sides of the `->` token (redundancy), we can write an equivalent method reference.
  prefs: []
  type: TYPE_NORMAL
- en: Line 85 is the method reference equivalent of the lambda that was coded on line
    84\. `ArrayList` is specified to indicate which implementation of `List` we want
    to return. The `::new` syntax is unique to constructor method references. Line
    89 shows how the method reference is executed – invoke the `apply()` method while
    passing in 200 in this example.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our discussion on the four different types of method references.
    However, before we leave method references, we would like to discuss an example
    outlining just how important context is when trying to understand method references.
  prefs: []
  type: TYPE_NORMAL
- en: Method references and context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example will present three lambdas with their corresponding method references.
    *Figure 14**.15* shows the code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.15 – Method references and context](img/B19793_14_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.15 – Method references and context
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, lines 7-11 define a class called `Person`. Line 8 defines a
    `static` `howMany()` method that returns the number of objects in the `Person`
    array. Recall that `varargs` is represented by `…` and within the method, it is
    treated as an array (hence the `length` property). Given that the `people` parameter
    is a `varargs` parameter, we can invoke `howMany()` with 0 or more arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The first scenario is calling `howMany()` with no `Person` object at all and
    getting back the count of objects passed, which will be 0\. `Supplier` fits nicely
    as we will not be passing anything into the lambda, but will be getting back an
    `Integer` result. Line 15 is the lambda for this scenario. We accept in nothing
    and return an `Integer` count, which is the count of the number of `Person` objects
    passed to `howMany()`. This is, of course, `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 16 is the method reference equivalent for the lambda on line 15\. We will
    return to discuss this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The second scenario is calling `howMany()` with one `Person` object and getting
    back the count of objects passed, which will be `1`. `Function` fits nicely as
    we will be passing in one `Person` object to the lambda and receiving the `Integer`
    count. Line 21 is the lambda for this scenario. We accept one `Person` and return
    an `Integer`, representing the number of `Person` objects passed to `howMany()`.
    This is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 22 is the method reference equivalent for the lambda on line 21\. Again,
    we will return to discuss this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The third scenario is calling `howMany()` with two `Person` objects and getting
    back the count of objects passed, which will be `2`. `BiFunction` fits nicely
    as we will be passing in two `Person` objects to the lambda and receiving the
    `Integer` count. Line 27 is the lambda for this scenario. We accept two `Person`
    objects and return an `Integer` representing the number of `Person` objects passed
    to `howMany()`. This is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 28 is the method reference equivalent for the lambda on line 27.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s discuss the method references (lines 16, 22, and 28). Notice how
    they are all the same! Again, this is where context is key. The compiler can generate
    the relevant lambdas based on the functional interfaces and the generic types
    specified. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, as `howMany()` is a `static` method in `Person`, the compiler knows
    that the lambda will be `Person.howMany()`. But how many objects should be passed?
    As it is a `Supplier` interface, whose functional method is `T get()`, the compiler
    knows there will be no parameter input, so it knows to pass nothing to `howMany()`.
    Concerning what to return, `Supplier` is typed for `Integer`, which matches the
    return type for `howMany()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to pass one object to `howMany()`? Let’s examine the second
    method reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The one difference here is that we are declaring a `Function` as opposed to
    the previous `Supplier`. `Function`s take in one parameter and return a result.
    We know `Integer` must be the return type, as that is the return type of `howMany()`.
    So, what the compiler does here is take the input and pass it to the `howMany()`
    method. The equivalent lambda (line 21) shows what is happening in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, what if we want to pass in two objects to `howMany()`? The last method
    reference demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The compiler sees `BiFunction` and realizes that `BiFunction` requires two inputs,
    so it will pass the two inputs to `howMany()`. And of course, this particular
    `BiFunction` return type of `Integer` matches the return type of the method `howMany()`.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have three equivalent method references that map to three different lambdas
    because of the three different contexts. Method references can be tricky. Check
    the context and if possible, map the method reference to its equivalent lambda
    expression. Once in lambda form, it is easier to interpret.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on method references and concludes [*Chapter 14*](B19793_14.xhtml#_idTextAnchor355).
    Now, let’s put that knowledge into practice to reinforce the concepts we’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dinosaur care tasks are often very similar, but not identical. To make our code
    cleaner, we can use lambda expressions. Create a custom functional interface called
    `DinosaurHandler` with a method called `handle(Dinosaur dinosaur)`. Implement
    it in a lambda expression that sets a dinosaur to be asleep or awake (first, add
    a property to your `Dinosaur` class if needed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lambda expressions are extremely useful with the `java.util.function` interfaces.
    Let’s use them to manage dinosaurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `Predicate<Dinosaur>` lambda that checks if a dinosaur is a carnivore
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `Supplier<Dinosaur>` lambda that returns a new dinosaur
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `Consumer<Dinosaur>` lambda that prints a dinosaur’s name
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `Function<Dinosaur, String>` lambda that returns a dinosaur’s diet
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions have specific rules about variable usage. We’re going to
    create an example of a lambda expression that modifies an “effectively final”
    variable. Add a variable that tracks the number of dinosaurs and create a lambda
    expression that increases this count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Method references can make our code more readable. Write examples of using
    method references in the context of your park:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`System.out::println` to print dinosaur names.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dinosaur::getName` (assume the `Dinosaur` class has a `getName()` method)
    to get the name of each dinosaur.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collections::sort` to sort a list of dinosaur names.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dinosaur::new` to create a new dinosaur (assume the `Dinosaur` class has an
    appropriate constructor)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Project – agile dinosaur care system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our park is growing, and so are the tasks that need to be accomplished. Lambda
    expressions can simplify our code and improve the efficiency of operations. Let’s
    integrate them into our system!
  prefs: []
  type: TYPE_NORMAL
- en: Incorporate lambda expressions into your “dinosaur care system” for sorting,
    filtering, and performing actions on collections of dinosaurs. Furthermore, design
    a notification system using method references to alert park staff about various
    events, enhancing communication and responsiveness within our park.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps. We assume certain methods exist. You’ll have to create
    those methods according to your `Dinosaur` class’s design:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` class defined with properties such as `name`, `species`, `healthStatus`,
    and so on. You’ll also want to have a `DinosaurCareSystem` class where the main
    functionalities of handling dinosaurs are implemented.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Dinosaur` objects and you want to sort them by their name. Use the `sort`
    method of the `List` interface with a lambda expression. Here’s an example: `dinosaurs.sort((d1,
    d2) >` `d1.getName().compareTo(d2.getName()))`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`List<Dinosaur> illDinosaurs = dinosaurs.stream().filter(d >` `d.isIll()).collect(Collectors.toList())`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DinosaurCareSystem` class, create a method called `sendNotification(String
    message)`. Then in another method where you are checking dinosaur health status,
    for example, use a method reference to call `sendNotification` each time a dinosaur
    is found to be ill. The code may look something like this: `dinosaurs.stream().filter(Dinosaur::isIll).forEach(d
    > sendNotification(d.getName() + "` `is ill."))`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`healthboosting` program. With lambdas, you can do this directly on the list:
    `dinosaurs.forEach(d >` `d.increaseHealth(10))`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that lambda expressions make your code more concise.
    We saw that a functional interface is an interface with just one `abstract` method.
    Lambda expressions are classes that implement functional interfaces with everything
    but the bare minimum remaining.
  prefs: []
  type: TYPE_NORMAL
- en: The terms `final` and “effectively final” refer to local variables used inside
    lambda expressions. Any non-`final` local variable used by a lambda must not change
    its value, either in the method or the lambda itself. The compiler enforces this,
    thus making the local variable “effectively final.” This is to ensure that the
    method’s view of the local variables value is consistent with the lambda’s view
    (of the local variable’s value). This does not apply to instance or `static` variables
    or local variables *not* used inside lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: We took a deep dive into functional interfaces from the API. We examined predicates
    (which test a condition), such as `Predicate<T>` and `BiPredicate<T, U>`, plus
    their primitive consuming counterparts, `DoublePredicate`, `IntPredicate`, and
    `LongPredicate`.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined `Supplier<T>` (which gives you something) and its primitive
    consuming specializations, which are `BooleanSupplier`, `DoubleSupplier`, `IntSupplier`,
    and `LongSupplier`.
  prefs: []
  type: TYPE_NORMAL
- en: We explored consumers (which take but do not give back), `Consumer<T>` and `BiConsumer<T,
    U>`, and their primitive consuming specializations, `DoubleConsumer`, `IntConsumer`,
    and `LongConsumer`.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at functions (which both take and give back), `Function<T, R>`
    and `BiFunction<T, U, R>`, and their primitive consuming counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we examined variations of functions. `UnaryOperator<T>` is a variation
    of `Function`, where both the input and output types are the same. Similarly,
    `BinaryOperator<T>` is a variation of `BiFunction`, where the two input types
    and the output type are all the same.
  prefs: []
  type: TYPE_NORMAL
- en: To make your code even more concise, in certain situations, you can use method
    references instead of lambda expressions. If your lambda is just invoking one
    method and there is redundancy concerning parameters, a method reference can be
    written.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four different types of method references: bound, unbound, static,
    and constructor. A bound method reference is bound to an existing variable in
    the method, outside of the lambda’s scope. An unbound method reference relies
    on the instance to be passed at runtime. A static method reference is also considered
    unbound and executes a `static` method. Lastly, a constructor method reference
    creates objects using the `::``new` syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: We also had a look at the importance of context in understanding method references.
    We saw an example where the same method reference was generating three different
    lambdas (in the background) due to the three different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on lambda expressions. They will be very important
    as we move on to our next two Stream-related chapters.
  prefs: []
  type: TYPE_NORMAL
