<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer082">
			</div>
		</div>
		<div class="Content" id="_idContainer083">
			<h1 id="_idParaDest-225"><a id="_idTextAnchor229"/>10. Encryption</h1>
		</div>
		<div class="Content" id="_idContainer085">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter discusses Java's support for encryption. It does this first, by defining symmetric and asymmetric key encryption, then teaching you to implement those encryptions <strong class="bold">Advanced Encryption Standard</strong> (<strong class="bold">AES</strong>) and <strong class="bold">Rivest-Shamir-Adleman</strong> (<strong class="bold">RSA</strong>), respectively. You will further learn to differentiate between block and stream ciphers, so that you may utilize them appropriately when encrypting your files.<a id="_idTextAnchor230"/></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor231"/>Introduction</h1>
			<p>Encryption is the process of scrambling data so that it can be sent in plain sight between two or more parties without anyone else being able to understand what was sent. Today, almost everything you do online is encrypted—be it reading an email, sending a photo to a popular social network, or downloading source code. Most serious websites today are also encrypted. Applying encryption to your software is vital for safeguarding your integrity, data, and business, as well as that of your customer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Encryption is a very complicated topic that gets more complex every year as we try to safeguard our applications from new malicious code and individuals. This chapter will not go into detail about how encryption should be implemented in software. Instead, we will explain how you can use the APIs that are available within Java.</p>
			<p>In Java, we have a collection of classes and interfaces that have been specifically created for handling most security-related cases on the Java platform—they're all gathered in what is called the <strong class="bold">Java Cryptography Architecture</strong> (<strong class="bold">JCA</strong>). Within the JCA lies the foundation for building secure applications in Java. Several other secure libraries within Java use the JCA to implement their security. With the JCA, you can either create your own custom security providers or use the already available standard providers. In most cases, using the standard providers is enough.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor232"/>Plaintext</h2>
			<p>In cryptographic terms, plaintext means the data that you wish to encrypt. Cleartext is another popular term that is used interchangeably with plaintext depending on who you ask.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor233"/>Ciphertext</h2>
			<p>This is the encrypted version of plaintext. This is the data that is safe to send to the receiving party.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor234"/>Ciphers</h2>
			<p>A cipher is a mathematical function, or algorithm, that is used to encrypt plaintext data into ciphertext. However, a cipher is not enough to create ciphertext from plaintext – you also require a key that defines the unique way your encryption will work. All keys are generated uniquely. Depending on the type of cipher you make, you'll have one or two keys to encrypt and decrypt your data.</p>
			<p>To initialize a cipher in Java, you'll need to know three things about it: the algorithm used, the mode, and the type of padding. Different ciphers work in different ways, so defining the correct transformation is critical to avoid causing exceptions or creating insecure applications:</p>
			<p class="source-code">Cipher cipher = Cipher.getInstance(&lt;transformation&gt;);</p>
			<p class="source-code">cipher.init(Cipher.ENCRYPT_MODE, &lt;key&gt;);</p>
			<p>The algorithms or ciphers are kept in what we call cryptographic providers (or just providers). Depending on the system in which the application is running, you may not have access to all kinds of ciphers out of the box. In some cases, you may even have to install additional providers to access the cipher you wish you use.</p>
			<p>However, every <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) does come with a set of available ciphers with different transformations. At the very least, you'll always find the following transformations available on any JVM today:</p>
			<ul>
				<li>AES/CBC/NoPadding</li>
				<li>AES/CBC/PKCS5Padding</li>
				<li>AES/ECB/NoPadding</li>
				<li>AES/ECB/PKCS5Padding</li>
				<li>AES/GCM/NoPadding</li>
				<li>DES/CBC/NoPadding</li>
				<li>DES/CBC/PKCS5Padding</li>
				<li>DES/ECB/NoPadding</li>
				<li>DES/ECB/PKCS5Padding</li>
				<li>DESede/CBC/NoPadding</li>
				<li>DESede/CBC/PKCS5Padding</li>
				<li>DESede/ECB/NoPadding</li>
				<li>DESede/ECB/PKCS5Padding</li>
				<li>RSA/ECB/PKCS1Padding</li>
				<li>RSA/ECB/OAEPWithSHA-1AndMGF1Padding</li>
				<li>RSA/ECB/OAEPWithSHA-256AndMGF1Padding</li>
			</ul>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor235"/>Keys</h2>
			<p>Every cipher requires at least one key to encrypt the plaintext and decrypt the ciphertext. Depending on the type of cipher, the key can be either symmetric or asymmetric. Usually, you'll work with keys stored in non-volatile memory, but you can also generate keys from code. In the JCA, there is a simple command that is used to generate a key for a specific cipher:</p>
			<p class="source-code">KeyPair keyPair = KeyPairGenerator.getInstance(algorithm).generateKeyPair();</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor236"/>Symmetric Key Encryption</h1>
			<p>Symmetric encryption is usually considered less safe than asymmetric encryption. This is not because the algorithms are less secure than asymmetric encryption, but because the key that is used to unlock the content must be shared by more than one party. The following diagram illustrates how symmetric encryption works, in general terms.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer084">
					<img alt="Figure 10.1: Symmetric encryption" src="image/C13927_10_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1: Symmetric encryption</p>
			<p>You can create keys for symmetric encryption in this way:</p>
			<p class="source-code">Key key = KeyGenerator.getInstance(&lt;algorithm&gt;).generateKey();</p>
			<p>One of the most popular symmetric encryption methods today is the <strong class="bold">Advanced Encryption Standard</strong> (<strong class="bold">AES</strong>). </p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor237"/>Exercise 1: Encrypting the String Using Advanced Encryption Standard</h2>
			<p>In this exercise, we will encrypt the "<strong class="source-inline">My secret message</strong>" string using AES:</p>
			<ol>
				<li>If IntelliJ is already started but no project is open, then select <strong class="source-inline">Create New Project</strong>. If IntelliJ already has a project opened, then select <strong class="source-inline">File</strong> -&gt;<strong class="source-inline"> New</strong> -&gt; <strong class="source-inline">Project</strong> from the menu.</li>
				<li>In <strong class="source-inline">New Project Dialog</strong>, select a Java project. Click on <strong class="source-inline">Next</strong>.</li>
				<li>Check the box to create the project from a template. Select <strong class="source-inline">Command Line App</strong>. Then, click on <strong class="source-inline">Next</strong>.</li>
				<li>Give the new project the name <strong class="source-inline">Chapter10</strong>.</li>
				<li>IntelliJ will give you a default project location; if you wish to select your own, you can enter it here.</li>
				<li>Set the package name to <strong class="source-inline">com.packt.java.chapter10</strong>.</li>
				<li>Click on <strong class="source-inline">Finish</strong>. IntelliJ will create your project called <strong class="source-inline">Chapter10</strong> with the standard folder structure. IntelliJ will also create the main entry point for your application, called <strong class="source-inline">Main.java</strong>. </li>
				<li>Rename this file to <strong class="source-inline">Exercise1.java</strong>. When you're done, it should look like this:<p class="source-code">package com.packt.java.chapter10;</p><p class="source-code">  </p><p class="source-code">public class Exercise1 {</p><p class="source-code">  </p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    // write your code here</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Decide on the algorithm that you want to use for your encryption – in this example, we're using AES –then, generate the key for the encryption. Generating the key may cause an exception if the selected algorithm isn't supported by any of the providers on the system:<p class="source-code">package com.packt.java.chapter10;</p><p class="source-code">  </p><p class="source-code">import javax.crypto.KeyGenerator;</p><p class="source-code">import java.security.Key;</p><p class="source-code">import java.security.NoSuchAlgorithmException;</p><p class="source-code">  </p><p class="source-code">public class Exercise1{</p><p class="source-code">  </p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        try {</p><p class="source-code">            String algorithm = "AES";</p><p class="source-code">            Key privateKey = KeyGenerator.getInstance(algorithm)              .generateKey();</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">In this exercise, we're using a variable to store the key. However, in most real-life scenarios, you'll likely use a less volatile form of storage—such as a file or database.</p></li>
				<li>The next step is to define the actual encryption transformation to use. As mentioned previously, the transformation contains information about how to handle the cipher. In this case, we're using AES, which is a block cipher, so we need to define how to apply the key to each block of the plaintext data. Additionally, we need to define whether there should be any padding, and what that padding should look like:<p class="source-code">package com.packt.java.chapter10;</p><p class="source-code">  </p><p class="source-code">import javax.crypto.KeyGenerator;</p><p class="source-code">import java.security.Key;</p><p class="source-code">import java.security.NoSuchAlgorithmException;</p><p class="source-code">  </p><p class="source-code">public class Exercise1 {</p><p class="source-code">  </p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        try {</p><p class="source-code">            String algorithm = "AES";</p><p class="source-code">            Key privateKey = KeyGenerator.getInstance                           (algorithm).generateKey();</p><p class="source-code">            String transformation = algorithm + "/ECB/NoPadding";</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p>We already chose AES as the algorithm, so we're starting the transformation with that. Following this, we've decided to go for the less-safe <strong class="bold">Electronic Code Book</strong> (<strong class="bold">ECB</strong>) transformation mode, which means we're applying the key in the same way for each block of plaintext data. Finally, we've defined that we'll use no padding if a block in the plaintext data is shorter than the cipher block length.</p></li>
				<li>Query the system for the cipher with the suggested transformation. This method can throw both <strong class="source-inline">NoSuchAlgorithmException</strong> and <strong class="source-inline">NoSuchPaddingException.</strong> Make sure to handle this if that is the case:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        try {</p><p class="source-code">            String algorithm = "AES";</p><p class="source-code">            Key privateKey = KeyGenerator.getInstance(algorithm)              .generateKey();</p><p class="source-code">            String transformation = algorithm + "/ECB/NoPadding";</p><p class="source-code">            Cipher cipher = Cipher.getInstance(transformation);</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (NoSuchPaddingException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Encrypting and decrypting is almost identical when compared to the Java API. When encrypting a plaintext file, you initiate the cipher in encryption mode, and when decrypting a ciphertext file, you initiate the cipher in decryption mode. This may cause <strong class="source-inline">InvalidKeyException</strong> if the key is wrong:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        try {</p><p class="source-code">            String algorithm = "AES";</p><p class="source-code">            Key privateKey = KeyGenerator.getInstance(algorithm)              .generateKey();</p><p class="source-code">            String transformation = algorithm + "/ECB/NoPadding";</p><p class="source-code">            Cipher cipher = Cipher.getInstance(transformation);</p><p class="source-code">            cipher.init(Cipher.ENCRYPT_MODE, privateKey);</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (NoSuchPaddingException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (InvalidKeyException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>In fact, encrypting your text is a two-step process, and you always need to adjust your work depending on the actual bytes of the data. Since we're working on a <strong class="source-inline">String</strong>, you will need to get the actual bytes of this <strong class="source-inline">String</strong>:<p class="source-code-heading">Exercise1.java</p><p class="source-code">1 package com.packt.java.chapter10;</p><p class="source-code">2 </p><p class="source-code">3 import javax.crypto.*;</p><p class="source-code">4 import java.security.InvalidKeyException;</p><p class="source-code">5 import java.security.Key;</p><p class="source-code">6 import java.security.NoSuchAlgorithmException;</p><p class="source-code">7 </p><p class="source-code">8 public class Exercise1 {</p><p class="source-code">9 </p><p class="source-code">10     public static void main(String[] args) {</p><p class="source-code">11         try {</p><p class="source-code">12         String algorithm = "AES";</p><p class="source-code">13         Key privateKey = KeyGenerator.getInstance(algorithm)             .generateKey();</p><p class="source-code">14         String transformation = algorithm + "/ECB/PKCS5Padding";</p><p class="source-code">15         Cipher cipher = Cipher.getInstance(transformation);</p><p class="source-code">16         cipher.init(Cipher.ENCRYPT_MODE, privateKey);</p><p class="source-code-link"><a href="https://packt.live/32veWeE">https://packt.live/32veWeE</a></p><p>As you may have noticed, there are a lot of things that could go wrong when working with encryption. Usually, you should handle these exceptions gracefully, but in this case, we'll just print them.</p></li>
				<li>Now, the last thing to do is print the encrypted version of the text to verify that you've encrypted the data. You should see gibberish in the terminal. That's fine; it just means you've succeeded in hiding the plaintext message in a ciphertext file:<p>What happens if you change the transformation padding to <strong class="source-inline">NoPadding</strong>?</p><p>What happens if you keep the <strong class="source-inline">PKCS5Padding</strong> but change the plaintext message to "<strong class="source-inline">This is 16 bytes</strong>"?</p><p>Try to decrypt the message by instead initializing the cipher to <strong class="source-inline">MODE_DECRYPT</strong>, and then passing the ciphertext rather than the plaintext message. Remember, you need to use the same key for this process to work; otherwise, you'll see gibberish again.</p></li>
			</ol>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor238"/>Block Ciphers</h1>
			<p>AES is a block cipher, meaning that encryption is handled on one block of plaintext at a time. A block size depends on the key size; that is, a larger key means a larger block.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor239"/>Initialization Vectors</h2>
			<p>Some of the transformation modes for block ciphers require you to work with an initialization vector – it's an improvement that handles the obvious repeat pattern of the ECB mode. This is easily visualized by an image showing the difference in encryption using AES/ECB and AES/CBC. </p>
			<p>CBC refers to <strong class="bold">Cipher Block Chaining</strong> and, in short, it scrambles the current block of data based on the previous block of data. Or, if it was the first block, it scrambles the data based on the initialization vector.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor240"/>Stream Ciphers</h2>
			<p>A stream cipher, on the other hand, works by encrypting each byte at a time. There is a theoretical discussion about what is known as "the one-time pad," which represents the ideal stream encryption. These are, in theory, extremely secure, but are also very impractical, as the key must be the same length as the plaintext data. With large plaintext data, such keys are impossible to use.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor241"/>Asymmetric Key Encryption</h1>
			<p>In asymmetric key encryption, the private key is held by one party only—the receiver or owner of the data. The sender of the data, who is not considered the owner, uses what we call a public key to encrypt the data. The public key can be held by anyone without jeopardizing any previously encrypted messages. This is considered a more secure way of handling encryption, as only the receiver can decrypt the message.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor242"/>Exercise 2: Encrypting the String Using the RSA Asymmetric Key Encryption</h2>
			<p>Encrypt the "<strong class="source-inline">My secret message</strong>" message using the <strong class="bold">Rivest–Shamir–Adleman</strong> (<strong class="bold">RSA</strong>) asymmetric key encryption. This is a public/private key combination:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Chapter10</strong> project in IDEA if it's not already open.</li>
				<li>Create a new Java class using the <strong class="source-inline">File -&gt; New -&gt; Java Class</strong> menu.</li>
				<li>Enter <strong class="source-inline">Exercise2</strong> as <strong class="source-inline">Name</strong>, and then select <strong class="source-inline">OK</strong>. You should now have an empty class in your project:<p class="source-code">package com.packt.java.chapter10;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">main</strong> method—you'll write all your code in that for this exercise:<p class="source-code">package com.packt.java.chapter10;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Declare a plaintext <strong class="source-inline">String</strong> with the content "<strong class="source-inline">My secret message</strong>":<p class="source-code">package com.packt.java.chapter10;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        String plaintext = "My secret message";</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add another string "RSA" in which you'll write the algorithm for this exercise:<p class="source-code">package com.packt.java.chapter10;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        String plaintext = "My secret message";</p><p class="source-code">        String algorithm = "RSA";</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Because RSA is an asymmetric form of key encryption, you need to generate a key pair instead of a key. Catch the exception if the algorithm is not found:<p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        try {</p><p class="source-code">            String plaintext = "My secret message";</p><p class="source-code">            String algorithm = "RSA";</p><p class="source-code">            KeyPair keyPair = KeyPairGenerator.getInstance(algorithm)              .generateKeyPair();</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">             e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Define the transformation; we'll go with electronic code block and <strong class="source-inline">PKCS1Padding</strong> for this exercise:<p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        try{</p><p class="source-code">            String plaintext = "My secret message";</p><p class="source-code">            String algorithm = "RSA";</p><p class="source-code">            KeyPair keyPair = KeyPairGenerator.getInstance(algorithm)              .generateKeyPair();</p><p class="source-code">            String transformation = algorithm + "/ECB/PKCS1Padding";</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create a cipher for the algorithm and initialize it with the chosen transformation. Remember to always use the public key when encrypting with RSA:<p class="source-code">        try{</p><p class="source-code">            String plaintext = "My secret message";</p><p class="source-code">            String algorithm = "RSA";</p><p class="source-code">            KeyPair keyPair = KeyPairGenerator.getInstance(algorithm)              .generateKeyPair();</p><p class="source-code">            String transformation = algorithm + "/ECB/PKCS1Padding";</p><p class="source-code">            Cipher cipher = Cipher.getInstance(transformation);</p><p class="source-code">            cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (NoSuchPaddingException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (InvalidKeyException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Finally, encrypt the plaintext into ciphertext, you'll notice that the ciphertext is much larger when using RSA than AES. This is because of the key size.</li>
			</ol>
			<p class="source-code-heading">Exercise2.java</p>
			<p class="source-code">1  package com.packt.java.chapter10;</p>
			<p class="source-code">2  </p>
			<p class="source-code">3  import javax.crypto.*;</p>
			<p class="source-code">4  import java.security.InvalidKeyException;</p>
			<p class="source-code">5  import java.security.KeyPair;</p>
			<p class="source-code">6  import java.security.KeyPairGenerator;</p>
			<p class="source-code">7  import java.security.NoSuchAlgorithmException;</p>
			<p class="source-code">8  </p>
			<p class="source-code">9  public class Exercise2 {</p>
			<p class="source-code">10 </p>
			<p class="source-code">11     public static void main(String[] args) {</p>
			<p class="source-code">12         try {</p>
			<p class="source-code">13             String plaintext = "My secret message";</p>
			<p class="source-code">14             String algorithm = "RSA";</p>
			<p class="source-code">15             KeyPair keyPair = KeyPairGenerator.getInstance(algorithm)              .generateKeyPair();</p>
			<p class="source-code">16             String transformation = algorithm + "/ECB/PKCS1Padding";</p>
			<p class="source-code">17             Cipher cipher = Cipher.getInstance(transformation);</p>
			<p class="source-code">18             cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());</p>
			<p class="source-code-link"><a href="https://packt.live/2MvdL9x">https://packt.live/2MvdL9x</a></p>
			<p>You can also use the decrypt logic for RSA. Remember to use the private key when decrypting; otherwise, it will not work.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor243"/>Encrypting Files</h1>
			<p>Encrypting files is very much like encrypting strings. However, with large files, it may be wise to empty the cipher streams. However, if the file is too large, or if there are multiple files, then it may be wise to apply <strong class="source-inline">CipherStreams</strong>—not to be confused with Stream Cipher.</p>
			<p><strong class="source-inline">CipherStreams</strong> inherit most of their behavior from <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong> of Java, with the modification that you can decrypt a file you read, or encrypt a file you write with the supplied cipher.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor244"/>Exercise 3: Encrypting a File</h2>
			<p>The following exercise displays how to encrypt a file. You can find this file in the code repository.</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Chapter10</strong> project in IDEA if it's not already open.</li>
				<li>Create a new Java class, using the <strong class="source-inline">File</strong> | <strong class="source-inline">New</strong> | <strong class="source-inline">Java Class</strong> menu.</li>
				<li>Enter <strong class="source-inline">Exercise3</strong> as Name, and then select <strong class="source-inline">OK</strong>. You should now have an empty class in your project:<p class="source-code">package com.packt.java.chapter10;</p><p class="source-code">public class Exercise3 {</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">main</strong> method in which you'll write the code for this exercise:<p class="source-code">package com.packt.java.chapter10;</p><p class="source-code">  </p><p class="source-code">public class Exercise3 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Define the algorithm to use for your encryption; we'll go back to AES for this exercise and generate the key:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        try {</p><p class="source-code">            String algorithm = "AES";</p><p class="source-code">            Key secretKey = KeyGenerator.getInstance(algorithm)              .generateKey();</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Get an instance of the cipher and initialize it for encryption:<p class="source-code">        try{</p><p class="source-code">            String algorithm = "AES";</p><p class="source-code">            Key secretKey = KeyGenerator.getInstance(algorithm)              .generateKey();</p><p class="source-code">            String transformation = algorithm + "/CBC/NoPadding";</p><p class="source-code">            Cipher cipher = Cipher.getInstance(transformation);</p><p class="source-code">            cipher.init(Cipher.ENCRYPT_MODE, secretKey);</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (NoSuchPaddingException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (InvalidKeyException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Create a file for the encryption; you can download the <strong class="source-inline">plaintext.txt</strong> file from the book's GitHub repository if you wish. Alternatively, you can just create your own text file using lipsum—or even better, copy a document from your computer. We're placing these files in the "<strong class="source-inline">res</strong>" folder of your project:<p class="source-code">        try {</p><p class="source-code">            String algorithm = "AES";</p><p class="source-code">            Key secretKey = KeyGenerator.getInstance(algorithm)              .generateKey();</p><p class="source-code">            String transformation = algorithm + "/CBC/NoPadding";</p><p class="source-code">            Cipher cipher = Cipher.getInstance(transformation);</p><p class="source-code">            cipher.init(Cipher.ENCRYPT_MODE, secretKey);</p><p class="source-code">            Path pathToFile = Path.of("res/plaintext.txt");</p><p class="source-code">            File plaintext = pathToFile.toFile();</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (NoSuchPaddingException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }catch (InvalidKeyException e){</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>In addition to this, create a file that will hold the encrypted contents. Make sure the file doesn't already exist:<p class="source-code">            File ciphertext = Path.of("res/ciphertext.txt").toFile();</p><p class="source-code">            if (ciphertext.exists()) {</p><p class="source-code">                ciphertext.delete();</p><p class="source-code">            }</p><p class="source-code">        } catch (NoSuchAlgorithmException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (NoSuchPaddingException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } catch (InvalidKeyException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p></li>
				<li>Now it's time to add the cipher streams. In this instance, we need <strong class="source-inline">FileInputStream</strong> to read the contents of the <strong class="source-inline">plaintext.txt</strong> file, <strong class="source-inline">FileOutputStream</strong> to write an initialization vector, and <strong class="source-inline">CipherOutputStream</strong> to perform the encryption:<p class="source-code">            try (FileInputStream fileInputStream = new               FileInputStream(plaintext);</p><p class="source-code">                FileOutputStream fileOutputStream = new                   FileOutputStream(ciphertext);</p><p class="source-code">                CipherOutputStream cipherOutputStream = new                   CipherOutputStream(fileOutputStream, cipher)); {</p><p class="source-code">}</p><p class="source-code">            } catch (NoSuchAlgorithmException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            } catch (NoSuchPaddingException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            } catch (InvalidKeyException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            } catch (FileNotFoundException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            } catch (IOException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Write the initialization vector; you will find it in the initialized cipher. Make sure to use <strong class="source-inline">FileOutputStream</strong> as we do not want to encrypt these bytes:<p class="source-code">            try (FileInputStream fileInputStream = new               FileInputStream(plaintext);</p><p class="source-code">                FileOutputStream fileOutputStream = new                   FileOutputStream(ciphertext);</p><p class="source-code">                CipherOutputStream cipherOutputStream =                   new CipherOutputStream(fileOutputStream,  cipher))  {</p><p class="source-code">                fileOutputStream.write(cipher.getIV());</p><p class="source-code">}</p><p class="source-code">            } catch (NoSuchAlgorithmException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            } catch (NoSuchPaddingException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            } catch (InvalidKeyException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            } catch (FileNotFoundException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            } catch (IOException e) {</p><p class="source-code">                e.printStackTrace();</p><p class="source-code">            }</p><p class="source-code">        }</p></li>
				<li>Finally, write the contents of <strong class="source-inline">FileInputStream</strong> to <strong class="source-inline">CipherOutputStream</strong>, allowing the contents to be encrypted in the process:<p class="source-code-heading">Exercise3.java</p><p class="source-code">1  package com.packt.java.chapter10;</p><p class="source-code">2  </p><p class="source-code">3  import javax.crypto.Cipher;</p><p class="source-code">4  import javax.crypto.CipherOutputStream;</p><p class="source-code">5  import javax.crypto.KeyGenerator;</p><p class="source-code">6  import javax.crypto.NoSuchPaddingException;</p><p class="source-code">7  import java.io.*;</p><p class="source-code">8  import java.nio.file.Path;</p><p class="source-code">9  import java.security.InvalidKeyException;</p><p class="source-code">10 import java.security.Key;</p><p class="source-code">11 import java.security.NoSuchAlgorithmException;</p><p class="source-code">12 </p><p class="source-code">13 public class Exercise3 {</p><p class="source-code">14 </p><p class="source-code">15     public static void main(String[] args) {</p><p class="source-code-link"><a href="https://packt.live/2J4nKjI">https://packt.live/2J4nKjI</a></p><p>There are numerous ways of working with files in Java, and this is just one way of encrypting the contents. If you have larger files, perhaps <strong class="source-inline">BufferedReader</strong> would be a good option to use.</p></li>
				<li>Instead of encrypting a file, use the cipher streams to encrypt a whole folder. Perhaps the best practice here is to first compress the folder into a ZIP archive and then encrypt that file.</li>
			</ol>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor245"/>Summary</h1>
			<p>The JCA contains everything you need to work with encryption. In this chapter, you've only really scratched the surface of this major framework. This is just enough to get you started, but if you intend to progress further into the complexities of this framework, you will first need to develop a greater understanding of cryptography.</p>
			<p>In the next chapter, we will cover the launching of processes, as well as sending input and capturing the output of child processes.</p>
		</div>
		<div class="Basic-Text-Frame" id="_idContainer086">
			<p>XRB39</p>
		</div>
	</body></html>