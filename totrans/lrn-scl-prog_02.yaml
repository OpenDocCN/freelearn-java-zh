- en: Understanding Types in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strong type system is one of the most important parts of the Scala language.
    Like a double-edged sword, it helps the compiler to verify and optimize the code
    on one side, while at the same time guiding developers toward possible correct
    implementations and preventing them from making programming mistakes on another
    side. As with any sharp tool, it requires some skill so that it can be used for
    carving beautiful source code without cutting the user in the process.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will improve this skill by recapping and summarizing basic
    type-related knowledge, taking a look at a new type that was introduced in Scala
    2.13, and finally looking at some advanced usages of types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Different ways to create a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different ways to parameterize a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kinds of types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using types to express domain constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, make sure you have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available under our GitHub repository at: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02)[.](https://github.com/PacktPublishing/Learn-Scala---Fundamentals-of-Scala-2.13/ch02)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type of something is a summation of the information the compiler owns about
    this *something*. In the most general case, we're talking about the type of a
    variable; the knowledge of the compiler includes the methods that are available
    on this variable and the classes that the variable extends. A very convenient
    feature of Scala is that it tries to use type inference where possible, freeing
    the developer from the need to define types explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a structured look at Scala's type system, starting with a short recap
    of its basics.
  prefs: []
  type: TYPE_NORMAL
- en: Ways to create a type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four ways to define a type in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: By using a literal to define a singleton type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the type keyword to define an alias for an abstract or concrete type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By defining a class, object, or trait to create a concrete type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By defining a method that creates a method type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Singleton types were introduced in Scala 2.13, and we''ll look at them in detail
    later in this chapter. For now, let''s try to define and refer to some concrete
    types in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The type can be referred before it is fully defined, as shown by the example
    of `SomeTrait`.
  prefs: []
  type: TYPE_NORMAL
- en: When annotating types, traits and classes can be used directly, but the type
    of an object needs to be referenced by using its `type` operator. The `a.type` form
    in Scala describes a *singleton type*. Depending upon whether `p` conforms to `scala.AnyRef`,
    it denotes either a set of values, `[a, null]`, or just an `a`. As we usually
    don't use `null` in Scala programs, we can say that `a.type `denotes a type containing
    a single element, `a`. Normally, it is not used in *regular *code because it is
    easier to reference an object directly than to pass it as a parameter, but this
    style has found its use in some advanced libraries to implement parts of the internal
    DSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Scala 2.13, there is a new marker trait `Singleton` that can be applied
    as an upper bound on a type parameter, which indicates that the singleton type
    should be inferred for this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A *method type* does not denote a value, nor does it appear directly in the
    program. It is an internal representation of a method definition. It is represented
    as a sequence of parameter names with respective types and a return type of the
    method. The method type is important into know about because, if a method name
    is used as a value, its type is implicitly converted to the corresponding function
    type. As we defined in the `usage` method, the compiler internally created a method
    type called `(a: SomeClass, b: SomeObject.type)SomeTrait`.'
  prefs: []
  type: TYPE_NORMAL
- en: Literal types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala 2.13 introduced a special kind of singleton type—the *literal type*.
    It denotes a single value of some literal and represents the most precise type
    of this literal. It is available for all types for which literal syntax is available
    (for example, `Boolean`, `Char`, `String`, and `Symbol`). It is impossible to
    define a literal type for `Unit` (by specification) and for `Byte` and `Short`
    (because there is no syntax to define literals of such types). This is how it
    works in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to define a variable of a literal type. The first way is
    by using an explicit type ascription, and the second way is by making it a non-lazy
    `final`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A literal type is erased to the normal type during compilation, and so it is
    not possible to override methods using literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, the compiler prevented us from declaring two methods
    with the same name, and so took a parameter with a different literal type because
    of the erasure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The singleton type forming the `.type` operator can be used to specify that
    a function should return a literal type and not a normal type, as demonstrated
    by the type of `t` inferred by the compiler—`42`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Scala 2.13, there is a type class called `scala.ValueOf[T]` and an operator
    called `scala.Predef.valueOf[T]` that can be used to yield values for singleton types.
    This is how `valueOf[T]` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how it can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern matching against literal types also works as expected, though the
    syntax is unusual and probably not very useful, as demonstrated by this first
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These literal types are probably not very interesting for day-to-day programming,
    but are very useful for type-level library development.
  prefs: []
  type: TYPE_NORMAL
- en: Compound (intersection) types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A compound type is defined as a combination of zero or more component types
    with a refinement. If no refinement is provided, an implicit empty one (`{}`)
    is added by the compiler. Depending on the number of components, we can have the
    following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If just a refinement is given, the compound type is equivalent to extending `AnyRef`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single type is extended by using the corresponding `extends` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two or more types are combined by interleaving them with the `with` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a name clash in combined types and/or refinement, the usual override
    rules apply. This means that the rightmost type or refinement has the highest
    priority. This combination also represents an inheritance relation, and it is
    possible to access members of extended types with the use of the `super` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compound type is easy to imagine as a layer of wrappers. Because of this,
    the process of resolving conflicting members in traits is called **trait linearisation**,
    while the decorator design pattern is called **stackable traits**. The following
    example demonstrates how layers of traits can access methods defined on subtypes
    of the compound type to implement a decorated `toString` representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The definition of type contains just a refinement in the case of zero components
    being extended. This way of defining a type is known as a **structural type**.
    The use of structural types is generally discouraged in Scala because it can lead
    to a generation of bytecode that will access structurally defined members using
    reflection, which is significantly slower. Nevertheless, it is useful to define
    type lambdas, which we will take a look at near the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Type constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type constraints are rules associated with a type. They define a subset of
    all types that, for example, a variable can have. A type constraint takes the
    form of lower bound (subtype relation) or upper bound (supertype relation). It
    is possible to define multiple constraints for a single type. In this case, a
    type must satisfy both of them. Constraints are defined using the symbols `>:`
    (lower, unhappy bound) and  `<:` (upper, happy bound), and the direction of the
    sign corresponds to the reversed direction of the arrow on the UML diagram, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a801360-cd32-48dc-a797-40bf79b3e084.png)'
  prefs: []
  type: TYPE_IMG
- en: The type constraints are inclusive, which is why type `B` represents both the
    upper and lower bounds. Besides `B` in our type hierarchy, only `A` obeys the
    `LOWER` type constraint and only `C ` obeys the `UPPER` constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Scala's types hierarchy and special types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type constraints in combination with Scala''s type hierarchy give us a few
    interesting classes that are important to know about. To recap, the type hierarchy
    is represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f06375d-67c7-4713-af6c-7e00f662fb2b.png)'
  prefs: []
  type: TYPE_IMG
- en: In Scala, all types have a maximum upper bound of **Any** and a lower bound
    of **Nothing**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Value Classes** is a Scala way to avoid allocating runtime objects. This
    works by wrapping JVM''s primitive types. Scala already represents numeric types
    and `Boolean` and `Char` as **AnyVal**, and it is possible to implement custom
    value classes by extending **AnyVal** and obeying a few restrictions. An interesting
    subtype of **AnyVal** is a **Unit** type, which represents a case where something
    unimportant needs to be returned from a function or a method. It roughly corresponds
    to the void return type and has a single member, `()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**AnyRef** is a representation of any type that is allocated at runtime. In
    JVM, it is possible to have `null` in a place where an object reference is expected;
    the type of `null` is `Null`. The `Null` type has a single inhabitant, `null`,
    the same way `Unit` has a single value of `()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Nothing` is a special subtype of every other type and has no members. Because
    of this, it is not possible to instantiate members of that type. As a result,
    it is useful to indicate that the only possibility for a method or function to
    terminate is to do this abnormally, usually by throwing an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two traits that are not represented in the preceding diagram, `Serializable`
    and `Product`. The former marker trait is used to tell the JVM that some class
    should be serializable across platforms, and it just delegates to Java's interface, `java.io.Serializable`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Product` stays for the Cartesian product, which is basically just an ordered
    set of pairs of named types. In Scala, `Product` is extended by tuples and case
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Self` type is another special notion in Scala that''s used to define dependencies
    between traits without declaring an extension relation. This syntax allows you
    to bring in the scope of the trait members from other traits, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last member in our zoo of special types is `Dynamic`. This is a marker trait
    that allows you to use the dynamic invocation of methods (also known as **duck
    typing**).
  prefs: []
  type: TYPE_NORMAL
- en: It feels a bit inappropriate to go into the details of `Dynamic` here because
    Scala's strength is exactly the opposite—to express knowledge about the system
    statically using proper types. For curious readers, official documentation on
    this is available here: [https://www.scala-lang.org/api/current/scala/Dynamic.html](https://www.scala-lang.org/api/current/scala/Dynamic.html).
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding type hierarchy is quite important for understanding how type
    inference works. Type inference is a mechanism that the compiler uses to guess
    the type of an expression or a method if the definition of its type is omitted.
    The same also applies to the type parameters of polymorphic methods or generic
    classes and sometimes to anonymous function parameter types as well. This inference
    aims to provide the most specific type possible while obeying all of the existing
    constraints. The compiler does this by walking the hierarchy tree and finding
    the *least upper bound*. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we specified the return types as the compiler infers them. For the first
    two cases, you can easily follow the hierarchy of Scala types to understand how
    the compiler did the inference. The last three are a bit more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: In `sOrC`, the inferred type is `java.io.Serializable`. The reason for this
    is that Scala's `String` is just an alias for `java.lang.String`, which extends `java.io.Serializable`.
    All case classes in Scala extend `Product with Serializable` by default and `Serializable`
    extends `java.io.Serializable`. Therefore, `java.io.Serializable` is the least
    upper bound in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `cOrD`, `D` is not a case class, and therefore it does not extend anything
    but the `AnyRef`, which becomes an inferred type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `cOrE`, both `C` and `E` are case classes, and so the compiler can infer
    the most specific type, that is, `Product with Serializable`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In fact, the preciseness of the compiler can go quite far, as the following
    example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the inferred type of `fOrG` is a compound type with three
    members.
  prefs: []
  type: TYPE_NORMAL
- en: Path-dependent types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have avoided talking about paths, mostly because they are not
    types themselves. However, they can be a part of named types, and thus have an
    important role in Scala's type system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A path can have one of the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: An empty path, denoted with `ε`. It cannot be written directly, but implicitly
    precedes any other path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C.this`, where `C` is a reference class. This is the path that is constructed
    if `this` is used inside of a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C.super.x.` or `C.super[P].` refers to the member `x` of the superclass or
    designated parent class, `P` of `C`. It plays the same role as `this` for the
    class, but refers to the classes that are upper in the hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p.x`, where `p` is a path and `x` is a stable member of `p`. The stable member
    is an object definition or a value definition for which it is possible for the
    compiler to tell that it will always be accessible (as opposed to the volatile
    type where it is not possible, for example, there is an abstract type definition
    that can be overridden by a subclass).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Types within the path can be referred to by two operators, `#` (hash) and `.`
    (dot). The former is known as **type projection**, and `T#m` refers to the type
    member `m` of the type `T`. We can demonstrate the difference between these operators
    by building a type-safe lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined a type, `Lock`, with a nested type, `Key`. The key can be
    referenced using its path, `Lock.Key`, or by using a projection, `Lock#Key`. The
    former denotes a type tied to a specific instance, and the latter denotes a type
    that is not. The specific types of key are returned by two different constructor
    methods. The `makeKey` return type is a `Key` that is a shortcut for `this.Key`,
    which in turn is an alias for `Lock.this.type#Key` and represents a *path-dependent
    type*. The latter is just a type projection, `Lock#Key`. Because the path-dependent
    type refers to the concrete instance, the compiler will only allow the use of
    the appropriate type to call the `open` and `close` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `masterKey` is not path-dependent, and so can be used to call methods on
    any instance in a typical way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These path-dependent types conclude our journey regarding concrete types and
    can be used to describe values. All of the types we've seen so far (except method
    types) are named *value types* to reflect this fact. A named value type is called
    a **type designator**. All type designators are shorthand for type projections.
  prefs: []
  type: TYPE_NORMAL
- en: We will now switch gears and inspect how types can be used to narrate definitions
    of other types.
  prefs: []
  type: TYPE_NORMAL
- en: Types – all the way down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have only talked about concrete types. Despite being quite
    simple, they already allow for the expression of a lot of properties of a program
    on the type level and they have these properties verified at compile time. Scala
    gives the developer even more freedom by allowing them to use types as parameters
    while defining methods, classes, or other types. In the next section, we will
    look at different ways to do this, starting with basic type parameters and type
    member definition, and continuing with type constraints and variance topics. We'll
    conclude our discussion with higher kinded types and type lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type parameters are defined using square brackets `[]`. If applied to classes
    and methods, they must be declared before normal parameters, and the result is
    known as a **parameterized type**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Wrapper` class is parameterized by the `A` type. This type parameter is
    used to refer to the type of content in the `unwrap` method. The scope resolution
    rules apply to the type parameters the same way as they do to the normal parameters,
    as shown by the `unwrap` method definition.
  prefs: []
  type: TYPE_NORMAL
- en: The `createWrapper` method definition shows how the type parameter propagates
    to the implementation side—`Wrapper(a)` is parameterized with the `A` type by
    the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The `ConcreteWrapper` type definition shows that type aliases are parameterized
    in the same way that types are.
  prefs: []
  type: TYPE_NORMAL
- en: We then use our parameterized type to demonstrate that it is possible to provide
    explicit type parameters on the call side, as well as rely on type inference.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type inference is in fact quite powerful. The compiler always tries to
    find the most specific type, as the following example reveals (I''ve provided
    the explicit type ascriptions, which reflect the types inferred by the compiler):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We discussed Scala's type hierarchy earlier, so it should be obvious how the
    compiler came up with the types shown in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to restrict possible definitions of the type parameter by using
    type constraints, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will check that the concrete definition conforms to the type parameter
    bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Type members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *type member* is similar to the type parameter, but it is defined as a type
    alias that''s a member of an abstract class or trait. It can then be made concrete
    at the moment the abstract definition itself is made concrete. Let''s look at
    the following few lines of code, which will show you how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined an abstract type member, `A`, and overrode it in the concrete
    implementation by binding it to the `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to define multiple type members, of course, and define constraints
    on them, including type members themselves as part of the constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Type inference is not applied in this case, so the following code will not
    compile because the type definition is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These type members can be defined using all language features that can be applied
    to other type definitions, including multiple type constraints and path-dependent
    types. In the following example, we demonstrate this by declaring type members
    in the `HolderDEF` and providing the concrete definition in the class `DEF`. Incompatible
    type definitions are noted as such and commented out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to combine type members and type parameters and use them
    later to further constrain possible definitions of the former:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Type members and type parameters look very similar in their function—this is
    done to define abstract type definitions that can be refined later. Given this
    similarity, a developer can use one or another most of the time. Still, there
    are a couple of nuances regarding the situations in which you should prefer to
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'These type parameters are usually more straightforward and easier to get right,
    so generally, they should be preferred. Type members are the way to go if you
    run into one of the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If the concrete type definition should remain hidden
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the intended way to provide the concrete definition of the type is via inheritance
    (overridden in subclasses or mixed-in via traits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is another simple rule that''s easy to memorize—type parameters are used
    to define the types of parameters of the method and type members to define the
    result type of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There is also another way to specify boundaries for type parameters and type
    members in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Generalized type constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two sections, we used type constraints provided by the language
    to precisely define type members and type parameters. There are also supplementary
    *generalized type constraints* defined in the standard library that allow you
    to define relations between types using type classes. We will look at type classes
    and implicits in detail in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml),
    *Getting* *to Know Implicits and Type Classes*, but we will give a brief introduction
    to generalized type constraints here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<:<` constraint expresses the requirement that the left-side type is a
    subtype of the right-side type. Basically, having an instance of  `A <:< B` is
    the same as having a definition of `A <: B`. But why is it needed, then? Because
    sometimes the language is not expressive enough. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not possible to express the `A <: Wrapper[B]` type constraint because
    the `A` in this definition will shadow the `A` type constraint in the definition
    of `Wrapper[A]`. The implicit, `ev`, solves this problem easily. `ev` will be
    available in scope if the compiler can prove that the subtype relation holds.'
  prefs: []
  type: TYPE_NORMAL
- en: Another generalized type constraint available in the Scala standard library
    is `=:=`. So, `A =:= B` allows you to require that `A` and `B` are equal, the
    same way that `A <:< B` allows you to express subtyping relation. Due to restrictions
    on subclassing, it also witnesses that `A <:< B`, but not that `B <:< A`. We will
    take a look in detail how this equality relation can be used to express domain
    constraints at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The strange syntax of `A <:< B` and `A =:= B` brings us to the next section, *Infix
    types*.
  prefs: []
  type: TYPE_NORMAL
- en: Infix types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way that Scala has infix operators, it has infix types. An infix
    type, such as `A Op B`, is just any type that has exactly two type operands. It
    is equivalent to the type defined as `Op[A, B]`. `Op` may be any valid identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type operators have the same associativity as term operators—they are left
    associative unless an operator ends in `:` (colon), in which case it is right
    associative. Consecutive infix operators must have the same associativity. Let''s
    look at an example to understand what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined four types, all of which have two type parameters and so can
    be used as infix types. Then, we define a type called `CC`, which expresses some
    relation between the `A`, `B`, and `C` types. The `DA` and `DB` type definitions
    show what the type definition looks like in infix notation. The first attempt
    to define some type, `E`, to be the same as the `C` type fails because of the
    different associativity of the types, `=+` and `=:`, and we have demonstrated
    how parentheses can be used to work around this rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'If used properly, infix types can greatly improve the readability of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see how infix types allow you to define type relation in a way
    that looks similar to Boolean operations.
  prefs: []
  type: TYPE_NORMAL
- en: Variance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Variance* is another aspect related to parameterized types. To understand
    why it is needed and how it works, let''s have a drink. First, we will define
    a glass that can be (half) full or empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There can only be one empty glass filled with `Nothing`, and we model this
    case with a case object. A full glass can be filled with different contents. `Nothing`
    is a subclass of any class in Scala, so in our case it should be able to substitute
    any contents. We will now create the contents and we would like to be able to
    drink it. The implementation is not important in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We now are able to drink from the full glass and are unable to do so from an
    empty one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: But what if instead of drinking, we'd like to define `drinkAndRefill`, which
    should refill an empty glass?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like our implementation to accept not only `Glass[Water]`, but also `Glass[Nothing]`,
    or more generally any `Glass[B]` if `B <: Water`. We can change our implementation
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if we would like our `Glass` to work like this with any method, not
    only `drinkAndRefill`? Then we need to define how the relation between parameterizing
    types should affect the way the parameterized type works. This is done with variance.
    Our definition, `sealed trait Glass[Contents]`, is called **invariant**, and it
    means that the relation in the type that parameterizes `Glass` does not affect
    how glasses with different contents are related—they are not related at all. The
    *covariance* means that, in regards to the compiler, if type parameters are in
    a subclass relation, then the main types should be too. It is expressed with a
    `+` (plus) before the type constraint. Therefore, our definition of the glass
    becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And the rest of the code remains unchanged. Now, if we have contents that are
    related, we can drink them without facing the same problems we had before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A typical use of covariance is with different kinds of immutable containers,
    where it is safe to have a more specific element in the container, like the one
    that is declared by the type.
  prefs: []
  type: TYPE_NORMAL
- en: It is not safe to do so with mutable containers, though. The compiler will not
    allow us to do this, but if it would, we might end up passing a container, `C`,
    with some subclass, `B`, to the method, expecting a container with superclass
    `A`. This method would then be able to replace the contents of `C` with `A` (as
    it is not even supposed to know about the existence of `B`), hence making future
    uses of `C[B]` impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s imagine that our glass is supposed to interact with a drinker.
    We''ll create a `Drinker` class for this, and the drinker is supposed to be able
    to drink the contents of `Glass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s inspect what happens if we have two different kinds of `Water`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`PureWater` is `Water` with some additional properties. We can create a glass
    full of it and let it fill a drinker. Obviously, if somebody can drink just water,
    they should be able to drink pure water as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this, we need to use *contravariance*, which is denoted by the `-` (minus
    sign) before the type parameter. We fix our `Drinker` like so, and our example
    starts to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It is important to notice that co- and contravariance do not define the type
    itself, but only the type parameters. This is very important for functional programming
    in Scala because it allows defining functions as first-class citizens. We will
    look at function definition in more detail in the next chapter, but to give you
    some indication, here is what it is about.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to pass over to the caller a function, that is, `f(water: Water):
    Water`, what kind of substitute would be safe to pass instead? It would not be
    safe to pass a function that accepts `PureWater` because the caller won''t be
    able to call it with such an argument. But it will be safe for the function to
    accept `Water` and any superclass of it that describes contravariance. For the
    result, it would be unacceptable for our replacement function to return anything
    higher in the hierarchy than `f` because the caller expects the result to be at
    least as specific as `f`. It would be no problem if our substitute was more specific,
    though. Therefore, we end up with covariance. Hence, we can define `f` as `f[-Parameter,+Result]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Existential types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Existential types come into play if we stop caring about the specifics of type
    parameters. Taking our previous example, if we have a method that expects a glass
    of something, but inside the method, we do not actually care what this something
    is, then we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this definition, we actually don''t need to know what `T` is, we just want
    to make sure that it is some kind of `Water`. Scala allows you to have an underscore
    as a placeholder, in the same way it can be utilized to denote unused variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a placeholder syntax for *existential type*s. As we saw previously,
    if the upper bound is omitted, `scala.Any` is assumed. In the case that the lower
    bound hasn't been defined, the compiler will implicitly add `scala.Nothing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This syntax is just a shorter version of the more powerful syntax `T forSome
    { Q }`, where `Q` is a sequence of type declarations, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Existential types are considered to be an advanced language feature and so need
    a respective import to be in scope or to be enabled as a compiler option.
  prefs: []
  type: TYPE_NORMAL
- en: Higher kinded types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our example of the glass has become a bit boring. To make it fascinating again,
    we''ll add another abstraction, a jar. This is how our model will look after that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The glass and the jar can both be filled with any contents. For instance, this
    is how it can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, both methods look identical with respect to the type used to
    construct the result. The parameterized type that is used to construct types is
    called a **type constructor**. As a consistent language, Scala allows you to abstract
    over type constructors in the same way it allows you to abstract over functions
    via higher order functions (more about this in the next chapter). This abstraction
    over type constructors is called **higher kinded types**. The syntax requires
    us to use an underscore to denote the expected type parameter on the definition
    side. The implementation should then use the type constructor without type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a type constructor to provide a generic filling functionality. Of
    course, we can''t get rid of the specific knowledge about how to fill our containers,
    but we can move it to the type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we''re using the type constructor `CC[_]` to denote
    both `Glass` and `Jar` in the `Filler` trait. We can now use created abstractions
    to define a generic filling functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `G[_]` type is a type constructor for glass and jar, and `Filler[G]` is
    a higher order type that uses this type constructor to build a full `G[C]` for
    any content, `C`. This is how the generic fill method can be used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This might not look like a huge win over the specific methods for now because
    we've provided our type constructors explicitly. The real advantage will become
    obvious the moment we start talking about implicits in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml),
    *Getting to know Implicits and Type Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Type lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a next step, let''s imagine that we have a generic `Filler` that is capable
    of filling different containers with different kinds of contents, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'What could we do if we had a requirement to provide a method that should only
    accept one type of container or content? We would need to fix the second type
    parameter in a similar fashion to how we would partially apply a function if given
    one of the arguments. A type alias can be used to do this on the type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'But it feels a bit verbose to define a type alias just to be used once in the
    definition of the function parameter. **Type lambda** is a syntax that allows
    us to do such partial type application in-place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The type lambda can also be used to define a parameter type directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The internal definition of `T[C]` is analogous to the type alias we defined
    previously. The added part is the type projection, `()#T[C]`, that allows us to
    reference the type we've just defined.
  prefs: []
  type: TYPE_NORMAL
- en: Using types to define domain constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen how simple types can be used to express domain constraints,
    as discussed in the *Path-dependent types* section. We implemented a lock that
    guaranteed at compile time that it is only possible to open and close it with
    the key created for this specific lock. We will conclude our study of type parameters
    and higher kinded types with two examples.
  prefs: []
  type: TYPE_NORMAL
- en: The first example will demonstrate an application of phantom types to create
    another version of the lock, which can guarantee the safety of state transitions
    at compile time without the use of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The second example will show how self-recursive types can help to constrain
    possible subtyping.
  prefs: []
  type: TYPE_NORMAL
- en: Phantom types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *phantom type* in Scala is a type that is never instantiated at runtime.
    Because of this, it is only useful at compile time to express domain constraints
    similar to (generalized) type constraints. To get a feeling for how this works,
    let''s imagine the following situation—we have an abstraction of `Lock`, that
    has already been implemented in different ways via the use of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to encode in the type system that only the following state transitions
    are allowed for any locks:'
  prefs: []
  type: TYPE_NORMAL
- en: open -> closed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: closed -> open
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: closed -> broken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: open -> broken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we already have an existing hierarchy, we cannot easily model these state
    transitions with inheritance by extending `Lock` with `ClosedLock`, `OpenLock`,
    and `BrokenLock`. Instead, we will use the phantom types `Open`, `Closed`, and
    `Broken` to model the states (we will define `Lock` from scratch later, just to
    avoid cluttering the example with unnecessary details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can assign this `State` to a `Lock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And define our state transitioning methods using type constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can bring any lock to the broken state so that the `break` method does not
    have any constraints defined on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transition to the `Open` state is only available from the `Closed` state,
    and we encode this fact with the existential type (that, nevertheless, should
    be available for successful compilation), which is a subclass of the current `State`
    of the lock and a superclass of `Closed`. The only possibility to satisfy type
    constraint is for `State` to be equal to `Closed`. This is done in the same way
    that it is only possible way to call the `close` method and satisfy type constraints
    by having `Lock` in the `Open` state. Let''s see how the compiler reacts in different
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The compiler refuses to accept calls that would lead to inappropriate state
    transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also provide an alternative implementation by using generalized type
    constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It is arguable that the generalized syntax conveys the intention much better
    as it almost reads as `State should be equal to Closed` in the first case or `State
    should be equal to Open` in the second case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the compiler reacts to our new implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the error messages are also better for the implementation with generalized
    type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Self-recursive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recall different implementations inheriting from a single trait from
    the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now extend `Lock` with an `open` method, which should return the same
    type of `Lock` and let our implementations serve as type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The realization is not very interesting for now—the important part is that it
    returns the same type as the instance it was called on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with this implementation, there is an issue that we can use it with something
    that is not a `Lock` at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, we don''t want to allow this! We want to constrain our type parameter
    so that it is a subtype of `Lock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'But unfortunately, this won''t compile because the `Lock` takes a type parameter
    that is absent in the preceding definition. We need to provide that type parameter.
    What should it be? Logically, the same type as we used to parameterize the `Lock`—`E`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The type parameter looks a bit weird because it refers to itself recursively.
    This way of defining a type is called a **self-recursive type parameter** (or
    sometimes an F-bounded type polymorphism).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can only parameterize `Lock` by the type, which is itself a `Lock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'But unfortunately, we can still mess things up by defining the wrong subtype
    as a type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we need to define another constraint that will say that the type
    parameter should refer to the type itself, not just any `Lock`. We already know
    that there is a self-type that can be used for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Nice! We've just defined a `Lock` trait that can only be parameterized with
    classes that extend this trait and only by the class itself. We've done this by
    using a combination of the self-recursive type parameter and the self-type.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type system is one of the key components of the Scala language. It allows
    the developer to express expectations about the behavior of the program, which
    can then be checked at compile time. This reduces the number of tests needed to
    verify the correctness of the solution and the possibility of runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, strictly typed languages are associated with verbose code. Normally,
    this is not the case with Scala because of its powerful type inference mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Scala allows you to define very narrow types containing a single value as well
    as much wider types, even those represented as a combination of other types.
  prefs: []
  type: TYPE_NORMAL
- en: The type definition can be made more precise by using type constraints, type
    parameters, and variance.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at some examples of how the type system can be used to express
    domain constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, Scala's ecosystem is much richer than what we have covered
    here. Some open source libraries offer advanced type constraints that are expressed
    as refined types, fixpoint types, or tagged types. Other libraries, such as shapeless,
    provide the possibility for type-level programming, which allows you to express
    and verify quite complex program logic at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which type constraints can you name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What implicit type constraints are added to a type if there are no type constraints
    defined on it by the developer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which operators can be used to refer to the nested type of some type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which type can be used as an infix type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the use of structural types discouraged in Scala?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is expressed via variance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mads Hartmann, and Ruslan Shevchenko, *Professional Scala*: You will learn how
    to write type-safe code concisely and expressively in an environment that lets
    you build for the JVM, browser, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vikash Sharma, *Learning Scala Programming: **Learn how to write scalable and
    concurrent programs in Scala*, a language that grows with you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
