<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">JavaServer Faces</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover <strong>JavaServer</strong> <strong>Faces</strong> (<strong>JSF</strong>), the standard component framework of the Java EE platform. Java EE 8 includes JSF 2.3, the latest version of JSF. JSF relies a lot on convention over configurationâ€”if we follow JSF conventions then we don't need to write a lot of configuration. In most cases, we don't need to write any configuration at all. This fact, combined with the fact that <kbd>web.xml</kbd> has been optional since Java EE 6, means that, in many cases, we can write complete web applications without having to write a single line of XML.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Facelets</li>
<li>JSF project stages</li>
<li>Data validation</li>
<li>Named beans</li>
<li>Navigation</li>
<li>Ajax-enabling JSF applications</li>
<li>JSF HTML5 support</li>
<li>Faces flows</li>
<li>JSF artifact injection</li>
<li>JSF WebSocket support</li>
<li>JSF component libraries</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing JSF</h1>
                </header>
            
            <article>
                
<p>JSF 2.0 introduced a number of enhancements to make JSF application development easier. In the following few sections, we will explore some of these features.</p>
<div class="packt_infobox">Readers not familiar with earlier versions of JSF may not understand the following few sections completely. Not to worry, everything will be perfectly clear by the end of this chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Facelets</h1>
                </header>
            
            <article>
                
<p>One notable difference between modern versions of JSF and earlier versions is that Facelets is now the preferred view technology. Earlier versions of JSF used <strong>Java Server Pages</strong> (<strong>JSP</strong>) as their default view technology. Since the JSP technology predates JSF, sometimes using JSP with JSF felt unnatural or created problems. For example, the JSP lifecycle is different from the JSF lifecycle; this mismatch introduced some problems for JSF 1.x application developers.</p>
<p>JSF was designed from the beginning to support multiple view technologies. To take advantage of this capability, Jacob Hookom wrote a view technology specifically for JSF. He named his view technology <strong>Facelets</strong>. Facelets was so successful it became a de-facto standard for JSF. The JSF expert group recognized Facelets' popularity and made it the official view technology for JSF in version 2.0 of the JSF specification.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optional faces-config.xml</h1>
                </header>
            
            <article>
                
<p>Legacy J2EE applications suffered from what some have considered to be excessive XML configuration.</p>
<p>Java EE 5 took some measures to reduce XML configuration considerably. Java EE 6 reduced the required configuration even further, making the JSF configuration file, <kbd>faces-config.xml</kbd>, optional in JSF 2.0.</p>
<p>In JSF 2.0 and newer versions, JSF managed beans can be configured via the <kbd>@ManagedBean</kbd> annotation, obviating the need to configure them in <kbd>faces-config.xml</kbd>. Java EE 6 introduced the <strong>Contexts and Dependency Injection</strong> (<strong>CDI</strong>) API, which provides an alternate way of implementing functionality typically implemented with JSF managed beans. As of JSF 2.2, CDI named beans are preferred over JSF managed beans; JSF 2.3 went even further, deprecating specific <span>JSF-</span>managed beans in favor of CDI named beans.</p>
<p>Additionally, there is a convention for JSF navigation: if the value of the action attribute of a JSF 2.0 command link or command button matches the name of a facelet (minus the XHTML extension), then by convention, the application will navigate to the facelet matching the action name. This convention allows us to avoid having to configure application navigation in <kbd>faces-config.xml</kbd>.</p>
<p>For many modern JSF applications, <kbd>faces-config.xml</kbd> is completely unnecessary as long as we follow established JSF conventions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Standard resource locations</h1>
                </header>
            
            <article>
                
<p>JSF 2.0 introduced standard resource locations. Resources are artifacts a page or JSF component needs to render properly. Resource examples include CSS stylesheets, JavaScript files, and images.</p>
<p>In JSF 2.0 and newer versions, resources can be placed in a subdirectory under a folder called <kbd>resources</kbd>, either at the root of the WAR file or under its <kbd>META-INF</kbd> directory. By convention, JSF components know they can retrieve resources from one of these two locations.</p>
<p>In order to avoid cluttering the <kbd>resources</kbd> directory, <kbd>resources</kbd> are typically placed in a subdirectory. This subdirectory is referred to from the <kbd>library</kbd> attribute of JSF components.</p>
<p>For example, we could place a CSS stylesheet called <kbd>styles.css</kbd> under <kbd>/resources/css/styles.css</kbd>.</p>
<p>In our JSF pages, we could retrieve this CSS file using the <kbd>&lt;h:outputStylesheet&gt;</kbd> tag, as follows:</p>
<pre style="padding-left: 60px">&lt;h:outputStylesheet library="css"  name="styles.css"/&gt; </pre>
<p>The value of the <kbd>library</kbd> attribute must match the subdirectory where our <kbd>stylesheet</kbd> is located.</p>
<p>Similarly, we could have a JavaScript file under <kbd>/resources/scripts/somescript.js</kbd> and an image under <kbd>/resources/images/logo.png</kbd>, and we could access these <kbd>resources</kbd> as follows:</p>
<pre style="padding-left: 60px">&lt;h:graphicImage library="images" name="logo.png"/&gt;</pre>
<p>And:</p>
<pre style="padding-left: 60px">&lt;h:outputScript library="scripts" name="somescript.js"/&gt; </pre>
<p>Notice that, in each case, the value of the <kbd>library</kbd> attribute matches the corresponding subdirectory name under the <kbd>resources</kbd> directory, and the value of the <kbd>name</kbd> attribute matches the resource's file name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing our first JSF application</h1>
                </header>
            
            <article>
                
<p>To illustrate basic JSF concepts, we will develop a simple application consisting of two Facelet pages and a single CDI named bean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Facelets</h1>
                </header>
            
            <article>
                
<p>As we mentioned in this chapter's introduction, the default view technology for JSF 2.0 and newer versions is <strong>Facelets</strong>. Facelets need to be written using standard XML. The most popular way to develop Facelet pages is to use XHTML in conjunction with JSF-specific XML namespaces. The following example shows how a typical Facelet page looks:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
 &lt;html  
<strong>      </strong><strong>                   <br/>      &gt;</strong><strong> <br/>    &lt;h:head&gt;</strong> 
        &lt;title&gt;Enter Customer Data&lt;/title&gt; 
<strong>    &lt;/h:head&gt;</strong><strong>   <br/>    &lt;h:body&gt;</strong><strong>        <br/>        &lt;h:outputStylesheet library="css" name="styles.css"/&gt;</strong><strong>                         <br/>        &lt;h:form id="customerForm"&gt;</strong><strong>     <br/>            &lt;h:messages&gt;&lt;/h:messages&gt;</strong><strong>          <br/>            &lt;h:panelGrid columns="2"</strong><strong>                                                                                                     <br/>             columnClasses="rightAlign,leftAlign"&gt;</strong><strong>                                                                   <br/>                &lt;h:outputLabel for="firstName" value="First Name:"&gt;</strong><strong>                                                                 <br/>                &lt;/h:outputLabel&gt;</strong><strong>             <br/>                &lt;h:inputText id="firstName"</strong><strong>                                                                                                                     <br/>                 label="First Name"</strong><strong>                                                                                                                     <br/>                 value="#{customer.firstName}"</strong><strong>                                                                                                                     <br/>                 required="true"&gt;</strong><strong>                                                                                 <br/>                    &lt;f:validateLength minimum="2" maximum="30"&gt;</strong><strong>                                                                                 <br/>                    &lt;/f:validateLength&gt;</strong><strong>                                                                 <br/>                &lt;/h:inputText&gt;</strong><strong>               <br/>                &lt;h:outputLabel for="lastName" value="Last Name:"&gt;</strong><strong>                                                                 <br/>                &lt;/h:outputLabel&gt;</strong><strong>                <br/>                &lt;h:inputText id="lastName"</strong><strong>                                                                                                                       <br/>                 label="Last Name"</strong><strong>                                                                                                                     <br/>                 value="#{customer.lastName}"</strong><strong>                                                                                                                     <br/>                 required="true"&gt;</strong><strong>                                                                                <br/>                    &lt;f:validateLength minimum="2" maximum="30"&gt;</strong><strong>                                                                                 <br/>                    &lt;/f:validateLength&gt;</strong><strong>                                                                                    <br/>                    &lt;/h:inputText&gt;</strong><strong>                <br/>                &lt;h:outputLabel for="email" value="Email:"&gt;</strong><strong>                                                                 <br/>                &lt;/h:outputLabel&gt;</strong><strong>               <br/>                &lt;h:inputText id="email" </strong><strong>                                                                                                                     <br/>                 label="Email" </strong><strong>                                                                                                                    <br/>                 value="#{customer.email}"&gt;</strong><strong>                                                                                             <br/>               &lt;f:validateLength minimum="3" maximum="30"&gt;</strong><strong>                                                                                 <br/>               &lt;/f:validateLength&gt;</strong><strong>                                               <br/>                 &lt;/h:inputText&gt;</strong><strong>              <br/>                &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt;</strong><strong>                                                                 <br/>             &lt;h:commandButton action="confirmation" value="Save"&gt;</strong><strong>                                                                 <br/>             &lt;/h:commandButton&gt;</strong><strong>          <br/>            &lt;/h:panelGrid&gt;</strong><strong>        <br/>        &lt;/h:form&gt;</strong><strong>   <br/>    &lt;/h:body&gt;</strong> 
&lt;/html&gt; </pre>
<p>The following screenshot illustrates how the previous page renders in the browser:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/dcb5841f-5eb1-4f8c-88e1-de9865c95345.png" style="width:23.08em;height:15.00em;"/></div>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">The preceding screenshot, of course, was taken after entering some data in every text field; originally each text field was blank.</p>
<p>Pretty much any Facelet JSF page will include the two namespaces illustrated in the example. The first namespace (<kbd/>) is for tags that render HTML components; by convention, the prefix <kbd>h</kbd> (for HTML) is used when using this <kbd>tag</kbd> library.</p>
<p>The second namespace (<kbd/>) is the core JSF <kbd>tag</kbd> library, by convention, the prefix <kbd>f</kbd> (for faces) is used when using this <kbd>tag</kbd> library.</p>
<p>The first JSF-specific tags we see in the preceding example are the <kbd>&lt;h:head&gt;</kbd> and <kbd>&lt;h:body&gt;</kbd> tags. These tags are analogous to the standard HTML <kbd>&lt;head&gt;</kbd> and <kbd>&lt;body&gt;</kbd> tags, and are rendered as such when the page is displayed in the browser.</p>
<p>The <kbd>&lt;h:outputStylesheet&gt;</kbd> tag is used to load a CSS stylesheet from a well-known location (JSF standardizes the locations of resources, such as CSS stylesheets and JavaScript files; this will be discussed in detail later in the chapter). The value of the <kbd>library</kbd> attribute must correspond to the directory where the CSS file resides (this directory must be under a <kbd>resources</kbd> directory). The <kbd>name</kbd> attribute must correspond to the name of the CSS stylesheet we want to load.</p>
<p>The next tag we see is the <kbd>&lt;h:form&gt;</kbd> tag. This tag generates an HTML form when the page is rendered. As can be seen in the example, there is no need to specify an <kbd>action</kbd> or a <kbd>method</kbd> attribute for this tag; as a matter of fact, there is no <kbd>action</kbd> or <kbd>method</kbd> attribute for this tag. The <kbd>action</kbd> attribute for the rendered HTML form will be generated automatically, and the <kbd>method</kbd> attribute will always be <kbd>post</kbd>. The <kbd>id</kbd> attribute of <kbd>&lt;h:form&gt;</kbd> is optional; however, it is a good idea to always add it, since it makes debugging JSF applications easier.</p>
<p>The next tag we see is the <kbd>&lt;h:messages&gt;</kbd> tag. As its name implies, this tag is used to display any messages. As we will see shortly, JSF can automatically generate validation messages, displayed inside this tag. Additionally, arbitrary messages can be added programmatically via the <kbd>addMessage()</kbd> method defined in <kbd>javax.faces.context.FacesContext</kbd>.</p>
<p>The next JSF tag we see is <kbd>&lt;h:panelGrid&gt;</kbd>. This tag is roughly equivalent to an HTML table, but it works a bit differently. Instead of declaring rows (<kbd>&lt;tr&gt;</kbd>) and cells (<kbd>&lt;td&gt;</kbd>), the <kbd>&lt;h:panelGrid&gt;</kbd> tag has a <kbd>columns</kbd> attribute; the value of this attribute indicates the number of columns in the table rendered by this tag. As we place components inside this tag, they will be placed in a row until the number of columns defined in the <kbd>columns</kbd> attribute is reached, when the next component will be placed in the next row. In the example, the value of the columns attribute is <kbd>2</kbd>, therefore the first two tags will be placed in the first row, the next two will be placed in the second row, and so forth.</p>
<p>Another interesting attribute of <kbd>&lt;h:panelGrid&gt;</kbd> is the <kbd>columnClasses</kbd> attribute. This attribute assigns a CSS class to each column in the rendered table. In the example, two CSS classes (separated by a comma) are used as the value for this attribute. This has the effect of assigning the first CSS class to the first column, and the second one to the second column. Had there been three or more columns, the third one would have gotten the first CSS class, the fourth one the second one, and so on, alternating between the first one and the second one. To clarify how this works, the next code snippet illustrates a portion of the source of the HTML markup generated by the preceding page:</p>
<pre style="padding-left: 60px">&lt;table&gt; 
    &lt;tbody&gt; 
        &lt;tr&gt; 
<strong>            &lt;td class="rightAlign"&gt;</strong><strong>      <br/>                &lt;label for="customerForm:firstName"&gt;</strong><strong>            <br/>                    First Name:</strong><strong>              <br/>                &lt;/label&gt;</strong><strong>     <br/>            &lt;/td&gt;</strong><strong>         <br/>            &lt;td class="leftAlign"&gt;</strong><strong>              <br/>                &lt;input id="customerForm:firstName" type="text"</strong><strong>                                      <br/>                 name="customerForm:firstName" /&gt;</strong><strong>    <br/>            &lt;/td&gt;</strong> 
        &lt;/tr&gt; 
        &lt;tr&gt; 
<strong>            &lt;td class="rightAlign"&gt;</strong><strong>   <br/>                &lt;label for="customerForm:lastName"&gt;</strong><strong>                                         <br/>                 Last Name:</strong><strong>             <br/>                &lt;/label&gt;</strong><strong>         <br/>            &lt;/td&gt;</strong><strong>           <br/>            &lt;td class="leftAlign"&gt;</strong><strong>             <br/>                &lt;input id="customerForm:lastName" type="text"</strong><strong>                                              <br/>                 name="customerForm:lastName" /&gt;</strong><strong>    <br/>            &lt;/td&gt;</strong> 
        &lt;/tr&gt; 
        &lt;tr&gt; 
<strong>            &lt;td class="rightAlign"&gt;</strong><strong>        <br/>                &lt;label for="customerForm:lastName"&gt;</strong><strong>          <br/>                    Email:</strong><strong>               <br/>                &lt;/label&gt;</strong><strong>            <br/>            &lt;/td&gt;</strong><strong>           <br/>            &lt;td class="leftAlign"&gt;</strong><strong>            <br/>                &lt;input id="customerForm:email" type="text"</strong><strong>                                              <br/>                 name="customerForm:email" /&gt;</strong><strong>    <br/>             &lt;/td&gt;</strong> 
        &lt;/tr&gt; 
        &lt;tr&gt; 
<strong>            &lt;td class="rightAlign"&gt;&lt;/td&gt;</strong><strong>   <br/>            &lt;td class="leftAlign"&gt;</strong><strong>          <br/>                &lt;input type="submit" name="customerForm:j_idt12"</strong><strong>                                     <br/>                 value="Save" /&gt;</strong><strong>         <br/>            &lt;/td&gt;</strong> 
        &lt;/tr&gt; 
    &lt;/tbody&gt; 
&lt;/table&gt; </pre>
<p>Notice how each <kbd>&lt;td&gt;</kbd> tag has an alternating CSS tagâ€”<kbd>"rightAlign"</kbd> or <kbd>"leftAlign"</kbd>; we achieved this by assigning the value <kbd>"rightAlign,leftAlign"</kbd> to the <kbd>columnClasses</kbd> attribute of <kbd>&lt;h:panelGrid&gt;</kbd>. We should note that the CSS classes we are using in our example are defined in the CSS stylesheet we loaded via the <kbd>&lt;h:outputStylesheet&gt;</kbd> we discussed earlier. The ID's of the generated markup are a combination of the ID we gave to the <kbd>&lt;h:form&gt;</kbd> component, plus the ID of each individual component. Notice that we didn't assign an ID to the <kbd>&lt;h:commandButton&gt;</kbd> component near the end of the page, so the JSF runtime assigned one automatically.</p>
<p>At this point in the example, we start adding components inside <kbd>&lt;h:panelGrid&gt;</kbd>. These components will be rendered inside the table rendered by <kbd>&lt;h:panelGrid&gt;</kbd>. As we mentioned before, the number of columns in the rendered table is defined by the <kbd>columns</kbd> attribute of <kbd>&lt;h:panelGrid&gt;</kbd>. Therefore, we don't need to worry about columns (or rows), we can just start adding components and they will be placed in the right place.</p>
<p>The next tag we see is the <kbd>&lt;h:outputLabel&gt;</kbd> tag. This tag renders as an HTML <kbd>label</kbd> element. Labels are associated with other components via the <kbd>for</kbd> attribute, whose value must match the ID of the component that the label is for.</p>
<p>Next, we see the <kbd>&lt;h:inputText&gt;</kbd> tag. This tag generates a text field in the rendered page. Its <kbd>label</kbd> attribute is used for any validation messages; it lets the user know what field the message refers to.</p>
<div class="packt_tip">Although it is not mandatory for the value of the <kbd>label</kbd> attribute of <kbd>&lt;h:inputText&gt;</kbd> to match the label displayed on the page, it is highly recommended to use this value. In case of an error, this will let the user know exactly what field the message is referring to.</div>
<p>Of particular interest is the tag's <kbd>value</kbd> attribute. What we see as the value for this attribute is a <strong>value binding expression</strong>. What this means is that this value is tied to a property of one of the application's named beans. In the example, this particular text field is tied to a property called <kbd>firstName</kbd> in a named bean called <kbd>customer</kbd>. When a user enters a value for this text field and submits the form, the corresponding property in the named bean is updated with this value. The tag's <kbd>required</kbd> attribute is optional; valid values for it are <kbd>true</kbd> and <kbd>false</kbd>. If this attribute is set to <kbd>true</kbd>, the container will not let the user submit the form until the user enters some data for the text field. If the user attempts to submit the form without entering a required value, the page will be reloaded and an error message will be displayed inside the <kbd>&lt;h:messages&gt;</kbd> tag:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/c9b523d5-2144-4efc-8ef1-bfc807dbccae.png" style="width:25.25em;height:16.83em;"/></div>
<p>The preceding screenshot illustrates the default error message shown when the user attempts to save the form in the example without entering a value for the customer's first name. The first part of the message (<span class="packt_screen">First Name</span>) is taken from the value of the <kbd>label</kbd> attribute of the corresponding <kbd>&lt;h:inputTextField&gt;</kbd> tag. The text of the message can be customized, as well as its style (font, color, and more.). We will cover how to do this later in the chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project stages</h1>
                </header>
            
            <article>
                
<p>Having a <kbd>&lt;h:messages&gt;</kbd> tag on every JSF page is a good idea; without it, the user might not see validation messages and will have no idea why the form submission is not going through. By default, JSF validation messages do not generate any output in the application server log. A common mistake new JSF developers make is failing to add a <kbd>&lt;h:messages&gt;</kbd> tag to their pages; without it, if validation fails, then the navigation seems to fail for no reason (the same page is rendered if navigation fails and, without a <kbd>&lt;h:messages&gt;</kbd> tag, no error messages are displayed in the browser).</p>
<p>To avoid this situation, JSF 2.0 introduced the concept of <strong>project stages</strong>.</p>
<p>The following project stages are defined in JSF 2.0 and newer versions:</p>
<ul>
<li>Production</li>
<li>Development</li>
<li>UnitTest</li>
<li>SystemTest</li>
</ul>
<p>We can define the project stage as an initialization parameter to the Faces servlet in <kbd>web.xml</kbd>, or as a custom JNDI resource. The preferred way of setting the project stage is through a custom JNDI resource.</p>
<div class="packt_infobox">The process to map global JNDI resources to component resources is application server-specific; when using GlassFish, a change needs to be made to the application's <kbd>web.xml</kbd>, plus we need to use a GlassFish-specific deployment descriptor.</div>
<p>Setting up a custom JNDI resource is application server-specific, consult your application server documentation for details. If we are using GlassFish to deploy our application, we can set up a custom JNDI by logging in to the web console, navigating to <span class="packt_screen">JNDI</span> | <span class="packt_screen">Custom Resources</span>, then clicking the <span class="packt_screen">New...</span> button:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/65263f05-a968-490d-b530-ecc2094d67ca.png" style="width:43.08em;height:29.92em;"/></div>
<p>In the resulting page, we need to enter the following information:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><span class="packt_screen">JNDI Name</span></p>
</td>
<td>
<p><kbd>javax.faces.PROJECT_STAGE</kbd></p>
</td>
</tr>
<tr>
<td>
<p><span class="packt_screen">Resource Type</span></p>
</td>
<td>
<p><kbd>java.lang.String</kbd></p>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>After entering these two values, the <span class="packt_screen">Factory Class</span> field will be automatically populated with the value : <kbd>org.glassfish.resources.custom.factory.PrimitivesAndStringFactory</kbd>.</p>
<p>After entering the values, we need to add a new property with a name of <span class="packt_screen">value</span> and a value corresponding to the project stage we want to use (<span class="packt_screen">Development</span>, in the preceding screenshot).</p>
<p>Setting the project stage allows us to perform some logic only if we are running in a specific stage. For instance, in one of our named beans, we could have code that looks like this:</p>
<pre>    Application application = facesContext.getApplication(); 
 
    if (application.getProjectStage().equals( 
        ProjectStage.Production)) { 
      //do production stuff 
    } else if (application.getProjectStage().equals( 
        ProjectStage.Development)) { 
      //do development stuff 
    } else if (application.getProjectStage().equals( 
        ProjectStage.UnitTest)) { 
      //do unit test stuff 
    } else if (application.getProjectStage().equals( 
        ProjectStage.SystemTest)) { 
      //do system test stuff 
    } </pre>
<p>As we can see, project stages allow us to modify our code's behavior for different environments. More importantly, setting the project stage allows the JSF engine to behave a bit differently based on the project stage setting. Relevant to our discussion, setting the project stage to Development results in additional logging statements in the application server log. Therefore, if we forget to add a <kbd>&lt;h:messages&gt;</kbd> tag to our page, our project stage is Development, and validation fails; a <span class="packt_screen">Validation Error</span> will be displayed on the page even if we omit the <kbd>&lt;h:messages&gt;</kbd> component:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/f5026fc8-5db0-4038-bf35-fc4368d3988b.png" style="width:25.58em;height:17.33em;"/></div>
<p>In the default <kbd>Production</kbd> stage, this error message is not displayed in the page, leaving us confused as to why our page navigation doesn't seem to be working.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validation</h1>
                </header>
            
            <article>
                
<p>Notice that each <kbd>&lt;h:inputField&gt;</kbd> tag has a nested <kbd>&lt;f:validateLength&gt;</kbd> tag. As its name implies, this tag validates that the entered value for the text field is between a minimum and maximum length. Minimum and maximum values are defined by the tag's <kbd>minimum</kbd> and <kbd>maximum</kbd> attributes. <kbd>&lt;f:validateLength&gt;</kbd> is one of the standard validators included with JSF. Just like with the <kbd>required</kbd> attribute of <kbd>&lt;h:inputText&gt;</kbd>, JSF will automatically display a default error message when a user attempts to submit a form with a value that does not validate:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/fbc4ee7f-2ba5-48b7-a7d3-dfa73575cb13.png" style="width:39.58em;height:16.75em;"/></div>
<p>Again, the default message and style can be overridden; we will cover how to do this later in the chapter.</p>
<p>In addition to <kbd>&lt;f:validateLength&gt;</kbd>, JSF includes other standard validators, which are listed in the following table:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Validation tag</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;f:validateBean&gt;</kbd></p>
</td>
<td>
<p>Bean validation allows us to validate named <kbd>bean</kbd> values by using annotations in our named beans without having to add validators to our JSF tags. This tag allows us to fine-tune bean validation if necessary.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;f:validateDoubleRange&gt;</kbd></p>
</td>
<td>
<p>Validates that the input is a valid <kbd>Double</kbd> value between the two values specified by the tag's <kbd>minimum</kbd> and <kbd>maximum</kbd> attributes, inclusive.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;f:validateLength&gt;</kbd></p>
</td>
<td>
<p>Validates that the input's length is between the values specified by the tag's <kbd>minimum</kbd> and <kbd>maximum</kbd> values, inclusive.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;f:validateLongRange&gt;</kbd></p>
</td>
<td>
<p>Validates that the input is a valid <kbd>Double</kbd> value between the values specified by the tag's <kbd>minimum</kbd> and <kbd>maximum</kbd> attributes, inclusive.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;f:validateRegex&gt;</kbd></p>
</td>
<td>
<p>Validates that the input matches a regular expression pattern specified in the tag's <kbd>pattern</kbd> attribute.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;f:validateRequired&gt;</kbd></p>
</td>
<td>
<p>Validates that the input is not empty. This tag is equivalent to setting the <kbd>required</kbd> attribute to <kbd>true</kbd> in the parent input field.</p>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Notice that in the description for <kbd>&lt;f:validateBean&gt;</kbd>, we briefly mentioned bean validation. The bean validation JSR aims to standardize JavaBean validation. JavaBeans are used across several other APIs that, up until recently, had to implement their own validation logic. JSF 2.0 adopted the bean validation standard to help validate named bean properties.</p>
<p>If we want to take advantage of bean validation, all we need to do is annotate the desired field with the appropriate bean validation annotation, without having to explicitly use a JSF validator.</p>
<div class="packt_infobox">For a complete list of bean validation annotations, refer to the <kbd>javax.validation.constraints</kbd> package in the Java EE 8 API at <a href="https://javaee.github.io/javaee-spec/javadocs/">https://javaee.github.io/javaee-spec/javadocs/</a><span>.</span><a href="http://docs.oracle.com/javaee/7/api/"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grouping components</h1>
                </header>
            
            <article>
                
<p><kbd>&lt;h:panelGroup&gt;</kbd> is the next new tag in the example. Typically, <kbd>&lt;h:panelGroup&gt;</kbd> is used to group several components together so that they occupy a single cell in an <kbd>&lt;h:panelGrid&gt;</kbd>. This can be accomplished by adding components inside <kbd>&lt;h:panelGroup&gt;</kbd> and adding <kbd>&lt;h:panelGroup&gt;</kbd> to <kbd>&lt;h:panelGrid&gt;</kbd>. As can be seen in the example, this particular instance of <kbd>&lt;h:panelGroup&gt;</kbd> has no child components. In this particular case, the purpose of <kbd>&lt;h:panelGroup&gt;</kbd> is to have an empty cell and have the next component, <kbd>&lt;h:commandButton&gt;</kbd>, align with all other input fields in the form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Form submission</h1>
                </header>
            
            <article>
                
<p><kbd>&lt;h:commandButton&gt;</kbd> renders an HTML submit button in the browser. Just like with standard HTML, its purpose is to submit the form. Its <kbd>value</kbd> attribute simply sets the button's label. This tag's <kbd>action</kbd> attribute is used for navigation; the next page to show is based on the value of this attribute. The <kbd>action</kbd> attribute can have a <kbd>String</kbd> constant or a <strong>method binding expression</strong>, meaning that it can point to a <kbd>method</kbd> in a named bean that returns a string.</p>
<p>If the base name of a page in our application matches the value of the <kbd>action</kbd> attribute of a <kbd>&lt;h:commandButton&gt;</kbd> tag, then we navigate to this page when clicking the button. This JSF feature frees us from having to define navigation rules, like we used to have to do in older versions of JSF. In our example, our confirmation page is called <kbd>confirmation.xhtml</kbd>; therefore by convention, this page will be shown when the button is clicked, since the value of its <kbd>action</kbd> attribute (confirmation) matches the base name of the page.</p>
<div class="packt_infobox">Even though the label for the button reads <span class="packt_screen">Save</span>, in our simple example, clicking on the button won't actually save any data.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Named beans</h1>
                </header>
            
            <article>
                
<p>There are two types of Java Beans that can interact with JSF pages: JSF managed beans and CDI named beans. JSF managed beans have been around since the first version of the JSF specification and can be used only in a JSF context. CDI named beans were introduced in Java EE 6 and can interoperate with other Java EE APIs, such as Enterprise JavaBeans. For this reason, CDI named beans are preferred over JSF managed beans.</p>
<p>To make a Java class a CDI named bean, all we need to do is make sure the class has a public, no argument constructor (one is created implicitly if there are no other constructors declared, which is the case in our example) and add the <kbd>@Named</kbd> annotation at the class level. Here is the managed bean for our example:</p>
<pre style="padding-left: 60px"><span>package net.ensode.glassfishbook.jsf;</span><br/>import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
 
<strong>@Named 
@RequestScoped</strong> 
public class Customer { 
 
  private String firstName; 
  private String lastName; 
  private String email; 
 
  public String getEmail() { 
    return email; 
  } 
 
  public void setEmail(String email) { 
    this.email = email; 
  } 
 
  public String getFirstName() { 
    return firstName; 
  } 
 
  public void setFirstName(String firstName) { 
    this.firstName = firstName; 
  } 
 
  public String getLastName() { 
    return lastName; 
  } 
 
  public void setLastName(String lastName) { 
    this.lastName = lastName; 
  } 
} </pre>
<p>The <kbd>@Named</kbd> class annotation designates this bean as a CDI named bean. This annotation has an optional <kbd>value</kbd> attribute we can use to give our bean a logical name for use in our JSF pages. However, by convention, the value of this attribute is the same as the class name (<kbd>Customer</kbd>, in our case), with its first character switched to lower case. In our example, we let this default behavior take place, therefore we access our bean's properties via the <kbd>customer</kbd> logical name. Notice the <kbd>value</kbd> attribute of any of the input fields in our example page to see this logical name in action.</p>
<p>Notice that, other than the <kbd>@Named</kbd> and <kbd>@RequestScoped</kbd> annotations, there is nothing special about this bean. It is a standard JavaBean with private properties and corresponding <kbd>getter</kbd> and <kbd>setter</kbd> methods. The <kbd>@RequestScoped</kbd> annotation specifies that the bean should live through a single request. The different named bean, scopes, available for our JSF applications, are covered in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Named bean scopes</h1>
                </header>
            
            <article>
                
<p>Managed beans always have a scope. A managed bean scope defines the lifespan of the application. The managed bean scope is defined by a class level annotation. The following table lists all valid managed bean scopes:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Named bean scope annotation</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>@ApplicationScoped</kbd></p>
</td>
<td>
<p>The same instance of application scoped named beans is available to all of our application's clients. If one client modifies the value of an application scoped managed bean, the change is reflected across clients.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@SessionScoped</kbd></p>
</td>
<td>
<p>An instance of each session scoped named bean is assigned to each of our application's clients. A session-scoped named bean can be used to hold client-specific data across requests.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@RequestScoped</kbd></p>
</td>
<td>
<p>Request scoped named beans only live through a single HTTP request.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Dependent</kbd></p>
</td>
<td>
<p>Dependent scoped named beans are assigned the same scope as the bean they are injected to.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@ConversationScoped</kbd></p>
</td>
<td>
<p>The conversation scope can span multiple requests, but is typically shorter than the session scope.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigation</h1>
                </header>
            
            <article>
                
<p>As can be seen in our input page, when clicking on the <span class="packt_screen">Save</span> button in the <kbd>customer_data_entry.xhtml</kbd> page, our application will navigate to a page called <kbd>confirmation.xhtml</kbd>. This happens because we are taking advantage of JSF's convention over configuration feature; if the value of the <kbd>action</kbd> attribute of a command button or link matches the base name of another page, then this navigation takes us to this page.</p>
<div class="packt_tip"><span class="packt_screen">Same page reloading when clicking on a button or link that should navigate to another page</span><span><span class="packt_screen">?</span></span> When JSF does not recognize the value of the <kbd>action</kbd> attribute of a command button or command link, it will by default navigate to the same page that was displayed in the browser when the user clicked on a button or link that is meant to navigate to another page.</div>
<p>If navigation does not seem to be working properly, chances are there is a typo in the value of this attribute. Remember that, by convention, JSF will look for a page whose base name matches the value of the <kbd>action</kbd> attribute of a command button or link.</p>
<p>The source for <kbd>confirmation.xhtml</kbd> looks like this:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
      &gt; 
  &lt;h:head&gt; 
    &lt;title&gt;Customer Data Entered&lt;/title&gt; 
  &lt;/h:head&gt; 
  &lt;h:body&gt; 
    &lt;h:panelGrid columns="2" columnClasses="rightAlign,leftAlign"&gt; 
      &lt;h:outputText value="First Name:"&gt;&lt;/h:outputText&gt; 
      &lt;h:outputText value="#{customer.firstName}"&gt;&lt;/h:outputText&gt; 
      &lt;h:outputText value="Last Name:"&gt;&lt;/h:outputText&gt; 
      &lt;h:outputText value="#{customer.lastName}"&gt;&lt;/h:outputText&gt; 
      &lt;h:outputText value="Email:"&gt;&lt;/h:outputText&gt; 
      &lt;h:outputText value="#{customer.email}"&gt;&lt;/h:outputText&gt; 
    &lt;/h:panelGrid&gt; 
  &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>The <kbd>&lt;h:outputText&gt;</kbd> is the only tag on this page we haven't covered before. This tag simply displays the value of its <kbd>value</kbd> attribute to the rendered page, its <kbd>value</kbd> attribute can be a simple string or a value binding expression. Since the value binding expressions in our <kbd>&lt;h:outputText&gt;</kbd> tags are the same expressions used in the previous page for the <kbd>&lt;h:inputText&gt;</kbd> tags, their values will correspond to the data the user entered:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/8c8ad334-ff9d-4320-9762-f4a565b8c32c.png" style="width:21.17em;height:11.42em;"/></div>
<p>In traditional (that is, non-JSF) Java web applications, we define URL patterns to be processed by specific servlets. Specifically for JSF, the suffixes <kbd>.jsf</kbd> or <kbd>.faces</kbd> are commonly used; another commonly used URL mapping for JSF is the <kbd>/faces</kbd> prefix. Under certain conditions, modern application servers automatically add all three mappings to the faces <kbd>servlet</kbd>, if these conditions are met, we don't have to specify any URL mappings at all.</p>
<p>If any of these conditions are met, then the FacesServlet will be automatically mapped:</p>
<ul>
<li>There is a <kbd>faces-config.xml</kbd> file in the <kbd>WEB-INF</kbd> directory of our web application</li>
<li>There is a <kbd>faces-config.xml</kbd> file in the <kbd>META-INF</kbd> directory of one of the dependencies of our web application</li>
<li>There is a filename ending in <kbd>.faces-config.xml</kbd> in the <kbd>META-INF</kbd> directory of one of the dependencies of our web application</li>
<li>We declare a context parameter named <kbd>javax.faces.CONFIG_FILES</kbd> in our <kbd>web.xml</kbd> or a <kbd>web-fragment.xml</kbd> in one of the dependencies</li>
<li>We pass a non-empty set of classes when invoking the <kbd>onStartup()</kbd> method of <kbd>ServletContextInitializer</kbd></li>
</ul>
<p>When none of the preceding conditions are met, we need to explicitly map the Faces <kbd>servlet</kbd> in our <kbd>web.xml</kbd> deployment descriptor, as illustrated here:</p>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;web-app  
          
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" 
         version="3.1"&gt; 
<strong>    &lt;servlet&gt;</strong><strong>        <br/>        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;</strong><strong>     <br/>        &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet- <br/>         class&gt;</strong><strong>               <br/>        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</strong><strong>    <br/>    &lt;/servlet&gt;</strong><strong> <br/>    &lt;servlet-mapping&gt;</strong><strong>      <br/>        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;</strong><strong>   <br/>        &lt;url-pattern&gt;/faces/*&lt;/url-pattern&gt;</strong><strong>    <br/>    &lt;/servlet-mapping&gt;</strong> 
&lt;/web-app&gt; </pre>
<p>The URL we used for the pages in our application was the name of our Facelets pages, prefixed by <kbd>/faces</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom data validation</h1>
                </header>
            
            <article>
                
<p>In addition to providing standard validators for our use, JSF allows us to create <kbd>custom validator</kbd>s. This can be done in one of two waysâ€”by creating a <kbd>custom validator</kbd> class or by adding <kbd>validation</kbd> methods to our named beans.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom validators</h1>
                </header>
            
            <article>
                
<p>In addition to the standard validators, JSF allows us to create custom validators by creating a Java class implementing the <kbd>javax.faces.validator.Validator</kbd> interface.</p>
<p>The following class implements an email validator, which we will use to validate the email text input field in our customer data entry screen:</p>
<pre style="padding-left: 60px">package net.ensode.glassfishbook.jsfcustomval; 
 
import javax.faces.application.FacesMessage; 
import javax.faces.component.UIComponent; 
import javax.faces.component.html.HtmlInputText; 
import javax.faces.context.FacesContext; 
import javax.faces.validator.FacesValidator; 
import javax.faces.validator.Validator; 
import javax.faces.validator.ValidatorException; 
import org.apache.commons.lang3.StringUtils; 
 
<strong>@FacesValidator(value = "emailValidator")</strong> 
public class EmailValidator implements Validator { 
 
  @Override 
<strong>  public void validate(FacesContext facesContext,</strong><strong>  <br/>     UIComponent uiComponent,</strong><strong>   <br/>     Object value) throws ValidatorException {</strong> 
    org.apache.commons.validator.routines.EmailValidator emailValidator = 
        org.apache.commons.validator.routines.EmailValidator.getInstance(); 
    HtmlInputText htmlInputText = (HtmlInputText) uiComponent; 
 
    String email = (String) value; 
 
    if (!StringUtils.isEmpty(email)) { 
      if (!emailValidator.isValid(email)) { 
        FacesMessage facesMessage = new FacesMessage(htmlInputText. 
            getLabel() 
            + ": email format is not valid"); 
        throw new ValidatorException(facesMessage); 
      } 
    } 
  } 
} </pre>
<p>The <kbd>@FacesValidator</kbd> annotation registers our class as a JSF custom validator class. The value of its <kbd>value</kbd> attribute is the logical name that JSF pages can use to refer to it.</p>
<p>As can be seen in the example, the only method we need to implement when implementing the Validator interface is a method called <kbd>validate()</kbd>. This method takes three parametersâ€”an instance of <kbd>javax.faces.context.FacesContext</kbd>, an instance of <kbd>javax.faces.component.UIComponent</kbd>, and an object. Typically, application developers only need to be concerned with the last two. The second parameter is the component whose data we are validating, the third parameter is the actual value. In the example, we cast <kbd>uiComponent</kbd> to <kbd>javax.faces.component.html.HtmlInputText</kbd>; this way, we get access to its <kbd>getLabel()</kbd> method, which we can use as part of the error message.</p>
<p>If the entered value is not an invalid email address format, a new instance of <kbd>javax.faces.application.FacesMessage</kbd> is created, passing the error message to be displayed in the browser as its <kbd>constructor</kbd> parameter. We then throw a new <kbd>javax.faces.validator.ValidatorException</kbd>. The error message is then displayed in the browser; it gets there behind the scenes via the JSF API.</p>
<div class="packt_tip"><span><span class="packt_screen"><strong>Apache Commons Validator</strong></span></span>: Our custom JSF validator uses <kbd>Apache Commons Validator</kbd> to do the actual validation. This library includes many common validations such as dates, credit card numbers, ISBN numbers, and emails. When implementing a custom validator, it's worth investigating whether this library already has a validator that we can use.</div>
<p>In order to use our validator on our page, we need to use the <kbd>&lt;f:validator&gt;</kbd> JSF tag. The following Facelets page is a modified version of the customer data entry screen. This version uses the <kbd>&lt;f:validator&gt;</kbd> tag to validate email:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
       
      &gt; 
  &lt;h:head&gt; 
    &lt;title&gt;Enter Customer Data&lt;/title&gt; 
  &lt;/h:head&gt; 
  &lt;h:body&gt; 
    &lt;h:outputStylesheet library="css" name="styles.css"/&gt; 
    &lt;h:form&gt; 
      &lt;h:messages&gt;&lt;/h:messages&gt; 
      &lt;h:panelGrid columns="2" 
       columnClasses="rightAlign,leftAlign"&gt; 
        &lt;h:outputText value="First Name:"&gt; 
        &lt;/h:outputText&gt; 
        &lt;h:inputText label="First Name" 
         value="#{customer.firstName}" 
         required="true"&gt; 
          &lt;f:validateLength minimum="2" maximum="30"&gt; 
          &lt;/f:validateLength&gt; 
        &lt;/h:inputText&gt; 
        &lt;h:outputText value="Last Name:"&gt;&lt;/h:outputText&gt; 
        &lt;h:inputText label="Last Name" 
         value="#{customer.lastName}" 
         required="true"&gt; 
          &lt;f:validateLength minimum="2" maximum="30"&gt; 
          &lt;/f:validateLength&gt; 
        &lt;/h:inputText&gt; 
        &lt;h:outputText value="Email:"&gt; 
        &lt;/h:outputText&gt; 
<strong>        &lt;h:inputText label="Email" value="#{customer.email}"&gt;          </strong><strong>           <br/>          &lt;f:validator validatorId="emailValidator" /&gt;</strong><strong>        <br/>        &lt;/h:inputText&gt;</strong> 
        &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt; 
        &lt;h:commandButton action="confirmation" value="Save"&gt; 
        &lt;/h:commandButton&gt; 
      &lt;/h:panelGrid&gt; 
    &lt;/h:form&gt; 
  &lt;/h:body&gt; 
&lt;/html&gt;</pre>
<p>After writing our custom validator and modifying our page to take advantage of it, we can see our <kbd>validator</kbd> in action:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/af2c0ad7-d199-425b-8d34-e6ca0ba446bc.png" style="width:21.25em;height:17.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validator methods</h1>
                </header>
            
            <article>
                
<p>Another way we can implement custom validation is by adding <kbd>validation</kbd> methods to one or more of the application's named beans. The following <kbd>Java</kbd> class illustrates the use of <kbd>validator</kbd> methods for JSF validation:</p>
<pre style="padding-left: 60px">package net.ensode.glassfishbook.jsfcustomval; 
 
import javax.enterprise.context.RequestScoped; 
import javax.faces.application.FacesMessage; 
import javax.faces.component.UIComponent; 
import javax.faces.component.html.HtmlInputText; 
import javax.faces.context.FacesContext; 
import javax.faces.validator.ValidatorException; 
import javax.inject.Named; 
 
import org.apache.commons.lang3.StringUtils; 
 
@Named 
@RequestScoped 
public class AlphaValidator { 
 
<strong>  public void validateAlpha(FacesContext facesContext,</strong><strong>       <br/>      UIComponent uiComponent,</strong><strong>     <br/>      Object value) throws ValidatorException {</strong> 
    if (!StringUtils.isAlphaSpace((String) value)) { 
      HtmlInputText htmlInputText = (HtmlInputText) uiComponent; 
      FacesMessage facesMessage = new FacesMessage(htmlInputText. 
          getLabel() 
          + ": only alphabetic characters are allowed."); 
      throw new ValidatorException(facesMessage); 
    } 
  } 
} </pre>
<p>In this example, the class contains only the <kbd>validator</kbd> method, but that does not always have to be the case. We can give our <kbd>validator</kbd> method any name we want; however its return value must be <kbd>void</kbd>, and it must take the three parameters illustrated in the example, in that order. In other words, except for the method name, the signature of a <kbd>validator</kbd> method must be identical to the signature of the <kbd>validate()</kbd> method defined in the <kbd>javax.faces.validator.Validator</kbd> interface.</p>
<p>As we can see, the body of the preceding <kbd>validator</kbd> method is nearly identical to the body of our <kbd>custom validator</kbd> class, <kbd>validate()</kbd> method. We check the value entered by the user to make sure it contains only alphabetic characters and/or spaces; if it does not, then we throw a <kbd>ValidatorException</kbd> passing an instance of <kbd>FacesMessage</kbd> containing an appropriate error message <kbd>String</kbd>: <kbd>StringUtils</kbd>.</p>
<div class="packt_tip">In the example, we used <kbd>org.apache.commons.lang3.StringUtils</kbd> to perform the actual validation logic. In addition to the method used in the example, this class contains several methods for verifying that a <kbd>String</kbd> is numeric or alphanumeric. This class, part of the <kbd>Apache Commons Lang</kbd> library, is very useful when writing <kbd>custom validators</kbd>.</div>
<p>Since every <kbd>validator</kbd> method must be in a named bean, we need to make sure the class containing our <kbd>validator</kbd> method is annotated with the <kbd>@Named</kbd> annotation, as illustrated in our example.</p>
<p>The last thing we need to do to use our <kbd>validator</kbd> method is to bind it to our component via the tag's <kbd>validator</kbd> attribute:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
       
      &gt; 
  &lt;h:head&gt; 
    &lt;title&gt;Enter Customer Data&lt;/title&gt; 
  &lt;/h:head&gt; 
  &lt;h:body&gt; 
    &lt;h:outputStylesheet library="css" name="styles.css"/&gt; 
    &lt;h:form&gt; 
      &lt;h:messages&gt;&lt;/h:messages&gt; 
      &lt;h:panelGrid columns="2" 
                   columnClasses="rightAlign,leftAlign"&gt; 
        &lt;h:outputText value="First Name:"&gt; 
        &lt;/h:outputText&gt; 
<strong>        &lt;h:inputText label="First Name"</strong><strong>              <br/>         value="#{customer.firstName}"</strong><strong>                                  <br/>         required="true"</strong><strong>                      <br/>         validator="#{alphaValidator.validateAlpha}"&gt;</strong> 
          &lt;f:validateLength minimum="2" maximum="30"&gt; 
          &lt;/f:validateLength&gt; 
<strong>        &lt;/h:inputText&gt;</strong> 
        &lt;h:outputText value="Last Name:"&gt;&lt;/h:outputText&gt; 
<strong>        &lt;h:inputText label="Last Name" <br/></strong><strong>         value="#{customer.lastName}"</strong><strong>                      <br/>         required="true"</strong><strong>                      <br/>         validator="#{alphaValidator.validateAlpha}"&gt;</strong> 
          &lt;f:validateLength minimum="2" maximum="30"&gt; 
          &lt;/f:validateLength&gt; 
<strong>        &lt;/h:inputText&gt;</strong> 
        &lt;h:outputText value="Email:"&gt; 
        &lt;/h:outputText&gt; 
        &lt;h:inputText label="Email" value="#{customer.email}"&gt; 
          &lt;f:validateLength minimum="3" maximum="30"&gt; 
          &lt;/f:validateLength&gt; 
          &lt;f:validator validatorId="emailValidator" /&gt; 
        &lt;/h:inputText&gt; 
        &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt; 
        &lt;h:commandButton action="confirmation" value="Save"&gt; 
        &lt;/h:commandButton&gt; 
      &lt;/h:panelGrid&gt; 
    &lt;/h:form&gt; 
  &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>Since neither the first name nor the last name fields should accept anything other than alphabetic characters or spaces, we added our custom validator method to both of these fields.</p>
<p>Notice that the value of the <kbd>validator</kbd> attribute of the <kbd>&lt;h:inputText&gt;</kbd> tag is a JSF expression language; it uses the default named bean name for the bean containing our <kbd>validation</kbd> method. <kbd>alphaValidator</kbd> is the name of our bean, and <kbd>validateAlpha</kbd> is the name of our <kbd>validator</kbd> method.</p>
<p>After modifying our page to use our <kbd>custom validator</kbd>, we can now see it in action:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/d965e629-306a-42b9-80da-0ab5d7db9792.png" style="width:37.92em;height:17.83em;"/></div>
<p>Notice how, for the <span class="packt_screen">First Name</span> field, both our custom validator message and the standard length validator were executed.</p>
<p>Implementing <kbd>validator</kbd> methods have the advantage of not having the overhead of creating a whole class just for a single <kbd>validator</kbd> method (our example does just that, but in many cases, <kbd>validator</kbd> methods are added to an existing named bean containing other methods); however, the disadvantage is that each component can only be validated by a single <kbd>validator</kbd> method. When using <kbd>validator</kbd> classes, several <kbd>&lt;f:validator&gt;</kbd> tags can be nested inside the tag to be validated, therefore multiple validations, both custom and standard, can be done on the field.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing JSF's default messages</h1>
                </header>
            
            <article>
                
<p>Like we mentioned earlier, it is possible to customize the style (font, color, text, and so on) of JSF's default validation messages. Additionally, it is possible to modify the text of default JSF validation messages. In the following sections, we will explain how to modify error message formatting and text.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing message styles</h1>
                </header>
            
            <article>
                
<p>Customizing message styles can be done via <strong>Cascading Style Sheets</strong> (<strong>CSS</strong>). This can be accomplished by using the <kbd>&lt;h:message&gt;</kbd>, <kbd>style</kbd>, or <kbd>styleClass</kbd> attributes. The <kbd>style</kbd> attribute is used when we want to declare the CSS style inline. The <kbd>styleClass</kbd> attribute is used when we want to use a predefined style in a CSS style sheet or inside a <kbd>&lt;style&gt;</kbd> tag in our page.</p>
<p>The following markup illustrates using the <kbd>styleClass</kbd> attribute to alter the style of error messages; it is a modified version of the input page we saw in the previous section:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
       
      &gt; 
  &lt;h:head&gt; 
    &lt;title&gt;Enter Customer Data&lt;/title&gt; 
  &lt;/h:head&gt; 
  &lt;h:body&gt; 
    &lt;h:outputStylesheet library="css" name="styles.css" /&gt; 
    &lt;h:form&gt; 
<strong>      &lt;h:messages styleClass="errorMsg"&gt;&lt;/h:messages&gt;</strong> 
      &lt;h:panelGrid columns="2" 
                   columnClasses="rightAlign,leftAlign"&gt; 
        &lt;h:outputText value="First Name:"&gt; 
        &lt;/h:outputText&gt; 
        &lt;h:inputText label="First Name" 
         value="#{customer.firstName}" 
         required="true" validator="# <br/>         {alphaValidator.validateAlpha}"&gt; 
          &lt;f:validateLength minimum="2" maximum="30"&gt; 
          &lt;/f:validateLength&gt; 
        &lt;/h:inputText&gt; 
        &lt;h:outputText value="Last Name:"&gt;&lt;/h:outputText&gt; 
        &lt;h:inputText label="Last Name" 
         value="#{customer.lastName}" 
         required="true" 
         validator="#{alphaValidator.validateAlpha}"&gt; 
          &lt;f:validateLength minimum="2" maximum="30"&gt; 
          &lt;/f:validateLength&gt; 
        &lt;/h:inputText&gt; 
        &lt;h:outputText value="Email:"&gt; 
        &lt;/h:outputText&gt; 
        &lt;h:inputText label="Email" value="#{customer.email}"&gt; 
          &lt;f:validator validatorId="emailValidator" /&gt; 
        &lt;/h:inputText&gt; 
        &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt; 
        &lt;h:commandButton action="confirmation" value="Save"&gt; 
        &lt;/h:commandButton&gt; 
      &lt;/h:panelGrid&gt; 
    &lt;/h:form&gt; 
  &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>The only difference between this page and the previous one is the use of the <kbd>styleClass</kbd> attribute of the <kbd>&lt;h:messages&gt;</kbd> tag. As we mentioned earlier, the value of the <kbd>styleClass</kbd> attribute must match the name of a CSS style defined in a cascading stylesheet that our page has access to.</p>
<p>In our case, we defined a CSS style for messages as follows:</p>
<pre style="padding-left: 60px">.errorMsg { 
  color: red; 
} </pre>
<p>Then we used this style as the value of the <kbd>styleClass</kbd> attribute of our <kbd>&lt;h:messages&gt;</kbd> tag.</p>
<p>The following screenshot illustrates how the validation error messages look after implementing this change:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/2f7df965-7cf7-4f95-8a8e-5cd220649e66.png" style="width:30.67em;height:19.25em;"/></div>
<p>In this particular case, we just set the color of the error message text to red, but we are only limited only by CSS capabilities in setting the style of the error messages.</p>
<p>Pretty much any standard JSF component has both a <kbd>style</kbd> and a <kbd>styleClass</kbd> attribute that can be used to alter its style. The former is used for predefined CSS styles, the latter is used for inline CSS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing message text</h1>
                </header>
            
            <article>
                
<p>Sometimes it is desirable to override the text of JSF's default validation errors. Default validation errors are defined in a resource bundle called <kbd>Messages.properties</kbd>. This file can typically be found inside one of the JSF JAR Files included with your application server. For example, GlassFish includes it inside a JAR file called <kbd>javax.faces.jar</kbd> file under <kbd>[glassfish installation directory]/glassfish/modules</kbd>. The file contains several messages; we are only interested in validation errors at this point. The default validation error messages are defined as follows:</p>
<pre><strong>javax.faces.validator.DoubleRangeValidator.MAXIMUM={1}: Validation Error: Value is greater than allowable maximum of "{0}" 
javax.faces.validator.DoubleRangeValidator.MINIMUM={1}: Validation Error: Value is less than allowable minimum of ''{0}'' 
javax.faces.validator.DoubleRangeValidator.NOT_IN_RANGE={2}: Validation Error: Specified attribute is not between the expected values of {0} and {1}. 
javax.faces.validator.DoubleRangeValidator.TYPE={0}: Validation Error: Value is not of the correct type 
javax.faces.validator.LengthValidator.MAXIMUM={1}: Validation Error: Length is greater than allowable maximum of ''{0}'' 
javax.faces.validator.LengthValidator.MINIMUM={1}: Validation Error: Length is less than allowable minimum of ''{0}'' 
javax.faces.validator.LongRangeValidator.MAXIMUM={1}: Validation Error: Value is greater than allowable maximum of ''{0}'' 
javax.faces.validator.LongRangeValidator.MINIMUM={1}: Validation Error: Value is less than allowable minimum of ''{0}'' 
javax.faces.validator.LongRangeValidator.NOT_IN_RANGE={2}: Validation Error: Specified attribute is not between the expected values of {0} and {1}. 
javax.faces.validator.LongRangeValidator.TYPE={0}: Validation Error: Value is not of the correct type. 
javax.faces.validator.NOT_IN_RANGE=Validation Error: Specified attribute is not between the expected values of {0} and {1}. 
javax.faces.validator.RegexValidator.PATTERN_NOT_SET=Regex pattern must be set. 
javax.faces.validator.RegexValidator.PATTERN_NOT_SET_detail=Regex pattern must be set to non-empty value. 
javax.faces.validator.RegexValidator.NOT_MATCHED=Regex Pattern not matched 
javax.faces.validator.RegexValidator.NOT_MATCHED_detail=Regex pattern of ''{0}'' not matched 
javax.faces.validator.RegexValidator.MATCH_EXCEPTION=Error in regular expression. 
javax.faces.validator.RegexValidator.MATCH_EXCEPTION_detail=Error in regular expression, ''{0}'' 
javax.faces.validator.BeanValidator.MESSAGE={0}</strong> </pre>
<p>In order to override the default error messages, we need to create our own resource bundle, using the same keys used in the default one, but altering the values to suit our needs. Here is a very simple customized resource bundle for our application. For example, to overwrite the message for minimum length validation, we would add the following property to our custom resource bundle:</p>
<pre style="padding-left: 60px">javax.faces.validator.LengthValidator.MINIMUM={1}: minimum allowed length is ''{0}'' </pre>
<p>In this resource bundle, we override the error message for when the value entered for a field validated by the <kbd>&lt;f:validateLength&gt;</kbd> tag is less than the allowed minimum. In order to let our application know that we have a custom resource bundle for message properties, we need to modify the application's <kbd>faces-config.xml</kbd> file:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8'?&gt; 
&lt;faces-config version="2.0" 
       
       
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
      http://java.sun.com/xml/ns/javaee/web-facesconfig_2_0.xsd"&gt; 
<strong>  &lt;application&gt;</strong><strong>    <br/>   &lt;message-bundle&gt;net.ensode.Messages&lt;/message-bundle&gt;</strong><strong>   <br/>  &lt;/application&gt;</strong> 
&lt;/faces-config&gt; </pre>
<p>As we can see, the only thing we need to do to the application's <kbd>faces-config.xml</kbd> file is to add a <kbd>&lt;message-bundle&gt;</kbd> element indicating the name and location of the resource bundle containing our custom messages.</p>
<div class="packt_infobox">Custom error message text definitions are one of the few cases where we still need to define a <kbd>faces-config.xml</kbd> file for modern JSF applications. However, notice how simple our <kbd>faces-config.xml</kbd> file is, a far cry from a typical <kbd>faces-config.xml</kbd> for JSF 1.x, which typically contains named bean definitions, navigation rules, and JSF validator definitions.</div>
<p>After adding our custom message resource bundle and modifying the application's<br/>
<kbd>faces-config.xml</kbd> file, we can see our custom validation message in action:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/563474d0-7122-4845-a9e0-7f4eccceb068.png" style="width:47.92em;height:22.17em;"/></div>
<p>As can be seen in the screenshot, if we haven't overridden a validation message, the default will still be displayed. In our resource bundle we only overrode the minimum length validation error message, therefore our custom error message is shown in the <span class="packt_screen">First Name</span> text field. Since we didn't override the error message in the other standard JSF validators, the default error message is shown for each one of them. The email validator is the custom validator we developed previously in this chapter; since it is a custom validator, its error message is not affected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ajax-enabling JSF applications</h1>
                </header>
            
            <article>
                
<p>JSF allows us to easily implement <strong>Ajax</strong> (<strong>Asynchronous JavaScript and XML</strong>) functionality into our web applications by simply employing the <kbd>&lt;f:ajax&gt;</kbd> tag and CDI named beans, without needing to implement any JavaScript code or having to parse JSON strings to implement Ajax with JSF.</p>
<p>The following illustrates a typical usage of the <kbd>&lt;f:ajax&gt;</kbd> tag:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
       
      &gt; 
  &lt;h:head&gt; 
    &lt;title&gt;JSF Ajax Demo&lt;/title&gt; 
  &lt;/h:head&gt; 
  &lt;h:body&gt; 
    &lt;h2&gt;JSF Ajax Demo&lt;/h2&gt; 
    &lt;h:form&gt; 
      &lt;h:messages/&gt; 
      &lt;h:panelGrid columns="2"&gt; 
 
        &lt;h:outputText value="Echo input:"/&gt; 
<strong>        &lt;h:inputText id="textInput" value="#{controller.text}"&gt;</strong><strong>           <br/>         &lt;f:ajax render="textVal" event="keyup"/&gt;</strong><strong>      <br/>        &lt;/h:inputText&gt;</strong> 
 
        &lt;h:outputText value="Echo output:"/&gt; 
        &lt;h:outputText id="textVal" value="#{controller.text}"/&gt; 
      &lt;/h:panelGrid&gt; 
      &lt;hr/&gt; 
      &lt;h:panelGrid columns="2"&gt; 
        &lt;h:panelGroup/&gt; 
        &lt;h:panelGroup/&gt; 
        &lt;h:outputText value="First Operand:"/&gt; 
        &lt;h:inputText id="first" value="#{controller.firstOperand}" <br/>        size="3"/&gt; 
        &lt;h:outputText value="Second Operand:"/&gt; 
        &lt;h:inputText id="second" <br/>         value="#{controller.secondOperand}"  <br/>         size="3"/&gt; 
        &lt;h:outputText value="Total:"/&gt; 
        &lt;h:outputText id="sum" value="#{controller.total}"/&gt; 
<strong>        &lt;h:commandButton <br/>         actionListener="#{controller.calculateTotal}"</strong><strong>                            <br/>                         value="Calculate Sum"&gt;</strong><strong>  <br/>        &lt;f:ajax execute="first second" render="sum"/&gt;</strong><strong>         <br/>      &lt;/h:commandButton&gt;</strong> 
      &lt;/h:panelGrid&gt; 
    &lt;/h:form&gt; 
  &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>After deploying our application, the preceding page renders as illustrated in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/ba04663c-2313-471b-9b86-7d2275a284f7.png" style="width:19.42em;height:20.25em;"/></div>
<p>The preceding page illustrates two uses of the <kbd>&lt;f:ajax&gt;</kbd> tag. At the top of the page, we use this tag by implementing a typical Ajax Echo example, in which we have a <kbd>&lt;h:outputText&gt;</kbd> component updating itself with the value of an input text component. Whenever any character is entered into the input field, the value of the <kbd>&lt;h:outputText&gt;</kbd> component is automatically updated.</p>
<p>To implement the functionality described in the previous paragraph, we put an <kbd>&lt;f:ajax&gt;</kbd> tag inside an <kbd>&lt;h:inputText&gt;</kbd> tag. The value of the <kbd>render</kbd> attribute of the <kbd>&lt;f:ajax&gt;</kbd> tag must correspond to the ID of a component we want to update after the Ajax request finishes. In our particular example, we want to update the <kbd>&lt;h:outputText&gt;</kbd> component with an ID of <kbd>textVal</kbd>, therefore this is the value we use for the render attribute of our <kbd>&lt;f:ajax&gt;</kbd> tag.</p>
<div class="packt_infobox">In some cases we may need to render more than one JSF component after an Ajax event finishes. In order to accommodate this, we can add several IDs as the value of the <kbd>render</kbd> attribute, we simply need to separate them by spaces.</div>
<p>The other <kbd>&lt;f:ajax&gt;</kbd> attribute we used in this instance is the <kbd>event</kbd> attribute. This attribute indicates the JavaScript event that triggers the Ajax event. In this particular case we need to trigger the event any time a key is released while a user is typing into the input field; therefore the appropriate event is to use is <kbd>keyup</kbd>.</p>
<p>The following table lists all supported JavaScript events:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Event</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>blur</kbd></p>
</td>
<td>
<p>The component loses focus.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>change</kbd></p>
</td>
<td>
<p>The component loses focus and its value has been modified.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>click</kbd></p>
</td>
<td>
<p>The component is clicked on.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>dblclick</kbd></p>
</td>
<td>
<p>The component is double-clicked on.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>focus</kbd></p>
</td>
<td>
<p>The component gains focus.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>keydown</kbd></p>
</td>
<td>
<p>A key is pressed while the component has focus.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>keypress</kbd></p>
</td>
<td>
<p>A key is pressed or held down while the component has focus.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>keyup</kbd></p>
</td>
<td>
<p>A key is released while the component has focus.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mousedown</kbd></p>
</td>
<td>
<p>Mouse button is pressed while the component has focus.</p>
</td>
</tr>
<tr>
<td><kbd>mousemove</kbd></td>
<td>
<p>Mouse pointer is moved over the component.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mouseout</kbd></p>
</td>
<td>
<p>Mouse pointer leaves the component.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mouseover</kbd></p>
</td>
<td>
<p>Mouse pointer is placed over the component.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mouseup</kbd></p>
</td>
<td>
<p>Mouse button is released while the component has focus.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>select</kbd></p>
</td>
<td>
<p>The component's text is selected.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>valueChange</kbd></p>
</td>
<td>
<p>Equivalent to change; the component loses focus and its value has been modified.</p>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>We use <kbd>&lt;f:ajax&gt;</kbd> once again further down in the page, to Ajax-enable a command button component. In this instance, we want to recalculate a value based on the value of two input components. In order to have the values on the server updated with the latest user input, we used the <kbd>execute</kbd> attribute of <kbd>&lt;f:ajax&gt;</kbd>; this attribute takes a space-separated list of component IDs for use as input. We then use the <kbd>render</kbd> attribute just like before to specify which components need to be re-rendered after the Ajax request finishes.</p>
<p>Notice we are using the <kbd>actionListener</kbd> attribute of <kbd>&lt;h:commandButton&gt;</kbd>. This attribute is typically used whenever we don't need to navigate to another page after clicking the button. The value for this attribute is an <kbd>action listener</kbd> method we wrote in one of our named beans. <kbd>Action listener</kbd> methods must return <kbd>void</kbd>, and take an instance of <kbd>javax.faces.event.ActionEvent</kbd> as its sole parameter.</p>
<p>The named bean for our application looks like this:</p>
<pre style="padding-left: 60px">package net.ensode.glassfishbook.jsfajax;<br/>import javax.faces.event.ActionEvent;<br/>import javax.faces.view.ViewScoped;<br/>import javax.inject.Named;<br/>@Named<br/>@ViewScoped<br/>public class Controller {<br/>  private String text;<br/>  private int firstOperand;<br/>  private int secondOperand;<br/>  private int total;<br/>  public Controller() {<br/>  }<br/><strong>  public void calculateTotal(ActionEvent actionEvent) {</strong><br/><strong>    total = firstOperand + secondOperand;</strong><br/><strong>  }</strong><br/>  public String getText() {<br/>    return text;<br/>  }<br/>  public void setText(String text) {<br/>    this.text = text;<br/>  }<br/>  public int getFirstOperand() {<br/>    return firstOperand;<br/>  }<br/>  public void setFirstOperand(int firstOperand) {<br/>    this.firstOperand = firstOperand;<br/>  }<br/>  public int getSecondOperand() {<br/>    return secondOperand;<br/>  }<br/>  public void setSecondOperand(int secondOperand) {<br/>    this.secondOperand = secondOperand;<br/>  }<br/>  public int getTotal() {<br/>    return total;<br/>  }<br/>  public void setTotal(int total) {<br/>    this.total = total;<br/>  }<br/>}</pre>
<p>Notice that we didn't have to do anything special in our named bean to enable Ajax in our application. It is all controlled by the <kbd>&lt;f:ajax&gt;</kbd> tag on the page.</p>
<p>As we can see from this example, Ajax-enabling JSF applications is very simple; we simply need to use a single tag to Ajax-enable our page, without having to write a single line of JavaScript, JSON, or XML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSF HTML5 support</h1>
                </header>
            
            <article>
                
<p>HTML5 is the latest version of the HTML specification and includes several improvements over the previous version of HTML. Modern versions of JSF include several features to make JSF pages work nicely with HTML5.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTML5-friendly markup</h1>
                </header>
            
            <article>
                
<p>Through the use of pass-through elements, we can develop our pages using HTML5 and also treat them as JSF components. To do this, we need to specify at least one element attributes using <a href="http://xmlns.jcp.org/jsf%20namespace"><span class="URLPACKT">http://xmlns.jcp.org/jsf</span> namespace</a>. The following example demonstrates this approach in action:</p>
<pre style="padding-left: 90px">&lt;!DOCTYPE html&gt;<br/>&lt;html <br/>      <strong>&gt;</strong><br/><strong>    &lt;head jsf:id="head"&gt;</strong><br/><strong>        &lt;title&gt;JSF Page with HTML5 Markup&lt;/title&gt;</strong><br/><strong>        &lt;link jsf:library="css" jsf:name="styles.css" rel="stylesheet"</strong><br/><strong>         type="text/css" href="resources/css/styles.css"/&gt;</strong><br/>    &lt;/head&gt;<br/>   <strong> &lt;body jsf:id="body"&gt;</strong><br/><strong>        &lt;form jsf:prependId="false"&gt;</strong><br/>            &lt;table style="border-spacing: 0; border-collapse:  <br/>             collapse"&gt;<br/>                &lt;tr&gt;<br/>                     &lt;td class="rightAlign"&gt;<br/>                      <strong>&lt;label jsf:for="firstName"&gt;First  <br/>                       Name&lt;/label&gt;</strong><br/>                    &lt;/td&gt;<br/>                    &lt;td class="leftAlign"&gt;<br/>                     <strong> &lt;input type="text" jsf:id="firstName"</strong><br/><strong>                       jsf:value="#{customer.firstName}"/&gt;</strong><br/>                    &lt;/td&gt;<br/>                &lt;/tr&gt;<br/>                &lt;tr&gt;<br/>                    &lt;td class="rightAlign"&gt;<br/>                     <strong> &lt;label jsf:for="lastName"&gt;<br/>                       Last Name&lt;/label&gt;</strong><br/>                    &lt;/td&gt;<br/>                    &lt;td class="leftAlign"&gt;<br/>                     <strong> &lt;input type="text" jsf:id="lastName"<br/></strong>                       <strong>jsf:value="#{customer.lastName}"/&gt;</strong><br/>                       &lt;/td&gt;<br/>                &lt;/tr&gt;<br/>                &lt;tr&gt;<br/>                    &lt;td class="rightAlign"&gt;<br/>                      <strong>&lt;label jsf:for="email"&gt;Email  <br/>                      Address&lt;/label&gt;</strong><br/>                    &lt;/td&gt;<br/>                    &lt;td class="leftAlign"&gt;<br/><strong>                      &lt;input type="email" jsf:id="email"<br/></strong><br/><strong>                           jsf:value="#{customer.email}"/&gt;&lt;/td&gt;</strong><br/>                &lt;/tr&gt;<br/>                &lt;tr&gt;<br/>                    &lt;td&gt;&lt;/td&gt;<br/>                  &lt;td&gt;<br/>                    <strong>&lt;input type="submit"  <br/>                     jsf:action="confirmation"</strong><br/>                     value="Submit"/&gt;<br/>                  &lt;/td&gt;<br/>                &lt;/tr&gt;<br/>            &lt;/table&gt;<br/>        &lt;/form&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>The first thing we should notice about the preceding example is the XML namespace prefixed by <kbd>jsf</kbd> near the top of the page. This namespace allows us to add JSF-specific attributes to HTML5 pages. When the JSF runtime encounters attributes prefixed by <kbd>jsf</kbd> in any of the tags on the page, it automatically converts the HTML5 tag to the equivalent JSF component. JSF-specific attributes are the same as in regular JSF pages, except they are prefixed with <kbd>jsf</kbd> therefore, at this point, they should be self-explanatory and will not be discussed in detail.</p>
<p>The preceding example will render and behave just like the first example in this chapter.</p>
<p>The technique described in this section is useful if we have experienced HTML web designers in our team who prefer to have full control over the look of the page. The pages are developed using standard HTML5 with JSF-specific attributes so that the JSF runtime can manage user input.</p>
<p>If our team consists primarily of Java developers with limited CSS/HTML knowledge, then it is preferable to develop the web pages for our web application using JSF components. HTML5 introduced several new attributes that didn't exist in previous versions of HTML. For this reason, JSF 2.2 introduced the ability to add arbitrary attributes to JSF components; this JSF/HTML5 integration technique is discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pass-through attributes</h1>
                </header>
            
            <article>
                
<p>JSF allows the definition of any arbitrary attributes (not processed by the JSF engine); these attributes are simply rendered as-is on the generated HTML displayed in the browser. The following example is a new version of an earlier example in this chapter, modified to take advantage of the HTML5 pass-through attributes:</p>
<pre style="padding-left: 60px" class="mce-root"><span>&lt;?xml version='1.0' encoding='UTF-8' ?&gt;</span><br/><span>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"</span><br/>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;<br/>&lt;html <br/>      <br/>      <br/>      <strong>&gt;<br/>    </strong>&lt;h:head&gt;<br/>        &lt;title&gt;Enter Customer Data&lt;/title&gt;<br/>    &lt;/h:head&gt;<br/>    &lt;h:body&gt;<br/>        &lt;h:outputStylesheet library="css" name="styles.css"/&gt;<br/>        &lt;h:form id="customerForm"&gt;<br/>            &lt;h:messages/&gt;<br/>            &lt;h:panelGrid columns="2"<br/>             columnClasses="rightAlign,leftAlign"&gt;<br/>                &lt;h:outputLabel for="firstName" value="First Name:"&gt;                <br/>                &lt;/h:outputLabel&gt;<br/>                &lt;h:inputText id="firstName"<br/>                 label="First Name"<br/>                 value="#{customer.firstName}"<br/>                 required="true"<br/>                 <strong>p:placeholder="First Name"&gt;<br/>                    </strong>&lt;f:validateLength minimum="2" maximum="30"&gt;<br/>                    &lt;/f:validateLength&gt;<br/>                &lt;/h:inputText&gt;<br/>                &lt;h:outputLabel for="lastName" value="Last Name:"&gt;<br/>                &lt;/h:outputLabel&gt;<br/>                &lt;h:inputText id="lastName"<br/>                 label="Last Name"<br/>                 value="#{customer.lastName}"<br/>                 required="true"<br/>                 <strong>p:placeholder="Last Name"&gt;<br/>                   </strong>&lt;f:validateLength minimum="2" maximum="30"&gt;                    <br/>                    &lt;/f:validateLength&gt;<br/>                &lt;/h:inputText&gt;<br/>                &lt;h:outputLabel for="email" value="Email:"&gt;<br/>                &lt;/h:outputLabel&gt;<br/>                &lt;h:inputText id="email"<br/>                 label="Email"<br/>                 value="#{customer.email}"<br/>                 <strong>p:placeholder="Email Address"&gt;<br/>                    </strong>&lt;f:validateLength minimum="3" maximum="30"&gt;<br/>                    &lt;/f:validateLength&gt;<br/>                &lt;/h:inputText&gt;<br/>                &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt;<br/>                &lt;h:commandButton action="confirmation" <br/>                 value="Save"&gt;<br/>                &lt;/h:commandButton&gt;<br/>            &lt;/h:panelGrid&gt;<br/>        &lt;/h:form&gt;<br/>    &lt;/h:body&gt;<br/>&lt;/html&gt;</pre>
<p>The first thing we should notice about this example is the addition of the <kbd>http://xmlns.jcp.org/jsf/passthrough"&gt;http://xmlns.jcp.org/jsf/passthrough</kbd> namespace, which allows us to add any arbitrary attributes to our JSF components.</p>
<p>In our example, we added the HTML5 <kbd>placeholder</kbd> attribute to all input text fields in our page; as we can see, we need it to be prefixed by the defined prefix for the namespace at the top of the application (<kbd>p</kbd>, in our case). The placeholder HTML attribute simply adds some placeholder text to input fields that are automatically deleted once the user starts typing on the input field (this technique was commonly implemented <em>by hand</em> using JavaScript before HTML5).</p>
<p>The following screenshot shows our updated page in action:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/58586e76-7ec8-4a30-b922-80a65636d3d7.png" style="width:36.50em;height:14.67em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSF 2.2 Faces flows</h1>
                </header>
            
            <article>
                
<p>JSF 2.2 introduced Faces flows, which defines a scope that can span several pages. Flow scoped beans are created when the user enters a flow (a set of web pages), and are destroyed when the user leaves the flow.</p>
<p>Faces flows adopts the convention over configuration principle of JSF. The following conventions are typically used when developing applications employing faces flows:</p>
<ul>
<li>All pages in the flow must be placed in a directory whose name defines the name of the flow</li>
<li>An XML configuration file named after the directory name, and suffixed with <span class="packt_screen">-flow</span>, must exist inside the directory that contains the pages in the flow (the file may be empty, but it must exist)</li>
<li>The first page in the flow must be named after the directory name that contains the flow</li>
<li>The last page in the flow must not be located inside the directory containing the flow and must be named after the directory name and suffixed with <span class="packt_screen">-return</span></li>
</ul>
<p>The following screenshot illustrates these conventions:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/625ea753-8c0a-4de8-b33c-f1c06d98b2b3.png" style="width:21.33em;height:12.75em;"/></div>
<p>In the preceding example, we define a flow named <kbd>customerinfo</kbd>; by convention, these files are inside a directory named <kbd>customerinfo</kbd>, and the first page on the flow is named <kbd>customerinfo.xhtml</kbd> (there are no restrictions on the names of other pages in the flow). When we exit the flow, we navigate to a page named <kbd>flowname-return.xml</kbd>; in our case, since our flow is named <kbd>customerinfo</kbd>, the name of the page in question is <kbd>customerinfo-return.xhtml</kbd>, which follows the naming convention and takes us out of the flow.</p>
<p>The markup for the pages doesn't illustrate anything we haven't seen before; therefore we will not show it. All example code is available as part of this book's code download bundle.</p>
<p>All of the previous pages store data in a named bean called <kbd>Customer</kbd>, which has a flow of scope:</p>
<pre style="padding-left: 60px">@Named 
<strong>@FlowScoped("customerinfo")</strong> 
public class Customer implements Serializable { 
   //class body omitted 
} </pre>
<p>The <kbd>@FlowScoped</kbd> annotation has a value attribute that must match the name of the flow that the bean is meant to work with (<kbd>customerinfo</kbd>, in this example).</p>
<p>This example creates a wizard-style set of pages in which data for a user is entered across several pages in the flow.</p>
<p>In the first page, we enter name information:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9e5d34d5-7a57-4861-8591-7d393a686bf0.png" style="width:28.42em;height:18.00em;"/></div>
<p>In the second page, we enter address information:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7a7d96a3-9280-4936-8a9d-f69924ca684a.png" style="width:26.08em;height:20.33em;"/></div>
<p>In the next page, we enter phone number information:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/646ffdc1-c73e-448b-b538-0596aaa7bb4a.png" style="width:23.50em;height:15.33em;"/></div>
<p>Finally, we display a <span class="packt_screen">Confirmation</span> page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/77845a56-9aa1-4c2a-a2fc-f23416c8989e.png" style="width:23.92em;height:25.75em;"/></div>
<p>If the user verifies that the information is correct, we navigate outside the flow to <kbd>customerinfo-return.xhtml</kbd>; otherwise, we go back to the first page in the flow to allow the user to make any necessary corrections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting JSF artifacts</h1>
                </header>
            
            <article>
                
<p>The JSF specification predates CDI. As such, many JSF artifacts, such as <kbd>FacesContext</kbd> and <kbd>ExternalContext</kbd>, had to be obtained via <kbd>static entry</kbd> methods; this resulted in hard-to-read boilerplate code. JSF 2.3 introduces the ability to inject JSF artifacts via CDI's <kbd>@Inject</kbd> annotation, as seen in the following example:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jsfarbitrarymess; 
 
import java.io.Serializable; 
import javax.faces.application.FacesMessage; 
import javax.faces.context.FacesContext; 
import javax.faces.view.ViewScoped; 
import javax.inject.Inject; 
import javax.inject.Named; 
 
@Named 
@ViewScoped 
public class ArbitraryMessageController implements Serializable { 
 
<strong>    @Inject</strong><strong>    <br/>    FacesContext facesContext;</strong> 
 
    public void saveData() { 
        FacesMessage facesMessage = new  <br/>         FacesMessage(FacesMessage.SEVERITY_INFO, 
         "Data saved successfully", "All Data successfully  <br/>          saved."); 
        facesContext.addMessage(null, facesMessage); 
    } 
} </pre>
<p>In this example, we need an instance of <kbd>FacesContext</kbd> so that we can send an arbitrary message to an <kbd>&lt;h:messages&gt;</kbd> component; as of JSF 2.3, we can simply annotate our instance of <kbd>FacesContext</kbd> with CDI's <kbd>@Inject</kbd> annotation.</p>
<div class="packt_infobox"><a href="54a73845-4f4d-4129-a361-85c78007f495.xhtml">Chapter 5</a>, <em>Contexts and Dependency Injection,</em> covers CDI in detail.</div>
<p>In order for us to be able to successfully inject a JSF artifact into our CDI named beans, we need to add a CDI <kbd>beans.xml</kbd> deployment descriptor to the <kbd>WEB-INF</kbd> directory of our WAR file, making sure to set the <kbd>bean-discovery-mode</kbd> attribute of its <kbd>&lt;beans&gt;</kbd> tag to all:</p>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;beans  
        
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee  
                           http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd" 
<strong>       bean-discovery-mode="all"&gt;</strong> 
&lt;/beans&gt; </pre>
<p>Additionally, we need to have a class in our WAR file annotated with the <kbd>@FacesConfig</kbd> annotation (we use this annotation to specify we are using JSF 2.3):</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jsfarbitrarymess.config; 
 
import javax.faces.annotation.FacesConfig; 
 
<strong>@FacesConfig(version = FacesConfig.Version.JSF_2_3)</strong> 
public class ConfigurationBean { 
 
} </pre>
<p>As can be seen in the preceding example, the class containing the <kbd>@FacesConfig</kbd> annotation doesn't have to have any code. We specify that we are using JSF 2.3 by passing <kbd>FacesConfig.Version.JSF_2_3</kbd> as the value of the annotation's version attribute.</p>
<p>In addition to illustrating how to inject the JSF artifact, this example illustrates a JSF feature we haven't seen beforeâ€”the ability to send arbitrary messages to an <kbd>&lt;h:messages&gt;</kbd> component via the <kbd>addMessage()</kbd> method of <kbd>FacesContext</kbd>. Next, we show the markup corresponding to the preceding CDI named bean:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
       
      &gt; 
    &lt;h:head&gt; 
        &lt;title&gt;JSF Arbitrary Messages Demo&lt;/title&gt; 
    &lt;/h:head&gt; 
    &lt;h:body&gt; 
        &lt;h:outputStylesheet library="css" name="styles.css"/&gt; 
<strong>        &lt;h:messages id="messages" /&gt;</strong> 
        &lt;h:form&gt; 
            &lt;h:panelGrid columns="2" 
             columnClasses="rightAlign,leftAlign"&gt; 
                 &lt;!-- Irrelevant markup omitted for brevity --&gt; 
<strong>                &lt;h:commandButton </strong><strong>    <br/>                actionListener="#     <br/>                {arbitraryMessageController.saveData()}"         </strong><strong>                    <br/>                 value="Save"&gt;</strong><strong>          <br/>               &lt;f:ajax render="messages"/&gt;</strong><strong>                 <br/>               &lt;/h:commandButton&gt;</strong> 
            &lt;/h:panelGrid&gt; 
        &lt;/h:form&gt; 
    &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>When the user clicks on the button generated by the <kbd>&lt;h:commandButton&gt;</kbd> component, the <kbd>saveData()</kbd> method of our CDI named bean is invoked, which in turn creates an instance of <kbd>FacesMessage</kbd> and passes it to the <kbd>addMessage()</kbd> method of <kbd>FacesContext</kbd>, resulting in the message being shown in the browser.</p>
<div class="packt_infobox">In case it isn't obvious, this simple example doesn't actually save any data; all we are illustrating here is how to pass arbitrary messages to the JSF <kbd>&lt;h:messages&gt;</kbd> component.</div>
<p><span>The following screenshot assumes the user has already pressed the</span> <span class="packt_screen">Save</span> <span>button. The message at the top is the result of our invocation to the</span> <kbd>addMessage()</kbd> <span>method of</span> <kbd>FacesContext</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6a333c2a-0350-4ff5-8cdf-69e8af7a6f78.png" style="width:17.83em;height:17.58em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSF WebSocket support</h1>
                </header>
            
            <article>
                
<p>In typical web applications, servers always respond to requests from a browser; there is no way for a server to send data to the client browser without responding to a request. <strong>WebSocket</strong> technology provides full duplex communication between a browser and a server, allowing servers to independently send data to a client, without having to respond to a request. WebSocket technology allows a myriad of new applications to be developed for the web, including updating stock tickers, multiplayer online games, and chat applications.</p>
<div class="packt_infobox">Although some of these types of web applications were developed before the advent of WebSockets, they relied on hacks to work around the limitations of the HTTP protocol. With WebSockets, these hacks are no longer necessary.</div>
<p>Traditionally, writing applications taking advantage of the WebSocket protocol required a lot of JavaScript code. JSF 2.3 introduces WebSocket support and abstracts out most of the JavaScript plumbing, allowing us to focus on developing the business logic of our applications.</p>
<p>The following example illustrates a simple chat application developed using JSF 2.3 WebSocket support.</p>
<p>First, let's take a look at an application-scoped CDI named bean responsible for sending messages to all browser clients:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jsfwebsocket; 
 
import java.io.Serializable; 
import javax.enterprise.context.ApplicationScoped; 
import javax.faces.push.Push; 
import javax.faces.push.PushContext; 
import javax.inject.Inject; 
import javax.inject.Named; 
 
@Named 
@ApplicationScoped 
public class JsfWebSocketMessageSender implements Serializable { 
 
    @Inject 
   <strong> @Push 
    private PushContext pushContext;</strong> 
 
    public void send(String message) { 
        System.out.println("Sending message: " + message); 
<strong>        pushContext.send(message);</strong> 
    } 
} </pre>
<p class="mce-root">As shown in the preceding example, in order to send data via WebSockets to the clients we need to inject an instance of an implementation of the <kbd>javax.faces.push.PushContext</kbd> interface, and annotate it with the <kbd>@Push</kbd> annotation. To actually send the message to the client, we need to invoke the <kbd>send()</kbd> method of the injected <kbd>PushContext</kbd> implementation; in our example, this is done in the <kbd>send()</kbd> method of our CDI named bean.</p>
<p>In our example, there is a session scoped CDI named bean that takes input from the user and passes it to the <kbd>send()</kbd> method of the preceding application scoped CDI named bean. Our session scoped CDI bean looks as follows:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jsfwebsocket; <br/>import java.io.Serializable; 
import javax.enterprise.context.SessionScoped; 
import javax.inject.Inject; 
import javax.inject.Named; 
 
@Named 
@SessionScoped 
public class JsfWebSocketController implements Serializable { 
 
<strong>    @Inject</strong><strong>   <br/>    private JsfWebSocketMessageSender jsfWebSocketMessageSender;</strong> 
 
    private String userName; 
    private String message; 
 
<strong>    public void sendMessage() {</strong><strong>          <br/>      jsfWebSocketMessageSender.send(String.format("%s: %s",  </strong><strong>            <br/>       userName,</strong><strong>   <br/>       message));<br/></strong><strong>    }</strong> 
 
    //setters getters and less relevant methods omitted for brevity. 
} </pre>
<p>The <kbd>sendMessage()</kbd> method of the preceding class calls the <kbd>send()</kbd> method of the application scoped CDI bean we discussed earlier, passing the name of the user and the message to be broadcast to all browsers. The aforementioned <kbd>sendMessage()</kbd> method is invoked via Ajax when a user clicks a button on the corresponding page, as shown in the following markup:</p>
<pre style="padding-left: 60px">    &lt;h:body&gt; 
<strong>        &lt;f:websocket channel="pushContext"</strong><strong>           <br/>         onmessage="socketListener" /&gt;</strong> 
 
        &lt;h:form prependId="false"&gt; 
            &lt;h:panelGrid columns="2"&gt; 
                &lt;h:outputLabel for="chatWindow" value="Chat  <br/>                 Window:"/&gt; 
                &lt;textarea id="chatWindow" rows="10"/&gt; 
                &lt;h:outputLabel for="chatInput" value="Type <br/>                 something here:"/&gt; 
                &lt;h:inputText id="chatInput" 
                 value="#{jsfWebSocketController.message}"/&gt; 
                &lt;h:panelGroup/&gt; 
                &lt;h:commandButton 
                 actionListener="# <br/>                 {jsfWebSocketController.sendMessage()}"  
                  value="Send message"&gt; 
                    &lt;f:ajax execute="chatInput"  <br/>                     render="chatWindow"/&gt; 
                &lt;/h:commandButton&gt; 
            &lt;/h:panelGrid&gt; 
        &lt;/h:form&gt; 
 
<strong>        &lt;script type="text/javascript"&gt;</strong><strong>        <br/>         function socketListener(message, channel, event) {</strong><strong>                 <br/>          var textArea = document.getElementById('chatWindow');</strong><strong>                 <br/>          var textAreaValue = textArea.value;</strong><strong>             <br/>          if (textAreaValue.trim() !== '') {</strong><strong>                     <br/>           textAreaValue += "\n";</strong><strong>       <br/>                }</strong><strong>             <br/>                textAreaValue += message;</strong><strong>     <br/>                textArea.value = textAreaValue;</strong><strong>                 <br/>                textArea.scrollTop = textArea.scrollHeight;</strong><strong>               <br/>            }</strong><strong>        <br/>        &lt;/script&gt;</strong> 
    &lt;/h:body&gt; </pre>
<p>The <kbd>&lt;f:websocket&gt;</kbd> tag in the preceding markup is needed to enable WebSocket support in our page. The value of its <kbd>channel</kbd> attribute links the page to the corresponding <kbd>PushContext</kbd> instance on the server (in our example, it is defined in the application scoped <kbd>JsfWebSocketMessageSender</kbd> CDI named bean). By convention, the value of the <kbd>channel</kbd> attribute must match the variable name on the corresponding CDI named bean (<kbd>pushContext</kbd>, in our example).</p>
<div class="packt_infobox">We're only showing the most relevant sections of the example; the complete example can be downloaded from this book's GitHub repository at <a href="https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples"><span class="InternetLink0">https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples</span></a>.</div>
<p>After building and deploying our application we can see it in action:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/545b3456-285a-461b-b05c-a03b4b9cc01b.png" style="width:24.08em;height:24.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional JSF component libraries</h1>
                </header>
            
            <article>
                
<p>In addition to the standard JSF component libraries, there are a number of third-party JSF tag libraries available. The following table lists some of the most popular:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Tag library</strong></p>
</td>
<td>
<p><strong>Distributor</strong></p>
</td>
<td>
<p><strong>License</strong></p>
</td>
<td>
<p><strong>URL</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>ICEfaces</kbd></p>
</td>
<td>
<p>ICEsoft</p>
</td>
<td>
<p>MPL 1.1</p>
</td>
<td>
<p><a href="http://www.icefaces.org"><span class="URLPACKT">http://www.icefaces.org</span></a></p>
</td>
</tr>
<tr>
<td>
<p><kbd>RichFaces</kbd></p>
</td>
<td>
<p>Red Hat/JBoss</p>
</td>
<td>
<p>LGPL</p>
</td>
<td>
<p><a href="http://www.jboss.org/richfaces"><span class="URLPACKT">http://www.jboss.org/richfaces</span></a></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Primefaces</kbd></p>
</td>
<td>
<p>Prime Technology</p>
</td>
<td>
<p>Apache 2.0</p>
</td>
<td>
<p><a href="http://www.primefaces.org"><span class="URLPACKT">http://www.primefaces.org</span></a></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered how to develop web-based applications using JavaServer Faces, the standard component framework for the Java EE platform. We looked at how to write a simple application by creating pages using Facelets as the view technology and CDI named beans. We also covered how to validate user input by using JSF's standard validators, by creating our own custom validators or by writing <kbd>validator</kbd> methods. Additionally, we covered how to customize standard JSF error messages, both the message text and the message style (font, color, and such). Also, we covered how to develop Ajax-enabled JSF pages, as well as how to integrate JSF and HTML5.</p>


            </article>

            
        </section>
    </body></html>