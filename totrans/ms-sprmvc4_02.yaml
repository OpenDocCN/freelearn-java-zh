- en: Chapter 2. Mastering the MVC Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 掌握MVC架构
- en: In this chapter, we will discuss the MVC architecture principles and see how
    Spring MVC implements those.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论MVC架构原则，并了解Spring MVC如何实现这些原则。
- en: We will continue to use the application from the previous chapter and build
    something more interesting. Our goal is to design a simple page where users can
    search for tweets corresponding to certain criteria and display them to our users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用上一章中的应用程序，并构建一些更有趣的东西。我们的目标是设计一个简单的页面，用户可以在其中根据特定标准搜索推文，并将它们展示给我们的用户。
- en: To achieve this, we will use the Spring Social Twitter project, which is available
    at [http://projects.spring.io/spring-social-twitter/](http://projects.spring.io/spring-social-twitter/).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用Spring Social Twitter项目，该项目可在[http://projects.spring.io/spring-social-twitter/](http://projects.spring.io/spring-social-twitter/)找到。
- en: We will see how to make Spring MVC work with a modern template engine, Thymeleaf,
    and try to understand the inner mechanics of the framework. We will route our
    users through different views, and finally, we will give a stellar look to our
    application using WebJars and Materialize ([http://materializecss.com](http://materializecss.com)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何使Spring MVC与现代模板引擎Thymeleaf协同工作，并尝试理解框架的内部机制。我们将通过不同的视图引导我们的用户，最后，我们将使用WebJars和Materialize
    ([http://materializecss.com](http://materializecss.com))为我们的应用程序提供一个出色的外观。
- en: The MVC architecture
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC架构
- en: I expect the meaning of the MVC acronym to be familiar to most. It stands for
    Model View Controller, and it is considered to be a very popular way to build
    a user interface by decoupling the data and the presentation layers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计MVC缩写的含义对大多数人来说都很熟悉。它代表模型-视图-控制器，并且被认为是通过解耦数据和表示层来构建用户界面的非常流行的方式。
- en: '![The MVC architecture](img/2117_02_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![MVC架构图](img/2117_02_01.jpg)'
- en: The MVC pattern became wildly popular after emerging from the world of Smalltalk
    and landing in the Ruby on Rails framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式在从小型计算机制造商的世界中脱颖而出，并在Ruby on Rails框架中落地后变得非常流行。
- en: 'The architectural pattern features three layers:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式具有三个层次：
- en: '**The Model**: This consists of various representations of the data your application
    knows about.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这包括应用程序所知道的数据的各种表示形式。'
- en: '**The View**: This is made up of several representations of the data that will
    be displayed to your users.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是由将显示给用户的几个数据表示形式组成的。'
- en: '**The Controller**: This is the part of the application that will handle user
    interactions. It''s a bridge between the model and the view.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这是应用程序中处理用户交互的部分。它是模型和视图之间的桥梁。'
- en: The idea behind MVC is to decouple the View from the Model. The model must be
    self-contained and ignorant of the UI. This basically allows the same data to
    be reused across multiple views. These views are different way to look at the
    data. Drill down or using different renderers (HTML, PDF) are good illustrations
    of this principle.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MVC背后的想法是将视图与模型解耦。模型必须是自包含的，并且对UI一无所知。这基本上允许相同的数据在多个视图中重用。这些视图是查看数据的不同方式。深入挖掘或使用不同的渲染器（HTML、PDF）是这一原则的良好说明。
- en: The Controller acts as a mediator between the user and the data. Its role is
    to control actions available to the end user, as well as routing through the different
    views of the application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器充当用户和数据之间的调解者。其角色是控制对最终用户可用的操作，并通过应用程序的不同视图进行路由。
- en: MVC critics and best practices
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC批评和最佳实践
- en: While MVC remains the go-to approach for designing a UI, many criticisms arose
    with its prevalence. Most critics are actually pointing a finger at the incorrect
    use of the pattern.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MVC仍然是设计UI的首选方法，但随着其普及，许多批评也随之而来。大多数批评实际上是指向了模式的错误使用。
- en: Anemic Domain Model
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贫血型领域模型
- en: Eric Evans' influential book *Domain Driven Design*, also abbreviated as **DDD**,
    defines a set of architecture rules leading to a better integration of the business
    domain inside the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 埃里克·埃文斯的具有影响力的书籍《领域驱动设计》，也简称为**DDD**，定义了一套架构规则，这些规则有助于在代码内部更好地整合业务领域。
- en: One of the core ideas is to take advantage of the object-oriented paradigms
    inside the domain objects. Going against this principle is sometimes referred
    to as **Anemic Domain Model**. A good definition of this problem can be found
    on Martin Fowler's blog ([http://www.martinfowler.com/bliki/AnemicDomainModel.html](http://www.martinfowler.com/bliki/AnemicDomainModel.html)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想之一是利用领域对象内的面向对象范式。违反这一原则有时被称为**贫血领域模型**。关于这个问题的良好定义可以在Martin Fowler的博客上找到（[http://www.martinfowler.com/bliki/AnemicDomainModel.html](http://www.martinfowler.com/bliki/AnemicDomainModel.html)）。
- en: 'An Anemic Model typically exhibits the following symptoms:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 贫血模型通常表现出以下症状：
- en: The model is constituted from very simple **plain old Java objects** (**POJO**s)
    with only getters and setters
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型由非常简单的**普通Java对象**（**POJO**s）构成，仅包含getter和setter方法
- en: All the business logic is handled inside a service layer
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有业务逻辑都在服务层内部处理
- en: Validation of the model is found outside this model, for instance, in controllers
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型的验证位于模型外部，例如，在控制器中
- en: This can be a bad practice depending on the complexity of your business domain.
    Generally speaking, DDD practices require additional efforts to isolate the domain
    from the application logic.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能取决于您的业务领域的复杂性，可能是一种不良实践。一般来说，DDD实践需要额外的努力来隔离领域与应用逻辑。
- en: Architecture is always a tradeoff. It is good to note that typical ways of designing
    a Spring application can lead to complicated maintenance somewhere along the road.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 架构总是需要权衡。值得注意的是，典型的Spring应用程序设计方式可能会导致维护过程中的复杂化。
- en: 'How to avoid domain anemia is explained here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如何避免领域贫血在这里解释：
- en: The Service layer is good for application-level abstraction like transaction
    handling, not business logic.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层适合于应用级别的抽象，如事务处理，而不是业务逻辑。
- en: Your domain should always be in a valid state. Leave validation inside the form
    objects using validators or JSR-303's validation annotations.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的领域应该始终处于有效状态。使用验证器或JSR-303的验证注解在表单对象内部进行验证。
- en: translate the inputs into meaningful domain objects.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入转换为有意义的领域对象。
- en: Think of your data layer in term of repositories with domain queries (refer
    to Spring Data Specification, for example)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的数据层视为具有领域查询的存储库（例如，参考Spring Data Specification）。
- en: Decouple your domain logic from the underlying persistence framework
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的领域逻辑与底层持久化框架解耦
- en: Use real objects as much as possible. For instance, manipulate the `FirstName`
    class rather than a string.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用真实对象。例如，操作`FirstName`类而不是字符串。
- en: 'There is much more to DDD than these simple rules: Entities, value types, Ubiquitous
    Language, Bounded Context, Onion Architecture, and anti corruption layers. I strongly
    encourage you to study these principles on your own. As far as we are concerned,
    with this book we will try to keep in mind the guidelines listed earlier as we
    craft our web application. These concerns will become more familiar to you as
    we advance through this book.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: DDD（领域驱动设计）远不止这些简单的规则：实体、值类型、通用语言、边界上下文、洋葱架构和反腐败层。我强烈建议您自己研究这些原则。就我们而言，在这本书中，我们将尝试在构建我们的Web应用程序时牢记前面列出的指南。随着我们在这本书中的进展，这些问题将变得越来越熟悉。
- en: Learning from the sources
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源头学习
- en: If you're familiar with Spring, you have probably already landed on Spring's
    website, [http://spring.io](http://spring.io). It is entirely made with Spring
    and the good news is that it is open source.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Spring，您可能已经访问了Spring的网站，[http://spring.io](http://spring.io)。它完全是用Spring制作的，好消息是它是开源的。
- en: 'The code name of the project is sagan. It has numerous interesting features:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的代码名称是sagan。它具有许多有趣的功能：
- en: A gradle multimodule project
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Gradle多模块项目
- en: Security integration
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全集成
- en: Github integration
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Github集成
- en: Elasticsearch integration
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elasticsearch集成
- en: A JavaScript frontend application
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个JavaScript前端应用程序
- en: The GitHub wiki associated with the project is really detailed and will help
    you get started easily with the project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与项目相关的GitHub wiki非常详细，这将帮助您轻松开始项目。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visit the following URL if you''re interested in the Spring''s architecture
    of a real world application:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Spring真实世界应用程序的架构感兴趣，请访问以下URL：
- en: '[https://github.com/spring-io/sagan](https://github.com/spring-io/sagan)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/spring-io/sagan](https://github.com/spring-io/sagan)'
- en: Spring MVC 1-0-1
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC 1-0-1
- en: 'In spring MVC, the model is a simple map encapsulated in the `Model` or `ModelAndView`
    classes of Spring MVC. It can come from a database, files, external services,
    and so on. It is up to you to define how to fetch the data and put it into the
    model. The recommended way of interacting with the data layer is through Spring
    Data libraries: Spring Data JPA, Spring Data MongoDB, and so on. There are a dozen
    projects related to Spring Data and I encourage you to take a look at [http://projects.spring.io/spring-data](http://projects.spring.io/spring-data).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring MVC中，模型是Spring MVC的`Model`或`ModelAndView`类封装的一个简单映射。它可以从数据库、文件、外部服务等来源。如何获取数据并将其放入模型取决于你。与数据层交互的推荐方式是通过Spring
    Data库：Spring Data JPA、Spring Data MongoDB等。与Spring Data相关联的项目有数十个，我鼓励你查看[http://projects.spring.io/spring-data](http://projects.spring.io/spring-data)。
- en: The controller side of Spring MVC is handled through the use of the `@Controller`
    annotation. In a web application, the controller's role is to respond to HTTP
    requests. Classes annotated with the `@Controller` annotation will be picked up
    by Spring and given a chance to handle upcoming requests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC的控制器端通过使用`@Controller`注解来处理。在Web应用程序中，控制器的作用是对HTTP请求做出响应。带有`@Controller`注解的类将被Spring拾取并有机会处理即将到来的请求。
- en: Via the `@RequestMapping` annotation, Controllers declare handling specific
    requests based on their HTTP method (`GET` or `POST` methods, for instance) and
    their URLs. The Controller then decides to either write content directly in the
    web response or route the application to a view and inject properties into that
    view.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`@RequestMapping`注解，控制器根据其HTTP方法（例如`GET`或`POST`方法）和URL声明处理特定请求。然后控制器决定是直接在Web响应中写入内容还是将应用程序路由到视图并将属性注入到该视图中。
- en: A pure RESTful application would choose the first approach and expose a JSON
    or XML representation of the model directly in the HTTP response with the `@ResponseBody`
    annotation. In the case of a web application, this type of architecture is often
    associated with a frontend JavaScript framework such as Backbone.js, AngularJS,
    or React. In this case, the Spring application would then only handle the Model
    layer of the MVC model. We will study this kind of architecture in [Chapter 4](ch04.html
    "Chapter 4. File Upload and Error Handling"), *File Upload and Error Handling*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个纯RESTful应用程序会选择第一种方法，并通过`@ResponseBody`注解直接在HTTP响应中暴露模型的JSON或XML表示。在Web应用程序的情况下，这种类型的架构通常与一个前端JavaScript框架相关联，例如Backbone.js、AngularJS或React。在这种情况下，Spring应用程序将只处理MVC模型中的模型层。我们将在[第4章](ch04.html
    "第4章。文件上传和错误处理")*文件上传和错误处理*中研究这种类型的架构。
- en: With the second approach, the Model is passed to the View, which is rendered
    by a templating engine and then written to the response.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种方法中，模型被传递到视图，由模板引擎渲染，然后写入响应。
- en: The view is often associated with a templating dialect, which will allow navigation
    inside the model. Popular dialects for templating are JSPs, FreeMarker, or Thymeleaf.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种视图通常与模板方言相关联，这将允许在模型内部进行导航。流行的模板方言包括JSPs、FreeMarker或Thymeleaf。
- en: Hybrid approaches may take advantage of the templating engine to interact with
    some aspects of the application and then delegate the view layer to a frontend
    framework.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 混合方法可以利用模板引擎与应用程序的一些方面进行交互，然后将视图层委托给前端框架。
- en: Using Thymeleaf
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Thymeleaf
- en: Thymeleaf is a templating engine that gets particular attention from the Spring
    community.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf是一个模板引擎，得到了Spring社区的特别关注。
- en: Its success is due mostly to its friendly syntax (it almost looks like HTML)
    and the ease with which it can be extended.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它的成功主要归功于其友好的语法（几乎看起来像HTML）以及它易于扩展。
- en: 'Various extensions are available and integrated with Spring Boot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的各种扩展已集成到Spring Boot中：
- en: '| Support | Dependency |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 支持 | 依赖 |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Layouts | `nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 布局 | `nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect` |'
- en: '| HTML5 data-* attributes | `com.github.mxab.thymeleaf.extras:thymeleaf-extras-data-attribute`
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| HTML5 data-*属性 | `com.github.mxab.thymeleaf.extras:thymeleaf-extras-data-attribute`
    |'
- en: '| Internet Explorer conditional comments | `org.thymeleaf.extras:thymeleaf-extras-conditionalcomments`
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Internet Explorer条件注释 | `org.thymeleaf.extras:thymeleaf-extras-conditionalcomments`
    |'
- en: '| Support for spring security | `org.thymeleaf.extras:thymeleaf-extras-springsecurity3`
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 对Spring安全性的支持 | `org.thymeleaf.extras:thymeleaf-extras-springsecurity3` |'
- en: A very good tutorial on Thymeleaf's integration with Spring can be found at
    [http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html](http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html](http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html)
    找到关于 Thymeleaf 与 Spring 集成的非常好的教程。
- en: 'Without further ado, let''s add the `spring-boot-starter-thymeleaf` dependency
    to bootstrap the thymeleaf templating engine:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们添加 `spring-boot-starter-thymeleaf` 依赖项以启动 thymeleaf 模板引擎：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our first page
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个页面
- en: 'We will now add the first page to our application. It will be located in `src/main/resources/templates`.
    Let''s call the file `resultPage.html`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向我们的应用程序添加第一个页面。它将位于 `src/main/resources/templates`。让我们称这个文件为 `resultPage.html`：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see from the very start that Thymeleaf integrates perfectly with html
    and its syntax almost feels natural.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一开始就看到 Thymeleaf 与 html 完美集成，其语法几乎感觉自然。
- en: The `th:text` value is put between pipes. It means that all the values inside
    the text will be concatenated.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`th:text` 的值放在管道之间。这意味着文本内的所有值都将连接起来。'
- en: It might seem a bit awkward at first, but in practice, text will rarely be hardcoded
    in our pages; so, Thymeleaf makes an opinionated design decision here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能有些不自然，但在实践中，我们的页面中很少会硬编码文本；因此，Thymeleaf 在这里做出了有见地的设计决策。
- en: 'Thymeleaf has a big advantage for web designers: everything that is dynamic
    inside the templates can fall back to a default value in the case where they are
    opened without the server running. Resource URLs can be specified relatively and
    every markup can contain placeholders. In our previous example, the text "Hello
    html" would not be displayed when the view is rendered in the context of our application,
    but it will if the file is opened directly with a web browser.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf 对网页设计师来说有一个很大的优势：模板内部的所有动态内容，在没有服务器运行的情况下打开时，都可以回退到默认值。资源 URL 可以指定为相对路径，并且每个标记都可以包含占位符。在我们的上一个例子中，当视图在我们的应用程序上下文中渲染时，文本
    "Hello html" 不会显示，但如果直接用网页浏览器打开文件，则会显示。
- en: 'To speed up development, add this property to your `application.properties`
    file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快开发速度，将此属性添加到您的 `application.properties` 文件中：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will disable the view cache and cause templates to reload every time they
    are accessed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将禁用视图缓存，并导致每次访问模板时都会重新加载。
- en: Of course, this setting will need to be disabled when we go into production.
    We will see that in [Chapter 8](ch08.html "Chapter 8. Optimizing Your Requests"),
    *Optimizing Your Requests*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们进入生产环境时，需要禁用此设置。我们将在 [第 8 章](ch08.html "第 8 章。优化您的请求") 中看到这一点，*优化您的请求*。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Reloading the views**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新加载视图**'
- en: With the cache disabled, simply save your view with eclipse or use the `Build
    > Make Project` action in IntelliJ to refresh the views after a change.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用缓存后，只需使用 eclipse 保存您的视图或使用 IntelliJ 中的 `Build > Make Project` 操作来在更改后刷新视图。
- en: Lastly, we will need to modify our `HelloController` class. Instead of displaying
    plain text, it must now route to our freshly created view. To accomplish this,
    we will remove the `@ResponseBody` annotation. Doing so and still returning a
    string will tell Spring MVC to map this string to a view name instead of displaying
    a particular model directly in the response.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改我们的 `HelloController` 类。它现在必须路由到我们刚刚创建的视图，而不是显示纯文本。为了完成这个任务，我们将移除 `@ResponseBody`
    注解。这样做并返回一个字符串将告诉 Spring MVC 将此字符串映射到视图名称，而不是直接在响应中显示特定的模型。
- en: 'Here is what our controller now looks like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的控制器现在是什么样子：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the controller will redirect the user to the view name `resultPage`.
    The `ViewResolver` interface will then associate this name with our page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，控制器将用户重定向到视图名称 `resultPage`。然后 `ViewResolver` 接口将此名称与我们的页面关联。
- en: Let's launch our application again and go to `http://localhost:8080`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次启动我们的应用程序并转到 `http://localhost:8080`。
- en: 'You will see the following page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下页面：
- en: '![Our first page](img/2117_02_02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个页面](img/2117_02_02.jpg)'
- en: Spring MVC architecture
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC 架构
- en: Let's take a step back from this spectacular new "Hello World" and try to understand
    what happened inside our web application. To do this, we will retrace the journey
    of the HTTP request our browser sent and the response it got from the server.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个精彩的 "Hello World" 新功能中退一步，试图理解我们的网络应用程序内部发生了什么。为此，我们将回顾浏览器发送的 HTTP 请求和从服务器收到的响应的旅程。
- en: DispatcherServlet
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DispatcherServlet
- en: 'The entry point of every Spring web application is the `DispatcherServlet`.
    The following figure illustrates the Dispatcher Servlet architecture:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Spring Web应用程序的入口点是`DispatcherServlet`。以下图展示了Dispatcher Servlet架构：
- en: '![DispatcherServlet](img/2117_02_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![DispatcherServlet](img/2117_02_03.jpg)'
- en: This is a classical `HttpServlet` class that dispatches HTTP requests to HandlerMapping.
    A **HandlerMapping** is an association of resources (URLs) and Controllers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一个经典的`HttpServlet`类，它将HTTP请求分派到`HandlerMapping`。**HandlerMapping**是资源（URL）和控制器之间的关联。
- en: The appropriate methods—those annotated with `@RequestMapping` annotation—are
    then called on the Controller. In this method, the controller sets the model data
    and returns the view name to the dispatcher.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在控制器上调用适当的带有`@RequestMapping`注解的方法。在这个方法中，控制器设置模型数据，并将视图名称返回给分派器。
- en: The `DispatcherServlet` will then interrogate the `ViewResolver` interface to
    find the corresponding implementation of the view.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`DispatcherServlet`将查询`ViewResolver`接口以找到视图的相应实现。
- en: In our case, the `ThymeleafAutoConfiguration` class has set up the view resolver
    for us.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`ThymeleafAutoConfiguration`类已经为我们设置了视图解析器。
- en: You can see in the `ThymeleafProperties` class that the default prefix for our
    views is `classpath:/templates/` the default suffix is `.html`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`ThymeleafProperties`类中看到，我们视图的默认前缀是`classpath:/templates/`，默认后缀是`.html`。
- en: This means that, given the view name `resultPage`, the view resolver will look
    in the templates directory of our classpath, looking for a file called `resultPage.html`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，给定视图名称`resultPage`，视图解析器将在我们的类路径的模板目录中查找名为`resultPage.html`的文件。
- en: In our application our `ViewResolver` interface is static, but more advanced
    implementation can return different results given the request headers or the user's
    locale.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们的`ViewResolver`接口是静态的，但更高级的实现可以根据请求头或用户的区域设置返回不同的结果。
- en: The view will finally be rendered and the result written to the response.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 视图最终将被渲染，并将结果写入响应。
- en: Passing data to the view
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递数据到视图
- en: Our first page is completely static; it does not really take advantage of the
    power of Spring MVC. Let's spice things up a little bit. What if the "Hello World"
    string, instead of being hardcoded, came from the server?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一页完全是静态的；它并没有真正利用Spring MVC的强大功能。让我们稍微加点料。如果“Hello World”字符串不是硬编码的，而是来自服务器会怎样呢？
- en: 'It would still be a lame "hello world" you say? Yes, but it will open up many
    more possibilities. Let''s change our `resultPage.html` file to display a message
    coming from the model:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你会说这仍然是一个蹩脚的“Hello World”吗？是的，但它将打开更多的可能性。让我们将我们的`resultPage.html`文件更改为显示来自模型的消息：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, let''s modify our controller so it puts this message inside this model:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们修改我们的控制器，使其将此消息放入此模型中：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I know, the suspense is killing you! Let's see what `http://localhost:8080`
    looks like.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，这种悬念正在折磨你！让我们看看`http://localhost:8080`看起来像什么。
- en: '![Passing data to the view](img/2117_02_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![传递数据到视图](img/2117_02_04.jpg)'
- en: The first thing to note is that we passed a new argument to the controller's
    method and that the `DispatcherServlet` provided the correct object for us. There
    are, in fact, many objects that can be injected into the controller's methods
    such as `HttpRequest` or `HttpResponse`, the `Locale`, the `TimeZone`, and the
    `Principal`, which represent an authenticated user. The full list of such objects
    is available in the documentation, which can be found at [http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-arguments](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-arguments).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们向控制器的方法传递了一个新的参数，并且`DispatcherServlet`为我们提供了正确的对象。实际上，有许多对象可以被注入到控制器的方法中，例如`HttpRequest`或`HttpResponse`，`Locale`，`TimeZone`和`Principal`，它们代表一个认证用户。此类对象的完整列表可在文档中找到，文档位于[http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-arguments](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-arguments)。
- en: Spring Expression Language
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring表达式语言
- en: When using the `${}` syntax, you are in fact using **Spring Expression Language**
    (**SpEL**). There are several variants of EL available in the wild; SpEl is one
    of the most powerful variants.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`${}`语法时，实际上你正在使用**Spring表达式语言**（**SpEL**）。在野外有几种可用的EL变体；SpEl是其中最强大的变体之一。
- en: 'Here is an overview of its main features:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其主要功能的概述：
- en: '| Feature | Syntax | Explanation |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 语法 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Accessing a list element | `list[0]` |   |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 访问列表元素 | `list[0]` |   |'
- en: '| Accessing a map entry | `map[key]` |   |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 访问映射条目 | `map[key]` |   |'
- en: '| Ternary operator | `condition ? ''yes'' : ''no''` |   |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 三元运算符 | `condition ? ''yes'' : ''no''` |   |'
- en: '| Elvis operator | `person ?: default` | Returns `default` if person''s value
    is null |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝运算符 | `person ?: default` | 如果 person 的值为 null，则返回 `default` |'
- en: '| Safe navigation | `person?.name` | Returns `null` if person or her name is
    null |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 安全导航 | `person?.name` | 如果 person 或她的名字为 null，则返回 `null` |'
- en: '| Templating | `''Your name is #{person.name}''` | Injects values into a string
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 模板 | `''Your name is #{person.name}''` | 将值注入到字符串中 |'
- en: '| Projections | `${persons.![name]}` | Extracts the names of all the persons
    and puts them into a list |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 投影 | `${persons.![name]}` | 提取所有人员的姓名并将它们放入列表中 |'
- en: '| Selection | `persons.?[name == ''Bob'']''` | Retrieves the person whose name
    is Bob inside a list |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 选择 | `persons.?[name == ''Bob'']''` | 在列表中检索名为 Bob 的人 |'
- en: '| Function call | `person.sayHello()` |   |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 函数调用 | `person.sayHello()` |   |'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For complete reference, check the manual at [http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的参考，请查看 [http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html)
    中的手册。
- en: The SpEl usage is not limited to views. You can also use it in various places
    inside the Spring framework, for instance, when injecting properties inside beans
    with the `@Value` annotation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: SpEl 的使用不仅限于视图。您还可以在 Spring 框架的各个地方使用它，例如，当使用 `@Value` 注解在 bean 中注入属性时。
- en: Getting data with a request parameter
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用请求参数获取数据
- en: We are able to display data coming from the server inside the view. However,
    what if we wanted to get input from the user? With the HTTP protocol, there are
    multiple ways to do this. The simplest way is to pass a query parameter to our
    URL.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够在视图中显示来自服务器的数据。然而，如果我们想从用户那里获取输入呢？使用 HTTP 协议，有多种方法可以做到这一点。最简单的方法是将查询参数传递给我们的
    URL。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Query parameters**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询参数**'
- en: You certainly know query parameters. They are found after the `?` character
    in a URL. They consist of a list of name and values separated by the & symbol
    (Ampersand), for example, `page?var1=value1&var2=value2`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您当然知道查询参数。它们位于 URL 中的 `?` 字符之后。它们由一个由 & 符号（和号）分隔的名称和值列表组成，例如，`page?var1=value1&var2=value2`。
- en: 'We can leverage this technique to ask our user for their name. Let''s modify
    our `HelloController` class again:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这项技术来请求用户的姓名。让我们再次修改我们的 `HelloController` 类：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we navigate to `localhost:8080/?name=Geoffroy`, we can see the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到 `localhost:8080/?name=Geoffroy`，我们可以看到以下内容：
- en: '![Getting data with a request parameter](img/2117_02_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使用请求参数获取数据](img/2117_02_05.jpg)'
- en: By default, the request parameter is mandatory. This means that if we were to
    navigate to `localhost:8080`, we would see an error message.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，请求参数是必需的。这意味着如果我们导航到 `localhost:8080`，我们会看到一个错误消息。
- en: 'Looking at the `@RequestParam` code, we can see that in addition to the value
    parameter, there are two other attributes possible: `required` and `defaultValue`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 `@RequestParam` 代码，我们可以看到除了值参数外，还有两个可能的属性：`required` 和 `defaultValue`。
- en: 'Therefore, we can change our code and specify a default value for our parameter
    or indicate that it is not required:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以更改我们的代码并指定参数的默认值或指示它不是必需的：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Java 8, it is possible not to specify the value parameter. In that case,
    the name of the annotated method parameter will be used.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 中，可以不指定值参数。在这种情况下，注解方法参数的名称将被使用。
- en: Enough Hello Worlds, let's fetch tweets!
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 足够的 "Hello World"，让我们获取推文！
- en: All right, the name of the book isn't "Mastering Hello Worlds", after all. With
    Spring, interrogating Twitter's API is really easy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这本书的名字并不是 "Mastering Hello Worlds"。使用 Spring，查询 Twitter 的 API 真的很简单。
- en: Registering your application
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册您的应用程序
- en: Before you start, you have to register your application in the Twitter developer
    console.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，您必须在 Twitter 开发者控制台中注册您的应用程序。
- en: Go to [https://apps.twitter.com](https://apps.twitter.com) and create a new
    application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://apps.twitter.com](https://apps.twitter.com) 并创建一个新的应用程序。
- en: Give it the name you please. Under the website and Callback URL sections, just
    enter `http://127.0.0.1:8080`. This will allow you to test your application in
    development on your local machine.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 给它您喜欢的名字。在网站和回调URL部分，只需输入 `http://127.0.0.1:8080`。这将允许您在本地机器上测试您的开发中的应用程序。
- en: '![Registering your application](img/2117_2_11.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![注册您的应用程序](img/2117_2_11.jpg)'
- en: 'Now, navigate to the keys, access the token, and copy the **Consumer Key**
    and the **Consumer Secret**. We will use this in a moment. Take a look at the
    following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导航到密钥，访问令牌，并复制**消费者密钥**和**消费者密钥**。我们稍后会使用这些。看看下面的截图：
- en: '![Registering your application](img/2117_02_12.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![注册你的应用程序](img/2117_02_12.jpg)'
- en: By default, our application has read only permissions. This will be enough for
    our application, but you can tweak it if you wish.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的应用程序只有只读权限。这对我们的应用程序来说已经足够了，但如果你愿意，可以对其进行调整。
- en: Setting up Spring Social Twitter
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Spring Social Twitter
- en: 'We will add the following dependency to our `build.gradle` file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`build.gradle`文件中添加以下依赖项：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Spring Social** is a set of projects providing access to the public APIs
    of various social networks. Out of the box, Spring Boot provides integration with
    Twitter, Facebook, and LinkedIn. Spring Social includes about 30 projects overall,
    which can be found at [http://projects.spring.io/spring-social/](http://projects.spring.io/spring-social/).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Social**是一组提供访问各种社交网络公共API的项目。Spring Boot默认提供了与Twitter、Facebook和LinkedIn的集成。Spring
    Social总共有大约30个项目，可以在[http://projects.spring.io/spring-social/](http://projects.spring.io/spring-social/)找到。'
- en: 'Add the following two lines to the `application.properties`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下两行添加到`application.properties`中：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These are the keys associated with the application we just created.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们刚刚创建的应用程序关联的键。
- en: You will learn more about OAuth in [Chapter 6](ch06.html "Chapter 6. Securing
    Your Application"), *Securing Your Application*. For now, we will just use those
    credentials to issue requests to Twitter's API on behalf of our application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第6章](ch06.html "第6章。保护你的应用程序")*保护你的应用程序*中了解更多关于OAuth的内容。现在，我们只需使用这些凭据代表我们的应用程序向Twitter的API发出请求。
- en: Accessing Twitter
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问Twitter
- en: 'We can now use Twitter in our controller. Let''s change its name to `TweetController`
    as a variable to reflect its new responsibility in a better manner:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在控制器中使用Twitter了。让我们将其名称更改为`TweetController`，以更好地反映其新的职责：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the code searches for tweets matching the request parameter.
    If it all goes well, you will see the text of the first one being displayed on
    your screen:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码正在搜索与请求参数匹配的推文。如果一切顺利，你将在屏幕上看到第一条推文的内容：
- en: '![Accessing Twitter](img/2117_02_06.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![访问Twitter](img/2117_02_06.jpg)'
- en: Of course, if the search doesn't yield any result, our clumsy code will fail
    with an `ArrayOutOfBoundException`. So, do not hesitate to tweet to solve the
    problem!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果搜索没有产生任何结果，我们笨拙的代码将因`ArrayOutOfBoundException`而失败。所以，不要犹豫，发推文解决问题！
- en: 'What if we wanted to display a list of tweets? Let''s modify the `resultPage.html`
    file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想显示推文列表呢？让我们修改`resultPage.html`文件：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `th:each` is a tag defined in Thymeleaf that allows it to iterate over a
    collection and assign each value to a variable inside a loop.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`th:each`是Thymeleaf中定义的一个标签，允许它遍历集合，并在循环中将每个值分配给变量。'
- en: 'We will need to change our controller as well:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改我们的控制器：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that we are using Java 8 streams to collect only the messages from the
    tweets. The `Tweet` class contains many other attributes such as the sender, the
    retweet count, and so on. However, we will keep it simple for now, as shown in
    the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用Java 8流来收集推文中的消息。`Tweet`类包含许多其他属性，如发送者、转发次数等。然而，我们现在将保持简单，如下面的截图所示：
- en: '![Accessing Twitter](img/2117_02_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![访问Twitter](img/2117_02_07.jpg)'
- en: Java 8 streams and lambdas
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 8流和lambda
- en: You might not be familiar with lambdas yet. In Java 8, every collection gets
    a default method `stream()`, which gives access to functional-style operations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还不熟悉lambda表达式。在Java 8中，每个集合都有一个默认方法`stream()`，它提供了对函数式操作方式的访问。
- en: These operations can be either intermediate operations returning a stream, and
    thus allowing chaining, or a terminal operation that returns a value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作可以是返回流的中间操作，从而允许链式调用，或者返回值的终端操作。
- en: 'The most famous intermediate operations are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的中间操作如下：
- en: '`map`: This applies a method to every element of a list and returns the list
    of results'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`: 将方法应用于列表中的每个元素，并返回结果列表'
- en: '`filter`: This returns a list of every element matching a predicate'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`: 返回匹配谓词的每个元素的列表'
- en: '`reduce`: This projects a list into a single value using an operation and an
    accumulator'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`: 使用操作和累加器将列表投影为一个单一值'
- en: Lambdas are shorthand syntax for function expressions. They can be coerced into
    a Single Abstract Method, an interface with only one function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda是函数表达式的简写语法。它们可以被强制转换为只有一个抽象方法的Single Abstract Method，一个只有一个函数的接口。
- en: 'For instance, you can implement the `Comparator` interface as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以这样实现`Comparator`接口：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Within lambdas, the return keyword is implicitly its last expression.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda表达式中，返回关键字隐式地是其最后一个表达式。
- en: The double colon operator we used earlier is a shortcut to get a reference to
    a function on a class,
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的双冒号运算符是获取类上函数引用的快捷方式，
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding is equivalent to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容等同于以下内容：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `collect` method allows us to call a terminal operation. The `Collectors`
    class is a set of terminal operations that will put results into lists, sets,
    or maps, allowing grouping, joining, and so on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect`方法允许我们调用一个终端操作。`Collectors`类是一组终端操作，将结果放入列表、集合或映射中，允许分组、连接等。'
- en: Calling the `collect(Collectors.toList())` method will produce a list with every
    element within the stream; in our case, the tweet names.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`collect(Collectors.toList())`方法将生成一个包含流中每个元素的列表；在我们的案例中，是推文名称。
- en: Material design with WebJars
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebJars的材料设计
- en: Our application is already great but it seriously leaves something to be desired
    in terms of aesthetics. You may have heard of material design. It is Google's
    take on flat design.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经很好了，但在美学方面还有很多需要改进的地方。你可能听说过材料设计。这是谷歌对扁平化设计的看法。
- en: We will use Materialize ([http://materializecss.com](http://materializecss.com)),
    a great looking responsive CSS and JavaScript library, just like Bootstrap.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Materialize（[http://materializecss.com](http://materializecss.com)），一个看起来很棒的响应式CSS和JavaScript库，就像Bootstrap一样。
- en: '![Material design with WebJars](img/2117_02_08.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![使用WebJars的材料设计](img/2117_02_08.jpg)'
- en: 'We talked a bit about WebJars in [Chapter 1](ch01.html "Chapter 1. Setting
    Up a Spring Web Application in No Time"), *Setting Up a Spring Web Application
    in No Time*; we will now get to use them. Add jQuery and Materialize CSS to our
    dependencies:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。快速设置Spring Web应用程序")中谈到了WebJars，*快速设置Spring Web应用程序*；我们现在将使用它们。将jQuery和Materialize
    CSS添加到我们的依赖项中：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The way a WebJar is organized is completely standardized. You will find the
    JS and CSS files of any library in `/webjars/{lib}/{version}/*.js`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: WebJar的组织方式是完全标准化的。你将在`/webjars/{lib}/{version}/*.js`中找到任何库的JS和CSS文件。
- en: 'For instance, to add jQuery to our page, the following to a web page:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将jQuery添加到我们的页面中，可以在网页中添加以下内容：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s modify our controller so that it gives us a list of all tweet objects
    instead of simple text:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的控制器，使其给我们一个所有推文对象的列表，而不是简单的文本：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s include materialize CSS in our view:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在视图中包含materialize CSS：
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The result already looks way better!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来已经好多了！
- en: '![Material design with WebJars](img/2117_02_10.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![使用WebJars的材料设计](img/2117_02_10.jpg)'
- en: Using layouts
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用布局
- en: The last thing we want to do is to put the reusable chunks of our UI into templates.
    To do this, we will use the `thymeleaf-layout-dialect` dependency, which is included
    in the `spring-boot-starter-thymeleaf` dependency of our project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最不想做的事情是将我们UI的可重用块放入模板中。为此，我们将使用`thymeleaf-layout-dialect`依赖项，它包含在我们的项目`spring-boot-starter-thymeleaf`依赖项中。
- en: 'We will create a new file called `default.html` in `src/main/resources/templates/layout`.
    It will contain the code we will repeat from page to page:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`src/main/resources/templates/layout`中创建一个名为`default.html`的新文件。它将包含我们将从页面到页面重复的代码：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will now modify the `resultPage.html` file so it uses the layout, which
    will simplify its contents:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将修改`resultPage.html`文件，使其使用布局，这将简化其内容：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `layout:decorator="layout/default"` will indicate where our layout can be
    found. We can then inject content into the different `layout:fragment` sections
    of the layout. Note that each template are valid HTML files. You can also override
    the title very easily.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout:decorator="layout/default"`将指示我们的布局在哪里。然后我们可以将内容注入布局的不同`layout:fragment`部分。请注意，每个模板都是有效的HTML文件。你也可以很容易地覆盖标题。'
- en: Navigation
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航
- en: We have a nice little tweet display application, but how are our users supposed
    to figure out that they need to supply a "search" request parameter?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个很好的小推文显示应用程序，但我们的用户应该如何知道他们需要提供一个“搜索”请求参数呢？
- en: It would be nice if we added a little form to our application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在应用程序中添加一个小表单会很好。
- en: 'Let''s do something like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做点这样的事情：
- en: '![Navigation](img/2117_02_13.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![导航](img/2117_02_13.jpg)'
- en: 'First, we need to modify our `TweetController` to add a second view to our
    application. The search page will be available directly at the root of our application
    and the result page when hit enter in the `search` field:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要修改我们的`TweetController`以向我们的应用程序添加第二个视图。搜索页面将直接位于我们应用程序的根目录，当在`search`字段中按下回车键时，将显示结果页面：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will add another page to the `templates` folder called the `searchPage.html`
    file. It will contain a simple form, which will pass the search term to the result
    page via the `get` method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`templates`文件夹中添加另一个页面，名为`searchPage.html`文件。它将包含一个简单的表单，通过`get`方法将搜索词传递到结果页面：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is very simple HTML and it works perfectly. You can try it now.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单的HTML，并且工作得很好。你现在可以尝试一下。
- en: What if we wanted to disallow some search result? Let's say we want to display
    an error message if the user types in `struts`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要禁止某些搜索结果怎么办？比如说，我们想在用户输入`struts`时显示一个错误信息。
- en: The best way to achieve this would be to modify the form to post the data. In
    the controller, we can then intercept what is posted and implement this business
    rule accordingly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点最好的方法是将表单修改为提交数据。在控制器中，我们可以拦截所提交的内容并相应地实现这个业务规则。
- en: 'First, we need to change the form in the `searchPage`, which is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更改`searchPage`中的表单，如下所示：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we change the form to this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将表单改为如下所示：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also need to handle this post on the server. Add this method to the `TweetController`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在服务器上处理这个POST请求。向`TweetController`添加此方法：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are several novelties here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个新特性：
- en: In the request mapping annotation, we specify the HTTP method we want to handle,
    that is, `POST`.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求映射注解中，我们指定我们想要处理的HTTP方法，即`POST`。
- en: We inject two attributes directly as method parameters. They are the request
    and `RedirectAttributes`.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们直接将两个属性作为方法参数注入。它们是请求和`RedirectAttributes`。
- en: We retrieve the value posted on the request and pass it on to the next view.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检索请求上提交的值，并将其传递给下一个视图。
- en: Instead of returning the name of the view, we make a redirection to a URL.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是返回视图的名称，而是将重定向到一个URL。
- en: The `RedirectAttributes` is a Spring model that will be specifically used to
    propagate values in a redirect scenario.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedirectAttributes`是Spring模型，将专门用于在重定向场景中传播值。'
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Redirect/Forward** are classical options in the context of a Java web application.
    They both change the view that is displayed on the user''s browser. The difference
    is that `Redirect` will send a 302 header that will trigger navigation inside
    the browser, whereas `Forward` will not cause the URL to change. In Spring MVC,
    you can use either option simply by prefixing your method return strings with
    `redirect:` or `forward:`. In both cases, the string you return will not be resolved
    to a view like we saw earlier, but will instead trigger navigation to a specific
    URL.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**重定向/转发**是Java Web应用程序中的经典选项。它们都会改变在用户浏览器上显示的视图。区别在于`Redirect`会发送一个302头部，这将触发浏览器内的导航，而`Forward`则不会导致URL改变。在Spring
    MVC中，你可以通过在方法返回字符串前加上`redirect:`或`forward:`来使用这两个选项中的任何一个。在两种情况下，你返回的字符串都不会像我们之前看到的那样解析为一个视图，而是会触发导航到特定的URL。'
- en: The preceding example is a bit contrived, and we will see smarter form handling
    in the next chapter. If you put a breakpoint in the `postSearch` method, you will
    see that it will be called right after a post in our form.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子有点牵强，我们将在下一章看到更智能的表单处理。如果你在`postSearch`方法中设置断点，你会看到它会在我们的表单POST之后立即被调用。
- en: So what about the error message?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，错误信息怎么办呢？
- en: 'Let''s change the `postSearch` method:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`postSearch`方法：
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the user's search terms contain "struts", we redirect them to the `searchPage`
    and add a little error message using flash attributes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户的搜索词包含“struts”，我们将它们重定向到`searchPage`，并使用闪存属性添加一条小错误信息。
- en: These special kinds of attributes live only for the time of a request and will
    disappear when the page is refreshed. This is very useful when we use the `POST-REDIRECT-GET`
    pattern, as we just did.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊的属性仅在请求期间存在，页面刷新后会消失。当我们使用`POST-REDIRECT-GET`模式时，这非常有用，正如我们刚才所做的那样。
- en: 'We will need to display this message in the `searchPage` result:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`searchPage`结果中显示这条信息：
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if users try to search for "struts2" tweets, they will get a useful and
    appropriate answer:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户尝试搜索“struts2”推文，他们将得到一个有用且适当的答案：
- en: '![Navigation](img/2117_02_14.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![导航](img/2117_02_14.jpg)'
- en: The check point
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点
- en: 'At the end of this chapter, you should have one controller, the `TweetController`,
    handling the search and the untouched generated configuration class, `MasterSpringMvcApplication`,
    in the `src/main/java` directory:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该有一个控制器，即`TweetController`，它处理搜索以及位于`src/main/java`目录中的未修改的生成配置类`MasterSpringMvcApplication`：
- en: '![The check point](img/2117_02_15.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![检查点](img/2117_02_15.jpg)'
- en: In the `src/main/resources` directory, you should have one default layout and
    two pages using it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main/resources`目录中，你应该有一个默认布局和两个使用该布局的页面。
- en: 'In the `application.properties` file, we added the Twitter application credentials
    as well as a property telling Spring not to cache the templates to ease development:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`application.properties`文件中，我们添加了Twitter应用程序凭据以及一个属性，告诉Spring不要缓存模板以简化开发：
- en: '![The check point](img/2117_02_16.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![检查点](img/2117_02_16.jpg)'
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what it takes to make a good MVC architecture.
    We saw some of the inner workings of Spring MVC and used Spring Social Twitter
    with very little configuration. We can now design a beautiful web application,
    thanks to WebJars.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何构建一个好的MVC架构。我们看到了Spring MVC的一些内部工作原理，并且使用Spring Social Twitter时配置非常少。现在，多亏了WebJars，我们可以设计一个漂亮的Web应用程序。
- en: In the next chapter, we will ask the user to fill in their profile, so that
    we can fetch tweets they might like automatically. This will give you the opportunity
    to learn more about forms, formatting, validation, and internationalization.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将要求用户填写他们的个人资料，这样我们就可以自动获取他们可能喜欢的推文。这将为你提供学习更多关于表单、格式化、验证和国际化的机会。
