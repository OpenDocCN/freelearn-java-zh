<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Thread Management</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following topics:</p>
<ul class="calibre17">
<li class="calibre18">Creating, running, and setting the characteristics of a thread</li>
<li class="calibre18">Interrupting a thread</li>
<li class="calibre18">Controlling the interruption of a thread</li>
<li class="calibre18">Sleeping and resuming a thread</li>
<li class="calibre18">Waiting for the finalization of a thread</li>
<li class="calibre18">Creating and running a daemon thread</li>
<li class="calibre18">Processing uncontrolled exceptions in a thread</li>
<li class="calibre18">Using thread local variables</li>
<li class="calibre18">Grouping threads and processing uncontrolled exceptions in a group of threads</li>
<li class="calibre18">Creating threads through a factory</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">In the computer world, when we talk about concurrency, we refer to a series of independent and unrelated tasks that run simultaneously on a computer. This simultaneity can be real if the computer has more than one processor or a multi-core processor, or it can be apparent if the computer has only one core processor.</p>
<p class="calibre4">All modern operating systems allow the execution of concurrent tasks. You can read your e-mails while listening to music or reading news on a web page. We can say this is process-level concurrency. But inside a process, we can also have various simultaneous tasks. Concurrent tasks that run inside a process are called <strong class="calibre1">threads</strong>. Another concept related to concurrency is parallelism. There are different definitions and relations withÂ the concurrency concept. Some authors talk about concurrency when you execute your application with multiple threads in a single-core processor. With this, you can see when your program execution is apparent. They talk about parallelism when you execute your application with multiple threads in a multi-core processor or in a computer with more than one processor, so this case is real as well. Other authors talk about concurrency when the threads of an application are executed without a predefined order, and they discuss parallelism when all these threads are executed in an ordered way.</p>
<p class="calibre4">This chapter presents a number of recipes that will show you how to perform basic operations with threads, using the Java 9 API. You will see how to create and run threads in a Java program, how to control their execution, process exceptions thrown by them, and how to group some threads to manipulate them as a unit.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating, running, and setting the characteristics of a thread</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we will learn how to do basic operations over a thread using the Java API. As with every element in the Java language, threads are objects. We have two ways of creating a thread in Java:</p>
<ul class="calibre17">
<li class="calibre18">Extending the <kbd class="calibre15">Thread</kbd> class and overriding the <kbd class="calibre15">run()</kbd> method.</li>
<li class="calibre18">Building a class that implements the <kbd class="calibre15">Runnable</kbd> interface and the <kbd class="calibre15">run()</kbd> method and then creating an object of the <kbd class="calibre15">Thread</kbd> class by passing the <kbd class="calibre15">Runnable</kbd> object as a parameter--this is the preferred approach and it gives you more flexibility.</li>
</ul>
<p class="calibre4">In this recipe, we will use the second approach to create threads. Then, we will learn how to change some attributes of the threads. The <kbd class="calibre15">Thread</kbd> class saves some information attributes that can help us identify a thread, know its status, or control its priority. These attributes are:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">ID</strong>: This attribute stores a unique identifier for each thread.</li>
<li class="calibre18"><strong class="calibre1">Name</strong>: This attribute stores the name of the thread.</li>
<li class="calibre18"><strong class="calibre1">Priority</strong>: This attribute stores the priority of the <kbd class="calibre15">Thread</kbd> objects. In Java 9, threads can have priority between 1 and 10, where 1 is the lowest priority and 10 is the highest. It's not recommended that you change the priority of the threads. It's only a hint to the underlying operating system and it doesn't guarantee anything, but it's a possibility that you can use if you want.</li>
<li class="calibre18"><strong class="calibre1">Status</strong>: This attribute stores the status of a thread. In Java, a thread can be present in one of the six states defined in the <kbd class="calibre15">Thread.State</kbd> enumeration: <kbd class="calibre15">NEW</kbd>, <kbd class="calibre15">RUNNABLE</kbd>, <kbd class="calibre15">BLOCKED</kbd>, <kbd class="calibre15">WAITING</kbd>, <kbd class="calibre15">TIMED_WAITING</kbd>, or <kbd class="calibre15">TERMINATED</kbd>. The following is a list specifying what each of these states means:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">NEW</kbd>: The thread has been created and it has not yet started</li>
<li class="calibre18"><kbd class="calibre15">RUNNABLE</kbd>: The thread is being executed in the JVM</li>
<li class="calibre18"><kbd class="calibre15">BLOCKED</kbd>: The thread is blocked and it is waiting for a monitor</li>
<li class="calibre18"><kbd class="calibre15">WAITING</kbd>: The thread is waiting for another thread</li>
<li class="calibre18"><kbd class="calibre15">TIMED_WAITING</kbd>: The thread is waiting for another thread with a specified waiting time</li>
<li class="calibre18"><kbd class="calibre15">TERMINATED</kbd>: The thread has finished its execution</li>
</ul>
</li>
</ul>
<p class="calibre4">In this recipe, we will implement an example that will create and run 10 threads that would calculate the prime numbers within the first 20,000 numbers.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example for this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Calculator</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Calculator implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. This method will execute the instructions of the thread we are creating, so this method will calculate the prime numbers within the first <kbd class="calibre15">20000</kbd> numbers:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          long current = 1L; <br class="title-page-name"/>          long max = 20000L; <br class="title-page-name"/>          long numPrimes = 0L; <br class="title-page-name"/> <br class="title-page-name"/>          System.out.printf("Thread '%s': START\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          while (current &lt;= max) { <br class="title-page-name"/>            if (isPrime(current)) { <br class="title-page-name"/>              numPrimes++; <br class="title-page-name"/>            } <br class="title-page-name"/>            current++; <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("Thread '%s': END. Number of Primes: %d\n",<br class="title-page-name"/>                          Thread.currentThread().getName(), numPrimes); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Then, implement the <em class="calibre14">auxiliar</em> <kbd class="calibre15">isPrime()</kbd> method. This method determines whether a number is a prime number or not:</li>
</ol>
<pre class="calibre23">
        private boolean isPrime(long number) { <br class="title-page-name"/>          if (number &lt;= 2) { <br class="title-page-name"/>            return true; <br class="title-page-name"/>          } <br class="title-page-name"/>          for (long i = 2; i &lt; number; i++) { <br class="title-page-name"/>            if ((number % i) == 0) { <br class="title-page-name"/>              return false; <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          return true; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Now implement the main class of the application. Create a class named <kbd class="calibre15">Main</kbd> that contains the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>                public static void main(String[] args) {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">First, write some information regarding the values of the maximum, minimum, and default priority of the threads:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Minimum Priority: %s\n",<br class="title-page-name"/>                          Thread.MIN_PRIORITY); <br class="title-page-name"/>        System.out.printf("Normal Priority: %s\n",<br class="title-page-name"/>                          Thread.NORM_PRIORITY); <br class="title-page-name"/>        System.out.printf("Maximun Priority: %s\n",<br class="title-page-name"/>                          Thread.MAX_PRIORITY);
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Then create 10 <kbd class="calibre15">Thread</kbd> objects to execute 10 <kbd class="calibre15">Calculator</kbd> tasks. Also, create two arrays to store the <kbd class="calibre15">Thread</kbd> objects and their statuses. We will use this information later to check the finalization of the threads. Execute five threads (the even ones) with maximum priority and the other five with minimum priority:</li>
</ol>
<pre class="calibre23">
        Thread threads[]; <br class="title-page-name"/>        Thread.State status[]; <br class="title-page-name"/>        threads = new Thread[10]; <br class="title-page-name"/>        status = new Thread.State[10]; <br class="title-page-name"/>        for (int i = 0; i &lt; 10; i++) { <br class="title-page-name"/>        threads[i] = new Thread(new Calculator()); <br class="title-page-name"/>          if ((i % 2) == 0) { <br class="title-page-name"/>            threads[i].setPriority(Thread.MAX_PRIORITY); <br class="title-page-name"/>          } else { <br class="title-page-name"/>            threads[i].setPriority(Thread.MIN_PRIORITY); <br class="title-page-name"/>          } <br class="title-page-name"/>            threads[i].setName("My Thread " + i); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">We are going to write information in a text file, so create a try-with-resources statement to manage the file. Inside this block of code, write the status of the threads in the file before you launch them. Then, launch the threads:</li>
</ol>
<pre class="calibre23">
        try (FileWriter file = new FileWriter(".\\data\\log.txt");<br class="title-page-name"/>        PrintWriter pw = new PrintWriter(file);) { <br class="title-page-name"/> <br class="title-page-name"/>          for (int i = 0; i &lt; 10; i++) { <br class="title-page-name"/>            pw.println("Main : Status of Thread " + i + " : " + <br class="title-page-name"/>                        threads[i].getState()); <br class="title-page-name"/>            status[i] = threads[i].getState(); <br class="title-page-name"/>          } <br class="title-page-name"/>          for (int i = 0; i &lt; 10; i++) { <br class="title-page-name"/>            threads[i].start(); <br class="title-page-name"/>          }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">After this, wait for the finalization of the threads. As we will learn in the <em class="calibre14">Waiting for the finalization of a thread</em> recipe of this chapter, we can use the <kbd class="calibre15">join()</kbd> method to wait for this to happen. In this case, we want to write information about the threads when their statuses change, so we can't use this method. We use this block of code:</li>
</ol>
<pre class="calibre23">
            boolean finish = false; <br class="title-page-name"/>            while (!finish) { <br class="title-page-name"/>              for (int i = 0; i &lt; 10; i++) { <br class="title-page-name"/>                if (threads[i].getState() != status[i]) { <br class="title-page-name"/>                  writeThreadInfo(pw, threads[i], status[i]); <br class="title-page-name"/>                  status[i] = threads[i].getState(); <br class="title-page-name"/>                } <br class="title-page-name"/>              } <br class="title-page-name"/> <br class="title-page-name"/>              finish = true; <br class="title-page-name"/>              for (int i = 0; i &lt; 10; i++) { <br class="title-page-name"/>                finish = finish &amp;&amp; (threads[i].getState() ==<br class="title-page-name"/>                                  State.TERMINATED); <br class="title-page-name"/>              } <br class="title-page-name"/>            } <br class="title-page-name"/> <br class="title-page-name"/>          } catch (IOException e) {<br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">In the previous block of code, we called the <kbd class="calibre15">writeThreadInfo()</kbd> method to write information about the status of a thread in the file. This is the code for this method:</li>
</ol>
<pre class="calibre23">
        private static void writeThreadInfo(PrintWriter pw,<br class="title-page-name"/>                                            Thread thread,<br class="title-page-name"/>                                            State state) { <br class="title-page-name"/>          pw.printf("Main : Id %d - %s\n", thread.getId(),<br class="title-page-name"/>                     thread.getName()); <br class="title-page-name"/>          pw.printf("Main : Priority: %d\n", thread.getPriority()); <br class="title-page-name"/>          pw.printf("Main : Old State: %s\n", state); <br class="title-page-name"/>          pw.printf("Main : New State: %s\n", thread.getState()); <br class="title-page-name"/>          pw.printf("Main : ************************************\n"); <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Run the program and see how the different threads work in parallel.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The following screenshot shows the console part of the output of the program. We can see that all the threads we have created run in parallel to do their respective jobs:</p>
<div class="cdpaligncenter"><img class="alignnone" src="../images/00005.jpeg"/></div>
<p class="calibre4">In this screenshot, you can see how threads are created and how the ones with an even number are executed first, as they have the highest priority, and the others executed later, as they have minimum priority. The following screenshot shows part of the output of the <kbd class="calibre15">log.txt</kbd> file where we write information about the status of the threads:</p>
<div class="cdpaligncenter"><img class="alignnone1" src="../images/00006.gif"/></div>
<p class="calibre4">Every Java program has at least one execution thread. When you run the program, JVM runs the execution thread that calls the <kbd class="calibre15">main()</kbd> method of the program.</p>
<p class="calibre4">When we call the <kbd class="calibre15">start()</kbd> method of a <kbd class="calibre15">Thread</kbd> object, we are creating another execution thread. Our program will have as many execution threads as the number of calls made to the <kbd class="calibre15">start()</kbd> method.</p>
<p class="calibre4">The <kbd class="calibre15">Thread</kbd> class has attributes to store all of the information of a thread. The OS scheduler uses the priority of threads to select the one that uses the CPU at each moment and actualizes the status of every thread according to its situation.</p>
<p class="calibre4">If you don't specify a name for a thread, JVM automatically assigns it one in this format: Thread-XX, where XX is a number. You can't modify the ID or status of a thread. The <kbd class="calibre15">Thread</kbd> class doesn't implement the <kbd class="calibre15">setId()</kbd> and <kbd class="calibre15">setStatus()</kbd> methods as these methods introduce modifications in the code.</p>
<p class="calibre4">A Java program ends when all its threads finish (more specifically, when all its non-daemon threads finish). If the initial thread (the one that executes the <kbd class="calibre15">main()</kbd> method) ends, the rest of the threads will continue with their execution until they finish. If one of the threads uses the <kbd class="calibre15">System.exit()</kbd> instruction to end the execution of the program, all the threads will end their respective execution.</p>
<p class="calibre4">Creating an object of the <kbd class="calibre15">Thread</kbd> class doesn't create a new execution thread. Also, calling the <kbd class="calibre15">run()</kbd> method of a class that implements the <kbd class="calibre15">Runnable</kbd> interface doesn't create a new execution thread. Only when you call the <kbd class="calibre15">start()</kbd> method, a new execution thread is created.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">As mentioned in the introduction of this recipe, there is another way of creating a new execution thread. You can implement a class that extends the <kbd class="calibre15">Thread</kbd> class and overrides the <kbd class="calibre15">run()</kbd> method of this class. Then, you can create an object of this class and call the <kbd class="calibre15">start()</kbd> method to have a new execution thread.</p>
<p class="calibre4">You can use the static method <kbd class="calibre15">currentThread()</kbd> of the <kbd class="calibre15">Thread</kbd> class to access the thread object that is running the current object.</p>
<p class="calibre4">You have to take into account that the <kbd class="calibre15">setPriority()</kbd> method can throw an <kbd class="calibre15">IllegalArgumentException</kbd> exception if you try to establish priority that isn't between 1 and 10.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating threads through a factory</em> recipe of this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Interrupting a thread</h1>
            

            <article>
                
<p class="calibre4">A Java program with more than one execution thread only finishes when the execution of all of its threads end (more specifically, when all its non-daemon threads end their execution or when one of the threads uses the <kbd class="calibre15">System.exit()</kbd> method). Sometimes, you may need to finish a thread because you want to terminate a program or when a user of the program wants to cancel the tasks that a thread object is doing.</p>
<p class="calibre4">Java provides an interruption mechanism that indicates to a thread that you want to finish it. One peculiarity of this mechanism is that thread objects have to check whether they have been interrupted or not, and they can decide whether they respond to the finalization request or not. A thread object can ignore it and continue with its execution.</p>
<p class="calibre4">In this recipe, we will develop a program that creates a thread and forces its finalization after 5 seconds, using the interruption mechanism.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example forÂ this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class called <kbd class="calibre15">PrimeGenerator</kbd> that extends the <kbd class="calibre15">Thread</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class PrimeGenerator extends Thread{
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Override the <kbd class="calibre15">run()</kbd> method including a loop that will run indefinitely. In this loop, process consecutive numbers beginning from one. For each number, calculate whether it's a prime number; if yes, as in this case, write it to the console:</li>
</ol>
<pre class="calibre23">
<strong class="calibre1">        </strong>@Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          long number=1L; <br class="title-page-name"/>          while (true) { <br class="title-page-name"/>            if (isPrime(number)) { <br class="title-page-name"/>              System.out.printf("Number %d is Prime\n",number); <br class="title-page-name"/>            }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">After processing a number, check whether the thread has been interrupted by calling the <kbd class="calibre15">isInterrupted()</kbd> method. If this method returns <kbd class="calibre15">true</kbd>, the thread has been interrupted. In this case, we write a message in the console and end the execution of the thread:</li>
</ol>
<pre class="calibre23">
            if (isInterrupted()) { <br class="title-page-name"/>              System.out.printf("The Prime Generator has been<br class="title-page-name"/>                                 Interrupted"); <br class="title-page-name"/>              return; <br class="title-page-name"/>            } <br class="title-page-name"/>            number++; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">isPrime()</kbd> method. You can get its code from the <em class="calibre14">Creating, running, and setting information of a thread</em> recipe of this chapter.</li>
<li value="5" class="calibre18">Now implement the main class of the example by implementing a class called <kbd class="calibre15">Main</kbd> and the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create and start an object of the <kbd class="calibre15">PrimeGenerator</kbd> class:</li>
</ol>
<pre class="calibre23">
        Thread task=new PrimeGenerator(); <br class="title-page-name"/>        task.start();
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Wait for 5 seconds and interrupt the <kbd class="calibre15">PrimeGenerator</kbd> thread:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          Thread.sleep(5000); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } <br class="title-page-name"/>        task.interrupt();
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Then, write information related to the status of the interrupted thread. The output of this piece of code will depend on whether the thread ends its execution before or after:</li>
</ol>
<pre class="calibre23">
          System.out.printf("Main: Status of the Thread: %s\n",<br class="title-page-name"/>                            task.getState()); <br class="title-page-name"/>          System.out.printf("Main: isInterrupted: %s\n",<br class="title-page-name"/>                            task.isInterrupted()); <br class="title-page-name"/>          System.out.printf("Main: isAlive: %s\n", task.isAlive()); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Run the example and see the results.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The following screenshot shows the result of the execution of the previous example. We can see how the <kbd class="calibre15">PrimeGenerator</kbd> thread writes the message and ends its execution when it detects that it has been interrupted. Refer to the following screenshot:</p>
<div class="cdpaligncenter"><img class="alignnone2" src="../images/00007.jpeg"/></div>
<p class="calibre4">The <kbd class="calibre15">Thread</kbd> class has an attribute that stores a <kbd class="calibre15">boolean</kbd> value indicating whether the thread has been interrupted or not. When you call the <kbd class="calibre15">interrupt()</kbd> method of a thread, you set that attribute to <kbd class="calibre15">true</kbd>. The <kbd class="calibre15">isInterrupted()</kbd> method only returns the value of that attribute.</p>
<p class="calibre4">The <kbd class="calibre15">main()</kbd> method writes information about the status of the interrupted thread. In this case, as this code is executed before the thread has finished its execution, the status is <kbd class="calibre15">RUNNABLE</kbd>, the return value of the <kbd class="calibre15">isInterrupted()</kbd> method is <kbd class="calibre15">true</kbd>, and the return value of the <kbd class="calibre15">isAlive()</kbd> method is <kbd class="calibre15">true</kbd> as well. If the interrupted <kbd class="calibre15">Thread</kbd> finishes its execution before the execution of this block of code (you can, for example, sleep the main thread for a second), the methods <kbd class="calibre15">isInterrupted()</kbd> and <kbd class="calibre15">isAlive()</kbd> will return a <kbd class="calibre15">false</kbd> value.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Thread</kbd> class has another method to check whether a thread has been interrupted or not. It's the static method, <kbd class="calibre15">interrupted()</kbd>, that checks whether the current thread has been interrupted or not.</p>
<div class="packt_infobox">There is an important difference between the <kbd class="calibre25">isInterrupted()</kbd> and <kbd class="calibre25">interrupted()</kbd> methods. The first one doesn't change the value of the interrupted attribute, but the second one sets it to <kbd class="calibre25">false</kbd>.</div>
<p class="calibre4">As mentioned earlier, a thread object can ignore its interruption, but this is not the expected behavior.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Controlling the interruption of a thread</h1>
            

            <article>
                
<p class="calibre4">In the previous recipe, you learned how you can interrupt the execution of a thread and what you have to do to control this interruption in the thread object. The mechanism shown in the previous example can be used if the thread that can be interrupted is simple. But if the thread implements a complex algorithm divided into some methods or it has methods with recursive calls, we will need to use a better mechanism to control the interruption of the thread. Java provides the <kbd class="calibre15">InterruptedException</kbd> exception for this purpose. You can throw this exception when you detect the interruption of a thread and catch it in the <kbd class="calibre15">run()</kbd> method.</p>
<p class="calibre4">In this recipe, we will implement a task that will look for files with a determined name in a folder and in all its subfolders. This is to show how you can use the <kbd class="calibre15">InterruptedException</kbd> exception to control the interruption of a thread.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example forÂ this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class called <kbd class="calibre15">FileSearch</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class FileSearch implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare two private attributes: one for the name of the file we are going to search for and one for the initial folder. Implement the constructor of the class, which initializes these attributes:</li>
</ol>
<pre class="calibre23">
        private String initPath; <br class="title-page-name"/>        private String fileName; <br class="title-page-name"/>        public FileSearch(String initPath, String fileName) { <br class="title-page-name"/>          this.initPath = initPath; <br class="title-page-name"/>          this.fileName = fileName; <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the <kbd class="calibre15">FileSearch</kbd> class. It checks whether the attribute <kbd class="calibre15">fileName</kbd> is a directory; if it is, it calls the <kbd class="calibre15">directoryProcess()</kbd> method. This method can throw an <kbd class="calibre15">InterruptedException</kbd> exception, so we have to catch them:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          File file = new File(initPath); <br class="title-page-name"/>          if (file.isDirectory()) { <br class="title-page-name"/>            try { <br class="title-page-name"/>              directoryProcess(file); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              System.out.printf("%s: The search has been interrupted",<br class="title-page-name"/>                                Thread.currentThread().getName()); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">directoryProcess()</kbd> method. This method will obtain the files and subfolders in a folder and process them. For each directory, the method will make a recursive call, passing the directory as a parameter. For each file, the method will call the <kbd class="calibre15">fileProcess()</kbd> method. After processing all files and folders, the method checks whether the thread has been interrupted; if yes, as in this case, it will throw an <kbd class="calibre15">InterruptedException</kbd> exception:</li>
</ol>
<pre class="calibre23">
        private void directoryProcess(File file) throws<br class="title-page-name"/>                                  InterruptedException { <br class="title-page-name"/>          File list[] = file.listFiles(); <br class="title-page-name"/>          if (list != null) { <br class="title-page-name"/>            for (int i = 0; i &lt; list.length; i++) { <br class="title-page-name"/>              if (list[i].isDirectory()) { <br class="title-page-name"/>                directoryProcess(list[i]); <br class="title-page-name"/>              } else { <br class="title-page-name"/>                fileProcess(list[i]); <br class="title-page-name"/>              } <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          if (Thread.interrupted()) { <br class="title-page-name"/>            throw new InterruptedException(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">fileProcess()</kbd> method. This method will compare the name of the file it's processing with the name we are searching for. If the names are equal, we will write a message in the console. After this comparison, the thread will check whether it has been interrupted; if yes, as in this case, it will throw an <kbd class="calibre15">InterruptedException</kbd> exception:</li>
</ol>
<pre class="calibre23">
        private void fileProcess(File file) throws <br class="title-page-name"/>                                    InterruptedException { <br class="title-page-name"/>          if (file.getName().equals(fileName)) { <br class="title-page-name"/>            System.out.printf("%s : %s\n",<br class="title-page-name"/>                              Thread.currentThread().getName(),<br class="title-page-name"/>                              file.getAbsolutePath()); <br class="title-page-name"/>          } <br class="title-page-name"/>          if (Thread.interrupted()) { <br class="title-page-name"/>            throw new InterruptedException(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Now let's implement the main class of the example. Implement a class called <kbd class="calibre15">Main</kbd> that contains the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create and initialize an object of the <kbd class="calibre15">FileSearch</kbd> class and thread to execute its task. Then start executing the thread. I have used a Windows operating system route. If you work with other operating systems, such as Linux or iOS, change the route to the one that exists on your operating system:</li>
</ol>
<pre class="calibre23">
        FileSearch searcher = new FileSearch("C:\\Windows",<br class="title-page-name"/>                                             "explorer.exe");<br class="title-page-name"/>        Thread thread=new Thread(searcher); <br class="title-page-name"/>        thread.start();
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Wait for 10 seconds and interrupt the thread:</li>
</ol>
<pre class="calibre23">
          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(10); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          thread.interrupt(); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Run the example and see the results.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The following screenshot shows the result of an execution of this example. You can see how the <kbd class="calibre15">FileSearch</kbd> object ends its execution when it detects that it has been interrupted.</p>
<div class="cdpaligncenter"><img class="alignnone3" src="../images/00008.jpeg"/></div>
<p class="calibre4">In this example, we use Java exceptions to control the interruption of a thread. When you run the example, the program starts going through folders by checking whether they have the file or not. For example, if you enter in the <kbd class="calibre15">\b\c\d</kbd> folder, the program will have three recursive calls to the <kbd class="calibre15">directoryProcess()</kbd> method. When it detects that it has been interrupted, it throws an <kbd class="calibre15">InterruptedException</kbd> exception and continues the execution in the <kbd class="calibre15">run()</kbd> method, no matter how many recursive calls have been made.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">InterruptedException</kbd> exception is thrown by some Java methods related to a concurrency API, such as <kbd class="calibre15">sleep()</kbd>. In this case, this exception is thrown if the thread is interrupted (with the <kbd class="calibre15">interrupt()</kbd> method) when it's sleeping.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Interrupting a thread</em> recipe of this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Sleeping and resuming a thread</h1>
            

            <article>
                
<p class="calibre4">Sometimes, you may be interested in pausing the execution of a thread during a determined period of time. For example, a thread in a program checks the sensor state once per minute. The rest of the time, it does nothing. During this time, the thread doesn't use any resources of the computer. After this period is over, the thread will be ready to continue with its execution when the operating system scheduler chooses it to be executed. You can use the <kbd class="calibre15">sleep()</kbd> method of the <kbd class="calibre15">Thread</kbd> class for this purpose. This method receives a long number as a parameter that indicates the number of milliseconds during which the thread will suspend its execution. After that time, the thread continues with its execution in the next instruction to the <kbd class="calibre15">sleep()</kbd> one when the JVM assigns it CPU time.</p>
<p class="calibre4">Another possibility is to use the <kbd class="calibre15">sleep()</kbd> method of an element of the <kbd class="calibre15">TimeUnit</kbd> enumeration. This method uses the <kbd class="calibre15">sleep()</kbd> method of the <kbd class="calibre15">Thread</kbd> class to put the current thread to sleep, but it receives the parameter in the unit that it represents and converts it into milliseconds.</p>
<p class="calibre4">In this recipe, we will develop a program that uses the <kbd class="calibre15">sleep()</kbd> method to write the actual date every second.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example for this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class called <kbd class="calibre15">ConsoleClock</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class ConsoleClock implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() {
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Write a loop with 10 iterations. In each iteration, create a <kbd class="calibre15">Date</kbd> object, write it to the console, and call the <kbd class="calibre15">sleep()</kbd> method of the <kbd class="calibre15">SECONDS</kbd> attribute of the <kbd class="calibre15">TimeUnit</kbd> class to suspend the execution of the thread for 1 second. With this value, the thread will be sleeping for approximately 1 second. As the <kbd class="calibre15">sleep()</kbd> method can throw an <kbd class="calibre15">InterruptedException</kbd> exception, we have to include some code to catch it. It's good practice to include code that frees or closes the resources the thread is using when it's interrupted:</li>
</ol>
<pre class="calibre23">
          for (int i = 0; i &lt; 10; i++) { <br class="title-page-name"/>            System.out.printf("%s\n", new Date()); <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              System.out.printf("The FileClock has been interrupted"); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">We have implemented the thread. Now let's implement the main class of the example. Create a class called <kbd class="calibre15">Main</kbd> that contains the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create an object of the <kbd class="calibre15">FileClock</kbd> class and a <kbd class="calibre15">thread</kbd> to execute it. Then, start executing a thread:</li>
</ol>
<pre class="calibre23">
        FileClock clock=new FileClock(); <br class="title-page-name"/>        Thread thread=new Thread(clock); <br class="title-page-name"/>        thread.start();
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Call the <kbd class="calibre15">sleep()</kbd> method of the <kbd class="calibre15">SECONDS</kbd> attribute of the <kbd class="calibre15">TimeUnit</kbd> class in the main thread to wait for 5 seconds:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(5); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        };
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Interrupt the <kbd class="calibre15">FileClock</kbd> thread:</li>
</ol>
<pre class="calibre23">
        thread.interrupt();
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Run the example and see the results.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">When you run the example, you would see how the program writes a <kbd class="calibre15">Date</kbd> object per second and also the message indicating that the <kbd class="calibre15">FileClock</kbd> thread has been interrupted.</p>
<p class="calibre4">When you call the <kbd class="calibre15">sleep()</kbd> method, the thread leaves the CPU and stops its execution for a period of time. During this time, it's not consuming CPU time, so the CPU could be executing other tasks.</p>
<p class="calibre4">When the thread is sleeping and is interrupted, the method throws an <kbd class="calibre15">InterruptedException</kbd> exception immediately and doesn't wait until the sleeping time is finished.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The Java concurrency API has another method that makes a thread object leave the CPU. It's the <kbd class="calibre15">yield()</kbd> method, which indicates to the JVM that the thread object can leave the CPU for other tasks. The JVM does not guarantee that it will comply with this request. Normally, it's only used for debugging purposes.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Waiting for the finalization of a thread</h1>
            

            <article>
                
<p class="calibre4">In some situations, we will have to wait for the end of the execution of a thread (the <kbd class="calibre15">run()</kbd> method ends its execution). For example, we may have a program that will begin initializing the resources it needs before proceeding with the rest of the execution. We can run initialization tasks as threads and wait for their finalization before continuing with the rest of the program.</p>
<p class="calibre4">For this purpose, we can use the <kbd class="calibre15">join()</kbd> method of the <kbd class="calibre15">Thread</kbd> class. When we call this method using a thread object, it suspends the execution of the calling thread until the object that is called finishes its execution.</p>
<p class="calibre4">In this recipe, we will learn the use of this method with an initialization example.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example for this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class called <kbd class="calibre15">DataSourcesLoader</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class DataSourcesLoader implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It writes a message to indicate that it starts its execution, sleeps for 4 seconds, and writes another message to indicate that it ends its execution:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          System.out.printf("Beginning data sources loading: %s\n",<br class="title-page-name"/>                            new Date()); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(4); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          
</pre>
<pre class="calibre23">
          System.out.printf("Data sources loading has finished: %s\n",<br class="title-page-name"/>                            new Date()); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Create a class called <kbd class="calibre15">NetworkConnectionsLoader</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. Implement the <kbd class="calibre15">run()</kbd> method. It will be equal to the <kbd class="calibre15">run()</kbd> method of the <kbd class="calibre15">DataSourcesLoader</kbd> class, but it will sleep for 6 seconds.</li>
<li value="4" class="calibre18">Now, create a class called <kbd class="calibre15">Main</kbd> that contains the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create an object of the <kbd class="calibre15">DataSourcesLoader</kbd> class and a thread to run it:</li>
</ol>
<pre class="calibre23">
       DataSourcesLoader dsLoader = new DataSourcesLoader(); <br class="title-page-name"/>       Thread thread1 = new Thread(dsLoader,"DataSourceThread");
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create an object of the <kbd class="calibre15">NetworkConnectionsLoader</kbd> class and a thread to run it:</li>
</ol>
<pre class="calibre23">
        NetworkConnectionsLoader ncLoader = new NetworkConnectionsLoader(); <br class="title-page-name"/>        Thread thread2 = new Thread(ncLoader,"NetworkConnectionLoader");
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Call the <kbd class="calibre15">start()</kbd> method of both the thread objects:</li>
</ol>
<pre class="calibre23">
        thread1.start(); <br class="title-page-name"/>        thread2.start();
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Wait for the finalization of both the threads using the <kbd class="calibre15">join()</kbd> method. This method can throw an <kbd class="calibre15">InterruptedException</kbd> exception, so we have to include the code to catch it:</li>
</ol>
<pre class="calibre23">
       try { <br class="title-page-name"/>          thread1.join(); <br class="title-page-name"/>          thread2.join(); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Write a message to indicate the end of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Configuration has been loaded: %s\n",<br class="title-page-name"/>                          new Date());
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Run the program and see the results.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">When you run this program, you would understand how both the thread objects start their execution. First, the <kbd class="calibre15">DataSourcesLoader</kbd> thread finishes its execution. Then, the <kbd class="calibre15">NetworkConnectionsLoader</kbd> class finishes its execution. At this moment, the <kbd class="calibre15">main</kbd>Â thread object continues its execution and writes the final message.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">Java provides two additional forms of the <kbd class="calibre15">join()</kbd> method:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">join (long milliseconds)</kbd></li>
<li class="calibre18"><kbd class="calibre15">join (long milliseconds, long nanos)</kbd></li>
</ul>
<p class="calibre4">In the first version of the <kbd class="calibre15">join()</kbd> method, instead of indefinitely waiting for the finalization of the thread called, the calling thread waits for the milliseconds specified as the parameter of the method. For example, if the object <kbd class="calibre15">thread1</kbd> has <kbd class="calibre15">thread2.join(1000)</kbd>, <kbd class="calibre15">thread1</kbd> suspends its execution until one of these two conditions are met:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">thread2</kbd> has finished its execution</li>
<li class="calibre18">1,000 milliseconds have passed</li>
</ul>
<p class="calibre4">When one of these two conditions is <kbd class="calibre15">true</kbd>, the <kbd class="calibre15">join()</kbd> method returns. You can check the status of the thread to know whether the <kbd class="calibre15">join()</kbd> method was returned because it finished its execution or because the specified time had passed.</p>
<p class="calibre4">The second version of the <kbd class="calibre15">join()</kbd> method is similar to the first one, but it receives the number of milliseconds and nanoseconds as parameters.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating and running a daemon thread</h1>
            

            <article>
                
<p class="calibre4">Java has a special kind of thread called <strong class="calibre1">daemon</strong> thread. When daemon threads are the only threads running in a program, the JVM ends the program after finishing these threads.</p>
<p class="calibre4">With these characteristics, daemon threads are normally used as service providers for normal (also called <strong class="calibre1">user</strong>) threads running in the same program. They usually have an infinite loop that waits for the service request or performs the tasks of a thread. A typical example of these kinds of threads is the Java garbage collector.</p>
<p class="calibre4">In this recipe, we will learn how to create a daemon thread by developing an example with two threads: one user thread that would write events on a queue and a daemon thread that would clean the queue, removing the events that were generated more than 10 seconds ago.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example forÂ this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create the <kbd class="calibre15">Event</kbd> class. This class only stores information about the events our program will work with. Declare two private attributes: one called the date of the <kbd class="calibre15">java.util.Date</kbd> type and the other called the event of the <kbd class="calibre15">String</kbd> type. Generate the methods to write and read their values.</li>
<li value="2" class="calibre18">Create the <kbd class="calibre15">WriterTask</kbd> class and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class WriterTask implements Runnable {
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare the queue that stores the events and implement the constructor of the class that initializes this queue:</li>
</ol>
<pre class="calibre23">
        private Deque&lt;Event&gt; deque; <br class="title-page-name"/>        public WriterTask (Deque&lt;Event&gt; deque){ <br class="title-page-name"/>          this.deque=deque; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of this task. This method will have a loop with 100 iterations. In each iteration, we create a new event, save it in the queue, and sleep for 1 second:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=1; i&lt;100; i++) { <br class="title-page-name"/>            Event event=new Event(); <br class="title-page-name"/>            event.setDate(new Date()); <br class="title-page-name"/>            event.setEvent(String.format("The thread %s has generated<br class="title-page-name"/>                           an event", Thread.currentThread().getId())); <br class="title-page-name"/>            deque.addFirst(event); <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create the <kbd class="calibre15">CleanerTask</kbd> class and specify that it extends the <kbd class="calibre15">Thread</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class CleanerTask extends Thread {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare the queue that stores the events and implement the constructor of the class that initializes this queue. In the constructor, mark this thread as a daemon thread with the <kbd class="calibre15">setDaemon()</kbd> method:</li>
</ol>
<pre class="calibre23">
        private Deque&lt;Event&gt; deque; <br class="title-page-name"/>        public CleanerTask(Deque&lt;Event&gt; deque) { <br class="title-page-name"/>          this.deque = deque; <br class="title-page-name"/>          setDaemon(true); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It has an infinite loop that gets the actual date and calls the <kbd class="calibre15">clean()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          while (true) { <br class="title-page-name"/>            Date date = new Date(); <br class="title-page-name"/>            clean(date); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">clean()</kbd> method. It gets the last event, and if it was created more than 10 seconds ago, it deletes it and checks the next event. If an event is deleted, it writes the message of the event and the new size of the queue so you can see its evolution:</li>
</ol>
<pre class="calibre23">
        private void clean(Date date) { <br class="title-page-name"/>          long difference; <br class="title-page-name"/>          boolean delete; <br class="title-page-name"/>         <br class="title-page-name"/>          if (deque.size()==0) { <br class="title-page-name"/>           return; <br class="title-page-name"/>          } <br class="title-page-name"/>          delete=false; <br class="title-page-name"/>          do { <br class="title-page-name"/>            Event e = deque.getLast(); <br class="title-page-name"/>            difference = date.getTime() - e.getDate().getTime(); <br class="title-page-name"/>            if (difference &gt; 10000) { <br class="title-page-name"/>              System.out.printf("Cleaner: %s\n",e.getEvent()); <br class="title-page-name"/>              deque.removeLast(); <br class="title-page-name"/>              delete=true; <br class="title-page-name"/>            } <br class="title-page-name"/>          } while (difference &gt; 10000); <br class="title-page-name"/>          if (delete){ <br class="title-page-name"/>            System.out.printf("Cleaner: Size of the queue: %d\n",<br class="title-page-name"/>                              deque.size()); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Now implement the <kbd class="calibre15">main</kbd> class. Create a class called <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create the queue to store the events using the <kbd class="calibre15">Deque</kbd> class:</li>
</ol>
<pre class="calibre23">
        Deque&lt;Event&gt; deque=new ConcurrentLinkedDeque&lt;Event&gt;();
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create and start as many <kbd class="calibre15">WriterTask</kbd> threads as available processors have the JVM and one <kbd class="calibre15">CleanerTask</kbd> method:</li>
</ol>
<pre class="calibre23">
        WriterTask writer=new WriterTask(deque); <br class="title-page-name"/>        for (int i=0; i&lt; Runtime.getRuntime().availableProcessors();<br class="title-page-name"/>             i++){ <br class="title-page-name"/>          Thread thread=new Thread(writer); <br class="title-page-name"/>          thread.start(); <br class="title-page-name"/>        } <br class="title-page-name"/>        CleanerTask cleaner=new CleanerTask(deque); <br class="title-page-name"/>        cleaner.start();
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Run the program and see the results.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">If you analyze the output of one execution of the program, you would see how the queue begins to grow until it has a size of, in our case, <kbd class="calibre15">40</kbd> events. Then, its size will vary around <kbd class="calibre15">40</kbd> events it has grown up to until the end of the execution. This size may depend on the number of cores of your machine. I have executed the code in a four-core processor, so we launch four <kbd class="calibre15">WriterTask</kbd> tasks.</p>
<p class="calibre4">The program starts with four <kbd class="calibre15">WriterTask</kbd> threads. Each thread writes an event and sleeps for 1 second. After the first <kbd class="calibre15">10</kbd> seconds, we have <kbd class="calibre15">40</kbd> events in the queue. During these <kbd class="calibre15">10</kbd> seconds, <kbd class="calibre15">CleanerTask</kbd> are executed whereas the fourÂ <kbd class="calibre15">WriterTask</kbd> threads sleep; however, but it doesn't delete any event because all of them were generated less than <kbd class="calibre15">10</kbd> seconds ago. During the rest of the execution, <kbd class="calibre15">CleanerTask</kbd> deletes four events every second and the four <kbd class="calibre15">WriterTask</kbd> threads write another four; therefore, the size of the queue varies around <kbd class="calibre15">40</kbd> events it has grown up to. Remember that the execution of this example depends on the number of available cores to the JVM of your computer. Normally, this number is equal to the number of cores of your CPU.</p>
<p class="calibre4">You can play with time until the <kbd class="calibre15">WriterTask</kbd> threads are sleeping. If you use a smaller value, you will see that <kbd class="calibre15">CleanerTask</kbd> has less CPU time and the size of the queue will increase because <kbd class="calibre15">CleanerTask</kbd> doesn't delete any event.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">You only can call the <kbd class="calibre15">setDaemon()</kbd> method before you call the <kbd class="calibre15">start()</kbd> method. Once the thread is running, you can't modify its daemon status calling the <kbd class="calibre15">setDaemon()</kbd> method. If you call it, you will get an <kbd class="calibre15">IllegalThreadStateException</kbd> exception.</p>
<p class="calibre4">You can use the <kbd class="calibre15">isDaemon()</kbd> method to check whether a thread is a daemon thread (the method returns <kbd class="calibre15">true</kbd>) or a non-daemon thread (the method returns <kbd class="calibre15">false</kbd>).</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Processing uncontrolled exceptions in a thread</h1>
            

            <article>
                
<p class="calibre4">A very important aspect in every programming language is the mechanism that helps you manage error situations in your application. The Java programming language, as almost all modern programming languages, implements an exception-based mechanism to manage error situations. These exceptions are thrown by Java classes when an error situation is detected. You can also use these exceptions or implement your own exceptions to manage the errors produced in your classes.</p>
<p class="calibre4">Java also provides a mechanism to capture and process these exceptions. There are exceptions that must be captured or re-thrown using the <kbd class="calibre15">throws</kbd> clause of a method. These exceptions are called checked exceptions. There are exceptions that don't have to be specified or caught. These are unchecked exceptions:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Checked exceptions</strong>: These must be specified in the <kbd class="calibre15">throws</kbd> clause of a method or caught inside them, for example, <kbd class="calibre15">IOException</kbd> or <kbd class="calibre15">ClassNotFoundException</kbd>.</li>
<li class="calibre18"><strong class="calibre1">Unchecked exceptions</strong>: These don't need to be specified or caught, for example, <kbd class="calibre15">NumberFormatException</kbd>.</li>
</ul>
<p class="calibre4">When a checked exception is thrown inside the <kbd class="calibre15">run()</kbd> method of a thread object, we have to catch and treat them because the <kbd class="calibre15">run()</kbd> method doesn't accept a <kbd class="calibre15">throws</kbd> clause. When an unchecked exception is thrown inside the <kbd class="calibre15">run()</kbd> method of a thread object, the default behavior is to write the stack trace in the console and exit the program.</p>
<p class="calibre4">Fortunately, Java provides us with a mechanism to catch and treat unchecked exceptions thrown in a thread object to avoid ending the program.</p>
<p class="calibre4">In this recipe, we will learn this mechanism using an example.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example forÂ this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First of all, we have to implement a class to treat unchecked exceptions. This class must implement the <kbd class="calibre15">UncaughtExceptionHandler</kbd> interface and implement the <kbd class="calibre15">uncaughtException()</kbd> method declared in this interface. It's an interface enclosed in the <kbd class="calibre15">Thread</kbd> class. In our case, let's call this class <kbd class="calibre15">ExceptionHandler</kbd> and create a method to write information about <kbd class="calibre15">Exception</kbd> and <kbd class="calibre15">Thread</kbd> that threw it. The following is the code:</li>
</ol>
<pre class="calibre23">
        public class ExceptionHandler implements UncaughtExceptionHandler { <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void uncaughtException(Thread t, Throwable e) { <br class="title-page-name"/>            System.out.printf("An exception has been captured\n"); <br class="title-page-name"/>            System.out.printf("Thread: %s\n",t.getId()); <br class="title-page-name"/>            System.out.printf("Exception: %s: %s\n",<br class="title-page-name"/>                              e.getClass().getName(),e.getMessage()); <br class="title-page-name"/>            System.out.printf("Stack Trace: \n"); <br class="title-page-name"/>            e.printStackTrace(System.out); <br class="title-page-name"/>            System.out.printf("Thread status: %s\n",t.getState()); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Now implement a class that throws an unchecked exception. Call this class <kbd class="calibre15">Task</kbd>, specify that it implements the <kbd class="calibre15">Runnable</kbd> interface, implement the <kbd class="calibre15">run()</kbd> method, and force the exception; for example, try to convert a <kbd class="calibre15">String</kbd> value into an <kbd class="calibre15">int</kbd> value:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable { <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void run() { <br class="title-page-name"/>            int numero=Integer.parseInt("TTT"); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Now implement the main class of the example. Implement a class called <kbd class="calibre15">Main</kbd> with its <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Create a <kbd class="calibre15">Task</kbd> object and <kbd class="calibre15">Thread</kbd> to run it. Set the unchecked exception handler using the <kbd class="calibre15">setUncaughtExceptionHandler()</kbd> method and start executing the thread:</li>
</ol>
<pre class="calibre23">
            Task task=new Task(); <br class="title-page-name"/>            Thread thread=new Thread(task); <br class="title-page-name"/>            thread.setUncaughtExceptionHandler(new ExceptionHandler()); <br class="title-page-name"/>            thread.start(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Run the example and see the results.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In the following screenshot, you can see the results of the execution of the example. The exception is thrown and captured by the handler that writes the information about <kbd class="calibre15">Exception</kbd> and <kbd class="calibre15">Thread</kbd> that threw it. This information is presented in the console:</p>
<div class="cdpaligncenter"><img class="alignnone4" src="../images/00009.jpeg"/></div>
<p class="calibre4">When an exception is thrown in a thread and remains uncaught (it has to be an unchecked exception), the JVM checks whether the thread has an uncaught exception handler set by the corresponding method. If it does, the JVM invokes this method with the <kbd class="calibre15">Thread</kbd> object and <kbd class="calibre15">Exception</kbd> as arguments.</p>
<p class="calibre4">If the thread doesn't have an uncaught exception handler, the JVM prints the stack trace in the console and ends the execution of the thread that had thrown the exception.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Thread</kbd> class has another method related to the process of uncaught exceptions. It's the static method <kbd class="calibre15">setDefaultUncaughtExceptionHandler()</kbd> that establishes an exception handler for all the thread objects in the application.</p>
<p class="calibre4">When an uncaught exception is thrown in the thread, the JVM looks for three possible handlers for this exception.</p>
<p class="calibre4">First it looks for the uncaught exception handler of the thread objects, as we learned in this recipe. If this handler doesn't exist, the JVM looks for the uncaught exception handler of <kbd class="calibre15">ThreadGroup</kbd>Â as explained in the <em class="calibre14">Grouping threads and processing uncontrolled exceptions in a group of threads</em> recipe. If this method doesn't exist, the JVM looks for the default uncaught exception handler, as we learned in this recipe.</p>
<p class="calibre4">If none of the handlers exits, the JVM writes the stack trace of the exception in the console and ends the execution of the Thread that had thrown the exception.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Grouping threads and processing uncontrolled exceptions in a group of threads</em> recipe of this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using thread local variables</h1>
            

            <article>
                
<p class="calibre4">One of the most critical aspects of a concurrent application is shared data. This has special importance in objects that extend the <kbd class="calibre15">Thread</kbd> class or implement the <kbd class="calibre15">Runnable</kbd> interface and in objects that are shared between two or more threads.</p>
<p class="calibre4">If you create an object of a class that implements the <kbd class="calibre15">Runnable</kbd> interface and then start various thread objects using the same <kbd class="calibre15">Runnable</kbd> object, all the threads would share the same attributes. This means that if you change an attribute in a thread, all the threads will be affected by this change.</p>
<p class="calibre4">Sometimes, you will be interested in having an attribute that won't be shared among all the threads that run the same object. The Java Concurrency API provides a clean mechanism called <strong class="calibre1">thread-local variables</strong> with very good performance. They have some disadvantages as well. They retain their value while the thread is alive. This can be problematic in situations where threads are reused.</p>
<p class="calibre4">In this recipe, we will develop two programs: one that would expose the problem in the first paragraph and another that would solve this problem using the thread-local variables mechanism.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example for this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, implement a program that has the problem exposed previously. Create a class called <kbd class="calibre15">UnsafeTask</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. Declare a private <kbd class="calibre15">java.util.Date</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        public class UnsafeTask implements Runnable{ <br class="title-page-name"/>          private Date startDate;
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the <kbd class="calibre15">UnsafeTask</kbd> object. This method will initialize the <kbd class="calibre15">startDate</kbd> attribute, write its value to the console, sleep for a random period of time, and again write the value of the <kbd class="calibre15">startDate</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          startDate=new Date(); <br class="title-page-name"/>          System.out.printf("Starting Thread: %s : %s\n",<br class="title-page-name"/>                            Thread.currentThread().getId(),startDate); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep( (int)Math.rint(Math.random()*10)); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("Thread Finished: %s : %s\n",<br class="title-page-name"/>                            Thread.currentThread().getId(),startDate); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Now, implement the main class of this problematic application. Create a class called <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method. This method will create an object of the <kbd class="calibre15">UnsafeTask</kbd> class and start <kbd class="calibre15">10</kbd> threads using this object, sleeping for 2 seconds between each thread:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/>            UnsafeTask task=new UnsafeTask(); <br class="title-page-name"/>            for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>              Thread thread=new Thread(task); <br class="title-page-name"/>              thread.start(); <br class="title-page-name"/>              try { <br class="title-page-name"/>                TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>              } catch (InterruptedException e) { <br class="title-page-name"/>                e.printStackTrace(); <br class="title-page-name"/>              } <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">In the following screenshot, you can see the results of this program's execution. Each thread has a different start time, but when they finish, there is a change in the value of the attribute. So they are writing a bad value. For example, check out the thread with the ID 13:</li>
</ol>
<div class="cdpaligncenter"><img class="alignnone5" src="../images/00010.jpeg"/></div>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">As mentioned earlier, we are going to use the thread-local variables mechanism to solve this problem.</li>
<li value="6" class="calibre18">Create a class called <kbd class="calibre15">SafeTask</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class SafeTask implements Runnable {
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Declare an object of the <kbd class="calibre15">ThreadLocal&lt;Date&gt;</kbd> class. This object will have an implicit implementation that would include the <kbd class="calibre15">initialValue()</kbd> method. This method will return the actual date:</li>
</ol>
<pre class="calibre23">
           private static ThreadLocal&lt;Date&gt; startDate=new<br class="title-page-name"/>                                                ThreadLocal&lt;Date&gt;(){ <br class="title-page-name"/>          protected Date initialValue(){ <br class="title-page-name"/>            return new Date(); <br class="title-page-name"/>          } <br class="title-page-name"/>        };
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It has the same functionality as the <kbd class="calibre15">run()</kbd> method of <kbd class="calibre15">UnsafeTask class</kbd>, but it changes the way it accesses the <kbd class="calibre15">startDate</kbd> attribute. Now we will use the <kbd class="calibre15">get()</kbd> method of the <kbd class="calibre15">startDate</kbd> object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          System.out.printf("Starting Thread: %s : %s\n",<br class="title-page-name"/>                       Thread.currentThread().getId(),startDate.get()); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep((int)Math.rint(Math.random()*10)); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("Thread Finished: %s : %s\n",<br class="title-page-name"/>                       Thread.currentThread().getId(),startDate.get()); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">The <kbd class="calibre15">Main</kbd> class of this example is the same as the unsafe example. The only difference is that it changes the name of the <kbd class="calibre15">Runnable</kbd> class.</li>
<li value="10" class="calibre18">Run the example and analyze the difference.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In the following screenshot, you can see the results of the execution of the safe sample. The ten <kbd class="calibre15">Thread</kbd> objects have their own value of the <kbd class="calibre15">startDate</kbd> attribute:</p>
<div class="cdpaligncenter"><img class="alignnone6" src="../images/00011.jpeg"/></div>
<p class="calibre4">The thread-local variables mechanism stores a value of an attribute for each thread that uses one of these variables. You can read the value using the <kbd class="calibre15">get()</kbd> method and change the value using the <kbd class="calibre15">set()</kbd> method. The first time you access the value of a thread-local variable, if it has no value for the thread object that it is calling, the thread-local variable will call the <kbd class="calibre15">initialValue()</kbd> method to assign a value for that thread and return the initial value.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The thread-local class also provides the <kbd class="calibre15">remove()</kbd> method that deletes the value stored in a thread-local variable for the thread that it's calling.</p>
<p class="calibre4">The Java Concurrency API includes the <kbd class="calibre15">InheritableThreadLocal</kbd> class that provides inheritance of values for threads created from a thread. If thread <kbd class="calibre15">A</kbd> has a value in a thread-local variable and it creates another thread <kbd class="calibre15">B</kbd>, then thread <kbd class="calibre15">B</kbd> will have the same value as thread <kbd class="calibre15">A</kbd> in the thread-local variable. You can override the <kbd class="calibre15">childValue()</kbd> method that is called to initialize the value of the child thread in the thread-local variable. It receives the value of the parent thread as a parameter in the thread-local variable.</p>
<p class="calibre4">Â <br class="title-page-name"/></p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Grouping threads and processing uncontrolled exceptions in a group of threads</h1>
            

            <article>
                
<p class="calibre4">An interesting functionality offered by the concurrency API of Java is the ability to group threads. This allows us to treat the threads of a group as a single unit and provide access to the thread objects that belong to a group in order to do an operation with them. For example, you have some threads doing the same task and you want to control them. You can, for example, interrupt all the threads of the group with a single call.</p>
<p class="calibre4">Java provides the <kbd class="calibre15">ThreadGroup</kbd> class to work with a groups of threads. A <kbd class="calibre15">ThreadGroup</kbd> object can be formed by thread objects and another <kbd class="calibre15">ThreadGroup</kbd> object, generating a tree structure of threads.</p>
<p class="calibre4">In the <em class="calibre14">Controlling the interruption of a thread</em> recipe, you learned how to use a generic method to process all the uncaught exceptions that are thrown in a thread object. In the <em class="calibre14">Processing uncontrolled exceptions in a thread</em> recipe, we wrote a handler to process the uncaught exceptions thrown by a thread. We can use a similar mechanism to process the uncaught exceptions thrown by a thread or a group of threads.</p>
<p class="calibre4">In this recipe, we will learn to work with <kbd class="calibre15">ThreadGroup</kbd> objects and how to implement and set the handler that would process uncaught exceptions in a group of threads. We'll do this using an example.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example for this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, extend the <kbd class="calibre15">ThreadGroup</kbd> class by creating a class called <kbd class="calibre15">MyThreadGroup</kbd> that would be extended from <kbd class="calibre15">ThreadGroup</kbd>. You have to declare a constructor with one parameter because the <kbd class="calibre15">ThreadGroup</kbd> class doesn't have a constructor without it. Extend the <kbd class="calibre15">ThreadGroup</kbd> class to override the <kbd class="calibre15">uncaughtException()</kbd> method in order to process the exceptions thrown by the threads of the group:</li>
</ol>
<pre class="calibre23">
        public class MyThreadGroup extends ThreadGroup { <br class="title-page-name"/>          public MyThreadGroup(String name) { <br class="title-page-name"/>            super(name); <br class="title-page-name"/>          }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Override the <kbd class="calibre15">uncaughtException()</kbd> method. This method is called when an exception is thrown in one of the threads of the <kbd class="calibre15">ThreadGroup</kbd> class. In this case, the method will write information about the exception and the thread that throws it; it will present this information in the console. Also, note that this method will interrupt the rest of the threads in the <kbd class="calibre15">ThreadGroup</kbd> class:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void uncaughtException(Thread t, Throwable e) { <br class="title-page-name"/>          System.out.printf("The thread %s has thrown an Exception\n",<br class="title-page-name"/>                            t.getId()); <br class="title-page-name"/>          e.printStackTrace(System.out); <br class="title-page-name"/>          System.out.printf("Terminating the rest of the Threads\n"); <br class="title-page-name"/>          interrupt(); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Create a class called <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. In this case, we will provoke an <kbd class="calibre15">AritmethicException</kbd> exception. For this, we will divide 1,000 with random numbers until the random generator generates zero to throw the exception:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          int result; <br class="title-page-name"/>          Random random=new Random(Thread.currentThread().getId()); <br class="title-page-name"/>          while (true) { <br class="title-page-name"/>            result=1000/((int)(random.nextDouble()*1000000000)); <br class="title-page-name"/>            if (Thread.currentThread().isInterrupted()) { <br class="title-page-name"/>              System.out.printf("%d : Interrupted\n",<br class="title-page-name"/>                                Thread.currentThread().getId()); <br class="title-page-name"/>              return; <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Now, implement the main class of the example by creating a class called <kbd class="calibre15">Main</kbd> and implement the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">First, calculate the number of threads you are going to launch. We use the <kbd class="calibre15">availableProcessors()</kbd> method of the <kbd class="calibre15">Runtime</kbd> class (we obtain the runtime object associated with the current Java application with the static method, called <kbd class="calibre15">getRuntime()</kbd>, of that class). This method returns the number of processors available to the JVM, which is normally equal to the number of cores of the computer that run the application:</li>
</ol>
<pre class="calibre23">
        int numberOfThreads = 2 * Runtime.getRuntime()<br class="title-page-name"/>                                      .availableProcessors();
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create an object of the <kbd class="calibre15">MyThreadGroup</kbd> class:</li>
</ol>
<pre class="calibre23">
        MyThreadGroup threadGroup=new MyThreadGroup("MyThreadGroup");
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create an object of the <kbd class="calibre15">Task</kbd> class:</li>
</ol>
<pre class="calibre23">
        Task task=new Task();
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Create the calculated number of <kbd class="calibre15">Thread</kbd> objects with this <kbd class="calibre15">Task</kbd> class and start them:</li>
</ol>
<pre class="calibre23">
        for (int i = 0; i &lt; numberOfThreads; i++) { <br class="title-page-name"/>          Thread t = new Thread(threadGroup, task); <br class="title-page-name"/>          t.start(); <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Then, write information about <kbd class="calibre15">ThreadGroup</kbd> in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Number of Threads: %d\n",<br class="title-page-name"/>                          threadGroup.activeCount()); <br class="title-page-name"/>        System.out.printf("Information about the Thread Group\n"); <br class="title-page-name"/>        threadGroup.list();
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Finally, write the status of the threads that form the group:</li>
</ol>
<pre class="calibre23">
            Thread[] threads = new Thread[threadGroup.activeCount()]; <br class="title-page-name"/>            threadGroup.enumerate(threads); <br class="title-page-name"/>            for (int i = 0; i &lt; threadGroup.activeCount(); i++) { <br class="title-page-name"/>              System.out.printf("Thread %s: %s\n", threads[i].getName(),<br class="title-page-name"/>                                threads[i].getState()); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Run the example and see the results.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In the following screenshot, you can see the output of the <kbd class="calibre15">list()</kbd> method of the <kbd class="calibre15">ThreadGroup</kbd> class and the output generated when we write the status of each <kbd class="calibre15">Thread</kbd> object:</p>
<div class="cdpaligncenter"><img class="alignnone7" src="../images/00012.jpeg"/></div>
<p class="calibre4">The <kbd class="calibre15">ThreadGroup</kbd> class stores thread objects and other <kbd class="calibre15">ThreadGroup</kbd> objects associated with it so it can access all of their information (status, for example) and perform operations over all its members (interrupt, for example).</p>
<p class="calibre4">Check out how one of the thread objects threw the exception that interrupted the other objects:</p>
<div class="cdpaligncenter"><img class="alignnone8" src="../images/00013.jpeg"/></div>
<p class="calibre4">When an uncaught exception is thrown in a <kbd class="calibre15">Thread</kbd> object, the JVM looks for three possible handlers for this exception.</p>
<p class="calibre4">First, it looks for the uncaught exception handler of the thread, as explained in the <em class="calibre14">Processing uncontrolled exceptions in a thread</em> recipe. If this handler doesn't exist, then the JVM looks for the uncaught exception handler of the <kbd class="calibre15">ThreadGroup</kbd> class of the thread, as learned in this recipe. If this method doesn't exist, the JVM looks for the default uncaught exception handler, as explained in the <em class="calibre14">Processing uncontrolled exceptions in a thread</em> recipe.</p>
<p class="calibre4">If none of the handlers exists, the JVM writes the stack trace of the exception in the console and ends the execution of the thread that had thrown the exception.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Processing uncontrolled exceptions in a thread</em> recipe</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating threads through a factory</h1>
            

            <article>
                
<p class="calibre4">The factory pattern is one of the most used design patterns in the object-oriented programming world. It is a creational pattern, and its objective is to develop an object whose mission should be this: creating other objects of one or several classes. With this, if you want to create an object of one of these classes, you could just use the factory instead of using a new operator.</p>
<p class="calibre4">With this factory, we centralize the creation of objects with some advantages:</p>
<ul class="calibre17">
<li class="calibre18">It's easy to change the class of the objects created or the way you'd create them.</li>
<li class="calibre18">It's easy to limit the creation of objects for limited resources; for example, we can only have <em class="calibre14">n</em> objects of a given type.</li>
<li class="calibre18">It's easy to generate statistical data about the creation of objects.</li>
</ul>
<p class="calibre4">Java provides an interface, the <kbd class="calibre15">ThreadFactory</kbd> interface, to implement a thread object factory. Some advanced utilities of the Java concurrency API use thread factories to create threads.</p>
<p class="calibre4">In this recipe, you will learn how to implement a <kbd class="calibre15">ThreadFactory</kbd> interface to create thread objects with a personalized name while saving the statistics of the thread objects created.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example for this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class called <kbd class="calibre15">MyThreadFactory</kbd> and specify that it implements the <kbd class="calibre15">ThreadFactory</kbd> interface:</li>
</ol>
<pre class="calibre23">
       public class MyThreadFactory implements ThreadFactory {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare three attributes: an integer number called counter, which we will use to store the number of thread objects created, a string called name with the base name of every thread created, and a list of string objects called stats to save statistical data about the thread objects created. Also, implement the constructor of the class that initializes these attributes:</li>
</ol>
<pre class="calibre23">
        private int counter; <br class="title-page-name"/>        private String name; <br class="title-page-name"/>        private List&lt;String&gt; stats; <br class="title-page-name"/>   <br class="title-page-name"/>        public MyThreadFactory(String name){ <br class="title-page-name"/>          counter=0; <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>          stats=new ArrayList&lt;String&gt;(); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">newThread()</kbd> method. This method will receive a <kbd class="calibre15">Runnable</kbd> interface and return a thread object for this <kbd class="calibre15">Runnable</kbd> interface. In our case, we generate the name of the thread object, create the new thread object, and save the statistics:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public Thread newThread(Runnable r) { <br class="title-page-name"/>          Thread t=new Thread(r,name+"-Thread_"+counter); <br class="title-page-name"/>          counter++; <br class="title-page-name"/>          stats.add(String.format("Created thread %d with name %s on %s\n",<br class="title-page-name"/>                                  t.getId(),t.getName(),new Date())); <br class="title-page-name"/>          return t; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">getStatistics()</kbd> method; it returns a <kbd class="calibre15">String</kbd> object with the statistical data of all the thread objects created:</li>
</ol>
<pre class="calibre23">
        public String getStats(){ <br class="title-page-name"/>          StringBuffer buffer=new StringBuffer(); <br class="title-page-name"/>          Iterator&lt;String&gt; it=stats.iterator(); <br class="title-page-name"/>     <br class="title-page-name"/>          while (it.hasNext()) { <br class="title-page-name"/>            buffer.append(it.next()); <br class="title-page-name"/>            buffer.append("\n"); <br class="title-page-name"/>          } <br class="title-page-name"/>     <br class="title-page-name"/>          return buffer.toString(); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a class called <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. In this example, these tasks are going to do nothing apart from sleeping for 1 second:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable { <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void run() { <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create the main class of the example. Create a class called <kbd class="calibre15">Main</kbd> and implement the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create a <kbd class="calibre15">MyThreadFactory</kbd> object and a <kbd class="calibre15">Task</kbd> object:</li>
</ol>
<pre class="calibre23">
        MyThreadFactory factory=new MyThreadFactory("MyThreadFactory"); <br class="title-page-name"/>        Task task=new Task();
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create 10 <kbd class="calibre15">Thread</kbd> objects using the <kbd class="calibre15">MyThreadFactory</kbd> object and start them:</li>
</ol>
<pre class="calibre23">
        Thread thread; <br class="title-page-name"/>        System.out.printf("Starting the Threads\n"); <br class="title-page-name"/>        for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>           thread=factory.newThread(task); <br class="title-page-name"/>          thread.start(); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Write the statistics of the thread factory in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Factory stats:\n"); <br class="title-page-name"/>        System.out.printf("%s\n",factory.getStats());
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Run the example and see the results.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ThreadFactory</kbd> interface has only one method, called <kbd class="calibre15">newThread()</kbd>. It receives a <kbd class="calibre15">Runnable</kbd> object as a parameter and returns a <kbd class="calibre15">Thread</kbd> object. When you implement a <kbd class="calibre15">ThreadFactory</kbd> interface, you have to implement it and override the <kbd class="calibre15">newThread</kbd> method. The most basic <kbd class="calibre15">ThreadFactory</kbd> has only one line:</p>
<pre class="calibre23">
    return new Thread(r);
</pre>
<p class="calibre4">You can improve this implementation by adding some variants, as follows:</p>
<ul class="calibre17">
<li class="calibre18">Creating personalized threads, as in the example, using a special format for the name or even creating your own <kbd class="calibre15">Thread</kbd> class that would inherit the Java <kbd class="calibre15">Thread</kbd> class</li>
<li class="calibre18">Saving thread creation statistics, as shown in the previous example</li>
<li class="calibre18">Limiting the number of threads created</li>
<li class="calibre18">Validating the creation of the threads</li>
</ul>
<p class="calibre4">You can add anything else you can imagine to the preceding list. The use of the factory design pattern is a good programming practice, but if you implement a <kbd class="calibre15">ThreadFactory</kbd> interface to centralize the creation of threads, you will have to review the code to guarantee that all the threads are created using the same factory.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Implementing the ThreadFactory interface to generate custom threads</em>Â and <em class="calibre14">Using our ThreadFactory in an Executor object</em> recipes in <a href="part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 8</span></a>, <em class="calibre14">Customizing Concurrency Classes</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>