<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Sunago - A Social Media Aggregator</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For our next project, we'll try something a bit more ambitious; we'll build a desktop application that aggregates data from various social media networks and displays it in one seamless interaction. We're also going to try something new, and we're going to give this project a name, something that might be a bit more appealing than the dry, albeit accurate, <kbd class="calibre16">description-turned-name</kbd> that we've used to date. This application, then, we'll call Sunago, which is the phonetic spelling of the (Koine) Greek word συνάγω, which means <strong class="calibre8">I gather together</strong>, <strong class="calibre8">collect</strong>, <strong class="calibre8">assemble</strong>.</p>
<p class="mce-root">Building the app will cover several different topics, some familiar, some new. That list includes the following:</p>
<ul class="calibre13">
<li class="calibre14">JavaFX</li>
<li class="calibre14">Internationalization and localization</li>
<li class="calibre14"><strong class="calibre3">Service Provider Interfaces</strong> (<strong class="calibre3">SPI</strong>)</li>
<li class="calibre14">REST API consumption</li>
<li class="calibre14"><kbd class="calibre16">ClassLoader</kbd> manipulation</li>
<li class="calibre14">Lambdas, lambdas, and more lambdas</li>
</ul>
<p class="mce-root">As usual, those are the just the highlights with a number of interesting items sprinkled throughout.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As with every application, before we get started, we need to think about what we want the application to do. That is, what are the functional requirements? At a high level, the description tells us what we want to achieve in broad terms, but, more specifically, we want the user to be able to do the following:</p>
<ul class="calibre13">
<li class="calibre14">Connect to several different social media networks</li>
<li class="calibre14">Determine, on a network-by-network basis, which group of data (users, lists, and more) to retrieve</li>
<li class="calibre14">See list of items from each network in a consolidated display</li>
<li class="calibre14">Be able to determine from which network an item came</li>
<li class="calibre14">Click on an item and have it loaded in the user's default browser</li>
</ul>
<p class="mce-root">In addition to this list of things the application <strong class="calibre8">should</strong> do, the things it <strong class="calibre8">shouldn't</strong> do include the following:</p>
<ul class="calibre13">
<li class="calibre14">Respond/reply to items</li>
<li class="calibre14">Comment on items</li>
<li class="calibre14">Manage friends/following lists</li>
</ul>
<p class="mce-root">These features would be great additions to the application, but they don't offer much that would be architecturally interesting beyond the basic application detailed previously, so, to keep things simple--and moving along--we'll limit the scope to the given basic set of requirements.</p>
<p class="mce-root">So where to start on the application? As in the previous chapters, we're going to make this a desktop application, so let's start there, with a JavaFX application. I'm going to tip my hand a little bit here to make things easier later on: this will be a multi-module project, so we first need to create the parent project. In NetBeans, click on <span class="calibre7">File</span> | <span class="calibre7">New Project...</span>, and select the <kbd class="calibre16">Maven</kbd> category, as seen in the following screenshot:</p>
<div class="mce-root1"><img class="image-border9" src="Images/56038160-c5e4-4c2f-8385-9ba0b50630bc.png"/></div>
<p class="mce-root">Click on the <span class="calibre7">Next</span> button, and fill in the project details, as shown next:</p>
<div class="mce-root1"><img class="image-border17" src="Images/6cca6c4d-c2cc-4735-bfed-a885dbeaff0f.png"/></div>
<p class="mce-root">When you click on <span class="calibre7">Finish</span>, you will be presented with an empty project. Once we add modules to this project, differentiating them might become difficult, so something I do as a matter of practice is to give each module a distinct, "namespaced" name. That is to say, each module has its own name, of course, but I prefix that with the name of the project. For example, since this is the base POM of the project, I call it <kbd class="calibre16">Master</kbd>. To reflect that, I modify the generated POM to look something like this:</p>
<pre class="calibre21">    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;project   
        
      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0  
      http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; 
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 
      &lt;groupId&gt;com.steeplesoft.sunago&lt;/groupId&gt; 
      &lt;artifactId&gt;master&lt;/artifactId&gt; 
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 
      &lt;name&gt;Sunago - Master&lt;/name&gt; 
      &lt;packaging&gt;pom&lt;/packaging&gt; 
    &lt;/project&gt; </pre>
<p class="mce-root">There's really not much to this yet. The advantage that a parent POM like this gives us is that we can build all the projects with one command if we so desire, and we can move any shared configuration to this shared parent POM to reduce duplication. What we need to add now, though, is a module, which NetBeans helps us do, as seen in this screenshot:</p>
<div class="mce-root1"><img class="image-border18" src="Images/84fdf68c-0c59-4b1c-804b-535a4242ccaa.png" width="721" height="262"/></div>
<p class="mce-root">After clicking on <span class="calibre7">Create New Module...</span>, you will be presented with the familiar <span class="calibre7">New Project</span> window, from which you'll want to select <span class="calibre7">Maven</span> | <span class="calibre7">JavaFX Application</span>, and click on <span class="calibre7">Next</span>. In the <span class="calibre7">New Java Application</span> screen, enter <kbd class="calibre16">app</kbd> for the project name, and click on <span class="calibre7">Finish</span> (all of the other defaults are acceptable as-is).</p>
<p class="mce-root">Again, we want to give this module a meaningful name, so let's modify the generated <kbd class="calibre16">pom.xml</kbd> as follows:</p>
<pre class="calibre21">    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;project   
        
      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0  
      http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; 
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 
      &lt;parent&gt; 
        &lt;groupId&gt;com.steeplesoft.sunago&lt;/groupId&gt; 
        &lt;artifactId&gt;master&lt;/artifactId&gt; 
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 
      &lt;/parent&gt; 
      &lt;artifactId&gt;sunago&lt;/artifactId&gt; 
      &lt;name&gt;Sunago - App&lt;/name&gt; 
      &lt;packaging&gt;jar&lt;/packaging&gt; 
    &lt;/project&gt; </pre>
<p class="mce-root">When NetBeans creates the project, it will generate several artifacts for us--two classes, <kbd class="calibre16">FXMLController</kbd> and <kbd class="calibre16">MainApp</kbd>, as well as the resources, <kbd class="calibre16">fxml/Scene.xml</kbd> and <kbd class="calibre16">styles/Styles.css</kbd>. While this may be stating the obvious, artifacts should have names that clearly communicate their purpose, so let's rename these.</p>
<p class="mce-root">The class <kbd class="calibre16">FxmlContoller</kbd> should be renamed to <kbd class="calibre16">SunagoController</kbd>. Perhaps the quickest and easiest way to do this is to open the class by double-clicking on it in <span class="calibre7">Project View</span>, then, in the source editor, click on the name of the class in the class declaration, and press <em class="calibre20">Ctrl</em> + <em class="calibre20">R</em>. The <span class="calibre7">Rename Class</span> dialog should appear, in which you need to enter the new name, and press <em class="calibre20">Enter</em>. This will rename the class and the file for you. Now repeat that process for <kbd class="calibre16">MainApp</kbd>, renaming it to <kbd class="calibre16">Sunago</kbd>.</p>
<p class="mce-root">We also want to rename the generated FXML file, <kbd class="calibre16">Scene.xml</kbd>, to <kbd class="calibre16">sunago.fxml</kbd>. To do that, right-click on the file in <span class="calibre7">Project View</span> and select <span class="calibre7">Rename...</span> from the context menu. Enter the new name (without the extension) in the <span class="calibre7">Rename</span> dialog, and press <em class="calibre20">Enter</em>. While we're at it, let's also rename <kbd class="calibre16">Styles.css</kbd> to <kbd class="calibre16">styles.css</kbd> so that the case is consistent. It's a minor thing, but consistency in the code can help produce confidence in you in whoever might take over your code in the future.</p>
<p class="mce-root">Unfortunately, renaming these files doesn't adjust the references to them in the Java sources, so we need to edit <kbd class="calibre16">Sunago.java</kbd> to point to these new names, which is done as follows:</p>
<pre class="calibre21">    @Override<br class="calibre2"/>    public void start(Stage stage) throws Exception {<br class="calibre2"/>      Parent root = fxmlLoader.load(<br class="calibre2"/>        getClass().getResource("/fxml/sunago.fxml"));<br class="calibre2"/><br class="calibre2"/>        Scene scene = new Scene(root);<br class="calibre2"/>        scene.getStylesheets().add("/styles/styles.css");<br class="calibre2"/><br class="calibre2"/>        stage.setTitle("Sunago, your social media aggregator");<br class="calibre2"/>        stage.setScene(scene);<br class="calibre2"/>        stage.show();<br class="calibre2"/>    }</pre>
<p class="mce-root">Note also that we changed the title to something more appropriate.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Setting up the user interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If we wanted to, we could now run our application. It would be very boring, but it would run. Let's try to fix the boring part.</p>
<p class="mce-root">The default FXML created is just an <span class="calibre7">AnchorPane</span> with two children, a <span class="calibre7">Button</span> and a <span class="calibre7">Label</span>. We don't need any of those, so let's get rid of them. Our main user interface will be pretty simple--basically, just a vertical stack of components--so we can use a <span class="calibre7">VBox</span> as our root component. Perhaps, the easiest way to change the root component from the <span class="calibre7">AnchorPane</span> that's there to a <span class="calibre7">VBox</span> is to use Scene Builder to wrap that component in a <span class="calibre7">VBox</span>, and then delete the <span class="calibre7">AnchorPane</span>:</p>
<div class="mce-root1"><img class="image-border19" src="Images/e5b12b35-a9e4-4b92-a7df-597c36cda218.png" width="476" height="607"/></div>
<p class="mce-root">To do that, open the FXML file in Scene Builder by double-clicking on the file (assuming you've configured NetBeans correctly so that it knows where to find Scene Builder. If not, refer back to <a href="ef175826-d02f-448f-b68e-5e3d03402bd0.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 17</a>, <em class="calibre20">Introduction</em>). In Scene Builder, right-click on <span class="calibre7">AnchorPane</span> in the <span class="calibre7">Document</span> section of the accordion on the left, select <span class="calibre7">Wrap in</span>, and then <span class="calibre7">VBox</span>, as shown in the preceding screenshot. Scene Builder will then modify the FXML file, making <span class="calibre7">AnchorPane</span> a child of <span class="calibre7">VBox</span> as expected. Once that's done, you can right-click on <span class="calibre7">AnchorPane</span>, and click on <span class="calibre7">Delete</span> to remove it and its children. This leaves us with an empty user interface that's more boring than it was when we began. We can fix that now by adding a couple of controls--a <span class="calibre7">MenuBar</span> and a <span class="calibre7">ListView</span>. We do that by clicking on each component in the <span class="calibre7">Controls</span> section of the accordion and dragging them to <span class="calibre7">VBox</span>. If you drop the components on <span class="calibre7">VBox</span>, they will be appended to its list of children. Make sure that <span class="calibre7">MenuBar</span> comes before <span class="calibre7">ListView</span>, or you'll have a very strange user interface.</p>
<p class="mce-root">Let's configure these components a bit now before we return to the code. Selecting <span class="calibre7">VBox</span> from the <span class="calibre7">Document</span> section on the left, we then need to select the <span class="calibre7">Layout</span> section in the accordion on the right. For <span class="calibre7">Min Width</span> and <span class="calibre7">Min Height</span>, enter <kbd class="calibre16">640</kbd> and <kbd class="calibre16">480</kbd> respectively. This will make the window's default size larger and more user-friendly.</p>
<p class="mce-root">For <span class="calibre7">MenuBar</span>, we need to expand its entry under <span class="calibre7">Document</span>, then expand each of its <span class="calibre7">Menu</span> children, which should reveal one <span class="calibre7">MenuItem</span> per <span class="calibre7">Menu</span>. Click on the first <span class="calibre7">Menu</span>, then, on the right, set <kbd class="calibre16">Text</kbd> to <kbd class="calibre16">_File</kbd>, and check <span class="calibre7">Mnemonic Parsing</span>. This will allow the user to press <em class="calibre20">Alt</em> + <em class="calibre20">F</em> to activate (or show) this menu. Next, click on its <kbd class="calibre16">MenuItem</kbd> child, setting <kbd class="calibre16">Text</kbd> to <kbd class="calibre16">_Exit</kbd>, and check <span class="calibre7">Mnemonic Parsing.</span> (If the text for a <kbd class="calibre16">Menu</kbd>, <kbd class="calibre16">MenuItem</kbd>, <kbd class="calibre16">Button</kbd>, and more has an underscore in it, make sure that <span class="calibre7">Mnemonic Parsing</span> is checked. For brevity's sake, I won't flag this explicitly again.) Open the <span class="calibre7">Code</span> section, and set the <span class="calibre7">On Action</span> value to <kbd class="calibre16">closeApplication</kbd>.</p>
<p class="mce-root">The second <kbd class="calibre16">Menu</kbd> should have its <span class="calibre7">Text</span> value set to <kbd class="calibre16">_Edit</kbd>. Its <kbd class="calibre16">MenuItem</kbd> should be labeled <kbd class="calibre16">_Settings</kbd>, and have an <span class="calibre7">On Action</span> value of <kbd class="calibre16">showPreferences</kbd>. Finally, the third <kbd class="calibre16">Menu</kbd> should be labeled <kbd class="calibre16">_Help</kbd>, and its <kbd class="calibre16">MenuItem</kbd> labeled <kbd class="calibre16">About</kbd> with an <span class="calibre7">On Action</span> of <kbd class="calibre16">showAbout</kbd>.</p>
<p class="mce-root">Next, we want to give <kbd class="calibre16">ListView</kbd> an ID, so select that on the left, make sure the <span class="calibre7">Code</span> section is expanded on the right, and enter <kbd class="calibre16">entriesListView</kbd> for <span class="calibre7">fx:id</span>.</p>
<p class="mce-root">The last edit we need to make is to set the controller. We do that in the accordion on the left, in the <span class="calibre7">Controller</span> section at the very bottom. Expand that, and make sure that the <span class="calibre7">Controller class</span> value matches the Java class and package we just created in NetBeans, then save the file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Setting up the controller</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Back in NetBeans, we need to fix up our controller to reflect the changes we just made in our FXML. In <kbd class="calibre16">SunagoController</kbd>, we need to add the <kbd class="calibre16">entriesListView</kbd> property as follows:</p>
<pre class="calibre21">    @FXML 
    private ListView&lt;SocialMediaItem&gt; entriesListView; </pre>
<p class="mce-root">Notice that the parameterized type is <kbd class="calibre16">SocialMediaItem</kbd>. That's a custom model we'll create in just a few moments. Before we tackle that, though, we need to finish wiring together our user interface. We defined three <kbd class="calibre16">onAction</kbd> handlers in the FXML. The corresponding code is as follows:</p>
<pre class="calibre21">    @FXML 
    public void closeApplication(ActionEvent event) { 
      Platform.exit(); 
    } </pre>
<p class="mce-root">Closing the application is as simple as calling the <kbd class="calibre16">exit</kbd> method on the <kbd class="calibre16">Platform</kbd> class. Showing the "about" box is also fairly simple, as we see in the <kbd class="calibre16">showAbout</kbd> method:</p>
<pre class="calibre21">    @FXML 
    public void showAbout(ActionEvent event) { 
      Alert alert = new Alert(Alert.AlertType.INFORMATION); 
      alert.setTitle("About..."); 
      alert.setHeaderText("Sunago (συνάγω)"); 
      alert.setContentText("(c) Copyright 2016"); 
      alert.showAndWait(); 
    } </pre>
<p class="mce-root">Using the built-in <kbd class="calibre16">Alert</kbd> class, we construct an instance, and set the values appropriate for an About screen, then display it modally via <kbd class="calibre16">showAndWait()</kbd>.</p>
<p class="mce-root">The preferences window is a much more complicated piece of logic, so we wrap that up in a new controller class, and call its <kbd class="calibre16">showAndWait()</kbd> method.</p>
<pre class="calibre21">    @FXML 
    public void showPreferences(ActionEvent event) { 
      PreferencesController.showAndWait(); 
    } </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Writing the model class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we look at that, though, there are a few more items in the main controller that we need to take care of. The first is the model class mentioned earlier, <kbd class="calibre16">SocialMediaItem</kbd>. As you can probably imagine, the structure of the data returned from a social network can be quite complex, and certainly, varied. The data requirements for a tweet, for example, are likely to be quite different from those for an Instagram post. What we'd like to be able to do, then, is to hide those complexities and differences behind a simple, reusable interface. In the real world, such a simple abstraction is not always possible, but, for our purposes here, we have such an interface in <kbd class="calibre16">SocialMediaItem</kbd>, as you can see in this piece of code:</p>
<pre class="calibre21">    public interface SocialMediaItem { 
      String getProvider(); 
      String getTitle(); 
      String getBody(); 
      String getUrl(); 
      String getImage(); 
      Date getTimestamp(); 
    } </pre>
<p class="mce-root">One of the problems with abstractions is that, to make them reusable, you, occasionally, have to structure them in such a way that they expose properties that may not be used by every implementation. It's not obvious yet, but that is certainly the case here. It's a scenario that some consider to be unacceptable, and they may have a point, but it's really a question of trade-offs. Our options include a slightly bloated interface or a complex system in which each network support module (which we'll get to shortly) provides its own renderer, and the application has to interrogate each module, looking for the renderer that can handle each item while drawing <kbd class="calibre16">ListView</kbd>. There are likely others, of course, but faced with (at least) those two, for the sake of simplicity and performance, we'll take the first option. When faced with similar situations while designing your own systems, though, you'll need to evaluate the various requirements of your project, and make an appropriate choice. For our needs here, the simple approach is more than adequate.</p>
<p class="mce-root">At any rate, each social media network module will implement that interface to wrap its data. This will give a common interface for the application to consume without needing to know exactly where it came from. We do, though, now need to tell the <kbd class="calibre16">ListView</kbd> how to draw a cell containing a <kbd class="calibre16">SocialMediaItem</kbd>. We can do that with this line of code in the <kbd class="calibre16">initialize()</kbd> method of our controller, as follows:</p>
<pre class="calibre21">    entriesListView.setCellFactory(listView -&gt;  
      new SocialMediaItemViewCell()); </pre>
<p class="mce-root">Obviously, that's a lambda. For the curious, the pre-lambda version of the preceding method would look like this:</p>
<pre class="calibre21">    entriesListView.setCellFactory( 
      new Callback&lt;ListView&lt;SocialMediaItem&gt;,  
      ListCell&lt;SocialMediaItem&gt;&gt;() {  
        @Override 
        public ListCell&lt;SocialMediaItem&gt; call( 
          ListView&lt;SocialMediaItem&gt; param) { 
            return new SocialMediaItemViewCell(); 
          } 
    }); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Finishing up the controller</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we look at <kbd class="calibre16">SocialMediaItemViewCell</kbd>, there are two more controller items. The first is the list that holds the <kbd class="calibre16">ListView</kbd> data. Remember that <kbd class="calibre16">ListView</kbd> operates from an <kbd class="calibre16">ObservableList</kbd>. This lets us make changes to the data in the list, and have it automatically reflected in the user interface. To create that list, we'll use a JavaFX helper method when we define the class property as follows:</p>
<pre class="calibre21">    private final ObservableList&lt;SocialMediaItem&gt; entriesList =  
      FXCollections.observableArrayList(); </pre>
<p class="mce-root">Then we need to connect that <kbd class="calibre16">List</kbd> to our <kbd class="calibre16">ListView</kbd>. Back in <kbd class="calibre16">intialize()</kbd>, we have the following:</p>
<pre class="calibre21">    entriesListView.setItems(entriesList); </pre>
<p class="mce-root">To finish off the rendering of <kbd class="calibre16">SocialMediaItem</kbd> interfaces, let's define <kbd class="calibre16">SocialMediaItemViewCell</kbd> like this:</p>
<pre class="calibre21">    public class SocialMediaItemViewCell extends  
      ListCell&lt;SocialMediaItem&gt; { 
      @Override 
      public void updateItem(SocialMediaItem item, boolean empty) { 
        super.updateItem(item, empty); 
        if (item != null) { 
          setGraphic(buildItemCell(item)); 
          this.setOnMouseClicked(me -&gt; SunagoUtil 
            .openUrlInDefaultApplication(item.getUrl())); 
        } else { 
            setGraphic(null); 
          } 
      } 
 
      private Node buildItemCell(SocialMediaItem item) { 
        HBox hbox = new HBox(); 
        InputStream resource = item.getClass() 
          .getResourceAsStream("icon.png"); 
        if (resource != null) { 
          ImageView sourceImage = new ImageView(); 
          sourceImage.setFitHeight(18); 
          sourceImage.setPreserveRatio(true); 
          sourceImage.setSmooth(true); 
          sourceImage.setCache(true); 
          sourceImage.setImage(new Image(resource)); 
          hbox.getChildren().add(sourceImage); 
        } 
 
        if (item.getImage() != null) { 
          HBox picture = new HBox(); 
          picture.setPadding(new Insets(0,10,0,0)); 
          ImageView imageView = new ImageView(item.getImage()); 
          imageView.setPreserveRatio(true); 
          imageView.setFitWidth(150); 
          picture.getChildren().add(imageView); 
          hbox.getChildren().add(picture); 
        } 
 
        Label label = new Label(item.getBody()); 
        label.setFont(Font.font(null, 20)); 
        label.setWrapText(true); 
        hbox.getChildren().add(label); 
 
        return hbox; 
      } 
 
    } </pre>
<p class="mce-root">There's a fair amount happening here, but <kbd class="calibre16">updateItem()</kbd> is our first point of interest. This is the method that is called every time the row is updated on the screen. Notice that we check to see if <kbd class="calibre16">item</kbd> is null. We do that because <kbd class="calibre16">ListView</kbd> calls this method not for every item in its <kbd class="calibre16">List</kbd>, but for every row in <kbd class="calibre16">ListView</kbd> that's visible, whether there's data for it or not. That means that, if <kbd class="calibre16">List</kbd> has five items but <kbd class="calibre16">ListView</kbd> is tall enough to show ten rows, this method will be called ten times, with the last five calls being made with a null <kbd class="calibre16">item</kbd>. In those cases, we call <kbd class="calibre16">setGraphic(null)</kbd> to clear out any item that may have been previously rendered.</p>
<p class="mce-root">If <kbd class="calibre16">item</kbd> is not null, though, we need to build the <kbd class="calibre16">Node</kbd> to display the item, which is done in <kbd class="calibre16">buildItemCell()</kbd>. For each item, we want to render three items--the social media network icon (so users can tell at a glance where the item is from), any image embedded in the item, and, finally, any text/caption from the item. To help arrange that, we start with an <kbd class="calibre16">HBox</kbd>.</p>
<p class="mce-root">Next, we try to find an icon for the network. If we had a formal contract written up, we would include language in it that would stipulate that the module include a file called <kbd class="calibre16">icon.png</kbd>, which is in the same package as the module's <kbd class="calibre16">SocialMediaItem</kbd> implementation. Using the <kbd class="calibre16">ClassLoader</kbd> for the implementation, then, we try to get an <kbd class="calibre16">InputStream</kbd> for the resource. We check for null, just to make sure the image was actually found; if so, we create an <kbd class="calibre16">ImageView</kbd>, set some properties, then wrap the resource in an <kbd class="calibre16">Image</kbd>, hand that to <kbd class="calibre16">ImageView</kbd>, then add <kbd class="calibre16">ImageView</kbd> to <kbd class="calibre16">HBox</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding an image for the item</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If the item has an image, we handle it in the same way that we did with the network icon image. This time, though, we actually wrap the <kbd class="calibre16">ImageView</kbd> in another <kbd class="calibre16">HBox</kbd> before adding it to the outer <kbd class="calibre16">HBox</kbd>. We do that so that we can add padding around the image (via <kbd class="calibre16">picture.setPadding(new Insets()</kbd>) to give this image some space between it and the network icon.</p>
<p class="mce-root">Finally, we create a <kbd class="calibre16">Label</kbd> to hold the item's body. We set the font size of the text to <kbd class="calibre16">20</kbd> points via <kbd class="calibre16">label.setFont(Font.font(null, 20))</kbd>, and add it to our <kbd class="calibre16">HBox</kbd>, which we then return to the caller, <kbd class="calibre16">updateItem()</kbd>.</p>
<div class="packt_tip">Any time you have a <kbd class="calibre39">ListView</kbd>, you are likely going to want a custom <kbd class="calibre39">ListCell</kbd> implementation like we have here. In some cases, calling <kbd class="calibre39">toString()</kbd> on the <kbd class="calibre39">List</kbd> contents might be appropriate, but that's not always the case, and you certainly can't have a complex <kbd class="calibre39">ListCell</kbd> structure like we have here without implementing <kbd class="calibre39">ListCell</kbd> yourself. If you're planning on doing much JavaFX development, you would be well advised to get comfortable with this technique.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the preferences user interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We're finally <strong class="calibre8">finished</strong> with the main controller, and we can turn our attention to the next big piece, <kbd class="calibre16">PreferencesController</kbd>. Our preferences dialog will be, as is usually expected, a modal dialog. It will offer a tabbed interface with one tab for general settings, then a tab for each supported social network. We start that work by adding a new FXML file and controller to our project, and NetBeans has a great wizard for that. Right-click on the desired package, and click on <span class="calibre7">New</span> | <span class="calibre7">Other</span>. From the <span class="calibre7">Categories</span> list, select <kbd class="calibre16">JavaFX</kbd>, and then, from the <span class="calibre7">File Types</span> lists, select <kbd class="calibre16">Empty FXML</kbd> as shown in the following screenshot:</p>
<div class="mce-root1"><img class="image-border9" src="Images/d02c92bc-117c-466b-be35-293fbe47bdd3.png"/></div>
<p class="mce-root">After clicking on <span class="calibre7">Next</span>, you should see the <span class="calibre7">FXML Name and Location</span> step. This will allow us to specify the name of our new file and the package in which it is created, as seen in this screenshot:</p>
<div class="mce-root1"><img class="image-border9" src="Images/a4da3802-8d3c-4b9e-98d8-cf745ab59519.png"/></div>
<p class="mce-root">Clicking on <span class="calibre7">Next</span> brings us to the <span class="calibre7">Controller Class</span> step. Here we can either create a new controller class, or attach our file to an existing one. Since this is a new dialog/window for our app, we need to create a new controller as follows:</p>
<div class="mce-root1"><img class="image-border9" src="Images/fdfc4f37-25ae-4350-bcf3-452f3f512432.png"/></div>
<p class="mce-root">Check the <span class="calibre7">Use Java Controller</span> checkbox, enter <kbd class="calibre16">PreferencesController</kbd> for the name, and select the desired package. We could click on <span class="calibre7">Next</span>, which would take us to the <span class="calibre7">Cascading Style Sheet</span> step, but we're not interested in specifying that for this controller, so, we end the wizard by clicking on <span class="calibre7">Finish</span>, which will take us to the source of our newly created controller class.</p>
<p class="mce-root">Let's start by laying out the user interface. Double-click on the new <kbd class="calibre16">prefs.fxml</kbd> file to open it in Scene Builder. Like our last FXML file, the default root element is <span class="calibre7">AnchorPane</span>. For this window, we'd like to use a <span class="calibre7">BorderPane</span>, so we use the same technique that we did last time to replace <span class="calibre7">AnchorPane</span>--right-click on the component, and click on <span class="calibre7">Wrap in</span> | <span class="calibre7">BorderPane</span>. The <span class="calibre7">AnchorPane</span> is now nested in <span class="calibre7">BorderPane</span>, so we right-click on it again and select <span class="calibre7">Delete</span>.</p>
<p class="mce-root">To build the user interface, we now drag a <span class="calibre7">TabPane</span> control from the accordion on the left, and drop it in the <span class="calibre7">CENTER</span> area of <span class="calibre7">BorderPane</span>. This will add a <span class="calibre7">TabPane</span> with two tabs to our user interface. We only want one right now, so delete the second one. We want to give our tab a meaningful label. We can do that by double-clicking on the tab in the preview window (or selecting the <span class="calibre7">Text</span> property in the <span class="calibre7">Properties</span> section of the <span class="calibre7">Inspector</span>) and typing <kbd class="calibre16">General</kbd>. Finally, expand the Inspector's <span class="calibre7">Code</span> section, and enter <kbd class="calibre16">tabPane</kbd> for <span class="calibre7">fx:id</span>.</p>
<p class="mce-root">Now we need to provide a means by which the user can close the window, and either save or discard changes. We implement that by dragging a <span class="calibre7">ButtonBar</span> component to our border pane's <span class="calibre7">BOTTOM</span> area. That will add a <span class="calibre7">ButtonBar</span> with one button, but we need two, so we drag another button on to the <span class="calibre7">ButtonBar</span>. The nice thing about this control is that it will handle button placement and padding for us, so, when we drop the new button, it's automatically added in the proper place on the right. (This behavior can be overridden, but it works exactly how we want it to, so we can just accept the defaults.)</p>
<p class="mce-root">For each <kbd class="calibre16">Button</kbd>, we need to set three properties--<kbd class="calibre16">text</kbd>, <kbd class="calibre16">fx:id</kbd>, and <kbd class="calibre16">onAction</kbd>. The first property is in the <span class="calibre7">Properties</span> section of the inspector, and the last two in the <span class="calibre7">Code</span> section. The values for the first button are <kbd class="calibre16">Save</kbd>, <kbd class="calibre16">savePrefs</kbd>, and <kbd class="calibre16">savePreferences</kbd>. For the second button, the values are <kbd class="calibre16">Cancel</kbd>, <kbd class="calibre16">cancel</kbd>, and <kbd class="calibre16">closeDialog</kbd>. Select the <span class="calibre7">Layout</span> section for the <kbd class="calibre16">ButtonBar</kbd> in the inspector, and set the right padding to 10 to make sure <kbd class="calibre16">Button</kbd> is not pressed against the edge of the window.</p>
<p class="mce-root">Finally, we'll add our only preference at this point. We want to allow the user to specify the maximum number of items to retrieve from each social media network for a given request. We do that for those scenarios where the application hasn't been used in a while (or ever). In those cases, we don't want to try to download, for example, thousands of tweets. To add support for this, we add two controls, <kbd class="calibre16">Label</kbd> and <kbd class="calibre16">TextField</kbd>.</p>
<p class="mce-root">Getting the position of the <span class="calibre7">Label</span> control right is pretty simple, as it's the first component. Scene Builder will provide red guidelines to help you position the component exactly where you want it, as shown in this screenshot:</p>
<div class="mce-root1"><img class="image-border20" src="Images/c774516b-5875-403b-8295-dd116fa47675.png"/></div>
<p class="mce-root">Making sure that <kbd class="calibre16">TextField</kbd> is lined up with the label can be trickier. By default, when you drop a component on <span class="calibre7">TabPane</span>, Scene Builder will add an <span class="calibre7">AnchorPane</span> to hold the new components. An <span class="calibre7">HBox</span> might be a better choice, but we'll go ahead and use <span class="calibre7">AnchorPane</span> to demonstrate this feature of Scene Builder. If you drag a <span class="calibre7">TextField</span> onto <span class="calibre7">TabPane</span> and try to position it, you should see more red lines show up. Positioned just right, you should see a red line running through the middle of the <span class="calibre7">Label</span> and the <kbd class="calibre16">TextField</kbd>, indicating that the two components are vertically aligned. This is what we want, so make sure there is a small space between <kbd class="calibre16">TextField</kbd> and the label and drop it.</p>
<p class="mce-root">We need to give <span class="calibre7">Label</span> some meaningful text, so double-click on it in the preview window, and enter <kbd class="calibre16">Number of items to retrieve</kbd>. We also need to give <kbd class="calibre16">TextField</kbd> an ID so that we can interact with it, so click on the component, expand the <span class="calibre7">Code</span> section in the Inspector, and set <span class="calibre7">fx:id</span> to <kbd class="calibre16">itemCount</kbd>.</p>
<p class="mce-root">Our user interface, while basic, is now as complete as we can make it here, so save the file, close Scene Builder, and return to NetBeans.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Saving user preferences</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To allow our newly-defined user interface to be wired into our controller, we need to create instance variables to match the controls with the <kbd class="calibre16">fx:id</kbd> attributes set, so, we add these to <kbd class="calibre16">PreferencesController</kbd> as follows:</p>
<pre class="calibre21">    @FXML 
    protected Button savePrefs; 
    @FXML 
    protected Button cancel; 
    @FXML 
    protected TabPane tabPane; </pre>
<p class="mce-root">In the <kbd class="calibre16">initialize()</kbd> method, we need to add support for loading the saved value for our <kbd class="calibre16">itemCount</kbd> field, so we need to talk a little bit about preferences.</p>
<p class="mce-root">Java, being the general-purpose language that it is, makes it possible to write any preference storing strategy that you can image. Fortunately, though, it also offers a couple of different standard APIs that allow you to do so in a more easily portable manner, those being <kbd class="calibre16">Preferences</kbd> and <kbd class="calibre16">Properties</kbd>.</p>
<p class="mce-root">The <kbd class="calibre16">java.util.Properties</kbd> class has been in the JDK since version 1.0, and while its basic, no-frills API might make that obvious, it's still a very useful abstraction. At its heart, <kbd class="calibre16">Properties</kbd> is a <kbd class="calibre16">Hashtable</kbd> implementation to which methods have been added for loading its data from input streams and readers, and writing its data to output streams and writers (in addition to a handful of other related methods). All the properties are treated as <kbd class="calibre16">String</kbd> values with <kbd class="calibre16">String</kbd> keys. Since <kbd class="calibre16">Properties</kbd> is a <kbd class="calibre16">Hashtable</kbd>, you can still use <kbd class="calibre16">put()</kbd> and <kbd class="calibre16">putAll()</kbd> to store non-string data, but that will result in <kbd class="calibre16">ClassCastException</kbd> should you call <kbd class="calibre16">store()</kbd>, so, it's probably best to avoid doing that.</p>
<p class="mce-root">The <kbd class="calibre16">java.util.prefs.Preferences</kbd> class was added in Java 1.4, and it's a much more modern API. Whereas with properties we have to handle persistence separately, preferences handle that for us opaquely--we don't need to worry about how or when it's written. In fact, the call to set a preference may return immediately, while the actual persistence may not occur for quite some time. The contract of the <kbd class="calibre16">Preferences</kbd> API guarantees that preferences will be persisted even if the JVM shuts down, assuming it's a normal, ordered shutdown (by definition, there's not much that can be done if the JVM process suddenly dies).</p>
<p class="mce-root">Additionally, the user also need not worry about how preferences are saved. The actual backing store is an implementation-specific detail. It could be a flat file, an OS-specific registry, a database or some sort of directory server. For the curious, the actual implementation is chosen by using the class name, if specified, in the <kbd class="calibre16">java.util.prefs.PreferencesFactory</kbd> system property. If that's not defined, the system will look for the file <kbd class="calibre16">META-INF/services/java.util.prefs.PreferencesFactory</kbd> (a mechanism known as SPI, which we will look at in depth later), and use the first class defined there. Finally, failing that, the implementation for the underlying platform is loaded and used.</p>
<p class="mce-root">So which to choose? Either will work as well as the other, but you have to decide if you want control of where the information is stored (<kbd class="calibre16">Properties</kbd>) or ease of implementation (<kbd class="calibre16">Preferences</kbd>). To a certain degree, portability might also be a concern. For example, if you have Java code running in some sort of a mobile or embedded device, you might not have permissions to write to the filesystem, and you might not have a filesystem at all. To show how similar the two implementations might be, though, we'll implement both.</p>
<p class="mce-root">To put my cards on the table a little bit, I would like for as much of this code as possible to be reusable in an Android environment. To help facilitate that, we'll create a very simple interface as follows:</p>
<pre class="calibre21">    public interface SunagoPreferences { 
      String getPreference(String key); 
      String getPreference(String key, String defaultValue); 
      Integer getPreference(String key, Integer defaultValue); 
      void putPreference(String key, String value); 
      void putPreference(String key, Integer value); 
    } </pre>
<p class="mce-root">We're only dealing with strings and integers, as the needs of the application are pretty basic. With the interface defined, how do we get a reference to an implementation? For that, we'll use a technique we've already seen mentioned briefly--the Service Provider Interface (SPI).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Plugins and extensions with the Service Provider Interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We've already seen SPI mentioned before when we looked at the <kbd class="calibre16">Preferences</kbd> class, and how the implementation is selected and loaded, but what exactly is it? The Service Provider Interface is a somewhat generic term for an interface that a third party can implement (or a class, abstract or not, that can be extended) to provide extra functionality, replace existing components, and more.</p>
<p class="mce-root">In a nutshell, the author of the target system (for example, the JDK itself in our previous example) defines and publishes an interface. Ideally, this system would provide a default implementation, but that's not necessary in all cases. Any interested third party could then implement this interface, register it, and the target system could then load and use it. One of the advantages of this approach is that the target system can be extended easily, with no coupling to the third party. That is to say, while the third party knows about the target system via the interface, the target system has no knowledge at all of the third party. It's merely operating off the interface it defined.</p>
<p class="mce-root">How are these third-party plugins registered with the target system? The third-party developer would create a text file using a specific file in a specific directory. The file has the same name as the interface being implemented. For the <kbd class="calibre16">Preferences</kbd> class example, one would be implementing the <kbd class="calibre16">java.util.prefs.PreferencesFactory</kbd> interface, so that would be the name of the file, which would be in the <kbd class="calibre16">META-INF/services</kbd> directory in the root of the libraries classpath. In a Maven-based project, the file would be found in <kbd class="calibre16">src/main/resources/META-INF/services</kbd>. The file contains just the name of the class implementing the interface. It's also possible to have more than one class listed in the services file, each on a new line. It's up to the consuming system, though, as to whether or not each of those might be used.</p>
<p class="mce-root">So what does all of this look like for us? As noted earlier, we're going to take a rare opportunity to show multiple implementations for our <kbd class="calibre16">Preferences</kbd> support. Both classes are small enough that we can show the uses of both <kbd class="calibre16">Properties</kbd> and <kbd class="calibre16">Preferences</kbd>, and use SPI to pick one to use.</p>
<p class="mce-root">Let's start with the <kbd class="calibre16">Properties</kbd>-based implementation:</p>
<pre class="calibre21">    public class SunagoProperties implements SunagoPreferences { 
      private Properties props = new Properties(); 
      private final String FILE = System.getProperty("user.home")  
        + File.separator + ".sunago.properties"; 
 
      public SunagoProperties() { 
        try (InputStream input = new FileInputStream(FILE)) { 
          props.load(input); 
        } catch (IOException ex) { 
        } 
    } </pre>
<p class="mce-root">In the preceding code, we start by implementing our <kbd class="calibre16">SunagoPreferences</kbd> interface. We then create an instance of the <kbd class="calibre16">Properties</kbd> class, and we also define a constant for the file name and location, which we put--in a system-independent manner--in the user's home directory.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Resource handling with try-with-resources</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The constructor shows something interesting that we haven't talked about--try-with-resources. Prior to Java 8, you might have written something like this:</p>
<pre class="calibre21">    public SunagoProperties(int a) { 
      InputStream input = null; 
      try { 
        input = new FileInputStream(FILE); 
        props.load(input); 
      } catch  (IOException ex) { 
        // do something 
      } finally { 
          if (input != null) { 
            try { 
                input.close(); 
            } catch (IOException ex1) { 
                Logger.getLogger(SunagoProperties.class.getName()) 
                  .log(Level.SEVERE, null, ex1); 
            } 
          } 
        } 
    } </pre>
<p class="mce-root">This preceding, incredibly verbose code declares an <kbd class="calibre16">InputStream</kbd> outside the try block, then does some work with it in the <kbd class="calibre16">try</kbd> block. In the <kbd class="calibre16">finally</kbd> block, we try to close the <kbd class="calibre16">InputStream</kbd>, but we first have to check to see if it's null. If, say, the file doesn't exist (as it won't be the first time this class is created), an <kbd class="calibre16">Exception</kbd> will be thrown, and <kbd class="calibre16">input</kbd> will be null. If it's not null, we can call <kbd class="calibre16">close()</kbd> on it, but that might throw <kbd class="calibre16">IOException</kbd>, so we have to wrap that in a <kbd class="calibre16">try/catch</kbd> block as well.</p>
<p class="mce-root">Java 8 introduced the try-with-resources construct that makes this much smaller. If an object is an instance of <kbd class="calibre16">AutoCloseable</kbd>, then it can be defined <strong class="calibre8">inside</strong> the <kbd class="calibre16">try</kbd> declaration, and it will be closed automatically when the <kbd class="calibre16">try</kbd> block scope terminates regardless of whether or not an <kbd class="calibre16">Exception</kbd> was thrown. That allows us to take what would normally be fourteen lines of code, and express the exact same functionality in four with much less noise.</p>
<p class="mce-root">Aside from <kbd class="calibre16">AutoCloseable</kbd>, note that we load any existing values in the file into our <kbd class="calibre16">Properties</kbd> instance via <kbd class="calibre16">Properties.load(InputStream)</kbd>.</p>
<p class="mce-root">Moving on, what we see next are pretty straightforward getters and setters:</p>
<pre class="calibre21">    @Override 
    public String getPreference(String key) { 
      return props.getProperty(key); 
    } 
 
    @Override 
    public String getPreference(String key, String defaultValue) { 
      String value = props.getProperty(key); 
      return (value == null) ? defaultValue : value; 
    } 
 
    @Override 
    public Integer getPreference(String key, Integer defaultValue) { 
      String value = props.getProperty(key); 
      return (value == null) ? defaultValue :  
        Integer.parseInt(value); 
    } 
 
    @Override 
    public void putPreference(String key, String value) { 
      props.put(key, value); 
      store(); 
    } 
 
    @Override 
    public void putPreference(String key, Integer value) { 
      if (value != null) { 
        putPreference(key, value.toString()); 
      } 
    } </pre>
<p class="mce-root">The final method is the one that writes our preferences back out, which is as follows:</p>
<pre class="calibre21">    private void store() { 
      try (OutputStream output = new FileOutputStream(FILE)) { 
        props.store(output, null); 
      } catch (IOException e) { } 
    } </pre>
<p class="mce-root">This last method looks a lot like our constructor, but we create an <kbd class="calibre16">OutputStream</kbd>, and call <kbd class="calibre16">Properties.store(OutputStream)</kbd> to write our values out to a file. Note that we call this method from every put method to make sure, insofar as possible, that the user preferences are faithfully persisted to disk.</p>
<p class="mce-root">What would a Preferences-based implementation look like? Not much different.</p>
<pre class="calibre21">    public class SunagoPreferencesImpl implements SunagoPreferences { 
      private final Preferences prefs = Preferences.userRoot() 
        .node(SunagoPreferencesImpl.class.getPackage() 
        .getName()); 
      @Override 
      public String getPreference(String key) { 
        return prefs.get(key, null); 
      } 
      @Override 
      public String getPreference(String key, String defaultValue) { 
        return prefs.get(key, defaultValue); 
      } 
 
      @Override 
      public Integer getPreference(String key,Integer defaultValue){ 
        return prefs.getInt(key, defaultValue); 
      } 
      @Override 
      public void putPreference(String key, String value) { 
        prefs.put(key, value); 
      } 
      @Override 
      public void putPreference(String key, Integer value) { 
        prefs.putInt(key, value); 
      } 
    } </pre>
<p class="mce-root">Two things to note. First, we don't need to handle persistence, as <kbd class="calibre16">Preferences</kbd> does that for us. Second, the instantiation of the <kbd class="calibre16">Preferences</kbd> instance needs some attention. Clearly, I think, we want these preferences to be scoped to the user, so we start with <kbd class="calibre16">Preferences.userRoot()</kbd> to get the root preference node. Then we ask for the node in which we want to store our preferences, which we have chosen to name after the package of our class.</p>
<p class="mce-root">Where does that put things? On Linux, the file might look something like <kbd class="calibre16">~/.java/.userPrefs/_!':!bw"t!#4!cw"0!'`!~@"w!'w!~@"z!'8!~g"0!#4!ag!5!')!c!!u!(:!d@"u!'%!~w"v!#4!}@"w!(!=/prefs.xml</kbd> (yes, that's a directory name). On Windows, those preferences are saved in the Windows Registry under the key <kbd class="calibre16">HKEY_CURRENT_USERSOFTWAREJavaSoftPrefscom.steeplesoft.sunago.app</kbd>. Unless you want to interact directly with these files, though, their exact location and format are merely implementation details. Sometimes, though, it's a good thing to know.</p>
<p class="mce-root">We have two implementations, so how do we pick which one to use? In the file (including the source root for clarity) <kbd class="calibre16">src/main/resources/META-INF/service/com.steeplesoft.sunago.api.SunagoPreferences</kbd>, we can put one of these two lines:</p>
<pre class="calibre21">    com.steeplesoft.sunago.app.SunagoPreferencesImpl 
    com.steeplesoft.sunago.app.SunagoProperties </pre>
<p class="mce-root">You can list both, but only the first will be chosen, which we'll see now. To make things simple, we've wrapped this up in a utility method as follows:</p>
<pre class="calibre21">    private static SunagoPreferences preferences; 
    public static synchronized <br class="calibre2"/>          SunagoPreferences getSunagoPreferences() { 
        if (preferences == null) { 
          ServiceLoader&lt;SunagoPreferences&gt; spLoader =  
            ServiceLoader.load(SunagoPreferences.class); 
          Iterator&lt;SunagoPreferences&gt; iterator = 
            spLoader.iterator(); 
          preferences = iterator.hasNext() ? iterator.next() : null; 
        } 
        return preferences; 
    } </pre>
<p class="mce-root">In what may be a bit of an overkill for our purposes here, we've implemented a singleton by declaring the instance of the <kbd class="calibre16">SunagoPreferences</kbd> interface as a private static, and made it available via a synchronized method, which checks for <kbd class="calibre16">null</kbd>, and creates the instance if needed.</p>
<p class="mce-root">While that's interesting, don't let it distract you from the meat of the method. We use the <kbd class="calibre16">ServiceLoader.load()</kbd> method to ask the system for any implementations of the <kbd class="calibre16">SunagoPreferences</kbd> interface. It's worth noting again, just to be clear, that it won't pick up <strong class="calibre8">any</strong> implementation in the system, but <strong class="calibre8">only</strong> those listed in the services file we described earlier. Using the <kbd class="calibre16">ServiceLoader&lt;SunagoPreferences&gt;</kbd> instance, we grab an iterator, and if it has an entry (<kbd class="calibre16">iterator.hasNext()</kbd>), we return that instance (<kbd class="calibre16">iterator.next()</kbd>). If it does not, we return <kbd class="calibre16">null</kbd>. There is a chance here for a <kbd class="calibre16">NullPointerException</kbd> since we are returning <kbd class="calibre16">null</kbd>, but we're also providing an implementation, so we avoid that risk. However, in your own code, you need to either ensure you have an implementation as we've done here, or to make sure that the consuming code is <kbd class="calibre16">null</kbd>-ready.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding a network - Twitter</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">So far, we have a pretty basic application, which can save and load its preferences, but let's get down to what we're here for and start connecting to social networks. What we hope to develop is a framework that makes it easy to add support for different social networks. Technically, as we'll soon see, the <strong class="calibre8">network</strong> need not even be social as the only thing that will imply a specific type of source is the name of the classes and interfaces involved. However, we will, in fact, focus on social networks, and we'll use a couple of different ones to show some variety. To that end, we'll start with Twitter, the massively popular microblogging platform, and Instagram, the increasingly photo-focused network that is now part of Facebook.</p>
<div class="packt_infobox">Speaking of Facebook, why are we not demonstrating integration with that social network? Two reasons--One, it's not significantly different from Twitter, so there would not be much that was new to cover; two, most importantly, the permissions that Facebook offers make it virtually impossible to integrate with it in a way that would be of interest here. For example, the permission to read a user's home timeline (or wall) is only granted to applications targeted at those platforms where Facebook is not currently available, and not at all to desktop applications, which is our target here.</div>
<p class="mce-root">As noted previously, we'd like to expose a way to add more networks without having to change the core application, so we need to develop an API. What we'll cover here is that API in a more or less <strong class="calibre8">finished</strong> state (is any software every truly finished?). However, while you will see a reasonably complete API, a word of caution--attempts to create an abstraction that start with that abstraction--that is, writing the abstraction from scratch--rarely end well. It is usually best to write a specific implementation to get a better understanding of the details required, then extract an abstraction. What you will see here is the end result of that process, so that process will not be covered here in any depth.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Registering as a Twitter developer</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To create an application that integrates with Twitter, we need to create a Twitter developer account, and then create a Twitter application. To create the account, we need to visit <a href="https://dev.twitter.com/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://dev.twitter.com</span></a>, and click on the <span class="calibre7">Join</span> button. Once you've created your developer account, you can click the <span class="calibre7">My Apps</span> link to go to <a href="https://apps.twitter.com/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://apps.twitter.com</span></a>. Here, we need to click on the <span class="calibre7">Create New App</span> button, which will get us a form that looks a bit like this:</p>
<div class="mce-root1"><img class="image-border21" src="Images/42daa02b-d5ea-4112-9c95-14dfcb9c1727.png" width="633" height="634"/></div>
<p class="mce-root">While the application we're developing is called <em class="calibre20">Sunago</em>, you won't be able to use that name, as it's already taken; you'll have to create a unique name of your own, assuming you're planning to run the application yourself. Once you've created the application, you'll be taken to the <span class="calibre7">Application Management</span> page for your new app. From this page, you can manage your app's permissions and keys, and, if needed, you can delete your app.</p>
<p class="mce-root">One thing to note on this page, as we'll need this soon, is where to find your application's <span class="calibre7">Consumer Key</span> and <span class="calibre7">Secret</span>. These are long, alphanumeric strings that your application will use to authenticate with Twitter's services. To interact with Twitter on behalf of a user--our ultimate goal--requires a different set of tokens, which we'll fetch shortly. Your <span class="calibre7">Consumer Key</span> and <span class="calibre7">Secret</span>--especially, <span class="calibre7">Consumer Secret</span>--should be kept, well, secret. If this combination is ever revealed publicly, other users will be able to masquerade as your app, potentially causing you serious headaches if they abuse the service. For that reason, you won't see the key/secret combination I generated anywhere in this book or the source code, which is why you will need to generate your own.</p>
<p class="mce-root">Armed now with our <span class="calibre7">Consumer Key</span> and <span class="calibre7">Secret</span>, we need to decide how to talk to Twitter. Twitter offers a public REST API, which they document on their site. If we were so inclined, we could pick an HTTP client of some sort, and start making calls. In the interests of simplicity and clarity, though, not to mention robustness, fault tolerance, and so on, we might be better served using a higher-level library of some sort. As luck would have it, there is a such a library, Twitter4J, which will make our integration much simpler and cleaner (for the curious, Twitter4J has over 200 Java classes. While we won't need all of the functionality represented there and exposed via the REST API, it should give you an idea of the scope of the effort required to write a reasonable wrapper for Twitter's REST interface).</p>
<p class="mce-root">As mentioned earlier, we want to be able to add networks to Sunago without having to change the core application, so we will write our Twitter integration in a separate Maven module. This will require that some of the code we've already written for Sunago be extracted into yet another module. Both our Twitter module and the main application module will then add a dependency on this new module. Since we'll have multiple modules at play here, we'll be sure to indicate to which module each class belongs. When we're finished, our project dependency graph will look like this:</p>
<div class="mce-root1"><img class="image-border22" src="Images/beb9bc78-0b95-45e0-aad5-5834e235f1f5.png"/></div>
<p class="mce-root">Technically, the only reason we show a dependency between the Application module and the Instagram and Twitter modules is because we're building them as part of the same project. A third-party developer, as we'll see, could easily develop an independent module, add it to the application's runtime classpath, and see the change in the application, all without this build-level dependency. Hopefully, though, this graph helps explain how the modules are related.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding Twitter preferences to Sunago</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's start by adding Twitter to our preferences screen. Before we can do any integration, we need to be able to configure the application, or, more accurately, the Twitter module, so that it can connect as a specific user. To enable that, we'll add a new interface to the API module as follows:</p>
<pre class="calibre21">    public abstract class SocialMediaPreferencesController { 
      public abstract Tab getTab(); 
      public abstract void savePreferences(); 
    } </pre>
<p class="mce-root">This interface will give Sunago two hooks into the module--one giving the module a chance to draw its own preferences user interface, and one to allow it to save those preferences. We can then implement that in our module. Before we do so, though, let's see how the application will find these implementations so that they can be used. For that, we will again turn to SPI. In Sunago's <kbd class="calibre16">PreferencesController</kbd> interface, we add this code:</p>
<pre class="calibre21">    private List&lt;SocialMediaPreferencesController&gt; smPrefs =  
      new ArrayList&lt;&gt;(); 
    @Override 
    public void initialize(URL url, ResourceBundle rb) { 
      itemCount.setText(SunagoUtil.getSunagoPreferences() 
       .getPreference(SunagoPrefsKeys.ITEM_COUNT.getKey(), "50")); 
      final ServiceLoader&lt;SocialMediaPreferencesController&gt;  
       smPrefsLoader = ServiceLoader.load( 
         SocialMediaPreferencesController.class); 
       smPrefsLoader.forEach(smp -&gt; smPrefs.add(smp)); 
       smPrefs.forEach(smp -&gt; tabPane.getTabs().add(smp.getTab())); 
    } </pre>
<p class="mce-root">We have an instance variable to hold a list of any <kbd class="calibre16">SocialMediaPreferencesController</kbd> instances we find. Next, in <kbd class="calibre16">initialize()</kbd>, we call the now familiar <kbd class="calibre16">ServiceLoader.load()</kbd> method to find any implementations, which we then add to the <kbd class="calibre16">List</kbd> that we created previously. Once we have our list of controllers, we call <kbd class="calibre16">getTab()</kbd> on each of them, adding the returned <kbd class="calibre16">Tab</kbd> instance to the <kbd class="calibre16">PreferencesController</kbd> interface's <kbd class="calibre16">tabPane</kbd>.</p>
<p class="mce-root">With the loading part clarified, let's now take a look at the Twitter preferences user interface implementation. We start by implementing the controller that will back this part of the user interface as follows:</p>
<pre class="calibre21">    public class TwitterPreferencesController  
      extends SocialMediaPreferencesController { 
        private final TwitterClient twitter; 
        private Tab tab; 
 
        public TwitterPreferencesController() { 
          twitter = new TwitterClient(); 
        } 
 
        @Override 
        public Tab getTab() { 
          if (tab == null) { 
            tab = new Tab("Twitter"); 
            tab.setContent(getNode()); 
          } 
 
          return tab; 
    } </pre>
<p class="mce-root">We'll take a look at <kbd class="calibre16">TwitterClient</kbd> in a moment, but, first, a note on <kbd class="calibre16">getTab()</kbd>. Notice that we create the <kbd class="calibre16">Tab</kbd> instance, which we need to return, but we delegate the creation of its contents to the <kbd class="calibre16">getNode()</kbd> method. <kbd class="calibre16">Tab.setContent()</kbd> allows us to completely replace the contents of the tab with a single call, something we'll make use of next. The <kbd class="calibre16">getNode()</kbd> method looks like this:</p>
<pre class="calibre21">    private Node getNode() { 
      return twitter.isAuthenticated() ? buildConfigurationUI() : 
        buildConnectUI(); 
    } </pre>
<p class="mce-root">If the user has already authenticated, then we want to present some configuration options. If not, then we need to offer a means to connect to Twitter.</p>
<pre class="calibre21">    private Node buildConnectUI() { 
      HBox box = new HBox(); 
      box.setPadding(new Insets(10)); 
      Button button = new Button(MessageBundle.getInstance() 
       .getString("connect")); 
      button.setOnAction(event -&gt; connectToTwitter()); 
 
      box.getChildren().add(button); 
 
      return box; 
    } </pre>
<p class="mce-root">In this simple user interface, we create an <kbd class="calibre16">HBox</kbd> primarily so we can add some padding. Without the <kbd class="calibre16">new Insets(10)</kbd> instance we pass to <kbd class="calibre16">setPadding()</kbd>, our button would be pressed right up against the top and left edges of the window, which is not visually appealing. Next, we create the <kbd class="calibre16">Button</kbd>, and set the <kbd class="calibre16">onAction</kbd> handler (ignore that constructor parameter for now).</p>
<p class="mce-root">The interesting part is hidden away in <kbd class="calibre16">connectToTwitter</kbd>, as shown in this code:</p>
<pre class="calibre21">    private void connectToTwitter() { 
      try { 
        RequestToken requestToken =  
          twitter.getOAuthRequestToken(); 
        LoginController.showAndWait( 
          requestToken.getAuthorizationURL(), 
           e -&gt; ((String) e.executeScript( 
             "document.documentElement.outerHTML")) 
              .contains("You've granted access to"), 
               e -&gt; { 
                 final String html =  
                   "&lt;kbd aria-labelledby="code-desc"&gt;&lt;code&gt;"; 
                    String body = (String) e.executeScript( 
                      "document.documentElement.outerHTML"); 
                    final int start = body.indexOf(html) +  
                     html.length(); 
                    String code = body.substring(start, start+7); 
                    saveTwitterAuthentication(requestToken, code); 
                    showConfigurationUI(); 
               }); 
      } catch (TwitterException ex) { 
        Logger.getLogger(getClass().getName()) 
          .log(Level.SEVERE, null, ex); 
      } 
    } </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">OAuth and logging on to Twitter</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We'll take a detour into <kbd class="calibre16">LoginController</kbd> in just a moment, but first, let's make sure we understand what's going on here. To log on to Twitter on behalf of a user, we need to generate an OAuth request token from which we get an authorization URL. The details of which are hidden nicely behind the Twitter4J API, but it is, basically, the OAuth authorization URL listed on the <span class="calibre7">Application Management</span> page with a request token passed as a query string. As we'll see, this URL is opened in a <kbd class="calibre16">WebView</kbd>, which prompts the user to authenticate against Twitter, and then authorize the application (or decline to):</p>
<div class="mce-root1"><img class="image-border23" src="Images/de141ca9-ccda-489a-b1f5-8aa496d98983.png" width="764" height="424"/></div>
<p class="mce-root">If the user successfully authenticates and authorizes the application, the <kbd class="calibre16">WebView</kbd> is redirected to a success page, which displays a numeric code that we need to capture to finish gathering the authentication/authorization credentials needed. The success page might look like this:</p>
<div class="mce-root1"><img class="image-border24" src="Images/2104c10e-20b4-4313-ac1c-eb187fe49f8b.png" width="782" height="318"/></div>
<p class="mce-root">For those not familiar with OAuth, what this allows us to do is to authenticate as the user, now and at any arbitrary moment in the future, without needing to store the user's actual password. The end result of this handshake between our application and Twitter is a token and token secret, which we'll pass to Twitter for authentication. As long as this token is valid--the user can invalidate it at any time via Twitter's web interface--we can connect and act as that user. Should the key ever be compromised, the user can revoke the key, affecting only the intended app and anyone attempting to use the stolen key.</p>
<p class="mce-root"><kbd class="calibre16">LoginController</kbd>, which is part of the API module, handles all of the boilerplate code for us, as seen in this code:</p>
<pre class="calibre21">    public class LoginController implements Initializable { 
      @FXML 
      private WebView webView; 
      private Predicate&lt;WebEngine&gt; loginSuccessTest; 
      private Consumer&lt;WebEngine&gt; handler; 
 
      public static void showAndWait(String url,  
       Predicate&lt;WebEngine&gt; loginSuccessTest, 
       Consumer&lt;WebEngine&gt; handler) { 
         try { 
           fxmlLoader loader = new fxmlLoader(LoginController 
             .class.getResource("/fxml/login.fxml")); 
 
           Stage stage = new Stage(); 
           stage.setScene(new Scene(loader.load())); 
           LoginController controller =  
              loader.&lt;LoginController&gt;getController(); 
           controller.setUrl(url); 
           controller.setLoginSuccessTest(loginSuccessTest); 
           controller.setHandler(handler); 
 
           stage.setTitle("Login..."); 
           stage.initModality(Modality.APPLICATION_MODAL); 
 
           stage.showAndWait(); 
         } catch (IOException ex) { 
           throw new RuntimeException(ex); 
         } 
    } </pre>
<p class="mce-root">This preceding code is a basic FXML-backed JavaFX controller, but we do have a static helper method to handle the details of creating, configuring, and showing an instance. We load the scene using FXML, get the controller (which is an instance of the enclosing class), set the <kbd class="calibre16">loginSuccessTest</kbd> and <kbd class="calibre16">handler</kbd> properties, and then show the dialog.</p>
<p class="mce-root">Do <kbd class="calibre16">loginSuccessTest</kbd> and <kbd class="calibre16">handler</kbd> look odd? They are instances of the Java 8 functional interfaces <kbd class="calibre16">Predicate&lt;T&gt;</kbd> and <kbd class="calibre16">Consumer&lt;T&gt;</kbd>. <kbd class="calibre16">Predicate</kbd> is a functional interface that takes a type, <kbd class="calibre16">WebEngine</kbd> in our case, and returns a <kbd class="calibre16">boolean</kbd>. It is designed to check for a certain condition given a variable of the specified type. In this instance, we call <kbd class="calibre16">WebEngine.executeScript().contains()</kbd> to extract a piece of the document, and see if it contains a certain piece of text indicating that we've been redirected to the login success page.</p>
<p class="mce-root"><kbd class="calibre16">Consumer&lt;T&gt;</kbd> is a functional interface (or, in our case, a lambda) that takes a single parameter of the specified type, and returns void. Our handler is a <kbd class="calibre16">Consumer</kbd>, which is called once our <kbd class="calibre16">Predicate</kbd> returns true. The lambda extracts the code from the HTML page, calls <kbd class="calibre16">saveTwitterAuthentication()</kbd> to finish authenticating the user, then <kbd class="calibre16">showConfigurationUI()</kbd> to change the user interface so that the user can configure Twitter-related settings.</p>
<p class="mce-root">The method <kbd class="calibre16">saveTwitterAuthentication()</kbd> is very straightforward, and is given as follows:</p>
<pre class="calibre21">    private void saveTwitterAuthentication(RequestToken requestToken,<br class="calibre2"/>     String code) { 
       if (!code.isEmpty()) { 
         try { 
           AccessToken accessToken = twitter 
             .getAcccessToken(requestToken, code); 
           prefs.putPreference(TwitterPrefsKeys.TOKEN.getKey(),  
             accessToken.getToken()); 
           prefs.putPreference(TwitterPrefsKeys.TOKEN_SECRET.getKey(),  
             accessToken.getTokenSecret()); 
         } catch (TwitterException ex) { 
           Logger.getLogger(TwitterPreferencesController 
             .class.getName()).log(Level.SEVERE, null, ex); 
         } 
       } 
    } </pre>
<p class="mce-root">The method <kbd class="calibre16">twitter.getAccessToken()</kbd> takes our request token and the code we extracted from the web page, and sends an HTTP <kbd class="calibre16">POST</kbd> to a Twitter REST endpoint, which generates the token secret we need. When that request returns, we store the token and token secret to our <kbd class="calibre16">Preferences</kbd> store (again, oblivious to where and how).</p>
<p class="mce-root">The method <kbd class="calibre16">showConfigurationUI()</kbd> and the related method should also be familiar.</p>
<pre class="calibre21">    private void showConfigurationUI() { 
      getTab().setContent(buildConfigurationUI()); 
    } 
    private Node buildConfigurationUI() { 
      VBox box = new VBox(); 
      box.setPadding(new Insets(10)); 
 
      CheckBox cb = new CheckBox(MessageBundle.getInstance() 
        .getString("homeTimelineCB")); 
      cb.selectedProperty().addListener( 
        (ObservableValue&lt;? extends Boolean&gt; ov,  
          Boolean oldVal, Boolean newVal) -&gt; { 
            showHomeTimeline = newVal; 
          }); 
 
      Label label = new Label(MessageBundle.getInstance() 
        .getString("userListLabel") + ":"); 
 
      ListView&lt;SelectableItem&lt;UserList&gt;&gt; lv = new ListView&lt;&gt;(); 
      lv.setItems(itemList); 
      lv.setCellFactory(CheckBoxListCell.forListView( 
        item -&gt; item.getSelected())); 
      VBox.setVgrow(lv, Priority.ALWAYS); 
 
      box.getChildren().addAll(cb, label, lv); 
      showTwitterListSelection(); 
 
      return box;
    } </pre>
<p class="mce-root">One new item in this preceding method is the listener we add to the <kbd class="calibre16">selectedProperty</kbd> of the <kbd class="calibre16">CheckBox</kbd>. Any time the selected value changes, our listener is called, which sets the value of the <kbd class="calibre16">showHomeTimeline</kbd> boolean.</p>
<p class="mce-root">The <kbd class="calibre16">ListView</kbd> also needs special attention. Notice the parameterized type, <kbd class="calibre16">SelectableItem&lt;UserList&gt;</kbd>. What is that? That's an abstract class we've created to wrap items for use in <kbd class="calibre16">CheckBoxListCell</kbd>, which you can see in the call to <kbd class="calibre16">setCellFactory()</kbd>. That class looks like this:</p>
<pre class="calibre21">    public abstract class SelectableItem&lt;T&gt; { 
      private final SimpleBooleanProperty selected =  
        new SimpleBooleanProperty(false); 
      private final T item; 
      public SelectableItem(T item) { 
        this.item = item; 
      } 
      public T getItem() { 
        return item; 
      } 
      public SimpleBooleanProperty getSelected() { 
        return selected; 
      } 
    } </pre>
<p class="mce-root">This class, which lives in the API module, is a simple wrapper around an arbitrary type that adds a <kbd class="calibre16">SimpleBooleanProperty</kbd>. We see how this property is manipulated when the cell factory is set up--<kbd class="calibre16">lv.setCellFactory(CheckBoxListCell .forListView(item -&gt; item.getSelected()))</kbd>. We expose <kbd class="calibre16">SimpleBooleanProperty</kbd> via the <kbd class="calibre16">getSelected()</kbd> method, which the <kbd class="calibre16">CheckBoxListCell</kbd> uses to set and read the state of each line.</p>
<p class="mce-root">Our final user interface-related method is this:</p>
<pre class="calibre21">    private void showTwitterListSelection() { 
      List&lt;SelectableItem&lt;UserList&gt;&gt; selectable =  
        twitter.getLists().stream() 
         .map(u -&gt; new SelectableUserList(u)) 
         .collect(Collectors.toList()); 
      List&lt;Long&gt; selectedListIds = twitter.getSelectedLists(prefs); 
      selectable.forEach(s -&gt; s.getSelected() 
        .set(selectedListIds.contains(s.getItem().getId()))); 
      itemList.clear(); 
      itemList.addAll(selectable); 
    } </pre>
<p class="mce-root">Using the same <kbd class="calibre16">SelectableItem</kbd> class, we request from Twitter all of the lists the user might have created, which we wrap in <kbd class="calibre16">SelectableUserList</kbd>, a <kbd class="calibre16">SelectableItem</kbd> child that overrides the <kbd class="calibre16">toString()</kbd> method to provide user-friendly text in <kbd class="calibre16">ListView</kbd>. We load any checked lists from preferences, set their respective booleans/checkboxes, and update our <kbd class="calibre16">ObservableList</kbd> and, thus, the user interface.</p>
<p class="mce-root">The final method we need to implement to satisfy the <kbd class="calibre16">SocialMediaPreferencesController</kbd> contract is <kbd class="calibre16">savePreferences()</kbd>, which is as follows:</p>
<pre class="calibre21">    public void savePreferences() { 
      prefs.putPreference(TwitterPrefsKeys.HOME_TIMELINE.getKey(),  
       Boolean.toString(showHomeTimeline)); 
      List&lt;String&gt; selectedLists = itemList.stream() 
       .filter(s -&gt; s != null) 
       .filter(s -&gt; s.getSelected().get()) 
       .map(s -&gt; Long.toString(s.getItem().getId())) 
       .collect(Collectors.toList()); 
      prefs.putPreference(TwitterPrefsKeys.SELECTED_LISTS.getKey(),  
       String.join(",", selectedLists)); 
    } </pre>
<p class="mce-root">This is a mostly straightforward saving of the user's options to preferences, but the list handling is worth pointing out. Rather than manually iterating over each item in the list, we can use a stream and apply a couple of <kbd class="calibre16">filter()</kbd> operations to strip out entries that are of no interest to us, <kbd class="calibre16">map()</kbd> each <kbd class="calibre16">SelectableUserList</kbd> that makes it through to <kbd class="calibre16">Long</kbd> (which is the list's ID), then collect them in a <kbd class="calibre16">List&lt;String&gt;</kbd>. We join that <kbd class="calibre16">List</kbd> using <kbd class="calibre16">String.join()</kbd>, and write it out to our preferences.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding a model for Twitter</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are still a couple of other interfaces that we need to implement to finish our Twitter support. The first, and simpler, one is <kbd class="calibre16">SocialMediaItem</kbd>:</p>
<pre class="calibre21">    public interface SocialMediaItem { 
      String getProvider(); 
      String getTitle(); 
      String getBody(); 
      String getUrl(); 
      String getImage(); 
      Date getTimestamp(); 
    } </pre>
<p class="mce-root">This preceding interface provides us with a nice abstraction over the various types of data that a social network might return without being too heavily burdened with fields that aren't used by most (or many, at least) networks. The Twitter implementation of this <kbd class="calibre16">Tweet</kbd> class is as follows:</p>
<pre class="calibre21">    public class Tweet implements SocialMediaItem { 
      private final Status status; 
      private final String url; 
      private final String body; 
 
      public Tweet(Status status) { 
        this.status = status; 
        body = String.format("@%s: %s (%s)",  
          status.getUser().getScreenName(), 
          status.getText(), status.getCreatedAt().toString()); 
        url = String.format("https://twitter.com/%s/status/%d", 
          status.getUser().getScreenName(), status.getId()); 
    } </pre>
<p class="mce-root">Taking the Twitter4J class <kbd class="calibre16">Status</kbd>, we extract information of interest to us, and store it in instance variables (whose getters are not shown, as they're just simple getters). For the <kbd class="calibre16">getImage()</kbd> method, we make a reasonable effort to extract any image from the tweet, as follows:</p>
<pre class="calibre21">    public String getImage() { 
      MediaEntity[] mediaEntities = status.getMediaEntities(); 
      if (mediaEntities.length &gt; 0) { 
        return mediaEntities[0].getMediaURLHttps(); 
      } else { 
          Status retweetedStatus = status.getRetweetedStatus(); 
          if (retweetedStatus != null) { 
            if (retweetedStatus.getMediaEntities().length &gt; 0) { 
              return retweetedStatus.getMediaEntities()[0] 
               .getMediaURLHttps(); 
            } 
          } 
        } 
      return null; 
    } </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing a Twitter client</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The second interface is <kbd class="calibre16">SocialMediaClient</kbd>. This interface serves not only as an abstraction that Sunago can use to interact with an arbitrary social network integration, but also as a guideline for interested developers to show them the minimum requirements for the integration. It looks like this:</p>
<pre class="calibre21">    public interface SocialMediaClient { 
      void authenticateUser(String token, String tokenSecret); 
      String getAuthorizationUrl(); 
      List&lt;? Extends SocialMediaItem&gt; getItems(); 
      boolean isAuthenticated(); 
    } </pre>
<p class="mce-root">For Twitter support, this preceding interface is implemented by the class <kbd class="calibre16">TwitterClient</kbd>. Most of the class is pretty basic, so we won't reproduce that here (you can peruse it in the source repository if you'd like details), but one implementation detail might be worth spending some time over. That method is <kbd class="calibre16">processList()</kbd>, which is as follows:</p>
<pre class="calibre21">    private List&lt;Tweet&gt; processList(long listId) { 
      List&lt;Tweet&gt; tweets = new ArrayList&lt;&gt;(); 
 
      try { 
        final AtomicLong sinceId = new AtomicLong( 
          getSinceId(listId)); 
        final Paging paging = new Paging(1,  
          prefs.getPreference(SunagoPrefsKeys. 
          ITEM_COUNT.getKey(), 50), sinceId.get()); 
        List&lt;Status&gt; statuses = (listId == HOMETIMELINE) ?  
          twitter.getHomeTimeline(paging) : 
           twitter.getUserListStatuses(listId, paging); 
        statuses.forEach(s -&gt; { 
          if (s.getId() &gt; sinceId.get()) { 
            sinceId.set(s.getId()); 
          } 
          tweets.add(new Tweet(s)); 
        }); 
        saveSinceId(listId, sinceId.get()); 
      } catch (TwitterException ex) { 
          Logger.getLogger(TwitterClient.class.getName()) 
           .log(Level.SEVERE, null, ex); 
        } 
        return tweets; 
    } </pre>
<p class="mce-root">There are several things going on in this last method. First, we want to limit how many tweets we actually retrieve. If this is the first time the app is used, or the first time that it's used in a long time, there could be a significant number of tweets. Retrieving all of them would be quite expensive in terms of network usage, memory and, perhaps, processing time. We implement that limit using the <kbd class="calibre16">Paging</kbd> object from Twitter4J.</p>
<p class="mce-root">We also don't want to retrieve tweets we already have, so, for each list, we keep a <kbd class="calibre16">sinceId</kbd>, which we can pass to the Twitter API. It will use this to find up to the specified number of tweets whose ID is greater than <kbd class="calibre16">sinceId</kbd>.</p>
<p class="mce-root">Wrapping all of this up in the <kbd class="calibre16">Paging</kbd> object, we call either <kbd class="calibre16">twitter.getHomeTimeline()</kbd> if the list ID is <kbd class="calibre16">-1</kbd> (an internal ID we've used to identify the home timeline) or <kbd class="calibre16">twitter.getUserListStatus()</kbd> for a user-defined list. For each <kbd class="calibre16">Status</kbd> returned, we update <kbd class="calibre16">sinceId</kbd> (which we've modeled using an <kbd class="calibre16">AtomicLong</kbd>, as any method variable used inside a lambda must be final or effectively final), and add the tweet to our <kbd class="calibre16">List</kbd>. Before exiting, we store <kbd class="calibre16">sinceId</kbd> for the list in our in-memory store, and then return the tweets for the Twitter list.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">A brief look at internationalization and localization</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">While somewhat basic, our integration with Twitter is now complete, as it fulfills our functional requirements for the network. However, there is one more piece of code that we need to take a quick look at. Earlier, in some of the code samples, you might have noticed code that looks like this: <kbd class="calibre16">MessageBundle.getInstance().getString("homeTimelineCB")</kbd>. What is that, and what does it do?</p>
<p class="mce-root">The <kbd class="calibre16">MessageBundle</kbd> class is a small wrapper around the internationalization and localization facilities (also known as i18n and l10n, where the numbers represent the number of letters dropped from the words to make the abbreviation) provided by the JDK. The code for this class is as follows:</p>
<pre class="calibre21">    public class MessageBundle { 
      ResourceBundle messages =  
        ResourceBundle.getBundle("Messages", Locale.getDefault()); 
 
      private MessageBundle() { 
      } 
 
      public final String getString(String key) { 
        return messages.getString(key); 
      } 
     
      private static class LazyHolder { 
        private static final MessageBundle INSTANCE =  
          new MessageBundle(); 
      } 
 
      public static MessageBundle getInstance() { 
        return LazyHolder.INSTANCE; 
      } 
    } </pre>
<p class="mce-root">There are two main items of interest here. We'll start at the end of the class with the <kbd class="calibre16">getInstance()</kbd> method. This is an example of what is known as the <strong class="calibre8">initialize on demand holder</strong> (<strong class="calibre8">IODH</strong>) pattern. There is a single, static instance of the class <kbd class="calibre16">MessageBundle</kbd> in the JVM. It is not initialized, however, until the <kbd class="calibre16">getInstance()</kbd> method is called. This is accomplished by taking advantage of how the JVM loads and initializes statics. As soon as a class is referenced in any way, it is loaded into <kbd class="calibre16">ClassLoader</kbd>, at which point any statics on the class will be initialized. The private static class <kbd class="calibre16">LazyHolder</kbd> is <strong class="calibre8">not</strong> initialized until the JVM is sure that something needs to access it. Once we call <kbd class="calibre16">getInstance()</kbd>, which references <kbd class="calibre16">LazyHolder.INSTANCE</kbd>, the class is initialized and the singleton instance created.</p>
<div class="packt_infobox">It should be noted that are ways around the singleton nature we're trying to implement (for example, via reflection), but our use case here does not warrant any worries over such an attack.</div>
<p class="mce-root">The actual functionality is implemented in the first line of the class, which is as follows</p>
<pre class="calibre21">    ResourceBundle messages =  
      ResourceBundle.getBundle("Messages", Locale.getDefault()); </pre>
<p class="mce-root">The <kbd class="calibre16">ResourceBundle</kbd> files, in the words of the Javadoc, <em class="calibre20">contain locale-specific objects</em>. Usually, this means Strings, as it does in our case. The <kbd class="calibre16">getBundle()</kbd> method will attempt to find and load a bundle with the name given for the specified locale. In our case, we're looking for a bundle named <kbd class="calibre16">Messages</kbd>. Technically, we're looking for a bundle in a family of bundles with the shared base name <kbd class="calibre16">Messages</kbd>. The system will use the <kbd class="calibre16">Locale</kbd> specified to find the correct file. This resolution will follow the same lookup logic that <kbd class="calibre16">Locale</kbd> uses, so the <kbd class="calibre16">getBundle()</kbd> method will return the bundle with the most specific matching name available.</p>
<p class="mce-root">Let's say we're running this application on my computer. I live in the United States, so my system's default locale is <kbd class="calibre16">en_US</kbd>. Following the rules of the <kbd class="calibre16">Locale</kbd> lookup, then, <kbd class="calibre16">getBundle()</kbd> will try to locate files in this order:</p>
<ol class="calibre18">
<li class="chapter"><kbd class="calibre16">Messages_en_US.properties</kbd>.</li>
<li class="chapter"><kbd class="calibre16">Messages_en.properties</kbd>.</li>
<li class="chapter"><kbd class="calibre16">Messages.properties</kbd>.</li>
</ol>
<p class="mce-root">The system will go from the most specific file to the least until it finds the key requested. If it's not found in any file, <kbd class="calibre16">MissingResourceException</kbd> is thrown. Each file consists of key/value pairs. Our <kbd class="calibre16">Messages.properties</kbd> file looks like this:</p>
<pre class="calibre21">    homeTimelineCB=Include the home timeline 
    userListLabel=User lists to include 
    connect=Connect 
    twitter=Twitter </pre>
<p class="mce-root">It is just a simple mapping of keys to localized text. We could have <kbd class="calibre16">Messages_es.properties</kbd> with this line:</p>
<pre class="calibre21">    userListLabel=Listas de usuarios para incluir </pre>
<p class="mce-root">If that were the only entry in the file, that one label in the file would be in Spanish, with everything else being in the default from <kbd class="calibre16">Message.properties</kbd>, which, in our case, is English.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Making our JAR file fat</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With that, our implementation is now complete. Before this can be used in the way we intend, though, we need to make a build change. If you recall the discussion of the requirements at the beginning of the chapter, we want to build a system that easily allows third-party developers to write modules that will add support for arbitrary social networks without the need to modify the core application. To deliver that functionality, these developers would need to offer a JAR that Sunago users could drop in a folder. When the application is started, the new functionality is now available.</p>
<p class="mce-root">That leaves us, then, with the task of bundling all of the required code. As the project stands now, a single JAR is created, which holds just our classes. That's not entirely sufficient, though, as we depend on the Twitter4J jar. Other modules could have even more dependencies. Requiring users to drop in, say, half a dozen or more jars is probably asking a bit much. Fortunately, Maven has a mechanism that will allow us to avoid that problem altogether: the shade plugin.</p>
<p class="mce-root">By configuring this plugin in our build, we can generate a single jar that holds our classes and resources, plus those of every dependency declared in the project. This is often called a <strong class="calibre8">fat jar</strong>, and is as follows:</p>
<pre class="calibre21">    &lt;build&gt; 
      &lt;plugins&gt; 
        &lt;plugin&gt; 
          &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; 
            &lt;version&gt;${plugin.shade}&lt;/version&gt; 
              &lt;executions&gt; 
                &lt;execution&gt; 
                  &lt;phase&gt;package&lt;/phase&gt; 
                    &lt;goals&gt; 
                      &lt;goal&gt;shade&lt;/goal&gt; 
                    &lt;/goals&gt; 
                  &lt;/execution&gt; 
              &lt;/executions&gt; 
        &lt;/plugin&gt; 
      &lt;/plugins&gt; 
    &lt;/build&gt; </pre>
<p class="mce-root">This is an official Maven plugin, so we can omit <kbd class="calibre16">groupId</kbd>, and we've defined a property, <kbd class="calibre16">plugin.shade</kbd>, somewhere up the POM's inheritance tree. When the package phase is run, the shade goal of this plugin will execute and build our fat jar.</p>
<pre class="calibre21"><strong class="calibre3">$ ll target/*.jar</strong>
  <strong class="calibre3">total 348</strong>
  <strong class="calibre3">-rwx------+ 1 jason None  19803 Nov 20 19:22 original-twitter-1.0-<br class="calibre2"/>  SNAPSHOT.jar</strong>
  <strong class="calibre3">-rwx------+ 1 jason None 325249 Nov 20 19:22 twitter-1.0-<br class="calibre2"/>  SNAPSHOT.jar</strong>  </pre>
<p class="mce-root">The original jar, which is considerably smaller, is renamed to <kbd class="calibre16">original-twitter-1.0-SNAPSHOT.jar</kbd>, and the fat jar receives the configured final name. It is this fat jar that is installed in the local maven repository, or deployed to an artifact manager, such as Artifactory.</p>
<p class="mce-root">There is a small bug, though. Our twitter module depends on the API module so that it can see the interfaces and classes exposed by the application. Currently, even those are included in the fat jar, which we don't want, as that can cause some <kbd class="calibre16">ClassLoader</kbd> issues down the road in some situations. To prevent that, we mark that dependency as <kbd class="calibre16">provided</kbd>, as shown next:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; 
      &lt;artifactId&gt;api&lt;/artifactId&gt; 
      &lt;version&gt;${project.version}&lt;/version&gt; 
      &lt;scope&gt;provided&lt;/scope&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">If we issue a <kbd class="calibre16">mvn clean install</kbd> now, we'll have a nice fat jar with only the classes we need to bundle, and one that's ready for distribution.</p>
<p class="mce-root">To make things as simple as possible, we're just going to declare a dependency on this jar in Sunago's app module, as follows:</p>
<pre class="calibre21">    &lt;dependencies&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; 
        &lt;artifactId&gt;api&lt;/artifactId&gt; 
        &lt;version&gt;${project.version}&lt;/version&gt; 
      &lt;/dependency&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; 
        &lt;artifactId&gt;twitter&lt;/artifactId&gt; 
        &lt;version&gt;${project.version}&lt;/version&gt; 
      &lt;/dependency&gt; 
    &lt;/dependencies&gt; </pre>
<p class="mce-root">If we run Sunago now, we'll see Twitter added to our settings screen, and, once connected and configured, we'll see tweets showing up on the main screen. We'll also notice that the main screen is a little plain, and, more importantly, doesn't provide any way of refreshing the contents, so let's fix that.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding a refresh button</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the <span class="calibre7">Projects</span> window, find <kbd class="calibre16">sunago.fxml</kbd>, right-click on it, and select <kbd class="calibre16">Edit</kbd>. We'll make this user interface change by hand, only for the sake of experience. Scroll down until you find the closing <kbd class="calibre16">Menubar</kbd> tag (<kbd class="calibre16">&lt;/Menubar&gt;</kbd>). On the line right after that, insert these lines:</p>
<pre class="calibre21">    &lt;ToolBar &gt; 
      &lt;items&gt; 
        &lt;Button fx:id="refreshButton" /&gt; 
        &lt;Button fx:id="settingsButton" /&gt; 
      &lt;/items&gt; 
    &lt;/ToolBar&gt; </pre>
<p class="mce-root">In <kbd class="calibre16">SunagoController</kbd>, we need to add the instance variables as follows:</p>
<pre class="calibre21">    @FXML 
    private Button refreshButton; 
    @FXML 
    private Button settingsButton; </pre>
<p class="mce-root">Then, in <kbd class="calibre16">initialize()</kbd>, we need to set them up like this:</p>
<pre class="calibre21">    refreshButton.setGraphic(getButtonImage("/images/reload.png")); 
    refreshButton.setOnAction(ae -&gt; loadItemsFromNetworks()); 
    refreshButton.setTooltip(new Tooltip("Refresh")); 
 
    settingsButton.setGraphic(getButtonImage("/images/settings.png")); 
    settingsButton.setOnAction(ae -&gt; showPreferences(ae)); 
    settingsButton.setTooltip(new Tooltip("Settings")); </pre>
<p class="mce-root">Notice that we're doing a bit more than setting up an action handler. The first thing we do is call <kbd class="calibre16">setGraphic()</kbd>. Remember from our discussion of the Twitter preference tab, calling <kbd class="calibre16">setGraphic()</kbd> will replace the child nodes with the <kbd class="calibre16">Node</kbd> that you specify. In these two cases, that <kbd class="calibre16">Node</kbd> is an <kbd class="calibre16">ImageView</kbd>, and comes from the <kbd class="calibre16">getButtonImage()</kbd> method.</p>
<pre class="calibre21">    private ImageView getButtonImage(String path) { 
      ImageView imageView = new ImageView( 
        new Image(getClass().getResourceAsStream(path))); 
      imageView.setFitHeight(32); 
      imageView.setPreserveRatio(true); 
      return imageView; 
    } </pre>
<p class="mce-root">After we set the action handler, we also set a tooltip. This will give our graphical buttons a textual description when the user hovers over the button with the mouse, as seen in this screenshot:</p>
<div class="mce-root1"><img class="image-border25" src="Images/89fcdd48-39c2-4ae8-9eb2-85641a96ab99.png" width="642" height="527"/></div>
<p class="mce-root">The action handler for the refresh button is worth looking at, and is given as follows:</p>
<pre class="calibre21">    private void loadItemsFromNetworks() { 
      List&lt;SocialMediaItem&gt; items = new ArrayList&lt;&gt;(); 
      clientLoader.forEach(smc -&gt; { 
        if (smc.isAuthenticated()) { 
            items.addAll(smc.getItems()); 
        } 
      }); 
 
      items.sort((o1, o2) -&gt;  
        o2.getTimestamp().compareTo(o1.getTimestamp())); 
      entriesList.addAll(0, items); 
    } </pre>
<p class="mce-root">This is the same method that we call from <kbd class="calibre16">initialize()</kbd>. Using the Service Provider Interface that we discussed earlier, we iterate over each <kbd class="calibre16">SocialMediaClient</kbd> available in the system. If the client has authenticated against its network, we call the <kbd class="calibre16">getItems()</kbd> method, and add whatever it may return to a local variable, <kbd class="calibre16">items</kbd>. Once we've queried all of the networks configured in the system, we then sort our list. This will cause the entries of the various networks to be intermingled, as they're sorted by their timestamps in descending chronological order. This sorted list is then added to our <kbd class="calibre16">ObservableList</kbd> at the head, or the zeroth element, to cause them to appear at the top of the list in the user interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding another network - Instagram</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">So that we can see another type of integration, as well as to demonstrate how the interfaces we've defined make adding new networks relatively quick and easy, let's add one more network to Sunago--Instagram. While Instagram is owned by Facebook, at the time of this writing, its APIs are much more permissive than the social-media giant's, so we'll be able to add an interesting integration relatively easily.</p>
<p class="mce-root">Much like with Twitter, we have a choice to make about how our interactions with the Instragram API will be handled. Just like Twitter, Instagram offers a public REST API that is secured using OAuth. Also, just like Twitter, though, manually implementing a client to consume those APIs is not an attractive proposition due to the level of effort required. Again, unless there's a compelling reason to write your own client library, I would suggest that using some sort of client wrapper should be the preferred route if one is available. Fortunately, there is--jInstagram.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Registering as an Instagram developer</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before starting to write our client, we need to register a new Instagram client with the service. We do that by first creating, if needed, an Instagram developer account at <a href="https://www.instagram.com/developer" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://www.instagram.com/developer</span></a>. Once we have an account, we need to register our application either by clicking the <span class="calibre7">Register Your Application</span> button on the page, or by visiting <a href="https://www.instagram.com/developer/clients/manage/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://www.instagram.com/developer/clients/manage/</span></a> directly. From here, we need to click on <span class="calibre7">Register a New Client</span>, which will present this form:</p>
<div class="mce-root1"><img class="image-border26" src="Images/b7824295-77c9-46c5-bcc3-28f34366386b.png"/></div>
<p class="mce-root">Once you've registered your new client, you can click on the <span class="calibre7">Manage</span> button on the resulting web page to get your client ID and secret. Hold on to those, as you'll need them in a moment.</p>
<p class="mce-root">Next, we'll start the actual client by creating a new module just like we did for the Twitter module. This one, though, we'll call <kbd class="calibre16">Sunago - Instagram</kbd> and the <kbd class="calibre16">artifactIdinstagram</kbd>. We'll also go ahead and add the jInstagram dependency as follows:</p>
<pre class="calibre21">    &lt;artifactId&gt;instagram&lt;/artifactId&gt; 
    &lt;name&gt;Sunago - Instagram&lt;/name&gt; 
    &lt;packaging&gt;jar&lt;/packaging&gt; 
    &lt;dependencies&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; 
        &lt;artifactId&gt;api&lt;/artifactId&gt; 
        &lt;version&gt;${project.version}&lt;/version&gt; 
        &lt;scope&gt;provided&lt;/scope&gt; 
      &lt;/dependency&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;com.sachinhandiekar&lt;/groupId&gt; 
        &lt;artifactId&gt;jInstagram&lt;/artifactId&gt; 
        &lt;version&gt;1.1.8&lt;/version&gt; 
      &lt;/dependency&gt; 
    &lt;/dependencies&gt; </pre>
<p class="mce-root">Note that we have the Sunago <kbd class="calibre16">api</kbd> dependency added as well already, scoped as provided. We also need to add the Shade plugin configuration, which looks just like it does in the Twitter module, so it's not shown here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the Instagram client</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With our new module created, we need to create three specific items to fulfill the contract provided by the Sunago API module. We need <kbd class="calibre16">SocialMediaPreferencesController</kbd>, <kbd class="calibre16">SocialMediaClient</kbd>, and <kbd class="calibre16">SocialMediaItem</kbd>.</p>
<p class="mce-root">Our <kbd class="calibre16">SocialMediaPreferencesController</kbd> instance is <kbd class="calibre16">InstagramPreferencesController</kbd>. It has the same <kbd class="calibre16">getTab()</kbd> method required by the interface, which is as follows:</p>
<pre class="calibre21">    public Tab getTab() { 
      if (tab == null) { 
        tab = new Tab(); 
        tab.setText("Instagram"); 
        tab.setContent(getNode()); 
      } 
 
      return tab; 
    } 
 
    private Node getNode() { 
      Node node = instagram.isAuthenticated() 
        ? buildConfigurationUI() : buildConnectUI(); 
      return node; 
    } </pre>
<p class="mce-root">To save time and space, for this example, we've left the Instagram implementation much more basic than the one we created for Twitter, so the user interface definition does not hold much of interest. However, the authentication handling is interesting, as, while it has the same OAuth flow that Twitter uses, the data is returned in a manner that is much more easily consumed. The connect button calls this method:</p>
<pre class="calibre21">    private static final String CODE_QUERY_PARAM = "code="; 
    private void showConnectWindow() { 
      LoginController.showAndWait(instagram.getAuthorizationUrl(), 
        e -&gt; e.getLocation().contains(CODE_QUERY_PARAM), 
        e -&gt; { 
          saveInstagramToken(e.getLocation()); 
          showInstagramConfig(); 
        }); 
    } </pre>
<p class="mce-root">This uses the <kbd class="calibre16">LoginController</kbd> that we saw with Twitter, but our <kbd class="calibre16">Predicate</kbd> and <kbd class="calibre16">Consumer</kbd> are much more concise. The page to which the user is redirected has the code in the URL as a query parameter, so there's no need to scrape the HTML. We can just pull it straight from the URL as follows:</p>
<pre class="calibre21">    private void saveInstagramToken(String location) { 
      int index = location.indexOf(CODE_QUERY_PARAM); 
      String code = location.substring(index +  
        CODE_QUERY_PARAM.length()); 
      Token accessToken = instagram. 
        verifyCodeAndGetAccessToken(code); 
      instagram.authenticateUser(accessToken.getToken(),  
        accessToken.getSecret()); 
    } </pre>
<p class="mce-root">Once we have the code, we use an API on our <kbd class="calibre16">instagram</kbd> object to get the access token, which we then use to authenticate the user. So what does the <kbd class="calibre16">instagram</kbd> object look like? Like <kbd class="calibre16">TwitterClient</kbd>, <kbd class="calibre16">InstagramClient</kbd> is a <kbd class="calibre16">SocialMediaClient</kbd> that wraps the jInstagram API.</p>
<pre class="calibre21">    public final class InstagramClient implements<br class="calibre2"/>    SocialMediaClient { 
 
      private final InstagramService service; 
      private Instagram instagram; </pre>
<p class="mce-root">The jInstagram API has two objects that we need to use. <kbd class="calibre16">InstagramService</kbd> encapsulates the OAuth logic. We get an instance of it using a builder as follows:</p>
<pre class="calibre21">    service = new InstagramAuthService() 
     .apiKey(apiKey) 
     .apiSecret(apiSecret) 
     .callback("http://blogs.steeplesoft.com") 
     .scope("basic public_content relationships follower_list") 
     .build(); </pre>
<p class="mce-root">As discussed earlier, to run the application locally, you'll need to provide your own API key and secret pair. The only use we have for the callback URL is to provide Instagram with a place to redirect our client to. Once it does that, we pull the code from the query parameters as we saw previously. Finally, we have to provide a list of scopes, which is what Instagram calls permissions, roughly. This list will allow us to get a list of the accounts that the authenticated user follows, which we'll use to get images:</p>
<pre class="calibre21">    @Override 
    public List&lt;? extends SocialMediaItem&gt; getItems() { 
      List&lt;Photo&gt; items = new ArrayList&lt;&gt;(); 
      try { 
        UserFeed follows = instagram.getUserFollowList("self"); 
        follows.getUserList().forEach(u -&gt;  
          items.addAll(processMediaForUser(u))); 
      } catch (InstagramException ex) { 
        Logger.getLogger(InstagramClient.class.getName()) 
          .log(Level.SEVERE, null, ex); 
      } 
 
      return items; 
    } </pre>
<p class="mce-root">If you read the jInstagram documentation, you'll be tempted to use the method <kbd class="calibre16">instagram.getUserFeeds()</kbd>, and if you do, you'll get what I got--a <kbd class="calibre16">404</kbd> error page. Instagram has done some work on their API that jInstagram has not yet reflected. What we need to do, then, is implement our own wrapper for that, which jInstagram makes fairly simple. Here, we get a list of the people that the user follows. For each user, we call <kbd class="calibre16">processMediaForUser()</kbd> to fetch and store any pending images.</p>
<pre class="calibre21">    private List&lt;Photo&gt; processMediaForUser(UserFeedData u) { 
      List&lt;Photo&gt; userMedia = new ArrayList&lt;&gt;(); 
      try { 
        final String id = u.getId(); 
        instagram.getRecentMediaFeed(id, 
          prefs.getPreference(SunagoPrefsKeys.ITEM_COUNT 
            .getKey(), 50), 
          getSinceForUser(id), null, null, null).getData() 
            .forEach(m -&gt; userMedia.add(new Photo(m))); 
        if (!userMedia.isEmpty()) { 
          setSinceForUser(id, userMedia.get(0).getId()); 
        } 
      } catch (InstagramException ex) { 
        Logger.getLogger(InstagramClient.class.getName()) 
          .log(Level.SEVERE, null, ex); 
      } 
      return userMedia; 
    } </pre>
<p class="mce-root">Using the same <strong class="calibre8">since ID</strong> and max count approach we used for the Twitter client, we request any recent media for the user. Each returned item is wrapped (via the lambda) in a <kbd class="calibre16">Photo</kbd> instance, which is our <kbd class="calibre16">SocialMediaItem</kbd> child for Instagram. Once we have our list, if it is not empty, we grab the first <kbd class="calibre16">Photo</kbd>, which we know is the oldest, because that's how the Instagram API returns its data, and we get the ID, which we store as the since ID for the next time this method is called. Finally, we return the <kbd class="calibre16">List</kbd> so that it can be added to the main <kbd class="calibre16">Photo</kbd> list given earlier.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Loading our plugins in Sunago</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With that, our new integration is done. To see it in action, we add the dependency to Sunago's POM as follows:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; 
      &lt;artifactId&gt;instagram&lt;/artifactId&gt; 
      &lt;version&gt;${project.version}&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">We then run the application.</p>
<p class="mce-root">Clearly, adding a dependency for each new integration is not an ideal solution, if for no other reason than that the user won't be running the application from an IDE or with Maven. What we need, then, is a way for the application to find any modules (or plugins, if you prefer that term) at runtime on the user's machine. The simplest solution would be to launch the application via a shell script like this:</p>
<pre class="calibre21">    #!/bin/bash 
    JARS=sunago-1.0-SNAPSHOT.jar 
    SEP=: 
    for JAR in `ls ~/.sunago/*.jar` ; do 
      JARS="$JARS$SEP$JAR" 
    done 
 
    java -cp $JARS com.steeplesoft.sunago.app.Sunago </pre>
<p class="mce-root">This preceding shell script creates a classpath using the main Sunago jar, plus any JARs found in <kbd class="calibre16">~/.sunago</kbd>, and then runs the application. This is simple and effective, but does require per-operating system versions. Fortunately, that just means this shell script for Mac and Linux, plus a batch file for Windows. That's not hard to do or difficult to maintain, but it does require that you have access to those operating systems to test and verify your scripts.</p>
<p class="mce-root">Another option is to make use of classloaders. As simple as it may seem to say it out loud, a <kbd class="calibre16">ClassLoader</kbd> is simply an object that is responsible for loading classes (and other resources). There are several classloaders at work in any given JVM, all arranged in a hierarchical fashion, starting with the bootstrap <kbd class="calibre16">ClassLoader</kbd>, then the platform <kbd class="calibre16">ClassLoader</kbd>, and, finally, the system--or application--<kbd class="calibre16">ClassLoader</kbd>. It is possible that a given application or runtime environment, such as a <strong class="calibre8">Java Enterprise Edition</strong> (<strong class="calibre8">Java EE</strong>) application server, might add one or more <kbd class="calibre16">ClassLoader</kbd> instances as children of the application <kbd class="calibre16">ClassLoader</kbd>. These added <kbd class="calibre16">ClassLoader</kbd> instances may themselves be hierarchical or they may be <strong class="calibre8">siblings</strong>. Either way, they are almost certainly children of the application <kbd class="calibre16">ClassLoader</kbd>.</p>
<p class="mce-root">A full treatment of classloaders and all that they entail is well beyond the scope of this book, but suffice it to say that we can create a new <kbd class="calibre16">ClassLoader</kbd> to allow the application to find the classes and resources in our <strong class="calibre8">plugin</strong> jars. To do this, we need to add a few methods--three to be exact--to our application class, Sunago. We'll start with the constructor:</p>
<pre class="calibre21">    public Sunago() throws Exception { 
      super(); 
      updateClassLoader(); 
    } </pre>
<p class="mce-root">Typically (though not always), when a JavaFX application starts, the <kbd class="calibre16">public static void main</kbd> method is run, which calls the <kbd class="calibre16">launch()</kbd> static method on the <kbd class="calibre16">Application</kbd> class, which we subclass. According to the Javadoc for <kbd class="calibre16">javafx.application.Application</kbd>, the JavaFX runtime performs the following steps when starting an application:</p>
<ol class="calibre18">
<li class="chapter">Constructs an instance of the specified <kbd class="calibre16">Application</kbd> class.</li>
<li class="chapter">Calls the <kbd class="calibre16">init()</kbd> method.</li>
<li class="chapter">Calls the <kbd class="calibre16">start(javafx.stage.Stage)</kbd> method.</li>
<li class="chapter">Waits for the application to finish, which happens when any of the following occur:
<ol class="calibre18">
<li class="chapter">The application calls <kbd class="calibre16">Platform.exit()</kbd>.</li>
<li class="chapter">The last window has been closed, and the <kbd class="calibre16">implicitExit</kbd> attribute on platform is true.</li>
</ol>
</li>
<li class="chapter">Calls the <kbd class="calibre16">stop()</kbd> method.</li>
</ol>
<p class="mce-root">We want to perform our <kbd class="calibre16">ClassLoader</kbd> work at step 1, in the constructor of our <kbd class="calibre16">Application</kbd>, to make sure that everything that follows has an up-to-date <kbd class="calibre16">ClassLoader</kbd>. That work is done in the second method that we need to add, which is this:</p>
<pre class="calibre21">    private void updateClassLoader() { 
      final File[] jars = getFiles(); 
      if (jars != null) { 
        URL[] urls = new URL[jars.length]; 
        int index = 0; 
        for (File jar : jars) { 
          try { 
            urls[index] = jar.toURI().toURL(); 
            index++; 
          } catch (MalformedURLException ex) { 
              Logger.getLogger(Sunago.class.getName()) 
               .log(Level.SEVERE, null, ex); 
            } 
        } 
        Thread.currentThread().setContextClassLoader( 
          URLClassLoader.newInstance(urls)); 
      } 
    } </pre>
<p class="mce-root">We start by getting a list of the jar files (we'll see that code in a moment), then, if the array is non-null, we need to build an array of <kbd class="calibre16">URL</kbd>s, so, we iterate over the <kbd class="calibre16">File</kbd> array, and call <kbd class="calibre16">.toURI().toURL()</kbd> to do so. Once we have our <kbd class="calibre16">URL</kbd> array we create a new <kbd class="calibre16">ClassLoader</kbd> (<kbd class="calibre16">URLClassLoader.newInstance(urls)</kbd>), then set the <kbd class="calibre16">ClassLoader</kbd> for the current Thread via <kbd class="calibre16">Thread.currentThread().setContextClassLoader()</kbd>.</p>
<p class="mce-root">This is our final additional method <kbd class="calibre16">getFiles()</kbd>:</p>
<pre class="calibre21">    private File[] getFiles() { 
      String pluginDir = System.getProperty("user.home")  
       + "/.sunago"; 
      return new File(pluginDir).listFiles(file -&gt; file.isFile() &amp;&amp;  
       file.getName().toLowerCase().endsWith(".jar")); 
    } </pre>
<p class="mce-root">This last method simply scans the files in <kbd class="calibre16">$HOME/.sunago</kbd>, looking for a file that ends with <kbd class="calibre16">.jar</kbd>. A list of zero or more jar files is returned to our calling code for inclusion in the new <kbd class="calibre16">ClassLoader</kbd>, and our work is done.</p>
<p class="mce-root">So there you have two ways of adding plugin jars to the runtime dynamically. Each has its strengths and weaknesses. The first requires multi-platform development and maintenance, while the second is a bit riskier, as classloaders can be tricky. I have tested the second approach on Windows and Linux and Java 8 and 9 with no errors detected. Which approach you use will, of course, depend on your unique environment and requirements, but you have at least two options with which to start your evaluation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With all of that said, our application is complete. Of course, hardly any software is truly complete, and there's much more that could be done to Sunago. Twitter support could be expanded to include direct messages. The Instagram module needs some configuration options added. While the capabilities exposed via the Facebook API are limiting, some sort of meaningful Facebook integration could be added. Sunago itself could be modified to, say, add support for in-application viewing of social media content (as opposed to shelling out to the host operating system's default browser). There are a handful of minor user experience bugs that could be addressed. And the list can go on and on. What we do have, though, is a moderately complex, networked application, that demonstrates a number of features and capabilities of the Java platform. We've built an extensible, internationalized JavaFX application that demonstrates the use of the Service Provider Interface and <kbd class="calibre16">ClassLoader</kbd> magic, and offers many more examples of lambdas, stream operations, and functional interfaces.</p>
<p class="mce-root">In the next chapter, we're going to build on the ideas presented here, and build an Android port of Sunago so that we can take our social media aggregation on-the-go with us.</p>


            </article>

            
        </section>
    </div>



  </body></html>