["```java\nval buyBait: String => Option[Bait]\nval makeBait: String => Option[Bait]\nval castLine: Bait => Option[Line]\nval hookFish: Line => Option[Fish]\n\ndef goFishing(bestBaitForFish: Option[String]): Option[Fish] =\n  for {\n    baitName <- bestBaitForFish\n    bait <- buyBait(baitName).orElse(makeBait(baitName))\n    line <- castLine(bait)\n    fish <- hookFish(line)\n  } yield fish\n```", "```java\ndef goFishing[M[_]: Monad](bestBaitForFish: M[String]): M[Fish] = {\n\n  val buyBait: String => M[Bait] = ???\n  val castLine: Bait => M[Line] = ???\n  val hookFish: Line => M[Fish] = ???\n\n  import Monad.lowPriorityImplicits._\n\n  for {\n    baitName <- bestBaitForFish\n    bait <- buyBait(baitName)\n    line <- castLine(bait)\n    fish <- hookFish(line)\n  } yield fish\n}\nCh10.goFishing(Option(\"Crankbait\"))\n```", "```java\nval buyBait: String => Future[Bait]\nval hookFish: Line => Future[Fish]\n```", "```java\ndef goFishing[M[_]: Monad, N[_]: Monad](bestBaitForFish: M[String]): N[Fish] = {\n\n  val buyBait: String => N[Bait] = ???\n  val castLine: Bait => M[Line] = ???\n  val hookFish: Line => N[Fish] = ???\n\n  // ... the rest goes as before\n}\nimport scala.concurrent.ExecutionContext.Implicits.global\nCh10.goFishing[Option, Future](Option(\"Crankbait\"))\n```", "```java\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\n\nscala> for {\n     | o <- Option(\"str\")\n     | c <- Future.successful(o)\n     | } yield c\n           c <- Future.successful(o)\n             ^\nOn line 3: error: type mismatch;\n        found : scala.concurrent.Future[String]\n        required: Option[?]\n```", "```java\nOption(\"str\").flatMap { o: String =>\n  val f: Future[String] = Future(o).map { c: String => c }\n  f\n}\n```", "```java\nfor {\n  baitName <- bestBaitForFish\n} yield for {\n  bait <- buyBait(baitName)\n} yield for {\n  line <- castLine(bait)\n} yield for {\n  fish <- hookFish(line)\n} yield fish\n```", "```java\ndef goFishing(bestBaitForFish: Option[String]): Future[Fish] =\n  bestBaitForFish match {\n    case None => Future.failed(new NoSuchElementException)\n    case Some(name) => buyBait(name).flatMap { bait: Bait =>\n      castLine(bait) match {\n        case None => Future.failed(new IllegalStateException)\n        case Some(line) => hookFish(line)\n      }\n    }\n  }\n```", "```java\nval buyBaitFO: String => Future[Option[Bait]] = (name: String) => buyBait(name).map(Option.apply)\nval castLineFO: Bait => Future[Option[Line]] = castLine.andThen(Future.successful)\nval hookFishFO: Line => Future[Option[Fish]] = (line: Line) => hookFish(line).map(Option.apply)\n```", "```java\ndef goFishing(bestBaitForFish: Future[Option[String]]): Future[Option[Fish]] = ???\n```", "```java\nbestBaitForFish.flatMap { /* takes Option[?] and returns Future[Option[?]] */ }\n```", "```java\ncase None => Future.successful(Option.empty[Fish])\ncase Some(name) => buyBaitFO(name) /* now what ? */\n```", "```java\ndef goFishingA(bestBaitForFish: Future[Option[String]]): Future[Option[Fish]] =\n  bestBaitForFish.flatMap {\n    case None => Future.successful(Option.empty[Fish])\n    case Some(name) => buyBaitFO(name).flatMap {\n      case None => Future.successful(Option.empty[Fish])\n      case Some(bait) => castLineFO(bait).flatMap {\n        case None => Future.successful(Option.empty[Fish])\n        case Some(line) => hookFishFO(line)\n      }\n    }\n  }\n```", "```java\ndef noResult[T]: Future[Option[T]] = Future.successful(Option.empty[T])\n```", "```java\ndef continue[A, B](arg: Future[Option[A]])(f: A => Future[Option[B]]): Future[Option[B]] =\n  arg.flatMap {\n    case None => noResult[B]\n    case Some(a) => f(a)\n  }\n```", "```java\ndef goFishing(bestBaitForFish: Future[Option[String]]): Future[Option[Fish]] =\n  continue(bestBaitForFish) { name =>\n    continue(buyBaitFO(name)) { bait =>\n      continue(castLineFO(bait)) { line =>\n        hookFishFO(line)\n      }\n    }\n  }\n```", "```java\nfinal case class FutureOption[A](value: Future[Option[A]]) {\n  def continue[B](f: A => FutureOption[B]): FutureOption[B] = new FutureOption(value.flatMap {\n    case None => noResult[B]\n    case Some(a) => f(a).value\n  })\n}\n```", "```java\nimplicit class FutureOption[A](value: Future[Option[A]]) {\n  def compose[B](f: A => FutureOption[B]): FutureOption[B] = new FutureOption(value.flatMap {\n    case None => noResult[B]\n    case Some(a) => f(a).value\n  })\n}\n```", "```java\ndef goFishing(bestBaitForFish: Future[Option[String]]): Future[Option[Fish]] = {\n  val result = bestBaitForFish.compose { name =>\n    buyBaitFO(name).compose { bait =>\n      castLineFO(bait).compose { line =>\n        hookFishFO(line)\n      }\n    }\n  }\n  result.value\n}\n```", "```java\nimplicit class FOption[F[_]: Monad, A](val value: F[Option[A]]) {\n  def compose[B](f: A => FOption[F, B]): FOption[F, B] = {\n    val result = value.flatMap {\n      case None => noResultF[F, B]\n      case Some(a) => f(a).value\n    }\n    new FOption(result)\n  }\n  def isEmpty: F[Boolean] = Monad[F].map(value)(_.isEmpty)\n}\n```", "```java\nimplicit def fOptionMonad[F[_] : Monad] = new Monad[FOption[F, ?]] {\n  override def unit[A](a: => A): FOption[F, A] = Monad[F].unit(Monad[Option].unit(a))\n  override def flatMap[A, B](a: FOption[F, A])(f: A => FOption[F, B]): FOption[F, B] =\n    a.compose(f)\n}\n```", "```java\nval buyBaitFO: String => FOption[Future, Bait] = // as before\nval castLineFO: Bait => FOption[Future, Line] = // as before\nval hookFishFO: Line => FOption[Future, Fish] = // as before\n```", "```java\ndef goFishing(bestBaitForFish: FOption[Future, String]): FOption[Future, Fish] = for {\n  name <- bestBaitForFish\n  bait <- buyBaitFO(name)\n  line <- castLineFO(bait)\n  fish <- hookFishFO(line)\n} yield fish\n```", "```java\nabstract class FishingApi[F[_]: Monad] {\n\n  val buyBait: String => F[Bait]\n  val castLine: Bait => F[Line]\n  val hookFish: Line => F[Fish]\n\n  def goFishing(bestBaitForFish: F[String]): F[Fish] = for {\n    name <- bestBaitForFish\n    bait <- buyBait(name)\n    line <- castLine(bait)\n    fish <- hookFish(line)\n  } yield fish\n}\n```", "```java\nimport Transformers.OptionTMonad\nimport ch09.Monad.futureMonad\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// we need to fix the types first to be able to implement concrete fucntions\nobject Ch10 {\n  type Bait = String\n  type Line = String\n  type Fish = String\n}\n\nobject Ch10FutureFishing extends FishingApi[OptionT[Future, ?]] with App {\n\n  val buyBaitImpl: String => Future[Bait] = Future.successful\n  val castLineImpl: Bait => Option[Line] = Option.apply\n  val hookFishImpl: Line => Future[Fish] = Future.successful\n\n  override val buyBait: String => OptionT[Future, Bait] = \n    (name: String) => buyBaitImpl(name).map(Option.apply)\n  override val castLine: Bait => OptionT[Future, Line] = \n    castLineImpl.andThen(Future.successful(_))\n  override val hookFish: Line => OptionT[Future, Fish] = \n    (line: Line) => hookFishImpl(line).map(Option.apply)\n\n  goFishing(Transformers.optionTunit[Future, String](\"Crankbait\"))\n}\n```", "```java\nimport scala.util._\nobject Ch10OptionTTryFishing extends FishingApi[OptionT[Try, ?]] with App {\n\n  val buyBaitImpl: String => Try[Bait] = Success.apply\n  val castLineImpl: Bait => Option[Line] = Option.apply\n  val hookFishImpl: Line => Try[Fish] = Success.apply\n\n  override val buyBait: String => OptionT[Try, Bait] = \n    (name: String) => buyBaitImpl(name).map(Option.apply)\n  override val castLine: Bait => OptionT[Try, Line] = \n    castLineImpl.andThen(Try.apply(_))\n  override val hookFish: Line => OptionT[Try, Fish] = \n    (line: Line) => hookFishImpl(line).map(Option.apply)\n\n  goFishingM(Transformers.optionTunit[Try, String](\"Crankbait\"))\n\n}\n```", "```java\nobject Ch10EitherTFutureFishing extends FishingApi[EitherT[Future, String, ?]] with App {\n\n  val buyBaitImpl: String => Future[Bait] = Future.successful\n  val castLineImpl: Bait => Either[String, Line] = Right.apply\n  val hookFishImpl: Line => Future[Fish] = Future.successful\n\n  override val buyBait: String => EitherT[Future, String, Bait] =\n    (name: String) => buyBaitImpl(name).map(l => Right(l): Either[String, Bait])\n  override val castLine: Bait => EitherT[Future, String, Line] =\n    castLineImpl.andThen(Future.successful(_))\n  override val hookFish: Line => EitherT[Future, String, Fish] =\n    (line: Line) => hookFishImpl(line).map(l => Right(l): Either[String, Fish])\n\n  goFishing(Transformers.eitherTunit[Future, String, String](\"Crankbait\")).value\n\n}\n```", "```java\nimplicit class EitherT[F[_]: Monad, L, A](val value: F[Either[L, A]]) {\n  def compose[B](f: A => EitherT[F, L, B]): EitherT[F, L, B] = {\n    val result: F[Either[L, B]] = value.flatMap {\n      case Left(l) => Monad[F].unit(Left[L, B](l))\n      case Right(a) => f(a).value\n    }\n    new EitherT(result)\n  }\n  def isRight: F[Boolean] = Monad[F].map(value)(_.isRight)\n}\n```", "```java\ndef eitherTunit[F[_]: Monad, L, A](a: => A) = new EitherT[F, L, A](Monad[F].unit(Right(a)))\n\nimplicit def EitherTMonad[F[_] : Monad, L]: Monad[EitherT[F, L, ?]] = \n  new Monad[EitherT[F, L, ?]] {\n    override def unit[A](a: => A): EitherT[F, L, A] =\n      Monad[F].unit(ch09.Monad.eitherMonad[L].unit(a))\n    override def flatMap[A, B](a: EitherT[F, L, A])(f: A => EitherT[F, L, B]): EitherT[F, L, B] =\n      a.compose(f)\n}\n```", "```java\nFuture[Either[String, Option[Fish]]]\n```", "```java\ntype Inner[A] = EitherT[Future, String, A]\n```", "```java\ntype Outer[F[_], A] = OptionT[F, A]\n```", "```java\ntype Stack[A] = Outer[Inner, A]\n```", "```java\noverride val buyBait: String => Stack[Bait] =\n  (name: String) => new EitherT(buyBaitImpl(name).map(l => Right(Option(l)): Either[String, Option[Bait]]))\n\noverride val hookFish: Line => Stack[Fish] =\n  (line: Line) => new EitherT(hookFishImpl(line).map(l => Right(Option(l)): Either[String, Option[Fish]]))\n```", "```java\noverride val castLine: Bait => Stack[Line] =\n  (bait: Bait) => new EitherT(Future.successful(castLineImpl(bait).map(Option.apply)))\n```", "```java\nval input = optionTunit[Inner, String](\"Crankbait\")\n```", "```java\nval outerResult: Inner[Option[Fish]] = goFishing(input).value\nval innerResult: Future[Either[String, Option[Fish]]] = outerResult.value\n```", "```java\ncase class Bait(name: String) extends AnyVal\ncase class Line(length: Int) extends AnyVal\ncase class Fish(name: String) extends AnyVal\n\nsealed trait Action[A]\nfinal case class BuyBait[A](name: String, f: Bait => A) extends Action[A]\nfinal case class CastLine[A](bait: Bait, f: Line => A) extends Action[A]\nfinal case class HookFish[A](line: Line, f: Fish => A) extends Action[A]\n```", "```java\nfinal case class Done[F[_]: Functor, A](a: A) extends Free[F, A]\n```", "```java\nfinal case class Suspend[F[_]: Functor, A](action: F[Free[F, A]]) extends Free[F, A]\n```", "```java\nclass Free[F[_]: Functor, A] {\n  def flatMap[B](f: A => Free[F, B]): Free[F, B] = this match {\n    case Done(a) => f(a)\n    case Join(a) => Join(implicitly[Functor[F]].map(a)(_.flatMap(f)))\n  }\n}\n```", "```java\nimplicit val actionFunctor: Functor[Action] = new Functor[Action] {\n  override def map[A, B](in: Action[A])(f: A => B): Action[B] = in match {\n    case BuyBait(name, a) => BuyBait(name, x => f(a(x)))\n    case CastLine(bait, a) => CastLine(bait, x => f(a(x)))\n    case HookFish(line, a) => HookFish(line, x => f(a(x)))\n  }\n}\n```", "```java\ndef buyBait(name: String): Free[Action, Bait] = Join(BuyBait(name, bait => Done(bait)))\ndef castLine(bait: Bait): Free[Action, Line] = Join(CastLine(bait, line => Done(line)))\ndef hookFish(line: Line): Free[Action, Fish] = Join(HookFish(line, fish => Done(fish)))\n```", "```java\ndef catchFish(baitName: String): Free[Action, Fish] = for {\n  bait <- buyBait(baitName)\n  line <- castLine(bait)\n  fish <- hookFish(line)\n} yield fish\n```", "```java\nJoin(BuyBait(\"Crankbait\", Join(CastLine(bait, Join(HookFish(line, Done(fish)))))))\n```", "```java\n@tailrec\ndef goFishingAcc[A](actions: Free[Action, A], log: List[AnyVal]): List[AnyVal] = actions match {\n  case Join(BuyBait(name, f)) =>\n    val bait = Bait(name)\n    goFishingAcc(f(bait), bait :: log)\n  case Join(CastLine(bait, f)) =>\n    val line = Line(bait.name.length)\n    goFishingAcc(f(line), line :: log)\n  case Join(HookFish(line, f)) =>\n    val fish = Fish(s\"CatFish from ($line)\")\n    goFishingAcc(f(fish), fish :: log)\n  case Done(_) => log.reverse\n}\n```", "```java\nscala> import ch10.FreeMonad._\nimport ch10.FreeMonad._\nscala> println(goFishingAcc(catchFish(\"Crankbait\"), Nil))\nList(Bait(Crankbait), Line(9), Fish(CatFish from (Line(9))))\n```", "```java\ndef log[A](a: A): Unit = println(a)\n\n@scala.annotation.tailrec\ndef goFishingLogging[A](actions: Free[Action, A], unit: Unit): A = actions match {\n  case Join(BuyBait(name, f)) =>\n    goFishingLogging(f(Bait(name)), log(s\"Buying bait $name\"))\n  case Join(CastLine(bait, f)) =>\n    goFishingLogging(f(Line(bait.name.length)), log(s\"Casting line with ${bait.name}\"))\n  case Join(HookFish(line, f)) =>\n    goFishingLogging(f(Fish(\"CatFish\")), log(s\"Hooking fish from ${line.length} feet\"))\n  case Done(fish) => fish\n}\n```", "```java\nscala> println(goFishingLogging(catchFish(\"Crankbait\"), ()))\nBuying bait Crankbait\nCasting line with Crankbait\nHooking fish from 9 feet\nFish(CatFish)\n```"]