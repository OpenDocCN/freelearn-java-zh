<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 9. Concurrency in Practice"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/><span class="koboSpan" id="kobo.1.1">Chapter 9. Concurrency in Practice</span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">"The best theory is inspired by practice."</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Donald Knuth</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">We have studied a plethora of different concurrency facilities in this book. </span><span class="koboSpan" id="kobo.8.2">By now, you will have learned about dozens of different ways of starting concurrent computations and accessing shared data. </span><span class="koboSpan" id="kobo.8.3">Knowing how to use different styles of concurrency is useful, but it might not yet be obvious when to use which.</span></p><p><span class="koboSpan" id="kobo.9.1">The goal of this final chapter is to introduce the big picture of concurrent programming. </span><span class="koboSpan" id="kobo.9.2">We will study the use cases for various concurrency abstractions, see how to debug concurrent programs, and how to integrate different concurrency libraries in larger applications. </span><span class="koboSpan" id="kobo.9.3">In this chapter, we will perform the following tasks:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.10.1">Summarize the characteristics and typical uses of different concurrency frameworks introduced in the earlier chapters</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.11.1">Investigate how to deal with various kinds of bugs appearing in concurrent applications</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.12.1">Learn how to identify and resolve performance bottlenecks</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.13.1">Apply the previous knowledge about concurrency to implement a larger concurrent application, namely, a remote file browser</span></li></ul></div><p><span class="koboSpan" id="kobo.14.1">We start with an overview of the important concurrency frameworks we have learned about in this book, and a summary of when to use each of them.</span></p><div class="section" title="Choosing the right tools for the job"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec59"/><span class="koboSpan" id="kobo.15.1">Choosing the right tools for the job</span></h1></div></div></div><p><span class="koboSpan" id="kobo.16.1">In this section, we present an overview of the different concurrency libraries that we learned about. </span><span class="koboSpan" id="kobo.16.2">We take a step back and look at the differences between these libraries, and what they have in common. </span><span class="koboSpan" id="kobo.16.3">This summary will give us an insight into what different concurrency abstractions are useful for.</span></p><p><span class="koboSpan" id="kobo.17.1">A concurrency framework usually needs to address several concerns:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.18.1">It must provide a way to declare data that is shared between concurrent executions</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.19.1">It must provide constructs for reading and modifying program data</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.20.1">It must be able to express conditional execution, triggered when a certain set of conditions are fulfilled</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.21.1">It must define a way to start concurrent executions</span></li></ul></div><p><span class="koboSpan" id="kobo.22.1">Some of the frameworks from this book address all these concerns; others address only a subset, and transfer part of the responsibility to another framework.</span></p><p><span class="koboSpan" id="kobo.23.1">Typically, in a concurrent programming model, we express concurrently shared data differently from data intended to be accessed only from a single thread. </span><span class="koboSpan" id="kobo.23.2">This allows the JVM runtime to optimize sequential parts of the program more effectively. </span><span class="koboSpan" id="kobo.23.3">So far, we've seen a lot of different ways to express concurrently shared data, ranging from the low-level facilities to advanced high-level abstractions. </span><span class="koboSpan" id="kobo.23.4">We summarize different data abstractions in the following table:</span></p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.24.1">Data abstraction</span></strong></span></p>
</th><th>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">Datatype or annotation</span></strong></span></p>
</th><th>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.26.1">Description</span></strong></span></p>
</th></tr></thead><tbody><tr><td>
<p><span class="koboSpan" id="kobo.27.1">Volatile variables</span></p><p>
</p><p><span class="koboSpan" id="kobo.28.1">(JDK)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.29.1">@volatile</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.30.1">Ensures visibility and the happens-before relationship on class fields and local variables that are captured in closures.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.31.1">Atomic variables</span></p><p>
</p><p><span class="koboSpan" id="kobo.32.1">(JDK)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.33.1">AtomicReference[T]</span></p><p>
</p><p><span class="koboSpan" id="kobo.34.1">AtomicInteger</span></p><p>
</p><p><span class="koboSpan" id="kobo.35.1">AtomicLong</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.36.1">Provide basic composite atomic operations, such as </span><span class="strong"><strong>
<code class="literal"><span class="koboSpan" id="kobo.37.1">compareAndSet</span></code>
</strong></span><span class="koboSpan" id="kobo.38.1"> and </span><span class="strong"><strong>
<code class="literal"><span class="koboSpan" id="kobo.39.1">incrementAndGet</span></code>
</strong></span><span class="koboSpan" id="kobo.40.1">.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.41.1">Futures and promises</span></p><p>
</p><p><span class="koboSpan" id="kobo.42.1">(</span><span class="strong"><strong>
<code class="literal"><span class="koboSpan" id="kobo.43.1">scala.concurrent</span></code>
</strong></span><span class="koboSpan" id="kobo.44.1">)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.45.1">Future[T]</span></p><p>
</p><p><span class="koboSpan" id="kobo.46.1">Promise[T]</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.47.1">Sometimes called single-assignment variables, these express values that might not be computed yet but will eventually become available.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.48.1">Observables and subjects</span></p><p>
</p><p><span class="koboSpan" id="kobo.49.1">(Rx)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.50.1">Observable[T]</span></p><p>
</p><p><span class="koboSpan" id="kobo.51.1">Subject[T]</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.52.1">Also known as first-class event streams, these describe many different values that arrive one after another in time.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.53.1">Transactional references</span></p><p>
</p><p><span class="koboSpan" id="kobo.54.1">(ScalaSTM)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.55.1">Ref[T]</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.56.1">These describe memory locations that can only be accessed from within memory transactions. </span><span class="koboSpan" id="kobo.56.2">Their modifications only become visible after the transaction successfully commits.</span></p>
</td></tr></tbody></table></div><p><span class="koboSpan" id="kobo.57.1">The next important concern is providing access to shared data, which includes reading and modifying shared memory locations. </span><span class="koboSpan" id="kobo.57.2">Usually, a concurrent program uses special constructs to express such accesses. </span><span class="koboSpan" id="kobo.57.3">We summarize the different data access constructs in the following table:</span></p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.58.1">Data abstraction</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.59.1">Data access constructs</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.60.1">Description</span></strong></span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.61.1">Arbitrary data</span></p><p>
</p><p><span class="koboSpan" id="kobo.62.1">(JDK)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.63.1">synchronized</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.64.1">Uses intrinsic object locks to exclude access to arbitrary shared data.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.65.1">Atomic variables and classes</span></p><p>
</p><p><span class="koboSpan" id="kobo.66.1">(JDK)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.67.1">compareAndSet</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.68.1">Atomically exchanges the value of a single memory location. </span><span class="koboSpan" id="kobo.68.2">It allows implementing lock-free programs.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.69.1">Futures and promises</span></p><p>
</p><p><span class="koboSpan" id="kobo.70.1">(</span><span class="strong"><strong>
<code class="literal"><span class="koboSpan" id="kobo.71.1">scala.concurrent</span></code>
</strong></span><span class="koboSpan" id="kobo.72.1">)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.73.1">value</span></p><p>
</p><p><span class="koboSpan" id="kobo.74.1">tryComplete</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.75.1">Used to assign a value to a promise, or to check the value of the corresponding future. </span><span class="koboSpan" id="kobo.75.2">The </span><span class="strong"><strong>
<code class="literal"><span class="koboSpan" id="kobo.76.1">value</span></code>
</strong></span><span class="koboSpan" id="kobo.77.1"> method is not a preferred way to interact with a future.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.78.1">Transactional references and classes</span></p><p>
</p><p><span class="koboSpan" id="kobo.79.1">(Scala STM)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.80.1">atomic</span></p><p>
</p><p><span class="koboSpan" id="kobo.81.1">orAtomic</span></p><p>
</p><p><span class="koboSpan" id="kobo.82.1">single</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.83.1">Atomically modifies the values of a set of memory locations. </span><span class="koboSpan" id="kobo.83.2">Reduces the risk of deadlocks, but disallows side effects inside the transactional block.</span></p>
</td></tr></tbody></table></div><p><span class="koboSpan" id="kobo.84.1">Concurrent data access is not the only concern of a concurrency framework. </span><span class="koboSpan" id="kobo.84.2">As we have learned in previous chapters, concurrent computations sometimes need to proceed only after a certain condition is met. </span><span class="koboSpan" id="kobo.84.3">In the following table, we summarize different constructs that enable this:</span></p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.85.1">Concurrency framework</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.86.1">Conditional execution constructs</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.87.1">Description</span></strong></span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.88.1">JVM concurrency</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.89.1">wait</span></p><p>
</p><p><span class="koboSpan" id="kobo.90.1">notify</span></p><p>
</p><p><span class="koboSpan" id="kobo.91.1">notifyAll</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.92.1">Used to suspend the execution of a thread until some other thread notifies that the conditions are met.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.93.1">Futures and promises</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.94.1">onComplete</span></p><p>
</p><p><span class="koboSpan" id="kobo.95.1">Await.ready</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.96.1">Conditionally schedules an asynchronous computation. </span><span class="koboSpan" id="kobo.96.2">The </span><span class="strong"><strong>
<code class="literal"><span class="koboSpan" id="kobo.97.1">Await.ready</span></code>
</strong></span><span class="koboSpan" id="kobo.98.1"> method suspends the thread until the future completes.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.99.1">Reactive extensions</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.100.1">subscribe</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.101.1">Asynchronously or synchronously executes a computation when an event arrives.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.102.1">Software transactional memory</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.103.1">retry</span></p><p>
</p><p><span class="koboSpan" id="kobo.104.1">retryFor</span></p><p>
</p><p><span class="koboSpan" id="kobo.105.1">withRetryTimeout</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.106.1">Retries the current memory transaction when some of the relevant memory locations change.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.107.1">Actors</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.108.1">receive</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.109.1">Executes the actor's </span><span class="strong"><strong>
<code class="literal"><span class="koboSpan" id="kobo.110.1">receive</span></code>
</strong></span><span class="koboSpan" id="kobo.111.1"> block when a message arrives.</span></p>
</td></tr></tbody></table></div><p><span class="koboSpan" id="kobo.112.1">Finally, a concurrency model must define a way to start a concurrent execution. </span><span class="koboSpan" id="kobo.112.2">We summarize different concurrency constructs in the following table:</span></p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.113.1">Concurrency framework</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.114.1">Concurrency constructs</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.115.1">Description</span></strong></span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.116.1">JVM concurrency</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.117.1">Thread.start</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.118.1">Starts a new thread of execution.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.119.1">Execution contexts</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.120.1">execute</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.121.1">Schedules a block of code for execution on a thread pool.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.122.1">Futures and promises</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.123.1">Future.apply</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.124.1">Schedules a block of code for execution, and returns the future value with the result of the execution.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.125.1">Parallel collections</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.126.1">par</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.127.1">Allows invoking data-parallel versions of collection methods.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.128.1">Reactive extensions</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.129.1">Observable.create</span></p><p>
</p><p><span class="koboSpan" id="kobo.130.1">observeOn</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.131.1">The </span><span class="strong"><strong>
<code class="literal"><span class="koboSpan" id="kobo.132.1">create</span></code>
</strong></span><span class="koboSpan" id="kobo.133.1"> method defines an event source. </span><span class="koboSpan" id="kobo.133.2">The </span><span class="strong"><strong>
<code class="literal"><span class="koboSpan" id="kobo.134.1">observeOn</span></code>
</strong></span><span class="koboSpan" id="kobo.135.1"> method schedules the handling of events on different threads.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.136.1">Actors</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.137.1">actorOf</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.138.1">Schedules a new actor object for execution.</span></p>
</td></tr></tbody></table></div><p><span class="koboSpan" id="kobo.139.1">This breakdown shows us that different concurrency libraries focus on different tasks. </span><span class="koboSpan" id="kobo.139.2">For example, parallel collections do not have conditional waiting constructs, because a data-parallel operation proceeds on separate elements independently. </span><span class="koboSpan" id="kobo.139.3">Similarly, software transactional memory does not come with a construct to express concurrent computations, and focuses only on protecting access to shared data. </span><span class="koboSpan" id="kobo.139.4">Actors do not have special constructs for modeling shared data and protecting access to it, because data is encapsulated within separate actors and accessed serially only by the actor that owns it.</span></p><p><span class="koboSpan" id="kobo.140.1">Having classified concurrency libraries according to how they model shared data and express concurrency, we present a summary of what different concurrency libraries are good for:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.141.1">The classical JVM concurrency model uses threads, the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">synchronized</span></code><span class="koboSpan" id="kobo.143.1"> statement, volatile variables, and atomic primitives for low-level tasks. </span><span class="koboSpan" id="kobo.143.2">Uses include implementing a custom concurrency utility, a concurrent data structure, or a concurrency framework optimized for specific tasks.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.144.1">Futures and promises are best suited for referring to concurrent computations that produce a single result value. </span><span class="koboSpan" id="kobo.144.2">Futures model latency in the program, and allow composing values that become available later during the execution of the program. </span><span class="koboSpan" id="kobo.144.3">Uses include performing remote network requests and waiting for replies, referring to the result of an asynchronous long-running computation, or reacting to the completion of an I/O operation. </span><span class="koboSpan" id="kobo.144.4">Futures are usually the glue of a concurrent application, binding the different parts of a concurrent program together. </span><span class="koboSpan" id="kobo.144.5">We often use futures to convert single-event callback APIs into a standardized representation based on the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">Future</span></code><span class="koboSpan" id="kobo.146.1"> type.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.147.1">Parallel collections are best suited for efficiently executing data-parallel operations on large datasets. </span><span class="koboSpan" id="kobo.147.2">Uses include file searching, text processing, linear algebra applications, numerical computations, and simulations. </span><span class="koboSpan" id="kobo.147.3">Long-running Scala collection operations are usually good candidates for parallelization.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.148.1">Reactive extensions are used to express asynchronous event-based programs. </span><span class="koboSpan" id="kobo.148.2">Unlike parallel collections, in reactive extensions, data elements are not available when the operation starts, but arrive while the application is running. </span><span class="koboSpan" id="kobo.148.3">Uses include converting callback-based APIs, modeling events in user interfaces, modeling events external to the application, manipulating program events with collection-style combinators, streaming data from input devices or remote locations, or incrementally propagating changes in the data model throughout the program.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.149.1">Use STM to protect program data from getting corrupted by concurrent accesses. </span><span class="koboSpan" id="kobo.149.2">An STM allows building complex data models and accessing them with the reduced risk of deadlocks and race conditions. </span><span class="koboSpan" id="kobo.149.3">A typical use is to protect concurrently accessible data while retaining good scalability between threads whose accesses to data do not overlap.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.150.1">Actors are suitable for encapsulating concurrently accessible data, and seamlessly building distributed systems. </span><span class="koboSpan" id="kobo.150.2">Actor frameworks provide a natural way to express concurrent tasks that communicate by explicitly sending messages. </span><span class="koboSpan" id="kobo.150.3">Uses include serializing concurrent access to data to prevent corruption, expressing stateful concurrency units in the system, and building distributed applications such as trading systems, P2P networks, communication hubs, or data-mining frameworks.</span></li></ul></div><p><span class="koboSpan" id="kobo.151.1">Advocates of specific programming languages, libraries, or frameworks might try to convince you that their technology is the best for any task and any situation, often with the intent of selling it. </span><span class="koboSpan" id="kobo.151.2">Richard Stallman once said that "computer science is the only industry more fashion-driven than women's fashion." </span><span class="koboSpan" id="kobo.151.3">As engineers, we need to know better than to succumb to programming fashion and marketing propaganda. </span><span class="koboSpan" id="kobo.151.4">Different frameworks are tailored towards specific use cases, and the correct way to choose a technology is to carefully weigh its advantages and disadvantages when applied to a specific situation.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip100"/><span class="koboSpan" id="kobo.152.1">Tip</span></h3><p><span class="koboSpan" id="kobo.153.1">There is no one-size-fits-all technology. </span><span class="koboSpan" id="kobo.153.2">Use your own best judgment when deciding which concurrency framework to use for a specific programming task.</span></p></div></div><p><span class="koboSpan" id="kobo.154.1">Sometimes, choosing the best-suited concurrency utility is easier said than done. </span><span class="koboSpan" id="kobo.154.2">It takes a great deal of experience to choose the correct technology. </span><span class="koboSpan" id="kobo.154.3">In many cases, we do not even know enough about the requirements of the system to make an informed decision. </span><span class="koboSpan" id="kobo.154.4">Regardless, a good rule of thumb is to apply several concurrency frameworks to different parts of the same application, each best suited for a specific task. </span><span class="koboSpan" id="kobo.154.5">Often, the real power of different concurrency frameworks becomes apparent when they are used together. </span><span class="koboSpan" id="kobo.154.6">This is the topic we will cover in the following section.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Putting it all together - a remote file browser"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec60"/><span class="koboSpan" id="kobo.1.1">Putting it all together - a remote file browser</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this section, we use our knowledge about different concurrency frameworks to build a remote file browser. </span><span class="koboSpan" id="kobo.2.2">This larger application example illustrates how different concurrency libraries work together, and how to apply them to different situations. </span><span class="koboSpan" id="kobo.2.3">We will name our remote file browser ScalaFTP.</span></p><p><span class="koboSpan" id="kobo.3.1">The ScalaFTP browser is divided into two main components: the server and the client process. </span><span class="koboSpan" id="kobo.3.2">The server process will run on the machine whose filesystem we want to manipulate. </span><span class="koboSpan" id="kobo.3.3">The client will run on our own computer, and comprise of a graphical user interface used to navigate the remote filesystem. </span><span class="koboSpan" id="kobo.3.4">To keep things simple, the protocol that the client and the server will use to communicate will not really be FTP, but a custom communication protocol. </span><span class="koboSpan" id="kobo.3.5">By choosing the correct concurrency libraries to implement different parts of ScalaFTP, we will ensure that the complete ScalaFTP implementation fits inside just 500 lines of code.</span></p><p><span class="koboSpan" id="kobo.4.1">Specifically, the ScalaFTP browser will implement the following features:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Displaying the names of the files and the directories in a remote filesystem, and allowing navigation through the directory structure</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Copying files between directories in a remote filesystem</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Deleting files in a remote filesystem</span></li></ul></div><p><span class="koboSpan" id="kobo.8.1">To implement separate pieces of this functionality, we will divide the ScalaFTP server and client programs into layers. </span><span class="koboSpan" id="kobo.8.2">The task of the server program is to answer to incoming copy and delete requests, and to answer queries about the contents of specific directories. </span><span class="koboSpan" id="kobo.8.3">To make sure that its view of the filesystem is consistent, the server will cache the directory structure of the filesystem. </span><span class="koboSpan" id="kobo.8.4">We divide the server program into two layers: the filesystem API and the server interface. </span><span class="koboSpan" id="kobo.8.5">The filesystem API will expose the data model of the server program, and define useful utility methods to manipulate the filesystem. </span><span class="koboSpan" id="kobo.8.6">The server interface will receive requests and send responses back to the client.</span></p><p><span class="koboSpan" id="kobo.9.1">Since the server interface will require communicating with the remote client, we decide to use the Akka actor framework. </span><span class="koboSpan" id="kobo.9.2">Akka comes with remote communication facilities, as we learned in </span><a class="link" href="ch08.html" title="Chapter 8.  Actors"><span class="koboSpan" id="kobo.10.1">Chapter 8</span></a><span class="koboSpan" id="kobo.11.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.12.1">Actors</span></em></span><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">The contents of the filesystem, that is, its state, will change over time. </span><span class="koboSpan" id="kobo.13.3">We are therefore interested in choosing proper constructs for data access.</span></p><p><span class="koboSpan" id="kobo.14.1">In the filesystem API, we can use object monitors and locking to synchronize access to shared state, but we will avoid these due to the risk of deadlocks. </span><span class="koboSpan" id="kobo.14.2">We similarly avoid using atomic variables, because they are prone to race conditions. </span><span class="koboSpan" id="kobo.14.3">We could encapsulate the filesystem state within an actor, but note that this can lead to a scalability bottleneck: an actor would serialize all accesses to the filesystem state. </span><span class="koboSpan" id="kobo.14.4">Therefore, we decide to use the ScalaSTM framework to model the filesystem contents. </span><span class="koboSpan" id="kobo.14.5">An STM avoids the risk of deadlocks and race conditions, and ensures good horizontal scalability, as we learned in </span><a class="link" href="ch07.html" title="Chapter 7. Software Transactional Memory"><span class="koboSpan" id="kobo.15.1">Chapter 7</span></a><span class="koboSpan" id="kobo.16.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">Software Transactional Memory</span></em></span><span class="koboSpan" id="kobo.18.1">.</span></p><p><span class="koboSpan" id="kobo.19.1">The task of the client program will be to graphically present the contents of the remote filesystem, and communicate with the server. </span><span class="koboSpan" id="kobo.19.2">We divide the client program into three layers of functionality. </span><span class="koboSpan" id="kobo.19.3">The GUI layer will render the contents of the remote filesystem and register user requests, such as button clicks. </span><span class="koboSpan" id="kobo.19.4">We will implement the GUI using the Swing and Rx frameworks, similarly to how we implemented the web browser in </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.20.1">Chapter 6</span></a><span class="koboSpan" id="kobo.21.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.22.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">The client API will replicate the server interface on the client side and communicate with the server. </span><span class="koboSpan" id="kobo.23.3">We will use Akka to communicate with the server, but expose the results of remote operations as futures. </span><span class="koboSpan" id="kobo.23.4">Finally, the client logic will be a gluing layer, which binds the GUI and the client API together.</span></p><p><span class="koboSpan" id="kobo.24.1">The architecture of the ScalaFTP browser is illustrated in the following diagram, in which we indicate which concurrency libraries will be used by separate layers. </span><span class="koboSpan" id="kobo.24.2">The dashed line represents the communication path between the client and the server:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.25.1"><img src="graphics/image_09_001.jpg" alt="Putting it all together - a remote file browser"/></span></div><p><span class="koboSpan" id="kobo.26.1">We now start by implementing the ScalaFTP server, relying on the bottom-up design approach. </span><span class="koboSpan" id="kobo.26.2">In the following section, we will describe the internals of the filesystem API.</span></p><div class="section" title="Modeling the filesystem"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec80"/><span class="koboSpan" id="kobo.27.1">Modeling the filesystem</span></h2></div></div></div><p><span class="koboSpan" id="kobo.28.1">In </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.29.1">Chapter 3</span></a><span class="koboSpan" id="kobo.30.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.31.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.32.1">, we used atomic variables and concurrent collections to implement a non-blocking, thread-safe filesystem API, which allowed copying files and retrieving snapshots of the filesystem. </span><span class="koboSpan" id="kobo.32.2">In this section, we repeat this task using STM. </span><span class="koboSpan" id="kobo.32.3">We will see that it is much intuitive and less error-prone to use STM.</span></p><p><span class="koboSpan" id="kobo.33.1">We start by defining the different states that a file can be in. </span><span class="koboSpan" id="kobo.33.2">As in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.34.1">Chapter 3</span></a><span class="koboSpan" id="kobo.35.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.36.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.37.1">, the file can be currently created, in the idle state, being copied, or being deleted. </span><span class="koboSpan" id="kobo.37.2">We model this with a sealed </span><code class="literal"><span class="koboSpan" id="kobo.38.1">State</span></code><span class="koboSpan" id="kobo.39.1"> trait, and its four cases:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.40.1">sealed trait State 
case object Created extends State 
case object Idle extends State 
case class Copying(n: Int) extends State 
case object Deleted extends State 
</span></pre><p><span class="koboSpan" id="kobo.41.1">A file can only be deleted if it is in the idle state, and it can only be copied if it is in the idle state or in the copied state. </span><span class="koboSpan" id="kobo.41.2">Since a file can be copied to multiple destinations at a time, the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">Copying</span></code><span class="koboSpan" id="kobo.43.1"> state encodes how many copies are currently under way. </span><span class="koboSpan" id="kobo.43.2">We add the methods </span><code class="literal"><span class="koboSpan" id="kobo.44.1">inc</span></code><span class="koboSpan" id="kobo.45.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.46.1">dec</span></code><span class="koboSpan" id="kobo.47.1"> to the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">State</span></code><span class="koboSpan" id="kobo.49.1"> trait, which return a new state with one more or one fewer copy, respectively. </span><span class="koboSpan" id="kobo.49.2">For example, the implementation of </span><code class="literal"><span class="koboSpan" id="kobo.50.1">inc</span></code><span class="koboSpan" id="kobo.51.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.52.1">dec</span></code><span class="koboSpan" id="kobo.53.1"> for the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">Copying</span></code><span class="koboSpan" id="kobo.55.1"> state is as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.56.1">def inc: State = Copying(n + 1) 
def dec: State = if (n &gt; 1) Copying(n - 1) else Idle 
</span></pre><p><span class="koboSpan" id="kobo.57.1">Similar to the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">File</span></code><span class="koboSpan" id="kobo.59.1"> class in the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">java.io</span></code><span class="koboSpan" id="kobo.61.1"> package, we represent both the files and directories with the same entity, and refer to them more generally as files. </span><span class="koboSpan" id="kobo.61.2">Each file is represented by the </span><code class="literal"><span class="koboSpan" id="kobo.62.1">FileInfo</span></code><span class="koboSpan" id="kobo.63.1"> class that encodes the path, its name, its parent directory and the date of the last modification to the file, a Boolean value denoting if the file is a directory, the size of the file, and its </span><code class="literal"><span class="koboSpan" id="kobo.64.1">State</span></code><span class="koboSpan" id="kobo.65.1"> object. </span><span class="koboSpan" id="kobo.65.2">The </span><code class="literal"><span class="koboSpan" id="kobo.66.1">FileInfo</span></code><span class="koboSpan" id="kobo.67.1"> class is immutable, and updating the state of the file will require creating a fresh </span><code class="literal"><span class="koboSpan" id="kobo.68.1">FileInfo</span></code><span class="koboSpan" id="kobo.69.1"> object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.70.1">case class FileInfo(path: String, name: String, 
  parent: String, modified: String, isDir: Boolean, 
  size: Long, state: State) 
</span></pre><p><span class="koboSpan" id="kobo.71.1">We separately define the factory methods </span><code class="literal"><span class="koboSpan" id="kobo.72.1">apply</span></code><span class="koboSpan" id="kobo.73.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.74.1">creating</span></code><span class="koboSpan" id="kobo.75.1"> that take a </span><code class="literal"><span class="koboSpan" id="kobo.76.1">File</span></code><span class="koboSpan" id="kobo.77.1"> object and return a </span><code class="literal"><span class="koboSpan" id="kobo.78.1">FileInfo</span></code><span class="koboSpan" id="kobo.79.1"> object in the </span><code class="literal"><span class="koboSpan" id="kobo.80.1">Idle</span></code><span class="koboSpan" id="kobo.81.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.82.1">Created</span></code><span class="koboSpan" id="kobo.83.1"> state, respectively.</span></p><p><span class="koboSpan" id="kobo.84.1">Depending on where the server is started, the root of the ScalaFTP directory structure is a different subdirectory in the actual filesystem. </span><span class="koboSpan" id="kobo.84.2">A </span><code class="literal"><span class="koboSpan" id="kobo.85.1">FileSystem</span></code><span class="koboSpan" id="kobo.86.1"> object tracks the files in the given </span><code class="literal"><span class="koboSpan" id="kobo.87.1">rootpath</span></code><span class="koboSpan" id="kobo.88.1"> directory, using a transactional map called </span><code class="literal"><span class="koboSpan" id="kobo.89.1">files</span></code><span class="koboSpan" id="kobo.90.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.91.1">class FileSystem(val rootpath: String) { 
  val files = TMap[String, FileInfo]() 
} 
</span></pre><p><span class="koboSpan" id="kobo.92.1">We introduce a separate </span><code class="literal"><span class="koboSpan" id="kobo.93.1">init</span></code><span class="koboSpan" id="kobo.94.1"> method to initialize the </span><code class="literal"><span class="koboSpan" id="kobo.95.1">FileSystem</span></code><span class="koboSpan" id="kobo.96.1"> object. </span><span class="koboSpan" id="kobo.96.2">The </span><code class="literal"><span class="koboSpan" id="kobo.97.1">init</span></code><span class="koboSpan" id="kobo.98.1"> method starts a transaction, clears the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">files</span></code><span class="koboSpan" id="kobo.100.1"> map, and traverses the files and directories under </span><code class="literal"><span class="koboSpan" id="kobo.101.1">rootpath</span></code><span class="koboSpan" id="kobo.102.1"> using the Apache Commons IO library. </span><span class="koboSpan" id="kobo.102.2">For each file and directory, the </span><code class="literal"><span class="koboSpan" id="kobo.103.1">init</span></code><span class="koboSpan" id="kobo.104.1"> method creates a </span><code class="literal"><span class="koboSpan" id="kobo.105.1">FileInfo</span></code><span class="koboSpan" id="kobo.106.1"> object and adds it to the </span><code class="literal"><span class="koboSpan" id="kobo.107.1">files</span></code><span class="koboSpan" id="kobo.108.1"> map, using its path as the key:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.109.1">def init() = atomic { implicit txn =&gt; 
  files.clear() 
  val rootDir = new File(rootpath) 
  val all = TrueFileFilter.INSTANCE 
  val fileIterator = 
    FileUtils.iterateFilesAndDirs(rootDir, all, all).asScala 
  for (file &lt;- fileIterator) { 
    val info = FileInfo(file) 
    files(info.path) = info 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.110.1">Recall that the ScalaFTP browser must display the contents of the remote filesystem. </span><span class="koboSpan" id="kobo.110.2">To enable directory queries, we first add the </span><code class="literal"><span class="koboSpan" id="kobo.111.1">getFileList</span></code><span class="koboSpan" id="kobo.112.1"> method to the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">FileSystem</span></code><span class="koboSpan" id="kobo.114.1"> class, which retrieves the files in the specified </span><code class="literal"><span class="koboSpan" id="kobo.115.1">dir</span></code><span class="koboSpan" id="kobo.116.1"> directory. </span><span class="koboSpan" id="kobo.116.2">The </span><code class="literal"><span class="koboSpan" id="kobo.117.1">getFileList</span></code><span class="koboSpan" id="kobo.118.1"> method starts a transaction and filters the files whose direct parent is equal to </span><code class="literal"><span class="koboSpan" id="kobo.119.1">dir</span></code><span class="koboSpan" id="kobo.120.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.121.1">def getFileList(dir: String): Map[String, FileInfo] = 
  atomic { implicit txn =&gt; 
    files.filter(_._2.parent == dir) 
  } 
</span></pre><p><span class="koboSpan" id="kobo.122.1">We implement the copying logic in the filesystem API with the </span><code class="literal"><span class="koboSpan" id="kobo.123.1">copyFile</span></code><span class="koboSpan" id="kobo.124.1"> method. </span><span class="koboSpan" id="kobo.124.2">This method takes a path to the </span><code class="literal"><span class="koboSpan" id="kobo.125.1">src</span></code><span class="koboSpan" id="kobo.126.1"> source file and the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">dest</span></code><span class="koboSpan" id="kobo.128.1"> destination file, and starts a transaction. </span><span class="koboSpan" id="kobo.128.2">After checking whether the </span><code class="literal"><span class="koboSpan" id="kobo.129.1">dest</span></code><span class="koboSpan" id="kobo.130.1"> destination file exists or not, the </span><code class="literal"><span class="koboSpan" id="kobo.131.1">copyFile</span></code><span class="koboSpan" id="kobo.132.1"> method inspects the state of the source file entry, and fails unless the state is </span><code class="literal"><span class="koboSpan" id="kobo.133.1">Idle</span></code><span class="koboSpan" id="kobo.134.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.135.1">Copying</span></code><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">It then calls </span><code class="literal"><span class="koboSpan" id="kobo.137.1">inc</span></code><span class="koboSpan" id="kobo.138.1"> to create a new state with the increased copy count, and updates the source file entry in the </span><code class="literal"><span class="koboSpan" id="kobo.139.1">files</span></code><span class="koboSpan" id="kobo.140.1"> map with the new state. </span><span class="koboSpan" id="kobo.140.2">Similarly, the </span><code class="literal"><span class="koboSpan" id="kobo.141.1">copyFile</span></code><span class="koboSpan" id="kobo.142.1"> method creates a new entry for the destination file in the </span><code class="literal"><span class="koboSpan" id="kobo.143.1">files</span></code><span class="koboSpan" id="kobo.144.1"> map. </span><span class="koboSpan" id="kobo.144.2">Finally, the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">copyFile</span></code><span class="koboSpan" id="kobo.146.1"> method calls the </span><code class="literal"><span class="koboSpan" id="kobo.147.1">afterCommit</span></code><span class="koboSpan" id="kobo.148.1"> handler to physically copy the file to disk after the transaction completes. </span><span class="koboSpan" id="kobo.148.2">Recall that it is not legal to execute side-effecting operations from within the transaction body, so the private </span><code class="literal"><span class="koboSpan" id="kobo.149.1">copyOnDisk</span></code><span class="koboSpan" id="kobo.150.1"> method is called only after the transaction commits:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.151.1">def copyFile(src: String, dest: String) = atomic { implicit txn =&gt; 
  val srcfile = new File(src) 
  val destfile = new File(dest) 
  val info = files(src) 
  if (files.contains(dest)) sys.error(s"Destination exists.") 
  info.state match { 
    case Idle | Copying(_) =&gt; 
      files(src) = info.copy(state = info.state.inc) 
      files(dest) = FileInfo.creating(destfile, info.size) 
      Txn.afterCommit { _ =&gt; copyOnDisk(srcfile, destfile) } 
      src 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.152.1">The </span><code class="literal"><span class="koboSpan" id="kobo.153.1">copyOnDisk</span></code><span class="koboSpan" id="kobo.154.1"> method calls the </span><code class="literal"><span class="koboSpan" id="kobo.155.1">copyFile</span></code><span class="koboSpan" id="kobo.156.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.157.1">FileUtils</span></code><span class="koboSpan" id="kobo.158.1"> class from the Apache Commons IO library. </span><span class="koboSpan" id="kobo.158.2">After the file transfer completes, the </span><code class="literal"><span class="koboSpan" id="kobo.159.1">copyOnDisk</span></code><span class="koboSpan" id="kobo.160.1"> method starts another transaction, in which it decreases the copy count of the source file and sets the state of the destination file to </span><code class="literal"><span class="koboSpan" id="kobo.161.1">Idle</span></code><span class="koboSpan" id="kobo.162.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.163.1">private def copyOnDisk(srcfile: File, destfile: File) = { 
  FileUtils.copyFile(srcfile, destfile) 
  atomic { implicit txn =&gt; 
    val ninfo = files(srcfile.getPath) 
    files(srcfile.getPath) = ninfo.copy(state = ninfo.state.dec) 
    files(destfile.getPath) = FileInfo(destfile) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.164.1">The </span><code class="literal"><span class="koboSpan" id="kobo.165.1">deleteFile</span></code><span class="koboSpan" id="kobo.166.1"> method deletes a file in a similar way. </span><span class="koboSpan" id="kobo.166.2">It changes the file state to </span><code class="literal"><span class="koboSpan" id="kobo.167.1">Deleted</span></code><span class="koboSpan" id="kobo.168.1">, deletes the file, and starts another transaction to remove the file entry:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.169.1">def deleteFile(srcpath: String): String = atomic { implicit txn =&gt; 
  val info = files(srcpath) 
  info.state match { 
    case Idle =&gt; 
      files(srcpath) = info.copy(state = Deleted) 
      Txn.afterCommit { _ =&gt; 
        FileUtils.forceDelete(info.toFile) 
        files.single.remove(srcpath) 
      } 
      srcpath 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.170.1">Modeling the server data model with the STM allows for the seamless addition of different concurrent computations to the server program. </span><span class="koboSpan" id="kobo.170.2">In the following section, we will implement a server actor that uses the server API to execute filesystem operations.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip101"/><span class="koboSpan" id="kobo.171.1">Tip</span></h3><p><span class="koboSpan" id="kobo.172.1">Use STM to model concurrently accessible data, as an STM works transparently with most concurrency frameworks.</span></p></div></div><p><span class="koboSpan" id="kobo.173.1">Having completed the filesystem API, we now proceed to the server interface layer of the ScalaFTP browser.</span></p></div><div class="section" title="The server interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec81"/><span class="koboSpan" id="kobo.174.1">The server interface</span></h2></div></div></div><p><span class="koboSpan" id="kobo.175.1">The server interface comprises of a single actor called </span><code class="literal"><span class="koboSpan" id="kobo.176.1">FTPServerActor</span></code><span class="koboSpan" id="kobo.177.1">. </span><span class="koboSpan" id="kobo.177.2">This actor will receive client requests and respond to them serially. </span><span class="koboSpan" id="kobo.177.3">If it turns out that the server actor is the sequential bottleneck of the system, we can simply add additional server interface actors to improve horizontal scalability.</span></p><p><span class="koboSpan" id="kobo.178.1">We start by defining the different types of messages that the server actor can receive. </span><span class="koboSpan" id="kobo.178.2">We follow the convention of defining them inside the companion object of the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">FTPServerActor</span></code><span class="koboSpan" id="kobo.180.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.181.1">object FTPServerActor { 
  sealed trait Command 
  case class GetFileList(dir: String) extends Command 
  case class CopyFile(src: String, dest: String) extends Command 
  case class DeleteFile(path: String) extends Command 
  def apply(fs: FileSystem) = Props(classOf[FTPServerActor], fs) 
} 
</span></pre><p><span class="koboSpan" id="kobo.182.1">The actor template of the server actor takes a </span><code class="literal"><span class="koboSpan" id="kobo.183.1">FileSystem</span></code><span class="koboSpan" id="kobo.184.1"> object as a parameter. </span><span class="koboSpan" id="kobo.184.2">It reacts to the </span><code class="literal"><span class="koboSpan" id="kobo.185.1">GetFileList</span></code><span class="koboSpan" id="kobo.186.1">, </span><code class="literal"><span class="koboSpan" id="kobo.187.1">CopyFile</span></code><span class="koboSpan" id="kobo.188.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.189.1">DeleteFile</span></code><span class="koboSpan" id="kobo.190.1"> messages by calling the appropriate methods from the filesystem API:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.191.1">class FTPServerActor(fileSystem: FileSystem) extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case GetFileList(dir) =&gt; 
      val filesMap = fileSystem.getFileList(dir) 
      val files = filesMap.map(_._2).to[Seq] 
      sender ! </span><span class="koboSpan" id="kobo.191.2">files 
    case CopyFile(srcpath, destpath) =&gt; 
      Future { 
        Try(fileSystem.copyFile(srcpath, destpath)) 
      } pipeTo sender 
    case DeleteFile(path) =&gt; 
      Future { 
        Try(fileSystem.deleteFile(path)) 
      } pipeTo sender 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.192.1">When the server receives a </span><code class="literal"><span class="koboSpan" id="kobo.193.1">GetFileList</span></code><span class="koboSpan" id="kobo.194.1"> message, it calls the </span><code class="literal"><span class="koboSpan" id="kobo.195.1">getFileList</span></code><span class="koboSpan" id="kobo.196.1"> method with the specified </span><code class="literal"><span class="koboSpan" id="kobo.197.1">dir</span></code><span class="koboSpan" id="kobo.198.1"> directory, and sends a sequence collection with the </span><code class="literal"><span class="koboSpan" id="kobo.199.1">FileInfo</span></code><span class="koboSpan" id="kobo.200.1"> objects back to the client. </span><span class="koboSpan" id="kobo.200.2">Since </span><code class="literal"><span class="koboSpan" id="kobo.201.1">FileInfo</span></code><span class="koboSpan" id="kobo.202.1"> is a case class, it extends the </span><code class="literal"><span class="koboSpan" id="kobo.203.1">Serializable</span></code><span class="koboSpan" id="kobo.204.1"> interface, and its instances can be sent over the network.</span></p><p><span class="koboSpan" id="kobo.205.1">When the server receives a </span><code class="literal"><span class="koboSpan" id="kobo.206.1">CopyFile</span></code><span class="koboSpan" id="kobo.207.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.208.1">DeleteFile</span></code><span class="koboSpan" id="kobo.209.1"> message, it calls the appropriate filesystem method asynchronously. </span><span class="koboSpan" id="kobo.209.2">The methods in the filesystem API throw exceptions when something goes wrong, so we need to wrap calls to them in </span><code class="literal"><span class="koboSpan" id="kobo.210.1">Try</span></code><span class="koboSpan" id="kobo.211.1"> objects. </span><span class="koboSpan" id="kobo.211.2">After the asynchronous file operations complete, the resulting </span><code class="literal"><span class="koboSpan" id="kobo.212.1">Try</span></code><span class="koboSpan" id="kobo.213.1"> objects are piped back as messages to the sender actor, using the Akka </span><code class="literal"><span class="koboSpan" id="kobo.214.1">pipeTo</span></code><span class="koboSpan" id="kobo.215.1"> method.</span></p><p><span class="koboSpan" id="kobo.216.1">To start the ScalaFTP server, we need to instantiate and initialize a </span><code class="literal"><span class="koboSpan" id="kobo.217.1">FileSystem</span></code><span class="koboSpan" id="kobo.218.1"> object and start the server actor. </span><span class="koboSpan" id="kobo.218.2">We parse the network port command-line argument, and use it to create an actor system that is capable of remote communication. </span><span class="koboSpan" id="kobo.218.3">For this, we use the </span><code class="literal"><span class="koboSpan" id="kobo.219.1">remotingSystem</span></code><span class="koboSpan" id="kobo.220.1"> factory method that we introduced in </span><a class="link" href="ch08.html" title="Chapter 8.  Actors"><span class="koboSpan" id="kobo.221.1">Chapter 8</span></a><span class="koboSpan" id="kobo.222.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.223.1">Actors</span></em></span><span class="koboSpan" id="kobo.224.1">. </span><span class="koboSpan" id="kobo.224.2">The remoting actor system then creates an instance of the </span><code class="literal"><span class="koboSpan" id="kobo.225.1">FTPServerActor</span></code><span class="koboSpan" id="kobo.226.1">. </span><span class="koboSpan" id="kobo.226.2">This is shown in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.227.1">object FTPServer extends App { 
  val fileSystem = new FileSystem(".") 
  fileSystem.init() 
  val port = args(0).toInt 
  val actorSystem = ch8.remotingSystem("FTPServerSystem", port) 
  actorSystem.actorOf(FTPServerActor(fileSystem), "server") 
} 
</span></pre><p><span class="koboSpan" id="kobo.228.1">The ScalaFTP server actor can run inside the same process as the client application, in another process in the same machine, or on a different machine connected with a network. </span><span class="koboSpan" id="kobo.228.2">The advantage of the actor model is that we usually need not worry about where the actor runs until we integrate it into the entire application.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip102"/><span class="koboSpan" id="kobo.229.1">Tip</span></h3><p><span class="koboSpan" id="kobo.230.1">When you need to implement a distributed application that runs on different machines, use an actor framework.</span></p></div></div><p><span class="koboSpan" id="kobo.231.1">Our server program is now complete, and we can run it with the </span><code class="literal"><span class="koboSpan" id="kobo.232.1">run</span></code><span class="koboSpan" id="kobo.233.1"> command from SBT. </span><span class="koboSpan" id="kobo.233.2">We set the actor system to use the port </span><code class="literal"><span class="koboSpan" id="kobo.234.1">12345</span></code><span class="koboSpan" id="kobo.235.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.236.1">run 12345 
</span></pre><p><span class="koboSpan" id="kobo.237.1">In the following section, we will implement the file navigation API for the ScalaFTP client, which will communicate with the server interface over the network.</span></p></div><div class="section" title="Client navigation API"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec82"/><span class="koboSpan" id="kobo.238.1">Client navigation API</span></h2></div></div></div><p><span class="koboSpan" id="kobo.239.1">The client API exposes the server interfaces to the client program through asynchronous methods that return future objects. </span><span class="koboSpan" id="kobo.239.2">Unlike the server's filesystem API, which runs locally, the client API methods execute remote network requests. </span><span class="koboSpan" id="kobo.239.3">Futures are a natural way to model latency in the client API methods, and to avoid blocking during network requests.</span></p><p><span class="koboSpan" id="kobo.240.1">Internally, the client API maintains an actor instance that communicates with the server actor. </span><span class="koboSpan" id="kobo.240.2">The client actor does not know the actor reference of the server actor when it is created. </span><span class="koboSpan" id="kobo.240.3">For this reason, the client actor starts in an </span><span class="strong"><strong><span class="koboSpan" id="kobo.241.1">unconnected</span></strong></span><span class="koboSpan" id="kobo.242.1"> state. </span><span class="koboSpan" id="kobo.242.2">When it receives the </span><code class="literal"><span class="koboSpan" id="kobo.243.1">Start</span></code><span class="koboSpan" id="kobo.244.1"> message with the URL of the server actor system, the client constructs an actor path to the server actor, sends out an </span><code class="literal"><span class="koboSpan" id="kobo.245.1">Identify</span></code><span class="koboSpan" id="kobo.246.1"> message, and switches to the </span><span class="strong"><strong><span class="koboSpan" id="kobo.247.1">connecting</span></strong></span><span class="koboSpan" id="kobo.248.1"> state. </span><span class="koboSpan" id="kobo.248.2">If the actor system is able to find the server actor, the client actor eventually receives the </span><code class="literal"><span class="koboSpan" id="kobo.249.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.250.1"> message with the server actor reference. </span><span class="koboSpan" id="kobo.250.2">In this case, the client actor switches to the </span><span class="strong"><strong><span class="koboSpan" id="kobo.251.1">connected</span></strong></span><span class="koboSpan" id="kobo.252.1"> state, and is able to forward commands to the server. </span><span class="koboSpan" id="kobo.252.2">Otherwise, the connection fails and the client actor reverts to the unconnected state. </span><span class="koboSpan" id="kobo.252.3">The state diagram of the client actor is shown in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.253.1"><img src="graphics/image_09_002.jpg" alt="Client navigation API"/></span></div><p><span class="koboSpan" id="kobo.254.1">We define the </span><code class="literal"><span class="koboSpan" id="kobo.255.1">Start</span></code><span class="koboSpan" id="kobo.256.1"> message in the client actor's companion object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.257.1">object FTPClientActor { 
  case class Start(host: String) 
} 
</span></pre><p><span class="koboSpan" id="kobo.258.1">We then define the </span><code class="literal"><span class="koboSpan" id="kobo.259.1">FTPClientActor</span></code><span class="koboSpan" id="kobo.260.1"> class and give it an implicit </span><code class="literal"><span class="koboSpan" id="kobo.261.1">Timeout</span></code><span class="koboSpan" id="kobo.262.1"> parameter. </span><span class="koboSpan" id="kobo.262.2">The </span><code class="literal"><span class="koboSpan" id="kobo.263.1">Timeout</span></code><span class="koboSpan" id="kobo.264.1"> parameter will be used later in the Akka ask pattern, when forwarding client requests to the server actor. </span><span class="koboSpan" id="kobo.264.2">The stub of the </span><code class="literal"><span class="koboSpan" id="kobo.265.1">FTPClientActor</span></code><span class="koboSpan" id="kobo.266.1"> class is as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.267.1">class FTPClientActor(implicit val timeout: Timeout) 
extends Actor 
</span></pre><p><span class="koboSpan" id="kobo.268.1">Before defining the </span><code class="literal"><span class="koboSpan" id="kobo.269.1">receive</span></code><span class="koboSpan" id="kobo.270.1"> method, we define behaviors corresponding to different actor states. </span><span class="koboSpan" id="kobo.270.2">Once the client actor in the unconnected state receives the </span><code class="literal"><span class="koboSpan" id="kobo.271.1">Start</span></code><span class="koboSpan" id="kobo.272.1"> message with the host string, it constructs an actor path to the server and creates an actor selection object. </span><span class="koboSpan" id="kobo.272.2">The client actor then sends the </span><code class="literal"><span class="koboSpan" id="kobo.273.1">Identify</span></code><span class="koboSpan" id="kobo.274.1"> message to the actor selection, and switches its behavior to </span><code class="literal"><span class="koboSpan" id="kobo.275.1">connecting</span></code><span class="koboSpan" id="kobo.276.1">. </span><span class="koboSpan" id="kobo.276.2">This is shown in the following behavior method, named </span><code class="literal"><span class="koboSpan" id="kobo.277.1">unconnected</span></code><span class="koboSpan" id="kobo.278.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.279.1">def unconnected: Actor.Receive = { 
  case Start(host) =&gt; 
    val serverActorPath = 
      s"akka.tcp://FTPServerSystem@$host/user/server" 
    val serverActorSel = context.actorSelection(serverActorPath) 
    serverActorSel ! </span><span class="koboSpan" id="kobo.279.2">Identify(()) 
    context.become(connecting(sender)) 
} 
</span></pre><p><span class="koboSpan" id="kobo.280.1">The </span><code class="literal"><span class="koboSpan" id="kobo.281.1">connecting</span></code><span class="koboSpan" id="kobo.282.1"> method creates a behavior given an actor reference to the sender of the </span><code class="literal"><span class="koboSpan" id="kobo.283.1">Start</span></code><span class="koboSpan" id="kobo.284.1"> message. </span><span class="koboSpan" id="kobo.284.2">We call this actor reference </span><code class="literal"><span class="koboSpan" id="kobo.285.1">clientApp</span></code><span class="koboSpan" id="kobo.286.1">, because the ScalaFTP client application will send the </span><code class="literal"><span class="koboSpan" id="kobo.287.1">Start</span></code><span class="koboSpan" id="kobo.288.1"> message to the client actor. </span><span class="koboSpan" id="kobo.288.2">Once the client actor receives an </span><code class="literal"><span class="koboSpan" id="kobo.289.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.290.1"> message with the </span><code class="literal"><span class="koboSpan" id="kobo.291.1">ref</span></code><span class="koboSpan" id="kobo.292.1"> reference to the server actor, it can send </span><code class="literal"><span class="koboSpan" id="kobo.293.1">true</span></code><span class="koboSpan" id="kobo.294.1"> back to the </span><code class="literal"><span class="koboSpan" id="kobo.295.1">clientApp</span></code><span class="koboSpan" id="kobo.296.1"> reference, indicating that the connection was successful. </span><span class="koboSpan" id="kobo.296.2">In this case, the client actor switches to the </span><code class="literal"><span class="koboSpan" id="kobo.297.1">connected</span></code><span class="koboSpan" id="kobo.298.1"> behavior. </span><span class="koboSpan" id="kobo.298.2">Otherwise, if the client actor receives an </span><code class="literal"><span class="koboSpan" id="kobo.299.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.300.1"> message without the server reference, the client actor sends </span><code class="literal"><span class="koboSpan" id="kobo.301.1">false</span></code><span class="koboSpan" id="kobo.302.1"> back to the application and reverts to the </span><code class="literal"><span class="koboSpan" id="kobo.303.1">unconnected</span></code><span class="koboSpan" id="kobo.304.1"> state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.305.1">def connecting(clientApp: ActorRef): Actor.Receive = { 
  case ActorIdentity(_, Some(ref)) =&gt; 
    clientApp ! </span><span class="koboSpan" id="kobo.305.2">true 
    context.become(connected(ref)) 
  case ActorIdentity(_, None) =&gt; 
    clientApp ! </span><span class="koboSpan" id="kobo.305.3">false 
    context.become(unconnected) 
} 
</span></pre><p><span class="koboSpan" id="kobo.306.1">The </span><code class="literal"><span class="koboSpan" id="kobo.307.1">connected</span></code><span class="koboSpan" id="kobo.308.1"> state uses the </span><code class="literal"><span class="koboSpan" id="kobo.309.1">serverActor</span></code><span class="koboSpan" id="kobo.310.1"> server actor reference to forward the </span><code class="literal"><span class="koboSpan" id="kobo.311.1">Command</span></code><span class="koboSpan" id="kobo.312.1"> messages. </span><span class="koboSpan" id="kobo.312.2">To do so, the client actor uses the Akka ask pattern, which returns a future object with the server's response. </span><span class="koboSpan" id="kobo.312.3">The contents of the future are piped back to the original sender of the </span><code class="literal"><span class="koboSpan" id="kobo.313.1">Command</span></code><span class="koboSpan" id="kobo.314.1"> message. </span><span class="koboSpan" id="kobo.314.2">In this way, the client actor serves as an intermediary between the application, which is the sender, and the server actor. </span><span class="koboSpan" id="kobo.314.3">The </span><code class="literal"><span class="koboSpan" id="kobo.315.1">connected</span></code><span class="koboSpan" id="kobo.316.1"> method is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.317.1">def connected(serverActor: ActorRef): Actor.Receive = { 
  case command: Command =&gt; 
    (serverActor ? </span><span class="koboSpan" id="kobo.317.2">command).pipeTo(sender) 
} 
</span></pre><p><span class="koboSpan" id="kobo.318.1">Finally, the </span><code class="literal"><span class="koboSpan" id="kobo.319.1">receive</span></code><span class="koboSpan" id="kobo.320.1"> method returns the </span><code class="literal"><span class="koboSpan" id="kobo.321.1">unconnected</span></code><span class="koboSpan" id="kobo.322.1"> behavior, in which the client actor is created:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.323.1">def receive = unconnected 
</span></pre><p><span class="koboSpan" id="kobo.324.1">Having implemented the client actor, we can proceed to the client API layer. </span><span class="koboSpan" id="kobo.324.2">We model it as a trait with a </span><code class="literal"><span class="koboSpan" id="kobo.325.1">connected</span></code><span class="koboSpan" id="kobo.326.1"> value, the concrete methods </span><code class="literal"><span class="koboSpan" id="kobo.327.1">getFileList</span></code><span class="koboSpan" id="kobo.328.1">, </span><code class="literal"><span class="koboSpan" id="kobo.329.1">copyFile</span></code><span class="koboSpan" id="kobo.330.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.331.1">deleteFile</span></code><span class="koboSpan" id="kobo.332.1">, and an abstract </span><code class="literal"><span class="koboSpan" id="kobo.333.1">host</span></code><span class="koboSpan" id="kobo.334.1"> method. </span><span class="koboSpan" id="kobo.334.2">The client API creates a private remoting actor system and a client actor. </span><span class="koboSpan" id="kobo.334.3">It then instantiates the </span><code class="literal"><span class="koboSpan" id="kobo.335.1">connected</span></code><span class="koboSpan" id="kobo.336.1"> future that computes the connection status by sending a </span><code class="literal"><span class="koboSpan" id="kobo.337.1">Start</span></code><span class="koboSpan" id="kobo.338.1"> message to the client actor. </span><span class="koboSpan" id="kobo.338.2">The methods </span><code class="literal"><span class="koboSpan" id="kobo.339.1">getFileList</span></code><span class="koboSpan" id="kobo.340.1">, </span><code class="literal"><span class="koboSpan" id="kobo.341.1">copyFile</span></code><span class="koboSpan" id="kobo.342.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.343.1">deleteFile</span></code><span class="koboSpan" id="kobo.344.1"> are similar. </span><span class="koboSpan" id="kobo.344.2">They use the ask pattern on the client actor to obtain a future with the response.</span></p><p><span class="koboSpan" id="kobo.345.1">Recall that the actor messages are not typed, and the ask pattern returns a </span><code class="literal"><span class="koboSpan" id="kobo.346.1">Future[Any]</span></code><span class="koboSpan" id="kobo.347.1"> object. </span><span class="koboSpan" id="kobo.347.2">For this reason, each method in the client API uses the </span><code class="literal"><span class="koboSpan" id="kobo.348.1">mapTo</span></code><span class="koboSpan" id="kobo.349.1"> future combinator to restore the type of the message:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.350.1">trait FTPClientApi { 
  implicit val timeout: Timeout = Timeout(4 seconds) 
  private val props = Props(classOf[FTPClientActor], timeout) 
  private val system = ch8.remotingSystem("FTPClientSystem", 0) 
  private val clientActor = system.actorOf(props) 
  def host: String 
  val connected: Future[Boolean] = { 
    val f = clientActor ? </span><span class="koboSpan" id="kobo.350.2">FTPClientActor.Start 
    f.mapTo[Boolean] 
  } 
  def getFileList(d: String): Future[(String, Seq[FileInfo])] = { 
    val f = clientActor ? </span><span class="koboSpan" id="kobo.350.3">FTPServerActor.GetFileList(d) 
    f.mapTo[Seq[FileInfo]].map(fs =&gt; (d, fs)) 
  } 
  def copyFile(src: String, dest: String): Future[String] = { 
    val f = clientActor ? </span><span class="koboSpan" id="kobo.350.4">FTPServerActor.CopyFile(src, dest) 
    f.mapTo[Try[String]].map(_.get) 
  } 
  def deleteFile(srcpath: String): Future[String] = { 
    val f = clientActor ? </span><span class="koboSpan" id="kobo.350.5">FTPServerActor.DeleteFile(srcpath) 
    f.mapTo[Try[String]].map(_.get) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.351.1">Note that the client API does not expose the fact that it uses actors for remote communication. </span><span class="koboSpan" id="kobo.351.2">Moreover, the client API is similar to the server API, but the return types of the methods are futures instead of normal values. </span><span class="koboSpan" id="kobo.351.3">Futures encode the latency of a method without exposing the cause for the latency, so we often find them at the boundaries between different APIs. </span><span class="koboSpan" id="kobo.351.4">We can internally replace the actor communication between the client and the server with the remote </span><code class="literal"><span class="koboSpan" id="kobo.352.1">Observable</span></code><span class="koboSpan" id="kobo.353.1"> objects, but that would not change the client API.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip103"/><span class="koboSpan" id="kobo.354.1">Tip</span></h3><p><span class="koboSpan" id="kobo.355.1">In a concurrent application, use futures at the boundaries of the layers to express latency.</span></p></div></div><p><span class="koboSpan" id="kobo.356.1">Now that we can programmatically communicate with the remote ScalaFTP server, we turn our attention to the user interface of the client program.</span></p></div><div class="section" title="The client user interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec83"/><span class="koboSpan" id="kobo.357.1">The client user interface</span></h2></div></div></div><p><span class="koboSpan" id="kobo.358.1">In this section, we create the static user interface for the ScalaFTP client program. </span><span class="koboSpan" id="kobo.358.2">This graphical frontend will make our ScalaFTP application easy and intuitive to use. </span><span class="koboSpan" id="kobo.358.3">We will rely on the Scala Swing library to implement the UI.</span></p><p><span class="koboSpan" id="kobo.359.1">We will implement the client interface in an abstract </span><code class="literal"><span class="koboSpan" id="kobo.360.1">FTPClientFrame</span></code><span class="koboSpan" id="kobo.361.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.362.1">abstract class FTPClientFrame extends MainFrame { 
  title = "ScalaFTP" 
} 
</span></pre><p><span class="koboSpan" id="kobo.363.1">In the remainder of this section, we augment the </span><code class="literal"><span class="koboSpan" id="kobo.364.1">FTPClientFrame</span></code><span class="koboSpan" id="kobo.365.1"> class with different UI components. </span><span class="koboSpan" id="kobo.365.2">These UI components will enable the end user to interact with the client application, and ultimately with the remote server. </span><span class="koboSpan" id="kobo.365.3">Therefore, we will implement the following:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.366.1">A menu bar with common application options</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.367.1">A status bar that displays various user notifications, such as the connection state, status of the last requested operation, and various error messages</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.368.1">A pair of file panes that display the path to a specific directory in the filesystem, along with its contents, and buttons that start a copy or delete operation</span></li></ul></div><p><span class="koboSpan" id="kobo.369.1">After we are done, the ScalaFTP client program will look like the following screenshot:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.370.1"><img src="graphics/image_09_003.jpg" alt="The client user interface"/></span></div><p><span class="koboSpan" id="kobo.371.1">We start by implementing the menu bar. </span><span class="koboSpan" id="kobo.371.2">When creating Swing components in our UI, we can instantiate an anonymous class that extends a </span><code class="literal"><span class="koboSpan" id="kobo.372.1">Menu</span></code><span class="koboSpan" id="kobo.373.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.374.1">MenuBar</span></code><span class="koboSpan" id="kobo.375.1"> class, and assign it to a local variable. </span><span class="koboSpan" id="kobo.375.2">However, using an anonymous class does not allow access to its custom members. </span><span class="koboSpan" id="kobo.375.3">If the anonymous UI component class contains nested components, we are not able to refer to them. </span><span class="koboSpan" id="kobo.375.4">Therefore, we will use nested singleton objects to instantiate UI components, as doing this allows us to refer to the object's nested components.</span></p><p><span class="koboSpan" id="kobo.376.1">In the following code snippet, we create the </span><code class="literal"><span class="koboSpan" id="kobo.377.1">menu</span></code><span class="koboSpan" id="kobo.378.1"> singleton object that extends the </span><code class="literal"><span class="koboSpan" id="kobo.379.1">MenuBar</span></code><span class="koboSpan" id="kobo.380.1"> class. </span><span class="koboSpan" id="kobo.380.2">We create the </span><code class="literal"><span class="koboSpan" id="kobo.381.1">file</span></code><span class="koboSpan" id="kobo.382.1"> and the </span><code class="literal"><span class="koboSpan" id="kobo.383.1">help</span></code><span class="koboSpan" id="kobo.384.1"> menu, with the </span><code class="literal"><span class="koboSpan" id="kobo.385.1">exit</span></code><span class="koboSpan" id="kobo.386.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.387.1">about</span></code><span class="koboSpan" id="kobo.388.1"> menu items, respectively, and take care to add each </span><code class="literal"><span class="koboSpan" id="kobo.389.1">Menu</span></code><span class="koboSpan" id="kobo.390.1"> component to the </span><code class="literal"><span class="koboSpan" id="kobo.391.1">contents</span></code><span class="koboSpan" id="kobo.392.1"> collection of the enclosing component:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.393.1">object menu extends MenuBar { 
  object file extends Menu("File") { 
    val exit = new MenuItem("Exit ScalaFTP") 
    contents += exit 
  } 
  object help extends Menu("Help") { 
    val about = new MenuItem("About...") 
    contents += about 
  } 
  contents += file += help 
} 
</span></pre><p><span class="koboSpan" id="kobo.394.1">Similarly, we implement the </span><code class="literal"><span class="koboSpan" id="kobo.395.1">status</span></code><span class="koboSpan" id="kobo.396.1"> object by extending the </span><code class="literal"><span class="koboSpan" id="kobo.397.1">BorderPanel</span></code><span class="koboSpan" id="kobo.398.1"> class. </span><span class="koboSpan" id="kobo.398.2">The </span><code class="literal"><span class="koboSpan" id="kobo.399.1">BorderPanel</span></code><span class="koboSpan" id="kobo.400.1"> components are used to hold other nested components: in our case, two nested </span><code class="literal"><span class="koboSpan" id="kobo.401.1">Label</span></code><span class="koboSpan" id="kobo.402.1"> objects. </span><span class="koboSpan" id="kobo.402.2">The anonymous </span><code class="literal"><span class="koboSpan" id="kobo.403.1">Label</span></code><span class="koboSpan" id="kobo.404.1"> object always contains the static </span><code class="literal"><span class="koboSpan" id="kobo.405.1">Status: </span></code><span class="koboSpan" id="kobo.406.1">text, while the named </span><code class="literal"><span class="koboSpan" id="kobo.407.1">Label</span></code><span class="koboSpan" id="kobo.408.1"> object contains arbitrary status messages. </span><span class="koboSpan" id="kobo.408.2">We place the anonymous </span><code class="literal"><span class="koboSpan" id="kobo.409.1">Label</span></code><span class="koboSpan" id="kobo.410.1"> object to the left, and the </span><code class="literal"><span class="koboSpan" id="kobo.411.1">Label</span></code><span class="koboSpan" id="kobo.412.1"> object with the status messages in the center. </span><span class="koboSpan" id="kobo.412.2">This is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.413.1">object status extends BorderPanel { 
  val label = new Label("connecting...", null, Alignment.Left) 
  layout(new Label("Status: ")) = West 
  layout(label) = Center 
} 
</span></pre><p><span class="koboSpan" id="kobo.414.1">Finally, we implement a custom </span><code class="literal"><span class="koboSpan" id="kobo.415.1">FilePane</span></code><span class="koboSpan" id="kobo.416.1"> component that displays the contents of a directory in the remote filesystem. </span><span class="koboSpan" id="kobo.416.2">We will have two </span><code class="literal"><span class="koboSpan" id="kobo.417.1">FilePane</span></code><span class="koboSpan" id="kobo.418.1"> instances in the client program, so we declare a custom </span><code class="literal"><span class="koboSpan" id="kobo.419.1">FilePane</span></code><span class="koboSpan" id="kobo.420.1"> class, which itself extends the </span><code class="literal"><span class="koboSpan" id="kobo.421.1">BorderPanel</span></code><span class="koboSpan" id="kobo.422.1"> component type:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.423.1">class FilePane extends BorderPanel 
</span></pre><p><span class="koboSpan" id="kobo.424.1">We hierarchically decompose the </span><code class="literal"><span class="koboSpan" id="kobo.425.1">FilePane</span></code><span class="koboSpan" id="kobo.426.1"> class into three parts: the </span><code class="literal"><span class="koboSpan" id="kobo.427.1">pathBar</span></code><span class="koboSpan" id="kobo.428.1"> component that displays the path to the current directory, the </span><code class="literal"><span class="koboSpan" id="kobo.429.1">scrollPane</span></code><span class="koboSpan" id="kobo.430.1"> component that allows scrolling through the contents of the current directory, and the </span><code class="literal"><span class="koboSpan" id="kobo.431.1">buttons</span></code><span class="koboSpan" id="kobo.432.1"> component that contains the copy and delete buttons. </span><span class="koboSpan" id="kobo.432.2">In the following code snippet, we add a non-editable text field with the current path, and an </span><code class="literal"><span class="koboSpan" id="kobo.433.1">upButton</span></code><span class="koboSpan" id="kobo.434.1"> component that is used to navigate up the file hierarchy:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.435.1">object pathBar extends BorderPanel { 
  val label = new Label("Path:") 
  val filePath = new TextField(".") { editable = false } 
  val upButton = new Button("^") 
  layout(label) = West 
  layout(filePath) = Center 
  layout(upButton) = East 
} 
</span></pre><p><span class="koboSpan" id="kobo.436.1">The </span><code class="literal"><span class="koboSpan" id="kobo.437.1">scrollPane</span></code><span class="koboSpan" id="kobo.438.1"> component contains a </span><code class="literal"><span class="koboSpan" id="kobo.439.1">Table</span></code><span class="koboSpan" id="kobo.440.1"> object named </span><code class="literal"><span class="koboSpan" id="kobo.441.1">fileTable</span></code><span class="koboSpan" id="kobo.442.1">. </span><span class="koboSpan" id="kobo.442.2">The </span><code class="literal"><span class="koboSpan" id="kobo.443.1">fileTable</span></code><span class="koboSpan" id="kobo.444.1"> object will contain the columns named </span><code class="literal"><span class="koboSpan" id="kobo.445.1">Filename</span></code><span class="koboSpan" id="kobo.446.1">, </span><code class="literal"><span class="koboSpan" id="kobo.447.1">Size</span></code><span class="koboSpan" id="kobo.448.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.449.1">Date modified</span></code><span class="koboSpan" id="kobo.450.1">, and each table row will contain a file or a subdirectory within the current working directory. </span><span class="koboSpan" id="kobo.450.2">To prevent the user from modifying filenames, sizes, or modification dates, we install a custom </span><code class="literal"><span class="koboSpan" id="kobo.451.1">TableModel</span></code><span class="koboSpan" id="kobo.452.1"> object that disallows editing in every row and column. </span><span class="koboSpan" id="kobo.452.2">The complete implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.453.1">scrollPane</span></code><span class="koboSpan" id="kobo.454.1"> component is as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.455.1">object scrollPane extends ScrollPane { 
  val columnNames = 
    Array[AnyRef]("Filename", "Size", "Date modified") 
  val fileTable = new Table { 
    showGrid = true 
    model = new DefaultTableModel(columnNames, 0) { 
      override def isCellEditable(r: Int, c: Int) = false 
    } 
    selection.intervalMode = Table.IntervalMode.Single 
  } 
  contents = fileTable 
} 
</span></pre><p><span class="koboSpan" id="kobo.456.1">The </span><code class="literal"><span class="koboSpan" id="kobo.457.1">buttons</span></code><span class="koboSpan" id="kobo.458.1"> singleton object is a </span><code class="literal"><span class="koboSpan" id="kobo.459.1">GridPanel</span></code><span class="koboSpan" id="kobo.460.1"> component with one row and two columns. </span><span class="koboSpan" id="kobo.460.2">Each column contains a single button, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.461.1">object buttons extends GridPanel(1, 2) { 
  val copyButton = new Button("Copy") 
  val deleteButton = new Button("Delete") 
  contents += copyButton += deleteButton 
} 
</span></pre><p><span class="koboSpan" id="kobo.462.1">We then place these custom components inside the </span><code class="literal"><span class="koboSpan" id="kobo.463.1">FilePane</span></code><span class="koboSpan" id="kobo.464.1"> component:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.465.1">layout(pathBar) = North 
layout(scrollPane) = Center 
layout(buttons) = South 
</span></pre><p><span class="koboSpan" id="kobo.466.1">Finally, we add the </span><code class="literal"><span class="koboSpan" id="kobo.467.1">parent</span></code><span class="koboSpan" id="kobo.468.1"> directory field and the list of the files in the current directory, named </span><code class="literal"><span class="koboSpan" id="kobo.469.1">dirFiles</span></code><span class="koboSpan" id="kobo.470.1">, into the </span><code class="literal"><span class="koboSpan" id="kobo.471.1">FilePane</span></code><span class="koboSpan" id="kobo.472.1"> class, as well as a few convenience methods to more easily access deeply nested UI components:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.473.1">var parent: String = "." 
</span><span class="koboSpan" id="kobo.473.2">var dirFiles: Seq[FileInfo] = Nil 
def table = scrollPane.fileTable 
def currentPath = pathBar.filePath.text 
</span></pre><p><span class="koboSpan" id="kobo.474.1">Recall that we need one </span><code class="literal"><span class="koboSpan" id="kobo.475.1">FilePane</span></code><span class="koboSpan" id="kobo.476.1"> instance on the left-hand side of the client program, and another one on the right. </span><span class="koboSpan" id="kobo.476.2">We declare the </span><code class="literal"><span class="koboSpan" id="kobo.477.1">files</span></code><span class="koboSpan" id="kobo.478.1"> singleton object inside the </span><code class="literal"><span class="koboSpan" id="kobo.479.1">FTPClientFrame</span></code><span class="koboSpan" id="kobo.480.1"> class to hold the two </span><code class="literal"><span class="koboSpan" id="kobo.481.1">FilePane</span></code><span class="koboSpan" id="kobo.482.1"> instances, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.483.1">object files extends GridPanel(1, 2) { 
  val leftPane = new FilePane 
  val rightPane = new FilePane 
  contents += leftPane += rightPane 
  def opposite(pane: FilePane) = 
    if (pane eq leftPane) rightPane else leftPane 
} 
</span></pre><p><span class="koboSpan" id="kobo.484.1">Finally, we need to place the </span><code class="literal"><span class="koboSpan" id="kobo.485.1">menu</span></code><span class="koboSpan" id="kobo.486.1">, </span><code class="literal"><span class="koboSpan" id="kobo.487.1">files</span></code><span class="koboSpan" id="kobo.488.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.489.1">status</span></code><span class="koboSpan" id="kobo.490.1"> components at the top, center, and bottom of the client program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.491.1">contents = new BorderPanel { 
  layout(menu) = North 
  layout(files) = Center 
  layout(status) = South 
} 
</span></pre><p><span class="koboSpan" id="kobo.492.1">We can already run the client program at this point, and try to interact with it. </span><span class="koboSpan" id="kobo.492.2">Unfortunately, the client program does not do anything yet. </span><span class="koboSpan" id="kobo.492.3">Clicking on the </span><code class="literal"><span class="koboSpan" id="kobo.493.1">FilePane</span></code><span class="koboSpan" id="kobo.494.1"> component, the buttons, or the menu items currently does not have any effect, as we have not yet defined callbacks for various UI actions. </span><span class="koboSpan" id="kobo.494.2">In the following section, we will use Rx to complete the functionality of the client application.</span></p></div><div class="section" title="Implementing the client logic"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec84"/><span class="koboSpan" id="kobo.495.1">Implementing the client logic</span></h2></div></div></div><p><span class="koboSpan" id="kobo.496.1">We are now ready to add some life to the ScalaFTP client program. </span><span class="koboSpan" id="kobo.496.2">We will define the logic layer in the </span><code class="literal"><span class="koboSpan" id="kobo.497.1">FTPClientLogic</span></code><span class="koboSpan" id="kobo.498.1"> trait. </span><span class="koboSpan" id="kobo.498.2">We only want to allow mixing in the </span><code class="literal"><span class="koboSpan" id="kobo.499.1">FTPClientLogic</span></code><span class="koboSpan" id="kobo.500.1"> trait with classes that extend both the </span><code class="literal"><span class="koboSpan" id="kobo.501.1">FTPClientFrame</span></code><span class="koboSpan" id="kobo.502.1"> class and the </span><code class="literal"><span class="koboSpan" id="kobo.503.1">FTPClientApi</span></code><span class="koboSpan" id="kobo.504.1"> trait, as this allows the logic layer to refer to both UI components and use the client API. </span><span class="koboSpan" id="kobo.504.2">Therefore, we give this trait the self-type </span><code class="literal"><span class="koboSpan" id="kobo.505.1">FTPClientFrame</span></code><span class="koboSpan" id="kobo.506.1"> class with </span><code class="literal"><span class="koboSpan" id="kobo.507.1">FTPClientApi</span></code><span class="koboSpan" id="kobo.508.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.509.1">trait FTPClientLogic { 
  self: FTPClientFrame with FTPClientApi =&gt; 
} 
</span></pre><p><span class="koboSpan" id="kobo.510.1">Before we begin, recall that the Swing components can only be modified from the event-dispatching thread. </span><span class="koboSpan" id="kobo.510.2">Similar to how we ensured this using the </span><code class="literal"><span class="koboSpan" id="kobo.511.1">swingScheduler</span></code><span class="koboSpan" id="kobo.512.1"> object in </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.513.1">Chapter 6</span></a><span class="koboSpan" id="kobo.514.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.515.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.516.1">, we now introduce the </span><code class="literal"><span class="koboSpan" id="kobo.517.1">swing</span></code><span class="koboSpan" id="kobo.518.1"> method, which takes a block of code and schedules it for execution on the Swing library's event-dispatching thread:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.519.1">def swing(body: =&gt;Unit) = { 
  val r = new Runnable { def run() = body } 
  javax.swing.SwingUtilities.invokeLater(r) 
} 
</span></pre><p><span class="koboSpan" id="kobo.520.1">Throughout this section, we will rely on the </span><code class="literal"><span class="koboSpan" id="kobo.521.1">swing</span></code><span class="koboSpan" id="kobo.522.1"> method in order to ensure that the effect of asynchronous computations occur only on the Swing event-dispatching thread.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip104"/><span class="koboSpan" id="kobo.523.1">Tip</span></h3><p><span class="koboSpan" id="kobo.524.1">The Swing toolkit permits modifying UI components only from the event-dispatching thread, but does not ensure this restriction at compile time, and can unexpectedly fail during runtime.</span></p></div></div><p><span class="koboSpan" id="kobo.525.1">We begin by relating the connection status to the user interface. </span><span class="koboSpan" id="kobo.525.2">Recall that we introduced the </span><code class="literal"><span class="koboSpan" id="kobo.526.1">connected</span></code><span class="koboSpan" id="kobo.527.1"> future as part of the client API. </span><span class="koboSpan" id="kobo.527.2">Depending on the result of the </span><code class="literal"><span class="koboSpan" id="kobo.528.1">connected</span></code><span class="koboSpan" id="kobo.529.1"> future, we either modify the </span><code class="literal"><span class="koboSpan" id="kobo.530.1">text</span></code><span class="koboSpan" id="kobo.531.1"> value of the status label to display an error message, or report that the client program has successfully connected to the server. </span><span class="koboSpan" id="kobo.531.2">In the latter case, we call the </span><code class="literal"><span class="koboSpan" id="kobo.532.1">refreshPane</span></code><span class="koboSpan" id="kobo.533.1"> method to update the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.534.1">FilePane</span></code><span class="koboSpan" id="kobo.535.1"> components that we will look at shortly. </span><span class="koboSpan" id="kobo.535.2">The following code snippet shows the </span><code class="literal"><span class="koboSpan" id="kobo.536.1">onComplete</span></code><span class="koboSpan" id="kobo.537.1"> callback:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.538.1">connected.onComplete { 
  case Failure(t) =&gt; 
    swing { status.label.text = s"Could not connect: $t" } 
  case Success(false) =&gt; 
    swing { status.label.text = "Could not find server." </span><span class="koboSpan" id="kobo.538.2">} 
  case Success(true) =&gt; 
    swing { 
      status.label.text = "Connected!" 
      </span><span class="koboSpan" id="kobo.538.3">refreshPane(files.leftPane) 
      refreshPane(files.rightPane) 
    } 
} 
</span></pre><p><span class="koboSpan" id="kobo.539.1">There are two steps involved in updating the </span><code class="literal"><span class="koboSpan" id="kobo.540.1">FilePane</span></code><span class="koboSpan" id="kobo.541.1"> component. </span><span class="koboSpan" id="kobo.541.2">First, we need to get the contents of the remote directory from the server. </span><span class="koboSpan" id="kobo.541.3">Second, once these contents arrive, we need to refresh the </span><code class="literal"><span class="koboSpan" id="kobo.542.1">Table</span></code><span class="koboSpan" id="kobo.543.1"> object in the </span><code class="literal"><span class="koboSpan" id="kobo.544.1">FilePane</span></code><span class="koboSpan" id="kobo.545.1"> component. </span><span class="koboSpan" id="kobo.545.2">In the following code, we call the </span><code class="literal"><span class="koboSpan" id="kobo.546.1">getFileList</span></code><span class="koboSpan" id="kobo.547.1"> method from the client API, and refresh the </span><code class="literal"><span class="koboSpan" id="kobo.548.1">Table</span></code><span class="koboSpan" id="kobo.549.1"> object with the </span><code class="literal"><span class="koboSpan" id="kobo.550.1">updatePane</span></code><span class="koboSpan" id="kobo.551.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.552.1">def refreshPane(pane: FilePane): Unit = { 
  val dir = pane.pathBar.filePath.text 
  getFileList(dir) onComplete { 
    case Success((dir, files)) =&gt; 
      swing { updatePane(pane, dir, files) } 
    case Failure(t) =&gt; 
      swing { status.label.text = s"Could not update pane: $t" } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.553.1">The </span><code class="literal"><span class="koboSpan" id="kobo.554.1">updatePane</span></code><span class="koboSpan" id="kobo.555.1"> method takes the </span><code class="literal"><span class="koboSpan" id="kobo.556.1">dir</span></code><span class="koboSpan" id="kobo.557.1"> directory name and the </span><code class="literal"><span class="koboSpan" id="kobo.558.1">files</span></code><span class="koboSpan" id="kobo.559.1"> list, and uses them to update the </span><code class="literal"><span class="koboSpan" id="kobo.560.1">FilePane</span></code><span class="koboSpan" id="kobo.561.1"> component </span><code class="literal"><span class="koboSpan" id="kobo.562.1">p</span></code><span class="koboSpan" id="kobo.563.1">. </span><span class="koboSpan" id="kobo.563.2">It extracts the </span><code class="literal"><span class="koboSpan" id="kobo.564.1">DefaultTableModel</span></code><span class="koboSpan" id="kobo.565.1"> object, and clears its previous contents by setting the row count to </span><code class="literal"><span class="koboSpan" id="kobo.566.1">0</span></code><span class="koboSpan" id="kobo.567.1">. </span><span class="koboSpan" id="kobo.567.2">It then updates the </span><code class="literal"><span class="koboSpan" id="kobo.568.1">parent</span></code><span class="koboSpan" id="kobo.569.1"> field in the </span><code class="literal"><span class="koboSpan" id="kobo.570.1">FilePane</span></code><span class="koboSpan" id="kobo.571.1"> object to the parent of the </span><code class="literal"><span class="koboSpan" id="kobo.572.1">dir</span></code><span class="koboSpan" id="kobo.573.1"> directory.</span></p><p><span class="koboSpan" id="kobo.574.1">Finally, it stores the </span><code class="literal"><span class="koboSpan" id="kobo.575.1">files</span></code><span class="koboSpan" id="kobo.576.1"> list into the </span><code class="literal"><span class="koboSpan" id="kobo.577.1">dirFiles</span></code><span class="koboSpan" id="kobo.578.1"> field, and adds a row for each entry:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.579.1">def updatePane(p: FilePane, dir: String, files: Seq[FileInfo]) = { 
  val table = p.scrollPane.fileTable 
  table.model match { 
    case d: DefaultTableModel =&gt; 
      d.setRowCount(0) 
      p.parent = 
        if (dir == ".") "." 
        </span><span class="koboSpan" id="kobo.579.2">else dir.take(dir.lastIndexOf(File.separator)) 
      p.dirFiles = files.sortBy(!_.isDir) 
      for (f &lt;- p.dirFiles) d.addRow(f.toRow) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.580.1">In the preceding method, we relied on the </span><code class="literal"><span class="koboSpan" id="kobo.581.1">toRow</span></code><span class="koboSpan" id="kobo.582.1"> method to convert the </span><code class="literal"><span class="koboSpan" id="kobo.583.1">FileInfo</span></code><span class="koboSpan" id="kobo.584.1"> object into an array of </span><code class="literal"><span class="koboSpan" id="kobo.585.1">String</span></code><span class="koboSpan" id="kobo.586.1"> objects, which the </span><code class="literal"><span class="koboSpan" id="kobo.587.1">Table</span></code><span class="koboSpan" id="kobo.588.1"> component works with:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.589.1">def toRow = Array[AnyRef]( 
  name, if (isDir) "" else size / 1000 + "kB", modified) 
</span></pre><p><span class="koboSpan" id="kobo.590.1">So far, so good! </span><span class="koboSpan" id="kobo.590.2">Our client program is able to connect to the server and show the contents of the root directory. </span><span class="koboSpan" id="kobo.590.3">Next, we need to implement the UI logic that allows navigating through the remote filesystem.</span></p><p><span class="koboSpan" id="kobo.591.1">When dealing with UI events in </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.592.1">Chapter 6</span></a><span class="koboSpan" id="kobo.593.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.594.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.595.1">, we augmented our UI components with </span><code class="literal"><span class="koboSpan" id="kobo.596.1">Observable</span></code><span class="koboSpan" id="kobo.597.1"> objects. </span><span class="koboSpan" id="kobo.597.2">Recall that we added the </span><code class="literal"><span class="koboSpan" id="kobo.598.1">clicks</span></code><span class="koboSpan" id="kobo.599.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.600.1">texts</span></code><span class="koboSpan" id="kobo.601.1"> methods in order to process events from the </span><code class="literal"><span class="koboSpan" id="kobo.602.1">Button</span></code><span class="koboSpan" id="kobo.603.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.604.1">TextField</span></code><span class="koboSpan" id="kobo.605.1"> components. </span><span class="koboSpan" id="kobo.605.2">In the following code, we augment the </span><code class="literal"><span class="koboSpan" id="kobo.606.1">Table</span></code><span class="koboSpan" id="kobo.607.1"> component with the </span><code class="literal"><span class="koboSpan" id="kobo.608.1">rowDoubleClicks</span></code><span class="koboSpan" id="kobo.609.1"> method, which returns an </span><code class="literal"><span class="koboSpan" id="kobo.610.1">Observable</span></code><span class="koboSpan" id="kobo.611.1"> object with the indices of the rows that have been double-clicked on:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.612.1">implicit class TableOps(val self: Table) { 
  def rowDoubleClicks = Observable[Int] { sub =&gt; 
    self.peer.addMouseListener(new MouseAdapter { 
      override def mouseClicked(e: java.awt.event.MouseEvent) { 
        if (e.getClickCount == 2) { 
          val row = self.peer.getSelectedRow 
          sub.onNext(row) 
        } 
      } 
    }) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.613.1">To navigate through the remote filesystem, users need to click on the </span><code class="literal"><span class="koboSpan" id="kobo.614.1">FilePane</span></code><span class="koboSpan" id="kobo.615.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.616.1">upButton</span></code><span class="koboSpan" id="kobo.617.1"> objects. </span><span class="koboSpan" id="kobo.617.2">We need to set up this functionality once for each pane, so we define the </span><code class="literal"><span class="koboSpan" id="kobo.618.1">setupPane</span></code><span class="koboSpan" id="kobo.619.1"> method for this purpose:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.620.1">def setupPane(pane: FilePane): Unit 
</span></pre><p><span class="koboSpan" id="kobo.621.1">The first step when reacting to the clicks on the </span><code class="literal"><span class="koboSpan" id="kobo.622.1">FilePane</span></code><span class="koboSpan" id="kobo.623.1"> component is mapping each user double-click to the name of the file or directory that has been clicked on. </span><span class="koboSpan" id="kobo.623.2">Then, if the double-clicked file is a directory, we update the current </span><code class="literal"><span class="koboSpan" id="kobo.624.1">filePath</span></code><span class="koboSpan" id="kobo.625.1"> method, and call the </span><code class="literal"><span class="koboSpan" id="kobo.626.1">refreshPane</span></code><span class="koboSpan" id="kobo.627.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.628.1">val fileClicks = 
  pane.table.rowDoubleClicks.map(row =&gt; pane.dirFiles(row)) 
fileClicks.filter(_.isDir).subscribe { fileInfo =&gt; 
  pane.pathBar.filePath.text = 
    pane.pathBar.filePath.text + File.separator + fileInfo.name 
  refreshPane(pane) 
} 
</span></pre><p><span class="koboSpan" id="kobo.629.1">Similarly, when the user clicks on the </span><code class="literal"><span class="koboSpan" id="kobo.630.1">upButton</span></code><span class="koboSpan" id="kobo.631.1"> component, we call the </span><code class="literal"><span class="koboSpan" id="kobo.632.1">refreshPane</span></code><span class="koboSpan" id="kobo.633.1"> method to navigate to the parent directory:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.634.1">pane.pathBar.upButton.clicks.subscribe { _ =&gt; 
  pane.pathBar.filePath.text = pane.parent 
  refreshPane(pane) 
} 
</span></pre><p><span class="koboSpan" id="kobo.635.1">Navigating through the remote filesystem is informative, but we also want to be able to copy and delete the remote files. </span><span class="koboSpan" id="kobo.635.2">This requires reacting to UI button clicks, each of which needs to be mapped to the correct, currently selected file. </span><span class="koboSpan" id="kobo.635.3">The </span><code class="literal"><span class="koboSpan" id="kobo.636.1">rowActions</span></code><span class="koboSpan" id="kobo.637.1"> method produces an event stream with the files that were selected at the time, at the point when a button was clicked:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.638.1">def rowActions(button: Button): Observable[FileInfo] = 
  button.clicks 
    .map(_ =&gt; pane.table.peer.getSelectedRow) 
    .filter(_ != -1) 
    .map(row =&gt; pane.dirFiles(row)) 
</span></pre><p><span class="koboSpan" id="kobo.639.1">Clicking on the copy button will copy the selected file to the directory selected in the opposite pane. </span><span class="koboSpan" id="kobo.639.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.640.1">rowActions</span></code><span class="koboSpan" id="kobo.641.1"> method to map the directory on the opposite pane, and call the </span><code class="literal"><span class="koboSpan" id="kobo.642.1">copyFile</span></code><span class="koboSpan" id="kobo.643.1"> method from the client API. </span><span class="koboSpan" id="kobo.643.2">Recall that the </span><code class="literal"><span class="koboSpan" id="kobo.644.1">copyFile</span></code><span class="koboSpan" id="kobo.645.1"> method returns a future, so we need to call the </span><code class="literal"><span class="koboSpan" id="kobo.646.1">onComplete</span></code><span class="koboSpan" id="kobo.647.1"> method to process its result asynchronously:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.648.1">rowActions(pane.buttons.copyButton) 
  .map(info =&gt; (info, files.opposite(pane).currentPath)) 
  .subscribe { t =&gt; 
    val (info, destDir) = t 
    val dest = destDir + File.separator + info.name 
    copyFile(info.path, dest) onComplete { 
      case Success(s) =&gt; 
        swing { 
          status.label.text = s"File copied: $s" 
          refreshPane(pane) 
        } 
    } 
  } 
</span></pre><p><span class="koboSpan" id="kobo.649.1">We use the </span><code class="literal"><span class="koboSpan" id="kobo.650.1">rowActions</span></code><span class="koboSpan" id="kobo.651.1"> method in a similar way, in order to react to clicks on the delete button. </span><span class="koboSpan" id="kobo.651.2">Finally, we call the </span><code class="literal"><span class="koboSpan" id="kobo.652.1">setupPane</span></code><span class="koboSpan" id="kobo.653.1"> method once for each pane:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.654.1">setupPane(files.leftPane) 
setupPane(files.rightPane) 
</span></pre><p><span class="koboSpan" id="kobo.655.1">Our remote file browser is now fully functional. </span><span class="koboSpan" id="kobo.655.2">To test it, we open two separate instances of the terminal, and run SBT in our project directory from both the terminals. </span><span class="koboSpan" id="kobo.655.3">We first run the server program:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.656.1">&gt; set fork := true</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.657.1">&gt; run 12345</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.658.1">By making sure that the server is running on port </span><code class="literal"><span class="koboSpan" id="kobo.659.1">12345</span></code><span class="koboSpan" id="kobo.660.1">, we can run the client from the second terminal as follows:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.661.1">&gt; set fork := true</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.662.1">&gt; run 127.0.0.1:12345</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.663.1">Now, try copying some of our project files between different directories. </span><span class="koboSpan" id="kobo.663.2">If you've also implemented the delete functionality, make sure that you back up the project files before deleting anything, just in case. </span><span class="koboSpan" id="kobo.663.3">It's not always a good idea to test experimental file-handling utilities on our source code.</span></p></div><div class="section" title="Improving the remote file browser"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec85"/><span class="koboSpan" id="kobo.664.1">Improving the remote file browser</span></h2></div></div></div><p><span class="koboSpan" id="kobo.665.1">If you successfully ran both the ScalaFTP server, client programs, and copied files around, you might have noticed that, if you delete a file on the disk from an external application, such as your source-code editor, the changes will not be reflected in the ScalaFTP server program. </span><span class="koboSpan" id="kobo.665.2">The reason for this is that the server actor does not monitor the filesystem for changes, and the server filesystem layer is not updated when we delete the file.</span></p><p><span class="koboSpan" id="kobo.666.1">To account for filesystem changes external to the ScalaFTP server program, we need to monitor the filesystem for changes. </span><span class="koboSpan" id="kobo.666.2">This sounds like an ideal case for event streams. </span><span class="koboSpan" id="kobo.666.3">Recall that we already did this in </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.667.1">Chapter 6</span></a><span class="koboSpan" id="kobo.668.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.669.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.670.1">, when we defined the </span><code class="literal"><span class="koboSpan" id="kobo.671.1">modified</span></code><span class="koboSpan" id="kobo.672.1"> method to track file modifications. </span><span class="koboSpan" id="kobo.672.2">This time, we define the </span><code class="literal"><span class="koboSpan" id="kobo.673.1">FileCreated</span></code><span class="koboSpan" id="kobo.674.1">, </span><code class="literal"><span class="koboSpan" id="kobo.675.1">FileDeleted</span></code><span class="koboSpan" id="kobo.676.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.677.1">FileModified</span></code><span class="koboSpan" id="kobo.678.1"> types to denote three different kinds of filesystem events:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.679.1">sealed trait FileEvent 
case class FileCreated(path: String) extends FileEvent 
case class FileDeleted(path: String) extends FileEvent 
case class FileModified(path: String) extends FileEvent 
</span></pre><p><span class="koboSpan" id="kobo.680.1">By implementing the additional methods in the </span><code class="literal"><span class="koboSpan" id="kobo.681.1">FileAlterationListener</span></code><span class="koboSpan" id="kobo.682.1"> interface, we ensure that the resulting </span><code class="literal"><span class="koboSpan" id="kobo.683.1">Observable</span></code><span class="koboSpan" id="kobo.684.1"> object produces any one of the three event types. </span><span class="koboSpan" id="kobo.684.2">In the following code snippet, we show the relevant part of the </span><code class="literal"><span class="koboSpan" id="kobo.685.1">fileSystemEvents</span></code><span class="koboSpan" id="kobo.686.1"> method that produces an </span><code class="literal"><span class="koboSpan" id="kobo.687.1">Observable[FileEvent]</span></code><span class="koboSpan" id="kobo.688.1"> object with the filesystem events:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.689.1">override def onFileCreate(file: File) = 
  obs.onNext(FileCreated(file.getPath)) 
override def onFileChange(file: File) = 
  obs.onNext(FileModified(file.getPath)) 
override def onFileDelete(file: File) = 
  obs.onNext(FileDeleted(file.getPath)) 
</span></pre><p><span class="koboSpan" id="kobo.690.1">Now that we have an event stream of file events, we can easily modify the filesystem model. </span><span class="koboSpan" id="kobo.690.2">We subscribe to the file event stream, and start single-operation transactions to update the </span><code class="literal"><span class="koboSpan" id="kobo.691.1">fileSystem</span></code><span class="koboSpan" id="kobo.692.1"> transactional map:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.693.1">fileSystemEvents(".").subscribe { e =&gt; e match { 
    case FileCreated(path) =&gt; 
      fileSystem.files.single(path) = FileInfo(new File(path)) 
    case FileDeleted(path) =&gt; 
      fileSystem.files.single.remove(path) 
    case FileModified(path) =&gt; 
      fileSystem.files.single(path) = FileInfo(new File(path)) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.694.1">Now, you can run the server and the client again, and experiment with either deleting or copying files in your editor after the server has started. </span><span class="koboSpan" id="kobo.694.2">You will notice that the filesystem changes are detected on the server, and eventually shown when the client is refreshed.</span></p><p><span class="koboSpan" id="kobo.695.1">Note that this example was chosen to illustrate how all the different concurrency libraries described in this book work together. </span><span class="koboSpan" id="kobo.695.2">However, there is no need to use all of these concurrency libraries in every program. </span><span class="koboSpan" id="kobo.695.3">In many situations, we only need a few different concurrency abstractions. </span><span class="koboSpan" id="kobo.695.4">Depending on your programming task, you should decide which ones are the best fit.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip105"/><span class="koboSpan" id="kobo.696.1">Tip</span></h3><p><span class="koboSpan" id="kobo.697.1">Never over-engineer your concurrent program. </span><span class="koboSpan" id="kobo.697.2">Only use those concurrency libraries that help you solve your specific programming task.</span></p></div></div><p><span class="koboSpan" id="kobo.698.1">Having studied how to combine different concurrency libraries in a larger application, and having caught a glimpse of how to pick the correct concurrency library, we turn our attention to another aspect of dealing with concurrency, namely, debugging concurrent programs.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Debugging concurrent programs"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec61"/><span class="koboSpan" id="kobo.1.1">Debugging concurrent programs</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Concurrent programming is much harder than sequential programming. </span><span class="koboSpan" id="kobo.2.2">There are multiple reasons for this. </span><span class="koboSpan" id="kobo.2.3">First, the details of the memory model are much more important in concurrent programming, resulting in increased programming complexity. </span><span class="koboSpan" id="kobo.2.4">Even on a platform with a well-defined memory model, such as the JVM, the programmer must take care to use proper memory access primitives in order to avoid data races. </span><span class="koboSpan" id="kobo.2.5">Then, it is harder to track the execution of a multithreaded program, simply because there are multiple executions proceeding simultaneously. </span><span class="koboSpan" id="kobo.2.6">Language debuggers are still focused on tracking the execution of a single thread at a time. </span><span class="koboSpan" id="kobo.2.7">Deadlocks and inherent nondeterminism are another source of bugs, neither of which is common in sequential programs. </span><span class="koboSpan" id="kobo.2.8">To make things worse, all these issues only have to do with ensuring the correctness of a concurrent program. </span><span class="koboSpan" id="kobo.2.9">Ensuring improved throughput and performance opens a separate set of problems, and is often harder than it sounds. </span><span class="koboSpan" id="kobo.2.10">Generally, a lot of effort is required to ensure that a concurrent program really runs faster, and performance debugging is an art of its own.</span></p><p><span class="koboSpan" id="kobo.3.1">In this section, we survey some of the typical causes of errors in concurrent programs, and inspect different methods of dealing with them. </span><span class="koboSpan" id="kobo.3.2">We start with the simplest form of concurrency bugs, which are revealed by a lack of progress in the system.</span></p><div class="section" title="Deadlocks and lack of progress"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec86"/><span class="koboSpan" id="kobo.4.1">Deadlocks and lack of progress</span></h2></div></div></div><p><span class="koboSpan" id="kobo.5.1">Despite the scariness typically associated with the term deadlock, when it comes to debugging concurrent programs, deadlocks are one of the more benevolent forms of concurrency bugs you will encounter. </span><span class="koboSpan" id="kobo.5.2">The reason for this is that deadlocks are easy to track down and analyze. </span><span class="koboSpan" id="kobo.5.3">In this section, we study how to identify and resolve a deadlock in a concurrent program.</span></p><p><span class="koboSpan" id="kobo.6.1">Before we begin, we will make sure that SBT starts the example programs in a separate JVM process. </span><span class="koboSpan" id="kobo.6.2">To do this, we enter the following command into the SBT interactive shell:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.7.1">&gt; set fork := true</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.8.1">In </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.9.1">Chapter 2</span></a><span class="koboSpan" id="kobo.10.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.11.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.12.1">, we discussed at length what deadlocks are and why they occur. </span><span class="koboSpan" id="kobo.12.2">Here, we recall the bank account example introduced in that chapter, which is a canonical example of a deadlock. </span><span class="koboSpan" id="kobo.12.3">The bank account example consisted of an </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Account</span></code><span class="koboSpan" id="kobo.14.1"> class and the </span><code class="literal"><span class="koboSpan" id="kobo.15.1">send</span></code><span class="koboSpan" id="kobo.16.1"> method, which locks two </span><code class="literal"><span class="koboSpan" id="kobo.17.1">Account</span></code><span class="koboSpan" id="kobo.18.1"> objects, and transfers a certain amount of money between them:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.19.1">class Account(var money: Int) 
 
def send(a: Account, b: Account, n: Int) = a.synchronized { 
  b.synchronized { 
    a.money -= n 
    b.money += n 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.20.1">A deadlock nondeterministically occurs when we simultaneously make an attempt to transfer money from account </span><code class="literal"><span class="koboSpan" id="kobo.21.1">a</span></code><span class="koboSpan" id="kobo.22.1"> to account </span><code class="literal"><span class="koboSpan" id="kobo.23.1">b</span></code><span class="koboSpan" id="kobo.24.1">, and vice versa, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">val a = new Account(1000) 
val b = new Account(2000) 
val t1 = ch2.thread { for (i &lt;- 0 until 100) send(a, b, 1) } 
val t2 = ch2.thread { for (i &lt;- 0 until 100) send(b, a, 1) } 
t1.join() 
t2.join() 
</span></pre><p><span class="koboSpan" id="kobo.26.1">In the preceding snippet, we are using the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">thread</span></code><span class="koboSpan" id="kobo.28.1"> method for the thread creation from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.29.1">Chapter 2</span></a><span class="koboSpan" id="kobo.30.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.31.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">This program never completes, as the </span><code class="literal"><span class="koboSpan" id="kobo.33.1">t1</span></code><span class="koboSpan" id="kobo.34.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.35.1">t2</span></code><span class="koboSpan" id="kobo.36.1"> threads get suspended in the deadlock state. </span><span class="koboSpan" id="kobo.36.2">In a larger program, this effect manifests itself as a lack of response. </span><span class="koboSpan" id="kobo.36.3">When a concurrent program fails to produce a result or an end, this is a good indication that part of it is in the deadlock state.</span></p><p><span class="koboSpan" id="kobo.37.1">Usually, the most difficult part in debugging a deadlock is localizing it. </span><span class="koboSpan" id="kobo.37.2">While this is easy to determine in our simple example, it is much harder in a larger application. </span><span class="koboSpan" id="kobo.37.3">However, a defining feature of a deadlock is the lack of any progress, and we can use this to our advantage to determine its cause; we simply need to find the threads that are in a blocked state, and determine their stack-traces.</span></p><p><span class="koboSpan" id="kobo.38.1">The Java VisualVM tool, which comes bundled with newer JDK distributions, is the simplest way to determine the state of the running Scala and Java applications. </span><span class="koboSpan" id="kobo.38.2">Without exiting our deadlocked program, we run the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">jvisualvm</span></code><span class="koboSpan" id="kobo.40.1"> program from another terminal instance as follows:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.41.1">$ jvisualvm</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.42.1">Once run, the Java VisualVM application shows all the active JVM processes on the current machine. </span><span class="koboSpan" id="kobo.42.2">In the following screenshot, the Java VisualVM application shows us the SBT process, our deadlock example program, and VisualVM itself, as the running instances:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.43.1"><img src="graphics/image_09_004.jpg" alt="Deadlocks and lack of progress"/></span></div><p><span class="koboSpan" id="kobo.44.1">After clicking on the example process, we get the report shown in the following screenshot:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.45.1"><img src="graphics/image_09_005.jpg" alt="Deadlocks and lack of progress"/></span></div><p><span class="koboSpan" id="kobo.46.1">The preceding screenshot shows that there are multiple threads running inside the example process. </span><span class="koboSpan" id="kobo.46.2">Most of these threads are part of the virtual machine runtime, and not under the direct control of the programmer. </span><span class="koboSpan" id="kobo.46.3">Other threads, such as </span><span class="strong"><strong><span class="koboSpan" id="kobo.47.1">main</span></strong></span><span class="koboSpan" id="kobo.48.1">, </span><span class="strong"><strong><span class="koboSpan" id="kobo.49.1">Thread-0</span></strong></span><span class="koboSpan" id="kobo.50.1">, and </span><span class="strong"><strong><span class="koboSpan" id="kobo.51.1">Thread-1</span></strong></span><span class="koboSpan" id="kobo.52.1"> are created by our program.</span></p><p><span class="koboSpan" id="kobo.53.1">To determine the cause of the deadlock, we need to inspect the threads in the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">BLOCKED</span></code><span class="koboSpan" id="kobo.55.1"> state. </span><span class="koboSpan" id="kobo.55.2">By examining their stack-traces, we can determine the cycle that is causing the deadlock. </span><span class="koboSpan" id="kobo.55.3">In this case, Java VisualVM was smart enough to automatically determine the cause of the deadlock, and displays the deadlocked threads with the red bar.</span></p><p><span class="koboSpan" id="kobo.56.1">After clicking on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.57.1">Thread Dump</span></strong></span><span class="koboSpan" id="kobo.58.1"> button, Java VisualVM displays the stack traces of all the threads, as shown in the following screenshot:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.59.1"><img src="graphics/image_09_006.jpg" alt="Deadlocks and lack of progress"/></span></div><p><span class="koboSpan" id="kobo.60.1">The stack traces in the preceding screenshot tell us exactly where in the program the threads are blocked, and why. </span><span class="koboSpan" id="kobo.60.2">Both </span><span class="strong"><strong><span class="koboSpan" id="kobo.61.1">Thread-0</span></strong></span><span class="koboSpan" id="kobo.62.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.63.1">Thread-1</span></strong></span><span class="koboSpan" id="kobo.64.1"> threads are suspended in line 15 of the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">Debugging.scala</span></code><span class="koboSpan" id="kobo.66.1"> file. </span><span class="koboSpan" id="kobo.66.2">Inspecting these lines of code in our editor reveals that both the threads are blocked on the nested </span><code class="literal"><span class="koboSpan" id="kobo.67.1">synchronized</span></code><span class="koboSpan" id="kobo.68.1"> statement. </span><span class="koboSpan" id="kobo.68.2">We now know that the cause of the deadlock is the inverted locking order in the </span><code class="literal"><span class="koboSpan" id="kobo.69.1">send</span></code><span class="koboSpan" id="kobo.70.1"> method.</span></p><p><span class="koboSpan" id="kobo.71.1">We've already discussed how to deal with this type of a deadlock in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.72.1">Chapter 2</span></a><span class="koboSpan" id="kobo.73.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.74.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">Enforcing a locking order in the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">send</span></code><span class="koboSpan" id="kobo.77.1"> method is a textbook example of dealing with deadlocks, and is easy to ensure by assigning unique identifiers to different locks.</span></p><p><span class="koboSpan" id="kobo.78.1">In some cases, we are not able to enforce the locking order to avoid deadlocks. </span><span class="koboSpan" id="kobo.78.2">For example, in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.79.1">Chapter 3</span></a><span class="koboSpan" id="kobo.80.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.81.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.82.1">, we learned that the lazy values initialization implicitly calls the </span><code class="literal"><span class="koboSpan" id="kobo.83.1">synchronized</span></code><span class="koboSpan" id="kobo.84.1"> statement without our control. </span><span class="koboSpan" id="kobo.84.2">There, we eluded deadlocks by avoiding the explicit </span><code class="literal"><span class="koboSpan" id="kobo.85.1">synchronized</span></code><span class="koboSpan" id="kobo.86.1"> statements on the object enclosing the lazy value. </span><span class="koboSpan" id="kobo.86.2">Another way of preventing deadlocks is to avoid blocking when a resource is not available. </span><span class="koboSpan" id="kobo.86.3">In </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.87.1">Chapter 3</span></a><span class="koboSpan" id="kobo.88.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.89.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.90.1">, we learned that custom locks can return an error value, letting the rest of the program decide how to proceed if a lock is not available.</span></p><p><span class="koboSpan" id="kobo.91.1">Besides deadlocks, there are other kinds of concurrency bugs that are associated with a lack of progress. </span><span class="koboSpan" id="kobo.91.2">We've already seen examples of </span><span class="strong"><strong><span class="koboSpan" id="kobo.92.1">starvation</span></strong></span><span class="koboSpan" id="kobo.93.1">, in which a concurrent computation is denied access to the required resources. </span><span class="koboSpan" id="kobo.93.2">In </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.94.1">Chapter 4</span></a><span class="koboSpan" id="kobo.95.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.96.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.97.1">, we started many futures simultaneously, and suspended them by calling the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">sleep</span></code><span class="koboSpan" id="kobo.99.1"> method. </span><span class="koboSpan" id="kobo.99.2">As a result, the thread-pool underlying the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.101.1"> object became exhausted, and no additional futures could execute until the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">sleep</span></code><span class="koboSpan" id="kobo.103.1"> method returned.</span></p><p><span class="koboSpan" id="kobo.104.1">In a </span><span class="strong"><strong><span class="koboSpan" id="kobo.105.1">livelock</span></strong></span><span class="koboSpan" id="kobo.106.1">, different concurrent computations are not suspended, and constantly change their state, but are unable to make progress. </span><span class="koboSpan" id="kobo.106.2">A livelock is akin to the situation in which two people approach each other on the street, and constantly try to move to the opposite side in order to allow the other person to pass. </span><span class="koboSpan" id="kobo.106.3">As a result, neither person moves on, and they constantly move from one side to the other. </span><span class="koboSpan" id="kobo.106.4">What is common to these kinds of errors is that the system makes no or very little progress, making them easy to identify.</span></p><p><span class="koboSpan" id="kobo.107.1">Looking for a deadlock is like hunting for a dead animal. </span><span class="koboSpan" id="kobo.107.2">Since it implies no progress, a deadlock is tracked down more easily than other kinds of concurrency bugs. </span><span class="koboSpan" id="kobo.107.3">In the following section, we will study a more malevolent class of concurrency errors that manifest themselves through incorrect program outputs.</span></p></div><div class="section" title="Debugging incorrect program outputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec87"/><span class="koboSpan" id="kobo.108.1">Debugging incorrect program outputs</span></h2></div></div></div><p><span class="koboSpan" id="kobo.109.1">In this section, we study a broader range of concurrency bugs that manifest themselves as incorrect outputs of the program. </span><span class="koboSpan" id="kobo.109.2">Generally, these kinds of errors are harder to track, because their effects become apparent long after the actual error took place. </span><span class="koboSpan" id="kobo.109.3">A real-world example of such an error is a piece of broken glass lying on the road. </span><span class="koboSpan" id="kobo.109.4">You don't see the glass when you drive your car, and accidentally run over it. </span><span class="koboSpan" id="kobo.109.5">By the time your tire runs flat and you realize what happened, it is difficult to figure out where exactly along the road the glass was.</span></p><p><span class="koboSpan" id="kobo.110.1">There are two main ways in which an error can appear. </span><span class="koboSpan" id="kobo.110.2">First, the concurrent program can consistently produce the same erroneous outputs. </span><span class="koboSpan" id="kobo.110.3">When this happens, we can consider ourselves lucky, as we are able to consistently reproduce the error to study it. </span><span class="koboSpan" id="kobo.110.4">Conversely, the incorrect output might appear only occasionally, in some executions of the program. </span><span class="koboSpan" id="kobo.110.5">This is a much less desired situation. </span><span class="koboSpan" id="kobo.110.6">A buggy concurrent program might exhibit incorrect behavior only occasionally due to its inherent nondeterminism. </span><span class="koboSpan" id="kobo.110.7">We will look at both deterministic and nondeterministic errors in the rest of the section.</span></p><p><span class="koboSpan" id="kobo.111.1">The goal of this section will be to implement the </span><code class="literal"><span class="koboSpan" id="kobo.112.1">fold</span></code><span class="koboSpan" id="kobo.113.1"> method on futures. </span><span class="koboSpan" id="kobo.113.2">Given a sequence of future objects, a zero value, and the </span><code class="literal"><span class="koboSpan" id="kobo.114.1">folding</span></code><span class="koboSpan" id="kobo.115.1"> operator, the </span><code class="literal"><span class="koboSpan" id="kobo.116.1">fold</span></code><span class="koboSpan" id="kobo.117.1"> method will return a future object with the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">folding</span></code><span class="koboSpan" id="kobo.119.1"> operator that is applied between all the values. </span><span class="koboSpan" id="kobo.119.2">We will require the </span><code class="literal"><span class="koboSpan" id="kobo.120.1">folding</span></code><span class="koboSpan" id="kobo.121.1"> operator to be commutative, associative, and without side effects. </span><span class="koboSpan" id="kobo.121.2">The </span><code class="literal"><span class="koboSpan" id="kobo.122.1">fold</span></code><span class="koboSpan" id="kobo.123.1"> method will closely correspond to the </span><code class="literal"><span class="koboSpan" id="kobo.124.1">foldLeft</span></code><span class="koboSpan" id="kobo.125.1"> method on collections. </span><span class="koboSpan" id="kobo.125.2">The signature of the </span><code class="literal"><span class="koboSpan" id="kobo.126.1">fold</span></code><span class="koboSpan" id="kobo.127.1"> method on futures will be as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.128.1">def fold[T](fs: Seq[Future[T]])(z: T)(op: (T, T) =&gt; T): Future[T] 
</span></pre><p><span class="koboSpan" id="kobo.129.1">One use case for the </span><code class="literal"><span class="koboSpan" id="kobo.130.1">fold</span></code><span class="koboSpan" id="kobo.131.1"> method is to compute the sum of the values in many different future objects, which cannot be done directly with the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">foldLeft</span></code><span class="koboSpan" id="kobo.133.1"> method on collections. </span><span class="koboSpan" id="kobo.133.2">This is illustrated in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.134.1">val fs: Seq[Future[Int]] = for (i &lt;- 0 until 5) yield Future { i } 
val sum: Future[Int] = fold(fs)(0)(_ + _) 
</span></pre><p><span class="koboSpan" id="kobo.135.1">We will implement the </span><code class="literal"><span class="koboSpan" id="kobo.136.1">fold</span></code><span class="koboSpan" id="kobo.137.1"> method in two steps. </span><span class="koboSpan" id="kobo.137.2">First, we will accumulate the values from all the values in the </span><code class="literal"><span class="koboSpan" id="kobo.138.1">fs</span></code><span class="koboSpan" id="kobo.139.1"> sequence by applying the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">op</span></code><span class="koboSpan" id="kobo.141.1"> operator on them. </span><span class="koboSpan" id="kobo.141.2">Accumulating the values will give us the accumulation value of the resulting future. </span><span class="koboSpan" id="kobo.141.3">Then, after all the futures complete, we will complete the resulting future with the accumulation value.</span></p><p><span class="koboSpan" id="kobo.142.1">We start by implementing several basic concurrency abstractions that will help us implement the </span><code class="literal"><span class="koboSpan" id="kobo.143.1">fold</span></code><span class="koboSpan" id="kobo.144.1"> method. </span><span class="koboSpan" id="kobo.144.2">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.145.1">concurrent accumulator</span></strong></span><span class="koboSpan" id="kobo.146.1"> is a concurrency facility that allows you to keep track of an accumulation of values. </span><span class="koboSpan" id="kobo.146.2">Here, the values can be integers, and the accumulation can be their sum. </span><span class="koboSpan" id="kobo.146.3">A concurrent accumulator comes with the </span><code class="literal"><span class="koboSpan" id="kobo.147.1">add</span></code><span class="koboSpan" id="kobo.148.1"> method that is used to add new values, and the </span><code class="literal"><span class="koboSpan" id="kobo.149.1">apply</span></code><span class="koboSpan" id="kobo.150.1"> method that is used to obtain the current state of the accumulation. </span><span class="koboSpan" id="kobo.150.2">We present the simplest possible lock-free implementation of a concurrent accumulator, which uses atomic variables from </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.151.1">Chapter 3</span></a><span class="koboSpan" id="kobo.152.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.153.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.154.1">. </span><span class="koboSpan" id="kobo.154.2">The </span><code class="literal"><span class="koboSpan" id="kobo.155.1">Accumulator</span></code><span class="koboSpan" id="kobo.156.1"> class takes the type </span><code class="literal"><span class="koboSpan" id="kobo.157.1">T</span></code><span class="koboSpan" id="kobo.158.1"> of the accumulation, a </span><code class="literal"><span class="koboSpan" id="kobo.159.1">z</span></code><span class="koboSpan" id="kobo.160.1"> initial value, and an </span><code class="literal"><span class="koboSpan" id="kobo.161.1">op</span></code><span class="koboSpan" id="kobo.162.1"> reduction operator, and is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.163.1">class Accumulator[T](z: T)(op: (T, T) =&gt; T) { 
  private val value = new AtomicReference(z) 
  def apply(): T = value.get 
  @tailrec final def add(v: T): Unit = { 
    val ov = value.get 
    val nv = op(ov, v) 
    if (!value.compareAndSet(ov, nv)) add(v) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.164.1">The </span><code class="literal"><span class="koboSpan" id="kobo.165.1">Accumulator</span></code><span class="koboSpan" id="kobo.166.1"> implementation has a private atomic variable, named </span><code class="literal"><span class="koboSpan" id="kobo.167.1">value</span></code><span class="koboSpan" id="kobo.168.1">, initialized with the </span><code class="literal"><span class="koboSpan" id="kobo.169.1">z</span></code><span class="koboSpan" id="kobo.170.1"> value, and is used to track the value of the accumulation. </span><span class="koboSpan" id="kobo.170.2">The </span><code class="literal"><span class="koboSpan" id="kobo.171.1">apply</span></code><span class="koboSpan" id="kobo.172.1"> method is easy to implement; we simply call the linearizable </span><code class="literal"><span class="koboSpan" id="kobo.173.1">get</span></code><span class="koboSpan" id="kobo.174.1"> method to obtain the current accumulation value. </span><span class="koboSpan" id="kobo.174.2">The </span><code class="literal"><span class="koboSpan" id="kobo.175.1">add</span></code><span class="koboSpan" id="kobo.176.1"> method must use the </span><code class="literal"><span class="koboSpan" id="kobo.177.1">compareAndSet</span></code><span class="koboSpan" id="kobo.178.1"> operation to atomically update the accumulation. </span><span class="koboSpan" id="kobo.178.2">Here, we read the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">ov</span></code><span class="koboSpan" id="kobo.180.1"> current value of the atomic variable, call the </span><code class="literal"><span class="koboSpan" id="kobo.181.1">op</span></code><span class="koboSpan" id="kobo.182.1"> operator to compute the new </span><code class="literal"><span class="koboSpan" id="kobo.183.1">nv</span></code><span class="koboSpan" id="kobo.184.1"> accumulation value, and, finally, call the </span><code class="literal"><span class="koboSpan" id="kobo.185.1">compareAndSet</span></code><span class="koboSpan" id="kobo.186.1"> operation to replace the old </span><code class="literal"><span class="koboSpan" id="kobo.187.1">ov</span></code><span class="koboSpan" id="kobo.188.1"> accumulation value with the new </span><code class="literal"><span class="koboSpan" id="kobo.189.1">nv</span></code><span class="koboSpan" id="kobo.190.1"> value. </span><span class="koboSpan" id="kobo.190.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.191.1">compareAndSet</span></code><span class="koboSpan" id="kobo.192.1"> operation returns </span><code class="literal"><span class="koboSpan" id="kobo.193.1">false</span></code><span class="koboSpan" id="kobo.194.1">, then the accumulation was modified, as it was previously read, and the tail-recursive </span><code class="literal"><span class="koboSpan" id="kobo.195.1">add</span></code><span class="koboSpan" id="kobo.196.1"> operation must be retried. </span><span class="koboSpan" id="kobo.196.2">We studied this technique at length in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.197.1">Chapter 3</span></a><span class="koboSpan" id="kobo.198.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.199.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.200.1">.</span></p><p><span class="koboSpan" id="kobo.201.1">Note that, because of the retries, the </span><code class="literal"><span class="koboSpan" id="kobo.202.1">op</span></code><span class="koboSpan" id="kobo.203.1"> operator can be invoked multiple times with the same </span><code class="literal"><span class="koboSpan" id="kobo.204.1">v</span></code><span class="koboSpan" id="kobo.205.1"> argument. </span><span class="koboSpan" id="kobo.205.2">Therefore, our lock-free concurrent accumulator implementation only works correctly with a reduction operator that is free from side effects.</span></p><p><span class="koboSpan" id="kobo.206.1">Next, we will need a facility that allows different futures to synchronize. </span><span class="koboSpan" id="kobo.206.2">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.207.1">countdown latch</span></strong></span><span class="koboSpan" id="kobo.208.1"> is a synchronization primitive that performs a specific action once a specified number of threads agree that the action can be performed. </span><span class="koboSpan" id="kobo.208.2">Our </span><code class="literal"><span class="koboSpan" id="kobo.209.1">CountDownLatch</span></code><span class="koboSpan" id="kobo.210.1"> class takes the number of threads </span><code class="literal"><span class="koboSpan" id="kobo.211.1">n</span></code><span class="koboSpan" id="kobo.212.1">, and an </span><code class="literal"><span class="koboSpan" id="kobo.213.1">action</span></code><span class="koboSpan" id="kobo.214.1"> block. </span><span class="koboSpan" id="kobo.214.2">The latch keeps an atomic integer variable, named </span><code class="literal"><span class="koboSpan" id="kobo.215.1">left</span></code><span class="koboSpan" id="kobo.216.1">, with the current countdown value, and defines a </span><code class="literal"><span class="koboSpan" id="kobo.217.1">count</span></code><span class="koboSpan" id="kobo.218.1"> method, which decreases the value of the </span><code class="literal"><span class="koboSpan" id="kobo.219.1">left</span></code><span class="koboSpan" id="kobo.220.1"> atomic variable. </span><span class="koboSpan" id="kobo.220.2">After </span><code class="literal"><span class="koboSpan" id="kobo.221.1">n</span></code><span class="koboSpan" id="kobo.222.1"> calls of the </span><code class="literal"><span class="koboSpan" id="kobo.223.1">count</span></code><span class="koboSpan" id="kobo.224.1"> method, the </span><code class="literal"><span class="koboSpan" id="kobo.225.1">action</span></code><span class="koboSpan" id="kobo.226.1"> block is invoked once. </span><span class="koboSpan" id="kobo.226.2">This is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.227.1">class CountDownLatch(n: Int)(action: =&gt;Unit) { 
  private val left = new AtomicInteger(n) 
  def count() = 
    if (left.decrementAndGet() &lt;= 1) action 
} 
</span></pre><p><span class="koboSpan" id="kobo.228.1">We now have all the prerequisites for implementing the </span><code class="literal"><span class="koboSpan" id="kobo.229.1">fold</span></code><span class="koboSpan" id="kobo.230.1"> method. </span><span class="koboSpan" id="kobo.230.2">This method needs to return a future object, so we start by instantiating a promise object. </span><span class="koboSpan" id="kobo.230.3">The promise will enable us to return the future object corresponding to the promise. </span><span class="koboSpan" id="kobo.230.4">We have seen this pattern many times in </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.231.1">Chapter 4</span></a><span class="koboSpan" id="kobo.232.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.233.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">Next, we need some way of combining the values from the different futures, so we instantiate an </span><code class="literal"><span class="koboSpan" id="kobo.235.1">Accumulator</span></code><span class="koboSpan" id="kobo.236.1"> object with the initial </span><code class="literal"><span class="koboSpan" id="kobo.237.1">z</span></code><span class="koboSpan" id="kobo.238.1"> value and the </span><code class="literal"><span class="koboSpan" id="kobo.239.1">op</span></code><span class="koboSpan" id="kobo.240.1"> reduction operator. </span><span class="koboSpan" id="kobo.240.2">We can complete the promise with the value of the accumulator only after all the futures complete, so we create a countdown latch with the countdown value set to the number of the futures. </span><span class="koboSpan" id="kobo.240.3">The action associated with the countdown latch completes the promise with the value of the accumulator, and we decide to use the </span><code class="literal"><span class="koboSpan" id="kobo.241.1">trySuccess</span></code><span class="koboSpan" id="kobo.242.1"> method for this purpose. </span><span class="koboSpan" id="kobo.242.2">Finally, we need to install callbacks on all the futures, which update the accumulator, and then call the </span><code class="literal"><span class="koboSpan" id="kobo.243.1">count</span></code><span class="koboSpan" id="kobo.244.1"> method on the latch. </span><span class="koboSpan" id="kobo.244.2">The complete implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.245.1">fold</span></code><span class="koboSpan" id="kobo.246.1"> method is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.247.1">def fold[T](fs: Seq[Future[T]])(z: T)(op: (T, T) =&gt; T) = { 
  val p = Promise[T]() 
  val accu = new Accumulator(z)(op) 
  val latch = new CountDownLatch(fs.length)({ 
    p.trySuccess(accu())) 
  }) 
  for (f &lt;- fs) f foreach { case v =&gt; 
    accu.add(v) 
    latch.count() 
  } 
  p.future 
} 
</span></pre><p><span class="koboSpan" id="kobo.248.1">If you paid close attention, you might have noticed that we deliberately introduced an error somewhere in the </span><code class="literal"><span class="koboSpan" id="kobo.249.1">fold</span></code><span class="koboSpan" id="kobo.250.1"> implementation. </span><span class="koboSpan" id="kobo.250.2">Don't worry if you did not notice this error yet, as we will now analyze how the error manifests itself, and how to identify it. </span><span class="koboSpan" id="kobo.250.3">To test the </span><code class="literal"><span class="koboSpan" id="kobo.251.1">fold</span></code><span class="koboSpan" id="kobo.252.1"> method, we run the following example program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.253.1">val fs = for (i &lt;- 0 until 5) yield Future { i } 
val folded = fold(fs)(0)(_ + _) 
folded foreach { case v =&gt; log(s"folded: $v") } 
</span></pre><p><span class="koboSpan" id="kobo.254.1">On our machine, running this program prints the correct value </span><code class="literal"><span class="koboSpan" id="kobo.255.1">10</span></code><span class="koboSpan" id="kobo.256.1">. </span><span class="koboSpan" id="kobo.256.2">We already feel confident that we implemented the program correctly, but we run the program again, just to be sure. </span><span class="koboSpan" id="kobo.256.3">This time, however, the program outputs the value </span><code class="literal"><span class="koboSpan" id="kobo.257.1">7</span></code><span class="koboSpan" id="kobo.258.1">. </span><span class="koboSpan" id="kobo.258.2">It turns out that we have a bug in our implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.259.1">fold</span></code><span class="koboSpan" id="kobo.260.1"> method. </span><span class="koboSpan" id="kobo.260.2">Even worse, the bug manifests itself nondeterministically!</span></p><p><span class="koboSpan" id="kobo.261.1">In sequential programming, the normal response would be to use the debugger, and proceed stepwise through the program, until we reach the buggy behavior. </span><span class="koboSpan" id="kobo.261.2">In concurrent programming, this approach often does not help. </span><span class="koboSpan" id="kobo.261.3">By tracking the progress of one thread in the debugger, we are arbitrarily delaying it, and changing the execution schedule of the program. </span><span class="koboSpan" id="kobo.261.4">The bug appears nondeterministically, so it might not appear when we run the program in the debugger.</span></p><p><span class="koboSpan" id="kobo.262.1">Instead of going forward through the program, to find the culprit, we work our way backwards through the code. </span><span class="koboSpan" id="kobo.262.2">The future is completed with the incorrect value, meaning that some thread must have inserted the incorrect value into the corresponding promise. </span><span class="koboSpan" id="kobo.262.3">We should insert a breakpoint at the promise completion point and observe what happens. </span><span class="koboSpan" id="kobo.262.4">To keep things simple, we avoid using the debugger, and insert a simple </span><code class="literal"><span class="koboSpan" id="kobo.263.1">println</span></code><span class="koboSpan" id="kobo.264.1"> statement to track the value with which the promise is completed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.265.1">val total = accu() 
println(total) 
p.trySuccess(total) 
</span></pre><p><span class="koboSpan" id="kobo.266.1">Running the program again gives the following output:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.267.1">8</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.268.1">10</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.269.1">ForkJoinPool-1-worker-1: folded: 8</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.270.1">This reveals a surprising fact: the promise is, in fact, completed twice. </span><span class="koboSpan" id="kobo.270.2">The first time, some thread uses the value </span><code class="literal"><span class="koboSpan" id="kobo.271.1">8</span></code><span class="koboSpan" id="kobo.272.1"> of the accumulator, and the second time, another thread uses the value </span><code class="literal"><span class="koboSpan" id="kobo.273.1">10</span></code><span class="koboSpan" id="kobo.274.1">. </span><span class="koboSpan" id="kobo.274.2">This also means that the </span><code class="literal"><span class="koboSpan" id="kobo.275.1">action</span></code><span class="koboSpan" id="kobo.276.1"> block of the countdown latch was called twice, so we need to find out why. </span><span class="koboSpan" id="kobo.276.2">We therefore modify the </span><code class="literal"><span class="koboSpan" id="kobo.277.1">count</span></code><span class="koboSpan" id="kobo.278.1"> method in order to track when the </span><code class="literal"><span class="koboSpan" id="kobo.279.1">action</span></code><span class="koboSpan" id="kobo.280.1"> block is called:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.281.1">def count() = { 
  val v = left.decrementAndGet() 
  if (v &lt;= 1) { 
    println(v) 
    action 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.282.1">The program output now shows the following content:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.283.1">1</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.284.1">0</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.285.1">ForkJoinPool-1-worker-15: folded: 7</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.286.1">It appears that the </span><code class="literal"><span class="koboSpan" id="kobo.287.1">action</span></code><span class="koboSpan" id="kobo.288.1"> block is called not only on the last decrement, but also on one before the last. </span><span class="koboSpan" id="kobo.288.2">This is because the </span><code class="literal"><span class="koboSpan" id="kobo.289.1">decrementAndGet</span></code><span class="koboSpan" id="kobo.290.1"> method first decrements the atomic integer, and then returns its value, rather than the other way around. </span><span class="koboSpan" id="kobo.290.2">The way to fix this is to either call the </span><code class="literal"><span class="koboSpan" id="kobo.291.1">getAndDecrement</span></code><span class="koboSpan" id="kobo.292.1"> method, or change the </span><code class="literal"><span class="koboSpan" id="kobo.293.1">if</span></code><span class="koboSpan" id="kobo.294.1"> statement. </span><span class="koboSpan" id="kobo.294.2">We reimplement the </span><code class="literal"><span class="koboSpan" id="kobo.295.1">count</span></code><span class="koboSpan" id="kobo.296.1"> method as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.297.1">def count() = 
  if (left.decrementAndGet() == 0) action 
</span></pre><p><span class="koboSpan" id="kobo.298.1">Note that, if we had used the </span><code class="literal"><span class="koboSpan" id="kobo.299.1">success</span></code><span class="koboSpan" id="kobo.300.1"> method in place of </span><code class="literal"><span class="koboSpan" id="kobo.301.1">trySuccess</span></code><span class="koboSpan" id="kobo.302.1">, we would have learned about the error much earlier. </span><span class="koboSpan" id="kobo.302.2">Let's change the implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.303.1">action</span></code><span class="koboSpan" id="kobo.304.1"> block in the </span><code class="literal"><span class="koboSpan" id="kobo.305.1">fold</span></code><span class="koboSpan" id="kobo.306.1"> method to use the </span><code class="literal"><span class="koboSpan" id="kobo.307.1">success</span></code><span class="koboSpan" id="kobo.308.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.309.1">p.success(accu())) 
</span></pre><p><span class="koboSpan" id="kobo.310.1">Running the program with this change, and the previously incorrect </span><code class="literal"><span class="koboSpan" id="kobo.311.1">count</span></code><span class="koboSpan" id="kobo.312.1"> method, results in the following exception:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.313.1">java.lang.IllegalStateException: Promise already completed. 
</span></pre><p><span class="koboSpan" id="kobo.314.1">This is much better. </span><span class="koboSpan" id="kobo.314.2">The output of the program is incorrect, but the exception consistently occurs each time that the program is run. </span><span class="koboSpan" id="kobo.314.3">Along with the cause of the error, we consistently get a full stack-trace to quickly determine where the error has occurred. </span><span class="koboSpan" id="kobo.314.4">We say that the error occurs deterministically.</span></p><p><span class="koboSpan" id="kobo.315.1">Recall that, in </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.316.1">Chapter 4</span></a><span class="koboSpan" id="kobo.317.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.318.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.319.1">, we used the </span><code class="literal"><span class="koboSpan" id="kobo.320.1">tryComplete</span></code><span class="koboSpan" id="kobo.321.1"> method to implement the </span><code class="literal"><span class="koboSpan" id="kobo.322.1">or</span></code><span class="koboSpan" id="kobo.323.1"> combinator on futures. </span><span class="koboSpan" id="kobo.323.2">This combinator was inherently nondeterministic, so we were forced to use the </span><code class="literal"><span class="koboSpan" id="kobo.324.1">tryComplete</span></code><span class="koboSpan" id="kobo.325.1"> method. </span><span class="koboSpan" id="kobo.325.2">However, there is no need to use any of the </span><code class="literal"><span class="koboSpan" id="kobo.326.1">tryXYZ</span></code><span class="koboSpan" id="kobo.327.1"> methods in the </span><code class="literal"><span class="koboSpan" id="kobo.328.1">fold</span></code><span class="koboSpan" id="kobo.329.1"> implementation, as the </span><code class="literal"><span class="koboSpan" id="kobo.330.1">fold</span></code><span class="koboSpan" id="kobo.331.1"> method should always return a future with the same result. </span><span class="koboSpan" id="kobo.331.2">Wherever possible, you should use the </span><code class="literal"><span class="koboSpan" id="kobo.332.1">complete</span></code><span class="koboSpan" id="kobo.333.1">, </span><code class="literal"><span class="koboSpan" id="kobo.334.1">success</span></code><span class="koboSpan" id="kobo.335.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.336.1">failure</span></code><span class="koboSpan" id="kobo.337.1"> methods in place of the </span><code class="literal"><span class="koboSpan" id="kobo.338.1">tryComplete</span></code><span class="koboSpan" id="kobo.339.1">, </span><code class="literal"><span class="koboSpan" id="kobo.340.1">trySuccess</span></code><span class="koboSpan" id="kobo.341.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.342.1">tryFailure</span></code><span class="koboSpan" id="kobo.343.1"> methods. </span><span class="koboSpan" id="kobo.343.2">More generally, always strive for deterministic semantics, unless the program itself is inherently nondeterministic.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip106"/><span class="koboSpan" id="kobo.344.1">Tip</span></h3><p><span class="koboSpan" id="kobo.345.1">Program defensively: check for consistency violations often, prefer determinism, and fail at an early stage. </span><span class="koboSpan" id="kobo.345.2">This simplifies the debugging process when program errors arise.</span></p></div></div><p><span class="koboSpan" id="kobo.346.1">In the following section, we turn to a different correctness aspect in concurrent programs, namely, testing their performance.</span></p></div><div class="section" title="Performance debugging"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec88"/><span class="koboSpan" id="kobo.347.1">Performance debugging</span></h2></div></div></div><p><span class="koboSpan" id="kobo.348.1">When it comes to performance debugging, the field is virtually endless. </span><span class="koboSpan" id="kobo.348.2">A separate book on the subject would barely scratch the surface. </span><span class="koboSpan" id="kobo.348.3">The goal of this section is to show you two basic examples that will teach you the basics of analyzing and resolving performance problems in concurrent Scala programs.</span></p><p><span class="koboSpan" id="kobo.349.1">In recent years, processor clock rates have reached a limit, and processor vendors have struggled to improve single processor performance. </span><span class="koboSpan" id="kobo.349.2">As a consequence, multicore processors have overwhelmed the consumer market. </span><span class="koboSpan" id="kobo.349.3">Their main goal is to offer increased performance by increasing parallelism. </span><span class="koboSpan" id="kobo.349.4">Ultimately, the goal of concurrent and parallel computing is to increase the program performance.</span></p><p><span class="koboSpan" id="kobo.350.1">There are two ways in which program performance can be improved. </span><span class="koboSpan" id="kobo.350.2">The first is through optimizing the program, so that its sequential instance runs as fast as possible. </span><span class="koboSpan" id="kobo.350.3">The second approach is to run parts of the program in parallel. </span><span class="koboSpan" id="kobo.350.4">In concurrent and parallel computing, both approaches are key to achieving optimal performance. </span><span class="koboSpan" id="kobo.350.5">It does not make sense to parallelize a program that is much slower than the optimal sequential program.</span></p><p><span class="koboSpan" id="kobo.351.1">Thus, we will study both, how to optimize, and how to parallelize a concurrent program. </span><span class="koboSpan" id="kobo.351.2">We will start with a single-threaded version of the program that uses a concurrent accumulator, and ensure that it runs efficiently. </span><span class="koboSpan" id="kobo.351.3">Then, we will ensure that the program is also scalable, that is, adding additional processors makes it faster.</span></p><p><span class="koboSpan" id="kobo.352.1">The first step in debugging the performance of a parallel program is to measure its running time. </span><span class="koboSpan" id="kobo.352.2">As stated in </span><a class="link" href="ch05.html" title="Chapter 5. Data-Parallel Collections"><span class="koboSpan" id="kobo.353.1">Chapter 5</span></a><span class="koboSpan" id="kobo.354.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.355.1">Data-Parallel Collections</span></em></span><span class="koboSpan" id="kobo.356.1">, benchmarking the program performance is the only principled way of knowing how fast the program is and finding its bottlenecks. </span><span class="koboSpan" id="kobo.356.2">This task can be complicated on the JVM, due to effects such as garbage collection, JIT compilation, and adaptive optimizations.</span></p><p><span class="koboSpan" id="kobo.357.1">Fortunately, the Scala ecosystem comes with a tool called ScalaMeter, which is designed to easily test the performance of both Scala and Java programs. </span><span class="koboSpan" id="kobo.357.2">The ScalaMeter tool can be used in two ways. </span><span class="koboSpan" id="kobo.357.3">First, ScalaMeter allows defining performance regression tests, which are essentially unit tests for performance. </span><span class="koboSpan" id="kobo.357.4">Second, ScalaMeter allows inline benchmarking that is used to benchmark parts of the running application. </span><span class="koboSpan" id="kobo.357.5">In this section, we will keep things simple, and only use ScalaMeter's inline benchmarking feature. </span><span class="koboSpan" id="kobo.357.6">We add the following line to our </span><code class="literal"><span class="koboSpan" id="kobo.358.1">build.sbt</span></code><span class="koboSpan" id="kobo.359.1"> file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.360.1">libraryDependencies += 
  "com.storm-enroute" %% "scalameter-core" % "0.6" 
</span></pre><p><span class="koboSpan" id="kobo.361.1">To use ScalaMeter inside our programs, we need to import the following package:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.362.1">import org.scalameter._ 
</span></pre><p><span class="koboSpan" id="kobo.363.1">This package gives us access to the </span><code class="literal"><span class="koboSpan" id="kobo.364.1">measure</span></code><span class="koboSpan" id="kobo.365.1"> statement that is used to measure various performance metrics. </span><span class="koboSpan" id="kobo.365.2">By default, this method measures the running time of a snippet of code. </span><span class="koboSpan" id="kobo.365.3">Let's use it to measure how long it takes to add one million integers to the </span><code class="literal"><span class="koboSpan" id="kobo.366.1">Accumulator</span></code><span class="koboSpan" id="kobo.367.1"> object defined in the preceding section:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.368.1">val time = measure { 
  val acc = new Accumulator(0)(_ + _) 
  var i = 0 
  val total = 1000000 
  while (i &lt; total) { 
    acc.add(i) 
    i += 1 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.369.1">Printing the </span><code class="literal"><span class="koboSpan" id="kobo.370.1">time</span></code><span class="koboSpan" id="kobo.371.1"> value gives us the following output:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.372.1">Running time: 34.60</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.373.1">From this, we might conclude that adding one million integers takes approximately 34 milliseconds. </span><span class="koboSpan" id="kobo.373.2">However, this conclusion is wrong. </span><span class="koboSpan" id="kobo.373.3">As discussed in </span><a class="link" href="ch05.html" title="Chapter 5. Data-Parallel Collections"><span class="koboSpan" id="kobo.374.1">Chapter 5</span></a><span class="koboSpan" id="kobo.375.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.376.1">Data-Parallel Collections</span></em></span><span class="koboSpan" id="kobo.377.1">, after a JVM program is run, it goes through a warm-up phase. </span><span class="koboSpan" id="kobo.377.2">The program usually achieves the best possible performance only after the warm-up phase is completed. </span><span class="koboSpan" id="kobo.377.3">To measure the relevant running time more accurately, we need to first ensure that the JVM reached stable performance.</span></p><p><span class="koboSpan" id="kobo.378.1">The good news is that ScalaMeter can do this automatically. </span><span class="koboSpan" id="kobo.378.2">In the following code, we configure the </span><code class="literal"><span class="koboSpan" id="kobo.379.1">measure</span></code><span class="koboSpan" id="kobo.380.1"> call to use the default warmer implementation, called </span><code class="literal"><span class="koboSpan" id="kobo.381.1">Warmer.Default</span></code><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">We set several configuration parameters, such as the minimum number of warm-up runs, the maximum number of warm-up runs, and the number of benchmark runs that are used to compute the average running time. </span><span class="koboSpan" id="kobo.382.3">Finally, we set the </span><code class="literal"><span class="koboSpan" id="kobo.383.1">verbose</span></code><span class="koboSpan" id="kobo.384.1"> key to </span><code class="literal"><span class="koboSpan" id="kobo.385.1">true</span></code><span class="koboSpan" id="kobo.386.1"> in order to get more logging output about ScalaMeter's execution. </span><span class="koboSpan" id="kobo.386.2">This is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.387.1">val accTime = config( 
  Key.exec.minWarmupRuns -&gt; 20, 
  Key.exec.maxWarmupRuns -&gt; 40, 
  Key.exec.benchRuns -&gt; 30, 
  Key.verbose -&gt; true 
) withWarmer(new Warmer.Default) measure { 
  val acc = new Accumulator(0L)(_ + _) 
  var i = 0 
  val total = 1000000 
  while (i &lt; total) { 
    acc.add(i) 
    i += 1 
  } 
} 
println("Accumulator time: " + accTime) 
</span></pre><p><span class="koboSpan" id="kobo.388.1">When running this, make sure that there are no active applications running in the background on your computer. </span><span class="koboSpan" id="kobo.388.2">Running this snippet of code gives us the following output:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.389.1">18. </span><span class="koboSpan" id="kobo.389.2">warmup run running time: 17.285859</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.390.1">GC detected.</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.391.1">19. </span><span class="koboSpan" id="kobo.391.2">warmup run running time: 21.460975</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.392.1">20. </span><span class="koboSpan" id="kobo.392.2">warmup run running time: 16.557505</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.393.1">21. </span><span class="koboSpan" id="kobo.393.2">warmup run running time: 17.712535</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.394.1">22. </span><span class="koboSpan" id="kobo.394.2">warmup run running time: 16.355897</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.395.1">Steady-state detected.</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.396.1">Accumulator time: 17.24</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.397.1">We can now see how the running time changes during the warm-up runs. </span><span class="koboSpan" id="kobo.397.2">Eventually, ScalaMeter detects a steady state and outputs the running time. </span><span class="koboSpan" id="kobo.397.3">We now have a value of </span><code class="literal"><span class="koboSpan" id="kobo.398.1">17.24</span></code><span class="koboSpan" id="kobo.399.1"> milliseconds, which is a good estimate.</span></p><p><span class="koboSpan" id="kobo.400.1">A closer inspection of the ScalaMeter output reveals that, occasionally, a </span><span class="strong"><strong><span class="koboSpan" id="kobo.401.1">Garbage Collection</span></strong></span><span class="koboSpan" id="kobo.402.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.403.1">GC</span></strong></span><span class="koboSpan" id="kobo.404.1">) cycle occurs. </span><span class="koboSpan" id="kobo.404.2">These GC cycles appear periodically during the execution of our code snippet, so we conclude that something in the </span><code class="literal"><span class="koboSpan" id="kobo.405.1">add</span></code><span class="koboSpan" id="kobo.406.1"> method allocates heap objects. </span><span class="koboSpan" id="kobo.406.2">However, the </span><code class="literal"><span class="koboSpan" id="kobo.407.1">add</span></code><span class="koboSpan" id="kobo.408.1"> implementation does not contain any </span><code class="literal"><span class="koboSpan" id="kobo.409.1">new</span></code><span class="koboSpan" id="kobo.410.1"> statements. </span><span class="koboSpan" id="kobo.410.2">The object allocation must be happening implicitly somehow.</span></p><p><span class="koboSpan" id="kobo.411.1">Note that the </span><code class="literal"><span class="koboSpan" id="kobo.412.1">Accumulator</span></code><span class="koboSpan" id="kobo.413.1"> class is generic. </span><span class="koboSpan" id="kobo.413.2">It takes a </span><code class="literal"><span class="koboSpan" id="kobo.414.1">T</span></code><span class="koboSpan" id="kobo.415.1"> type parameter, which denotes the type of the accumulation. </span><span class="koboSpan" id="kobo.415.2">Scala allows using both the reference types, such as </span><code class="literal"><span class="koboSpan" id="kobo.416.1">String</span></code><span class="koboSpan" id="kobo.417.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.418.1">Option</span></code><span class="koboSpan" id="kobo.419.1">, and primitive types, such as </span><code class="literal"><span class="koboSpan" id="kobo.420.1">Int</span></code><span class="koboSpan" id="kobo.421.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.422.1">Long</span></code><span class="koboSpan" id="kobo.423.1">, as class-type parameters. </span><span class="koboSpan" id="kobo.423.2">Although this conveniently allows treating both the primitive and reference types in the same way, it has the unfortunate side effect that the primitive values passed to generic classes are converted into heap objects. </span><span class="koboSpan" id="kobo.423.3">This process is known as auto-boxing, and it hurts the performance in various ways. </span><span class="koboSpan" id="kobo.423.4">First, it is much slower than just passing a primitive value. </span><span class="koboSpan" id="kobo.423.5">Second, it causes GC cycles more frequently. </span><span class="koboSpan" id="kobo.423.6">Third, it affects cache-locality and might cause memory contention. </span><span class="koboSpan" id="kobo.423.7">In the case of the </span><code class="literal"><span class="koboSpan" id="kobo.424.1">Accumulator</span></code><span class="koboSpan" id="kobo.425.1"> class, each time we call the </span><code class="literal"><span class="koboSpan" id="kobo.426.1">add</span></code><span class="koboSpan" id="kobo.427.1"> method with a </span><code class="literal"><span class="koboSpan" id="kobo.428.1">Long</span></code><span class="koboSpan" id="kobo.429.1"> value, a </span><code class="literal"><span class="koboSpan" id="kobo.430.1">java.lang.Long</span></code><span class="koboSpan" id="kobo.431.1"> object is created on the heap.</span></p><p><span class="koboSpan" id="kobo.432.1">In practice, boxing is sometimes problematic, and sometimes not. </span><span class="koboSpan" id="kobo.432.2">Generally, it should be avoided in high-performance code. </span><span class="koboSpan" id="kobo.432.3">In our case, we can avoid boxing by creating an accumulator specialized for the </span><code class="literal"><span class="koboSpan" id="kobo.433.1">Long</span></code><span class="koboSpan" id="kobo.434.1"> values. </span><span class="koboSpan" id="kobo.434.2">We show it in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.435.1">class LongAccumulator(z: Long)(op: (Long, Long) =&gt; Long) { 
  private val value = new AtomicLong(z) 
  @tailrec final def add(v: Long): Unit = { 
    val ov = value.get 
    val nv = op(ov, v) 
    if (!value.compareAndSet(ov, nv)) add(v) 
  } 
  def apply() = value.get 
} 
</span></pre><p><span class="koboSpan" id="kobo.436.1">Re-running the program reveals that the new accumulator is almost twice as fast:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.437.1">Long accumulator time: 8.88</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.438.1">Boxing can slow down the program by a factor of anywhere between one and several dozen. </span><span class="koboSpan" id="kobo.438.2">This depends on the specific ratio of object allocations and other work, and it needs to be measured on a per-program basis.</span></p><p><span class="koboSpan" id="kobo.439.1">An unfortunate side effect is that we can only use the new accumulator implementation for </span><code class="literal"><span class="koboSpan" id="kobo.440.1">Long</span></code><span class="koboSpan" id="kobo.441.1"> values. </span><span class="koboSpan" id="kobo.441.2">However, Scala allows us to retain the generic nature of the previous </span><code class="literal"><span class="koboSpan" id="kobo.442.1">Accumulator</span></code><span class="koboSpan" id="kobo.443.1"> implementation. </span><span class="koboSpan" id="kobo.443.2">The Scala specialization feature allows the annotation of class type parameters with the </span><code class="literal"><span class="koboSpan" id="kobo.444.1">@specialized</span></code><span class="koboSpan" id="kobo.445.1"> annotation, instructing the Scala compiler to automatically generate versions of the generic class for primitive types, such as </span><code class="literal"><span class="koboSpan" id="kobo.446.1">Long</span></code><span class="koboSpan" id="kobo.447.1">, and avoid boxing. </span><span class="koboSpan" id="kobo.447.2">We will not dive any further into this topic, and instead let interested readers find out more on their own.</span></p><p><span class="koboSpan" id="kobo.448.1">Now that we know how to identify performance issues and optimize sequential programs, we study how to improve the performance by increasing the parallelism level. </span><span class="koboSpan" id="kobo.448.2">Let's parallelize the previous program by adding one million integers from four separate threads. </span><span class="koboSpan" id="kobo.448.3">This is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.449.1">val intAccTime4 = config( 
  Key.exec.minWarmupRuns -&gt; 20, 
  Key.exec.maxWarmupRuns -&gt; 40, 
  Key.exec.benchRuns -&gt; 30, 
  Key.verbose -&gt; true 
) withWarmer(new Warmer.Default) measure { 
  val acc = new LongAccumulator(0L)(_ + _) 
  val total = 1000000 
  val p = 4 
  val threads = for (j &lt;- 0 until p) yield ch2.thread { 
    val start = j * total / p 
    var i = start 
    while (i &lt; start + total / p) { 
      acc.add(i) 
      i += 1 
    } 
  } 
  for (t &lt;- threads) t.join() 
} 
println("4 threads integer accumulator time: " + intAccTime4) 
</span></pre><p><span class="koboSpan" id="kobo.450.1">In the preceding example, we distribute the work of adding 1 million integers across four different threads, so we expect the running time of the program to increase four times. </span><span class="koboSpan" id="kobo.450.2">Sadly, running the program reveals that our expectations were wrong:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.451.1">4 threads integer accumulator time: 95.85</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.452.1">As pointed out in </span><a class="link" href="ch05.html" title="Chapter 5. Data-Parallel Collections"><span class="koboSpan" id="kobo.453.1">Chapter 5</span></a><span class="koboSpan" id="kobo.454.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.455.1">Data-Parallel Collections</span></em></span><span class="koboSpan" id="kobo.456.1">, perpetually writing to the same memory location from multiple threads results in memory contention issues. </span><span class="koboSpan" id="kobo.456.2">In most computer architectures, cache-lines need to be exchanged between the processors writing to the same memory location, and this slows down the program. </span><span class="koboSpan" id="kobo.456.3">In our case, the contention point is the </span><code class="literal"><span class="koboSpan" id="kobo.457.1">AtomicLong</span></code><span class="koboSpan" id="kobo.458.1"> object in the </span><code class="literal"><span class="koboSpan" id="kobo.459.1">LongAccumulator</span></code><span class="koboSpan" id="kobo.460.1"> class. </span><span class="koboSpan" id="kobo.460.2">Simultaneously invoking the </span><code class="literal"><span class="koboSpan" id="kobo.461.1">compareAndSet</span></code><span class="koboSpan" id="kobo.462.1"> operation on the same memory location does not scale.</span></p><p><span class="koboSpan" id="kobo.463.1">To address the issue of memory contention, we need to somehow disperse the writes throughout different cache-lines. </span><span class="koboSpan" id="kobo.463.2">Instead of adding the accumulated value to a single memory location, we will maintain many memory locations with partial accumulation values. </span><span class="koboSpan" id="kobo.463.3">When some processor calls the </span><code class="literal"><span class="koboSpan" id="kobo.464.1">add</span></code><span class="koboSpan" id="kobo.465.1"> method, it will pick one of these memory locations and update the partial accumulation. </span><span class="koboSpan" id="kobo.465.2">When a processor calls the </span><code class="literal"><span class="koboSpan" id="kobo.466.1">apply</span></code><span class="koboSpan" id="kobo.467.1"> method, it will scan all the partial accumulations and add them together. </span><span class="koboSpan" id="kobo.467.2">In this implementation, we trade the performance of the </span><code class="literal"><span class="koboSpan" id="kobo.468.1">apply</span></code><span class="koboSpan" id="kobo.469.1"> method for the improved scalability of the </span><code class="literal"><span class="koboSpan" id="kobo.470.1">add</span></code><span class="koboSpan" id="kobo.471.1"> method. </span><span class="koboSpan" id="kobo.471.2">This trade-off is acceptable in many cases, including our </span><code class="literal"><span class="koboSpan" id="kobo.472.1">fold</span></code><span class="koboSpan" id="kobo.473.1"> method, where we call the </span><code class="literal"><span class="koboSpan" id="kobo.474.1">add</span></code><span class="koboSpan" id="kobo.475.1"> method many times, but the </span><code class="literal"><span class="koboSpan" id="kobo.476.1">apply</span></code><span class="koboSpan" id="kobo.477.1"> method only once.</span></p><p><span class="koboSpan" id="kobo.478.1">Furthermore, note that the new </span><code class="literal"><span class="koboSpan" id="kobo.479.1">apply</span></code><span class="koboSpan" id="kobo.480.1"> implementation is not linearizable, as explained in </span><a class="link" href="ch07.html" title="Chapter 7. Software Transactional Memory"><span class="koboSpan" id="kobo.481.1">Chapter 7</span></a><span class="koboSpan" id="kobo.482.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.483.1">Software Transactional Memory</span></em></span><span class="koboSpan" id="kobo.484.1">. </span><span class="koboSpan" id="kobo.484.2">If some processor calls the </span><code class="literal"><span class="koboSpan" id="kobo.485.1">apply</span></code><span class="koboSpan" id="kobo.486.1"> method when multiple processors are calling the </span><code class="literal"><span class="koboSpan" id="kobo.487.1">add</span></code><span class="koboSpan" id="kobo.488.1"> method, the resulting accumulation value can be slightly incorrect. </span><span class="koboSpan" id="kobo.488.2">However, if no other processor calls the </span><code class="literal"><span class="koboSpan" id="kobo.489.1">add</span></code><span class="koboSpan" id="kobo.490.1"> method when the </span><code class="literal"><span class="koboSpan" id="kobo.491.1">apply</span></code><span class="koboSpan" id="kobo.492.1"> method is called, the resulting accumulation value will be correct. </span><span class="koboSpan" id="kobo.492.2">We say that the new </span><code class="literal"><span class="koboSpan" id="kobo.493.1">apply</span></code><span class="koboSpan" id="kobo.494.1"> implementation is </span><span class="strong"><strong><span class="koboSpan" id="kobo.495.1">quiescently consistent</span></strong></span><span class="koboSpan" id="kobo.496.1"> with respect to the </span><code class="literal"><span class="koboSpan" id="kobo.497.1">add</span></code><span class="koboSpan" id="kobo.498.1"> method.</span></p><p><span class="koboSpan" id="kobo.499.1">Note that this property is sufficient for ensuring the correctness of the preceding </span><code class="literal"><span class="koboSpan" id="kobo.500.1">fold</span></code><span class="koboSpan" id="kobo.501.1"> implementation, because the </span><code class="literal"><span class="koboSpan" id="kobo.502.1">fold</span></code><span class="koboSpan" id="kobo.503.1"> method only calls the </span><code class="literal"><span class="koboSpan" id="kobo.504.1">apply</span></code><span class="koboSpan" id="kobo.505.1"> method after all the </span><code class="literal"><span class="koboSpan" id="kobo.506.1">add</span></code><span class="koboSpan" id="kobo.507.1"> calls are completed.</span></p><p><span class="koboSpan" id="kobo.508.1">We now show the implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.509.1">ParLongAccumulator</span></code><span class="koboSpan" id="kobo.510.1"> class, which uses an </span><code class="literal"><span class="koboSpan" id="kobo.511.1">AtomicLongArray</span></code><span class="koboSpan" id="kobo.512.1"> object, named </span><code class="literal"><span class="koboSpan" id="kobo.513.1">values</span></code><span class="koboSpan" id="kobo.514.1">, to keep the partial accumulation values. </span><span class="koboSpan" id="kobo.514.2">Atomic arrays are arrays on which we can call operations such as the </span><code class="literal"><span class="koboSpan" id="kobo.515.1">compareAndSet</span></code><span class="koboSpan" id="kobo.516.1"> method. </span><span class="koboSpan" id="kobo.516.2">Conceptually, an </span><code class="literal"><span class="koboSpan" id="kobo.517.1">AtomicLongArray</span></code><span class="koboSpan" id="kobo.518.1"> is equivalent to an array of </span><code class="literal"><span class="koboSpan" id="kobo.519.1">AtomicLong</span></code><span class="koboSpan" id="kobo.520.1"> objects, but is more memory-efficient.</span></p><p><span class="koboSpan" id="kobo.521.1">The </span><code class="literal"><span class="koboSpan" id="kobo.522.1">ParLongAccumulator</span></code><span class="koboSpan" id="kobo.523.1"> class must choose a proper size for the </span><code class="literal"><span class="koboSpan" id="kobo.524.1">AtomicLongArray</span></code><span class="koboSpan" id="kobo.525.1"> object. </span><span class="koboSpan" id="kobo.525.2">Setting the size of the array to the number of processors will not make the memory contention problems go away. </span><span class="koboSpan" id="kobo.525.3">Recall from </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.526.1">Chapter 3</span></a><span class="koboSpan" id="kobo.527.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.528.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.529.1">, that a processor needs to own a cache-line in exclusive mode before writing to it. </span><span class="koboSpan" id="kobo.529.2">A cache-line size is typically 64 bytes. </span><span class="koboSpan" id="kobo.529.3">This means that on a 32-bit JVM, eight consecutive entries in an </span><code class="literal"><span class="koboSpan" id="kobo.530.1">AtomicLongArray</span></code><span class="koboSpan" id="kobo.531.1"> object fit inside a single cache-line. </span><span class="koboSpan" id="kobo.531.2">Even when different processors write to separate </span><code class="literal"><span class="koboSpan" id="kobo.532.1">AtomicLongArray</span></code><span class="koboSpan" id="kobo.533.1"> entries, memory contention occurs if these entries lie in the same cache-line. </span><span class="koboSpan" id="kobo.533.2">This effect is known as </span><span class="strong"><strong><span class="koboSpan" id="kobo.534.1">false-sharing</span></strong></span><span class="koboSpan" id="kobo.535.1">. </span><span class="koboSpan" id="kobo.535.2">A necessary precondition in avoiding false-sharing is to make the array size at least eight times larger than the number of processors.</span></p><p><span class="koboSpan" id="kobo.536.1">A </span><code class="literal"><span class="koboSpan" id="kobo.537.1">ParLongAccumulator</span></code><span class="koboSpan" id="kobo.538.1"> object is used by many different threads simultaneously. </span><span class="koboSpan" id="kobo.538.2">In most programs, there are many more threads than processors. </span><span class="koboSpan" id="kobo.538.3">To reduce false-sharing, as much as possible, we set the size of the </span><code class="literal"><span class="koboSpan" id="kobo.539.1">values</span></code><span class="koboSpan" id="kobo.540.1"> array to 128 times the number of processors:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.541.1">import scala.util.hashing 
class ParLongAccumulator(z: Long)(op: (Long, Long) =&gt; Long) { 
  private val par = Runtime.getRuntime.availableProcessors * 128 
  private val values = new AtomicLongArray(par) 
  @tailrec final def add(v: Long): Unit = { 
    val id = Thread.currentThread.getId.toInt 
    val pos = math.abs(hashing.byteswap32(id)) % par 
    val ov = values.get(pos) 
    val nv = op(ov, v) 
    if (!values.compareAndSet(pos, ov, nv)) add(v) 
  } 
  def apply(): Long = { 
    var total = z 
    for (i &lt;- 0 until values.length) 
      total = op(total, values.get(i)) 
    total 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.542.1">The new </span><code class="literal"><span class="koboSpan" id="kobo.543.1">add</span></code><span class="koboSpan" id="kobo.544.1"> implementation is similar to the previous one. </span><span class="koboSpan" id="kobo.544.2">The main difference is that the new implementation needs to pick the </span><code class="literal"><span class="koboSpan" id="kobo.545.1">pos</span></code><span class="koboSpan" id="kobo.546.1"> memory location for the partial accumulation value. </span><span class="koboSpan" id="kobo.546.2">Different processors should pick different memory locations based on their index. </span><span class="koboSpan" id="kobo.546.3">Unfortunately, standard APIs on the JVM do not provide the index of the current processor. </span><span class="koboSpan" id="kobo.546.4">An adequate approximation is to compute the </span><code class="literal"><span class="koboSpan" id="kobo.547.1">pos</span></code><span class="koboSpan" id="kobo.548.1"> partial accumulation location from the current thread ID. </span><span class="koboSpan" id="kobo.548.2">We additionally use the </span><code class="literal"><span class="koboSpan" id="kobo.549.1">byteswap32</span></code><span class="koboSpan" id="kobo.550.1"> hashing function to effectively randomize the location in the array. </span><span class="koboSpan" id="kobo.550.2">This decreases the likelihood that two threads with adjacent IDs end up writing to adjacent entries in the array, and reduces the possibility of false-sharing.</span></p><p><span class="koboSpan" id="kobo.551.1">Running the program demonstrates that we reached our goal, and improved the program performance by a factor of almost three:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.552.1">Parallel integer accumulator time: 3.34</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.553.1">There are additional ways to improve our </span><code class="literal"><span class="koboSpan" id="kobo.554.1">ParLongAccumulator</span></code><span class="koboSpan" id="kobo.555.1"> class. </span><span class="koboSpan" id="kobo.555.2">One is to further reduce false sharing by choosing the entries in the </span><code class="literal"><span class="koboSpan" id="kobo.556.1">values</span></code><span class="koboSpan" id="kobo.557.1"> array more randomly. </span><span class="koboSpan" id="kobo.557.2">Another is to ensure that the </span><code class="literal"><span class="koboSpan" id="kobo.558.1">apply</span></code><span class="koboSpan" id="kobo.559.1"> method is not only quiescently consistent, but also linearizable. </span><span class="koboSpan" id="kobo.559.2">In the interest of keeping this section simple and clear, we do not dive further into these topics, but let interested readers explore them on their own.</span></p><p><span class="koboSpan" id="kobo.560.1">In this and the preceding sections, we summarized the different styles of concurrency and studied the basics of dealing with concurrency bugs. </span><span class="koboSpan" id="kobo.560.2">This gave us a useful insight into the big picture, but the theory that we learned is only valuable if it can be applied in practice. </span><span class="koboSpan" id="kobo.560.3">We designed and implemented a remote file browser application, a practical example of a large concurrent application. </span><span class="koboSpan" id="kobo.560.4">This gave us insight into both the theoretical and practical side of concurrent programming.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec62"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Having seen the technical details of a variety of different concurrency libraries in the preceding chapters, we took a couple of steps back and presented a more cohesive view of Scala concurrency. </span><span class="koboSpan" id="kobo.2.2">After presenting a taxonomy of different styles of concurrency, we outlined the use cases for different concurrency frameworks. </span><span class="koboSpan" id="kobo.2.3">We then studied how to debug concurrent programs and analyze their performance. </span><span class="koboSpan" id="kobo.2.4">Finally, we combined the different concurrency frameworks together to implement a real-world distributed application: a remote file browser.</span></p><p><span class="koboSpan" id="kobo.3.1">The best theory is inspired by practice, and the best practice is inspired by theory. </span><span class="koboSpan" id="kobo.3.2">This book has given you a fair amount of both. </span><span class="koboSpan" id="kobo.3.3">To deepen your understanding of concurrent computing, consider studying the references listed at the end of each chapter: you should already be able to grasp most of them. </span><span class="koboSpan" id="kobo.3.4">Importantly, to improve your practical concurrent programming skills, try to solve the exercises from this book. </span><span class="koboSpan" id="kobo.3.5">Finally, start building your own concurrent applications. </span><span class="koboSpan" id="kobo.3.6">By now, you must have understood both how high-level concurrency abstractions work and how to use them together, and are on the path to becoming a true concurrency expert.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec63"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The following exercises will improve your skills in building practical concurrent applications. </span><span class="koboSpan" id="kobo.2.2">Some of them require extending the ScalaFTP program from this chapter, while others require implementing concurrent applications from scratch. </span><span class="koboSpan" id="kobo.2.3">Finally, several exercises are dedicated to testing the performance and scalability of concurrent programs:</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.3.1">Extend the ScalaFTP application to allow the addition of directories to the remote filesystem.</span></li><li class="listitem"><span class="koboSpan" id="kobo.4.1">Extend the ScalaFTP application so that the changes in the server filesystem are automatically reflected in the client program.</span></li><li class="listitem"><span class="koboSpan" id="kobo.5.1">Extend the ScalaFTP application so that it allows parallel regex searches over filenames in the remote filesystem.</span></li><li class="listitem"><span class="koboSpan" id="kobo.6.1">Extend the ScalaFTP server so that it allows recursively copying directories.</span></li><li class="listitem"><span class="koboSpan" id="kobo.7.1">Implement the download and upload functionality, and use </span><code class="literal"><span class="koboSpan" id="kobo.8.1">Observable</span></code><span class="koboSpan" id="kobo.9.1"> objects to display the file transfer progress in a Swing </span><code class="literal"><span class="koboSpan" id="kobo.10.1">ProgressBar</span></code><span class="koboSpan" id="kobo.11.1"> component.</span></li><li class="listitem"><span class="koboSpan" id="kobo.12.1">Extend the ScalaFTP client implementation so that a </span><code class="literal"><span class="koboSpan" id="kobo.13.1">FilePane</span></code><span class="koboSpan" id="kobo.14.1"> can display either a remote or a local filesystem's contents.</span></li><li class="listitem"><span class="koboSpan" id="kobo.15.1">Design and implement a distributed chat application.</span></li><li class="listitem"><span class="koboSpan" id="kobo.16.1">Design and implement a Paint program with collaborative editing.</span></li><li class="listitem"><span class="koboSpan" id="kobo.17.1">Compare the duration of creating and starting a new thread, and waiting for its termination, against the duration of starting a computation using </span><code class="literal"><span class="koboSpan" id="kobo.18.1">Future.apply</span></code><span class="koboSpan" id="kobo.19.1"> and waiting for the completion of the corresponding </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Future</span></code><span class="koboSpan" id="kobo.21.1"> object.</span></li><li class="listitem"><span class="koboSpan" id="kobo.22.1">A pool is one of the simplest collection abstractions, which allows the addition and extraction of elements. </span><span class="koboSpan" id="kobo.22.2">The </span><code class="literal"><span class="koboSpan" id="kobo.23.1">remove</span></code><span class="koboSpan" id="kobo.24.1"> operation returns any element that was previously added to the pool. </span><span class="koboSpan" id="kobo.24.2">A concurrent pool is represented by the </span><code class="literal"><span class="koboSpan" id="kobo.25.1">ConcurrentPool</span></code><span class="koboSpan" id="kobo.26.1"> class:</span><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">        class ConcurrentPool[T] { 
          def add(x: T): Unit = ??? 
          </span><span class="koboSpan" id="kobo.27.2">def remove(): T = ??? 
          </span><span class="koboSpan" id="kobo.27.3">def isEmpty(): Boolean = ??? 
        </span><span class="koboSpan" id="kobo.27.4">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.28.1">Implement the concurrent pool and make sure that its operations are linearizable. </span><span class="koboSpan" id="kobo.28.2">Measure and ensure high performance and scalability of your implementation.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.29.1">Compare the performance and scalability of the Treiber stack from the exercise in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.30.1">Chapter 2</span></a><span class="koboSpan" id="kobo.31.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.32.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.33.1">, against the transactional sorted list from </span><a class="link" href="ch07.html" title="Chapter 7. Software Transactional Memory"><span class="koboSpan" id="kobo.34.1">Chapter 7</span></a><span class="koboSpan" id="kobo.35.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.36.1">Software Transactional Memory</span></em></span><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">How are they compared to the concurrent pool from the previous exercise?</span></li><li class="listitem"><span class="koboSpan" id="kobo.38.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">getUniqueId</span></code><span class="koboSpan" id="kobo.40.1"> method from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.41.1">Chapter 2</span></a><span class="koboSpan" id="kobo.42.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.43.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">Measure and ensure high performance and scalability of your implementation.</span></li><li class="listitem"><span class="koboSpan" id="kobo.45.1">Implement a lock-free concurrent linked list and a lock-based concurrent linked list that support linearizable prepend and append operations. </span><span class="koboSpan" id="kobo.45.2">Both implementations must be singly linked lists. </span><span class="koboSpan" id="kobo.45.3">Measure the performance of inserting many elements.</span></li><li class="listitem"><span class="koboSpan" id="kobo.46.1">A barrier is a concurrent object that allows </span><span class="emphasis"><em><span class="koboSpan" id="kobo.47.1">N</span></em></span><span class="koboSpan" id="kobo.48.1"> threads to synchronize at some point in the program. </span><span class="koboSpan" id="kobo.48.2">A barrier exposes a single method, </span><code class="literal"><span class="koboSpan" id="kobo.49.1">await</span></code><span class="koboSpan" id="kobo.50.1">, which effectively blocks the thread until all </span><span class="emphasis"><em><span class="koboSpan" id="kobo.51.1">N</span></em></span><span class="koboSpan" id="kobo.52.1"> threads call </span><code class="literal"><span class="koboSpan" id="kobo.53.1">await</span></code><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">After all </span><span class="emphasis"><em><span class="koboSpan" id="kobo.55.1">N</span></em></span><span class="koboSpan" id="kobo.56.1"> threads call </span><code class="literal"><span class="koboSpan" id="kobo.57.1">await</span></code><span class="koboSpan" id="kobo.58.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">await</span></code><span class="koboSpan" id="kobo.60.1"> invocations of all the threads immediately return. </span><span class="koboSpan" id="kobo.60.2">Blocking can be done, for example, by busy-waiting. </span><span class="koboSpan" id="kobo.60.3">Use atomic integers to implement a barrier. </span><span class="koboSpan" id="kobo.60.4">Measure the performance of your implementation for one, two, four, and eight threads, and some large number of calls to </span><code class="literal"><span class="koboSpan" id="kobo.61.1">await</span></code><span class="koboSpan" id="kobo.62.1">.</span></li></ol></div></div></div></div></body></html>