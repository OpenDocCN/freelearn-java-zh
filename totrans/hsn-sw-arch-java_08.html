<html><head></head><body>
		<div id="_idContainer060">
			<h1 id="_idParaDest-141"><a id="_idTextAnchor141"/>Chapter 6: Exploring Essential Java Architectural Patterns</h1>
			<p>In the last chapter, you had an overview of the most common development models, from the older (but still used) <strong class="bold">Waterfall model</strong> to the widely used and appreciated <strong class="bold">DevOps</strong> and <strong class="bold">Agile</strong>.</p>
			<p>In this chapter, you will have a look at some very common architectural patterns. These architectural definitions are often considered basic building blocks that are useful to know about in order to solve common architectural problems.</p>
			<p>You will learn about the following topics in this chapter:</p>
			<ul>
				<li>Encapsulation and hexagonal architectures</li>
				<li>Learning about multi-tier architectures</li>
				<li>Exploring Model View Controller</li>
				<li>Diving into event-driven and reactive approaches</li>
				<li>Designing for large-scale adoption</li>
				<li>Case studies and examples</li>
			</ul>
			<p>After reading this chapter, you'll know about some useful tools that can be used to translate requirements into well-designed software components that are easy to develop and maintain. All the patterns described in this chapter are, of course, orthogonal to the development models that we have seen in the previous chapters; in other words, you can use all of them regardless of the model used.</p>
			<p>Let's start with one of the most natural architectural considerations: encapsulation and hexagonal architectures.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor142"/>Encapsulation and hexagonal architectures</h1>
			<p><strong class="bold">Encapsulation</strong> is a concept taken for granted by programmers who are used to working with object-oriented <a id="_idIndexMarker566"/>programming and, indeed, it is quite a basic idea. When talking <a id="_idIndexMarker567"/>about encapsulation, your mind goes to the getters and setters methods. To put it simply, you can hide fields in your class, and control how the other objects interact with them. This is a basic way to protect the status of your object (internal data) from the outside world. In this way, you decouple the state from the behavior, and you are free to switch the data type, validate the input, change formats, and so on. In short, it's easy to understand the advantages of this approach.</p>
			<p>However, encapsulation is a concept that goes beyond simple getters and setters. I personally find some <a id="_idIndexMarker568"/>echoes of this concept in other modern approaches, such as APIs and microservices (more on this in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>). In my opinion, encapsulation (also known as <strong class="bold">information hiding</strong>) is all about modularization, in that it's about having objects talk to each other by using defined contracts.</p>
			<p>If those contracts (in this case, normal method signatures) are stable and generic enough, objects can change their internal implementation or can be swapped with other objects without breaking the overall functionality. That is, of course, a concept that fits nicely with interfaces. An interface can be seen as a <em class="italic">super contract</em> (a set of methods) and a way to easily identify compatible objects. </p>
			<p>In my personal view, the concept of encapsulation is extended with the idea of hexagonal architectures. Hexagonal architectures, theorized by Alistair Cockburn in 2005, visualize an application component as a hexagon. The following diagram illustrates this:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_6.01_B16354.jpg" alt="Figure 6.1 – Hexagonal architecture schema&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Hexagonal architecture schema</p>
			<p>As you can see in the preceding diagram, the business logic stays at the core of this representation:</p>
			<ul>
				<li><strong class="bold">Core</strong>: The core can be intended to be the domain model, as seen in <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>. It's the real distinctive part of your application component – the one solving the business problem. </li>
				<li><strong class="bold">Port</strong>: Around the core, the ports are represented. The domain model uses the ports as a way to <a id="_idIndexMarker569"/>communicate with other application components, being <a id="_idIndexMarker570"/>other modules or systems (such as databases and other infrastructures). The ports are usually mapped to use cases of the module itself (such as sending payments). However, more technical interpretations of ports are not unusual (such as persisting to a database).</li>
				<li><strong class="bold">Adapter</strong>: The layer outside the ports represents the adapters. The Adapter is a well-known pattern in which a piece of software acts as an interpreter between two different sides. In this case, it translates from the domain model to the outside world, and vice versa, according to what is defined in each port. While the diagram is in the shape of a hexagon, that's not indicative of being limited to six ports or adapters. That's just <a id="_idIndexMarker571"/>a graphical representation, probably <a id="_idIndexMarker572"/>related to the idea of representing the ports as discrete <a id="_idIndexMarker573"/>elements (which is hard to do if you represent the layers as concentric circles). The hexagonal architecture is also known as <strong class="bold">Ports and Adapters</strong>. <p class="callout-heading">Important Note:</p><p class="callout">There is another architectural model implementing encapsulation that is often compared to hexagonal architectures: <strong class="bold">Onion architectures</strong>. Whether the hexagonal architecture defines <a id="_idIndexMarker574"/>the roles mentioned earlier, such as core, ports, and adapters, the Onion architecture focuses the modeling on the concept of layers. There is an inner core (the Domain layer) and then a number of layers around it, usually including a repository (to access the data of the Domain layer), services (to implement business logic and other interactions), and a presentation layer (for interacting with the end user or other systems). Each layer is supposed to communicate only with the layer above itself.</p></li>
			</ul>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/>Hexagonal architectures and Domain Driven Design</h2>
			<p>Encapsulation is a<a id="_idIndexMarker575"/> cross-cutting concern, applicable to many aspects of a software architecture, and hexagonal architectures are a way to implement this concept. As we have seen, encapsulation has many touchpoints with the concept of <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>). The core, as mentioned, can be seen as the domain model in DDD. The Adapter pattern is also <a id="_idIndexMarker576"/>very similar to the concept of the Infrastructure layer, which in DDD is the layer mapping the domain model with the underlying technology (and abstracting such technology details).</p>
			<p>It's then worth noticing that DDD is a way more complete approach, as seen in <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>, tackling things such as defining a language for creating domain model concepts and implementing some peculiar use cases (such as where to store data, where to store implementations, how to make different models talk to each other). Conversely, hexagonal architectures are a more practical, immediate approach that may directly address a concern (such as implementing encapsulation in a structured way), but do not touch other aspects (such as how to <a id="_idIndexMarker577"/>define<a id="_idIndexMarker578"/> the objects in the core).</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor144"/>Encapsulation and microservices</h2>
			<p>While we are going to talk about microservices in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>, I'm sure you are familiar with, or at least have heard about, the concept of microservices. In this <a id="_idIndexMarker579"/>section, it's relevant to mention that the topic of encapsulation is one <a id="_idIndexMarker580"/>of the core reasonings behind microservices. Indeed, a microservice is considered to be a disposable piece of software, easy to scale and to interoperate with other similar components through a well-defined API.</p>
			<p>Moreover, each microservice composing an application is (in theory) a product, with a dedicated team behind it and using a set of technologies (including the programming language itself) different from the other microservices around it. For all those reasons, encapsulation is the basis of the microservices applications, and the concepts behind it (as the ones that we have seen in the context of hexagonal architectures) are intrinsic in microservices.</p>
			<p>So, as you now know, the concept of modularization is in some way orthogonal to software entities. This need to define clear responsibilities and specific contracts is a common way to address complexity, and it has a lot of advantages, such as testability, scaling, extensibility, and more. Another common way to define roles in a software system is the multi-tier architecture.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor145"/>Learning about multi-tier architectures</h1>
			<p><strong class="bold">Multi-tier architectures</strong>, also known as <strong class="bold">n-tier architectures</strong>, are a way to categorize software architectures based on the number and kind of tiers (or layers) encompassing the <a id="_idIndexMarker581"/>components of such a system. A tier is a logical grouping of the <a id="_idIndexMarker582"/>software components, and it's usually also reflected in the physical deployment of the components. One way of designing applications is to define the number of tiers composing them and how they communicate with each other. Then, you can define which component belongs to which tier. The most common types of multi-tier applications are defined in the following list:</p>
			<ul>
				<li>The simplest (and most useless) examples are <strong class="bold">single-tier applications</strong>, where every component <a id="_idIndexMarker583"/>falls into the same layer. So, you have <a id="_idIndexMarker584"/>what is called a monolithic application.</li>
				<li>Things get slightly more interesting in the next iteration, that is, <strong class="bold">two-tier applications</strong>. These are commonly implemented as client-server systems. You will have a layer <a id="_idIndexMarker585"/>including the components provided to <a id="_idIndexMarker586"/>end users, usually through some kind of graphical or textual user interfaces, and a layer including the <a id="_idIndexMarker587"/>backend systems, which normally implement the business rules and the transactional functionalities.</li>
				<li><strong class="bold">Three-tier applications</strong> are a very common architectural setup. In this kind of design, you have a presentation layer taking care of interaction with end users. We also have <a id="_idIndexMarker588"/>a business logic layer implementing the business logic <a id="_idIndexMarker589"/>and exposing APIs consumable by the presentation layer, and a data layer, which is responsible for storing data in a persistent way (such as in a database or on a disk).</li>
				<li>More than three layers can be contemplated, but that is less conventional, meaning that the naming and roles may vary. Usually, the additional tiers are specializations of the business logic tier, which was seen in the previous point. An example of a four-tier application was detailed in <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>, when talking about the layered architecture of DDD.</li>
			</ul>
			<p>The following diagram illustrates the various types of multi-tier architectures:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_6.02_B16354.jpg" alt="Figure 6.2 – Multi-tier architectures&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Multi-tier architectures</p>
			<p>The advantages of a multi-tier approach are similar to those that you can achieve with the modularization of your application components (more on this in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>). Some of the advantages are as follows:</p>
			<ul>
				<li>The most relevant advantage is probably <strong class="bold">scalability</strong>. This kind of architecture allows each layer <a id="_idIndexMarker590"/>to scale independently from each other. So, if you have more load on the business (or frontend, or database) layer, you can scale it (vertically, by adding more <a id="_idIndexMarker591"/>computational resources, or horizontally, by adding more instances of the same component) without having a huge impact on the other components. And that is also linked to increased stability overall: an issue on one of the layers is not so likely to influence the other layers.</li>
				<li>Another positive impact is improved <strong class="bold">testability</strong>. Since you are forced to define clearly how the <a id="_idIndexMarker592"/>layers communicate with each other (such as by defining some APIs), it becomes easier to test each layer individually by using the same communication channel.</li>
				<li><strong class="bold">Modularity</strong> is also an interesting aspect. Having layers talking to each other will enforce a well-defined <a id="_idIndexMarker593"/>API to decouple each other. For this reason, it is possible (and is very common) to have different actors on the same layer, interacting with the other layer. The most widespread example here is related to the frontend. Many applications have different versions of the frontend (such as a web GUI and a mobile app) interacting with the same underlying layer.</li>
				<li>Last but not least, by <strong class="bold">layering</strong> your application, you will end up having more parallelization in the development process. Sub teams can work on a layer without interfering with each other. The layers, in most cases, can be released individually, reducing the risks associated with a big bang release.</li>
			</ul>
			<p>There are, of course, drawbacks to the multi-tier approach, and they are similar to the ones you can observe when adopting other modular approaches, such as microservices. The main disadvantage is to do with <strong class="bold">tracing</strong>.</p>
			<p>It may become hard to understand the end-to-end path of each transaction, especially (as is common) if one call in a layer is mapped to many calls in other layers. To mitigate this, you will have to adopt specific monitoring to trace the path of each call; this is usually done by <a id="_idIndexMarker594"/>injecting unique IDs to correlate the calls to each other to help when troubleshooting is needed (such as when you want to spot where the transactions slow down) and in general to give better visibility into system behavior. We will study this approach (often referred to as tracing or observability) in more detail in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>.</p>
			<p>In the next section, we will have a look at a widespread pattern: Model View Controller.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor146"/>Exploring Model View Controller</h1>
			<p>At first glance, <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>) may show some similarities with the classical three-tier architecture. You have the classification of your logical objects into three kinds and a clear <a id="_idIndexMarker595"/>separation between presentation and data layers. However, MVC and the three-tier architecture are two different concepts that often coexist. </p>
			<p>The three-tier architecture is an architectural style where the elements (presentation, business, and data) are split into different deployable artifacts (possibly even using different languages and technologies). These elements are often executed on different servers in order to achieve the already discussed goals of scalability, testability, and so on.</p>
			<p>On the other hand, MVC is not an architectural style, but a design pattern. For this reason, it does <a id="_idIndexMarker596"/>not suggest any particular deployment model regarding its components, and indeed, very often the Model, View, and Controller coexist in the same application layer.</p>
			<p>Taking apart the <em class="italic">philosophical</em> similarity and differences, from a practical point of view, MVC is a common pattern for designing and implementing the presentation layer in a multi-tier architecture.</p>
			<p>In MVC, the three essential components are listed as follows:</p>
			<ul>
				<li><strong class="bold">Model</strong>: This component takes <a id="_idIndexMarker597"/>care of abstracting access to the data used by the application. There is no logic to the data presented here.</li>
				<li><strong class="bold">View</strong>: This component takes care of the interaction with the users (or other external systems), including <a id="_idIndexMarker598"/>the visual representation of data (if expected).</li>
				<li><strong class="bold">Controller</strong>: This component receives the commands (often mediated by the view) from <a id="_idIndexMarker599"/>the users (or other external systems) and updates the other two components accordingly. The <strong class="bold">Controller</strong> is commonly seen as a facilitator (or glue) between the <strong class="bold">Model</strong> and <strong class="bold">View</strong> components.</li>
			</ul>
			<p>The following diagram shows you the essential components of MVC:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_6.03_B16354.jpg" alt="Figure 6.3 – MVC components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – MVC components</p>
			<p>Another difference between MVC and the three-tier architecture is clear from the interaction of the three components described previously: in a three-tier architecture, the interaction is usually linear; that is, the presentation layer does not interact directly with the data layer. MVC classifies the kind and goal of each interaction but also allows all three components to interact with each other, forming a triangular model.</p>
			<p>MVC is commonly <a id="_idIndexMarker600"/>implemented by a framework or middleware and is used by the developer, specific interfaces, hooks, conventions, and more.</p>
			<p>In the real world, this pattern is commonly implemented either at the server side or the client side.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor147"/>Server-side MVC</h2>
			<p>The <strong class="bold">Java Enterprise Edition</strong> (<strong class="bold">JEE</strong>) implementation<a id="_idIndexMarker601"/> is a widely used example (even if not really a modern one) of an <a id="_idIndexMarker602"/>MVC server-side implementation. In this <a id="_idIndexMarker603"/>section, we are going to mention some <em class="italic">classical</em> Java implementations of web technologies (such as JSPs and servlets) that are going to be detailed further in <a href="B16354_10_Final_JM_ePUB.xhtml#_idTextAnchor250"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing User Interaction</em>.</p>
			<p>In terms of relevance to this chapter, it's worthwhile knowing that in the JEE world, the MVC model is <a id="_idIndexMarker604"/>implemented using Java beans, the view is in <a id="_idIndexMarker605"/>the form of JSP files, and the controller takes the form of servlets, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_6.04_B16354.jpg" alt="Figure 6.4 – MVC with JEE&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – MVC with JEE</p>
			<p>As you can see, in this way, the end user interacts with the web pages generated by the <strong class="bold">JSPs</strong> (the <strong class="bold">View</strong>), which are bound to the Java <strong class="bold">Beans</strong> (the <strong class="bold">Model</strong>) keeping the values displayed and collected. The overall flow is guaranteed by the <strong class="bold">Servlets</strong> (the <strong class="bold">Controller</strong>), which take care of things such as the binding of the Model and View, session handling, page <a id="_idIndexMarker606"/>routing, and other aspects that <em class="italic">glue</em> the application together. Other widespread Java MVC frameworks, such as <strong class="bold">Spring MVC</strong>, adopt a similar approach. </p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor148"/>Client-side MVC </h2>
			<p>MVC can also be <a id="_idIndexMarker607"/>completely implemented on the client side, which usually<a id="_idIndexMarker608"/> means that <a id="_idIndexMarker609"/>all three roles are played by a web browser. The de facto standard language for client-side MVC is <strong class="bold">JavaScript</strong>.</p>
			<p>Client-side MVC is almost<a id="_idIndexMarker610"/> identical to <strong class="bold">single-page applications</strong>. We will see more about single-page applications in <a href="B16354_10_Final_JM_ePUB.xhtml#_idTextAnchor250"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing User Interaction</em>, but basically, the idea is to minimize page changes and full-page reloads in order to provide a near-native experience to users while keeping the advantages of a web application (such as simplified distribution and centralized management).</p>
			<p>The single-page applications approach is not so different from server-side MVC. This technology commonly uses a templating language for views (similar to what we have seen with JSPs on the server side), a model implementation for keeping data and storing it in local browser storage or remotely calling the remaining APIs exposed from the backend, and controllers for navigation, session handling, and more support code.</p>
			<p>In this section, you learned about MVC and related patterns, which are considered a classical implementation for applications and have been useful for nicely setting up all the components and interactions, separating the user interface from the implementation.</p>
			<p>In the next section, we will have a look at the event-driven and reactive approaches.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/>Diving into event-driven and reactive approaches</h1>
			<p><strong class="bold">Event-driven architecture</strong> isn't a new concept. My first experiences with it were related to GUI <a id="_idIndexMarker611"/>development (with <strong class="bold">Java Swing</strong>) a long time ago. But, of course, the concept is older than that. And the reason is that events, meaning <em class="italic">things that happen</em>, are a pretty natural phenomenon in the real world. </p>
			<p>There is also a technological reason for the event-driven approach. This way of programming is deeply related to (or in other words, is most advantageous when used together with) asynchronous and non-blocking approaches, and these paradigms are inherently efficient in terms of the use of resources.</p>
			<p>Here is a diagram representing the event-driven approach:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_6.05_B16354.jpg" alt="Figure 6.5 – Event -driven approach&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Event-driven approach</p>
			<p>As shown in the previous diagram, the whole concept of the event-driven approach is to have our application <a id="_idIndexMarker612"/>architecture react to external events. When it comes to GUIs, such events are mostly user inputs (such as clicking a button, entering data in text fields, and so on), but events can be many other things, such as changes in the price of a stock option, a payment transaction coming in, data being collected from sensors, and so on. </p>
			<p>Another pattern worth mentioning is the <strong class="bold">actor model</strong> pattern, which is another way to use messaging to <a id="_idIndexMarker613"/>maximize the concurrency and throughput of a software system.</p>
			<p>I like to think that <strong class="bold">reactive programming</strong> is an evolution of all this. Actually, it is probably an evolution of many different techniques.</p>
			<p>It is a bit harder to <a id="_idIndexMarker614"/>define reactive, probably because this approach is still relatively new and less widespread. Reactive has its roots in functional programming, and it's a complete paradigm shift from the way you think about and write your code right now. While it's out of the scope of this book to introduce functional programming, we will try to understand some principles of reactive programming with the usual goal of giving you some more tools you can use in your day-to-day architect life and that you can develop further elsewhere if you find them useful for solving your current issues.</p>
			<p>But first, let's start with a cornerstone concept: events.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor150"/>Defining events, commands, and messages</h2>
			<p>From a technological point of view, an event can be defined as something that changes the status of <a id="_idIndexMarker615"/>something. In an event-driven architecture, such a change is then <a id="_idIndexMarker616"/>propagated (notified) as a message that can be picked <a id="_idIndexMarker617"/>up by components <em class="italic">interested</em> in that kind of event. </p>
			<p>For this reason, the <a id="_idIndexMarker618"/>terms <strong class="bold">event-driven</strong> and <strong class="bold">message-driven</strong> are commonly <a id="_idIndexMarker619"/>used interchangeably (even if the meaning may be slightly different).</p>
			<p>So, an <strong class="bold">event</strong> can be seen as a more abstract concept to do with new information, while a message can be seen as how this information is propagated throughout our system. Another core concept is the <strong class="bold">command</strong>. Roughly speaking, a command is the expression of an action, while an event is an expression of something happening (such as a change in the status of something).</p>
			<p>So, an event reflects a change in data (and somebody downstream may need to be notified of the change and need to do something accordingly), while a command explicitly asks for a specific action to be done by somebody downstream.</p>
			<p>Again, generally speaking, an event may have a broader audience (many consumers might be interested in it), while a command is usually targeted at a specific system. Both types of messages are a nice way to implement loose coupling, meaning it's possible to switch at any moment between producer and consumer implementations, given that the contract (the message format) is respected. It could be even done live with zero impact on system uptime. That's why the usage of messaging techniques is so important in application design.</p>
			<p>Since these concepts are so important and there are many different variations on brokers, messages, and how they are propagated and managed, we will look at more on messaging in <a href="B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing Application Integration and Business Automation</em>. Now, let's<a id="_idTextAnchor151"/> talk about the event-driven approach in detail.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Introducing the event-driven pattern and event-driven architecture</h2>
			<p>The <strong class="bold">event-driven pattern</strong> is a pattern and architectural style focused on reacting to things happening <a id="_idIndexMarker620"/>around (or inside of) our application, where notifications <a id="_idIndexMarker621"/>of actions to be taken appear in the form of events.</p>
			<p>In its simplest form, expressed in imperative languages (as is widespread in embedded systems), event-driven architecture is managed via infinite loops in code that continuously poll against event sources (queues), and actions are performed when messages are received.</p>
			<p>However, <strong class="bold">event-driven architecture</strong> is orthogonal to the programming style, meaning that it can <a id="_idIndexMarker622"/>be adopted both in imperative models and other <a id="_idIndexMarker623"/>models, such as object-oriented programming. </p>
			<p>With regard to <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>), there are plenty of Java-based examples when <a id="_idIndexMarker624"/>it comes to user interface development, with a widely known one being the Swing framework. Here you have objects (such as buttons, windows, and other controls) that provide handlers for user events. You can register one or more handlers (consumers) with those events, which are then executed.</p>
			<p>From the point of view of the application flow, you are not defining the order in which the methods are executing. You are just defining the possibilities, which are then executed and composed according to the user inputs.</p>
			<p>But if you abstract a bit, many other aspects of Java programming are event-driven. Servlets inherently react to events (such as an incoming HTTP request), and even error handling, with try-catch, defines the ways to react if an unplanned event occurs. In those examples, however, the events are handled internally by the framework, and you don't have a centralized middleware operating them (such as a messaging broker or queue manager). Events are simply a way to define the behavior of an application.</p>
			<p>Event-driven architecture can be extended as an architectural style. Simply put, an event-driven architecture prescribes that all interactions between the components of your software system are done via events (or commands). Such events, in this case, are mediated by a central messaging system (a broker, or bus). </p>
			<p>In this way, you can extend the advantages of the event-driven pattern, such as loose coupling, better scalability, and a more natural way to represent the use case, beyond a single software component. Moreover, you will achieve the advantage of greater visibility (as you can inspect the content and number of messages exchanged between the pieces of your architecture). You will also have better manageability and uptime (because you can start, stop, and change every component without directly impacting the others, as a consequence of loose coupling).</p>
			<h3>Challenges of the event-driven approach</h3>
			<p>So far, we have seen the advantages of the event-driven approach. In my personal opinion, they greatly outweigh the challenges that it poses, so I strongly recommend using this kind of <a id="_idIndexMarker625"/>architecture wherever possible. As always, take into account that the techniques and advice provided in this book are seldom entirely prescriptive, so in the real world I bet you will use some bits of the event-driven pattern even if you are using other patterns and techniques as your main choice.</p>
			<p>However, for the sake of completeness, I think it is worth mentioning the challenges I have faced while building event-driven architectures in the past:</p>
			<ul>
				<li><strong class="bold">Message content</strong>: It's always challenging to define what should be inside a message. In theory, you should keep the message as simple and as light as possible to avoid hogging the messaging channels and achieve better performance. So, you usually have only a message type and references to data stored elsewhere.</li>
			</ul>
			<p>However, this means that downstream systems may not have all the data needed for the computation in the message, and so they would complete the data from external systems (typically, a database). Moreover, most of the messaging frameworks and APIs (such<a id="_idIndexMarker626"/> as <strong class="bold">JMS</strong>) allow you to complete your message with metadata, such as headers and attachments. I've seen endless discussions about what should go into a message and what the metadata is. Of course, I don't have an answer here. My advice, as always, is to keep it as simple as possible.</p>
			<ul>
				<li><strong class="bold">Message format</strong>: Related to the previous point, the message format is also very relevant. Hence, after you establish what information type should be contained in each message, the next step is to decide the shape this information should have. You will have to define a message schema, and this should be understandable by each actor. Also, message validation could be needed (to understand whether each message is a formally valid one), and a schema repository could be useful, in order to have a centralized infrastructure that each actor can access to extract metadata about how each message should be formatted.</li>
				<li><strong class="bold">Transactional behavior</strong>: The write or read of a message, in abstract, constitutes access to external storage (not so different from accessing a database). For this reason, if you are building a traditional enterprise application, when you are using messaging, you will need to extend your transactional behavior.</li>
			</ul>
			<p>It's a very common situation that if your consumer needs to update the database as a consequence of receiving a message, you will have a transaction encompassing the read of the message and the write to the database. If the write fails, you will roll back the read of the message. In the Java world, you will implement this with a two-phase commit. While it's a well-known problem and many frameworks offer some facilities to do this, it's still not a simple solution; it can be hard to troubleshoot (and recover from) and can have a non-negligible performance hit. </p>
			<ul>
				<li><strong class="bold">Tracing</strong>: If the <a id="_idIndexMarker627"/>system starts dispatching many messages between many systems, including intermediate steps such as message transformations and filtering, it may become difficult to reconstruct a user transaction end to end. This could lead to a lack of visibility (from a logical/use case point of view) and make troubleshooting harder. However, you can easily solve this aspect with the propagation of transaction identifiers in messages and appropriate logging.</li>
				<li><strong class="bold">Security</strong>: You will need to apply security practices at many points. In particular, you may want to authenticate the connections to the messaging system (both for producing and consuming messages), define access control for authorization (you can read and write only to authorized destinations), and even sign messages to ensure the identity of the sender. This is not a big deal, honestly, but is one more thing to take into account.</li>
			</ul>
			<p>As you can see, the challenges are not impossible to face, and the advantages will probably outweigh them for you. Also, as we will see in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>, many of these challenges are not <a id="_idIndexMarker628"/>exclusive to event-driven architecture, as they are also common in distributed architectures such as microservices.</p>
			<h3>Event-driven and domain model</h3>
			<p>We have already <a id="_idIndexMarker629"/>discussed many times the importance of <a id="_idIndexMarker630"/>correctly modeling a business domain, and how this domain is very specific to the application boundaries. Indeed, in <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>, we introduced the idea of bounded context. Event-driven architectures are dealing almost every time with the exchange of information between different bounded contexts.</p>
			<p>As already discussed, there are a number of techniques for dealing with such kinds of interactions between different bounded contexts, including the shared kernel, customer suppliers, conformity, and anti-corruption layer. As already mentioned, unfortunately, a perfect approach does not exist for ensuring that different bounded contexts can share meaningful information but stay correctly decoupled.</p>
			<p>My personal experience is that the often-used approach here is the shared kernel. In other words, a new object is defined and used as an event format. Such an object contains the minimum amount of information needed for the different bounded contexts to communicate. This does not necessarily mean that the communication will work in every case and no side effects will occur, but it's a solution good enough in most cases.</p>
			<p>In the next section, we are going to touch on a common implementation of the event-driven pattern, known as the actor model.</p>
			<h3>Building on the event-driven architecture – the actor model</h3>
			<p>The <strong class="bold">actor model</strong> is a stricter <a id="_idIndexMarker631"/>implementation of the event-driven <a id="_idIndexMarker632"/>pattern. In the actor model, the actor is the most elementary unit of computation, encapsulating the state and behavior. An actor can communicate with other actors only through messages.</p>
			<p>An actor can create other actors. Each actor encapsulates its internal status (no actor can directly manipulate the status of another actor). This is usually a nice and elegant way to take advantage of multithreading and parallel processing, thereby maintaining integrity and avoiding explicit locks and synchronizations.</p>
			<p>In my personal experience, the actor model is a bit too prescriptive when it comes to describing bigger use cases. Moreover, some requirements, such as session handling and access to <a id="_idIndexMarker633"/>relational databases, are not an immediate match <a id="_idIndexMarker634"/>with the actor model's logic (though they are still implementable within it). You will probably end up implementing some components (maybe core ones) with the actor model while having others that use a less rigorous approach, for the sake of simplicity. The most famous actor model implementation <a id="_idIndexMarker635"/>with Java is probably <strong class="bold">Akka</strong>, with some other frameworks, such as <strong class="bold">Vert.x</strong>, taking some principles from it.</p>
			<p>So far, we have elaborated on generic messaging with both the event-driven approach and the actor model.</p>
			<p>It is now important, for the purpose of this chapter, to introduce the concept of <strong class="bold">streaming</strong>.</p>
			<h3>Introducing streaming</h3>
			<p><strong class="bold">Streaming</strong> has grown more popular with the rise of Apache Kafka even if other popular alternatives, such as <a id="_idIndexMarker636"/>Apache Pulsar, are available. Streaming shares some similarities with messaging (there are still producers, consumers, and messages flowing, after all), but it also has some slight differences. </p>
			<p>From a purely technical point of view, streaming has one important difference compared with messaging. In a streaming system, messages persist for a certain amount of time (or, if you want, a specified number of messages can be maintained), regardless of whether they have been consumed or not. </p>
			<p>This creates a kind of <em class="italic">sliding window</em>, meaning that consumers of a streaming system can rewind messages, following the flow from a previous point to the current point. This means that some of the information is moved from the messaging system (the broker, or bus) to the consumers (which have to maintain a cursor to keep track of the messages read and can move back in time).</p>
			<p>This behavior also enables some advanced use cases. Since consumers can see a consolidated list of messages (the stream, if you like), complex logic can be applied to such messages. Different messages can be combined for computation purposes, different streams can be merged, and advanced filtering logic can be implemented. Moreover, the offloading of part of the logic from the server to the consumers is one factor that enables the management of high volumes of messages with low latencies, allowing for near real-time scenarios.</p>
			<p>Given those technical differences, streaming also offers some conceptual differences that lead to use cases that are ideal for modeling with this kind of technology.</p>
			<p>With streams, the events (which are then propagated as messages) are seen as a whole information flow as they usually have a constant rate. And moreover, a single event is normally less <a id="_idIndexMarker637"/>important than the sequence of events. Last but not least, the ability to rewind the event stream leads to better consistency in distributed environments.</p>
			<p>Imagine adding more instances of your application (scaling). Each instance can reconstruct the status of the data by looking at the sequence of messages collected until that moment, in an approach commonly defined as <strong class="bold">Event Sourcing</strong>. This is also a commonly used <a id="_idIndexMarker638"/>pattern to improve resiliency and return to normal operations following a malfunction or disaster event. This characteristic is one of the reasons for the rising popularity of streaming systems in microservice architectures.</p>
			<h3>Touching on reactive programming</h3>
			<p>I like to think of <strong class="bold">reactive programming</strong> as event-driven architecture being applied to data streaming. However, I'm aware <a id="_idIndexMarker639"/>that that's an oversimplification, as reactive programming is a complex concept, both from a theoretical and technological point of view.</p>
			<p>To fully embrace the benefits of reactive programming, you have to both master the tools for <a id="_idIndexMarker640"/>implementing it (such as <strong class="bold">RxJava</strong>, <strong class="bold">Vert.x</strong>, or even <strong class="bold">BaconJS</strong>) and switch your <a id="_idIndexMarker641"/>reasoning to the reactive point of view. We can do this by modeling all our data <a id="_idIndexMarker642"/>as streams (including changes in variables content) and writing our code on the basis of a declarative approach.</p>
			<p>Reactive programming considers data streams as the primary construct. This makes the programming style an elegant and efficient way to write asynchronous code, by observing streams and reacting to signals. I understand that this is not easy at all to grasp at first glance.</p>
			<p>It's also worth noting that the term <em class="italic">reactive</em> is also used in the context of reactive systems, as per the <strong class="bold">Reactive</strong> <strong class="bold">Manifesto</strong>, produced in 2014 by the community to implement <a id="_idIndexMarker643"/>responsive and distributed systems. The Reactive Manifesto focuses on building systems that are as follows:</p>
			<ul>
				<li><strong class="bold">Responsive</strong>: This means replying with minimal and predictable delays to inputs (in order to maximize the user experience).</li>
				<li><strong class="bold">Resilient</strong>: This means that a failure in one of the components is handled gracefully and impacts the whole system's availability and responsiveness as little as possible.</li>
				<li><strong class="bold">Elastic</strong>: This means that the system can adapt to variable workloads, keeping constant response times.</li>
				<li><strong class="bold">Message-driven</strong>: This means that systems that adhere to the manifesto use a message-driven communication model (hence achieving the same goals as described in the <em class="italic">Introducing the event-driven pattern and event-driven architecture</em> section).</li>
			</ul>
			<p>While some of the goals and techniques of the Reactive Manifesto resonate with the concepts we have explored so far, reactive systems and reactive programming are different things. </p>
			<p>The Reactive Manifesto does <a id="_idIndexMarker644"/>not prescribe any particular approach to achieve the preceding four goals, while reactive programming does not guarantee, per se, all the benefits pursued by the Reactive Manifesto.</p>
			<p>A bit confusing, I know. So, now that we've understood the differences between a reactive system (as per the Reactive Manifesto) and reactive programming, let's shift our focus back to reactive programming. </p>
			<p>As we have said, the <a id="_idIndexMarker645"/>concept of data streaming is central to reactive programming. Another fundamental ingredient is the <strong class="bold">declarative approach</strong> (something similar to functional programming). In this approach, you express what you want to achieve instead of focusing on all the steps needed to get there. You declare the final result (leveraging standard constructs such as filter, map, and join) and attach it to a stream of data to which it will be applied. </p>
			<p>The final result will be compact and elegant, even if it may not be immediate in terms of readability. One last <a id="_idIndexMarker646"/>concept that is crucial in reactive programming is <strong class="bold">backpressure</strong>. This is basically a mechanism for standardizing communication between producers and consumers in a reactive programming model in order to regulate flow control. </p>
			<p>This means that if a consumer can't keep up with the pace of messages received from the producer (typically because of a lack of resources), it can send a notification about the problem upstream so that it can be managed by the producer or any other intermediate entity in the stream chain (in reactive programming, an event stream can be manipulated by intermediate functions). In theory, backpressure can bubble up to the first producer, which can also be a human user in the case of interactive systems. </p>
			<p>When a producer is notified of backpressure, it can manage the issue in different ways. The most simple is to slow down the speed and just send less data, if possible. A more elaborate technique is to buffer the data, waiting for the consumer to get up to speed (for example, by scaling its resources). A more destructive approach (but one that is effective nevertheless) is to drop some messages. However, this may not be the best solution in every case.</p>
			<p>With that, we have finished our quick look at reactive programming. I understand that some concepts have been merely mentioned, and things such as the functional and declarative approaches may require at least a whole chapter on their own. However, a full deep dive <a id="_idIndexMarker647"/>into the topic is beyond the scope of this book. I hope I gave you some hints to orient yourself toward the best architectural approach when it comes to message- and event-centric use cases.</p>
			<p>In this section, you learned about the basic concepts and terms to do with reactive and event-driven programming, which, if well understood and implemented, can be used to create high-performance applications.</p>
			<p>In the next section, we will start discussing how to optimize our architecture for performance and scalability purposes.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor153"/>Designing for large-scale adoption</h1>
			<p>So far, in this chapter, we have discussed some widespread patterns and architectural styles that are well used in the world of enterprise Java applications. </p>
			<p>One common idea <a id="_idIndexMarker648"/>around the techniques that we have discussed is to organize the code and the software components not only for better readability, but also for performance and scalability.</p>
			<p>As you can see (and will continue to see) in this book, in current <em class="italic">web-scale</em> applications, it is crucial to think ahead in terms of planning to absorb traffic spikes, minimize resource usage, and ultimately have good performance. Let's have a quick look at what this all means in our context.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Defining performance goals</h2>
			<p><strong class="bold">Performance</strong> is a very <a id="_idIndexMarker649"/>broad term. It can mean many different things, and often you will want to achieve <a id="_idIndexMarker650"/>all performance goals at once, which is of course not realistic.</p>
			<p>In my personal experience, there are some main performance indicators to look after, as they usually have a direct impact on the business outcome:</p>
			<ul>
				<li><strong class="bold">Throughput</strong>: This is measured as the number of transactions that can be managed per time unit (usually in seconds). The tricky part here is to define exactly what a transaction is in each particular context, as probably your system will manage different transaction types (with different resources being needed for each kind of transaction). Business people understand this metric instantaneously, knowing that having a higher throughput means that you will spend less on hardware (or cloud) resources.</li>
				<li><strong class="bold">Response time</strong>: This term means many different things. It usually refers to the time it takes to load your web pages or the time it takes to complete a transaction. This has to do with customer satisfaction (the quicker, the better). You may also have a contractual <strong class="bold">Service</strong> <strong class="bold">Level</strong> <strong class="bold">Agreement</strong> (<strong class="bold">SLA</strong>); for example, your <a id="_idIndexMarker651"/>system must complete a transaction in no more than <em class="italic">x</em> milliseconds. Also, you may want to focus on an average time or set a maximum time threshold.</li>
				<li><strong class="bold">Elapsed time</strong>: This basically means the amount of time needed to complete a defined chunk of work. This is common for batch computations (such as in big data or other calculations). This is kind of a mix of the previous two metrics. If you are able to do more work in parallel, you will spend less on your infrastructure. You may have a fixed deadline that you have to honor (such as finishing all your computations before a branch opens to the public).</li>
			</ul>
			<p><strong class="bold">Performance tuning</strong> is definitely a <a id="_idIndexMarker652"/>broad topic, and there is no magic formula to easily achieve the best performance. You will need to get real-world experience by experimenting with different configurations and get a lot of production <a id="_idIndexMarker653"/>traffic, as each case is different. However, here are some general considerations for each performance goal that we have seen:</p>
			<ul>
				<li>To enhance throughput, your best bet is to parallelize. This basically means leveraging <a id="_idIndexMarker654"/>threading <a id="_idIndexMarker655"/>where possible. It's unbelievable how often we tend to chain our calls in a sequential way. Unless it is strictly necessary (because of data), we should parallelize as much as we can and then merge the results.</li>
			</ul>
			<p>This entails, basically, splitting each call wherever possible (by delegating it to another thread), waiting for all the subcalls to complete in order to join the results in the main thread, and returning the main thread to the caller. This is particularly relevant where the subcalls involve calling to external systems (such as via web services). When parallelizing, the total elapsed time to answer will be equal to the longest subcall, instead of being the sum of the time of each subcall.</p>
			<p>In the next diagram, you can see how parallelizing calls can help in reducing the total elapsed time needed to complete the execution of an application feature:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_6.06_B16354.jpg" alt="Figure 6.6 – Sequential versus parallel approach&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Sequential versus parallel approach</p>
			<ul>
				<li>There should<a id="_idIndexMarker656"/> be a physical separation of our service based on the load and the performance <a id="_idIndexMarker657"/>expectations (something greatly facilitated by containers and microservices architecture). Instead of mixing all your APIs, you may want to dedicate more resources to the more critical ones (perhaps even dynamically, following the variation of traffic) by isolating them from the other services.</li>
				<li>For better response times, async is the way to go. After reviewing the previous sections for advice, I suggest working with your business and functional analysts and fighting to have everything be as asynchronous as possible from a use case perspective.</li>
			</ul>
			<p>It is very uncommon to have really strict requirements in terms of checking everything on every backend system before giving feedback to your users. Your best bet is to do a quick validation and reply with an acknowledgment to the customer. You will, of course, need an asynchronous channel (such as an email, a notification, or a webhook) to notify regarding progression of the transaction. There are countless examples in real life; for example, when you buy something online, often, your card funds won't even be checked in the first interaction. You are then notified by email that the payment has been completed (or has failed). Then, the package is shipped, and so on. Moreover, optimizing access to data is crucial; caching, pre-calculating, and de-duplicating are all viable strategies.</p>
			<ul>
				<li>When optimizing for elapsed time, you may want to follow the advice previously given: parallelizing and optimizing access to data is key. Also, here, you may want to rely on <a id="_idIndexMarker658"/>specialized infrastructure, such <a id="_idIndexMarker659"/>as scaling to have a lot of hardware (maybe in the cloud) and powering it off when it is not needed, or using infrastructures optimized for input/output. But the best advice is to work on the use case to maximize the amount of parallelizable work, possibly duplicating part of the information.</li>
			</ul>
			<p>We will learn more about performance in <a href="B16354_12_Final_JM_ePUB.xhtml#_idTextAnchor292"><em class="italic">Chapter 12</em></a>, <em class="italic">Cross-Cutting Concerns</em>. Let's now review some key concepts linked to scalability.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor155"/>Stateless</h2>
			<p><strong class="bold">Stateless</strong> is a very<a id="_idIndexMarker660"/> recurrent <a id="_idIndexMarker661"/>concept (we will see it again in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>). It is difficult to define with simple words, however. </p>
			<p>Let's take the example of an ATM versus a workstation.</p>
			<p>Your workstation is something that is usually difficult to replace. Yes, you have backups and you probably store some of your data online (in your email inbox, on the intranet, or on shared online drives). But still, when you have to change your laptop for a new one, you lose some time ensuring that you have copied any local data. Then, you have to export and reimport your settings, and so on. In other words, your laptop is very much stateful. It has a lot of local data that you don't want to lose.</p>
			<p>Now, let's think about an ATM. Before you insert your card, it is a perfectly empty machine. It then loads your data, allows cash withdrawal (or whatever you need), and then it goes back to the previous (empty) state, ready for the next client to serve. It is stateless from this point of view. It is also engineered to minimize the impact if something happens while you are using it. It's usually enough to end your current session and restart from scratch.</p>
			<p>But back to our software architecture: <em class="italic">how do we design an architecture to be stateless?</em></p>
			<p>The most common ways are as follows:</p>
			<ul>
				<li><strong class="bold">Push the state to clients</strong>: This can mean having a cookie in the customer browser or having your APIs carry a token (such as a <strong class="bold">JWT</strong>). Every time you get a request, you may get to choose the best instance for your software (be it a container, a new JVM instance, or simply a thread) to handle it – <em class="italic">which will it be: the closest to the customer, the closest to the data, or simply the one with the least amount of load at that moment?</em></li>
				<li><strong class="bold">Push the state to an external system</strong>: You can offload the state to a dedicated system, such as a distributed cache. Your API (and business logic) only need to identify the user. All the session data is then loaded from a dedicated system. Any new instance can simply ask for the session data. Of course, your problem is then how to scale and maximize the uptime of such a caching system.</li>
			</ul>
			<p>Whatever your <a id="_idIndexMarker662"/>approach is, think always about the <em class="italic">phoenix</em>; that is, you should be able to reconstruct the data <a id="_idIndexMarker663"/>from the ashes (and quickly). In this way, you can maximize scaling, and as a positive side effect, you will boost availability and disaster recovery capabilities. As highlighted in the <em class="italic">Introducing streaming</em> section, events (and the event sourcing technique) are a good way to implement similar approaches. Indeed, provided that you have persisted all the changes in your data into a streaming system, such changes could be replayed in case of a disaster, and you can reconstruct the data from scratch.</p>
			<p>Beware of the concept of <strong class="bold">stickiness</strong> (pointing your clients to the same instance whenever possible). It's a quick win at the beginning, but it may lead you to unbalanced infrastructure and <a id="_idIndexMarker664"/>a lack of scalability. The next foundational aspect of performance is data.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Data</h2>
			<p><strong class="bold">Data</strong> is very often a<a id="_idIndexMarker665"/> crucial aspect of performance management. Slow access times to the data you need will <a id="_idIndexMarker666"/>frustrate all other optimizations in terms of parallelizing or keeping interactions asynchronous. Of course, each type of data has different optimization paths: indexing for relational databases, proximity for in-memory caching, and low-level tuning for filesystems.</p>
			<p>However, here are my considerations as regards the low-hanging fruit when optimizing access to data:</p>
			<ul>
				<li><strong class="bold">Sharding</strong>: This is a foundational concept. If you can split your data into smaller chunks (such as by segmenting your users by geographical areas, sorting using alphabetical order, or <a id="_idIndexMarker667"/>using any other criteria compliant with your data model), you can dedicate a subset of the system (such as a database schema or a file) to each data shard.</li>
			</ul>
			<p>This will boost your resource usage by minimizing the interference between different data segments. A common strategy to properly cluster data in shards is <strong class="bold">hashing</strong>. If you can define a proper hashing function, you will have a quick and reliable way to identify where <a id="_idIndexMarker668"/>your data is located by mapping the result of the hashing operation to a specific system (containing the realm that is needed). If you still need to access data across different shards (such as for performing computations or for different representations of data), you may consider a different sharding strategy or even duplicating your data (but this path is always complex and risky, so be careful with that).</p>
			<ul>
				<li><strong class="bold">Consistency point</strong>: This is another concept to take care of. It may seem like a lower-level detail, but it's worthwhile exploring. To put it simply: <em class="italic">how often do you need your data to persist?</em> Persistence particularly common in long transactions (such as ones involving a lot of submethods). Maybe you just don't need to persist your data every time; you can keep it in the memory and batch all the persistence operations (this often includes writing to files or other intensive steps) together.</li>
			</ul>
			<p>For sure, if the system crashes, you might lose your data (and whether to take this risk is up to you), but are you sure that incongruent data (which is what you'd have after saving only <a id="_idIndexMarker669"/>a part of the operations) is better than no data at all? Moreover, maybe you can afford a crash because your data has persisted elsewhere and can be recovered (think about streaming, which we learned about previously). Last but not least, <em class="italic">is it okay if your use case requires persistence at every step?</em> Just be aware of that. Very often, we simply don't care about this aspect, and we pay a penalty without even knowing it.</p>
			<ul>
				<li><strong class="bold">Caching</strong>: This is the most common technique. Memory is cheap, after all, and almost always has better access times than disk storage. So, you may just want to have a caching layer in front of your persistent storage (database, filesystem, or whatever). Of course, you will end up dealing with stale data and the propagation of changes, but it's still a simple and powerful concept, so it's worth a try.</li>
			</ul>
			<p>Caching may be<a id="_idIndexMarker670"/> implemented in different ways. Common implementations include caching data in <a id="_idIndexMarker671"/>the working memory of each microservice (in other words, in the heap, in the case of Java applications), or relying on external caching systems (such as client-server, centralized caching systems such as Infinispan or Redis). Another implementation makes use of external tools (such as Nginx or Varnish) sitting in front of the API of each microservice and caching everything at that level.</p>
			<p>We will see more about data in <a href="B16354_11_Final_JM_ePUB.xhtml#_idTextAnchor271"><em class="italic">Chapter 11</em></a>, <em class="italic">Dealing with Data</em>, but for now, let me give you a spoiler about my favorite takeaway here: you must have multiple ways of storing and retrieving data and using it according to the constraints of your use case. Your mobile application has a very different data access pattern from a batch computation system. Now, let's go to the next section and have a quick overview of scaling techniques.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>Scaling</h2>
			<p><strong class="bold">Scaling</strong> has been the <a id="_idIndexMarker672"/>main mantra so far for reaching performance goals and is one of the key reasons why you <a id="_idIndexMarker673"/>would want to architect your software in a certain way (such as in a multi-tier or async fashion). And honestly, I'm almost certain that you already know what scaling is and why it matters. However, let's quickly review the main things to consider when we talk about scaling:</p>
			<ul>
				<li><strong class="bold">Vertical scaling</strong> is, somewhat, the most traditional way of scaling. To achieve better performance, you <a id="_idIndexMarker674"/>need to add more resources to your infrastructure. While it is still common and advisable in some scenarios (such as when trying to squeeze more performance from databases, caches, or other stateful systems), it is seldom a long-term solution.</li>
			</ul>
			<p>You will hit a blocking limit sooner or later. Moreover, vertical scaling is not very dynamic, as you may need to purchase new hardware or resize your virtual machine, and maybe downtime will be needed to make effective changes. It is not something you can do in a few seconds to absorb a traffic spike.</p>
			<ul>
				<li><strong class="bold">Horizontal scaling</strong> is way more popular nowadays as it copes well with cloud and PaaS architectures. It is also the basis of stateless, sharding, and the other concepts discussed <a id="_idIndexMarker675"/>previously. You can simply create another instance of a component, and that's it. In this sense, the slimmer, the better. If your service is very small and efficient and takes a very short time to start (<em class="italic">microservices,</em> <em class="italic">anyone?</em>), it will nicely absorb traffic spikes.</li>
			</ul>
			<p>You can take this concept to the extreme and shut down everything (thereby saving money) when you have no traffic. As we will see in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>, scaling to zero (so that no instance is running if there are no requests to work with) is the concept behind serverless. </p>
			<ul>
				<li>We are naturally led to think about scaling in a <strong class="bold">reactive way</strong>. You can get more traffic and react by scaling your components. The key here is identifying which metric to look after. It is usually the number of requests, but memory and CPU consumption are the other key metrics to look after. The advantage of this approach is that you will consume the resources needed for scaling <em class="italic">just in time</em>, hence you will mostly use it in an efficient way. The disadvantage is that you may end up suffering a bit if traffic increases suddenly, especially if the new instances take some time to get up and running.</li>
				<li>The opposite of reactive scaling is, of course, <strong class="bold">proactive scaling</strong>. You may know in advance that a traffic spike is expected, such as in the case of Black Friday or during the tax payment <a id="_idIndexMarker676"/>season. If you manage to automate your infrastructure in the right way, you can schedule the proper growth of the infrastructure in advance. This may be even more important if scaling takes some time, as in vertical scaling. The obvious advantage of this approach is that you will be ready in no time in case of a traffic increase, as all the instances needed are already up and running. The disadvantage is that you may end up wasting resources, especially if you overestimate the expected traffic.</li>
			</ul>
			<p>With this section, we achieved the goals of this chapter. There was quite a lot of interesting content. We started with hexagonal architectures (an interesting example of encapsulation), before moving on to multi-tier architectures (a very common way to organize application components). Then, you learned about MVC (a widely used pattern for user interfaces), event-driven (an alternative way to design highly performant applications), and finally, we <a id="_idIndexMarker677"/>looked at some common-sense suggestions about building highly scalable and performant application architectures.</p>
			<p>It is not possible to get into all the details of all the topics discussed in this chapter. However, I hope to<a id="_idIndexMarker678"/> have given you the foundation you need to start experimenting and learning more about the topics that are relevant to you.</p>
			<p>And now, let's have a look at some practical examples.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor158"/>Case studies and examples</h1>
			<p>As with other chapters in this book, let's end this chapter with some practical considerations about how to apply the concepts we've looked at to our recurrent example involving a mobile payment solution. Let's start with encapsulation.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/>Encapsulating with a hexagonal architecture</h2>
			<p>A common way to map hexagonal concepts in Java is to encompass the following concept representations:</p>
			<ul>
				<li>The core maps into <a id="_idIndexMarker679"/>the domain model. So, here you have the usual entities (<strong class="bold">Payment</strong>, in our example), services (<strong class="bold">PaymentService</strong>, in this case), value objects, and so on. Basically, all the elements <a id="_idIndexMarker680"/>in the core are <strong class="bold">Plain Old Java Objects</strong> (<strong class="bold">POJOs</strong>) and some business logic implementations.</li>
				<li>Here, the ports are the interfaces. They are somewhere in the middle, between a logical concept in the domain realm (enquire, notify, and store, in our example) and the respective technical concepts. This will promote the decoupling of the business logic (in the core) and the specific technology (which may change and evolve).</li>
				<li>The adapters are implementations of such interfaces. So, an enquire interface will be implemented by <strong class="bold">SoapAdapter</strong>, <strong class="bold">RestAdapter</strong>, and <strong class="bold">GraphQLAdapter</strong>, in this particular case.</li>
				<li>Outside of the hexagon, the external actors (such as the mobile app, databases, queues, or even external applications) interact with our application domain via the adapters provided.</li>
			</ul>
			<p>The following diagram illustrates the preceding points:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_6.07_B16354.jpg" alt="Figure 6.7 – Hexagonal architecture example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Hexagonal architecture example</p>
			<p>Here are some key considerations:</p>
			<ul>
				<li>The cardinality is completely arbitrary. You are not limited to six ports or adapters. Each <a id="_idIndexMarker681"/>port can map to one or more adapters. Each external system can be bound to one or more adapters. Each adapter can be consumed by more than one external system (they are not exclusive unless you want them to be).</li>
			</ul>
			<p>This logical <a id="_idIndexMarker682"/>grouping can be seen at the level that <a id="_idIndexMarker683"/>you want. This could be an application, meaning that everything inside the hexagon is deployed on a single artifact – an <strong class="bold">Enterprise Application Archive</strong> (<strong class="bold">EAR</strong>) or a <strong class="bold">Java Application Archive</strong> (<strong class="bold">JAR</strong>) – in a machine, or it could be a collection of different artifacts and machines (as in a microservices setup). In this case, most probably you will decouple your interfaces with REST or something similar, to avoid sharing dependencies across your modules.</p>
			<ul>
				<li>The advantage in terms of test coverage is obvious. You can switch each adapter into a mock system, to test in environments that don't have the complete infrastructure. So, you can test your notifications without the need for a queue, or test persistence without the need for a database. This, of course, will not replace <a id="_idIndexMarker684"/>end-to-end testing, in which you have to broaden your test and attach it to real adapters (such as in automating tests that call REST or SOAP APIs) or even external systems (such as in testing the mobile app or the web app itself).</li>
			</ul>
			<p>As usual, I think that considering hexagonal modeling as a tool can be useful when implementing software architecture. Let's now have a quick look at multi-tier architecture.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor160"/>Componentizing with multi-tier architecture</h2>
			<p><strong class="bold">Multi-tier architecture</strong> gives us occasion to think about componentization and, ultimately, the evolution <a id="_idIndexMarker685"/>of software architectures. If we think about our mobile payment application, a three-tier approach may be considered a good fit. And honestly, it is. Historically, you probably wouldn't have had many other options than a pure, centralized, client-server application. Even with a modern perspective, starting with a less complex approach, such as the three-tier one, it can be a good choice for two reasons:</p>
			<ul>
				<li>It can be considered a <em class="italic">prototypization</em> phase, with the goal of building a <strong class="bold">Minimum Viable Product </strong>(<strong class="bold">MVP</strong>). You will have something to showcase and test soon, which <a id="_idIndexMarker686"/>means you can check whether you have correctly understood the requirements or whether users like (and use) your product. Moreover, if you designed your application correctly (using well-designed APIs), maybe you can evolve your backend (toward multi-tier or microservices) with minimal impact on the clients.</li>
				<li>It can be a good benchmark for your domain definition. As per the famous Martin Fowler article (<em class="italic">Monolith First</em>), you may want to start with a simpler, all-in-one <a id="_idIndexMarker687"/>architecture in order to understand the boundaries of your business logic, and then correctly decomponentize it in the following phase (maybe going toward a cloud-native approach).</li>
			</ul>
			<p>In the next diagram, you can see a simple representation of an application's evolution from three-tier to microservices:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_6.08_B16354.jpg" alt="Figure 6.8 – Tier segmentation evolution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – Tier segmentation evolution</p>
			<p>As you can see in the previous diagram, each component change has a role and name. There are some key considerations to make about this kind of evolution:</p>
			<ul>
				<li>We will see more <a id="_idIndexMarker688"/>about microservices in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>. For now, consider the fact that this example will only represent architectural evolution over time and how your tier segmentation can evolve. Microservices is probably not similar to multi-tier architecture, as some concepts (such as responsibilities in terms of data representation in views) are orthogonal to it (in other words, you can still have concepts from three-tier on top of microservices).</li>
				<li>We are starting with three tiers because it is simply an antipattern to have business logic mixed together with your data in terms of being deployed to the database (with stored procedures and such). However, in my opinion, having an external database does not constitute a data layer <em class="italic">per se</em>. So, in this example, the three-tier architecture can also be seen as a two-tier/client-server architecture, with the external database simply being a technological detail.</li>
				<li>In the real world, there is no defined boundary between one architectural view (such as three-tier) and another alternative (such as microservices). It's not as if one day you will <a id="_idIndexMarker689"/>transition from client-server (or three-tier) to microservices. You will probably start adding more layers, and then reorganize some capabilities into a complete microservice from the ground up and offload some capabilities to it.</li>
			</ul>
			<p>In general, it is possible to have a few differing architectural choices coexisting in the same application, perhaps just for a defined (limited) time, leading to a transition to a completely different architecture. In other words, your three-tier architecture can start with some modularized microservices alongside tiers (making it a hybrid architecture, bringing different styles together), and then the tiered part can be progressively reduced and the microservices part increased, before a final and complete move to a microservices implementation.</p>
			<p>Once again, this is designed to give you some food for thought as to how to use some key concepts seen in this <a id="_idIndexMarker690"/>chapter in the real world. It's important to understand that it's rare (and maybe wrong) to completely and religiously embrace just one model, for instance, starting with a pure three-tier model and staying with it even if the external conditions change (if you start using a cloud-like environment, for example).</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor161"/>Planning for performance and scalability</h2>
			<p>As seen in <a id="_idIndexMarker691"/>the previous <a id="_idIndexMarker692"/>sections, performance is a broad term. In our example, it is likely that we will want to optimize for both throughput and response time. It is, of course, a target that is not easy to reach, but it is a common request in this kind of project: </p>
			<ul>
				<li><strong class="bold">Throughput</strong> means a more <a id="_idIndexMarker693"/>sustainable business, with a lower cost for each transaction (considering hardware, power, software licenses, and so on).</li>
				<li><strong class="bold">Response time</strong> means having a happier customer base and, ultimately, the success of the project. Being an <a id="_idIndexMarker694"/>online product, it is expected today that access to this kind of service (whether it is for making a payment or accessing a list of transactions) happens with zero delay; every hiccup could lead a customer to switch to alternative platforms.</li>
			</ul>
			<p>Also, you may want to have a hard limit. It is common to have a timeout, meaning that if your payment takes more than 10 seconds, it is considered to have failed and is forcefully dropped. That's for limiting customer dissatisfaction and avoiding the overloading of the infrastructure.</p>
			<p><em class="italic">But how do you design your software architecture to meet such objectives?</em> As usual, there is no magic recipe for this. Performance tuning is a continuous process in which you have to monitor every single component for performance and load, experiment to find the most efficient solution, and then switch to the next bottleneck. However, there are a number of considerations that can be made upfront:</p>
			<ul>
				<li>First of all, there is <strong class="bold">transactional behavior</strong>. We will see in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>, how heavily decentralized architectures, such as <a id="_idIndexMarker695"/>microservices, do not cope well with long and distributed transactions. Even if you are not yet in such a situation and you are starting with a simpler, three-tier architecture, having long transaction boundaries will cause serialization in your code, penalizing your performance.</li>
			</ul>
			<p>To avoid this, you have to restrict the transaction as much as possible and handle consistency in different ways wherever possible. You may want to have your transaction encompass the payment request and the check of monetary funds (as in the classic examples about transactions), but you can take most of the other operations elsewhere. So, notifications and updates of non-critical systems (such as CRMs or data sources only used for inquiries) can be done outside of the transactions and retried in the case of failures.</p>
			<ul>
				<li>As a follow-up from the previous point, it should be taken into account that you don't have to penalize the most common cases to avoid very remote cases unless they have dramatic consequences. So, it is okay to check funds before making the payments in a strict way (as in the same transaction), because a malfunction there can cause bad advertising and a loss of trust in your platform, with potentially devastating consequences.</li>
			</ul>
			<p>But you can <a id="_idIndexMarker696"/>probably afford to have a notification lost<a id="_idIndexMarker697"/> or sent twice from time to time if this means that 99% of the other transaction are performing better. And the rules can also be adapted to your specific context. Maybe the business can accept skipping some online checks (such as anti-fraud checks) in payment transactions of small amounts. The damage of some fraudulent transactions slipping through (or only being identified after the fact) may be lower than the benefit in terms of performance for the vast majority of licit traffic.</p>
			<ul>
				<li>In terms of <strong class="bold">asynchronous behavior</strong>, as has been seen, it is expected that you only do synchronously what's essential to do synchronously. So, apart from the obvious <a id="_idIndexMarker698"/>things such as notifications, every other step should be made asynchronous if possible – for example, updating downstream systems.</li>
			</ul>
			<p>So, in our use case, if we have a transactional database (or a legacy system) storing the user position that is used to authorize payments, it should be checked and updated synchronously to keep consistency. But if we have other systems, such as a CRM that stores the customer position, perhaps it's okay to place an update request in a queue and update that system after a few seconds, when the message is consumed and acted upon. </p>
			<ul>
				<li>Last but not least, in terms of <strong class="bold">scaling</strong>, the more your component will be stateless, the <a id="_idIndexMarker699"/>better. So, if we have each step of the payment process carrying over all the data needed (such as the customer identifier and transaction identifier), maybe we can minimize the lookups and checks on the external systems.</li>
			</ul>
			<p>In the case of more load, we can (in advance, if it is planned, or reactively if it is an unexpected peak) create more instances of our components. Then, they will be immediately able to take over for the incoming requests, even if they originated from existing instances.</p>
			<p>So, if you imagine a payment transaction being completed in more than one step (as in first checking for the existence of the recipient, then making a payment request, then sending a confirmation), then it may be possible that each of those steps is worked on by different instances of the same component. Think about what would happen if you had to manage all those steps on the same instance that started the process because the component stored the data in an internal session. In cases of high traffic, new instances would not be able to help with <a id="_idIndexMarker700"/>the<a id="_idIndexMarker701"/> existing transactions, which would have to be completed where they originated. And the failure of one instance would likely create issues for users.</p>
			<p>This completes the content of this chapter. Let's quickly recap the key concepts that you have seen.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, you have seen a lot of the cornerstone concepts when it comes to architectural patterns and best practices in Java. In particular, you started with the concept of encapsulation; one practical way to achieve it is the hexagonal architecture. You then moved to multi-tier architectures, which is a core concept in Java and JEE (especially the three-tier architecture, which is commonly implemented with beans, servlets, and JSPs).</p>
			<p>There was a quick look at MVC, which is more a design pattern than an architectural guideline but is crucial to highlight some concepts such as the importance of separating presentation from business logic. You then covered the asynchronous and event-driven architecture concepts, which apply to a huge portion of different approaches that are popular right now in the world of Java. These concepts are known for their positive impacts on performance and scalability, which were also the final topics of this chapter.</p>
			<p>While being covered further in other chapters, such as <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>, and <a href="B16354_12_Final_JM_ePUB.xhtml#_idTextAnchor292"><em class="italic">Chapter 12</em></a>, <em class="italic">Cross-Cutting Concerns</em>, here you have seen some general considerations about architecture that will link some of the concepts that you've seen so far, such as tiering and asynchronous interactions, to specific performance goals.</p>
			<p>In the next chapter, we will look in more detail at what middleware is and how it's evolving.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor163"/>Further reading</h1>
			<ul>
				<li><em class="italic">Hexagonal architecture</em>, by Alistair Cockburn (<a href="https://alistair.cockburn.us/hexagonal-architecture/">https://alistair.cockburn.us/hexagonal-architecture/</a>)</li>
				<li><em class="italic">Java Performance: The Definitive Guide: Getting the Most Out of Your Code</em>, by Scott Oaks, published by O'Reilly Media (2014)</li>
				<li><em class="italic">Kafka Streams in Action</em>, by William P. Bejeck Jr., published by Manning</li>
				<li><em class="italic">Scalability Rules 50 Principles for Scaling Web Sites</em>, by Martin L. Abbott and Michael T. Fisher, published by Pearson Education (2011)</li>
				<li><em class="italic">Monolith First</em>, by Martin Fowler (<a href="https://www.martinfowler.com/bliki/MonolithFirst.html">https://www.martinfowler.com/bliki/MonolithFirst.html</a>)</li>
			</ul>
		</div>
	</body></html>