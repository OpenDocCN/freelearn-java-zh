- en: '5\. Many to One: Reducing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn new techniques for dealing with sequential data.
    You will learn how to use the `reduce` function, as well as other reducing techniques
    that provide greater flexibility for transforming or extracting data from a sequence.
    We will use the simple form of `reduce`, use `reduce` with an initializer and
    an accumulator, and solve problems requiring a variable-length "window" over a
    sequence. We will also reduce sequences with functions other than `reduce`.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use `reduce` with complex accumulators.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is about using Clojure''s `reduce` function and about *reducing*
    in general. By that, we mean starting with a sequence and *boiling it down* to
    a single thing. ("Reducing" is also cooking term, after all.) `map` and `filter`
    were about taking the sequence you have and turning it into the sequence you want:
    *sequence in, sequence out*. But that''s not always what we want. Even simple
    operations on a sequence, such as calculating an average, a sum, or a maximum,
    cannot be directly calculated this way. That''s where `reduce`, as well as a wider
    family of functions and patterns, comes in: *sequence in, something else out*.
    It''s "something else" because the result might be a number, a string, a map,
    or even another sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw that functions such as `map` and `filter` only
    look at one element at a time: how should we transform this item? Should we discard
    this item, or keep it? This is a powerful approach because it creates a clear
    scope for the action of the functions we write, which helps us to write simpler
    code, and it allows lazy evaluation. There is a limit to this approach, however,
    when we need to look at a sequence as a whole, or at least as more than just the
    current item. This is why `map` and `filter` are only partial replacements for
    a `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure, the `reduce` function is not the only way to generate a result from
    an entire sequence. Even the simple `count` function is a way of reducing a sequence
    down to a single value. Some core functions actually use `reduce` themselves so
    that we don't have to. The recursion and looping techniques that we'll discuss
    in the next chapter can do this as well. The patterns we are going to look at
    here should, in general, be what you consider first, after you've decided that
    `map` and `filter` are not enough. `reduce` and other similar functions provide
    a clear way of solving a certain kind of problem, which is why they are an important
    part of your mental Clojure toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: The Basics of reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how `reduce` works, the best place to start is with a simple
    example. Let''s try to find the sum of a list of integers. In an imperative language
    such as JavaScript, we might do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sum` variable here accumulates information found in previous iterations
    of the loop. This is exactly what `reduce` does. Here''s a Clojure version of
    the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the first iteration, `sum-so-far` refers to `0` and `item` refers to `8`.
    In subsequent iterations, `sum-so-far` refers to the result of evaluating the
    function with the previous item in the collection and `item` refers to the current
    item of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this work? This expression looks a lot like some of the uses of `map`
    or `filter` in the previous chapter. The layout of the s-expression should be
    very familiar by now:'
  prefs: []
  type: TYPE_NORMAL
- en: A function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An anonymous function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vector of integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And yet, you can probably already tell that this expression is quite different
    from using `map` or `filter`. First of all, there is only one sequence supplied,
    yet the anonymous function takes two arguments, `sum-so-far` and `item`. And,
    of course, the biggest surprise is the result, which is not a sequence at all,
    but a single integer. This isn't `map` territory anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this expression simply adds up integers in the sequence provided.
    To do that, it iterates over the integers in the sequence, seemingly like `map`
    would. The key difference is that with `reduce`, the function *"remembers"* the
    result of evaluating the previous calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's break down the operations here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time `reduce` calls the function we''ve provided, `(fn [sum-so-far
    item] (+ sum-so-far item))`, the arguments are the first two items in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: sum-so-far and item are the first two items in the list (call
    1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: sum-so-far and item are the first two items in the list (call 1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of the next calls, `sum-so-far` is the result of the previous calculation,
    and `item` is the next integer in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Calls 2 and 3: each call builds on the result of the previous
    calls'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Calls 2 and 3: each call builds on the result of the previous calls'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could simplify this expression by replacing the anonymous function with
    Clojure''s `+` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And we could even use `apply` and avoid using `reduce` altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with `(apply + …)`, we haven''t really escaped from `reduce`: internally,
    the `+` function, when called with more than two arguments, uses a version of
    `reduce` to move through the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Finding the Day with the Maximum Temperature'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clojure''s `max` function is useful when dealing with a list of numbers, but
    what do you do when the numbers you want to compare are part of a more complex
    data structure? Suppose we have the following weather data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to be able to write functions that return the entire map for the day
    with the highest maximum temperature, the lowest minimum, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a REPL and copy the `weather-days` variable from the book GitHub''s repository
    and paste it into your REPL. You''ll find the file here: [https://packt.live/2SXw372](https://packt.live/2SXw372).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `map` and `max` to find the highest temperature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This could be useful, but it doesn't tell us what day had this temperature,
    or whether it was sunny or cloudy that day, or what the minimum temperature was
    that day.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Find the maximum `:max` temperature with `reduce`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the maximum temperature of a given day is higher than `max-day-so-far`, that
    day replaces `max-day-so-far` until another day with a higher temperature dethrones
    it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Find the day that had the lowest maximum temperature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Returning the *item* with the maximum value, rather than returning the maximum
    itself, can be useful when working with complex data structures. You will probably
    never be confronted with this exact problem. The important thing is to be able
    to quickly write a specialized version of `max`, `min`, a comparator, or whatever
    other function you need that is adapted to the needs of your particular data.
    Because of its power and flexibility, knowing how to use `reduce` can be extremely
    useful in those situations. It's no accident either that, internally, many core
    Clojure functions use `reduce` themselves. This is true of `take-while`, `set`,
    `into`, and `map`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tasks such as adding integers or finding maximum values have a common thread:
    the input values and the accumulated values are of the same type. When two numbers
    are added, the result is a number; when a maximum or a minimum is chosen between
    two numbers, the result is still a number. When we use `reduce` to add numbers
    together, the running total is a number just like all the other inputs. In the
    examples so far, the first function call that `reduce` makes takes the first two
    items in the sequence. We can break a `reduce` call into its successive function
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We actually don''t need the anonymous function that we used in the previous
    examples, because `+` takes numbers as arguments, and returns a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: The arguments and the return value are all of the same type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: The arguments and the return value are all of the same type'
  prefs: []
  type: TYPE_NORMAL
- en: 'In each of our examples so far, three different things are all of the same
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: The values in the sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both arguments to `+`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value of `+`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous exercise, we returned a map rather than a single number. That
    was possible because the same kinds of maps were used in these three places: the
    maps we iterate over as well as the current "best" map that we are comparing the
    others to.'
  prefs: []
  type: TYPE_NORMAL
- en: If this was all we could do with `reduce`, however, it would be rather restrictive.
    Not all problems can be expressed by this kind of function. Often, we want to
    compute and accumulate some other kind of value. We might need more complex summary
    statistics, or to merge individual values together in a specific way, or to divide
    a sequence into segments based on special criteria. Just because you have a sequence
    of `matches`, to take up our tennis examples again, doesn't mean that the result
    you want can also be expressed as a tennis `match`. Maybe we want to iterate over
    a list of matches and accumulate some other kind of information. At the end of
    this chapter, in fact, we are going to do just that. At the beginning of this
    chapter, we said that `reduce` can turn a sequence into *anything* else, but so
    far, this hasn't really been true.
  prefs: []
  type: TYPE_NORMAL
- en: This is why there is a second form of `reduce` that takes an additional argument.
    When the additional argument is present, it becomes the first argument to the
    reducing function. On that initial function call, the first item in the sequence
    is the second argument. This is a crucial improvement because the reducing function's
    return value no longer has to be the same kind of thing that is in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following snippet, where we supply an empty map as an initial
    value for our reduction. As it moves through the sequence, the reducing function
    updates the `:maximum` and `:minimum` fields when new values are discovered. The
    expression returns a function at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression finds both the minimum and the maximum value in a sequence.
    Calling `reduce` like this might be useful if, for some reason, it was difficult
    to loop over a list twice, if it were very, very long, or perhaps there was a
    stream that was not being retained. To return two values, we'll place them in
    a map. Without the initializing argument for `reduce`, this would already have
    been impossible. This is a case where "numbers in, numbers out" is not sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we supply an empty map as an initial value for our reduction. As it moves
    through the sequence, the reducing function updates the `:maximum` and `:minimum`
    fields when new values are discovered. The expression returns a function at the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common pattern in a case like this would be to return a two-item vector
    (a tuple) instead of a map: `[minimum maximum]`.'
  prefs: []
  type: TYPE_NORMAL
- en: On each call of the reducing function, the first argument is always a map, and
    the second argument is always an integer from the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This difference makes `reduce` much more useful. Now, we can extract whatever
    data we like from each item in the sequence and insert it and carry it forward
    as the context for the subsequent iterations. Most of the time, we can think of
    this context as an `acc`. Later, when we look at some of Clojure's other looping
    constructs, the idea of an explicit context will reappear.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning with reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partitioning a sequence into smaller sequences is a common problem and there
    are many ways to solve it. When the simpler solutions aren't enough, `reduce`
    can be a useful alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at some of the other possibilities. If sub-sequences
    of a fixed length are required, then there is `partition` or `partition-all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two is that `partition` stops when it has filled
    its last group, while `partition-all` continues, even if this means the final
    sub-sequence won't contain the same number of items.
  prefs: []
  type: TYPE_NORMAL
- en: There is also `partition-by`, which offers more flexibility. In addition to
    the sequence to break apart, `partition-by` takes a function that will be called
    on each item. `partition-by` will then start a new subsequence whenever the return
    value changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we break a sequence into sub-sequences depending on whether the integers
    are greater than or less than 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Because `partition-by` allows you to write your own partitioning function, this
    can be a rather useful function when used creatively.
  prefs: []
  type: TYPE_NORMAL
- en: However, just like `map` and `filter` themselves, none of these functions can
    look at more than one item at a time. What if, for example, we wanted to partition
    a sequence of integers into sequences whose sum was less than 20? To solve this
    kind of problem, we need to be able to consider more than one item at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `reduce` for this, the key is to use a map as an initializer and
    accumulator, with at least two different fields: one for the accumulated sequences
    and one for the current sequence. The accumulator might look as follows, mid-way
    through a reduction, if we are trying to make sequences whose sum is less than
    20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The vectors in `segments` are complete: if one more item was added, their sums
    would exceed 20\. The `:current` vector adds up to 15 right now. If the next item
    in the main sequence is 4 or more, we won''t be able to add it to this vector
    and we''ll move `[5 10]` over to `segments`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how this would work in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look. For convenience, we start by extracting the segments
    and current bindings from the accumulator. Then, we set up a couple of useful
    bindings: `current-with-n` is the current sequence plus the current item, `n`.
    At this point, we don''t know if this is a valid sequence. Its total might go
    beyond the limit of 20\. To check this, we assign another binding (for clarity),
    `total-with-n`, and we compare that to 20.'
  prefs: []
  type: TYPE_NORMAL
- en: If `current-with-n` adds up to more than 20, this means that `current` is a
    valid sub-sequence. In that case, we add it as is (without `n`) to our list of
    accumulated segments, and we place `n` as the first item in a brand new `:current`
    vector. On the other hand, if `current-with-n` does not add up to 20 yet, we just
    append `n` to `current` and keep going.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that the final result is not exactly what we want: the last
    item, `[18]`, is still stuck in `:current`. To present a clean result, we should
    probably wrap our call to `reduce` in a function that will take care of this last
    bit of housekeeping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve made our function a little bit more versatile by adding a `limit`
    parameter so that we can choose other values besides 20\. We also create a binding
    for the result of the call to `reduce` that we then use, at the last line of the
    function, to append the final value of `:current` to the accumulated segments.
    Now we get the result we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This common pattern will allow you to do lots of interesting things with `reduce`.
    In the next two exercises, we will use variations of it to solve two rather different
    kinds of problems.
  prefs: []
  type: TYPE_NORMAL
- en: Looking Back with reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, Clojure's `map` function is extremely useful
    and versatile. The key to understanding `map` is the idea of the one-to-one *mapping*
    (there's that word!) between each item in the input sequence and each item in
    the output sequence. Sometimes, this isn't what we need. The windowing pattern
    we used in *Chapter 4*, *Mapping and Filtering*, is one way to work around this,
    but it has its own limitations. Often, we don't know how "wide" the window needs
    to be. It might depend on the data itself and vary as we move through the input
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this problem quite easily with `reduce` and an accumulator that
    retains a certain number of items. To start with a simple example, let''s suppose
    we have a list of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For each integer in the list, we want to return a two-item tuple containing:'
  prefs: []
  type: TYPE_NORMAL
- en: The integer itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the integer is odd, the sum of the consecutive odd integers preceding it;
    if it's even, the sum of the consecutive even integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following this logic, the first `9` in the list should be replaced with `[9
    0]`, since it is preceded by an even integer. The second `9`, on the other hand,
    should be replaced with `[9 10]`, since it is preceded by a `3` and a `7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is a function that solves this with `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look, starting with the accumulator, a map with two keys
    referencing empty vectors: `:current`, for the current series of integers with
    the same parity; and `:ret`, for the list of values that will be returned. (The
    entire `reduce` expression is wrapped by a `(:ret…)` expression to extract this
    value.)'
  prefs: []
  type: TYPE_NORMAL
- en: The reducing function starts with some destructuring to give us easy access
    to `:current`; now, `n`, of course, is the current integer in the list. Inside
    the function, the structure is quite simple. The `if` expression has a somewhat
    elaborate set of nested logical operators. First, we use `(seq current)` to check
    whether `current` is empty, which would be the case on the first iteration. The
    `seq` function returns `false` if a vector or list is empty. Then, since we know
    `(last current)` will return an integer, we can test to see whether `n` and the
    previous value in the list are both odd or both even.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Because we are using vectors here, `conj` appends new items to the end of the
    vector. To get the most recent item, we use `last`. If we were using lists instead
    of vectors, `conj` would append to the front of the list and we would have to
    use `first` to get the most recent item. When using `conj`, it's important to
    make sure the underlying data structure is what you think it is. Otherwise, your
    results could easily be backward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on which branch of the `if` statement we end up in, we update `acc`
    differently. In the first case, the current integer has the same parity as the
    contents of `current`. We thread `acc` through two calls to `update`. As you remember
    from *Chapter 2*, *Data types and Immutability*, `update` takes a function as
    its second argument, `conj` in this case, because we are adding to the vector,
    and applies it to the value associated with the key provided as the first value.
    We add an additional argument, `[n (apply + current)]`. This will be the second
    argument to `conj`. Altogether, it''s as though we were calling `conj` like this:
    `(conj (:ret acc) [n (apply + current)])`. The second call to `update` adds `n`
    to our running list of integers.'
  prefs: []
  type: TYPE_NORMAL
- en: In the other case, when we are at the beginning of the list or because of a
    change from odd to even or even to odd, we know that the current total is zero.
    Instead of `update`, we can use `assoc` here because we're starting over with
    a fresh list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the function on our sequence of integers gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: The original inputs are followed by the sum of the preceding,
    consecutive integers of the same parity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.4: The original inputs are followed by the sum of the preceding, consecutive
    integers of the same parity'
  prefs: []
  type: TYPE_NORMAL
- en: This would be impossible with `map` because, unlike the windowing technique
    we used, the `:current` vector in the accumulator here can contain as many items
    as necessary, depending on the input. This also shows the flexibility of `reduce`
    when using an accumulator. Now, we can practice using it on a real problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Measuring Elevation Differences on Slopes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The organizers of a bicycle race in a mountainous region want to improve the
    signs they place on the side of the road. Currently, each sign simply indicates
    the distance from the start of the race. The race organizers would like to add
    two more numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: The distance to the top or bottom of the current slope, depending on whether
    that part of the racecourse is gaining or losing elevation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining elevation gain or loss until the end of the current slope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Racecourse sign indicating the remaining distance and elevation
    until'
  prefs: []
  type: TYPE_NORMAL
- en: the top of the current hill
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Racecourse sign indicating the remaining distance and elevation
    until the top of the current hill'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data you have is a list of tuples: the first value is the distance from
    the start of the race, and the second is the elevation at that point. You can
    copy the data from [https://packt.live/38IcEvx](https://packt.live/38IcEvx):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will solve this problem using `reduce` and the "looking back" pattern. There
    is, however, a difficulty we need to resolve first. If we are looking *back*,
    how do we know how far we are from the *next* peak or the *next* valley? Simple:
    we''ll reverse the racecourse data so that when we''re looking back, we''re actually
    looking forward!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, as we descend the slopes, we can "see" forward and
    compare our current position with the peaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: The descent slopes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: The descent slopes'
  prefs: []
  type: TYPE_NORMAL
- en: By reversing the direction, we traverse the data; when we look "back," we are
    looking forward geographically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start writing some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a fresh REPL in an empty directory and open a new file, `bike_race.clj`.
    Add the corresponding namespace declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clojure namespaces use hyphens between words (sometimes referred to as "kebab
    case") but, because of Clojure's Java origins, the corresponding filenames use
    underscores instead (or "snake case"). That's why the `bike-race` namespace is
    in a file named `bike_race.clj`. In *Chapter 8*, *Namespaces, Libraries and Leiningen*
    you will learn more about namespaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the `distance-elevation` var from the book's GitHub repository at [https://packt.live/38IcEvx](https://packt.live/38IcEvx).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the skeleton for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are only a couple of notable differences with the basic "looking back"
    pattern described above. First of all, there is more destructuring for easy access
    to the `distance` and `elevation` values inside the incoming tuple. Secondly,
    the entire call to `reduce` is wrapped inside a `->` threading macro. This is,
    of course, equivalent to `(reverse (:calculated (reduce…)))` but has the advantage
    of organizing the code according to how the data flows through the function. This
    is a fairly common idiom with accumulators when only one of the fields will ultimately
    be returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Otherwise, the general approach is the same: the `:current` field will contain
    all the points on the path up to the *previous* (but geographically *next*) peak
    or valley. The `:calculated` field will store the calculated values so they can
    be returned at the end.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will need to know whether the new position is on the same slope as the positions
    stored in `current`. Are we still going up, or down, or have we gone over a peak,
    or across the lowest part of a valley? To simplify our code, we''ll write a helper
    function, taking `current` and the new elevation. This will return `true` or `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we check whether there is only one value in `current`. If so, we know
    the answer to our question because, with only two points, we know we are on the
    same slope. This also protects our next tests from errors since we can now be
    sure that there are at least two items in `current`. (We still have to be careful
    not to call this function with an empty list.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we know that we have at least two items, we can do some destructuring.
    This destructuring is doubly nested: first, we take the last two elements in `current`,
    using the `take-last` function, and then we extract and name the second part of
    those tuples. To destructure the tuples, we use an underscore, `_`, as a placeholder
    to indicate that we are not interested in the first value. This use of an underscore
    here is simply a Clojure convention that means essentially "don''t pay attention
    to this value."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We named the binding `the-last` instead of simply `last`. This is because of
    Clojure's `last` function. Since we don't use `last` in this scope, we *could*
    have named the binding `last` without a problem. However, it is a good practice
    to avoid using names that coincide with standard Clojure functions. The danger
    is that your local binding might "shadow" a core Clojure function, resulting in
    a confusing bug.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we have three values and we want to see whether they are either all increasing
    or all decreasing. This turns out to be quite simple with Clojure's comparison
    functions, which accept more than two arguments. `(>= next-to-last the-last elevation)`
    will return `true` if `next-to-last` is greater than or equal to `the-last` ,
    and if `the-last` is greater than or equal to `elevation`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the REPL, move to the `bike-race` namespace as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the `same-slope-as-current?` function:![Figure 5.7: Testing the program'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_05_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.7: Testing the program'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It seems to work as expected, including when there is only one value in `current`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The rest of the function will be structured around a `cond` expression with
    three branches to handle the three possible cases: the initial case where `current`
    is empty; the continuing case, when we are on the same slope as what is in `current`;
    and the slope change case, when we have passed a peak or a valley and we need
    to reset `current`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the reducing function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In what we referred to above as the "continuing case," when we are at a position
    that prolongs the slope in `current`, we simply subtract the current elevation
    and distance from the first item in `current`. The "slope change" case is slightly
    more complex because we have to reset `current`, taking care to include the latest
    "peak-or-valley." A figure might make this clearer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.8: The new current starts at the top of the previous peak'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_05_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we are starting over with a new value in `:current`, instead of `update`,
    we use `assoc`, which replaces the old value entirely.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the function using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.9: A partial view of the results'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_05_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.9: A partial view of the results'
  prefs: []
  type: TYPE_NORMAL
- en: In this problem, the most important part of the data is the relationship between
    the items. Problems like this require an approach that allows us to "see" more
    than one item at a time. Unlike the windowing technique we used with map in the
    last chapter, in this problem, we don't know beforehand how far we need to look.
    This is where `reduce` can really shine, because it allows us to shape the accumulator
    to suit the needs of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Winning and Losing Streaks'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will start with a vector of all the matches that Serena
    Williams played in 2015\. Each match is represented by a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t need this data to perform this exercise, but if you''d like to play
    around with the data, it is available here: [https://packt.live/37HKOyC](https://packt.live/37HKOyC).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to add a `:current_streak` field to each match that would say "Lost
    3," if Williams was struggling and had lost her last three matches, or "Won 5":'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a convenient directory, open a REPL and a file called `tennis_reduce.clj`
    with the corresponding namespace definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Clojure, when a namespace contains more than one word, the words are joined
    by hyphens. The corresponding file, however, must use underscores instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We'll use this file and namespace for the rest of the tennis-related exercises
    in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the course's GitHub repository, in [https://packt.live/2sPo4hv](https://packt.live/2sPo4hv),
    copy the `serena-williams-2015` var into your file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the skeleton of a function based on a call to `reduce`, and provide
    an initializer map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The map that we provide as an initial value here shows us the form of the data
    we need for each iteration. The counters for current wins and current losses are
    self-explanatory: we''ll just need to update those values depending on what happens
    in each successive match. `:matches` may seem strange at first, though. It is
    there because we want to return the entire sequence of matches, decorated with
    the new `:current-streak` field. Because of Clojure''s immutability, we can''t
    just modify the matches "in place" as we go along. As we move through the items
    in the `matches` list, we add some data to each match and then place it in the
    `:matches` vector in the accumulator.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extract the matches from the call to `reduce`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `:current-wins` and `:current-losses` fields aren't useful outside of the
    function, so we want to only return the newly decorated matches.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a helper function that formats a string for presenting the current streak:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are three possible situations: a winning streak (at least one win, zero
    losses), a losing streak (at least one loss, zero wins) or no matches played yet
    (zero wins, zero losses). This is a good time to use `cond`, which allows us to
    have multiple conditions without using nested `if` statements. The test for the
    final catch-all condition could be anything at all, except `false` or `nil`. We
    use the `:otherwise` keyword because it is easy to read. And finally, `pos?` is
    a handy and commonly used predicate for determining whether a number is above
    zero, rather than writing `(> current-wins 0)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This logic could have been part of the main reducing function. Breaking it out
    into its own, very simple function makes for easier-to-read code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a skeleton for the reducing function. As usual, it takes two arguments:
    the accumulator, `acc`, and the current match. All we do here is some destructuring
    so that we''ll have easy access to this context inside the function. We also keep
    references to the original maps, `acc` and `match`, because our function will
    end up returning modified versions of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Introduce a `let` binding for the current match and insert it into the `:matches`
    vector in the accumulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Even though our function isn't complete yet, this is the most important part
    of the data flow. The `match` argument is "decorated" with the current streak
    information formatted by the `streak-string` helper function and then inserted
    into the `:matches` vector that the function will return at the end. We don't
    have the contextual information yet, so that is the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step here is to produce the contextual information: we need to update
    `:current-wins` and `:current-losses` in the accumulator so that we''re ready
    for the next iteration. The logic here is that if Williams won the current match,
    then we need to add 1 to the current streak and set the losing streak to zero.
    These will be used for calculating the winning and losing streaks for the next
    match. Conversely, if Williams lost the previous match, we set the current winning
    streak to zero and add 1 to the losing streak.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To translate this logic into code, we''ll start by adding another `let` binding,
    `serena-victory?`, that we will refer to later:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now all that remains is updating `:current-wins` and `:current-losses` in `acc`.
    We''ll use the `->` threading macro because there are several things that need
    to be done to our accumulator:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The calls to `assoc` just apply the conditional logic discussed above, incrementing
    the counters or resetting them to zero. Here is the complete function when we
    put all the parts back together:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try the function on the data. You should see something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.10: Using the function on data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Using the function on data'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows us a couple of different interesting things about using `reduce`.
    The first point is that we are free to create whatever kind of context we would
    like to pass on to each successive iteration of the reducing function. To make
    things simple in this case, we just counted the number of wins or losses, but
    the context can be just as complex as you need it to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second point is that the ultimate return value can also be whatever we
    need it to be. The function in this example actually looks like something you
    might do with `map`: it takes a sequence and returns a sequence of the same length.
    Yet, by building up data from previous calls to the reducing function, it does
    something that `map` would be unable to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing without reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go any further, it's important to point out that sometimes there are
    other, better options than `reduce` for taking a sequence and turning it into
    something non-sequential. Often, this is because Clojure provides functions that
    do the hard work for us. Sometimes, clever use of Clojure's "sequence-to-sequence"
    functions can get you the data you need.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, it is usually preferable to do as much as possible with functions
    that can handle lazy sequences before turning to `reduce`. In some cases, this
    can be for performance reasons, and in nearly all cases, your code will be easier
    to write, and, more importantly, *to read*, if you can stay in the realm of sequences.
    That said, most solutions will require a little of both. Knowing how to combine
    the two is an important skill.
  prefs: []
  type: TYPE_NORMAL
- en: zipmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure's `zipmap` function is a tool for building a map from two sequences.
    The first sequence becomes the keys for the new map and the second becomes the
    values. This is often useful for building a lookup table. Lookup tables can be
    convenient when you need to repeatedly access data in a sequence based on its
    content rather than its position in the list.
  prefs: []
  type: TYPE_NORMAL
- en: It's easy to imagine a scenario where this would be useful. Maybe at one step
    in a program, you have a list of maps, each one containing contact data for a
    person. Later, you discover that you often have a telephone number and need to
    find the corresponding user. If you have a lookup table where the keys are telephone
    numbers, you can find a user with a simple `(get users-by-phone "+44 011 1234
    5678")`. Maps provide easy access, as long as you have meaningful and unique keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic operation of `zipmap` is to align two sequences, one for the keys
    and one for the values, which `zipmap` will "zip" together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Often, you will only have the second list, the values. You will derive values
    from the list and use them as the keys. Just be careful that the keys are unique
    to avoid collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.04: Creating a Lookup Table with zipmap'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are an extremely useful and flexible way to quickly access data. Often,
    however, the data you have is sequential and you find that you would like to be
    able to access an individual item without having to walk the entire sequence.
    If you know the criteria that you'll use to look up the item you need, building
    a lookup table from your data can be an interesting solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you have a list of some of the matches that Petra Kvitova
    played in 2014\. Let''s suppose you need to be able to quickly access the matches
    by date, perhaps to be able to plug them into a calendar of some kind or to test
    which players were playing on the same day. Whatever the reason, you need to build
    a map where the keys are dates and the values are the individual matches. Because
    the same player never plays two matches on the same day, we can be sure that the
    date keys are unique. Here''s how to build the lookup table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following var into your REPL from the book''s GitHub repository: [https://packt.live/39Joc2H](https://packt.live/39Joc2H):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `map` to create a sequence with a date from each match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Combine both sequences into a single map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the map to look up a match by date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a single line of code, you've created a way to quickly find a match for a
    given day. Because it's so concise, this pattern can easily be integrated into
    a more complex function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Building a lookup table like this might seem wasteful in terms of memory resources.
    Aren't we doubling the amount of data in memory? Actually, we aren't. Clojure's
    immutable data structures efficiently share data, which is possible without conflict
    because the data cannot be modified. This means that, in this example, the original
    sequence and the lookup table we've created are basically two ways of accessing
    the same data.
  prefs: []
  type: TYPE_NORMAL
- en: Maps to Sequences, and Back Again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most useful techniques is one that we mentioned briefly in the last
    chapter: using `into` to build a map from a list of paired items. This pattern
    is so versatile that it''s worth taking a closer look.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, the pattern looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Maps, after all, are really just data pairs, and Clojure knows how to convert
    between the two. It''s just as easy to make a sequence of tuples from a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Use a map as a map when that makes sense, but don't hesitate to use it as a
    sequence whenever that's easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need to "modify" a map (in the Clojure sense of not actually modifying,
    but creating a new map with modified data), you may be tempted to use the `keys`
    function to iterate through the values in the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve used `reduce` to multiply each of the values by 10\. This works,
    but it adds complexity and mental overhead to a problem that can be solved more
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We simply interpret the map, `letters-and-numbers`, as a list of key-value pairs.
    In the function supplied to `map`, we've used destructuring to assign `k` and
    `v` to the key and value inside the tuple, which we then wrap up again in a two-item
    vector. Thanks to `into`, we get a map back again in the end.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, there is another version of `reduce` specifically for iterating
    through the key-value pairs in a map, called `reduce-kv`. The main difference
    is that with `reduce-kv`, the reducing function that you provide takes three arguments,
    instead of two: the first is the same as `reduce`, but the next two are the key
    and the corresponding value in the map.'
  prefs: []
  type: TYPE_NORMAL
- en: group-by
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summarizing data in Clojure doesn't always mean calling `reduce` directly. The
    language provides functions that are built on top of `reduce` that are sometimes
    more convenient. `group-by` is one of those functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `group-by` function takes a sequence, calls a function on each item, and
    uses whatever the function call returns as a key in a map. The value of the key
    will be a list of all the items that returned the same key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have a list of maps where each map represents a dish, with
    a `:name` key for the dish''s name, and a `:course` field that tells us what part
    of the meal the dish is served at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With `group-by`, we can organize this list by category. The function we call
    on each item will just be the `:course` keyword, to extract the corresponding
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For most of our examples, we use keywords as map keys. This is usually more
    readable and provides the convenience of using keywords as functions. However,
    Clojure allows us to use any value as map keys. Just like we''ve been using strings
    for the names of tennis players, you can also use any Clojure value as a map key:
    integers, vectors, maps, even functions!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'With *very* little coding, we have a nicely organized map. `group-by` uses
    `reduce` under the hood and really just encapsulates a fairly simple pattern.
    We could write a simplified version of `group-by` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call `our-group-by` on the list of dishes, we get the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The official version will have better performance, but the real advantage of
    a function like `group-by` is that it frees us from thinking about the details.
    Any time you have a list and some categories, `group-by` is ready to help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Quick Summary Statistics with group-by'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll use `group-by` to quickly count the number of matches
    played in different tournaments in our tennis match data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same directory as *Exercise 5.03*, *Winning and Losing Streaks*, create
    a `deps.edn` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the namespace declaration in `tennis_reduce.clj` so that it references
    these two new libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start a REPL in the same directory as the previous exercise, with the same `deps.edn`,
    and then open and evaluate `tennis_reduce.clj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your REPL, move to the `packt-clj.tennis-reduce` namespace as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure that you have the `match_scores_1968-1990_unindexed_csv.csv` file
    in the same directory. This is the same data file we used in *Chapter 4*, *Mapping
    and Filtering*. You can find it here: [https://packt.live/36k1o6X](https://packt.live/36k1o6X).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the now familiar `with-open` macro that we''ve used before, and give
    your function an expressive name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a call to `group-by` that builds a map where the keys are the `:tourney_slug`
    instances and the values are the lists of matches played there. To make the output
    more manageable, temporarily remove all but a few keys in the match maps by mapping
    over the list with `select-keys`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Evaluate the source file and then try calling this function. Define a var so
    that your screen doesn''t fill up with tennis match data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Examine some of the data, first by using the `keys` function, to see all the
    tournament names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look at a single tournament. Once again, limit the data returned, this time
    by using `take`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `count` to obtain the number of matches played in a single tournament:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the total number of matches played in each tournament using `count`
    in the original function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that `select-keys` is gone. Since we are reducing the lists of matches
    to a single integer, there is no point in removing any fields. Here, we use a
    pattern that you have seen before: the call to `map` treats the Clojure map as
    if it were a sequence of key-value pairs. The function passed to `map` then returns
    a two-item vector with the keyword and the newly calculated total. And finally,
    `into` repackages the sequence back into a map.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the file again and call `tennis-csv→tournament-match-counts` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inspect the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we see that the Grand Slam tournaments have the exact same number of matches
    over the same period, because these seven-round tournaments are structured identically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we were able to extract the data we wanted in a few short
    lines of code. Beyond illustrating the power of `group-by`, this is a good example
    of how mapping and reducing can work together. We used `group-by` to structure
    our data, and then `map` to shape it some more. It's easy to imagine using `filter`
    as well, if we wanted to limit the scope of our inquiry to certain players or
    certain tournaments, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing Tennis Scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we were able to generate some summary data from the
    tennis scores, using `filter`. If we wanted to know how many matches a particular
    player had won, we could filter out that player's victories and call `count`.
    While this approach works well when we are only interested in one player, it becomes
    cumbersome if we want more complete data. For example, if we needed to know the
    number of matches played or won by *each* of the players in the dataset, we would
    have to filter, for each query, the entire history of all the matches. The `map`
    and `filter` functions are extremely useful in many situations, but reducing a
    large collection down into a more compact report is not what they are best for.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that for each player, we need to know the number of matches played,
    won, and lost. We'll walk through two different ways to solve the problem in Clojure,
    the first using `reduce` and the second using `group-by`, one of Clojure's many
    convenient `reduce`-based functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the first exercise, we will use a common reducing pattern to build up our
    data, row by row, from the CSV file. Of course, we'll use the three-argument version
    of `reduce` with a map as the accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.06: Complex Accumulation with reduce'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For each row of CSV in the tennis dataset we''ve been using, the work we need
    to do is rather simple: count the wins and losses. In an imperative language,
    the most common approach would be to loop over the results, and for each line
    do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We will do essentially the same thing in Clojure, but within the scope of a
    function passed to `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `tennis_reduce.clj`, start your REPL, evaluate the file, and move to the
    `packt-`Copy in the `with-open` pattern that we''ve used before and prepare the
    skeleton of a call to `reduce`. We''ll call this function `win-loss-by-player`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We won't need the call to `sc/cast-with` this time, since the only values we
    need are strings. And we don't need to call `doall` either, because `reduce` is
    not lazy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the function to pass to `reduce`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we use `->` to thread the accumulator, `acc`, through two calls to `update-in`.
    This function, like `assoc-in`, allows us to access the content of a nested data
    structure by providing a vector as a second argument. Each call in this example
    would look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By repeatedly calling this on the accumulator as `reduce` moves through the
    list of matches, we end up with a large map of player "slugs" mapped to small
    maps each containing a `:wins` key and a `:losses` key:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Evaluate your file and try running the function on the CSV data. Put the results
    in a var to avoid filling up your screen with all the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look up a player, using the "slug":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need to use `get` here because the keys in our map are strings. If we had
    used the `keyword` function to convert the player "slugs" when building up the
    map, we could access a player's data with `(:roger-federer w-l)` instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Introduction to Elo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the rest of this chapter, and in some of the following chapters, we are going
    to be working with the Elo Rating System to develop player ratings and predict
    match outcomes. The algorithm itself is quite simple and it will allow us to demonstrate
    how Clojure can be used as a data analysis tool. Since we'll be referring to it
    a lot, it's worth taking a closer look at how it works. The Elo Rating System
    was developed by Arpad Elo to rate chess players. The United States Chess Federation
    began using it in 1960.
  prefs: []
  type: TYPE_NORMAL
- en: Elo ratings work by establishing a score for each player. This score is used
    to calculate the probable outcome of a match. When the real outcome of the match
    is known, a player's rating is raised or lowered depending on their performance
    relative to the probable outcome. In other words, if a beginner with a low rating
    loses to a higher-rated player, the beginner's rating will not suffer by much,
    since that outcome was expected. If they defeat the higher-rated player, on the
    other hand, their rating will increase by a much greater margin, and the higher-rated
    player's rating will be diminished accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The obvious question is, of course, how do we know a player''s rating to start
    with? This requires looking at their previous matches, and the rating of their
    opponents, which, in turn, are determined by the ratings of *their* opponents,
    and so on. If that sounds recursive, it''s because it is. Our strategy will take
    the form of a complex reduction: starting at the earliest match, we will accumulate
    player ratings, which we will then use to calculate the scores for each successive
    match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Reducing from match to match: each result improves the ratings
    for the next match'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Reducing from match to match: each result improves the ratings
    for the next match'
  prefs: []
  type: TYPE_NORMAL
- en: 'Does this look familiar? It might, because we are doing the same thing as in
    the previous reductions: calculating a context, moving it forward, and using it
    again for the next calculation. The difference with this project is that the context
    is much more complex. Our method for moving through the data is fundamentally
    the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can perform this reduction, we need to build a few key pieces of
    the Elo implementation. At the heart of the Elo system is a simple formula for
    determining the probability of a player winning a given match. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Calculating the probability of outcomes for a given match'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Calculating the probability of outcomes for a given match'
  prefs: []
  type: TYPE_NORMAL
- en: '*P*1 and *P*2 here are the probabilities of winning for player one and player
    two. *R*1 and *R*2 are their respective ratings before the match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we fill in the values for a match between a player, rated at 700, and a
    stronger player, rated at 1,000, we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Example Elo calculation for a single match'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: Example Elo calculation for a single match'
  prefs: []
  type: TYPE_NORMAL
- en: The *P*1 value indicates that there is a 15% chance that the weaker player will
    win the match and an 85% chance that the stronger player will win. The reliability
    of these percentages depends, of course, on the quality of the ratings. Before
    we look at how the ratings are calculated, though, let's translate these equations
    into Clojure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.07: Calculating Probabilities for a Single Match'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll set up one of the building blocks for our implementation
    of the Elo system, the formula for calculating the probabilities of victory for
    each of the two players in a match, based on their current ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same folder as in the previous exercises, add `math.numeric-tower`,
    which is Clojure''s standard `math` library, to your `deps.edn` file. It should
    look like this now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `tennis_reduce.clj`, update the namespace declaration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open a REPL session, evaluate `tennis_reduce.clj`, and move to the `packt-clj.tennis-reduce`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a function implementing the formula for calculating the probability of
    a player defeating another player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try your function with players of different strengths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the match is finally played, if the strong player wins, their rating will
    increase modestly (and their opponent's rating will go down slightly) because
    the result was not a surprise. If the weaker player wins, on the other hand, the
    change to the ratings will be much more significant.
  prefs: []
  type: TYPE_NORMAL
- en: 'This equation shows how the player''s score is updated after a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Equation to calculate the player’s score'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: Equation to calculate the player''s score'
  prefs: []
  type: TYPE_NORMAL
- en: A player's new rating (*R'*) is based on their previous rating (*R*), the match
    score (*S*), the expected score (*ES*), and the *K* factor.
  prefs: []
  type: TYPE_NORMAL
- en: The score (*S*) of a tennis match is either 0, for a loss, or 1, for a victory.
    If a player is expected to win by a probability of 0.75 and they go on to win
    their match, then the (*S* - *ES*) part of the equation works out to 1 - 0.75
    = 0.25\. This result gets multiplied by what the Elo system calls the "*K* factor."
    The *K* factor determines the impact of a match result on a player's overall rating.
    A high *K* factor means ratings will move around a lot; a low *K* factor means
    they will be more stable. If we use a *K* factor of 32, that gives us 32 * 0.25
    = 8, so the player's rating in this example would go up by eight points. If the
    player had lost instead, we would get 32 * (0 - 0.75) = -24\. Once again, unexpected
    results thus have a much greater impact on ratings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.08: Updating Player Ratings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will update the player ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file and REPL session as the previous exercise, define a `k-factor`
    var and a function that encapsulates the equation for updating a player''s rating
    after a match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's test the equation with some outputs from the `match-probability`
    function that we defined earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A player rated 1,500 loses to a slightly weaker player (1,400):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The player's rating has gone down by almost 21 points.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A player with a low rating, 400, scores an upset victory against a strong player (1,000):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the supposedly weaker player gains 31 points, which is close
    to the maximum possible gain per match when *K* is 32\. This shows how *K* determines
    the importance of a single match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These two equations are all the math we need. That's it! The beauty of the Elo
    system is that the actual calculations are quite simple. Now, it's time to start
    using the functions we've written on some real data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Calculating Elo Ratings for Tennis'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sports journalism website has asked you to provide improved ratings for the
    men's professional tennis circuit. They want to know the relative strengths of
    current players, as well as the strength of a given player during a given year
    in the past. Most of all, the journalists want high-quality predictions for future
    matches.
  prefs: []
  type: TYPE_NORMAL
- en: Your assignment is to build the prototype for this new system. A REPL-based
    implementation is fine for now, but it's important to be able to demonstrate the
    accuracy of your results based on past match data.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you'll need to write a function that parses the CSV file that we've
    been working with, using `reduce`. The function will not only calculate player
    ratings. It will also keep track of its own success rate in predicting match results.
    This will allow you to show the journalists how well your algorithm works, and
    before that, it will allow you to tweak your code to obtain the best possible
    predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your accumulator map will need to build up the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player ratings**: This is the most important part: a huge map linking each
    player to his rating. The map will be updated with the new ratings for the two
    players in the match being analyzed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Success count**: For each match where one of the two players has a better
    than 50% chance of winning, did the expected winner actually win? By counting
    successes, you''ll be able to divide by the total number of match predictions
    to determine the precision of your predictions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total match count**: The total number of matches that have been considered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prediction count**: The number of matches where a winner could be predicted
    – that is, matches where the forecast was not 50-50\. Since we''re excluding those
    matches from the success count, we need to exclude them from the prediction count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set up your project with a `deps.edn` file containing the necessary references
    to the Clojure libraries you will use and include the tennis data files from [https://packt.live/37DCkZn](https://packt.live/37DCkZn).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place your work in a new file and namespace. Include the `recalculate-rating`
    and `match-probability` functions from the previous exercises.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the skeleton for a new function. It should accept two arguments: the
    path to the CSV file and a *K* factor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt the pattern based around `with-open` used in previous activities and exercises
    for reading the file, mappifying each line and converting useful fields to integers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a call to `reduce` that will encompass most of the remaining logic you
    need to write.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design an initializer/accumulator map as the second argument to `reduce` that
    will adequately keep track of all the information you need to pass on from one
    iteration to the next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code to update the accumulator after each match. Use the functions
    you already have to predict a winner and adjust the ratings according to the actual
    result of the match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your function on the tennis datasets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When testing, the results will be huge, so remember to assign them to a var.
    Check your results in the REPL by querying the result map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should be able to query your results like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.15: Expected query results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: Expected query results'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also be able to check how often the match predictions were correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Checking the match prediction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_05_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.16: Checking the match prediction'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 693.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this chapter, we''ve taken another important step forward in our exploration
    of Clojure''s collections and how to use them to solve problems. Techniques involving
    collections will always be at the heart of your Clojure programming experience:
    they will inform how you organize your code, as well as how you choose and design
    your data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at flexible ways to work with the collections
    in Clojure.
  prefs: []
  type: TYPE_NORMAL
