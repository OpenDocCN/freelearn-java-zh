<html><head></head><body>
		<div id="_idContainer021">
			<h1 id="_idParaDest-41"><em class="italic"><a id="_idTextAnchor040"/>Chapter 3</em>: jOOQ Core Concepts</h1>
			<p>Before exploring more awesome features of jOOQ, we have to cover the core (fundamental) concepts that jOOQ relies on. Having a decent insight into jOOQ core concepts helps us to make the right decisions and to understand how jOOQ works under the hood. Don't worry, our aim is not to enter the jOOQ bowels! We aim to bring you close to the jOOQ paradigm and start thinking about your persistent layer in the jOOQ context.</p>
			<p>The goal of this chapter is to briefly introduce the following topics:</p>
			<ul>
				<li>Hooking jOOQ results (<strong class="source-inline">Result</strong>) and records (<strong class="source-inline">Record</strong>)</li>
				<li>Exploring jOOQ query types</li>
				<li>Understanding the jOOQ fluent API</li>
				<li>Highlighting how jOOQ emphasizes SQL syntax correctness</li>
				<li>Casting, coercing, and collating</li>
				<li>Binding values (parameters)</li>
			</ul>
			<p>By the end of this chapter, you'll be familiar with the jOOQ core concepts that will help you to easily follow the upcoming chapters. </p>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter03">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter03</a>.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Hooking jOOQ results (Result) and records (Record)</h1>
			<p>In the <a id="_idIndexMarker127"/>previous<a id="_idIndexMarker128"/> chapters, we've mapped the JDBC result set of our queries to POJOs via the jOOQ <strong class="source-inline">fetchInto()</strong> method. But, in jOOQ, between the JDBC result set and a well-known <strong class="source-inline">List&lt;POJO&gt;</strong> (or other data structure such as an array, map, and set), there is another fundamental layer referenced as <strong class="source-inline">Result&lt;Record&gt;</strong> represented from the following two interfaces:</p>
			<ul>
				<li><strong class="source-inline">org.jooq.Record</strong>: When we trigger a <strong class="source-inline">SELECT</strong> query, we get back a result set that contains a list of columns and the corresponding list of values. Typically, we refer to the content of the result set as <em class="italic">records</em>. jOOQ maps each such <em class="italic">record</em> to its <strong class="source-inline">Record</strong> interface. Think of <strong class="source-inline">Record</strong> as the jOOQ internal representation of <em class="italic">records</em>.</li>
				<li><strong class="source-inline">org.jooq.Result</strong>: The jOOQ <strong class="source-inline">Result</strong> interface is a <strong class="source-inline">java.util.List</strong> of <strong class="source-inline">org.jooq.Record</strong>. In other words, jOOQ maps each <em class="italic">record</em> of the result set to a <strong class="source-inline">Record</strong> and collects this record in <strong class="source-inline">Result</strong>. Once <strong class="source-inline">Result&lt;Record&gt;</strong> is complete (the whole result set was processed), it can be mapped into an array, a set/list of POJOs, or a map, or it can be returned as it is.</li>
			</ul>
			<p>The following figure represents this straightforward path: JDBC result set | jOOQ <strong class="source-inline">Result&lt;Record&gt;</strong> | array/list/set/map:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B16833_Figure_3.1.jpg" alt="Figure 3.1 – Processing of the JDBC ResultSet&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Processing of the JDBC ResultSet</p>
			<p>As you can see from this figure, we can fetch the result set as type-specific to the application's needs (for instance, <strong class="source-inline">List&lt;POJO&gt;</strong>), but we can fetch the result set directly as <strong class="source-inline">Result&lt;Record&gt;</strong> as well. If you come from the JPA area, then you may think that the jOOQ <strong class="source-inline">Record</strong> is somehow similar to JPA entities, but this is not true. In jOOQ, there is no equivalent of persistence context (first-level cache), and jOOQ doesn't perform any kind of heavy lifting on these objects such as state transitions and auto-flushes. Most <a id="_idIndexMarker129"/>of the time, you can use records through the jOOQ<a id="_idIndexMarker130"/> API directly since you'll not even need a POJO.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In jOOQ, by default, the JDBC result set is fetched into memory eagerly (all data projected by the current query will be stored in memory), but as you'll see in <a href="B16833_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>,<em class="italic"> Fetching and Mapping</em>, we can operate on large result sets "lazily" using <strong class="source-inline">fetchLazy()</strong> and the <strong class="source-inline">Cursor</strong> type. Mapping the JDBC result set to <strong class="source-inline">Result&lt;Record&gt;</strong> comes with multiple benefits of which we highlight the following:</p>
			<p class="callout">a) <strong class="source-inline">Result&lt;Record&gt;</strong> represents non-type-safe query results, but it can also represent type-safe query results via <strong class="source-inline">Record</strong> specializations such as table records, updatable records, and degree records up to degree 22 (number 22 is derived from Scala – <a href="https://stackoverflow.com/q/6241441/521799">https://stackoverflow.com/q/6241441/521799</a>).</p>
			<p class="callout">b) After fully loading <strong class="source-inline">Result&lt;Record&gt;</strong> into memory, jOOQ frees the resources as early as possible. It is preferable to operate on an in-memory <strong class="source-inline">Result&lt;Record&gt;</strong> instead of operating on a JDBC result set holding open a connection to the database.</p>
			<p class="callout">c) <strong class="source-inline">Result&lt;Record&gt;</strong> can be easily exported to XML, CSV, JSON, and HTML.</p>
			<p class="callout">d) jOOQ exposes a friendly and comprehensive API for manipulating <strong class="source-inline">Result&lt;Record&gt;</strong>, therefore, for manipulating the result set.</p>
			<p>jOOQ supports a<a id="_idIndexMarker131"/> few types of <strong class="source-inline">Record</strong> as follows:</p>
			<ul>
				<li><strong class="bold">Table records</strong>: These records are implemented via <strong class="source-inline">org.jooq.TableRecord</strong> and <strong class="source-inline">org.jooq.UpdatableRecord</strong> (records that can be stored back in the database again). A <strong class="source-inline">TableRecord</strong>/<strong class="source-inline">UpdatableRecord</strong> record originates from a single table (or view) having a primary key. Only <strong class="source-inline">UpdatableRecord</strong>s have a (known to jOOQ) primary key. The jOOQ Code Generator can produce this type of record on our behalf – for instance (check out our previous applications), the <strong class="source-inline">jooq.generated.tables.records</strong> package, which contains <strong class="source-inline">CustomerRecord</strong>, <strong class="source-inline">EmployeeRecord</strong>, and <strong class="source-inline">OfficeRecord</strong>. All these table records have been generated via the jOOQ generator and are strongly typed.</li>
				<li><strong class="bold">Records of well-defined degree</strong>: jOOQ defines 22 interfaces that extend <strong class="source-inline">Record</strong> with the purpose of providing type-safety for queries that project custom record types in SQL. The query can contain records originating from a single table or from multiple tables. jOOQ will choose the proper <strong class="source-inline">Record1</strong> ... <strong class="source-inline">Record22</strong> interface and will pick up the correct types to guarantee the type-safety of query <a id="_idIndexMarker132"/>results.<p class="callout-heading">Important Note</p><p class="callout">This kind of type-safety is applied to records for degrees up to 22. This also applies to row value expressions, subselects that are combined by a set operator (for example, <strong class="source-inline">UNION</strong>), <strong class="source-inline">IN</strong> predicates and comparison predicates taking subselects, and <strong class="source-inline">INSERT</strong> and <strong class="source-inline">MERGE</strong> statements that take type-safe <strong class="source-inline">VALUES()</strong> clauses. Beyond degree 22, there is no type-safety.</p></li>
				<li><strong class="bold">UDT records</strong>: These <a id="_idIndexMarker133"/>records are useful for supporting <strong class="bold">User-Defined Types</strong> (<strong class="bold">UDTs</strong>) specific to Oracle and PostgreSQL. They are represented in jOOQ via the <strong class="source-inline">org.jooq.UDTRecord</strong> API.</li>
				<li><strong class="bold">Embeddable records</strong>: These records represent synthetic UDTs <a id="_idIndexMarker134"/>and they are implemented via <strong class="source-inline">org.jooq.EmbeddableRecord</strong>. This topic is covered in <a href="B16833_07.xhtml#_idTextAnchor110"><em class="italic">Chapter 7</em></a>, <em class="italic">Types, Converters, and Bindings</em>.</li>
			</ul>
			<p>Let's see several examples of fetching jOOQ records.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Fetching Result&lt;Record&gt; via plain SQL</h2>
			<p>In jOOQ, <a id="_idIndexMarker135"/>plain <a id="_idIndexMarker136"/>SQL, such as an SQL string, returns an anonymous type-safe <strong class="source-inline">Result&lt;Record&gt;</strong>. Here are two examples:</p>
			<pre class="source-code">/* non type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;Record&gt; result = ctx.fetch(</pre>
			<pre class="source-code">  "SELECT customer_name, customer_number, credit_limit</pre>
			<pre class="source-code">   FROM customer");</pre>
			<pre class="source-code">/* non type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;Record&gt; result = ctx.resultQuery(</pre>
			<pre class="source-code">  "SELECT customer_name, customer_number, credit_limit</pre>
			<pre class="source-code">   FROM customer").fetch();</pre>
			<p>Iterating <strong class="source-inline">Result</strong> is like iterating <strong class="source-inline">java.util.List</strong>. Each <strong class="source-inline">Record</strong> can be accessed via a comprehensive API that, among other methods, exposes more than 10 <strong class="source-inline">get()</strong>/<strong class="source-inline">getValue()</strong> methods for retrieving values from records in a non type-safe manner. Consider the following example:</p>
			<pre class="source-code">/* non type-safe values */</pre>
			<pre class="source-code">for (Record record : result) {</pre>
			<pre class="source-code">  // get value by index</pre>
			<pre class="source-code">  Object r1 = record.get(0);</pre>
			<pre class="source-code">  // get value by name</pre>
			<pre class="source-code">  Object r2 = record.get("customer_number");</pre>
			<pre class="source-code">  // get value by name and type</pre>
			<pre class="source-code">  BigDecimal r3 = record.getValue(</pre>
			<pre class="source-code">    "credit_limit", BigDecimal.class);</pre>
			<pre class="source-code">}</pre>
			<p>Pay attention to <strong class="source-inline">r3</strong>. Our example works just fine, but if the specified type is not the proper one for the specified column (in other words, the data type cannot be converted, but conversion is possible), then we'll get a jOOQ <strong class="source-inline">DataTypeException</strong> or, even worse, you'll silently use the results of an apparently successful conversion that may have an improper representation. Moreover, typos in column names or columns that don't exist will cause <strong class="source-inline">java.lang.IllegalArgumentException</strong>.</p>
			<p>In order to avoid such unpleasant cases, from this point forward, we rely on classes obtained via the jOOQ Code Generator. This gives us a tremendous boost in productivity and a wide <a id="_idIndexMarker137"/>range of features. Hmmm, have I told you <a id="_idIndexMarker138"/>that you should always count on the jOOQ Code Generator? Anyway, let's continue with examples.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Fetching Result&lt;Record&gt; via select()</h2>
			<p>The <a id="_idIndexMarker139"/>parameter-less <strong class="source-inline">select()</strong> method <a id="_idIndexMarker140"/>of <strong class="source-inline">DSLContext</strong> results in a projection that includes all columns. It also produces a non-type-safe <strong class="source-inline">Result&lt;Record&gt;</strong>. This time, we use the Java-based schema produced by the jOOQ Code Generator:</p>
			<pre class="source-code">/* non type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;Record&gt; result = ctx.select().from(CUSTOMER).fetch();</pre>
			<p>Even if <strong class="source-inline">Result&lt;Record&gt;</strong> is non-type-safe, the values of records can be type-safely extracted via the jOOQ generated classes. More precisely, we use the attributes of the generated <strong class="source-inline">Customer</strong> class as follows (<strong class="source-inline">CUSTOMER</strong> is <strong class="source-inline">static</strong>):</p>
			<pre class="source-code">/* type-safe values */</pre>
			<pre class="source-code">for (Record r : result) {</pre>
			<pre class="source-code">  String r1 = r.get(CUSTOMER.CUSTOMER_NAME);</pre>
			<pre class="source-code">  Long r2 = r.get(CUSTOMER.CUSTOMER_NUMBER);</pre>
			<pre class="source-code">  BigDecimal r3 = r.get(CUSTOMER.CREDIT_LIMIT);</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>One step further, we<a id="_idIndexMarker141"/> can express this <a id="_idIndexMarker142"/>non-type-safe <strong class="source-inline">Result&lt;Record&gt;</strong> as a type-safe one.</p>
			<h3>Mapping org.jooq.Record into a strongly-typed org.jooq.TableRecord</h3>
			<p>Since we<a id="_idIndexMarker143"/> fetch data from a<a id="_idIndexMarker144"/> single table having a primary key (<strong class="source-inline">CUSTOMER</strong>), we can use <strong class="source-inline">TableRecord</strong> associated by jOOQ with the database table.</p>
			<p>Transforming the previous non-type-safe <strong class="source-inline">Result&lt;Record&gt;</strong> into a type-safe one can be done by mapping <strong class="source-inline">org.jooq.Record</strong> into the corresponding strongly-typed <strong class="source-inline">org.jooq.TableRecord</strong> via the <strong class="source-inline">Record.into(Table&lt;Z&gt; table)</strong> method. In this case, the corresponding strongly-typed <strong class="source-inline">org.jooq.TableRecord</strong> is <strong class="source-inline">CustomerRecord</strong>. Check out the following code:</p>
			<pre class="source-code">/* type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;CustomerRecord&gt; result = ctx.select().from(CUSTOMER)</pre>
			<pre class="source-code">  .fetch().into(CUSTOMER);</pre>
			<p>The same thing can be done via <strong class="source-inline">Record.into(Class&lt;? extends E&gt; type)</strong>:</p>
			<pre class="source-code">/* type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">List&lt;CustomerRecord&gt; result = ctx.select().from(CUSTOMER)</pre>
			<pre class="source-code">  .fetch().into(CustomerRecord.class);</pre>
			<p>This time, we can use the <strong class="source-inline">CustomerRecord</strong> getters to access the values of records:</p>
			<pre class="source-code">/* type-safe values */</pre>
			<pre class="source-code">for (CustomerRecord r : result) {</pre>
			<pre class="source-code">  String r1 = r.getCustomerName();</pre>
			<pre class="source-code">  Long r2 = r.getCustomerNumber();</pre>
			<pre class="source-code">  BigDecimal r3 = r.getCreditLimit();</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>Let's see <a id="_idIndexMarker145"/>what<a id="_idIndexMarker146"/> happens if we enrich this query to fetch data from two (or more) tables.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Fetching Result&lt;Record&gt; via select() and join()</h2>
			<p>Let's <a id="_idIndexMarker147"/>enrich <strong class="source-inline">ctx.select().from(CUSTOMER)</strong> with<a id="_idIndexMarker148"/> a <strong class="source-inline">JOIN</strong> clause <a id="_idIndexMarker149"/>to fetch <a id="_idIndexMarker150"/>records from <strong class="source-inline">CUSTOMERDETAIL</strong> as well (there is a one-to-one relationship between <strong class="source-inline">CUSTOMER</strong> and <strong class="source-inline">CUSTOMERDETAIL</strong>):</p>
			<pre class="source-code">/* non type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;Record&gt; result = ctx.select()</pre>
			<pre class="source-code">  .from(CUSTOMER)</pre>
			<pre class="source-code">  .join(CUSTOMERDETAIL)</pre>
			<pre class="source-code">    .on(CUSTOMER.CUSTOMER_NUMBER</pre>
			<pre class="source-code">      .eq(CUSTOMERDETAIL.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>The values of records can be type-safely extracted from the attributes of the generated <strong class="source-inline">Customer</strong> and <strong class="source-inline">Customerdetail</strong> class:</p>
			<pre class="source-code">/* type-safe values */</pre>
			<pre class="source-code">for (Record r : result) {</pre>
			<pre class="source-code">  String r1 = r.get(CUSTOMER.CUSTOMER_NAME);</pre>
			<pre class="source-code">  Long r2 = r.get(CUSTOMER.CUSTOMER_NUMBER);</pre>
			<pre class="source-code">  BigDecimal r3 = r.get(CUSTOMER.CREDIT_LIMIT);</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  String r4 = r.get(CUSTOMERDETAIL.CITY);</pre>
			<pre class="source-code">  String r5 = r.get(CUSTOMERDETAIL.COUNTRY);</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>Re-writing <a id="_idIndexMarker151"/>this <a id="_idIndexMarker152"/>non-type-safe <strong class="source-inline">Result&lt;Record&gt;</strong> as a type-safe <a id="_idIndexMarker153"/>one <a id="_idIndexMarker154"/>is a little bit verbose. Let's see how to do it.</p>
			<h3>Mapping org.jooq.Record into a strongly-typed org.jooq.TableRecord</h3>
			<p>Transforming<a id="_idIndexMarker155"/> the <a id="_idIndexMarker156"/>previous non-type-safe <strong class="source-inline">Result&lt;Record&gt;</strong> into a type-safe one can be done via the proper <strong class="source-inline">select(SelectField&lt;T1&gt;, SelectField&lt;T2&gt;...SelectField&lt;T22&gt;)</strong> or <strong class="source-inline">into(Field&lt;T1&gt;, Field&lt;T2&gt; ... Field&lt;T22&gt;)</strong> method and the proper <strong class="source-inline">Record[N]</strong> interface, <strong class="source-inline">N=1..22</strong>. Our schema reveals that the <strong class="source-inline">CUSTOMER</strong> and <strong class="source-inline">CUSTOMERDETAIL</strong> tables contain a total of 15 fields, therefore, the proper <strong class="source-inline">Record[N]</strong> is <strong class="source-inline">Record15</strong> and we use the <strong class="source-inline">select(SelectField&lt;T1&gt;, SelectField&lt;T2&gt;... SelectField&lt;T15&gt;)</strong> counterpart:</p>
			<pre class="source-code">/* type-safe Result&lt;Record&gt; via select() */        </pre>
			<pre class="source-code">Result&lt;Record15&lt;Long, String, String, String, </pre>
			<pre class="source-code">  String, Long, BigDecimal, Integer, Long, String, String, </pre>
			<pre class="source-code">  String, String, String, String&gt;&gt; result</pre>
			<pre class="source-code">  = ctx.select(CUSTOMER.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">    CUSTOMER.CUSTOMER_NAME,CUSTOMER.CONTACT_FIRST_NAME, </pre>
			<pre class="source-code">    CUSTOMER.CONTACT_LAST_NAME,CUSTOMER.PHONE, </pre>
			<pre class="source-code">    CUSTOMER.SALES_REP_EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">    CUSTOMER.CREDIT_LIMIT,CUSTOMER.FIRST_BUY_DATE,</pre>
			<pre class="source-code">    CUSTOMERDETAIL.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">    CUSTOMERDETAIL.ADDRESS_LINE_FIRST,</pre>
			<pre class="source-code">    CUSTOMERDETAIL.ADDRESS_LINE_SECOND, </pre>
			<pre class="source-code">    CUSTOMERDETAIL.CITY,CUSTOMERDETAIL.COUNTRY, </pre>
			<pre class="source-code">    CUSTOMERDETAIL.POSTAL_CODE,CUSTOMERDETAIL.STATE)</pre>
			<pre class="source-code">      .from(CUSTOMER)</pre>
			<pre class="source-code">      .join(CUSTOMERDETAIL)</pre>
			<pre class="source-code">      .on(CUSTOMER.CUSTOMER_NUMBER.eq(</pre>
			<pre class="source-code">        CUSTOMERDETAIL.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">      .fetch();</pre>
			<p>Or, we<a id="_idIndexMarker157"/> can <a id="_idIndexMarker158"/>use the <strong class="source-inline">into(Field&lt;T1&gt;, Field&lt;T2&gt; ... Field&lt;T15&gt;)</strong> counterpart:</p>
			<pre class="source-code">/* type-safe Result&lt;Record&gt;via into() */</pre>
			<pre class="source-code">Result&lt;Record15&lt;Long, String, String, String, </pre>
			<pre class="source-code">         String, Long, BigDecimal, Integer, Long, String,  </pre>
			<pre class="source-code">         String, String, String, String, String&gt;&gt; result =  </pre>
			<pre class="source-code">   ctx.select()</pre>
			<pre class="source-code">      .from(CUSTOMER)</pre>
			<pre class="source-code">      .join(CUSTOMERDETAIL)</pre>
			<pre class="source-code">         .on(CUSTOMER.CUSTOMER_NUMBER</pre>
			<pre class="source-code">            .eq(CUSTOMERDETAIL.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">      .fetch()</pre>
			<pre class="source-code">      .into(CUSTOMER.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">    CUSTOMER.CUSTOMER_NAME, CUSTOMER.CONTACT_FIRST_NAME, </pre>
			<pre class="source-code">    CUSTOMER.CONTACT_LAST_NAME,CUSTOMER.PHONE, </pre>
			<pre class="source-code">    CUSTOMER.SALES_REP_EMPLOYEE_NUMBER, CUSTOMER.CREDIT_LIMIT, </pre>
			<pre class="source-code">    CUSTOMER.FIRST_BUY_DATE, CUSTOMERDETAIL.CUSTOMER_NUMBER,   </pre>
			<pre class="source-code">    CUSTOMERDETAIL.ADDRESS_LINE_FIRST, </pre>
			<pre class="source-code">    CUSTOMERDETAIL.ADDRESS_LINE_SECOND, CUSTOMERDETAIL.CITY,</pre>
			<pre class="source-code">    CUSTOMERDETAIL.COUNTRY, CUSTOMERDETAIL.POSTAL_CODE,</pre>
			<pre class="source-code">    CUSTOMERDETAIL.STATE);</pre>
			<p>Obviously, we<a id="_idIndexMarker159"/> have 22 such <strong class="source-inline">select()</strong> and <strong class="source-inline">into()</strong> methods, but <a id="_idIndexMarker160"/>we need the one that corresponds to our records' degree.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Have you noticed the <strong class="source-inline">Record15&lt;…&gt;</strong> construction? Of course you have! It's hard to miss! Besides the obvious verbosity, it is not that easy to fill up the data types as well. You have to identify and write down each data type of the fetched fields in the correct order. Fortunately, we can avoid this torturous step by using the Java 9 <strong class="source-inline">var</strong> keyword. Once you have practiced the examples from this chapter and you've got familiar with <strong class="source-inline">Record[N]</strong>, consider using <strong class="source-inline">var</strong> whenever you don't have a good reason to manually write down <strong class="source-inline">Record[N]</strong>. On the other hand, if you are using Kotlin/Scala, then you can take advantage of better support for tuple-style data structures and rely on automatic destructuration of <strong class="source-inline">Record[N]</strong>as <strong class="source-inline">val(a, b, c) = select(A, B, C)</strong>. For more details, consider this example: <a href="https://github.com/jOOQ/jOOQ/tree/main/jOOQ-examples/jOOQ-kotlin-example">https://github.com/jOOQ/jOOQ/tree/main/jOOQ-examples/jOOQ-kotlin-example</a>. So far, in Java, the previous two examples can be expressed using <strong class="source-inline">var</strong> as follows:</p>
			<p class="callout"><strong class="source-inline">var result = ctx.select(...);</strong></p>
			<p class="callout"><strong class="source-inline">var result = ctx.select()...into(...);</strong></p>
			<p>The records values can be accessed in the same way via the attributes of the generated <strong class="source-inline">Customer</strong> and <strong class="source-inline">Customerdetail</strong> classes. But, can we access it via the corresponding<a id="_idIndexMarker161"/> table<a id="_idIndexMarker162"/> records? </p>
			<h3>Extracting the two TableRecords from Record</h3>
			<p>Extracting<a id="_idIndexMarker163"/> the<a id="_idIndexMarker164"/> two individual strongly-typed <strong class="source-inline">TableRecord</strong> types (<strong class="source-inline">CustomerRecord</strong> and <strong class="source-inline">CustomerdetailRecord</strong>) from the denormalized <strong class="source-inline">Record</strong> can be done via the <strong class="source-inline">Record.into(Table&lt;Z&gt; table)</strong> method. I bet you didn't think that this was possible:</p>
			<pre class="source-code">Result&lt;CustomerRecord&gt; rcr=result.into(CUSTOMER);</pre>
			<pre class="source-code">Result&lt;CustomerdetailRecord&gt; rcd=result.into(CUSTOMERDETAIL);</pre>
			<p>Further, we can rely on the built-in getters of <strong class="source-inline">CustomerRecord</strong> and <strong class="source-inline">CustomerdetailRecord</strong> to access the corresponding values.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Fetching Result&lt;Record&gt; via selectFrom()</h2>
			<p>The best<a id="_idIndexMarker165"/> approach for selecting, in a type-safe<a id="_idIndexMarker166"/> manner, all the columns from a single table into <strong class="source-inline">Result&lt;Record&gt;</strong> relies on the <strong class="source-inline">selectFrom(table)</strong> method. In this context, jOOQ returns the record type supplied with the argument table, therefore, it returns <strong class="source-inline">TableRecord</strong>. Check out the code:</p>
			<pre class="source-code">/* type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;CustomerRecord&gt; result </pre>
			<pre class="source-code">  = ctx.selectFrom(CUSTOMER).fetch();</pre>
			<p>Further, the <strong class="source-inline">CustomerRecord</strong> getters return the values:</p>
			<pre class="source-code">/* type-safe values */</pre>
			<pre class="source-code">for (CustomerRecord r : result) {</pre>
			<pre class="source-code">  String r1 = r.getCustomerName();</pre>
			<pre class="source-code">  Long r2 = r.getCustomerNumber();</pre>
			<pre class="source-code">  BigDecimal r3 = r.getCreditLimit();</pre>
			<pre class="source-code">  ... </pre>
			<pre class="source-code">}</pre>
			<p>While this <a id="_idIndexMarker167"/>is really cool, please consider the<a id="_idIndexMarker168"/> following important note as well.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Don't consider that <strong class="source-inline">select().from(table)</strong>and <strong class="source-inline">selectFrom(table)</strong> are the same thing. The former, <strong class="source-inline">select().from(table)</strong>, returns a non-type-safe <strong class="source-inline">Result&lt;Record&gt;</strong> and we can use any clause that modifies the type of the table expression (for instance, <strong class="source-inline">JOIN</strong>). On the other hand, <strong class="source-inline">selectFrom(table)</strong> returns a type-safe <strong class="source-inline">Result&lt;TableRecord&gt;</strong> and doesn't permit the usage of any clause that modifies the type of the table expression.</p>
			<p>Next, let's tackle ad hoc selects.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Fetching Result&lt;Record&gt; via ad hoc selects</h2>
			<p>In ad hoc <a id="_idIndexMarker169"/>selects, we enlist the needed <a id="_idIndexMarker170"/>columns that can originate in one or more tables. As long as we enlist the columns explicitly and rely on Java-based schema, jOOQ will determine the correct types and will prepare a record of a certain degree. Here is an example that selects some columns from a single table:</p>
			<pre class="source-code">/* type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;Record3&lt;Long, String, BigDecimal&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">    CUSTOMER.CUSTOMER_NUMBER, CUSTOMER.CUSTOMER_NAME,   </pre>
			<pre class="source-code">    CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">  .from(CUSTOMER)</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>Since we have three columns, jOOQ has picked up the record of degree 3, <strong class="source-inline">Record3</strong>, and automatically inferred the correct Java types, <strong class="source-inline">Long</strong>, <strong class="source-inline">String</strong>, and <strong class="source-inline">BigDecimal</strong>.</p>
			<p>Next, let's see an example that fetches five columns originating from two tables:</p>
			<pre class="source-code">/* type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;Record5&lt;Long, BigDecimal, String, String, String&gt;&gt;</pre>
			<pre class="source-code">  result = ctx.select(CUSTOMER.CUSTOMER_NUMBER,    </pre>
			<pre class="source-code">      CUSTOMER.CREDIT_LIMIT, CUSTOMERDETAIL.CITY,   </pre>
			<pre class="source-code">      CUSTOMERDETAIL.COUNTRY, CUSTOMERDETAIL.POSTAL_CODE)</pre>
			<pre class="source-code">    .from(CUSTOMER)</pre>
			<pre class="source-code">    .join(CUSTOMERDETAIL)</pre>
			<pre class="source-code">    .on(CUSTOMER.CUSTOMER_NUMBER</pre>
			<pre class="source-code">      .eq(CUSTOMERDETAIL.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">    .fetch();</pre>
			<p>This time, jOOQ picked up <strong class="source-inline">Record5&lt;Long, BigDecimal, String, String, String&gt;</strong>. I think you've got the idea!</p>
			<p>Accessing the values of records in a type-safe manner can be done via the attributes of the <a id="_idIndexMarker171"/>generated <a id="_idIndexMarker172"/>classes or you can use <strong class="source-inline">Record.into(Table&lt;Z&gt; table)</strong> to extract the strongly-typed <strong class="source-inline">TableRecords</strong> and rely on the corresponding getters. But, pay attention that only the fields listed/projected in the query have been populated with values from the result set.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Fetching Result&lt;Record&gt; via UDTs</h2>
			<p>UDTs are<a id="_idIndexMarker173"/> ORDBMS <a id="_idIndexMarker174"/>features formally supported by Oracle and PostgreSQL and are modeled by jOOQ as <strong class="source-inline">UDTRecord</strong>. Let's consider the following UDT defined in PostgreSQL:</p>
			<pre class="source-code">/* Define a type using CREATE TYPE */</pre>
			<pre class="source-code">CREATE TYPE "evaluation_criteria" AS ("communication_ability" </pre>
			<pre class="source-code">  INT, "ethics" INT, "performance" INT, "employee_input" INT);</pre>
			<p>Next, the <strong class="source-inline">MANAGER</strong> table schema uses this type as follows:</p>
			<pre class="source-code">CREATE TABLE "manager" (</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  "manager_evaluation" evaluation_criteria DEFAULT NULL</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">);</pre>
			<p>Running the jOOQ Code Generator produces an <strong class="source-inline">org.jooq.UDT</strong> implementation named <strong class="source-inline">EvaluationCriteria.java</strong> (in the <strong class="source-inline">jooq.generated.udt</strong> package). Besides the <strong class="source-inline">org.jooq.UDT</strong> implementation, an <strong class="source-inline">org.jooq.UDTRecord</strong> implementation is also generated under the name <strong class="source-inline">EvaluationCriteriaRecord.java</strong> (in the <strong class="source-inline">jooq.generated.udt.records</strong> package).</p>
			<p>Having <a id="_idIndexMarker175"/>these<a id="_idIndexMarker176"/> artifacts generated, we can write the following example that returns a type-safe <strong class="source-inline">Result&lt;Record&gt;</strong>:</p>
			<pre class="source-code">/* type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;Record2&lt;String, EvaluationCriteriaRecord&gt;&gt; result =</pre>
			<pre class="source-code">  ctx.select(MANAGER.MANAGER_NAME, MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">     .from(MANAGER)</pre>
			<pre class="source-code">     .fetch();</pre>
			<p>Accessing the values of records can be done as follows. Of course, the climax is represented by accessing the UDT record's values:</p>
			<pre class="source-code">/* type-safe values */</pre>
			<pre class="source-code">for(Record2 r : result) {</pre>
			<pre class="source-code">  String r1 = r.get(MANAGER.MANAGER_NAME);</pre>
			<pre class="source-code">  Integer r2 = r.get(MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">    .getCommunicationAbility();</pre>
			<pre class="source-code">  Integer r3 = r.get(MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">    .getEthics();</pre>
			<pre class="source-code">  Integer r4 = r.get(MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">    .getPerformance();</pre>
			<pre class="source-code">  Integer r5 = r.get(MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">    .getEmployeeInput();</pre>
			<pre class="source-code">}</pre>
			<p>Alternatively, relying <a id="_idIndexMarker177"/>on <strong class="source-inline">Record.into(Table&lt;Z&gt; table)</strong> can be<a id="_idIndexMarker178"/> done as follows:</p>
			<pre class="source-code">/* type-safe Result&lt;Record&gt; */</pre>
			<pre class="source-code">Result&lt;ManagerRecord&gt; result =</pre>
			<pre class="source-code">  ctx.select(MANAGER.MANAGER_NAME, MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">     .from(MANAGER)</pre>
			<pre class="source-code">     .fetch()</pre>
			<pre class="source-code">     .into(MANAGER); // or, into(ManagerRecord.class)</pre>
			<p>This time, accessing the values of records can be done via <strong class="source-inline">getManagerEvaluation()</strong>:</p>
			<pre class="source-code">/* type-safe values */</pre>
			<pre class="source-code">for(ManagerRecord r : result) {</pre>
			<pre class="source-code">  String r1 =r.getManagerName();</pre>
			<pre class="source-code">  Integer r2 =r.getManagerEvaluation()</pre>
			<pre class="source-code">    .getCommunicationAbility();</pre>
			<pre class="source-code">  Integer r3 = r.getManagerEvaluation().getEthics();</pre>
			<pre class="source-code">  Integer r4 = r.getManagerEvaluation().getPerformance();</pre>
			<pre class="source-code">  Integer r5 = r.getManagerEvaluation().getEmployeeInput();</pre>
			<pre class="source-code">}</pre>
			<p>Well, this was a brief overview of jOOQ records. I've intentionally skipped <strong class="source-inline">UpdatableRecord</strong> for now since this topic is covered later in <a href="B16833_09.xhtml#_idTextAnchor162"><em class="italic">Chapter 9</em></a>, <em class="italic">CRUD, Transactions, and Locking</em>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When this book was written, attempting to serialize a jOOQ record to JSON/XML via Spring Boot default Jackson features (for instance, by returning <strong class="source-inline">Record</strong> from a REST controller) will result in an exception! Setting <strong class="source-inline">FAIL_ON_EMPTY_BEANS=false</strong> will eliminate the exception but will lead to a weird and useless result. Alternatively, you can return POJOs or rely on jOOQ formatting capabilities – as you'll see later, jOOQ can format a record as JSON, XML, and HTML. And, let's not forget the alternative of using SQL/XML or SQL/JSON features and generating the JSON directly in the database (see <em class="italic">Chapter 8</em>, <em class="italic">Fetching and Mapping</em>). However, if you really want to serialize the jOOQ record, then you can rely on <strong class="source-inline">intoMap()</strong> and <strong class="source-inline">intoMaps()</strong>, as you can see in the bundled code. Meanwhile, you can monitor the progress on this topic here: <a href="https://github.com/jOOQ/jOOQ/issues/11889">https://github.com/jOOQ/jOOQ/issues/11889</a>.</p>
			<p>The <a id="_idIndexMarker179"/>examples <a id="_idIndexMarker180"/>covered in this section are available for Maven and Gradle in the code bundled with the book under the name <em class="italic">RecordResult</em>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Exploring jOOQ query types</h1>
			<p>jOOQ distinguishes <a id="_idIndexMarker181"/>between two <a id="_idIndexMarker182"/>main types of queries:</p>
			<ul>
				<li>DML (<strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">MERGE</strong>, among others) and DDL (<strong class="source-inline">CREATE</strong>, <strong class="source-inline">ALTER</strong>, <strong class="source-inline">DROP</strong>, <strong class="source-inline">RENAME</strong>, and similar) queries that produce a modification in the database</li>
				<li>DQL (<strong class="source-inline">SELECT</strong>) queries that produce results</li>
			</ul>
			<p>DML and DDL queries are represented in jOOQ by the <strong class="source-inline">org.jooq.Query</strong> interface, while DQL queries are represented by the <strong class="source-inline">org.jooq.ResultQuery</strong> interface. The <strong class="source-inline">ResultQuery</strong> interface extends (among others) the <strong class="source-inline">Query</strong> interface.</p>
			<p>For instance, the following snippet of code contains two jOOQ queries:</p>
			<pre class="source-code">Query query = ctx.query("DELETE FROM payment </pre>
			<pre class="source-code">  WHERE customer_number = 103");</pre>
			<pre class="source-code">Query query = ctx.deleteFrom(PAYMENT)</pre>
			<pre class="source-code">  .where(PAYMENT.CUSTOMER_NUMBER.eq(103L));  </pre>
			<p>These queries can<a id="_idIndexMarker183"/> be executed via jOOQ and they <a id="_idIndexMarker184"/>return the number of affected rows:</p>
			<pre class="source-code">int affectedRows = query.execute();</pre>
			<p>And, here are two result queries: first, a plain SQL query – here, jOOQ cannot infer the <strong class="source-inline">Record</strong> types:</p>
			<pre class="source-code">ResultQuery&lt;Record&gt; resultQuery = ctx.resultQuery(</pre>
			<pre class="source-code">  "SELECT job_title FROM employee WHERE office_code = '4'");</pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">Result&lt;Record&gt; fetched = resultQuery.fetch();</pre>
			<pre class="source-code">List&lt;String&gt; result = fetched.into(String.class);        </pre>
			<p>Second, a jOOQ <strong class="source-inline">ResultQuery</strong> expressed via jOOQ generated classes (notice that this time, jOOQ infers the number of <strong class="source-inline">ResultQuery</strong> parameters and types – since we fetch only <strong class="source-inline">JOB_TITLE</strong>, there is <strong class="source-inline">Record1&lt;String&gt;</strong>):</p>
			<pre class="source-code">ResultQuery&lt;Record1&lt;String&gt;&gt; resultQuery</pre>
			<pre class="source-code">  = ctx.select(EMPLOYEE.JOB_TITLE)</pre>
			<pre class="source-code">       .from(EMPLOYEE)</pre>
			<pre class="source-code">       .where(EMPLOYEE.OFFICE_CODE.eq("4"));        </pre>
			<pre class="source-code">Result&lt;Record1&lt;String&gt;&gt; fetched = resultQuery.fetch();</pre>
			<pre class="source-code">List&lt;String&gt; result = fetched.into(String.class);       </pre>
			<p>Since <strong class="source-inline">ResultQuery</strong> extends <strong class="source-inline">Iterable</strong>, you can just <em class="italic">foreach</em> your queries in PL/SQL style and do something with each record. For instance, the following snippet of code works like a charm:</p>
			<pre class="source-code">for (Record2&lt;String, String&gt; customer : ctx.select(</pre>
			<pre class="source-code">             CUSTOMER.CUSTOMER_NAME, CUSTOMER.PHONE)</pre>
			<pre class="source-code">       .from(CUSTOMER)) {</pre>
			<pre class="source-code">  System.out.println("Customer:\n" + customer);</pre>
			<pre class="source-code">}         </pre>
			<pre class="source-code">for (CustomerRecord customer : ctx.selectFrom(CUSTOMER)</pre>
			<pre class="source-code">       .where(CUSTOMER.SALES_REP_EMPLOYEE_NUMBER.eq(1504L))) {</pre>
			<pre class="source-code">  System.out.println("Customer:\n" + customer);</pre>
			<pre class="source-code">}</pre>
			<p>There is no need to explicitly call <strong class="source-inline">fetch()</strong>, but you can do it. The examples from this section are<a id="_idIndexMarker185"/> grouped in an application <a id="_idIndexMarker186"/>named <em class="italic">QueryAndResultQuery</em>. Next, let's talk about the jOOQ fluent API.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Understanding the jOOQ fluent API</h1>
			<p>Most of the time <a id="_idIndexMarker187"/>spent with jOOQ is about writing fluent code via the jOOQ fluent API. This approach is quite convenient for building fluent SQL expressions that avoid disrupting or chunking the code. Moreover, fluent APIs are easy to enrich with more operations.</p>
			<p>Relying on a brilliant implementation of the interface-driven design concept, jOOQ hides most implementations from client code and acts as a <em class="italic">good friend</em> that is ready to listen regarding the<a id="_idIndexMarker188"/> SQL that you need to run. Let's see several usages of the jOOQ fluent API.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Writing fluent queries</h2>
			<p>So far, we <a id="_idIndexMarker189"/>have written several SQL in the jOOQ DSL API fluent style. Let's have another one as follows:</p>
			<pre class="source-code">DSL.select(</pre>
			<pre class="source-code">      ORDERDETAIL.ORDER_LINE_NUMBER, </pre>
			<pre class="source-code">      sum(ORDERDETAIL.QUANTITY_ORDERED).as("itemsCount"),</pre>
			<pre class="source-code">      sum(ORDERDETAIL.PRICE_EACH</pre>
			<pre class="source-code">        .mul(ORDERDETAIL.QUANTITY_ORDERED)).as("total"))</pre>
			<pre class="source-code">   .from(ORDERDETAIL)   </pre>
			<pre class="source-code">   .where((val(20).lt(ORDERDETAIL.QUANTITY_ORDERED)))</pre>
			<pre class="source-code">   .groupBy(ORDERDETAIL.ORDER_LINE_NUMBER)</pre>
			<pre class="source-code">   .orderBy(ORDERDETAIL.ORDER_LINE_NUMBER)</pre>
			<pre class="source-code">   .getSQL();</pre>
			<p>The goal of dissecting to the bone the previous jOOQ query is far away from us, but let's try to have some insights about how this query is seen through jOOQ eyes. This will help you to quickly accumulate the information from the chapters that follow and will increase your confidence in jOOQ.</p>
			<p>Roughly, a JOOQ fluent query is composed of two basic building blocks: <strong class="bold">column expressions</strong> (or fields) and <strong class="bold">table expressions</strong>. These are manipulated via conditions, functions, and constraints to obtain a set of valid query steps that are logically chained and/or nested in the final jOOQ query. Of course, a jOOQ query may contain other parts <a id="_idIndexMarker190"/>as well, and all the parts that compose that query are<a id="_idIndexMarker191"/> referenced as <strong class="bold">query parts</strong> and have the <strong class="source-inline">org.jooq.QueryPart</strong> interface as a common base type. Let's briefly cover column expressions, table expressions, and query steps to better understand this paragraph.</p>
			<h3>Column expressions</h3>
			<p><strong class="bold">Column expressions</strong> or <strong class="bold">fields</strong> refer to<a id="_idIndexMarker192"/> one<a id="_idIndexMarker193"/> or more columns, and they are represented by the <strong class="source-inline">org.jooq.Field</strong> interface. There are many kinds of column expressions and all of them can be used in a variety of SQL statements/clauses to produce fluent queries. For example, in the <strong class="source-inline">SELECT</strong> clause, we have <strong class="source-inline">org.jooq.SelectField</strong> (which is a special <strong class="source-inline">org.jooq.Field</strong> interface for <strong class="source-inline">SELECT</strong>); in the <strong class="source-inline">WHERE</strong> clause, we have <strong class="source-inline">org.jooq.Field</strong>; in the <strong class="source-inline">ORDER BY</strong> clause, we have <strong class="source-inline">org.jooq.OrderField</strong>; in the <strong class="source-inline">GROUP BY</strong> clause, we have <strong class="source-inline">org.jooq.GroupField</strong>; and in conditions and functions, we typically have <strong class="source-inline">org.jooq.Field</strong>.</p>
			<p>Column expressions can be arbitrary built via the jOOQ fluent API to shape different query parts such as arithmetic expressions (for example, <strong class="source-inline">column_expression_1.mul(column_expression_2)</strong>), conditions/predicates (<strong class="source-inline">org.jooq.Condition</strong>) used in <strong class="source-inline">WHERE</strong> and <strong class="source-inline">HAVING</strong> (for example, here is an equality condition: <strong class="source-inline">WHERE(column_expression_1.eq(column_expression_2))</strong>), and so on.</p>
			<p>When column expressions refer to table columns, they are referenced as <strong class="bold">table columns</strong>. Table<a id="_idIndexMarker194"/> columns implement a more specific interface called <strong class="source-inline">org.jooq.TableField</strong>. These kinds of column expressions are produced internally by the jOOQ Code Generator and you can see them in each Java class specific to a table. The instances of <strong class="source-inline">TableField</strong> cannot be created directly.</p>
			<p>Let's identify the column expressions types from our query using the following figure, which highlights them:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B16833_Figure_3.2.jpg" alt="Figure 3.2 – Identify the column expressions of this query&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Identify the column expressions of this query</p>
			<p>First of all, we have some table columns that reference the <strong class="source-inline">ORDERDETAIL</strong> table:</p>
			<pre class="source-code">Field&lt;Integer&gt; tc1 = ORDERDETAIL.ORDER_LINE_NUMBER;  </pre>
			<pre class="source-code">Field&lt;Integer&gt; tc2 = ORDERDETAIL.QUANTITY_ORDERED; </pre>
			<pre class="source-code">Field&lt;BigDecimal&gt; tc3 = ORDERDETAIL.PRICE_EACH;    </pre>
			<p>We have some extracted as <strong class="source-inline">TableField</strong>:</p>
			<pre class="source-code">TableField&lt;OrderdetailRecord,Integer&gt;</pre>
			<pre class="source-code">   tfc1 = ORDERDETAIL.ORDER_LINE_NUMBER;</pre>
			<pre class="source-code">TableField&lt;OrderdetailRecord,Integer&gt;</pre>
			<pre class="source-code">   tfc2 = ORDERDETAIL.QUANTITY_ORDERED;</pre>
			<pre class="source-code">TableField&lt;OrderdetailRecord,BigDecimal&gt;</pre>
			<pre class="source-code">   tfc3 = ORDERDETAIL.PRICE_EACH;</pre>
			<p>We also have an unnamed column expression:</p>
			<pre class="source-code">Field&lt;Integer&gt; uc1 = val(20);                  </pre>
			<p>Just as <a id="_idIndexMarker195"/>a <a id="_idIndexMarker196"/>quick note, here, the <strong class="source-inline">DSL.val()</strong> method simply creates <strong class="source-inline">Field&lt;Integer&gt;</strong> (gets a bind value as <strong class="source-inline">Param&lt;Integer&gt;</strong>, where <strong class="source-inline">Param</strong> extends <strong class="source-inline">Field</strong>) representing a constant value. We will discuss jOOQ parameters a little bit later in this chapter.</p>
			<p>Let's rewrite the query so far using the extracted columns expression:</p>
			<pre class="source-code">DSL.select(tc1, sum(tc2).as("itemsCount"),</pre>
			<pre class="source-code">           sum(tc3.mul(tc2)).as("total"))</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .where(uc1.lt(tc2))</pre>
			<pre class="source-code">   .groupBy(tc1)</pre>
			<pre class="source-code">   .orderBy(tc1)</pre>
			<pre class="source-code">   .getSQL();</pre>
			<p>Next, let's extract the usages of the <strong class="source-inline">sum()</strong> aggregate function. The first usage of <strong class="source-inline">sum()</strong> relies on a table column expression (<strong class="source-inline">tc2</strong>) to produce a function expression:</p>
			<pre class="source-code">Field&lt;BigDecimal&gt; f1 = sum(tc2); // function expression</pre>
			<p>The second usage of <strong class="source-inline">sum()</strong> wraps an arithmetic expression that uses two table column expressions (<strong class="source-inline">tc3</strong> and <strong class="source-inline">tc2</strong>), therefore, it can be extracted as follows:</p>
			<pre class="source-code">Field&lt;BigDecimal&gt; m1 = tc3.mul(tc2); // arithmetic expression</pre>
			<pre class="source-code">Field&lt;BigDecimal&gt; f2 = sum(m1);      // function expression</pre>
			<p>One step further, and we notice that our query uses aliases for <strong class="source-inline">f1</strong> and <strong class="source-inline">f2</strong>, therefore, these <a id="_idIndexMarker197"/>can <a id="_idIndexMarker198"/>be extracted as aliased expressions:</p>
			<pre class="source-code">Field&lt;BigDecimal&gt; a1 = f1.as("itemsCount"); // alias expression</pre>
			<pre class="source-code">Field&lt;BigDecimal&gt; a2 = f2.as("total");      // alias expression</pre>
			<p>Let's rewrite the query again:</p>
			<pre class="source-code">DSL.select(tc1, a1, a2)</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .where(uc1.lt(tc2))</pre>
			<pre class="source-code">   .groupBy(tc1)</pre>
			<pre class="source-code">   .orderBy(tc1)</pre>
			<pre class="source-code">   .getSQL();</pre>
			<p>Done! At this point, we have identified all column expressions of our query. How about table expressions?</p>
			<h3>Table expressions</h3>
			<p>Next<a id="_idIndexMarker199"/> to<a id="_idIndexMarker200"/> fields, tables also represent the basic building blocks of any query. jOOQ represents a table via <strong class="source-inline">org.jooq.Table</strong>. In our query, there is a single table reference:</p>
			<pre class="source-code">.from(ORDERDETAIL) // table expression ORDERDETAIL</pre>
			<p>It can be extracted as follows:</p>
			<pre class="source-code">// non type-safe table expression</pre>
			<pre class="source-code">Table&lt;?&gt; t1 = ORDERDETAIL; </pre>
			<pre class="source-code">// type-safe table expression  </pre>
			<pre class="source-code">Table&lt;OrderdetailRecord&gt; t1 = ORDERDETAIL;</pre>
			<p>This time, the query becomes the following:</p>
			<pre class="source-code">DSL.select(tc1, a1, a2)</pre>
			<pre class="source-code">   .from(t1)</pre>
			<pre class="source-code">   .where(uc1.lt(tc2))</pre>
			<pre class="source-code">   .groupBy(tc1)</pre>
			<pre class="source-code">   .orderBy(tc1)</pre>
			<pre class="source-code">   .getSQL();</pre>
			<p>jOOQ supports a wide range of tables not only database tables, including plain SQL tables, aliased tables, derived<a id="_idIndexMarker201"/> tables, <strong class="bold">Common Table Expressions</strong> (<strong class="bold">CTEs</strong>), temporary tables, and table-valued functions. But, we will discuss these in the upcoming chapters.</p>
			<p>So far, notice that we haven't touched <strong class="source-inline">uc1.lt(tc2)</strong>. As you can probably intuit, this is a condition that uses two column expressions and is mapped by jOOQ as <strong class="source-inline">org.jooq.Condition</strong>. It can be extracted as follows:</p>
			<pre class="source-code">Condition c1 = uc1.lt(tc2); // condition</pre>
			<p>After extracting all these parts, we obtain the following query:</p>
			<pre class="source-code">DSL.select(tc1, a1, a2)</pre>
			<pre class="source-code">   .from(t1)</pre>
			<pre class="source-code">   .where(c1)</pre>
			<pre class="source-code">   .groupBy(tc1)</pre>
			<pre class="source-code">   .orderBy(tc1)</pre>
			<pre class="source-code">   .getSQL();</pre>
			<p>Actually, you could even do the following, but there is no more type-safety:</p>
			<pre class="source-code">Collection&lt;? extends SelectField&gt; sf = List.of(tc1, a1, a2);</pre>
			<pre class="source-code">DSL.select(sf) …</pre>
			<p>Obviously, these query parts can be used to form other arbitrary queries as well. After all, in jOOQ, we <a id="_idIndexMarker202"/>can<a id="_idIndexMarker203"/> write queries that are 100% dynamic.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In jOOQ, even when they look like static queries (due to jOOQ's API design), every SQL is dynamic, therefore, it can be broken up into query parts that can be fluently glued back in any valid jOOQ query. We'll talk about more examples later when we'll tackle dynamic filters.</p>
			<p>Finally, let's quickly get an overview of the query steps topic.</p>
			<h3>Query steps (SelectFooStep, InsertFooStep, UpdateFooStep, and DeleteFooStep)</h3>
			<p>Continuing <a id="_idIndexMarker204"/>to<a id="_idIndexMarker205"/> identify <a id="_idIndexMarker206"/>the remaining<a id="_idIndexMarker207"/> query<a id="_idIndexMarker208"/> parts, we<a id="_idIndexMarker209"/> have <strong class="source-inline">select</strong>, <strong class="source-inline">from</strong>, <strong class="source-inline">where</strong>, <strong class="source-inline">groupBy</strong>, and <strong class="source-inline">orderBy</strong>. These<a id="_idIndexMarker210"/> parts <a id="_idIndexMarker211"/>are logically chained to form our query and are represented by jOOQ as query steps. There are many types of query steps, but the ones used by our query can be decomposed as follows:</p>
			<pre class="source-code">SelectSelectStep s1 = DSL.select(tc1, a1, a2);</pre>
			<pre class="source-code">SelectJoinStep s2 = s1.from(t1);</pre>
			<pre class="source-code">SelectConditionStep s3 = s2.where(c1);</pre>
			<pre class="source-code">SelectHavingStep s4 = s3.groupBy(tc1);</pre>
			<pre class="source-code">SelectSeekStep1 s5 = s4.orderBy(tc1);</pre>
			<pre class="source-code">              </pre>
			<pre class="source-code">return s5.getSQL();        </pre>
			<p>Or, the<a id="_idIndexMarker212"/> ones <a id="_idIndexMarker213"/>used <a id="_idIndexMarker214"/>as <a id="_idIndexMarker215"/>type-safe <a id="_idIndexMarker216"/>steps<a id="_idIndexMarker217"/> are<a id="_idIndexMarker218"/> as<a id="_idIndexMarker219"/> follows (remember, you can use Java 9 <strong class="source-inline">var</strong> instead of <strong class="source-inline">SelectSelectStep&lt;Record3&lt;Short, BigDecimal, BigDecimal&gt;&gt;</strong>):</p>
			<pre class="source-code">SelectSelectStep&lt;Record3&lt;Integer, BigDecimal, BigDecimal&gt;&gt;</pre>
			<pre class="source-code">  s1ts = DSL.select(tc1, a1, a2);</pre>
			<pre class="source-code">SelectJoinStep&lt;Record3&lt;Integer, BigDecimal, BigDecimal&gt;&gt;</pre>
			<pre class="source-code">  s2ts = s1ts.from(t1);</pre>
			<pre class="source-code">SelectConditionStep&lt;Record3&lt;Integer, BigDecimal, BigDecimal&gt;&gt;</pre>
			<pre class="source-code">  s3ts = s2ts.where(c1);</pre>
			<pre class="source-code">SelectHavingStep&lt;Record3&lt;Integer, BigDecimal, BigDecimal&gt;&gt;</pre>
			<pre class="source-code">  s4ts = s3ts.groupBy(tc1);</pre>
			<pre class="source-code">SelectSeekStep1&lt;Record3&lt;Integer, BigDecimal, BigDecimal&gt;,   </pre>
			<pre class="source-code">  Integer&gt; s5ts = s4ts.orderBy(tc1);</pre>
			<pre class="source-code">return s5ts.getSQL();</pre>
			<p>Check out the last line of this snippet of code. We return the generated valid SQL as a plain string without executing this query. Execution can happen in the presence of a connection to the database, therefore, we need <strong class="source-inline">DSLContext</strong> configured to accomplish this task. If we have injected <strong class="source-inline">DSLContext</strong>, then all we need to do is to use it as follows:</p>
			<pre class="source-code">return ctx.fetch(s5); // or, s5ts</pre>
			<p>Or, we can use it like this:</p>
			<pre class="source-code">SelectSelectStep s1 = <strong class="bold">ctx</strong>.select(tc1, a1, a2);</pre>
			<pre class="source-code">// or</pre>
			<pre class="source-code">SelectSelectStep&lt;Record3&lt;Integer, BigDecimal, BigDecimal&gt;&gt;</pre>
			<pre class="source-code">   s1ts = <strong class="bold">ctx</strong>.select(tc1, a1, a2);</pre>
			<p>This <strong class="source-inline">SelectSelectStep</strong> contains an internal reference to the <strong class="source-inline">DSLContext</strong> configuration, therefore, we can replace the last line as follows:</p>
			<pre class="source-code">return s5.fetch(); // or, s5ts</pre>
			<p>The complete code is available for Maven and Gradle in the code bundled with this book under the name <strong class="source-inline">FluentQueryParts</strong>. While in this section, you saw how to decompose the query steps, keep in mind that it's almost always a better choice to rely on dynamic SQL queries than referencing these step types. So, as a rule of thumb, <em class="italic">always</em> try to avoid assigning or referencing the query steps directly.</p>
			<p>Obviously, decomposing <a id="_idIndexMarker220"/>a query into parts is<a id="_idIndexMarker221"/> not a day-to-day task. Most of the<a id="_idIndexMarker222"/> time, you'll<a id="_idIndexMarker223"/> just <a id="_idIndexMarker224"/>use<a id="_idIndexMarker225"/> the<a id="_idIndexMarker226"/> fluent API, but there are cases <a id="_idIndexMarker227"/>when it is nice to know how to do it (for instance, it can be helpful for writing dynamic filters, referencing aliases in different places of a query, re-using a query part in multiple places, and writing correlated subqueries).</p>
			<p>Another use of the jOOQ fluent API is focused on the <strong class="source-inline">DSLContext</strong> creation.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Creating DSLContext</h2>
			<p>Most <a id="_idIndexMarker228"/>probably, in <a id="_idIndexMarker229"/>Spring Boot applications, we'll prefer to inject the default <strong class="source-inline">DSLContext</strong> as you saw in <a href="B16833_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Starting jOOQ and Spring Boot</em>, and <a href="B16833_02.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, <em class="italic">Customizing the jOOQ Level of Involvement</em>. But, in certain scenarios (for instance, wrapping and running a specific query with a custom setting, rendering an SQL in a different dialect than the default one, or needing to trigger an occasional query against a database that is not configured in Spring Boot), we'll prefer to use <strong class="source-inline">DSLContext</strong> as a local variable. This can be done in fluent style via the <strong class="source-inline">DSL.using()</strong> methods <a id="_idIndexMarker230"/>as in the following <a id="_idIndexMarker231"/>non-exhaustive list of examples.</p>
			<h3>Creating DSLContext from a data source and a dialect</h3>
			<p>Having <strong class="source-inline">DataSource</strong> (for <a id="_idIndexMarker232"/>instance, injected in your repository), we can create <strong class="source-inline">DSLContext</strong> and execute a query in fluent style as here:</p>
			<pre class="source-code">private final DataSource ds; // injected DataSource</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">List&lt;Office&gt; result = DSL.using(ds, SQLDialect.MYSQL)</pre>
			<pre class="source-code">  .selectFrom(OFFICE)</pre>
			<pre class="source-code">  .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code">  .fetchInto(Office.class);</pre>
			<p>This example relies on the <strong class="source-inline">DSL.using(DataSource datasource, SQLDialect dialect)</strong> method.</p>
			<h3>Creating DSLContext from a data source, a dialect, and some settings</h3>
			<p>Enabling/disabling <a id="_idIndexMarker233"/>some settings to the previous example requires us to instantiate <strong class="source-inline">org.jooq.conf.Settings</strong>. This class exposes a comprehensive fluent API (via the <strong class="source-inline">withFoo()</strong> methods) that influences the way jOOQ renders SQL code. For instance, the following snippet of code inhibits the rendering of the schema name (just look at this nice piece of fluent code):</p>
			<pre class="source-code">private final DataSource ds; // injected DataSource</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">List&lt;Office&gt; result = DSL.using(ds, SQLDialect.MYSQL, </pre>
			<pre class="source-code">      new Settings().withRenderSchema(Boolean.FALSE))</pre>
			<pre class="source-code">  .selectFrom(OFFICE)</pre>
			<pre class="source-code">  .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code">  .fetchInto(Office.class);</pre>
			<p>This<a id="_idIndexMarker234"/> example relies on the <strong class="source-inline">using(DataSource datasource, SQLDialect dialect, Settings settings)</strong> method.</p>
			<h3>Alter a setting of the injected DSLContext</h3>
			<p>In the previous<a id="_idIndexMarker235"/> example, we created <strong class="source-inline">DSLContext</strong> that doesn't render the schema name. This setting is applied to all usages of the created <strong class="source-inline">DSLContext</strong>, or in other words, to all queries triggered under the configuration of this <strong class="source-inline">DSLContext</strong>. How can we do the same thing for the default <strong class="source-inline">DSLContext</strong> provided by Spring Boot after it was injected into a repository? The following code provides the answer:</p>
			<pre class="source-code">private final DSLContext ctx; // injected DSLContext</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">List&lt;Office&gt; result = ctx.configuration()</pre>
			<pre class="source-code"> .<strong class="bold">set</strong>(new Settings().withRenderSchema(Boolean.FALSE)).dsl()</pre>
			<pre class="source-code"> .selectFrom(OFFICE)</pre>
			<pre class="source-code"> .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code"> .fetchInto(Office.class);</pre>
			<p>Mainly, we access the current configuration of the injected <strong class="source-inline">DSLContext</strong> via <strong class="source-inline">configuration()</strong>, we set our setting, and call the <strong class="source-inline">dsl()</strong> method to get access back to <strong class="source-inline">DSLContext</strong>. Notice that from this point forward, all usages of <strong class="source-inline">ctx</strong> will not render the schema name unless you don't enable it again. If you prefer to use some specific settings for a certain query, then create <strong class="source-inline">DSLContext</strong> derived from the injected one via <strong class="source-inline">derive()</strong> in place of <strong class="source-inline">set()</strong>. This way, the original <strong class="source-inline">DSLContext</strong> remains unaltered and you can operate on the derived one:</p>
			<pre class="source-code">private final DSLContext ctx; // injected DSLContext</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">List&lt;Office&gt; result = ctx.configuration()</pre>
			<pre class="source-code"> .<strong class="bold">derive</strong>(new Settings().withRenderSchema(Boolean.FALSE)).dsl()</pre>
			<pre class="source-code"> .selectFrom(OFFICE)</pre>
			<pre class="source-code"> .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code"> .fetchInto(Office.class);</pre>
			<p>So, in the previous <a id="_idIndexMarker236"/>example, <strong class="source-inline">ctx</strong> remains unchanged and jOOQ uses a derived <strong class="source-inline">DSLContext</strong>, which will not render the schema name.</p>
			<h3>Creating DSLContext from a connection</h3>
			<p>Creating <strong class="source-inline">DSLContext</strong> from <a id="_idIndexMarker237"/>a connection and executing the query in fluent style can be done as follows:</p>
			<pre class="source-code">try ( Connection conn</pre>
			<pre class="source-code">  = DriverManager.getConnection(</pre>
			<pre class="source-code">   "jdbc:mysql://localhost:3306/classicmodels",</pre>
			<pre class="source-code">   "root", "root")) {</pre>
			<pre class="source-code">    List&lt;Office&gt; result = DSL.using(conn)</pre>
			<pre class="source-code">      .selectFrom(OFFICE)</pre>
			<pre class="source-code">      .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code">      .fetchInto(Office.class);</pre>
			<pre class="source-code">    return result;</pre>
			<pre class="source-code">} catch (SQLException ex) { // handle exception }</pre>
			<p>In such cases, we have to close the connection manually; therefore, we have used the <strong class="source-inline">try-with-resources</strong> technique. This example relies on the <strong class="source-inline">DSL.using(Connection c)</strong> method. If<a id="_idIndexMarker238"/> you want to specify the SQL dialect as well, then try out <strong class="source-inline">DSL.using(Connection c, SQLDialect d)</strong>.</p>
			<h3>Creating DSLContext from a URL, user, and password</h3>
			<p>For <a id="_idIndexMarker239"/>standalone-based <a id="_idIndexMarker240"/>scripts, where<a id="_idIndexMarker241"/> handling resources is not important since the connection lives as long as the script itself, we can rely on <strong class="source-inline">DSL.using(String url)</strong>, <strong class="source-inline">DSL.using(String url, Properties properties)</strong>, and <strong class="source-inline">DSL.using(String url, String user, String password)</strong>.</p>
			<p>If you prefer to use the <strong class="source-inline">DSL.using(String url, String user, String password)</strong> method (or any of the other two) prior to jOOQ 3.14, then you have to explicitly close the connection as well. This can be done by explicitly calling <strong class="source-inline">DSLContext.close()</strong> or by using <strong class="source-inline">try-with-resources</strong>. Starting with jOOQ 3.14, these overloads of <strong class="source-inline">DSL.using()</strong> will produce the new <strong class="source-inline">CloseableDSLContext</strong> type that allows us to write this:</p>
			<pre class="source-code">try (CloseableDSLContext cdctx = DSL.using(</pre>
			<pre class="source-code">    "jdbc:mysql://localhost:3306/classicmodels", </pre>
			<pre class="source-code">    "root", "root")) {</pre>
			<pre class="source-code">   List&lt;Office&gt; result = cdctx.selectFrom(OFFICE)</pre>
			<pre class="source-code">     .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code">     .fetchInto(Office.class);</pre>
			<pre class="source-code">   return result;</pre>
			<pre class="source-code">}</pre>
			<p>Next, let's see how to use <strong class="source-inline">DSLContext</strong> without a database connection.</p>
			<h3>Rendering SQL in a certain dialect</h3>
			<p>Rendering<a id="_idIndexMarker242"/> SQL <a id="_idIndexMarker243"/>in a certain dialect (here, MySQL) can be done via this fluent code:</p>
			<pre class="source-code">String sql = DSL.using(SQLDialect.MYSQL)</pre>
			<pre class="source-code">                .selectFrom(OFFICE)</pre>
			<pre class="source-code">                .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code">                .getSQL();</pre>
			<p>Since there is no connection or data source, there is no interaction with the database. The returned string represents the generated SQL specific to the provided dialect. This example relies on the <strong class="source-inline">DSL.using(SQLDialect dialect)</strong> method.</p>
			<p>You can find all these examples in the code bundled with this book under the name <em class="italic">CreateDSLContext</em>.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Using Lambdas and streams</h2>
			<p>The jOOQ fluent API and Java 8 Lambdas and streams make a perfect team. Let's look at several examples that demonstrate this.</p>
			<h3>Using Lambdas</h3>
			<p>For instance, jOOQ <a id="_idIndexMarker244"/>comes with a functional interface <a id="_idIndexMarker245"/>named <strong class="source-inline">RecordMapper</strong> used for mapping a jOOQ record to a POJO. Let's assume that we have the following POJOs. First, let's assume we have <strong class="source-inline">EmployeeName</strong>:</p>
			<pre class="source-code">public class EmployeeName implements Serializable {</pre>
			<pre class="source-code">  private String firstName;</pre>
			<pre class="source-code">  private String lastName;</pre>
			<pre class="source-code">  // constructors, getters, setters,... omitted for brevity</pre>
			<pre class="source-code">}</pre>
			<p>Next, let's assume we have <strong class="source-inline">EmployeeData</strong>:</p>
			<pre class="source-code">public class EmployeeData implements Serializable {   </pre>
			<pre class="source-code">  private Long employeeNumber;    </pre>
			<pre class="source-code">  private int salary;</pre>
			<pre class="source-code">  private EmployeeName employeeName;</pre>
			<pre class="source-code">  // constructors, getters, setters,... omitted for brevity</pre>
			<pre class="source-code">}</pre>
			<p>Next, let's <a id="_idIndexMarker246"/>assume<a id="_idIndexMarker247"/> that we have the following plain SQL:</p>
			<pre class="source-code">SELECT employee_number, salary, first_name, last_name</pre>
			<pre class="source-code">FROM employee</pre>
			<p>Executing and mapping this plain SQL is achievable via the <strong class="source-inline">fetch(String sql)</strong> flavor and <strong class="source-inline">map(RecordMapper&lt;? super R,E&gt; rm)</strong> as in the following:</p>
			<pre class="source-code">List&lt;EmployeeData&gt; result</pre>
			<pre class="source-code">  = ctx.fetch("SELECT employee_number, first_name, </pre>
			<pre class="source-code">               last_name, salary FROM employee")</pre>
			<pre class="source-code">    .map(</pre>
			<pre class="source-code">      rs -&gt; new EmployeeData(</pre>
			<pre class="source-code">        rs.getValue("employee_number", Long.class),</pre>
			<pre class="source-code">        rs.getValue("salary", Integer.class),</pre>
			<pre class="source-code">        new EmployeeName(</pre>
			<pre class="source-code">          rs.getValue("first_name", String.class),</pre>
			<pre class="source-code">          rs.getValue("last_name", String.class))</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">    );</pre>
			<p>The same thing is applicable <a id="_idIndexMarker248"/>if the plain SQL is expressed via the Java-based schema:</p>
			<pre class="source-code">List&lt;EmployeeData&gt; result</pre>
			<pre class="source-code">  = ctx.select(EMPLOYEE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">          EMPLOYEE.FIRST_NAME,EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">          EMPLOYEE.SALARY)</pre>
			<pre class="source-code">    .from(EMPLOYEE)</pre>
			<pre class="source-code">    .fetch()</pre>
			<pre class="source-code">    .map(</pre>
			<pre class="source-code">      rs -&gt; new EmployeeData(</pre>
			<pre class="source-code">        rs.getValue(EMPLOYEE.EMPLOYEE_NUMBER),     </pre>
			<pre class="source-code">        rs.getValue(EMPLOYEE.SALARY),</pre>
			<pre class="source-code">        new EmployeeName(rs.getValue(EMPLOYEE.FIRST_NAME),</pre>
			<pre class="source-code">                         rs.getValue(EMPLOYEE.LAST_NAME))</pre>
			<pre class="source-code">      )</pre>
			<pre class="source-code">);</pre>
			<p>It is also <a id="_idIndexMarker249"/>applicable<a id="_idIndexMarker250"/> if it is more concisely expressed via <strong class="source-inline">fetch(RecordMapper&lt;? super R,E&gt; rm)</strong>:</p>
			<pre class="source-code">List&lt;EmployeeData&gt; result</pre>
			<pre class="source-code">  = ctx.select(EMPLOYEE.EMPLOYEE_NUMBER, EMPLOYEE.FIRST_NAME,</pre>
			<pre class="source-code">         EMPLOYEE.LAST_NAME, EMPLOYEE.SALARY)</pre>
			<pre class="source-code">       .from(EMPLOYEE)</pre>
			<pre class="source-code">  .fetch(</pre>
			<pre class="source-code">     rs -&gt; new EmployeeData(</pre>
			<pre class="source-code">       rs.getValue(EMPLOYEE.EMPLOYEE_NUMBER),             </pre>
			<pre class="source-code">       rs.getValue(EMPLOYEE.SALARY),</pre>
			<pre class="source-code">       new EmployeeName(rs.getValue(EMPLOYEE.FIRST_NAME),</pre>
			<pre class="source-code">                        rs.getValue(EMPLOYEE.LAST_NAME))</pre>
			<pre class="source-code">     )</pre>
			<pre class="source-code">  );</pre>
			<p>If you think that these mappings are too simple for using a custom <strong class="source-inline">RecordMapper</strong>, then you are right. You'll see more proper cases for custom record mappers later on when we'll detail mappings. For this case, both of them can be solved via the built-in <strong class="source-inline">into()</strong> and <strong class="source-inline">fetchInto()</strong> methods by simply enriching the SQLs with hints via aliases. First, we can enrich the plain SQL (for MySQL, we use backticks):</p>
			<pre class="source-code">List&lt;EmployeeData&gt; result = ctx.fetch("""</pre>
			<pre class="source-code">  SELECT employee_number, salary, </pre>
			<pre class="source-code">         first_name AS `employeeName.firstName`,</pre>
			<pre class="source-code">         last_name AS `employeeName.lastName` </pre>
			<pre class="source-code">  FROM employee""").into(EmployeeData.class);</pre>
			<p>And then, we<a id="_idIndexMarker251"/> can<a id="_idIndexMarker252"/> enrich the jOOQ SQL:</p>
			<pre class="source-code">List&lt;EmployeeData&gt; result </pre>
			<pre class="source-code">  = ctx.select(EMPLOYEE.EMPLOYEE_NUMBER, EMPLOYEE.SALARY,</pre>
			<pre class="source-code">            EMPLOYEE.FIRST_NAME.as("employeeName.firstName"), </pre>
			<pre class="source-code">            EMPLOYEE.LAST_NAME.as("employeeName.lastName"))</pre>
			<pre class="source-code">       .from(EMPLOYEE)</pre>
			<pre class="source-code">       .fetchInto(EmployeeData.class);</pre>
			<p>Let's see a few more examples of using Lambdas.</p>
			<p>The following snippet of code prints all sales. Since <strong class="source-inline">selectFrom()</strong> returns the record type supplied with the argument table, this code prints each <strong class="source-inline">SaleRecord</strong> (notice that calling <strong class="source-inline">fetch()</strong> is optional):</p>
			<pre class="source-code">ctx.selectFrom(SALE)</pre>
			<pre class="source-code">   .orderBy(SALE.SALE_)</pre>
			<pre class="source-code">   // .fetch() - optional</pre>
			<pre class="source-code">   .forEach(System.out::println);</pre>
			<p>Mapping the result set (<strong class="source-inline">SaleRecord</strong>) to <strong class="source-inline">List&lt;Double&gt;</strong> containing only the <strong class="source-inline">sale</strong> column can be done as<a id="_idIndexMarker253"/> follows via <strong class="source-inline">fetch().map(RecordMapper&lt;? super R,E&gt; rm)</strong>:</p>
			<pre class="source-code">ctx.selectFrom(SALE)</pre>
			<pre class="source-code">   .orderBy(SALE.SALE_)</pre>
			<pre class="source-code">   .fetch()</pre>
			<pre class="source-code">   .map(SaleRecord::getSale)</pre>
			<pre class="source-code">   .forEach(System.out::println);</pre>
			<p>Or, it<a id="_idIndexMarker254"/> can be done via <strong class="source-inline">fetch(RecordMapper&lt;? super R,E&gt; rm)</strong> as follows:</p>
			<pre class="source-code">ctx.selectFrom(SALE)</pre>
			<pre class="source-code">   .orderBy(SALE.SALE_)</pre>
			<pre class="source-code">   .fetch(SaleRecord::getSale)</pre>
			<pre class="source-code">   .forEach(System.out::println);</pre>
			<p>It can also be done via a Lambda expression as follows:</p>
			<pre class="source-code">ctx.selectFrom(SALE)</pre>
			<pre class="source-code">   .orderBy(SALE.SALE_)</pre>
			<pre class="source-code">   .fetch(s -&gt; s.getSale())</pre>
			<pre class="source-code">   .forEach(System.out::println);</pre>
			<p>Or, it can even be done via an anonymous record mapper as follows:</p>
			<pre class="source-code">return ctx.selectFrom(SALE)</pre>
			<pre class="source-code">          .orderBy(SALE.SALE_)</pre>
			<pre class="source-code">          .fetch(new RecordMapper&lt;SaleRecord, Double&gt;() {</pre>
			<pre class="source-code">             @Override</pre>
			<pre class="source-code">             public Double map(SaleRecord sr) {</pre>
			<pre class="source-code">                return sr.getSale();</pre>
			<pre class="source-code">             }</pre>
			<pre class="source-code">          });</pre>
			<p>Next, let's see how the <a id="_idIndexMarker255"/>jOOQ fluent API can be used with the Java Stream fluent API.</p>
			<h3>Using the Stream API</h3>
			<p>Using the <a id="_idIndexMarker256"/>jOOQ<a id="_idIndexMarker257"/> fluent API and the Stream fluent API as an apparently single fluent API is straightforward. Let's assume that we have this POJO:</p>
			<pre class="source-code">public class SaleStats implements Serializable {</pre>
			<pre class="source-code">  private double totalSale;</pre>
			<pre class="source-code">  private List&lt;Double&gt; sales;</pre>
			<pre class="source-code">  // constructor, getters, setters, ... omitted for brevity</pre>
			<pre class="source-code">}</pre>
			<p>A plain SQL can obtain a <strong class="source-inline">SaleStats</strong> instance as follows:</p>
			<pre class="source-code">SaleStats result = ctx.fetch(</pre>
			<pre class="source-code">    "SELECT sale FROM sale") // jOOQ fluent API ends here   </pre>
			<pre class="source-code"><strong class="bold">  .stream() // Stream fluent API starts here                   </strong></pre>
			<pre class="source-code">  .collect(Collectors.teeing(</pre>
			<pre class="source-code">     summingDouble(rs -&gt; rs.getValue("sale", Double.class)),</pre>
			<pre class="source-code">     mapping(rs -&gt; rs.getValue("sale", Double.class), </pre>
			<pre class="source-code">     toList()), SaleStats::new));</pre>
			<p>But, if we use the Java-based schema, then this code can be re-written as follows:</p>
			<pre class="source-code">SaleStats result = ctx.select(SALE.SALE_)</pre>
			<pre class="source-code">  .from(SALE)</pre>
			<pre class="source-code">  .fetch()  // jOOQ fluent API ends here                </pre>
			<pre class="source-code">  <strong class="bold">.stream() // Stream fluent API starts here                </strong></pre>
			<pre class="source-code">  .collect(Collectors.teeing(</pre>
			<pre class="source-code">     summingDouble(rs -&gt; rs.getValue(SALE.SALE_)),</pre>
			<pre class="source-code">     mapping(rs -&gt; rs.getValue(SALE.SALE_), toList()),</pre>
			<pre class="source-code">     SaleStats::new));</pre>
			<p>It looks like the jOOQ fluent<a id="_idIndexMarker258"/> API and the Stream fluent API work together like a charm! All we have to do is call the <strong class="source-inline">stream()</strong> method after <strong class="source-inline">fetch()</strong>. While <strong class="source-inline">fetch()</strong> fetches the entire result set into memory, <strong class="source-inline">stream()</strong> opens a stream on this result set. Fetching the entire result set into memory via <strong class="source-inline">fetch()</strong>allows the JDBC resources (for instance, the connection) to be closed before streaming the result set.</p>
			<p>Nevertheless, besides <strong class="source-inline">stream()</strong>, jOOQ also exposes a method named <strong class="source-inline">fetchStream()</strong>, which is tackled later in the chapter, dedicated to lazy loading next to other specific <a id="_idIndexMarker259"/>topics. As a quick hint, keep in mind <a id="_idIndexMarker260"/>that <strong class="source-inline">fetch().stream()</strong> and <strong class="source-inline">fetchStream()</strong> are not the same thing.</p>
			<p>The examples from this section are grouped in the <em class="italic">FunctionalJooq</em> application.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Fluent programmatic configuration</h2>
			<p>In the previous <a id="_idIndexMarker261"/>chapter, you already had a flavor of constructing the Code Generator configuration via the programmatic fluent API. The following snippet of code is just another example of the jOOQ <strong class="source-inline">Settings</strong> fluent API:</p>
			<pre class="source-code">List&lt;Office&gt; result = ctx.configuration()</pre>
			<pre class="source-code">  .set(<strong class="bold">new Settings().withRenderSchema(Boolean.FALSE)</strong></pre>
			<pre class="source-code"><strong class="bold">                     .withMaxRows(5)</strong></pre>
			<pre class="source-code"><strong class="bold">                     .withInListPadding(Boolean.TRUE)</strong>).dsl()</pre>
			<pre class="source-code">  .selectFrom(...)</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  .fetchInto(Office.class);</pre>
			<p>These are not the only cases when the jOOQ fluent API rocks. For instance, check the jOOQ  JavaFX application for creating a bar chart from a jOOQ <strong class="source-inline">result</strong>. This is available in the jOOQ <a id="_idIndexMarker262"/>manual.</p>
			<p>Next, let's see how jOOQ emphasizes that our fluent code should respect the SQL syntax correctness.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Highlighting that jOOQ emphasizes SQL syntax correctness</h1>
			<p>One of the <a id="_idIndexMarker263"/>coolest features of jOOQ consists of the fact that jOOQ doesn't allow us to write bad SQL syntax. If you aren't an SQL expert or simply have issues with SQL-specific syntax, then all you have to do is to let jOOQ guide you step by step.</p>
			<p>Having a fluent API for chaining methods to obtain a SQL is cool, but having a fluent API that emphasizes SQL syntax correctness is the coolest. jOOQ knows exactly how the query parts fit the puzzle and will help you via your IDE.</p>
			<p>For instance, let's assume that we <em class="italic">accidentally</em> wrote the following bad SQLs. Let's start with an SQL that misses the <strong class="source-inline">ON</strong> clause:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.JOB_TITLE, </pre>
			<pre class="source-code">           EMPLOYEE.OFFICE_CODE, SALE.SALE_)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .join(SALE)</pre>
			<pre class="source-code">   <strong class="bold">// "on" clause is missing here</strong></pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The IDE signals this issue immediately, as shown in the following figure:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B16833_Figure_3.3.jpg" alt="Figure 3.3 – Wrong SQL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Wrong SQL</p>
			<p>Let's continue <a id="_idIndexMarker264"/>with another wrong SQL that uses <strong class="source-inline">JOIN</strong> in an improper place:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .union(select(CUSTOMER.CONTACT_FIRST_NAME, </pre>
			<pre class="source-code">                 CUSTOMER.CONTACT_LAST_NAME)</pre>
			<pre class="source-code">          .from(CUSTOMER))</pre>
			<pre class="source-code"><strong class="bold">   .join(CUSTOMER)</strong></pre>
			<pre class="source-code"><strong class="bold">   // "join" is not allowed here</strong></pre>
			<pre class="source-code">   .on(CUSTOMER.SALES_REP_EMPLOYEE_NUMBER</pre>
			<pre class="source-code">      .eq(EMPLOYEE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>And, for the last example, let's look at a wrong SQL that misses <strong class="source-inline">over()</strong>:</p>
			<pre class="source-code">ctx.select(CUSTOMER.CUSTOMER_NAME, </pre>
			<pre class="source-code">           ORDER.ORDER_DATE,lead(ORDER.ORDER_DATE, 1)</pre>
			<pre class="source-code"><strong class="bold">   // missing over()</strong></pre>
			<pre class="source-code">   .orderBy(ORDER.ORDER_DATE).as("NEXT_ORDER_DATE"))</pre>
			<pre class="source-code">   .from(ORDER)</pre>
			<pre class="source-code">   .join(CUSTOMER)</pre>
			<pre class="source-code">      .on(ORDER.CUSTOMER_NUMBER</pre>
			<pre class="source-code">        .eq(CUSTOMER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Of course, we<a id="_idIndexMarker265"/> can continue like this forever, but I think you get the idea! So, count on jOOQ!</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Casting, coercing, and collating</h1>
			<p>jOOQ was designed to handle most of the casting issues under the hood, including for ultra-strong-typed databases such as DB2. Nevertheless, explicit casting and/or coercing still serve some isolated cases. Most probably, we'll need them when we are not satisfied with the jOOQ automatic mapping (for instance, we consider that jOOQ didn't find the most accurate mapping), or we just need a certain type to respond to a special case. Even if they add a little bit of verbosity, casting and coercing can be used fluently; therefore, the DSL expressions are not disrupted.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Casting</h2>
			<p>Most of the<a id="_idIndexMarker266"/> time, jOOQ <a id="_idIndexMarker267"/>finds the most accurate data type mapping between the database and Java. If we look into a jOOQ generated class that mirrors a database table, then we see that, for each column that has a database-specific type (for example, <strong class="source-inline">VARCHAR</strong>), jOOQ has found a Java type correspondent (for example, <strong class="source-inline">String</strong>). If we compare the schema of the <strong class="source-inline">PAYMENT</strong> table with the generated <strong class="source-inline">jooq.generated.tables.Payment</strong> class, then we find the following data type correspondence:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B16833_Figure_3.4.jpg" alt="Figure 3.4 – Type mapping between the database and Java&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Type mapping between the database and Java</p>
			<p>When the jOOQ mapping is not what we need or jOOQ cannot infer a certain type, then we can rely on the jOOQ casting API, which contains the following methods:</p>
			<pre class="source-code">// cast this field to the type of another field</pre>
			<pre class="source-code">&lt;Z&gt; Field&lt;Z&gt; cast(Field&lt;Z&gt; field);</pre>
			<pre class="source-code">// cast this field to a given DataType</pre>
			<pre class="source-code">&lt;Z&gt; Field&lt;Z&gt; cast(DataType&lt;Z&gt; type);</pre>
			<pre class="source-code">// cast this field to the default DataType for a given Class</pre>
			<pre class="source-code">&lt;Z&gt; Field&lt;Z&gt; cast(Class&lt;? extends Z&gt; type);</pre>
			<p>Besides these <a id="_idIndexMarker268"/>methods, the <strong class="source-inline">DSL</strong> class <a id="_idIndexMarker269"/>contains these methods:</p>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; cast(Object object, Field&lt;T&gt; field);</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; cast(Object object, DataType&lt;T&gt; type);</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; cast(Object object, Class&lt;? extends T&gt; type);</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; castNull(Field&lt;T&gt; field);</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; castNull(DataType&lt;T&gt; type);</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; castNull(Class&lt;? extends T&gt; type);</pre>
			<p>Let's have some examples against MySQL and let's start with the following query that maps the fetched data to the Java types that jOOQ has automatically chosen:</p>
			<pre class="source-code">Result&lt;Record2&lt;BigDecimal, LocalDateTime&gt;&gt; result =    </pre>
			<pre class="source-code">ctx.select(PAYMENT.INVOICE_AMOUNT.as("invoice_amount"),</pre>
			<pre class="source-code">           PAYMENT.CACHING_DATE.as("caching_date"))</pre>
			<pre class="source-code">   .from(PAYMENT)</pre>
			<pre class="source-code">   .where(PAYMENT.CUSTOMER_NUMBER.eq(103L))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>So, <strong class="source-inline">INVOICE_AMOUNT</strong> is mapped to <strong class="source-inline">BigDecimal</strong>, and <strong class="source-inline">CACHING_DATE</strong> is mapped to <strong class="source-inline">LocalDateTime</strong>. Let's assume that we are in a corner-case scenario that requires us to fetch <strong class="source-inline">INVOICE_AMOUNT</strong> as <strong class="source-inline">String</strong> and <strong class="source-inline">CACHING_DATE</strong> as <strong class="source-inline">LocalDate</strong>. Of course, we can loop the preceding result and perform the conversions of each record in Java, but, at the<a id="_idIndexMarker270"/> query level, we can accomplish this via jOOQ <strong class="source-inline">cast()</strong>, as follows:</p>
			<pre class="source-code">Result&lt;Record2&lt;String, LocalDate&gt;&gt; result =   </pre>
			<pre class="source-code">  ctx.select(</pre>
			<pre class="source-code">         PAYMENT.INVOICE_AMOUNT.cast(String.class)</pre>
			<pre class="source-code">           .as("invoice_amount"),</pre>
			<pre class="source-code">         PAYMENT.CACHING_DATE.cast(LocalDate.class)</pre>
			<pre class="source-code">           .as("caching_date"))</pre>
			<pre class="source-code">     .from(PAYMENT)</pre>
			<pre class="source-code">     .where(PAYMENT.CUSTOMER_NUMBER.eq(103L))</pre>
			<pre class="source-code">     .fetch();</pre>
			<p>Check out the SQL string generated after using <strong class="source-inline">cast()</strong>:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  cast(`classicmodels`.`payment`.`invoice_amount` as char) </pre>
			<pre class="source-code">    as `invoice_amount`,</pre>
			<pre class="source-code">  cast(`classicmodels`.`payment`.`caching_date` as date) </pre>
			<pre class="source-code">    as `caching_date`</pre>
			<pre class="source-code">FROM`classicmodels`.`payment`</pre>
			<pre class="source-code">WHERE`classicmodels`.`payment`.`customer_number` = 103</pre>
			<p>In the following figure, you can see the result set returned by these two SQLs:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B16833_Figure_3.5.jpg" alt="Figure 3.5 – Casting results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Casting results</p>
			<p>Notice that the jOOQ casting operations are rendered in the generated SQL string, therefore, the<a id="_idIndexMarker271"/> database<a id="_idIndexMarker272"/> is responsible for performing these casts. But, in this scenario, do we really need these clumsy castings or do we actually need data type coercions?</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Coercing</h2>
			<p>Data type <a id="_idIndexMarker273"/>coercions act <a id="_idIndexMarker274"/>like casting, except that they have no footprint on the actual SQL query being generated. In other words, data type coercions act as an unsafe cast in Java and are not rendered in the SQL string. With data type coercions, we only instruct jOOQ to pretend that a data type is of another data type and to bind it accordingly. Whenever possible, it is preferable to use coercions over casting. This way, we don't risk casting issues and we don't pollute the generated SQL with unnecessary castings. The API consists of several methods:</p>
			<pre class="source-code">// coerce this field to the type of another field</pre>
			<pre class="source-code">&lt;Z&gt; Field&lt;Z&gt; coerce(Field&lt;Z&gt; field);</pre>
			<pre class="source-code">// coerce this field to a given DataType</pre>
			<pre class="source-code">&lt;Z&gt; Field&lt;Z&gt; coerce(DataType&lt;Z&gt; type);</pre>
			<pre class="source-code">// coerce this field to the default DataType for a given Class</pre>
			<pre class="source-code">&lt;Z&gt; Field&lt;Z&gt; coerce(Class&lt;? Extends Z&gt; type);</pre>
			<p>Besides these methods, the <strong class="source-inline">DSL</strong> class contains these methods:</p>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; coerce(Field&lt;?&gt; field,  DataType&lt;T&gt; as)</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; coerce(Field&lt;?&gt; field, Field&lt;T&gt; as)</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; coerce(Field&lt;?&gt; field, Class&lt;T&gt; as)</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; coerce(Object value, Field&lt;T&gt; as)</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; coerce(Object value, DataType&lt;T&gt; as)</pre>
			<pre class="source-code">&lt;T&gt; Field&lt;T&gt; coerce(Object value, Field&lt;T&gt; as)</pre>
			<p>In the example from the <em class="italic">Casting</em> section, we relied on casting from <strong class="source-inline">BigDecimal</strong> to <strong class="source-inline">String</strong> and <a id="_idIndexMarker275"/>from <strong class="source-inline">LocalDateTime</strong> to <strong class="source-inline">LocalDate</strong>. This casting was rendered in the SQL string and was performed by the database. But, we can avoid polluting the SQL string with these casts via coercion as follows:</p>
			<pre class="source-code">Result&lt;Record2&lt;String, LocalDate&gt;&gt; result= ctx.select(</pre>
			<pre class="source-code">    PAYMENT.INVOICE_AMOUNT.coerce(String.class)</pre>
			<pre class="source-code">      .as("invoice_amount"),</pre>
			<pre class="source-code">    PAYMENT.CACHING_DATE.coerce(LocalDate.class)</pre>
			<pre class="source-code">      .as("caching_date"))</pre>
			<pre class="source-code">  .from(PAYMENT)</pre>
			<pre class="source-code">  .where(PAYMENT.CUSTOMER_NUMBER.eq(103L))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>The produced result set is the same as in the case of using casting, but the SQL string doesn't reflect coercions <a id="_idIndexMarker276"/>and the database didn't perform any casting operations. This is much better and safer:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  `classicmodels`.`payment`.`invoice_amount` </pre>
			<pre class="source-code">    as `invoice_amount`,</pre>
			<pre class="source-code">  `classicmodels`.`payment`.`caching_date` </pre>
			<pre class="source-code">    as `caching_date`</pre>
			<pre class="source-code">FROM `classicmodels`.`payment`</pre>
			<pre class="source-code">WHERE `classicmodels`.`payment`.`customer_number` = 103</pre>
			<p>Starting with version 3.12, jOOQ allows for coercing <strong class="source-inline">ResultQuery&lt;R1&gt;</strong> to a new <strong class="source-inline">ResultQuery&lt;R2&gt;</strong> type as well. For instance, check out this plain SQL:</p>
			<pre class="source-code">ctx.resultQuery(</pre>
			<pre class="source-code">  "SELECT first_name, last_name FROM employee").fetch();</pre>
			<p>The result type of this query is <strong class="source-inline">Result&lt;Record&gt;</strong> but we can easily replace <strong class="source-inline">fetch()</strong> with <strong class="source-inline">fetchInto()</strong> to map this result to the generated <strong class="source-inline">Employee</strong> POJO (only the <strong class="source-inline">firstName</strong> and <strong class="source-inline">lastName</strong> fields will be populated) or to a custom POJO containing only the fetched fields. But, how about fetching <strong class="source-inline">Result&lt;Record2&lt;String, String&gt;&gt;</strong>? This can be accomplished via one of the <strong class="source-inline">ResultQuery.coerce()</strong> flavors as follows:</p>
			<pre class="source-code">Result&lt;Record2&lt;String, String&gt;&gt; result = ctx.resultQuery(</pre>
			<pre class="source-code">    "SELECT first_name, last_name FROM employee")</pre>
			<pre class="source-code">  .coerce(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">  .fetch();   </pre>
			<p>Coercing a result <a id="_idIndexMarker277"/>set to a table can be done via <strong class="source-inline">ResultQuery.coerce(Table&lt;X&gt; table)</strong>. You can find an example in the bundled code next to an<a id="_idIndexMarker278"/> alternative before jOOQ 3.12. If during coercing, jOOQ finds any <strong class="source-inline">Converter</strong> or <strong class="source-inline">Binding</strong> configurations, then it will apply them (this is covered in <a href="B16833_07.xhtml#_idTextAnchor110"><em class="italic">Chapter 7</em></a>, <em class="italic">Types, Converters, and Bindings</em>).</p>
			<h3>Coercing versus casting</h3>
			<p>Don't <a id="_idIndexMarker279"/>conclude<a id="_idIndexMarker280"/> that <strong class="source-inline">coerce()</strong> can replace <strong class="source-inline">cast()</strong> all the time. Check out this example that uses <strong class="source-inline">coerce()</strong>:</p>
			<pre class="source-code">Result&lt;Record2&lt;BigDecimal, String&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">  PRODUCT.BUY_PRICE.coerce(SQLDataType.DECIMAL(10, 5))</pre>
			<pre class="source-code">    .as("buy_price"),</pre>
			<pre class="source-code">  PRODUCT.PRODUCT_DESCRIPTION.coerce(SQLDataType.VARCHAR(10))</pre>
			<pre class="source-code">    .as("prod_desc"))</pre>
			<pre class="source-code">  .from(PRODUCT)</pre>
			<pre class="source-code">  .where(PRODUCT.PRODUCT_ID.eq(1L))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>So, we pretend that <strong class="source-inline">BUY_PRICE</strong> is <strong class="source-inline">BigDecimal</strong> having a precision of <em class="italic">10</em> and a scale of <strong class="source-inline">5</strong>, and <strong class="source-inline">PRODUCT_DESCRIPTION</strong> is a string of length <em class="italic">10</em>. But, coercing cannot do that. In this case, coercing can pretend the <strong class="source-inline">BigDecimal</strong> (<strong class="source-inline">BUY_PRICE</strong> is really treated as a <strong class="source-inline">BigDecimal</strong> value), and <strong class="source-inline">String</strong> (<strong class="source-inline">PRODUCT_DESCRIPTION</strong> is really treated as a <strong class="source-inline">String</strong> value) types, but it cannot pretend the domain constraints. </p>
			<p>Let's <a id="_idIndexMarker281"/>replace <strong class="source-inline">coerce()</strong> with <strong class="source-inline">cast()</strong>:</p>
			<pre class="source-code">Result&lt;Record2&lt;BigDecimal, String&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">  PRODUCT.BUY_PRICE.cast(SQLDataType.DECIMAL(10, 5))</pre>
			<pre class="source-code">    .as("buy_price"),</pre>
			<pre class="source-code">  PRODUCT.PRODUCT_DESCRIPTION.cast(SQLDataType.VARCHAR(10))</pre>
			<pre class="source-code">    .as("prod_desc"))</pre>
			<pre class="source-code">  .from(PRODUCT)</pre>
			<pre class="source-code">  .where(PRODUCT.PRODUCT_ID.eq(1L))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>This time, casting is rendered in the generated SQL string. The following figure compares the result of using <strong class="source-inline">coerce()</strong> and <strong class="source-inline">cast()</strong>; this works as expected:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B16833_Figure_3.6.jpg" alt="Figure 3.6 – Coercing versus casting (1)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Coercing versus casting (1)</p>
			<p>Let's have one more <a id="_idIndexMarker282"/>example. Check out this example that uses <strong class="source-inline">coerce()</strong>:</p>
			<pre class="source-code">public void printInvoicesPerDayCoerce(LocalDate day) {</pre>
			<pre class="source-code">  ctx.select(PAYMENT.INVOICE_AMOUNT)</pre>
			<pre class="source-code">     .from(PAYMENT)</pre>
			<pre class="source-code">     <strong class="bold">.where(PAYMENT.PAYMENT_DATE</strong></pre>
			<pre class="source-code"><strong class="bold">       .coerce(LocalDate.class).eq(day))</strong></pre>
			<pre class="source-code">     .fetch()</pre>
			<pre class="source-code">     .forEach(System.out::println);</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">PAYMENT.PAYMENT_DATE</strong> is a timestamp, therefore, it is not enough to pretend that it is a date since the time component will fail our predicate. For instance, <em class="italic">2003-04-09 09:21:25</em> is not<a id="_idIndexMarker283"/> equal to <em class="italic">2003-04-09</em>. In this case, we need an actual <a id="_idIndexMarker284"/>cast from timestamp to date as follows:</p>
			<pre class="source-code">public void printInvoicesPerDayCast(LocalDate day) {</pre>
			<pre class="source-code">  ctx.select(PAYMENT.INVOICE_AMOUNT)</pre>
			<pre class="source-code">     .from(PAYMENT)</pre>
			<pre class="source-code">     <strong class="bold">.where(PAYMENT.PAYMENT_DATE</strong></pre>
			<pre class="source-code">       <strong class="bold">.cast(LocalDate.class).eq(day))</strong></pre>
			<pre class="source-code">     .fetch()</pre>
			<pre class="source-code">     .forEach(System.out::println);</pre>
			<pre class="source-code">}</pre>
			<p>This time, the cast takes place via this SQL (for <em class="italic">2003-04-09</em>):</p>
			<pre class="source-code">SELECT `classicmodels`.`payment`.`invoice_amount`</pre>
			<pre class="source-code">FROM `classicmodels`.`payment`</pre>
			<pre class="source-code">WHERE cast(`classicmodels`.`payment`.`payment_date` as date) </pre>
			<pre class="source-code">  = { d '2003-04-09' }</pre>
			<p>The following figure compares the results of using <strong class="source-inline">coerce()</strong> and <strong class="source-inline">cast()</strong>:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B16833_Figure_3.7.jpg" alt="Figure 3.7 – Coercing versus casting (2)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Coercing versus casting (2)</p>
			<p>Another good example where cast works and coerce does not is when the cast is performed in <strong class="source-inline">GROUP BY</strong>, which isn't uncommon when grouping timestamp columns by <strong class="source-inline">CAST(ts AS DATE)</strong>. Also, when the value being cast is an expression, not a bind variable, the effect is different (although coerce can be used to compare, for instance, <strong class="source-inline">INTEGER</strong> columns<a id="_idIndexMarker285"/> with <strong class="source-inline">BIGINT</strong> columns without the database<a id="_idIndexMarker286"/> needing to convert anything).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">As a rule of thumb, in some cases when both could work (for instance, when you project the expressions), it is best to use <strong class="source-inline">coerce()</strong> rather than <strong class="source-inline">cast()</strong>. This way, you don't risk unsafe or raw-type casting in Java and you don't pollute the generated SQL with unnecessary castings.</p>
			<p>Next, let's discuss collations.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Collation</h2>
			<p>Databases<a id="_idIndexMarker287"/> define a <a id="_idIndexMarker288"/>character set as a set of symbols and encodings. A collation defines a set of rules for comparing (ordering) characters in a character set. jOOQ allows us to specify a collation via <strong class="source-inline">collation</strong><strong class="source-inline">(Collation collation)</strong> for <strong class="source-inline">org.jooq.DateType</strong> and via <strong class="source-inline">collate</strong><strong class="source-inline">(String collation)</strong>, <strong class="source-inline">collate</strong><strong class="source-inline">(Collation collation)</strong>, and <strong class="source-inline">collate</strong><strong class="source-inline">(Name collation)</strong> for <strong class="source-inline">org.jooq.Field</strong>. Here is an example of setting the <strong class="source-inline">latin1_spanish_ci</strong> collation for a field:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .orderBy(PRODUCT.PRODUCT_NAME.collate("latin1_spanish_ci"))</pre>
			<pre class="source-code">   .fetch()</pre>
			<pre class="source-code">   .forEach(System.out::println);</pre>
			<p>All the examples<a id="_idIndexMarker289"/> from this section are available in the <em class="italic">CastCoerceCollate</em> application.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Binding values (parameters)</h1>
			<p>Binding<a id="_idIndexMarker290"/> values<a id="_idIndexMarker291"/> is another fundamental topic of jOOQ.</p>
			<p>The well-known prepared statements and bind values combination is the preferable approach to express SQL statements in JDBC. Among benefits, this combination provides protection against SQL injections, sustains caching (for instance, most connection pools cache prepared statements across connections or rely on JDBC driver caching capabilities as HikariCP does), and reusability capabilities (re-using execution plans for identical SQL statements, regardless of actual bind values).</p>
			<p>Having security and performance packed into this combination makes it preferable against static statements (<strong class="source-inline">java.sql.Statement</strong>) and inlined values, so jOOQ also embraces it as default.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">By default, jOOQ aligns its support for bind values to JDBC style. In other words, jOOQ relies on <strong class="source-inline">java.sql.PreparedStatement</strong> and indexed bind values or indexed parameters. Moreover, exactly like JDBC, jOOQ uses a <strong class="source-inline">?</strong> (question mark) character for marking the bind value placeholders.</p>
			<p class="callout">However, in contrast to JDBC, which supports only indexed parameters and the <strong class="source-inline">?</strong> character, jOOQ supports named and inlined parameters as well. Each of them is detailed in this section.</p>
			<p>So, in JDBC, the only way to exploit bind values aligns to the following example:</p>
			<pre class="source-code">Connection conn = ...;</pre>
			<pre class="source-code">try (PreparedStatement stmt = conn.prepareStatement(</pre>
			<pre class="source-code">  """SELECT first_name, last_name FROM employee </pre>
			<pre class="source-code">     WHERE salary &gt; ? AND job_title = ?""")) {</pre>
			<pre class="source-code">     stmt.setInt(1, 5000);</pre>
			<pre class="source-code">     stmt.setString(2, "Sales Rep");</pre>
			<pre class="source-code">     stmt.executeQuery();</pre>
			<pre class="source-code">}</pre>
			<p>In other words, in JDBC, it is our responsibility to keep track <a id="_idIndexMarker292"/>of the <a id="_idIndexMarker293"/>number of question marks and their corresponding index. This becomes cumbersome in complex/dynamic queries.</p>
			<p>As Lukas Eder highlights, "<em class="italic">The strength of languages such as L/SQL, PL/pgSQL, T-SQL (among other things) is precisely the fact that prepared statements can naturally embed bind values transparently, without the user having to think about the binding logic</em>."</p>
			<p>Now, let's see how jOOQ tackles bind values via indexed bind values or indexed parameters.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Indexed parameters</h2>
			<p>Writing the previous <a id="_idIndexMarker294"/>query via jOOQ's DSL API can be done as follows:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.SALARY.gt(5000)</pre>
			<pre class="source-code">     .and(EMPLOYEE.JOB_TITLE.eq("Sales Rep")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Even if it looks like we've inlined the values (<em class="italic">5000</em> and <em class="italic">Sales Rep</em>), this is not true. jOOQ abstracts away the JDBC frictions and allows us to use indexed parameters exactly where needed (directly in SQL). Since jOOQ takes care of everything, we don't even care about the indexes of the parameters. Moreover, we take advantage of type-safety for these parameters and we don't need to explicitly set their type. The preceding SQL renders the following SQL string (notice the<a id="_idIndexMarker295"/> rendered question marks as bind values placeholders):</p>
			<pre class="source-code">SELECT </pre>
			<pre class="source-code">  `classicmodels`.`employee`.`first_name`, </pre>
			<pre class="source-code">  `classicmodels`.`employee`.`last_name` </pre>
			<pre class="source-code">FROM`classicmodels`.`employee` </pre>
			<pre class="source-code">WHERE (`classicmodels`.`employee`.`salary` &gt; ? </pre>
			<pre class="source-code">       and `classicmodels`.`employee`.`job_title` = ?)</pre>
			<p>And, after jOOQ resolves the bind values, we have the following:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  `classicmodels`.`employee`.`first_name`, </pre>
			<pre class="source-code">  `classicmodels`.`employee`.`last_name` </pre>
			<pre class="source-code">FROM `classicmodels`.`employee` </pre>
			<pre class="source-code">WHERE(`classicmodels`.`employee`.`salary` &gt; 5000 </pre>
			<pre class="source-code">   and `classicmodels`.`employee`.`job_title` = 'Sales Rep')</pre>
			<p>Behind the scene, jOOQ uses a method named <strong class="source-inline">DSL.val(value)</strong> for transforming the given <strong class="source-inline">value</strong> argument (<strong class="source-inline">value</strong> can be <strong class="source-inline">boolean</strong>, <strong class="source-inline">byte</strong>, <strong class="source-inline">String</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">double</strong>, and so on) into a bind value. This <strong class="source-inline">DSL.val()</strong> method wraps and returns a bind value via the <strong class="source-inline">org.jooq.Param</strong> interface. This interface extends <strong class="source-inline">org.jooq.Field</strong>, therefore, extends a column expression(or field) and can be used accordingly via the jOOQ API. The previous query can also be written by explicitly using <strong class="source-inline">DSL.val()</strong> as follows:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.SALARY.gt(val(5000))</pre>
			<pre class="source-code">      .and(EMPLOYEE.JOB_TITLE.eq(val("Sales Rep"))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>But, as you just saw, using <strong class="source-inline">val()</strong> explicitly is not needed in this case. Using <strong class="source-inline">val()</strong> like this is just adding noise to the SQL <a id="_idIndexMarker296"/>expression.</p>
			<p>In this query, we've used hardcoded values, but, most probably, these values represent user inputs that land in the query via the arguments of the method containing this query. Check out this example, which extracts these hardcoded values as arguments of the method:</p>
			<pre class="source-code">public void userInputValuesAsIndexedParams(</pre>
			<pre class="source-code">        int salary, String job) {</pre>
			<pre class="source-code">  ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">     .from(EMPLOYEE)</pre>
			<pre class="source-code">     .where(EMPLOYEE.SALARY.gt(salary)</pre>
			<pre class="source-code">        .and(EMPLOYEE.JOB_TITLE.eq(job)))</pre>
			<pre class="source-code">     .fetch();</pre>
			<pre class="source-code">}</pre>
			<p>Of course, mixing <a id="_idIndexMarker297"/>hardcoded and user input values in the same query is supported as well. Next, let's tackle a bunch of examples where the explicit usage of <strong class="source-inline">val()</strong> is really needed.</p>
			<h3>Explicit usage of val()</h3>
			<p>There are <a id="_idIndexMarker298"/>cases when we cannot pass plain values to jOOQ <a id="_idIndexMarker299"/>and expect back bind values. There are a few such cases:</p>
			<ul>
				<li>When the bind value is at the left-hand side of an operator</li>
				<li>When <strong class="source-inline">Field</strong> references and <strong class="source-inline">Param</strong> values are mixed</li>
				<li>When the bind value occurs in a clause that doesn't support it (for instance, in <strong class="source-inline">select()</strong>)</li>
				<li>When functions require a <strong class="source-inline">Field&lt;T&gt;</strong> type for one of the parameters</li>
			</ul>
			<p>Let's have some examples.</p>
			<h4>Bind value is at the left-hand side of an operator</h4>
			<p>Having the plain<a id="_idIndexMarker300"/> value at the left-hand side of an operator doesn't allow us to write the needed jOOQ expression since we don't have access to the jOOQ DSL API. For instance, we cannot write <strong class="source-inline">...5000.eq(EMPLOYEE.SALARY)</strong> since the <strong class="source-inline">eq()</strong> method is not available. On the other hand, we should write <strong class="source-inline">...val(5000).eq(EMPLOYEE.SALARY)</strong>. This time, <em class="italic">5000</em> is wrapped in <strong class="source-inline">Param</strong> (which extends <strong class="source-inline">Field</strong>) via <strong class="source-inline">val(int/Integer value)</strong> and we can continue to exploit the jOOQ DSL API, such as the <strong class="source-inline">eq()</strong> method. Here is another example:</p>
			<pre class="source-code">ctx.select(PAYMENT.INVOICE_AMOUNT)</pre>
			<pre class="source-code">   .from(PAYMENT)</pre>
			<pre class="source-code">   .where(<strong class="bold">val(LocalDateTime.now()</strong>)</pre>
			<pre class="source-code">      .between(PAYMENT.PAYMENT_DATE)</pre>
			<pre class="source-code">         .and(PAYMENT.CACHING_DATE))</pre>
			<pre class="source-code">   .fetch(); </pre>
			<p>Here is an example <a id="_idIndexMarker301"/>where the value is a user input:</p>
			<pre class="source-code">public void usingValExplicitly(LocalDateTime date) {</pre>
			<pre class="source-code">ctx.select(PAYMENT.INVOICE_AMOUNT)</pre>
			<pre class="source-code">     .from(PAYMENT)</pre>
			<pre class="source-code">     .where(val(date).between(PAYMENT.PAYMENT_DATE)</pre>
			<pre class="source-code">       .and(PAYMENT.CACHING_DATE))</pre>
			<pre class="source-code">     .fetch();</pre>
			<pre class="source-code">}</pre>
			<p>Next, let's see the other case, when <strong class="source-inline">Field</strong> references and <strong class="source-inline">Param</strong> values are mixed.</p>
			<h4>Field references and Param values are mixed</h4>
			<p>Let's consider that we want to use the <strong class="source-inline">DSL.concat(Field&lt;?&gt;... fields)</strong> method for concatenating <strong class="source-inline">CUSTOMER.CONTACT_FIRST_NAME</strong>, the whitespace literal (<strong class="source-inline">" "</strong>), and <strong class="source-inline">CUSTOMER.CONTACT_LAST_NAME</strong> (for example, <em class="italic">Joana Nimar</em>). While <strong class="source-inline">CONTACT_FIRST_NAME</strong> and <strong class="source-inline">CONTACT_LAST_NAME</strong> are fields, the whitespace literal (<strong class="source-inline">" "</strong>) cannot be used in this context as a plain string. But, it can be wrapped in <strong class="source-inline">Param</strong> via the <strong class="source-inline">val()</strong> method, as follows:</p>
			<pre class="source-code">ctx.select(CUSTOMER.CUSTOMER_NUMBER,</pre>
			<pre class="source-code">    concat(CUSTOMER.CONTACT_FIRST_NAME, val(" "), </pre>
			<pre class="source-code">           CUSTOMER.CONTACT_LAST_NAME))</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Here is another <a id="_idIndexMarker302"/>example that mixes the jOOQ internal usage of <strong class="source-inline">val()</strong> and our explicit usage of <strong class="source-inline">val()</strong> for wrapping a user input value to add it as a column in the result set:</p>
			<pre class="source-code">public void usingValExplicitly(float vat) {</pre>
			<pre class="source-code">    ctx.select(</pre>
			<pre class="source-code">    EMPLOYEE.SALARY, </pre>
			<pre class="source-code">         // jOOQ implicit val()</pre>
			<pre class="source-code">         EMPLOYEE.SALARY.mul(vat).as("vat_salary"), </pre>
			<pre class="source-code">         // explicit val()</pre>
			<pre class="source-code">         val(vat).as("vat"))</pre>
			<pre class="source-code">      .from(EMPLOYEE)</pre>
			<pre class="source-code">      .fetch();</pre>
			<pre class="source-code">    }</pre>
			<p>Here is another <a id="_idIndexMarker303"/>example of mixing implicit and explicit <strong class="source-inline">val()</strong> usage for writing a simple arithmetic expression, <em class="italic">mod((((10 - 2) * (7 / 3)) / 2), 10)</em>:</p>
			<pre class="source-code">ctx.select(val(10).sub(2).mul(val(7).div(3)).div(2).mod(10))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>When the same parameter is used multiple times, it is advisable to extract it as in the following example:</p>
			<pre class="source-code">public void reusingVal(int salary) {</pre>
			<pre class="source-code">  Param&lt;Integer&gt; salaryParam = val(salary);</pre>
			<pre class="source-code">  ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">           salaryParam.as("base_salary"))</pre>
			<pre class="source-code">     .from(EMPLOYEE)</pre>
			<pre class="source-code">     .where(salaryParam.eq(EMPLOYEE.SALARY))</pre>
			<pre class="source-code">       .and(salaryParam.mul(0.15).gt(10000))</pre>
			<pre class="source-code">     .fetch();</pre>
			<pre class="source-code">}    </pre>
			<p>While we take <a id="_idIndexMarker304"/>care of the <strong class="source-inline">salary</strong> value, jOOQ will take care of the <em class="italic">0.15</em> and <em class="italic">10000</em> constants. All three will become indexed bind values.</p>
			<h3>Bind values from string query</h3>
			<p>If, for some<a id="_idIndexMarker305"/> reason, you want to bind <a id="_idIndexMarker306"/>values directly from a string query, then you can do it via plain SQL as in the following example:</p>
			<pre class="source-code">// bind value from string query</pre>
			<pre class="source-code">ctx.fetch("""</pre>
			<pre class="source-code">       SELECT first_name, last_name</pre>
			<pre class="source-code">       FROM employee WHERE salary &gt; ? AND job_title = ?</pre>
			<pre class="source-code">          """, 5000, "Sales Rep");                </pre>
			<pre class="source-code">// bind value from string query</pre>
			<pre class="source-code">ctx.resultQuery("""</pre>
			<pre class="source-code">        SELECT first_name, last_name</pre>
			<pre class="source-code">        FROM employee WHERE salary &gt; ? AND job_title = ?</pre>
			<pre class="source-code">                """, 5000, "Sales Rep")</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Next, let's talk about the named parameters.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Named parameters</h2>
			<p>While JDBC support is limited to indexed bind <a id="_idIndexMarker307"/>values, jOOQ goes beyond this limit and supports named parameters as well. Creating a jOOQ named parameter is accomplished via the <strong class="source-inline">DSL.param()</strong> methods. Among these methods, we have <strong class="source-inline">param(String name, T value)</strong>, which creates a named parameter with a name and an initial value. Here is an example:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.SALARY.gt(param("employeeSalary", 5000))</pre>
			<pre class="source-code">      .and(EMPLOYEE.JOB_TITLE</pre>
			<pre class="source-code">         .eq(param("employeeJobTitle", "Sales Rep"))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Here is an example of the values of named parameters being provided as user inputs:</p>
			<pre class="source-code">public void userInputValuesAsNamedParams(</pre>
			<pre class="source-code">                     int salary, String job) {</pre>
			<pre class="source-code">  ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">     .from(EMPLOYEE)</pre>
			<pre class="source-code">     .where(EMPLOYEE.SALARY</pre>
			<pre class="source-code">       .gt(param("employeeSalary", salary))</pre>
			<pre class="source-code">       .and(EMPLOYEE.JOB_TITLE</pre>
			<pre class="source-code">         .eq(param("employeeJobTitle", job))))</pre>
			<pre class="source-code">     .fetch();</pre>
			<pre class="source-code">}</pre>
			<p>While rendering the SQL of the previous queries, you have observed that jOOQ doesn't render the names of these parameters as<a id="_idIndexMarker308"/> placeholders. It still renders a question mark as the default placeholder. To instruct jOOQ to render the names of the parameters as placeholders, we call via the <strong class="source-inline">DSL.renderNamedParams()</strong> method that returns a string, as in the following example:</p>
			<pre class="source-code">String sql = ctx.renderNamedParams(</pre>
			<pre class="source-code">  ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">     .from(EMPLOYEE)</pre>
			<pre class="source-code">     .where(EMPLOYEE.SALARY.gt(param("employeeSalary", 5000))</pre>
			<pre class="source-code">     .and(EMPLOYEE.JOB_TITLE</pre>
			<pre class="source-code">        .eq(param("employeeJobTitle", "Sales Rep"))))</pre>
			<p>Moreover, we can specify a string to be used as a prefix for each rendered named parameter via <strong class="source-inline">Settings.withRenderNamedParamPrefix()</strong>. You can see an example in the bundled code.</p>
			<p>The returned string can be passed to another SQL access abstraction that supports named parameters. For this example, the<a id="_idIndexMarker309"/> rendered SQL string is as follows:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  `classicmodels`.`employee`.`first_name`, </pre>
			<pre class="source-code">  `classicmodels`.`employee`.`last_name` </pre>
			<pre class="source-code">FROM `classicmodels`.`employee` </pre>
			<pre class="source-code">WHERE (`classicmodels`.`employee`.`salary` &gt; : employeeSalary</pre>
			<pre class="source-code">       and `classicmodels`.`employee`.`job_title` </pre>
			<pre class="source-code">         = : employeeJobTitle)</pre>
			<p>Next, let's talk about the inline parameters.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Inline parameters</h2>
			<p>An inline bind value is rendered as the actual plain<a id="_idIndexMarker310"/> value via <strong class="source-inline">DSL.inline()</strong>. In other words, while indexed and named parameters render the bind values as placeholders via question marks (or names), inline parameters render their plain values directly. jOOQ automatically replaces the placeholders (<strong class="source-inline">?</strong> or <strong class="source-inline">:name</strong> for named parameters) and will properly escape inline bind values to avoid SQL syntax errors and SQL injection. Nevertheless, be warned that abusing the usage of the inline parameters may lead to poor performance on RDBMSs that have execution plan caches. So, avoid copying and pasting <strong class="source-inline">inline()</strong> everywhere!</p>
			<p>Typically, using <strong class="source-inline">inline()</strong> for constants is a good practice. For instance, earlier, we used <strong class="source-inline">val(" ")</strong> to express <strong class="source-inline">concat(CUSTOMER.CONTACT_FIRST_NAME, val(" "), CUSTOMER.CONTACT_LAST_NAME))</strong>. But, since the <strong class="source-inline">" "</strong> string is a constant, it can be inlined:</p>
			<pre class="source-code">ctx.select(CUSTOMER.CUSTOMER_NUMBER,</pre>
			<pre class="source-code">      concat(CUSTOMER.CONTACT_FIRST_NAME, <strong class="bold">inline(" ")</strong>, </pre>
			<pre class="source-code">      CUSTOMER.CONTACT_LAST_NAME))</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>But, if you know that this is not a constant, then it is better to rely on <strong class="source-inline">val()</strong> to sustain execution plan caches.</p>
			<p>At the <strong class="source-inline">Configuration</strong> level, we can use inline parameters by switching from the <strong class="source-inline">PreparedStatement</strong> default to a static <strong class="source-inline">Statement</strong> via jOOQ settings. For example, the following <strong class="source-inline">DSLContext</strong> will use static statements, and all queries triggered in the context of this configuration<a id="_idIndexMarker311"/> will use inline parameters:</p>
			<pre class="source-code">public void inlineParamsViaSettings() {</pre>
			<pre class="source-code">  DSL.using(ds, SQLDialect.MYSQL,</pre>
			<pre class="source-code">        new Settings().withStatementType(</pre>
			<pre class="source-code">              StatementType.STATIC_STATEMENT))</pre>
			<pre class="source-code">     .select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">     .from(EMPLOYEE)</pre>
			<pre class="source-code">     .where(EMPLOYEE.SALARY.gt(5000)</pre>
			<pre class="source-code">       .and(EMPLOYEE.JOB_TITLE.eq("Sales Rep")))</pre>
			<pre class="source-code">     .fetch();</pre>
			<pre class="source-code">}</pre>
			<p>Obviously, another option is to rely on <strong class="source-inline">inline()</strong>:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.SALARY.gt(inline(5000))</pre>
			<pre class="source-code">   .and(EMPLOYEE.JOB_TITLE.eq(inline("Sales Rep"))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Of course, the inlined values can be user inputs as well. But, this technique is not recommended since user inputs may vary across executions and this will affect the performance of RDBMSs that rely on execution plan caches.</p>
			<p>The previous two examples render the same SQL having the actual plain values inlined:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  `classicmodels`.`employee`.`first_name`, </pre>
			<pre class="source-code">  `classicmodels`.`employee`.`last_name` </pre>
			<pre class="source-code">FORM `classicmodels`.`employee` </pre>
			<pre class="source-code">WHERE (`classicmodels`.`employee`.`salary` &gt; 5000 </pre>
			<pre class="source-code">   and `classicmodels`.`employee`.`job_title` = 'Sales Rep')</pre>
			<p>Globally, we can choose the type of parameters<a id="_idIndexMarker312"/> via <strong class="source-inline">Settings</strong>, as here (indexed parameters (<strong class="source-inline">ParamType.INDEXED</strong>) are used by default):</p>
			<pre class="source-code">@Bean</pre>
			<pre class="source-code">public Settings jooqSettings() {</pre>
			<pre class="source-code">  return new Settings().withParamType(ParamType.NAMED);   </pre>
			<pre class="source-code">}</pre>
			<p>Or, here is the global setting for using static statements and inline parameters:</p>
			<pre class="source-code">@Bean</pre>
			<pre class="source-code">public Settings jooqSettings() {</pre>
			<pre class="source-code">  return new Settings()</pre>
			<pre class="source-code">    .withStatementType(StatementType.STATIC_STATEMENT)</pre>
			<pre class="source-code">    .withParamType(ParamType.INLINED);</pre>
			<pre class="source-code">}</pre>
			<p>Next, let's see a handy approach to rendering a query with different types of parameter placeholders.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Rendering a query with different types of parameter placeholders</h2>
			<p>Let's <a id="_idIndexMarker313"/>assume that we have a query that uses indexed <a id="_idIndexMarker314"/>parameters and we need to render it as a certain SQL string having a different type of parameter placeholder (for instance, this may be required by another SQL abstraction):</p>
			<pre class="source-code">ResultQuery query</pre>
			<pre class="source-code">  = ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">       .from(EMPLOYEE)</pre>
			<pre class="source-code">       .where(EMPLOYEE.SALARY.gt(5000)</pre>
			<pre class="source-code">         .and(EMPLOYEE.JOB_TITLE.eq("Sales Rep")));</pre>
			<p>A handy approach for rendering this query with a different type of parameter placeholder relies on the <strong class="source-inline">Query.getSQL(ParamType)</strong> method as follows:</p>
			<ul>
				<li><strong class="source-inline">ParamType.INDEXED</strong> (in this example, this is the default behavior):</li>
			</ul>
			<p class="source-code">String sql = query.getSQL(ParamType.INDEXED);</p>
			<p class="source-code">SELECT </p>
			<p class="source-code">  `classicmodels`.`employee`.`first_name`, </p>
			<p class="source-code">  `classicmodels`.`employee`.`last_name` </p>
			<p class="source-code">FROM `classicmodels`.`employee` </p>
			<p class="source-code">WHERE (`classicmodels`.`employee`.`salary` &gt; ? </p>
			<p class="source-code">    and `classicmodels`.`employee`.`job_title` = ?)</p>
			<ul>
				<li><strong class="source-inline">ParamType.NAMED</strong> (for <a id="_idIndexMarker315"/>parameters with<a id="_idIndexMarker316"/> names, this produces placeholders of the<strong class="source-inline">:name</strong> type, but for unnamed parameters, it produces <strong class="source-inline">:1</strong>, <strong class="source-inline">:2</strong>, to <strong class="source-inline">:n</strong>, therefore, a combination of colon and index):</li>
			</ul>
			<p class="source-code">String sql = query.getSQL(ParamType.NAMED);</p>
			<p class="source-code">SELECT </p>
			<p class="source-code">  `classicmodels`.`employee`.`first_name`, </p>
			<p class="source-code">  `classicmodels`.`employee`.`last_name` </p>
			<p class="source-code">FROM `classicmodels`.`employee` </p>
			<p class="source-code">WHERE (`classicmodels`.`employee`.`salary` &gt; :1 </p>
			<p class="source-code">    and `classicmodels`.`employee`.`job_title` = :2)</p>
			<ul>
				<li><strong class="source-inline">ParamType.INLINED</strong> and <strong class="source-inline">ParamType.NAMED_OR_INLINED</strong>:</li>
			</ul>
			<p class="source-code">String sql = query.getSQL(ParamType.INLINED);</p>
			<p class="source-code">String sql = query.getSQL(ParamType.NAMED_OR_INLINED);</p>
			<p class="source-code">SELECT </p>
			<p class="source-code">  `classicmodels`.`employee`.`first_name`, </p>
			<p class="source-code">  `classicmodels`.`employee`.`last_name` </p>
			<p class="source-code">FROM `classicmodels`.`employee` </p>
			<p class="source-code">WHERE (`classicmodels`.`employee`.`salary` &gt; 5000 and</p>
			<p class="source-code">       `classicmodels`.`employee`.`job_title` = 'Sales Rep')</p>
			<p>In this case, <strong class="source-inline">ParamType.INLINED</strong> and <strong class="source-inline">ParamType.NAMED_OR_INLINED</strong> produce <a id="_idIndexMarker317"/>the same <a id="_idIndexMarker318"/>output – inlined plain values. Actually, <strong class="source-inline">ParamType.NAMED_OR_INLINED</strong> generates named parameter placeholders only for parameters that are named explicitly, otherwise, it inlines all unnamed parameters. You can see more examples in the code bundled with the book.</p>
			<p>Next, let's see how we can extract jOOQ parameters from the query as <strong class="source-inline">List&lt;Object&gt;</strong>.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Extracting jOOQ parameters from the query</h2>
			<p>Accessing <a id="_idIndexMarker319"/>all <a id="_idIndexMarker320"/>types of supported parameters of a query can be accomplished via <strong class="source-inline">Query.getParams()</strong>, while accessing a single parameter can be done by index via <strong class="source-inline">Query.getParam()</strong>, as in the following example, which uses indexed parameters (the same approach can be used for inlined parameters):</p>
			<pre class="source-code">ResultQuery query</pre>
			<pre class="source-code">  = ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">       .from(EMPLOYEE)</pre>
			<pre class="source-code">       .where(EMPLOYEE.SALARY.gt(5000))</pre>
			<pre class="source-code">       .and(EMPLOYEE.JOB_TITLE.eq("Sales Rep"));</pre>
			<pre class="source-code">// wrap the value, 5000</pre>
			<pre class="source-code">Param&lt;?&gt; p1 = query.getParam("1"); </pre>
			<pre class="source-code">// wrap the value, "Sales Rep"</pre>
			<pre class="source-code">Param&lt;?&gt; p2 = query.getParam("2"); </pre>
			<p>If we use<a id="_idIndexMarker321"/> named<a id="_idIndexMarker322"/> parameters, then those names can be used in place of indexes:</p>
			<pre class="source-code">ResultQuery query</pre>
			<pre class="source-code">  = ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">       .from(EMPLOYEE)</pre>
			<pre class="source-code">       .where(EMPLOYEE.SALARY.gt(</pre>
			<pre class="source-code">          param("employeeSalary", 5000)))</pre>
			<pre class="source-code">       .and(EMPLOYEE.JOB_TITLE.eq(</pre>
			<pre class="source-code">          param("employeeJobTitle", "Sales Rep")));</pre>
			<pre class="source-code">// wrap the value, 5000</pre>
			<pre class="source-code">Param&lt;?&gt; p1 = query.getParam("employeeSalary"); </pre>
			<pre class="source-code">// wrap the value, "Sales Rep"</pre>
			<pre class="source-code">Param&lt;?&gt; p2 = query.getParam("employeeJobTitle"); </pre>
			<p>As you'll see soon, parameters can be used to<a id="_idIndexMarker323"/> set <a id="_idIndexMarker324"/>new binding values. Next, let's see how we can extract indexed and named parameters.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Extracting binding values</h2>
			<p>Having a parameter, we can extract its <a id="_idIndexMarker325"/>underlying bind value via <strong class="source-inline">getValue()</strong>.</p>
			<p>But, extracting all the query bind values for indexed and named parameters without interacting with <strong class="source-inline">Param</strong> can be done via <strong class="source-inline">getBindValues()</strong>. This method returns <strong class="source-inline">List&lt;Object&gt;</strong> containing all the bind values of the query represented as a query or any of its subinterfaces such as <strong class="source-inline">ResultQuery</strong>, <strong class="source-inline">Select</strong>, and so on. Here is an example for indexed parameters:</p>
			<pre class="source-code">public void extractBindValuesIndexedParams() {</pre>
			<pre class="source-code">  ResultQuery query</pre>
			<pre class="source-code">    = ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">         .from(EMPLOYEE)</pre>
			<pre class="source-code">         .where(EMPLOYEE.SALARY.gt(5000))</pre>
			<pre class="source-code">         .and(EMPLOYEE.JOB_TITLE.eq("Sales Rep"));</pre>
			<pre class="source-code">  System.out.println("Bind values: " </pre>
			<pre class="source-code">    + query.getBindValues());</pre>
			<pre class="source-code">}</pre>
			<p>And, here is an example for named parameters:</p>
			<pre class="source-code">public void extractBindValuesNamedParams() {</pre>
			<pre class="source-code">  ResultQuery query = ctx.select(</pre>
			<pre class="source-code">            EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">    .from(EMPLOYEE)</pre>
			<pre class="source-code">    .where(EMPLOYEE.SALARY.gt(param("employeeSalary", 5000))</pre>
			<pre class="source-code">    .and(EMPLOYEE.JOB_TITLE</pre>
			<pre class="source-code">       .eq(param("employeeJobTitle", "Sales Rep"))));</pre>
			<pre class="source-code">  System.out.println("Bind values: " </pre>
			<pre class="source-code">    + query.getBindValues());</pre>
			<pre class="source-code">}</pre>
			<p>In both examples, the returned list will contain two bind values, [<em class="italic">5000</em> and <em class="italic">Sales Rep</em>]. For inline parameters, <strong class="source-inline">getBindValues()</strong> returns an empty list. This is happening because, unlike <strong class="source-inline">getParams()</strong>, which returns all types of supported parameters, <strong class="source-inline">getBindValues()</strong> returns only <a id="_idIndexMarker326"/>actual bind values that render an actual placeholder.</p>
			<p>We can use the extracted binding values in another SQL abstraction, such as <strong class="source-inline">JdbcTemplate</strong> or JPA. For instance, here is <strong class="source-inline">JdbcTemplate</strong>:</p>
			<pre class="source-code">Query query = ctx.select(...)</pre>
			<pre class="source-code">                 .from(PAYMENT)                </pre>
			<pre class="source-code">                 .where(...);       </pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">List&lt;DelayedPayment&gt; result = jdbcTemplate.query(query.getSQL(),</pre>
			<pre class="source-code">   query.getBindValues().toArray(), new BeanPropertyRowMapper</pre>
			<pre class="source-code">      (DelayedPayment.class));</pre>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Setting new bind values</h2>
			<p>We must start this section with the following<a id="_idIndexMarker327"/> important note.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Conforming to jOOQ documentation, starting with version 4.0, jOOQ plans to make the <strong class="source-inline">Param</strong> class immutable. Modifying <strong class="source-inline">Param</strong> values is strongly discouraged; therefore, use the information from this section carefully.</p>
			<p>Nevertheless, modifying bind values via <strong class="source-inline">Param</strong> was still possible when this book was written. For instance, the following example executes an SQL with an initial set of bind values, sets new bind values, and executes the query again. Setting new bind values is done<a id="_idIndexMarker328"/> via the deprecated <strong class="source-inline">setConverted()</strong> method:</p>
			<pre class="source-code">public void modifyingTheBindValueIndexedParam() {</pre>
			<pre class="source-code">  try ( ResultQuery query </pre>
			<pre class="source-code">    = ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">         .from(EMPLOYEE)</pre>
			<pre class="source-code">         .where(EMPLOYEE.SALARY.gt(5000))</pre>
			<pre class="source-code">         .and(EMPLOYEE.JOB_TITLE.eq("SalesRep"))</pre>
			<pre class="source-code">         .keepStatement(true)) {</pre>
			<pre class="source-code">     // lazily create a new PreparedStatement</pre>
			<pre class="source-code">     Result result1 = query.fetch();</pre>
			<pre class="source-code">     System.out.println("Result 1: " + result1);</pre>
			<pre class="source-code">     // set new bind values</pre>
			<pre class="source-code">     Param&lt;?&gt; p1 = query.getParam("1"); </pre>
			<pre class="source-code">     Param&lt;?&gt; p2 = query.getParam("2"); </pre>
			<pre class="source-code">     p1.setConverted(75000);</pre>
			<pre class="source-code">     p2.setConverted("VP Marketing");</pre>
			<pre class="source-code">     // re-use the previous PreparedStatement</pre>
			<pre class="source-code">     Result result2 = query.fetch();</pre>
			<pre class="source-code">     System.out.println("Result 2: " + result2);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">Query</strong> interface also allows for setting new bind values directly, without explicitly accessing the <strong class="source-inline">Param</strong> type via the <strong class="source-inline">bind()</strong> method as follows (if there are named parameters that refer to them via their names <a id="_idIndexMarker329"/>instead of indexes):</p>
			<pre class="source-code">public void modifyingTheBindValueIndexedParam() {</pre>
			<pre class="source-code">  try ( ResultQuery query </pre>
			<pre class="source-code">    = ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">         .from(EMPLOYEE)</pre>
			<pre class="source-code">         .where(EMPLOYEE.SALARY.gt(5000))</pre>
			<pre class="source-code">         .and(EMPLOYEE.JOB_TITLE.eq("Sales Rep"))</pre>
			<pre class="source-code">         .keepStatement(true)) {</pre>
			<pre class="source-code">    // lazily create a new PreparedStatement</pre>
			<pre class="source-code">    Result result1 = query.fetch();</pre>
			<pre class="source-code">    System.out.println("Result 1: " + result1);</pre>
			<pre class="source-code">    // set new bind values</pre>
			<pre class="source-code">    query.bind(1, 75000);</pre>
			<pre class="source-code">    query.bind(2, "VP Marketing");</pre>
			<pre class="source-code">    // re-use the previous PreparedStatement</pre>
			<pre class="source-code">    Result result2 = query.fetch();</pre>
			<pre class="source-code">    System.out.println("Result 2: " + result2);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Nevertheless, behind the scene, <strong class="source-inline">bind()</strong> works via <strong class="source-inline">Param.setConverted()</strong>.</p>
			<p>For convenience (but, not required), notice that both examples take advantage of the fact that a <strong class="source-inline">PreparedStatement</strong> can be reused with different bind values. First, we ask jOOQ to keep the statement open via <strong class="source-inline">keepStatement(true)</strong>. Second, the <strong class="source-inline">Query</strong> becomes like a resource that must be closed via <strong class="source-inline">Query.close()</strong> or in a <strong class="source-inline">try-with-resources</strong> statement.</p>
			<p>In the case of inline parameters, jOOQ will automatically close any underlying <strong class="source-inline">PreparedStatement</strong> in order for new bind values to have an effect; therefore, there is no use in keeping the statements<a id="_idIndexMarker330"/> open. The code is straightforward and is available in the code bundled with the book.</p>
			<h3>Named/unnamed parameters with no initial value</h3>
			<p>While in the <a id="_idIndexMarker331"/>previous examples the parameters have an initial value that was modified later, jOOQ also supports named/unnamed parameters with no initial value. </p>
			<p>If you need a named parameter without providing an initial value at its creation, then you may need one of the following <strong class="source-inline">DSL.param()</strong> flavors.</p>
			<p>Here is an example of using <strong class="source-inline">DSL.param(String name)</strong> that returns <strong class="source-inline">Param&lt;Object&gt;</strong>:</p>
			<pre class="source-code">Param&lt;Object&gt; phoneParam = DSL.param("phone");             </pre>
			<pre class="source-code">// set the parameter value</pre>
			<pre class="source-code">phoneParam.setValue("(26) 642-7555"); </pre>
			<pre class="source-code">ctx.selectFrom(CUSTOMER)</pre>
			<pre class="source-code">   .where(phoneParam.eq(CUSTOMER.PHONE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This is an<a id="_idIndexMarker332"/> example of creating a named parameter with a defined class type and no initial value via <strong class="source-inline">param(String name, Class&lt;T&gt; type)</strong>:</p>
			<pre class="source-code">Param&lt;String&gt; phoneParam = DSL.param("phone", String.class);   </pre>
			<pre class="source-code">phoneParam.setValue("(26) 642-7555");</pre>
			<p>This is how we create a named parameter with a defined data type and no initial value via <strong class="source-inline">param(String name, DataType&lt;T&gt; type)</strong>:</p>
			<pre class="source-code">Param&lt;String&gt; phoneParam</pre>
			<pre class="source-code">  = DSL.param("phone", SQLDataType.VARCHAR);     </pre>
			<pre class="source-code">phoneParam.setValue("(26) 642-7555");</pre>
			<p>And, we can create a named parameter with a defined type of another field and no initial value via <strong class="source-inline">param(String name, Field&lt;T&gt; type)</strong>:</p>
			<pre class="source-code">Param&lt;String&gt; phoneParam = DSL.param("phone", CUSTOMER.PHONE); </pre>
			<pre class="source-code">phoneParam.setValue("(26) 642-7555");</pre>
			<p>We can also keep a reference to a named parameter having an initial value (for instance, just to not lose the generic type, <strong class="source-inline">&lt;T&gt;</strong>):</p>
			<pre class="source-code">Param&lt;String&gt; phoneParam</pre>
			<pre class="source-code">  = DSL.param("phone", "(26) 642-7555");                </pre>
			<pre class="source-code">// changing the value is still possible</pre>
			<pre class="source-code">phoneParam.setValue("another_value");</pre>
			<p>In addition, jOOQ supports unnamed parameters without initial values but with a defined type. We can create such parameters via <strong class="source-inline">param(Class&lt;T&gt; class)</strong>, <strong class="source-inline">param(DataType&lt;T&gt; dataType)</strong>, and <strong class="source-inline">param(Field&lt;T&gt; field)</strong>. </p>
			<p>Moreover, we <a id="_idIndexMarker333"/>can create a parameter without a name and initial value with a generic type (<strong class="source-inline">Object</strong>/<strong class="source-inline">SQLDataType.OTHER</strong>) via <strong class="source-inline">param()</strong>. You can find examples in the code bundled with this book.</p>
			<p>Rendering unnamed parameters via <strong class="source-inline">Query</strong> with <strong class="source-inline">renderNamedParams()</strong> results in rendering the positions of parameters starting with 1, such as <strong class="source-inline">:1</strong>, <strong class="source-inline">:2</strong>, to <strong class="source-inline">:n</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">At the time of writing, jOOQ still supports modifying binding values, but <strong class="source-inline">setValue()</strong>and <strong class="source-inline">setConverted()</strong> are deprecated and probably removed starting with version 4.0 when jOOQ plans to make <strong class="source-inline">Param</strong> immutable.</p>
			<p class="callout">Also, pay attention to <strong class="source-inline">param()</strong> and <strong class="source-inline">param(String name)</strong>. As a rule of thumb, avoid these methods if you are using any of the following dialects: SQLDialect.DB2, DERBY, H2, HSQLDB, INGRES, and SYBASE. These dialects may have trouble inferring the type of the bind value. In such cases, prefer <strong class="source-inline">param()</strong> flavors that explicitly set a type of the bind value.</p>
			<p>All the examples from this section are available in the <em class="italic">BindingParameters</em> application.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Summary</h1>
			<p>This was a comprehensive chapter, which covered several fundamental aspects of jOOQ. So far, you have learned how to create <strong class="source-inline">DSLContext</strong>, how the jOOQ fluent API works, how to deal with jOOQ <strong class="source-inline">Result</strong> and <strong class="source-inline">Record</strong>, how to tackle edge cases of casting and coercing, and how to use bind values. As a rule of thumb, having these fundamentals under your tool belt is a major advantage that helps you to make the correct and optimal decisions and will be a great support in the next chapters.</p>
			<p>In the next chapter, we will discuss alternatives for building a DAO layer and/or evolving the jOOQ-generated DAO layer.</p>
		</div>
	</body></html>