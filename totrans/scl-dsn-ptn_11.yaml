- en: Applying What We Have Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already come a long way in Scala and in learning about the various design
    patterns in the language. Now, you should be at a stage where you are confident
    about when to use specific design patterns and when to avoid them. You saw some
    of the specifics and nice features of Scala that lead to its expressiveness. We
    went through the *Gang of Four* design patterns as well as some important functional
    programming concepts, such as monads. Throughout this book, we have tried to keep
    mathematical theories to a really basic level, and we have tried to avoid some
    scary Greek letters in formulas that are hard to understand for non-mathematicians,
    who may also want to use a functional programming language to its full potential.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this and the next chapter is to look at Scala from a more practical
    point of view. Knowing about a language and some design patterns is not always
    enough for a developer to see the whole picture and the potential of language
    possibilities. In this chapter, we will show how some of the concepts we presented
    before can be combined to write even more powerful and cleaner programs. We will
    look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The lens design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cake design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pimp my library design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stackable traits design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type class design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the sections in this chapter will show concepts that we haven't seen
    before. Others will combine some of the features of Scala and the design patterns
    we have learned so far in order to achieve something else. In all the cases, though,
    these concepts will deal with either a specific language feature or a limitation
    we have already seen, or help in achieving something commonly seen in actual software
    engineering projects.
  prefs: []
  type: TYPE_NORMAL
- en: The lens design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already mentioned that, in Scala, objects are immutable. You can, of
    course, make sure that a specific class has its fields declared as `vars`, but
    this is discouraged and considered bad practice. After all, immutability is good
    and we should try to aim for it.
  prefs: []
  type: TYPE_NORMAL
- en: The lens design pattern was created specifically for that purpose and allows
    us to overcome the immutability limitation and at the same time preserve the code's
    readability. In the following subsections, we will start with some code that doesn't
    use the lens design pattern and we will go step by step to show how to use it
    and how it improves our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Lens example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to show the lens design pattern in practice, we will create a class
    hierarchy that is usually seen in enterprise applications. Let''s imagine that
    we are building a system for a library that can be used by the employees of different
    companies. We might end up with the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The representation of these classes as a class diagram will look like the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9aa271bd-7711-4ae2-9d7f-8e63019437ee.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram is pretty clear and it doesn't need too much explanation. We basically
    have a `User` class that has other information about the user. Other classes contain
    others and so on. There is absolutely no challenge in using our classes if we
    don't want to modify anything. However, as soon as we go on to modify something,
    it becomes complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Without the lens design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we will see how to use our classes if we want to modify
    some of their properties.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable and verbose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without getting into too much detail, let''s see what an example application
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding application creates one user for our library and then decides
    to change the company country code, as we initially created it in lowercase characters.
    The output of the application looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6b7b500-1d33-4ee4-bc5b-e7132d736473.png)'
  prefs: []
  type: TYPE_IMG
- en: Our application works correctly but as you can see in the highlighted code,
    it is extremely verbose and long and making a mistake is really easy. We don't
    want to write code like this, as it will be hard to maintain and change in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Using mutable properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thought that might come into your head is to change the classes and
    make the properties variable. Here is how our case classes would change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, using these classes will be as easy as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we could have also changed the country code using
    this—`uk.code = uk.code.toUpperCase`. This would work, because we use a reference
    of the country in our `User` object.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example will produce absolutely the same output. However, here
    we broke the rule that everything in Scala is immutable. This might not look like
    a big deal in the current example but, in reality, it goes against the Scala principles.
    This is considered bad code and we should try to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: With the lens design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous subsection, we saw how complicated something such as changing
    one property of a nested class can be. We are going after nice, clean, and correct
    code, and we also don't want to go against the principles of Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, cases such as the one we just mentioned previously are exactly
    the reason for the creation of the lens design pattern. In this chapter, we will
    see the Scalaz library for the first time in this book. It defines many functional
    programming abstractions for us, and we can easily use them straight away without
    worrying whether they follow some specific set of rules or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what are lenses anyway? We won''t get too deep into the theoretical aspects
    here, as this is out of the scope of this book. It is enough for us to know what
    they are used for, and if you want to know more, there is plenty of material on
    lenses, store, and comonads online, which can make these concepts clearer. A simple
    way to represent a lens is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This basically lets us get and set different properties of an object of the
    `X` type. This means that, in our case, we will have to define different lenses
    for the different properties we want to set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a companion object to our `User` class. There are a lot
    of things going on here, so we will explain this. You can see the calls to `Lens.lensu[A,
    B]`. They create actual lenses so that for an object of the `A` type, the calls
    get and set a value of the `B` type. There is nothing special about them really,
    and they simply look like boilerplate code. The interesting part here is the highlighted
    code—it uses the `>=>` operator, which is an alias for `andThen`. This allows
    us to compose lenses and this is exactly what we will do. We will define a composition
    that allows us to go from a `User` object through the chain and set the country
    code of the country of the `Company`. We could have used `compose` as well, which
    has an alias of `<=<` because `andThen` internally calls `compose` and it would
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The latter, however, is not as intuitive as the former.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our lens is now very easy. We need to make sure to import our companion
    object and then we can simply use the following code where we change the country
    code to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You saw how the lens design pattern allows us to cleanly set properties of our
    case class without breaking the immutability rule. We simply need to define the
    right lenses and then use them.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the boilerplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding example showed quite a lot of boilerplate code. It is not complicated,
    but it requires us to write quite a lot of extra stuff, and then any refactoring
    will likely affect these manually defined lenses. There has been an effort in
    creating libraries that automatically generate lenses for all user-defined classes
    that can then be used easily. One example of a library that seems to be maintained
    well is Monocle: [https://github.com/julien-truffaut/Monocle](http://julien-truffaut.github.io/Monocle/).
    It is well-documented and can be used so that we don''t have to write any boilerplate
    code. It has its limitations though, and users should make sure they are okay
    with what the library provides. It also provides other optics concepts that could
    be useful.'
  prefs: []
  type: TYPE_NORMAL
- en: The cake design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actual software projects will usually combine multiple components that will
    have to be used together. Most of the time, these components will depend on others,
    which in turn depend on other components, and so on. This makes creating objects
    in an application hard because we also need to create the objects they depend
    on and so on. This is where dependency injection comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what exactly is dependency injection? It turns out to be something really
    simple—every single class that has an object as a parameter in their constructor is actually
    an example of a dependency injection. The reason is that the dependency is injected
    into the class rather than instantiated inside it. Developers should actually
    try to use this kind of approach instead of creating objects inside a constructor.
    There are many reasons for this, but one of the most important ones is the fact
    that components can become tightly coupled and practically untestable.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection, however, could degrade the code quality if implemented
    using constructor parameters. This would make constructors take a large number
    of parameters and, as a consequence, it will become really difficult to use the
    constructors. Of course, using the factory design pattern could help, but there
    are other approaches that are much more common in enterprise applications. In
    the following subsections, we will briefly mention the alternatives and show how,
    using only the features of Scala, we can easily implement dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection libraries and Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers with a background in Java might be already familiar with some
    of the famous dependency injection libraries. Some popular examples are Spring
    ([https://spring.io/](https://spring.io/)) and Guice ([https://github.com/google/guice](https://github.com/google/guice)).
    In Spring, dependencies are usually managed in an XML file, where they are described,
    and the file tells the framework how to create instances and where to inject the
    objects into classes. Some of the terms used are beans.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Guice uses annotations that are then evaluated and replaced
    with the right objects. These are quite popular frameworks and they can also be
    used in Scala pretty easily. Those of you familiar with Play Framework will know
    that it uses exactly Guice to wire things up.
  prefs: []
  type: TYPE_NORMAL
- en: Using external libraries, however, adds dependencies to projects, increases
    the jar size, and so on. Nowadays, this is not really an issue. Scala, however,
    is quite an expressive language, as we have already seen, and we can implement
    dependency injection natively without any extra libraries. We will see how this
    can be done in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to implement dependency injection in Scala, we can use a special design
    pattern. It is called the cake design pattern. Without getting into too much detail,
    let's create an application. The application that we are creating will need to
    have a bunch of classes that depend on each other so that we can demonstrate how
    injection works.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create an application that can read from a database data about people,
    classes, and who has signed up to which classes. We will have a user service which
    will implement some simple business logic with the data, and a service that will
    access the data. It will be a small application, but it will clearly show how
    dependency injection works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the simple stuff. We will need to have a model for the objects
    that we will be representing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have two classes that will be used in our application.
    There is nothing special about them, so let's go further.
  prefs: []
  type: TYPE_NORMAL
- en: We said that we want our application to be able to read data from a database.
    There are different databases—MySQL, PostgreSQL, Oracle, and so on. If we want
    to use any of these, however, you will need to install some extra software that
    will require extra knowledge and will be tricky. Luckily, there is an in-memory
    database engine called H2 ([https://www.h2database.com/html/main.html](https://www.h2database.com/html/main.html))
    that we can use instead. Using this is as simple as adding a dependency to our
    `pom.xml` or `build.sbt` file and then using the database. We will see how this
    all works really soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, let''s make things more interesting and make sure that a different database
    engine could easily be plugged in. For this to work, we will need some kind of
    interface that will be implemented by different database services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used a trait and will extend this trait whenever we
    want to create an H2 database service, or an Oracle database service, and so on.
    Everything in the preceding code seems to be quite straightforward and doesn't
    need additional explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The order of the vals
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, listing the order of the variable definitions matters.
    This means that if we had declared `ds` first and then everything else, we would
    have faced a `NullPointerException`. This can be easily overcome using a `lazy
    val` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we will be implementing a service for the H2 database engine,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The actual implementation of the database service is in the nested `H2DatabaseService`
    class. Nothing special about it. But what about the `DatabaseComponent` trait?
    It is simple—we want to have a database component that we will mix in our classes
    and it will provide functionality to connect to the databases. The `databaseService`
    variable is left to be abstract and will have to be implemented when the component
    is mixed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a database component by itself is not useful at all. We will need to
    use it in some way. Let''s create another component, which creates our database
    and its tables and fills them up with data. Obviously, it will depend on the database
    component mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now this is a lot of code! There is nothing scary about it, though. Let's go
    through it and try to understand it. First, we followed the same pattern as before—we
    created a component trait with an abstract variable, in this case, called `migrationService`.
    We don't need to have multiple different migrations, so we simply created a class
    inside the component trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part here is the first line that we highlighted—`this: DatabaseComponent
    =>`. What does this mean? Luckily, we have already seen this syntax before in
    the book—it is nothing more than a **self type annotation**. What it does, however,
    is really interesting—it tells the compiler that whenever we mix in the `MigrationComponent`,
    we also need to mix in the `DatabaseComponent`. And this is exactly the piece
    of the puzzle that tells Scala that the migration component will depend on the
    database component. As a consequence, we are now able to run the code in the second
    highlighted row. And if we look carefully, it actually accesses `databaseService`,
    which is a part of `DatabaseComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we''ve skipped most of the other implementations, but
    they are straightforward and have nothing to do with the cake design pattern.
    Let''s see two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is just database code that creates a table and inserts data
    into it. The rest of the methods in the class are similar, but they differ in
    the table definitions and what is inserted into them. The full code can be seen
    in the examples that are provided with this book. Here, we will just extract the
    statements that create the database model so that you can have an idea of how
    the database is structured and what we can do with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our migration service in the preceding code simply creates tables in a database
    and inserts some information into them so that we can then use the service. We
    saw that this migration service depends on the database service, and we also saw
    how this dependency is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just by having these classes, our application will not be that useful. We need
    to be able to interact with the data and do something interesting with it. We
    can say that the migration component just makes sure we have the data. In real-world
    scenarios, we might already have a prepopulated database and we will need to work
    with what is inside this database. Whatever the case, we will need to have a data
    access layer to retrieve what we need. We have created the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This `DaoComponent` is similar to the `DatabaseComponent` in terms of its dependency.
    It just defines queries to retrieve data. We've skipped the simple `select` statements.
    It could, of course, define even more methods for insertions, updates, and deletes.
    It nicely hides the complexity of dealing with data from a database, and now we
    can actually create something useful in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is commonly seen in enterprise applications is different services that
    could access data in a database, perform some business logic on it, return results,
    and write it back into the database. We have created a simple service that deals
    with users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `UserComponent`, we follow the same pattern we already know, but this
    time our dependency is on `DaoComponent`. We can then have other components that
    depend on this component and on others as well. We haven''t shown any example
    here in which a component depends on multiple ones at the same time, but this
    is not hard to do at all. We just use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can have dependencies on as many components as we want, and this is where
    the cake design pattern starts to shine and shows its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring it all up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding code, we saw a bunch of components with their implementations
    that declare dependencies to others. We still haven''t seen how everything will
    be used together. By defining our components as traits, we can just mix them in
    together and they will be available to us. This is how we have done it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `ApplicationComponentRegistry` can be a class as
    well, instead of a Scala object. It mixes the components in and, since each of
    them had an abstract variable, it forces us to assign actual values to them. The
    nicest part of this is that, if we know that our application will need a `UserComponent`,
    the compiler will tell us that we also need a `DaoComponent`, and so on, down
    the chain. The compiler will basically make sure that we have the entire dependency
    chain available during compilation, and it won't let us run our application until
    we have done things properly. This is extremely useful. In other libraries, this
    is not the case and we often find out that our dependency graph is not built properly
    at runtime. Also, this way of wiring things up makes sure we have only one instance
    of each.
  prefs: []
  type: TYPE_NORMAL
- en: If we had used a class instead of an object for the `ApplicationComponentRegistry`,
    the statement about having only one instance of each component doesn't automatically
    become true. We need to take extra care, otherwise each instance of the registry
    might have different instances of the components.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have created our component registry, we can easily use everything
    in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we simply imported everything from the registry and
    then we used it. The output of this application is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/222041ae-860d-4500-9e09-cac4f3ac0dc7.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how easy it is to use the cake design pattern in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an important part of every application. We need to make sure that
    the changes we add do not negatively affect the other parts of our system and
    that every unit behaves correctly. Testing with the cake design pattern is also
    really simple to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cake design pattern allows us to easily create different environments.
    This is why we can create the following test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code simply contains every component and mocks every service
    with Mockito. Let''s write a test class for our `UserComponent` using our new
    test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we override the `userService` to be an actual implementation
    and then we use it for the tests. We use Mockito to simulate our database access
    and then we simply write a test that checks whether things work correctly. We
    have decided to simulate our database access. However, in some cases, people have
    test databases or use H2 for tests. Using our test environment, we have the flexibility
    to do whatever we decide.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests we wrote previously can be achieved with the `mvn clean test`
    or `sbt test` command.
  prefs: []
  type: TYPE_NORMAL
- en: Our test environment allows us to enable as many components in our tests as
    we want. We could simply override multiple such components in our test classes.
  prefs: []
  type: TYPE_NORMAL
- en: Other dependency injection alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing about the cake design pattern that we presented previously is the
    amount of boilerplate code that we need to write in order to wire everything up
    properly. In large applications, this could become an issue, so there are other
    alternatives that can be used to deal with this. We will briefly discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: Implicits for dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using implicits is something that removes the requirement of having the component
    traits and self type annotations of the cake design pattern. Implicits, however,
    can quickly complicate method definitions because every method has to declare
    implicit parameters to whatever components it depends on.
  prefs: []
  type: TYPE_NORMAL
- en: Reader monad for dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Reader` monad is available in the Scalaz library. The way dependency injection
    works with it is that we make each method return a function wrapped in the `Reader`
    monad, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we only expose `getAverageAgeOfUsersInClass(className:
    String)` to the users. Typically, for monads, computation here is built, but nothing
    is done until the last moment. We can build complex operations, use `map`, `flatMap`,
    and for comprehensions. We defer injecting the dependencies until the last moment,
    where we can simply call `apply` on a reader with the actual component or components
    it needs. The preceding explanation might sound a bit abstract, but things are
    pretty simple and can be seen in many places online.'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, this method is used together with the cake design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The pimp my library design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our daily job as developers, we often use different libraries. They, however,
    are usually made to be generic and allow many people to use them, so sometimes
    we need to do something extra that is specific to our use case in order to make
    things work properly. The fact that we cannot really modify the original library
    code means that we have to do something different. We have already looked at the
    decorator and the adapter design patterns. Well, pimp my library achieves something
    similar, but it does this in the Scala way and some of the extra work is given
    to the compiler to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: The pimp my library design pattern is really similar to extension methods in
    C#. We will see some examples in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using pimp my library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pimp my library design pattern is really easy to use. Let''s see an example
    in which we want to add some useful methods to the standard `String` class. Of
    course, we cannot modify its code, so we need to do something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a package object. It gives us the convenience
    to not do anything extra in order to be able to access its members from the classes
    in the same package in Scala. It can be a simple object, but then we will have
    to `import ObjectName._` in order to gain access to the members.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding object is just a detail and is not related to the design pattern.
    The pimp my library code is the internal class. There are a few important things
    about this:'
  prefs: []
  type: TYPE_NORMAL
- en: It is implicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It extends `AnyVal`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These features allow us to write the following application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We basically added an extension method to the standard string that checks whether
    the entire string is in uppercase or not. The only thing we need to do is make
    sure that the implicit class is available in the scope where we want to use the
    methods defined by it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding application is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cdb1e83-bc57-468a-8b3f-aa8428a5d2f3.png)'
  prefs: []
  type: TYPE_IMG
- en: In our example, we didn't have to write code that wraps strings in our extension
    class. Our code shows the type as a normal string; however, we can just do extra
    things with it. Additionally, the decorator design pattern will suffer in the
    cases where the class we are trying to decorate is final. Here, there is no issue.
    Again, all the magic happens because we have an implicit class, and the Scala
    compiler automatically figures out that it can wrap and unwrap a string depending
    on the methods we call on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, of course, add more methods to the `StringExtensions` class and they
    will be available to all the strings where the implicit class is available. We
    can also add other classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is capable of saving an entire collection of the `Person`
    type to a database (even though, in the example, we just print the collection
    to the standard output). For completeness, our `Person` model class is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the new extension is then similar to the earlier extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example will produce the expected result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56be3880-216f-49c3-9aba-80be954171a9.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also apply the pimp my library design pattern to our custom classes if
    we need to and if it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Pimp my library in real life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from the preceding section, the pimp my library design pattern
    is extremely easy to use. This is seen quite often, especially when a decorator
    or adapter design pattern is needed. We can, of course, figure out ways to deal
    with issues without this library design but, in reality, it helps us to avoid
    boilerplate code. It also really helps in making our code more readable. Last
    but not least, it can be used to simplify the use of specific libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The stackable traits design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are sometimes cases where we want to be able to provide different implementations
    for a method of a class. We might not even know all the possibilities that could
    exist at the moment of writing, but we can add them later and combine them or
    we can allow someone else to do this instead. This is another use case of the
    decorator design pattern, which for this purpose could be implemented with the
    stackable traits design pattern. We have already seen this pattern before in this
    book in [Chapter 7](263a83d5-a022-4678-9dcc-030c898373d6.xhtml), *Structural Design
    Patterns*, but we used it to read data, which adds a really important catch there.
    We will see another example here, which will make sure everything is completely
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: Using stackable traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stackable traits design pattern is based on mixin composition—something
    we became familiar with in the early chapters of this book. We usually have an
    abstract class or a trait that defines an interface, a base implementation, and
    traits that extend the abstract class to stack modifications on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, let''s implement the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db03b0a7-ae6c-431a-9ab9-cde8c7c50ef3.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is of a really simple application. We have a base `StringWriter`
    class, which has a basic implementation (`BasicStringWriter`) that just returns
    a message containing the string. On the right-hand side, we have traits that can
    add stackable modifications to the `StringWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is of the abstract class and the basic implementation. There
    is nothing special about these. Now, let''s look at the stackable traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The whole magic in the preceding code happens because of the `abstract override`
    modifier on the methods. It allows us to call `super` on an abstract method of
    the `super` class. This would otherwise fail, but here it just requires us to
    mix the traits in with a class or a trait that has `write` implemented. If we
    don't, we won't be able to compile our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example use of our traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we simply stack modifications together using mixin composition.
    In the current example, they are just illustrations that don''t do anything smart,
    but, in reality, we can have variations that will provide powerful modifications.
    The following figure shows the output of our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7da9e5ef-1e63-44bc-b81b-571e6a49a340.png)'
  prefs: []
  type: TYPE_IMG
- en: The modifications we have in our code would depend on the order in which they
    are applied. For example, if we put everything in uppercase first, then capitalization
    will not have any effect. Let's see the code and the relevant output and try to
    figure out how the modifications are applied. If you look at all the examples
    and outputs, you will see that the modifications are applied *from right to left*
    in the order we have mixed the traits in.
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at the example in [Chapter 7](263a83d5-a022-4678-9dcc-030c898373d6.xhtml),
    *Structural Design Patterns*, however, we will see that the actual modifications
    are reversed. The reason for this is that each trait does `super.readLines` and
    then maps. Well, this actually means that we will be pushing calls on the stack
    until we get to the basic implementation, and then we will be going back to do
    all the mappings. So in [Chapter 7](263a83d5-a022-4678-9dcc-030c898373d6.xhtml),
    *Structural Design Patterns*, the modifications are also applied from right to
    left, but because we just get the output and don't pass anything on, things are
    applied in left to right order.
  prefs: []
  type: TYPE_NORMAL
- en: The stackable traits order of execution
  prefs: []
  type: TYPE_NORMAL
- en: Stackable traits are always executed from the right mixin to the left. Sometimes,
    however, if we only get output and it doesn't depend on what is passed to the
    method, we simply end up with method calls on a stack, which then get evaluated
    and it will appear as if things are applied from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the preceding explanation is really important for using stackable
    traits. It actually perfectly matches what we saw about linearization in [Chapter
    2](39295d70-43a1-4c6c-b019-2723f048bf96.xhtml), *Traits and Mixin Compositions*.
  prefs: []
  type: TYPE_NORMAL
- en: The type class design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of times when we write software, we encounter similarities between different
    implementations. An important principle of good code design is to avoid repetition
    and it is known as **do not repeat yourself** (**DRY**). There are multiple ways
    that help us to avoid repetitions—inheritance, generics, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One way to make sure we do not repeat ourselves is through type classes.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of type classes is to define some behavior in terms of operations
    that a type must support in order to be considered a member of the type class.
  prefs: []
  type: TYPE_NORMAL
- en: A concrete example would be `Numeric`. We can say that it is a type class and
    defines the operations—addition, subtraction, multiplication, and so on, for the
    `Int`, `Double`, and such other classes. We have actually already encountered
    type classes earlier in this book in [Chapter 4](31807099-24ea-49c2-8dc1-8dcc978987d7.xhtml),
    *Abstract and Self Types*. Type classes are the ones that allow us to implement
    ad hoc polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Type class example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see an actual example that is also somehow useful to developers in this
    case. In machine learning, developers tend to use some statistical functions quite
    often in their work. There are statistical libraries and, if we try them out,
    we will see that these functions exist for different numeric types—`Int`, `Double`,
    and so on. Now, we could come up with something simple and implement these functions
    for all the numeric types we think about. This, however, is not feasible and makes
    our library impossible to extend. Moreover, statistical functions have the same
    definitions, no matter the type, so we don't want to repeat our code as many times
    as there are numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s first define our type class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding is just a trait that defines some operations that will require
    numbers to support it.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric in Scala
  prefs: []
  type: TYPE_NORMAL
- en: The Scala programming language has a `Numeric` trait that defines many of the
    previously mentioned operations.
  prefs: []
  type: TYPE_NORMAL
- en: If we had used the `Numeric` trait in the preceding code, we could have saved
    ourselves from some code writing, but for the sake of this example, let's use
    our custom type.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have defined a trait for the numbers, we can now write our library
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a lot of code in the preceding example. Defining the functions
    is pretty straightforward. Let's, however, explain the role of the `implicitly`
    keyword. It uses the so-called **context bounds** from Scala, and it is the crucial
    part that allows us to implement the type class design pattern. In order to use
    the preceding methods, it requires a type class member of `Number` for the `T`
    type to be implicitly available. As you can see in the comment above `mean`, we
    can alternatively have an implicit parameter to the methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write some example code that will use the previously mentioned
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling the preceding code right now will not be successful and we will see
    error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that we have not yet defined any implicitly available
    `Number` members for `Int` and `Double`. Let''s define them in the companion object
    for the `Number` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, our code will compile successfully. But how did this whole thing work when
    we had just defined these implicits in a companion object in a completely different
    file? First of all, our nested objects are implicit, and second of all, they are
    available in the companion object.
  prefs: []
  type: TYPE_NORMAL
- en: Defining your default type class members in the companion object
  prefs: []
  type: TYPE_NORMAL
- en: The companion object of the implicit type class parameter is the last place
    the compiler looks for implicit values. This means that nothing extra has to be
    done and users can easily override our implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run our code easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4c8d624-3ba1-4544-90eb-7f0cafa4931b.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, we can put our implicit values anywhere we want. If they are not
    in the companion object, however, we will have to do extra imports in order to
    make them available.
  prefs: []
  type: TYPE_NORMAL
- en: Type class design pattern alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are, of course, alternatives to the type class design pattern. We can
    use the adapter design pattern. It will, however, make it much harder to read
    our code because things will be wrapped all the time and they will be much more
    verbose. The type class design pattern takes advantage of the nice features of
    the Scala type system.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at our preceding code, we can also see that there is a fair bit of boilerplate
    code. This can become problematic in bigger projects, or when we try to define
    more complex type classes. A library that was written specifically to deal with
    these issues can be found at [https://github.com/mpilquist/simulacrum/](https://github.com/mpilquist/simulacrum/).
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing efficient code is an important part of software engineering. A lot of
    times, we will see cases where an expression is expensive to evaluate due to different
    possible reasons—database access, complex calculations, and so on. There are cases
    where we might even be able to exit the application without even evaluating these
    expensive expressions. This is where lazy evaluation becomes helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation makes sure that an expression is evaluated only once when it
    is actually needed.
  prefs: []
  type: TYPE_NORMAL
- en: Scala supports lazy evaluation in a couple of flavors—lazy variables and by-name
    parameters. We have already seen both in this book the former we saw when we looked
    at creational design patterns in [Chapter 6](9971ad44-53fa-4b20-a3a3-4417ffeac78f.xhtml),
    *Creational Design Patterns,* and more specifically, lazy initialization. We saw
    the latter in a few places, but we encountered it for the first time in [Chapter
    8](706552cf-27de-4b8b-b5a3-e6e22412056d.xhtml), *Behavioral Design Patterns -
    Part 1*, where we showed you how to implement the command design pattern in a
    way that is closer to how Scala does it.
  prefs: []
  type: TYPE_NORMAL
- en: There is an important difference between lazy variables and by-name parameters.
    The lazy variables will be calculated only once, whereas the by-name parameters
    will be calculated every time they are referred to in a method. There is a really
    simple trick we will show here that will fix this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating by-name parameters only once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine that we have an application that takes data about people from
    a database. The reading operation is something that is expensive, and it is a
    good candidate for lazy evaluation. For this example, we will simply simulate
    reading from the database. First of all, our model will be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a companion object that will have a method that simulates
    getting the data about people from a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code simply makes the current thread sleep for three seconds
    and returns a static result. Calling the `getFromDatabase` method multiple times
    will make our application slow, so we should consider lazy evaluation. Now, let''s
    add the following method to our companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we simply printed the list of data about people twice and we
    accessed the by-name parameter twice. This is bad because it will evaluate the
    function twice and we will have to wait for twice the amount of time. Let''s write
    another version that will fix this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This time, we will assign the by-name parameter to a `lazy val` and then use
    it instead. This will only evaluate the by-name parameter once and, again, if
    we end up not using it, it will not be evaluated at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this application, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/347d0943-321f-48a9-8fef-e09c7287b163.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the program output, the first version of our method retrieves
    the by-name parameter value twice, while the second version does it only once.
    The fact that we use a `lazy val` inside the second method also has the possibility
    of not evaluating our expensive expression at all if we don't actually use it.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative lazy evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another way to implement lazy evaluations in Scala. It is through using
    anonymous functions and taking advantage of the fact that functions are a part
    of unifications in Scala and we can also pass them as parameters easily. This
    is done as follows—a value is represented as `() => value` rather than just the
    value itself. It is somewhat pointless, though, especially because we already
    have two mechanisms that can do quite a lot. Using anonymous functions for a lazy
    evaluation is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a function to a method can also be considered as a way of lazily evaluating
    some data. This, however, can be useful and should not be confused with what we
    just said about anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mathematics and, as a consequence, in programming, there are functions that
    are not defined for all possible inputs. A simple example is the square root function—it
    will only work for real numbers if they are non-negative. In this section, we
    will look at partial functions and how we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions are not partially applied functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There seems to be some confusion around what partial functions are and what
    they are not. It is important for you to understand that these functions are not
    partially applied functions. Partially applied functions are simply functions
    that might take multiple parameters and we''ve specified some of them and then
    they return functions with fewer parameters that we can specify. There is another
    term—**curried functions**—that is related to partially applied functions. In
    terms of functionality, they provide the same functionality. Let''s see a quick
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have different definitions of greater and lesser
    or equal functions. First, we have them as normal functions. The second version
    is with multiple parameter lists and the last one is an actual curried function.
    Here is how to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The way we use partially applied functions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This returns a function of `Int` to `Boolean`, which we can use to check whether
    the parameter is greater or equal to the `MIN` value. This is a partially applied
    function.
  prefs: []
  type: TYPE_NORMAL
- en: For the curried versions of these functions, as you can see, we have switched
    the parameters. The reason is that curried functions are simply a chain of single
    parameter functions and the parameters are applied in the order we see them. The
    line `greaterOrEqualCurried(MIN) _` partially applies the function and returns
    a curried function that we can use similarly to above. As you can see in the code
    comments, we can actually convert any multiple parameter function into a curried
    function. The reason for `greaterOrEqual` and `lessOrEqual` not working in our
    example is that the parameters are applied in the order they are seen. Finally,
    we have a pure curried version in `greaterOrEqualCurriedVal` and `lessOrEqualCurriedVal`.
    This type of function is returned when we partially apply a function with multiple
    parameter lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding example, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b16ef7c8-238b-46e3-b9a9-48ce1f2df8bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Choosing whether to use partially applied functions or curried functions depends
    on many things, including personal preference. In both cases, we can achieve the
    same objectives with a slightly different syntax. As you can see, we can go from
    a normal to a curried function using `.curried`. We can also go the other way
    round using the `Function.uncurried` call and passing the function to it. This
    call makes sense when the curried function has more than one function in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Using partially applied functions for dependency injection
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way partially applied functions and curried functions work, we
    can use them for dependency injection. We can basically apply the dependencies
    to a function and then get another function, which we can use afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Partially defined functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already said that partial functions are only defined for specific subsets
    of all possible values the functions can get. This is quite useful, as we can
    basically perform `filter` and `map` at once. This means fewer CPU cycles and
    more readable code. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a partial function from `Int` to `Double`. It checks whether a number
    is non-negative and returns the square root of that number. This partial function
    can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `collect` method that takes a partial function. We''ve also
    shown one of the methods that partial functions have—`isDefinedAt`, whose name
    tells us exactly what it does. The output of our program will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/872cb315-f536-4e25-bfb6-485a1951abcb.png)'
  prefs: []
  type: TYPE_IMG
- en: Our partial function filtered out the negative numbers and returned the square
    roots of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial functions can also be used to chain operations or do something different
    if one operation is not possible. They have the `orElse`, `andThen`, `runWith`,
    and such other methods. It is clear from their names what the first two methods
    do. The third method uses the results of the partially applied function and performs
    an action that could potentially cause side effects. Let''s see an example of
    `orElse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we define another partial function that squares negative numbers. Then,
    we can add some extra code to our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38030e60-b8e4-4760-8624-1dec1a8e53f4.png)'
  prefs: []
  type: TYPE_IMG
- en: We will basically square the negative numbers and square root the positive ones.
    It might not make much sense in terms of the operations we do in this example,
    but it shows how we can chain partial functions. If, after combining the different
    partial functions, we end up covering the whole possible input space, then it
    might make more sense to use pattern matching and a normal function. If we don't
    match all the possible values, however, we can get runtime exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already saw implicits in a few places in this book. We used them in the type
    class design pattern and the pimp my library design pattern, and we also mentioned
    that they can be used for dependency injection. Implicits are also used for conversions
    from one type to another silently.
  prefs: []
  type: TYPE_NORMAL
- en: They are nothing more than some objects, values, or methods that the compiler
    knows about and injects for us into methods or places that need them. What we
    need to make sure is to make these implicits available to the scope of the methods
    that will use them.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already mentioned that implicits can be used for silent conversions.
    Sometimes, it might be useful to be able to assign a `Double` to an `Int` and
    not get an error. Other times, we might want to wrap an object of one type into
    another and take advantage of the methods the new one provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code listing, we have a package object that defines a method,
    which converts a `Double` to `Int`. This will allow us to write and successfully
    compile the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We don't have to do anything extra, as long as the `ImplicitExamples` object
    is in the same package as our package object. Another alternative would be to
    define our implicit conversions inside an object and import the object in the
    scope we will need it in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even wrap types in new objects. There are some examples in the `LowPriorityImplicits`
    class that is part of Scala, which can convert strings to sequences and so on.
    Now, let''s add an implicit conversion that will convert a list of `Int` to a
    `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use our implicit conversion in order to print a list of ASCII character
    codes as a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this example will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45d6f69e-a5de-431e-bb58-973850dcfa49.png)'
  prefs: []
  type: TYPE_IMG
- en: There are a lot of useful things which we might need implicit conversions for.
    They could help in separating our code nicely, but we should be careful not to
    overuse them because debugging could be problematic and the code's readability
    might suffer.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection using implicits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we showed dependency injection using the cake design pattern, we also
    mentioned that it is possible to achieve it using implicits. The idea is that
    services are created in one place and then we can write methods that implicitly
    require what the services need. By now, you should have acquired enough knowledge
    to be able to get to the right solution alone, so here we will just show a subset
    of the big example we had previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have a model defined, we can create a `DatabaseService` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Our database service does not depend on anything. It simply simulates that
    it reads something from a database. Now, let''s create a `UserService`, which
    will depend on the `DatabaseService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the signature of the only method the user service provides,
    it requires an instance of `DatabaseService` to be implicitly available. We can
    also explicitly pass one and override the one we have for the purpose of testing.
    Now that we have these services, we can wire them up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We have chosen to use a package object, but any object or class is fine, as
    long as we can import it wherever we need the object. Now, the use of our application
    is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1aa5069e-846c-494f-9179-4787d6ec14a3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, now we have used less boilerplate code than in the cake design
    pattern. A drawback of this approach is the method signatures, which can get more
    complex when we have more dependencies. In real-world applications, there could
    be a huge amount of dependencies, and also code readability will be affected due
    to the implicit variables. A possible solution to this could be wrapping dependencies
    in objects and implicitly passing them instead. In the end, it's mostly a matter
    of personal preference as to which dependency injection strategy will be used,
    as the same things can be achieved with both.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with implicit dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing with implicit dependency injection is similar to testing with the cake
    design pattern. We can have a new object that creates mocks of the services and
    then makes them available to the test classes. When we want to use a concrete
    implementation of a service, we can just override it. We could also pass a dependency
    explicitly here.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A significant part of the work of a developer is to minimize the amount of code
    duplication. There are multiple different approaches to do this, including inheritance,
    abstraction, generics, type classes, and so on. There are cases, however, where
    strongly typed languages will require some extra work in order to minimize some
    of the duplication. Let's imagine that we have a method that can read and print
    the contents of a file. If we have two different libraries that allow us to read
    a file, in order to use our method, we will have to make sure the methods that
    read the file somehow become the same type. One way would be by wrapping them
    in a class that implements a specific interface. Provided that in both the libraries
    the read method has the same signature, which could easily happen, Scala can use
    duck typing instead, and this way it will minimize the extra work we will have
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing is a term that comes from dynamic languages and it allows us to
    treat different types of objects in a similar manner based on a common method
    they have.
  prefs: []
  type: TYPE_NORMAL
- en: Another name for duck typing is **structural typing**.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything becomes clearer with an example. Let''s imagine that we want to
    have a method which can take a parser and print every word that the parser detects.
    Our parsers will have a method with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: A good way of doing this would be to have a common interface and make all the
    parsers implement it. However, let's set a condition that we cannot do this. The
    parsers could be coming from two different libraries where we cannot modify or
    connect in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have defined two different parser implementations for this example. The
    first one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This parser makes use of the `StringTokenizer` class and returns an array of
    all the words separated by spaces. Another implementation that does exactly the
    same is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just split the sentence using a regular expression for space.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, both the classes have a parse method with the same signature,
    but they have no connection with each other. We, however, want to be able to use
    them in a method and avoid code duplication. Here is how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we passed both the parsers to the `printSentenceParts`
    method and everything compiles and works fine. The reason things work is because
    of duck typing and this can be seen in the highlighted part of our example. The
    output of our application is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ce57804-9bc9-4b25-9adc-03c7968c93c3.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use duck typing for requiring even more methods to be available for an
    object by just expanding the parameter signature.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from the preceding code, duck typing saves us from some extra
    code writing and the need to define common interfaces. Other ways to achieve the
    same would involve creating wrappers, which implement a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: When to use duck typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overusing duck typing can negatively affect code quality and application performance.
    You should not avoid creating common interfaces in favor of duck typing. It should
    be really only used in cases when we cannot implement a common interface between
    different types. The argument about limiting the use of duck typing is further
    enhanced by the fact that, under the hood, they use reflection, which is slower
    and negatively impacts performance.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing high-performance programs is usually a mixture of using good algorithms
    and the smart usage of computer processing power. Caching is one mechanism that
    can help us, especially when a method takes time to calculate or it's called a
    lot of times in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is a mechanism of recording a function result based on its arguments
    in order to reduce computation in consecutive calls.
  prefs: []
  type: TYPE_NORMAL
- en: Along with saving CPU cycles, memoization can also be useful to minimize the
    application memory footprint by only having one instance of each result. Of course,
    for this entire mechanism to work, we need to have a function that always returns
    the same result when the same arguments are passed.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to achieve memoization. Some of them use imperative
    programming styles and it's pretty straightforward to get to them. Here, we will
    show an approach which is more suitable for Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we will need to hash strings millions of times. Each hashing
    takes some time, depending on the underlying algorithm, but if we store some results
    and reuse them for repeated strings, we can save some computation at the expense
    of having a table of results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with something as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is of a class that has a method called `md5`, which returns
    a hash of the string we pass to it. We have mixed in a trait called `Memoizer`,
    which has the following representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding trait has a method called `memo`, which uses a mutable map to
    retrieve the result of a function based on its input parameters, or calls the
    actual function passed to it if the result is not already in the map. This method
    returns a new function, which actually uses the aforementioned map and has its
    results memoized.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding memoizer example is potentially not thread safe. Multiple threads
    could access the map in parallel and cause the function to be executed twice.
    It's up to the developer to make sure thread safety is in place, if it's needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that we have used generics means that we can actually use this method
    to create a memoized version of any one-parameter function. Now, we can go back
    to our `Hasher` class and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes `memoMd5` a function that does exactly what `md5` does, but uses
    a map internally to try and retrieve results that we have already calculated.
    We can now use our `Hasher` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9f1df58-2794-4348-b385-3a9c71711af9.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding output proves that calling our memoized function for the same
    inputs actually retrieves the result from the map, instead of calling the part
    that processes the result again.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `memo` method that we showed previously is quite neat and easy to use,
    but it''s limiting. We can only get memoized versions of functions with one parameter
    (or we have to represent multiple parameters as a tuple). However, the Scalaz
    library already has support for memoization using the `Memo` object. We can simply
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code can go into our `Hasher` class and then we can instead call
    `memoMd5Scalaz` in our example. This would not require us to write the extra `Memoizer`
    trait and it will produce absolutely the same result as what we showed previously.
    Moreover, the Scalaz version gives us much more flexibility in terms of the way
    we cache and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to apply some of the advanced concepts of the Scala
    programming language in order to tackle problems that commonly emerge in actual
    software projects. We looked at the lens design pattern, where we also had our
    first encounter with the brilliant Scalaz library. We saw how to implement dependency
    injection without any extra libraries in Scala, and what it is used for. We also
    learned how we can write extensions to the libraries which we don't have any modification
    access for. Last but not least, we looked at the type class design pattern, lazy
    evaluation in Scala, partial functions (also known as function currying), duck
    typing, memoization, and implicit injection. By now, you should have quite an
    extensive knowledge of the language possibilities of Scala as well as design patterns,
    which can be used together to write exceptional software.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and last chapter of this book, we will focus a bit more on the Scalaz
    library, and we will show its support for some of the concepts we have already
    seen. We will also go through a final project that will combine our knowledge
    into something that can be used as production code. Finally, we will briefly summarize
    the content covered in this book and give useful pointers.
  prefs: []
  type: TYPE_NORMAL
