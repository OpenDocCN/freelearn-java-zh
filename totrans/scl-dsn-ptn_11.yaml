- en: Applying What We Have Learned
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用所学知识
- en: We have already come a long way in Scala and in learning about the various design
    patterns in the language. Now, you should be at a stage where you are confident
    about when to use specific design patterns and when to avoid them. You saw some
    of the specifics and nice features of Scala that lead to its expressiveness. We
    went through the *Gang of Four* design patterns as well as some important functional
    programming concepts, such as monads. Throughout this book, we have tried to keep
    mathematical theories to a really basic level, and we have tried to avoid some
    scary Greek letters in formulas that are hard to understand for non-mathematicians,
    who may also want to use a functional programming language to its full potential.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala和关于该语言的各种设计模式的学习中，我们已经走了很长的路。现在，你应该已经到了一个可以自信地使用特定设计模式并避免它们的时候了。你看到了Scala的一些具体和优秀的特性，这些特性导致了它的表现力。我们探讨了*四人帮*设计模式以及一些重要的函数式编程概念，如单子。在整个书中，我们尽量将数学理论保持在最基本水平，并尽量避免在公式中使用一些难以理解的希腊字母，这些公式对于非数学家来说很难理解，他们可能也希望充分发挥函数式编程语言的最大潜力。
- en: 'The aim of this and the next chapter is to look at Scala from a more practical
    point of view. Knowing about a language and some design patterns is not always
    enough for a developer to see the whole picture and the potential of language
    possibilities. In this chapter, we will show how some of the concepts we presented
    before can be combined to write even more powerful and cleaner programs. We will
    look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章的目的是从更实际的角度来看Scala。了解一种语言和一些设计模式并不总是足以让开发者看到整个画面和语言可能性的潜力。在本章中，我们将展示我们之前提出的一些概念如何结合在一起，以编写更强大、更干净的程序。我们将探讨以下主题：
- en: The lens design pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜头设计模式
- en: The cake design pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋糕设计模式
- en: The pimp my library design pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化我的图书馆设计模式
- en: The stackable traits design pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可堆叠特质设计模式
- en: The type class design pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类设计模式
- en: Lazy evaluation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性评估
- en: Partial functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分函数
- en: Implicit injection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式注入
- en: Duck typing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸭式类型
- en: Memoization
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Some of the sections in this chapter will show concepts that we haven't seen
    before. Others will combine some of the features of Scala and the design patterns
    we have learned so far in order to achieve something else. In all the cases, though,
    these concepts will deal with either a specific language feature or a limitation
    we have already seen, or help in achieving something commonly seen in actual software
    engineering projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些部分将展示我们之前没有见过的概念。其他部分将结合Scala的一些特性和我们迄今为止学到的设计模式，以实现其他目的。然而，在所有情况下，这些概念都将涉及特定的语言特性或我们已经看到的限制，或者有助于在实际的软件工程项目中实现常见的事情。
- en: The lens design pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜头设计模式
- en: We have already mentioned that, in Scala, objects are immutable. You can, of
    course, make sure that a specific class has its fields declared as `vars`, but
    this is discouraged and considered bad practice. After all, immutability is good
    and we should try to aim for it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，在Scala中，对象是不可变的。当然，你可以确保一个特定的类的字段被声明为`vars`，但这是不被推荐的，并被认为是坏做法。毕竟，不可变性是好的，我们应该努力追求它。
- en: The lens design pattern was created specifically for that purpose and allows
    us to overcome the immutability limitation and at the same time preserve the code's
    readability. In the following subsections, we will start with some code that doesn't
    use the lens design pattern and we will go step by step to show how to use it
    and how it improves our applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 镜头设计模式是为了这个目的而创建的，它使我们能够克服不可变性的限制，同时保持代码的可读性。在接下来的小节中，我们将从一些没有使用镜头设计模式的代码开始，一步一步地展示如何使用它以及它是如何改进我们的应用的。
- en: Lens example
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜头示例
- en: 'In order to show the lens design pattern in practice, we will create a class
    hierarchy that is usually seen in enterprise applications. Let''s imagine that
    we are building a system for a library that can be used by the employees of different
    companies. We might end up with the following classes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实践中展示镜头设计模式，我们将创建一个通常在企业应用程序中看到的类层次结构。让我们想象我们正在为一家图书馆构建一个系统，该系统可以被不同公司的员工使用。我们可能会得到以下类：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The representation of these classes as a class diagram will look like the following
    figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的表示作为类图将看起来如下所示：
- en: '![](img/9aa271bd-7711-4ae2-9d7f-8e63019437ee.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9aa271bd-7711-4ae2-9d7f-8e63019437ee.png)'
- en: The diagram is pretty clear and it doesn't need too much explanation. We basically
    have a `User` class that has other information about the user. Other classes contain
    others and so on. There is absolutely no challenge in using our classes if we
    don't want to modify anything. However, as soon as we go on to modify something,
    it becomes complicated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该图非常清晰，不需要太多解释。我们基本上有一个`User`类，其中包含有关用户的其他信息。其他类包含其他类，依此类推。如果我们不想修改任何内容，使用我们的类绝对没有任何挑战。然而，一旦我们开始修改某些内容，事情就会变得复杂。
- en: Without the lens design pattern
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有透镜设计模式
- en: In this subsection, we will see how to use our classes if we want to modify
    some of their properties.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如果我们要修改它们的某些属性，如何使用我们的类。
- en: Immutable and verbose
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变和冗长
- en: 'Without getting into too much detail, let''s see what an example application
    would look like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，让我们看看一个示例应用程序将是什么样子：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding application creates one user for our library and then decides
    to change the company country code, as we initially created it in lowercase characters.
    The output of the application looks like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的应用程序为我们的库创建了一个用户，然后决定更改公司国家代码，就像我们最初用小写字母创建的那样。应用程序的输出如下：
- en: '![](img/c6b7b500-1d33-4ee4-bc5b-e7132d736473.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6b7b500-1d33-4ee4-bc5b-e7132d736473.png)'
- en: Our application works correctly but as you can see in the highlighted code,
    it is extremely verbose and long and making a mistake is really easy. We don't
    want to write code like this, as it will be hard to maintain and change in the
    future.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序运行正确，但正如你在高亮代码中所看到的，它非常冗长且容易出错。我们不希望编写这样的代码，因为这将是难以维护和未来更改的。
- en: Using mutable properties
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可变属性
- en: 'The first thought that might come into your head is to change the classes and
    make the properties variable. Here is how our case classes would change:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可能首先出现在你脑海中的想法是更改类并使属性可变。以下是我们的案例类将如何改变：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After this, using these classes will be as easy as this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，使用这些类将像这样简单：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code example, we could have also changed the country code using
    this—`uk.code = uk.code.toUpperCase`. This would work, because we use a reference
    of the country in our `User` object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们也可以使用这种方式更改国家代码——`uk.code = uk.code.toUpperCase`。这将有效，因为我们使用`User`对象中的国家引用。
- en: The preceding example will produce absolutely the same output. However, here
    we broke the rule that everything in Scala is immutable. This might not look like
    a big deal in the current example but, in reality, it goes against the Scala principles.
    This is considered bad code and we should try to avoid it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例将产生完全相同的输出。然而，在这里我们打破了Scala中一切都是不可变的规则。在当前示例中，这可能看起来不是什么大问题，但事实上，这与Scala的原则相悖。这被认为是糟糕的代码，我们应该尽量避免。
- en: With the lens design pattern
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用透镜设计模式
- en: In the previous subsection, we saw how complicated something such as changing
    one property of a nested class can be. We are going after nice, clean, and correct
    code, and we also don't want to go against the principles of Scala.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中，我们看到了改变嵌套类的一个属性会变得多么复杂。我们追求的是漂亮、干净和正确的代码，而且我们也不想违反Scala的原则。
- en: Luckily for us, cases such as the one we just mentioned previously are exactly
    the reason for the creation of the lens design pattern. In this chapter, we will
    see the Scalaz library for the first time in this book. It defines many functional
    programming abstractions for us, and we can easily use them straight away without
    worrying whether they follow some specific set of rules or not.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们之前提到的那些情况正是透镜设计模式被创造出来的原因。在本章中，我们将第一次在本书中介绍Scalaz库。它为我们定义了许多函数式编程抽象，我们可以轻松地直接使用它们，而不用担心它们是否遵循某些特定的规则。
- en: 'So, what are lenses anyway? We won''t get too deep into the theoretical aspects
    here, as this is out of the scope of this book. It is enough for us to know what
    they are used for, and if you want to know more, there is plenty of material on
    lenses, store, and comonads online, which can make these concepts clearer. A simple
    way to represent a lens is the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，透镜究竟是什么呢？在这里，我们不会深入探讨理论方面，因为这超出了本书的范围。我们只需要知道它们是用来做什么的，如果你想要了解更多，网上有大量关于透镜、存储和单子的材料，这些材料可以使这些概念更加清晰。表示透镜的一个简单方法是以下内容：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This basically lets us get and set different properties of an object of the
    `X` type. This means that, in our case, we will have to define different lenses
    for the different properties we want to set:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上让我们能够获取和设置 `X` 类型对象的不同的属性。这意味着在我们的情况下，我们将不得不为想要设置的每个属性定义不同的镜头：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code is a companion object to our `User` class. There are a lot
    of things going on here, so we will explain this. You can see the calls to `Lens.lensu[A,
    B]`. They create actual lenses so that for an object of the `A` type, the calls
    get and set a value of the `B` type. There is nothing special about them really,
    and they simply look like boilerplate code. The interesting part here is the highlighted
    code—it uses the `>=>` operator, which is an alias for `andThen`. This allows
    us to compose lenses and this is exactly what we will do. We will define a composition
    that allows us to go from a `User` object through the chain and set the country
    code of the country of the `Company`. We could have used `compose` as well, which
    has an alias of `<=<` because `andThen` internally calls `compose` and it would
    look like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是我们 `User` 类的伴随对象。这里有很多事情在进行中，所以我们将解释这一点。你可以看到对 `Lens.lensu[A, B]` 的调用。它们创建实际的镜头，以便对于
    `A` 类型的对象，调用获取和设置 `B` 类型的值。实际上它们并没有什么特别之处，看起来就像模板代码。这里有趣的部分是高亮显示的代码——它使用了 `>=>`
    操作符，这是 `andThen` 的别名。这允许我们组合镜头，这正是我们将要做的。我们将定义一个组合，允许我们从 `User` 对象通过链路设置 `Company`
    的国家代码。我们也可以使用 `compose`，它的别名为 `<=<`，因为 `andThen` 内部调用 `compose`，它看起来如下：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The latter, however, is not as intuitive as the former.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，后者并不像前者那样直观。
- en: 'Using our lens is now very easy. We need to make sure to import our companion
    object and then we can simply use the following code where we change the country
    code to uppercase:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用我们的镜头非常简单。我们需要确保导入我们的伴随对象，然后我们可以简单地使用以下代码来将国家代码转换为大写：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You saw how the lens design pattern allows us to cleanly set properties of our
    case class without breaking the immutability rule. We simply need to define the
    right lenses and then use them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了如何通过镜头设计模式，我们可以干净地设置我们的案例类的属性，而不违反不可变性规则。我们只需要定义正确的镜头，然后使用它们。
- en: Minimizing the boilerplate
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化模板代码
- en: 'The preceding example showed quite a lot of boilerplate code. It is not complicated,
    but it requires us to write quite a lot of extra stuff, and then any refactoring
    will likely affect these manually defined lenses. There has been an effort in
    creating libraries that automatically generate lenses for all user-defined classes
    that can then be used easily. One example of a library that seems to be maintained
    well is Monocle: [https://github.com/julien-truffaut/Monocle](http://julien-truffaut.github.io/Monocle/).
    It is well-documented and can be used so that we don''t have to write any boilerplate
    code. It has its limitations though, and users should make sure they are okay
    with what the library provides. It also provides other optics concepts that could
    be useful.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子显示了大量的模板代码。它并不复杂，但需要我们编写相当多的额外内容，并且任何重构都可能影响这些手动定义的镜头。已经有人努力创建库来自动为所有用户定义的类生成镜头，这样就可以轻松使用。一个似乎维护得很好的库示例是
    Monocle：[https://github.com/julien-truffaut/Monocle](http://julien-truffaut.github.io/Monocle/)。它有很好的文档，可以用来确保我们不需要编写任何模板代码。尽管如此，它也有其局限性，用户应该确保他们接受库提供的内容。它还提供了其他可能有用的光学概念。
- en: The cake design pattern
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蛋糕设计模式
- en: Actual software projects will usually combine multiple components that will
    have to be used together. Most of the time, these components will depend on others,
    which in turn depend on other components, and so on. This makes creating objects
    in an application hard because we also need to create the objects they depend
    on and so on. This is where dependency injection comes in handy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的软件项目通常会结合多个组件，这些组件必须一起使用。大多数时候，这些组件将依赖于其他组件，而这些组件又依赖于其他组件，依此类推。这使得在应用程序中创建对象变得困难，因为我们还需要创建它们依赖的对象，依此类推。这就是依赖注入派上用场的地方。
- en: Dependency injection
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: So, what exactly is dependency injection? It turns out to be something really
    simple—every single class that has an object as a parameter in their constructor is actually
    an example of a dependency injection. The reason is that the dependency is injected
    into the class rather than instantiated inside it. Developers should actually
    try to use this kind of approach instead of creating objects inside a constructor.
    There are many reasons for this, but one of the most important ones is the fact
    that components can become tightly coupled and practically untestable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，依赖注入到底是什么呢？实际上它非常简单——任何在其构造函数中有一个对象作为参数的类实际上都是依赖注入的一个例子。原因是依赖被注入到类中，而不是在类内部实例化。开发者实际上应该尝试使用这种类型的做法，而不是在构造函数中创建对象。这样做有很多原因，但其中最重要的一个原因是组件可能会变得紧密耦合，实际上难以测试。
- en: Dependency injection, however, could degrade the code quality if implemented
    using constructor parameters. This would make constructors take a large number
    of parameters and, as a consequence, it will become really difficult to use the
    constructors. Of course, using the factory design pattern could help, but there
    are other approaches that are much more common in enterprise applications. In
    the following subsections, we will briefly mention the alternatives and show how,
    using only the features of Scala, we can easily implement dependency injection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用构造函数参数来实现依赖注入，可能会降低代码质量。这将使构造函数包含大量的参数，因此使用构造函数将变得非常困难。当然，使用工厂设计模式可能会有所帮助，但还有其他在企业应用程序中更为常见的方法。在接下来的小节中，我们将简要介绍这些替代方案，并展示如何仅使用Scala的特性轻松实现依赖注入。
- en: Dependency injection libraries and Scala
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入库和Scala
- en: Many developers with a background in Java might be already familiar with some
    of the famous dependency injection libraries. Some popular examples are Spring
    ([https://spring.io/](https://spring.io/)) and Guice ([https://github.com/google/guice](https://github.com/google/guice)).
    In Spring, dependencies are usually managed in an XML file, where they are described,
    and the file tells the framework how to create instances and where to inject the
    objects into classes. Some of the terms used are beans.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 许多拥有Java背景的开发者可能已经熟悉一些著名的依赖注入库。一些流行的例子包括Spring ([https://spring.io/](https://spring.io/))
    和Guice ([https://github.com/google/guice](https://github.com/google/guice))。在Spring中，依赖通常在XML文件中管理，其中描述了依赖项，并且文件告诉框架如何创建实例以及将对象注入到类中。其中使用的术语之一是bean。
- en: On the other hand, Guice uses annotations that are then evaluated and replaced
    with the right objects. These are quite popular frameworks and they can also be
    used in Scala pretty easily. Those of you familiar with Play Framework will know
    that it uses exactly Guice to wire things up.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Guice使用注解，然后这些注解会被评估并替换为正确的对象。这些框架相当流行，并且它们也可以很容易地在Scala中使用。那些熟悉Play Framework的人会知道，它正是使用Guice来连接事物的。
- en: Using external libraries, however, adds dependencies to projects, increases
    the jar size, and so on. Nowadays, this is not really an issue. Scala, however,
    is quite an expressive language, as we have already seen, and we can implement
    dependency injection natively without any extra libraries. We will see how this
    can be done in the following subsections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用外部库会增加项目的依赖项，增加jar文件的大小等等。如今，这并不是真正的问题。然而，正如我们已经看到的，Scala是一种相当表达性的语言，我们可以不使用任何额外的库本地实现依赖注入。我们将在接下来的小节中看到如何实现这一点。
- en: Dependency injection in Scala
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的依赖注入
- en: In order to implement dependency injection in Scala, we can use a special design
    pattern. It is called the cake design pattern. Without getting into too much detail,
    let's create an application. The application that we are creating will need to
    have a bunch of classes that depend on each other so that we can demonstrate how
    injection works.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Scala中实现依赖注入，我们可以使用一种特殊的设计模式。它被称为蛋糕设计模式。不深入细节，让我们创建一个应用程序。我们创建的应用程序将需要有一系列相互依赖的类，这样我们就可以展示注入是如何工作的。
- en: Writing our code
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的代码
- en: We will create an application that can read from a database data about people,
    classes, and who has signed up to which classes. We will have a user service which
    will implement some simple business logic with the data, and a service that will
    access the data. It will be a small application, but it will clearly show how
    dependency injection works.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，可以从数据库中读取有关人员、班级以及谁报名了哪些班级的数据。我们将有一个用户服务，它将使用数据实现一些简单的业务逻辑，并且还有一个将访问数据的服
    务。这将会是一个小型应用程序，但它将清楚地展示依赖注入是如何工作的。
- en: 'Let''s start with the simple stuff. We will need to have a model for the objects
    that we will be representing:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的事情开始。我们需要有一个模型来表示我们将要表示的对象：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we have two classes that will be used in our application.
    There is nothing special about them, so let's go further.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个将在我们的应用程序中使用的类。它们没有什么特别之处，所以让我们继续前进。
- en: We said that we want our application to be able to read data from a database.
    There are different databases—MySQL, PostgreSQL, Oracle, and so on. If we want
    to use any of these, however, you will need to install some extra software that
    will require extra knowledge and will be tricky. Luckily, there is an in-memory
    database engine called H2 ([https://www.h2database.com/html/main.html](https://www.h2database.com/html/main.html))
    that we can use instead. Using this is as simple as adding a dependency to our
    `pom.xml` or `build.sbt` file and then using the database. We will see how this
    all works really soon.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，我们希望我们的应用程序能够从数据库中读取数据。有不同类型的数据库——MySQL、PostgreSQL、Oracle 等。如果我们想使用这些数据库中的任何一个，那么你需要安装一些额外的软件，这将需要额外的知识，并且可能会很棘手。幸运的是，有一个内存数据库引擎叫做
    H2 ([https://www.h2database.com/html/main.html](https://www.h2database.com/html/main.html))，我们可以用它来代替。使用这个引擎就像在我们的
    `pom.xml` 或 `build.sbt` 文件中添加一个依赖项，然后使用数据库一样。我们很快就会看到这一切是如何工作的。
- en: 'Also, let''s make things more interesting and make sure that a different database
    engine could easily be plugged in. For this to work, we will need some kind of
    interface that will be implemented by different database services:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们让事情更有趣，并确保可以轻松地插入不同的数据库引擎。为了实现这一点，我们需要某种类型的接口，该接口将由不同的数据库服务实现：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we used a trait and will extend this trait whenever we
    want to create an H2 database service, or an Oracle database service, and so on.
    Everything in the preceding code seems to be quite straightforward and doesn't
    need additional explanation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了一个特质，并且每当我们要创建一个 H2 数据库服务、Oracle 数据库服务等时，都会扩展这个特质。前面的代码中的所有内容似乎都很直接，不需要额外的解释。
- en: The order of the vals
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: vals 的顺序
- en: In the preceding code, listing the order of the variable definitions matters.
    This means that if we had declared `ds` first and then everything else, we would
    have faced a `NullPointerException`. This can be easily overcome using a `lazy
    val` instead.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，变量定义的顺序很重要。这意味着如果我们首先声明了 `ds`，然后是其他所有内容，我们就会遇到一个 `NullPointerException`。这可以通过使用
    `lazy val` 来轻松克服。
- en: 'For our example, we will be implementing a service for the H2 database engine,
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将实现一个针对 H2 数据库引擎的服务，如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The actual implementation of the database service is in the nested `H2DatabaseService`
    class. Nothing special about it. But what about the `DatabaseComponent` trait?
    It is simple—we want to have a database component that we will mix in our classes
    and it will provide functionality to connect to the databases. The `databaseService`
    variable is left to be abstract and will have to be implemented when the component
    is mixed in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库服务的实际实现是在嵌套的 `H2DatabaseService` 类中。它没有什么特别之处。但是，关于 `DatabaseComponent` 特质呢？很简单——我们希望有一个数据库组件，我们可以将其混合到我们的类中，并提供连接到数据库的功能。`databaseService`
    变量被留为抽象的，并且当组件被混合时必须实现。
- en: 'Having a database component by itself is not useful at all. We will need to
    use it in some way. Let''s create another component, which creates our database
    and its tables and fills them up with data. Obviously, it will depend on the database
    component mentioned previously:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仅有一个数据库组件本身并没有什么用处。我们需要以某种方式使用它。让我们创建另一个组件，它将创建我们的数据库及其表，并用数据填充它们。显然，它将依赖于前面提到的数据库组件：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now this is a lot of code! There is nothing scary about it, though. Let's go
    through it and try to understand it. First, we followed the same pattern as before—we
    created a component trait with an abstract variable, in this case, called `migrationService`.
    We don't need to have multiple different migrations, so we simply created a class
    inside the component trait.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码确实很多！但这并不令人害怕。让我们逐行分析，并尝试理解它。首先，我们遵循了之前的模式——创建了一个具有抽象变量的组件特质，在这个例子中，它被称为`migrationService`。我们不需要有多个不同的迁移，所以我们只需在组件特质内部创建一个类。
- en: 'The interesting part here is the first line that we highlighted—`this: DatabaseComponent
    =>`. What does this mean? Luckily, we have already seen this syntax before in
    the book—it is nothing more than a **self type annotation**. What it does, however,
    is really interesting—it tells the compiler that whenever we mix in the `MigrationComponent`,
    we also need to mix in the `DatabaseComponent`. And this is exactly the piece
    of the puzzle that tells Scala that the migration component will depend on the
    database component. As a consequence, we are now able to run the code in the second
    highlighted row. And if we look carefully, it actually accesses `databaseService`,
    which is a part of `DatabaseComponent`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有趣的部分是我们突出显示的第一行——`this: DatabaseComponent =>`。这是什么意思？幸运的是，我们在书中已经见过这种语法了——它不过是一个**self类型注解**。然而，它所做的确实很有趣——它告诉编译器，每次我们将`MigrationComponent`混入时，我们还需要将`DatabaseComponent`混入。这正是Scala知道迁移组件将依赖于数据库组件的拼图的一部分。因此，我们现在能够在第二行突出显示的代码中运行。如果我们仔细观察，它实际上访问了`databaseService`，这是`DatabaseComponent`的一部分。'
- en: 'In the preceding code, we''ve skipped most of the other implementations, but
    they are straightforward and have nothing to do with the cake design pattern.
    Let''s see two of them:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码中，我们跳过了大多数其他实现，但它们都很直接，与蛋糕设计模式无关。让我们看看其中的两个：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code is just database code that creates a table and inserts data
    into it. The rest of the methods in the class are similar, but they differ in
    the table definitions and what is inserted into them. The full code can be seen
    in the examples that are provided with this book. Here, we will just extract the
    statements that create the database model so that you can have an idea of how
    the database is structured and what we can do with it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码只是创建表并将数据插入到表中的数据库代码。类中的其余方法类似，但它们在表定义和插入内容上有所不同。完整的代码可以在本书提供的示例中看到。在这里，我们只提取创建数据库模型的语句，以便您了解数据库的结构以及我们可以用它做什么：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our migration service in the preceding code simply creates tables in a database
    and inserts some information into them so that we can then use the service. We
    saw that this migration service depends on the database service, and we also saw
    how this dependency is implemented.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的迁移服务简单地创建数据库中的表，并将一些信息插入到这些表中，以便我们随后可以使用该服务。我们看到了这个迁移服务依赖于数据库服务，同时也看到了这种依赖是如何实现的。
- en: 'Just by having these classes, our application will not be that useful. We need
    to be able to interact with the data and do something interesting with it. We
    can say that the migration component just makes sure we have the data. In real-world
    scenarios, we might already have a prepopulated database and we will need to work
    with what is inside this database. Whatever the case, we will need to have a data
    access layer to retrieve what we need. We have created the following component:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过这些课程，我们的应用程序将不会那么有用。我们需要能够与数据交互并对它进行一些有趣的操作。我们可以这样说，迁移组件只是确保我们拥有数据。在现实世界的场景中，我们可能已经有一个预先填充的数据库，我们需要与数据库中的内容进行工作。无论哪种情况，我们都需要有一个数据访问层来检索所需的数据。我们已经创建了以下组件：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `DaoComponent` is similar to the `DatabaseComponent` in terms of its dependency.
    It just defines queries to retrieve data. We've skipped the simple `select` statements.
    It could, of course, define even more methods for insertions, updates, and deletes.
    It nicely hides the complexity of dealing with data from a database, and now we
    can actually create something useful in our application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`DaoComponent`在依赖方面与`DatabaseComponent`类似。它只是定义了用于检索数据的查询。我们跳过了简单的`select`语句。当然，它也可以定义更多用于插入、更新和删除的方法。它很好地隐藏了处理数据库数据的复杂性，现在我们实际上可以在我们的应用程序中创建一些有用的东西。
- en: 'What is commonly seen in enterprise applications is different services that
    could access data in a database, perform some business logic on it, return results,
    and write it back into the database. We have created a simple service that deals
    with users:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中常见的是不同的服务可以访问数据库中的数据，对它执行一些业务逻辑，返回结果，并将其写回数据库。我们创建了一个简单的处理用户的服务：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our `UserComponent`, we follow the same pattern we already know, but this
    time our dependency is on `DaoComponent`. We can then have other components that
    depend on this component and on others as well. We haven''t shown any example
    here in which a component depends on multiple ones at the same time, but this
    is not hard to do at all. We just use the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`UserComponent`中，我们遵循我们已知的相同模式，但这次我们的依赖是`DaoComponent`。然后我们可以有其他依赖此组件和其他组件的组件。我们没有在这里展示任何组件同时依赖多个组件的例子，但这并不难做到。我们只需使用以下方法：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can have dependencies on as many components as we want, and this is where
    the cake design pattern starts to shine and shows its benefits.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以依赖尽可能多的组件，这就是蛋糕设计模式开始发光并显示其优势的地方。
- en: Wiring it all up
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接所有组件
- en: 'In the preceding code, we saw a bunch of components with their implementations
    that declare dependencies to others. We still haven''t seen how everything will
    be used together. By defining our components as traits, we can just mix them in
    together and they will be available to us. This is how we have done it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到了一些组件及其实现，它们声明了对其他组件的依赖。我们还没有看到所有这些组件是如何一起使用的。通过将我们的组件定义为特质，我们只需将它们混合在一起，它们就会对我们可用。这就是我们这样做的方式：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, the `ApplicationComponentRegistry` can be a class as
    well, instead of a Scala object. It mixes the components in and, since each of
    them had an abstract variable, it forces us to assign actual values to them. The
    nicest part of this is that, if we know that our application will need a `UserComponent`,
    the compiler will tell us that we also need a `DaoComponent`, and so on, down
    the chain. The compiler will basically make sure that we have the entire dependency
    chain available during compilation, and it won't let us run our application until
    we have done things properly. This is extremely useful. In other libraries, this
    is not the case and we often find out that our dependency graph is not built properly
    at runtime. Also, this way of wiring things up makes sure we have only one instance
    of each.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`ApplicationComponentRegistry`也可以是一个类，而不是Scala对象。它将组件混合在一起，由于每个组件都有一个抽象变量，它迫使我们为它们分配实际值。最棒的部分是，如果我们知道我们的应用程序需要`UserComponent`，编译器会告诉我们还需要`DaoComponent`，依此类推，直到链的末端。编译器基本上会确保我们在编译期间有完整的依赖链可用，并且它不会让我们运行应用程序，直到我们正确地完成了这些事情。这非常实用。在其他库中，情况并非如此，我们经常发现我们的依赖图在运行时没有正确构建。此外，这种方式连接组件确保我们只有一个实例。
- en: If we had used a class instead of an object for the `ApplicationComponentRegistry`,
    the statement about having only one instance of each component doesn't automatically
    become true. We need to take extra care, otherwise each instance of the registry
    might have different instances of the components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用类而不是对象来表示`ApplicationComponentRegistry`，关于每个组件只有一个实例的声明不会自动成立。我们需要格外小心，否则注册表的每个实例可能会有不同的组件实例。
- en: 'After we have created our component registry, we can easily use everything
    in our application:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建组件注册表之后，我们可以轻松地在我们的应用程序中使用所有内容：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, we simply imported everything from the registry and
    then we used it. The output of this application is shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们简单地从注册表中导入了所有内容，然后使用了它。该应用程序的输出如下截图所示：
- en: '![](img/222041ae-860d-4500-9e09-cac4f3ac0dc7.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/222041ae-860d-4500-9e09-cac4f3ac0dc7.png)'
- en: This is how easy it is to use the cake design pattern in Scala.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用Scala中的蛋糕设计模式有多简单。
- en: Unit testing our application
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对我们的应用程序进行单元测试
- en: Testing is an important part of every application. We need to make sure that
    the changes we add do not negatively affect the other parts of our system and
    that every unit behaves correctly. Testing with the cake design pattern is also
    really simple to achieve.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是每个应用程序的重要部分。我们需要确保我们添加的更改不会对我们的系统其他部分产生负面影响，并且每个单元都表现正确。使用蛋糕设计模式进行测试也非常简单。
- en: 'The cake design pattern allows us to easily create different environments.
    This is why we can create the following test environment:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋糕设计模式允许我们轻松地创建不同的环境。这就是为什么我们可以创建以下测试环境：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code simply contains every component and mocks every service
    with Mockito. Let''s write a test class for our `UserComponent` using our new
    test environment:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码简单地包含了每个组件，并使用Mockito模拟了每个服务。让我们使用我们的新测试环境为我们的`UserComponent`编写一个测试类：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we override the `userService` to be an actual implementation
    and then we use it for the tests. We use Mockito to simulate our database access
    and then we simply write a test that checks whether things work correctly. We
    have decided to simulate our database access. However, in some cases, people have
    test databases or use H2 for tests. Using our test environment, we have the flexibility
    to do whatever we decide.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们覆盖了`userService`以使用实际实现，然后我们使用它进行测试。我们使用Mockito来模拟我们的数据库访问，然后我们简单地编写一个测试来检查一切是否正常工作。我们已经决定模拟我们的数据库访问。然而，在某些情况下，人们有测试数据库或使用H2进行测试。使用我们的测试环境，我们有灵活性去做我们决定的事情。
- en: Running the tests we wrote previously can be achieved with the `mvn clean test`
    or `sbt test` command.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们之前编写的测试可以通过`mvn clean test`或`sbt test`命令实现。
- en: Our test environment allows us to enable as many components in our tests as
    we want. We could simply override multiple such components in our test classes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试环境允许我们在测试中启用我们想要的任何组件。我们可以在我们的测试类中简单地覆盖多个这样的组件。
- en: Other dependency injection alternatives
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他依赖注入替代方案
- en: One thing about the cake design pattern that we presented previously is the
    amount of boilerplate code that we need to write in order to wire everything up
    properly. In large applications, this could become an issue, so there are other
    alternatives that can be used to deal with this. We will briefly discuss here.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们之前提出的蛋糕设计模式的一个问题是我们需要编写的样板代码量，以便正确地连接一切。在大型应用程序中，这可能会成为一个问题，因此有其他替代方案可以用来处理这个问题。我们在这里简要讨论一下。
- en: Implicits for dependency injection
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入的隐式参数
- en: Using implicits is something that removes the requirement of having the component
    traits and self type annotations of the cake design pattern. Implicits, however,
    can quickly complicate method definitions because every method has to declare
    implicit parameters to whatever components it depends on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隐式参数是消除蛋糕设计模式中组件特性和self类型注解要求的一种方法。然而，隐式参数会迅速使方法定义复杂化，因为每个方法都必须声明它所依赖的任何组件的隐式参数。
- en: Reader monad for dependency injection
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入的Reader monad
- en: 'The `Reader` monad is available in the Scalaz library. The way dependency injection
    works with it is that we make each method return a function wrapped in the `Reader`
    monad, for example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader` monad在Scalaz库中可用。依赖注入与它的结合方式是，我们让每个方法返回一个被`Reader` monad包装的函数，例如：'
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we only expose `getAverageAgeOfUsersInClass(className:
    String)` to the users. Typically, for monads, computation here is built, but nothing
    is done until the last moment. We can build complex operations, use `map`, `flatMap`,
    and for comprehensions. We defer injecting the dependencies until the last moment,
    where we can simply call `apply` on a reader with the actual component or components
    it needs. The preceding explanation might sound a bit abstract, but things are
    pretty simple and can be seen in many places online.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述代码中，我们只向用户公开了`getAverageAgeOfUsersInClass(className: String)`。通常，对于monads，计算在这里构建，但直到最后一刻才执行。我们可以构建复杂的操作，使用`map`、`flatMap`和for
    comprehensions。我们推迟注入依赖，直到最后一刻，那时我们可以在需要实际组件或组件的reader上简单地调用`apply`。前面的解释可能听起来有点抽象，但事情实际上非常简单，可以在网上许多地方看到。'
- en: In some cases, this method is used together with the cake design pattern.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这种方法与蛋糕设计模式一起使用。
- en: The pimp my library design pattern
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改我的库设计模式
- en: In our daily job as developers, we often use different libraries. They, however,
    are usually made to be generic and allow many people to use them, so sometimes
    we need to do something extra that is specific to our use case in order to make
    things work properly. The fact that we cannot really modify the original library
    code means that we have to do something different. We have already looked at the
    decorator and the adapter design patterns. Well, pimp my library achieves something
    similar, but it does this in the Scala way and some of the extra work is given
    to the compiler to deal with.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们作为开发者的日常工作中，我们经常使用不同的库。然而，它们通常被设计成通用的，允许许多人使用它们，因此有时我们需要做一些额外的工作，以适应我们的特定用例，以便使事情能够正常工作。我们无法真正修改原始库代码的事实意味着我们必须采取不同的方法。我们已经探讨了装饰器和适配器设计模式。好吧，改进我的库模式实现了类似的功能，但它以Scala的方式实现，并且一些额外的工作交由编译器处理。
- en: The pimp my library design pattern is really similar to extension methods in
    C#. We will see some examples in the following subsections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 改进我的库设计模式在C#中的扩展方法非常相似。我们将在以下小节中看到一些示例。
- en: Using pimp my library
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用改进我的库
- en: 'The pimp my library design pattern is really easy to use. Let''s see an example
    in which we want to add some useful methods to the standard `String` class. Of
    course, we cannot modify its code, so we need to do something else:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 改进我的库设计模式非常容易使用。让我们看看一个例子，我们想在标准`String`类中添加一些有用的方法。当然，我们无法修改其代码，因此我们需要做些其他事情：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, we have a package object. It gives us the convenience
    to not do anything extra in order to be able to access its members from the classes
    in the same package in Scala. It can be a simple object, but then we will have
    to `import ObjectName._` in order to gain access to the members.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有一个包对象。它为我们提供了便利，使我们能够不进行任何额外操作就能从同一包中的类访问其成员。它可以是简单的对象，但那时我们将不得不`import
    ObjectName._`以获得对成员的访问。
- en: 'The preceding object is just a detail and is not related to the design pattern.
    The pimp my library code is the internal class. There are a few important things
    about this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述对象只是一个细节，与设计模式无关。改进我的库代码是内部类。关于这一点有几个重要的事项：
- en: It is implicit
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是隐式的
- en: It extends `AnyVal`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它扩展了`AnyVal`
- en: 'These features allow us to write the following application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性使我们能够编写以下应用程序：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We basically added an extension method to the standard string that checks whether
    the entire string is in uppercase or not. The only thing we need to do is make
    sure that the implicit class is available in the scope where we want to use the
    methods defined by it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上向标准字符串添加了一个扩展方法，用于检查整个字符串是否为大写。我们唯一需要做的是确保隐式类在我们想要使用其定义的方法的作用域内可用。
- en: 'The output of the preceding application is shown as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述应用程序的输出如下所示：
- en: '![](img/7cdb1e83-bc57-468a-8b3f-aa8428a5d2f3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7cdb1e83-bc57-468a-8b3f-aa8428a5d2f3.png)'
- en: In our example, we didn't have to write code that wraps strings in our extension
    class. Our code shows the type as a normal string; however, we can just do extra
    things with it. Additionally, the decorator design pattern will suffer in the
    cases where the class we are trying to decorate is final. Here, there is no issue.
    Again, all the magic happens because we have an implicit class, and the Scala
    compiler automatically figures out that it can wrap and unwrap a string depending
    on the methods we call on it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们不需要编写在扩展类中包装字符串的代码。我们的代码将类型显示为普通字符串；然而，我们可以对其进行额外的操作。此外，装饰器设计模式在尝试装饰的类是final的情况下会受到影响。在这里，没有问题。再次强调，所有魔法都发生因为我们有一个隐式类，Scala编译器会自动确定它可以根据我们调用的方法来包装和展开字符串。
- en: 'We can, of course, add more methods to the `StringExtensions` class and they
    will be available to all the strings where the implicit class is available. We
    can also add other classes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以向`StringExtensions`类添加更多方法，并且它们将对所有可用的隐式类中的字符串可用。我们还可以添加其他类：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code is capable of saving an entire collection of the `Person`
    type to a database (even though, in the example, we just print the collection
    to the standard output). For completeness, our `Person` model class is defined
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码能够将整个`Person`类型的集合保存到数据库中（尽管在示例中我们只是将集合打印到标准输出）。为了完整性，我们的`Person`模型类定义如下：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the new extension is then similar to the earlier extension:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的扩展方法与早期的扩展方法类似：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding example will produce the expected result, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将产生预期的结果，如下所示：
- en: '![](img/56be3880-216f-49c3-9aba-80be954171a9.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56be3880-216f-49c3-9aba-80be954171a9.png)'
- en: We can also apply the pimp my library design pattern to our custom classes if
    we need to and if it makes sense.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要并且合理，我们也可以将改进我的库设计模式应用于我们的自定义类。
- en: Pimp my library in real life
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实生活中的改进我的库
- en: As you can see from the preceding section, the pimp my library design pattern
    is extremely easy to use. This is seen quite often, especially when a decorator
    or adapter design pattern is needed. We can, of course, figure out ways to deal
    with issues without this library design but, in reality, it helps us to avoid
    boilerplate code. It also really helps in making our code more readable. Last
    but not least, it can be used to simplify the use of specific libraries.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，改进我的库设计模式极其容易使用。这很常见，尤其是在需要装饰器或适配器设计模式时。我们当然可以找出处理问题的方法，但事实上，它帮助我们避免样板代码。它也真正有助于使我们的代码更易于阅读。最后但同样重要的是，它可以用来简化特定库的使用。
- en: The stackable traits design pattern
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可堆叠特性设计模式
- en: There are sometimes cases where we want to be able to provide different implementations
    for a method of a class. We might not even know all the possibilities that could
    exist at the moment of writing, but we can add them later and combine them or
    we can allow someone else to do this instead. This is another use case of the
    decorator design pattern, which for this purpose could be implemented with the
    stackable traits design pattern. We have already seen this pattern before in this
    book in [Chapter 7](263a83d5-a022-4678-9dcc-030c898373d6.xhtml), *Structural Design
    Patterns*, but we used it to read data, which adds a really important catch there.
    We will see another example here, which will make sure everything is completely
    clear.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望能够为类的某个方法提供不同的实现。我们甚至可能不知道在编写时所有可能存在的可能性，但我们可以在以后添加它们，并将它们组合起来，或者我们可以允许其他人来做这件事。这是装饰器设计模式的一个用例，为了这个目的，它可以与可堆叠特性设计模式一起实现。我们在这本书的[第7章](263a83d5-a022-4678-9dcc-030c898373d6.xhtml)中已经看到了这个模式，*结构型设计模式*，但我们用它来读取数据，这在那里增加了一个非常重要的限制。在这里，我们将看到另一个例子，以确保一切完全清楚。
- en: Using stackable traits
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可堆叠特性
- en: The stackable traits design pattern is based on mixin composition—something
    we became familiar with in the early chapters of this book. We usually have an
    abstract class or a trait that defines an interface, a base implementation, and
    traits that extend the abstract class to stack modifications on it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可堆叠特性设计模式基于混入组合——这是我们在这本书的前几章中熟悉的。我们通常有一个定义接口、基本实现和扩展抽象类以在其上堆叠修改的抽象类或特性。
- en: 'For our example, let''s implement the following diagram:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，让我们实现以下图示：
- en: '![](img/db03b0a7-ae6c-431a-9ab9-cde8c7c50ef3.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db03b0a7-ae6c-431a-9ab9-cde8c7c50ef3.png)'
- en: The preceding diagram is of a really simple application. We have a base `StringWriter`
    class, which has a basic implementation (`BasicStringWriter`) that just returns
    a message containing the string. On the right-hand side, we have traits that can
    add stackable modifications to the `StringWriter`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示是一个非常简单的应用程序。我们有一个基本的`StringWriter`类，它有一个基本实现（`BasicStringWriter`），它只是返回一个包含字符串的消息。在右侧，我们有可以添加可堆叠修改的`StringWriter`特性的特性。
- en: 'Let''s see the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code is of the abstract class and the basic implementation. There
    is nothing special about these. Now, let''s look at the stackable traits:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是抽象类和基本实现。这些没有什么特别之处。现在，让我们看看可堆叠特性：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The whole magic in the preceding code happens because of the `abstract override`
    modifier on the methods. It allows us to call `super` on an abstract method of
    the `super` class. This would otherwise fail, but here it just requires us to
    mix the traits in with a class or a trait that has `write` implemented. If we
    don't, we won't be able to compile our code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的全部魔法都是因为方法上的`abstract override`修饰符。它允许我们在`super`类的抽象方法上调用`super`。否则这将失败，但在这里，它只需要我们将特性与一个实现了`write`的类或特性混合。如果我们不这样做，我们就无法编译我们的代码。
- en: 'Let''s see an example use of our traits:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们特性的一个示例用法：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we simply stack modifications together using mixin composition.
    In the current example, they are just illustrations that don''t do anything smart,
    but, in reality, we can have variations that will provide powerful modifications.
    The following figure shows the output of our example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是通过混入组合将修改堆叠在一起。在当前示例中，它们只是说明性的，并没有做任何智能的事情，但现实中我们可以有提供强大修改的变体。以下图显示了我们的示例输出：
- en: '![](img/7da9e5ef-1e63-44bc-b81b-571e6a49a340.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da9e5ef-1e63-44bc-b81b-571e6a49a340.png)'
- en: The modifications we have in our code would depend on the order in which they
    are applied. For example, if we put everything in uppercase first, then capitalization
    will not have any effect. Let's see the code and the relevant output and try to
    figure out how the modifications are applied. If you look at all the examples
    and outputs, you will see that the modifications are applied *from right to left*
    in the order we have mixed the traits in.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中的修改将取决于它们应用的顺序。例如，如果我们首先将所有内容转换为大写，那么大写化将没有任何效果。让我们看看代码和相关的输出，并尝试找出修改是如何应用的。如果你查看所有示例和输出，你会发现修改是按照我们混合特性的顺序从右到左应用的。
- en: If we look back at the example in [Chapter 7](263a83d5-a022-4678-9dcc-030c898373d6.xhtml),
    *Structural Design Patterns*, however, we will see that the actual modifications
    are reversed. The reason for this is that each trait does `super.readLines` and
    then maps. Well, this actually means that we will be pushing calls on the stack
    until we get to the basic implementation, and then we will be going back to do
    all the mappings. So in [Chapter 7](263a83d5-a022-4678-9dcc-030c898373d6.xhtml),
    *Structural Design Patterns*, the modifications are also applied from right to
    left, but because we just get the output and don't pass anything on, things are
    applied in left to right order.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾[第7章](263a83d5-a022-4678-9dcc-030c898373d6.xhtml)中的示例，*结构设计模式*，然而，我们会看到实际的修改是相反的。原因是每个特性都会调用`super.readLines`然后映射。嗯，这实际上意味着我们将调用堆栈上的调用，直到我们到达基本实现，然后我们将返回去做所有的映射。所以，在[第7章](263a83d5-a022-4678-9dcc-030c898373d6.xhtml)中，*结构设计模式*，修改也是从右到左应用的，但由于我们只是获取输出而不传递任何东西，所以事情是按照从左到右的顺序应用的。
- en: The stackable traits order of execution
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可堆叠特性执行顺序
- en: Stackable traits are always executed from the right mixin to the left. Sometimes,
    however, if we only get output and it doesn't depend on what is passed to the
    method, we simply end up with method calls on a stack, which then get evaluated
    and it will appear as if things are applied from left to right.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可堆叠特性总是从右边的混入到左边执行。然而，有时如果我们只获取输出并且它不依赖于传递给方法的内容，我们最终会在堆栈上得到方法调用，然后这些调用将被评估，看起来就像是从左到右应用的一样。
- en: Understanding the preceding explanation is really important for using stackable
    traits. It actually perfectly matches what we saw about linearization in [Chapter
    2](39295d70-43a1-4c6c-b019-2723f048bf96.xhtml), *Traits and Mixin Compositions*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 理解前面的解释对于使用可堆叠特性非常重要。它实际上完美地匹配我们在[第2章](39295d70-43a1-4c6c-b019-2723f048bf96.xhtml)中关于线性化的观察，*特性和混入组合*。
- en: The type class design pattern
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类设计模式
- en: A lot of times when we write software, we encounter similarities between different
    implementations. An important principle of good code design is to avoid repetition
    and it is known as **do not repeat yourself** (**DRY**). There are multiple ways
    that help us to avoid repetitions—inheritance, generics, and so on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写软件的许多时候，我们会遇到不同实现之间的相似性。良好的代码设计的一个重要原则是避免重复，这被称为**不要重复自己**（**DRY**）。有多种方法可以帮助我们避免重复——继承、泛型等等。
- en: One way to make sure we do not repeat ourselves is through type classes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们不重复自己的一个方法是通过类型类。
- en: The purpose of type classes is to define some behavior in terms of operations
    that a type must support in order to be considered a member of the type class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类的目的是通过类型必须支持的操作来定义一些行为，以便被认为是类型类的成员。
- en: A concrete example would be `Numeric`. We can say that it is a type class and
    defines the operations—addition, subtraction, multiplication, and so on, for the
    `Int`, `Double`, and such other classes. We have actually already encountered
    type classes earlier in this book in [Chapter 4](31807099-24ea-49c2-8dc1-8dcc978987d7.xhtml),
    *Abstract and Self Types*. Type classes are the ones that allow us to implement
    ad hoc polymorphism.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具体的例子是`Numeric`。我们可以这样说，它是一个类型类，并为`Int`、`Double`以及其他类似类定义了操作——加法、减法、乘法等等。实际上，我们已经在本书的[第4章](31807099-24ea-49c2-8dc1-8dcc978987d7.xhtml)中遇到过类型类，*抽象和自类型*。类型类是允许我们实现特定多态的。
- en: Type class example
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类示例
- en: Let's see an actual example that is also somehow useful to developers in this
    case. In machine learning, developers tend to use some statistical functions quite
    often in their work. There are statistical libraries and, if we try them out,
    we will see that these functions exist for different numeric types—`Int`, `Double`,
    and so on. Now, we could come up with something simple and implement these functions
    for all the numeric types we think about. This, however, is not feasible and makes
    our library impossible to extend. Moreover, statistical functions have the same
    definitions, no matter the type, so we don't want to repeat our code as many times
    as there are numeric types.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际例子，这个例子对开发者来说也有些有用。在机器学习中，开发者往往在他们的工作中经常使用一些统计函数。有统计库，如果我们尝试它们，我们会看到这些函数对不同数值类型——`Int`、`Double`等等——都是存在的。现在，我们可以想出一个简单的方法，为所有我们认为的数值类型实现这些函数。然而，这是不可行的，并使得我们的库无法扩展。此外，统计函数的定义对于任何类型都是相同的，所以我们不希望像数值类型那么多地重复我们的代码。
- en: 'So let''s first define our type class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们首先定义我们的类型类：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding is just a trait that defines some operations that will require
    numbers to support it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面只是一个定义了一些需要数字支持的操作的特质的例子。
- en: Numeric in Scala
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的Numeric
- en: The Scala programming language has a `Numeric` trait that defines many of the
    previously mentioned operations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编程语言有一个`Numeric`特质，它定义了许多前面提到的操作。
- en: If we had used the `Numeric` trait in the preceding code, we could have saved
    ourselves from some code writing, but for the sake of this example, let's use
    our custom type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在前面的代码中使用了`Numeric`特质，我们可以节省一些代码编写，但为了这个例子，让我们使用我们的自定义类型。
- en: 'After we have defined a trait for the numbers, we can now write our library
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了一个数字的特质之后，我们现在可以按照以下方式编写我们的库：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There is quite a lot of code in the preceding example. Defining the functions
    is pretty straightforward. Let's, however, explain the role of the `implicitly`
    keyword. It uses the so-called **context bounds** from Scala, and it is the crucial
    part that allows us to implement the type class design pattern. In order to use
    the preceding methods, it requires a type class member of `Number` for the `T`
    type to be implicitly available. As you can see in the comment above `mean`, we
    can alternatively have an implicit parameter to the methods.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中有很多代码。定义函数相当直接。然而，让我们解释一下`implicitly`关键字的作用。它使用Scala中的所谓**上下文界限**，这是允许我们实现类型类设计模式的关键部分。为了使用前面的方法，它需要一个类型类成员`Number`对于`T`类型是隐式可用的。正如你在`mean`上面的注释中可以看到的，我们还可以为方法提供一个隐式参数。
- en: 'Now, let''s write some example code that will use the previously mentioned
    methods:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些示例代码，这些代码将使用前面提到的方法：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Compiling the preceding code right now will not be successful and we will see
    error similar to the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 编译前面的代码现在将不会成功，我们会看到类似于以下错误的错误：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The reason for this is that we have not yet defined any implicitly available
    `Number` members for `Int` and `Double`. Let''s define them in the companion object
    for the `Number` trait:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是我们还没有为`Int`和`Double`定义任何隐式可用的`Number`成员。让我们在`Number`特质的伴随对象中定义它们：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, our code will compile successfully. But how did this whole thing work when
    we had just defined these implicits in a companion object in a completely different
    file? First of all, our nested objects are implicit, and second of all, they are
    available in the companion object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的代码将成功编译。但是当我们刚刚在一个完全不同的文件中的伴随对象中定义了这些隐式值时，整个事情是如何工作的呢？首先，我们的嵌套对象是隐式的，其次，它们在伴随对象中是可用的。
- en: Defining your default type class members in the companion object
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在伴随对象中定义你的默认类型类成员
- en: The companion object of the implicit type class parameter is the last place
    the compiler looks for implicit values. This means that nothing extra has to be
    done and users can easily override our implementations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型类参数的伴随对象是编译器最后查找隐式值的地方。这意味着不需要做任何额外的事情，用户可以轻松地覆盖我们的实现。
- en: 'We can now run our code easily:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以轻松地运行我们的代码：
- en: '![](img/c4c8d624-3ba1-4544-90eb-7f0cafa4931b.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4c8d624-3ba1-4544-90eb-7f0cafa4931b.png)'
- en: Of course, we can put our implicit values anywhere we want. If they are not
    in the companion object, however, we will have to do extra imports in order to
    make them available.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将我们的隐式值放在我们想要的地方。然而，如果它们不在伴随对象中，我们就必须进行额外的导入，以便使它们可用。
- en: Type class design pattern alternatives
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类设计模式替代方案
- en: There are, of course, alternatives to the type class design pattern. We can
    use the adapter design pattern. It will, however, make it much harder to read
    our code because things will be wrapped all the time and they will be much more
    verbose. The type class design pattern takes advantage of the nice features of
    the Scala type system.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，类型类设计模式有替代方案。我们可以使用适配器设计模式。然而，这将使我们的代码难以阅读，因为事物将始终被包装，并且将更加冗长。类型类设计模式利用了Scala类型系统的良好特性。
- en: Looking at our preceding code, we can also see that there is a fair bit of boilerplate
    code. This can become problematic in bigger projects, or when we try to define
    more complex type classes. A library that was written specifically to deal with
    these issues can be found at [https://github.com/mpilquist/simulacrum/](https://github.com/mpilquist/simulacrum/).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们前面的代码，我们还可以看到有很多样板代码。在更大的项目或尝试定义更复杂的类型类时，这可能会成为问题。一个专门编写来处理这些问题的库可以在[https://github.com/mpilquist/simulacrum/](https://github.com/mpilquist/simulacrum/)找到。
- en: Lazy evaluation
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: Writing efficient code is an important part of software engineering. A lot of
    times, we will see cases where an expression is expensive to evaluate due to different
    possible reasons—database access, complex calculations, and so on. There are cases
    where we might even be able to exit the application without even evaluating these
    expensive expressions. This is where lazy evaluation becomes helpful.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高效的代码是软件工程的重要组成部分。很多时候，我们会看到由于不同的可能原因，表达式评估成本高昂的情况——数据库访问、复杂计算等等。在某些情况下，我们甚至可以在不评估这些昂贵表达式的情况下退出应用程序。这就是懒加载变得有帮助的地方。
- en: Lazy evaluation makes sure that an expression is evaluated only once when it
    is actually needed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载确保表达式仅在真正需要时才被评估一次。
- en: Scala supports lazy evaluation in a couple of flavors—lazy variables and by-name
    parameters. We have already seen both in this book the former we saw when we looked
    at creational design patterns in [Chapter 6](9971ad44-53fa-4b20-a3a3-4417ffeac78f.xhtml),
    *Creational Design Patterns,* and more specifically, lazy initialization. We saw
    the latter in a few places, but we encountered it for the first time in [Chapter
    8](706552cf-27de-4b8b-b5a3-e6e22412056d.xhtml), *Behavioral Design Patterns -
    Part 1*, where we showed you how to implement the command design pattern in a
    way that is closer to how Scala does it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Scala支持几种懒加载方式——懒变量和按名参数。在这本书中，我们已经看到了这两种方式：前者是在我们查看第6章的创建型设计模式时看到的，即*创建型设计模式*，特别是懒初始化。后者我们在几个地方都看到了，但第一次是在第8章*行为设计模式
    - 第1部分*中遇到的，我们向您展示了如何以更接近Scala的方式实现命令设计模式。
- en: There is an important difference between lazy variables and by-name parameters.
    The lazy variables will be calculated only once, whereas the by-name parameters
    will be calculated every time they are referred to in a method. There is a really
    simple trick we will show here that will fix this issue.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 懒变量和按名参数之间存在一个重要的区别。懒变量只计算一次，而按名参数每次在方法中引用时都会计算。这里有一个非常简单的技巧我们将展示，这将解决这个问题。
- en: Evaluating by-name parameters only once
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只计算一次按名参数
- en: 'Let''s imagine that we have an application that takes data about people from
    a database. The reading operation is something that is expensive, and it is a
    good candidate for lazy evaluation. For this example, we will simply simulate
    reading from the database. First of all, our model will be as simple as the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想我们有一个从数据库中获取人员数据的程序。读取操作是一种昂贵的操作，是懒加载的良好候选者。在这个例子中，我们将简单地模拟从数据库中读取。首先，我们的模型将尽可能简单，如下所示：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s create a companion object that will have a method that simulates
    getting the data about people from a database:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个伴随对象，它将有一个模拟从数据库获取人员数据的方法：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code simply makes the current thread sleep for three seconds
    and returns a static result. Calling the `getFromDatabase` method multiple times
    will make our application slow, so we should consider lazy evaluation. Now, let''s
    add the following method to our companion object:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码只是让当前线程休眠三秒钟并返回一个静态结果。多次调用`getFromDatabase`方法会使我们的应用程序变慢，因此我们应该考虑惰性评估。现在，让我们向我们的伴随对象添加以下方法：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, we simply printed the list of data about people twice and we
    accessed the by-name parameter twice. This is bad because it will evaluate the
    function twice and we will have to wait for twice the amount of time. Let''s write
    another version that will fix this issue:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们简单地打印了两次关于人员的数据列表，并且两次访问了按名称参数。这是不好的，因为它将评估函数两次，我们不得不等待两倍的时间。让我们写另一个版本来解决这个问题：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This time, we will assign the by-name parameter to a `lazy val` and then use
    it instead. This will only evaluate the by-name parameter once and, again, if
    we end up not using it, it will not be evaluated at all.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将按名称参数分配给`lazy val`，然后使用它。这将只评估一次按名称参数，而且，如果我们最终没有使用它，它将根本不会评估。
- en: 'Let''s see an example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we run this application, we will see the following output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个应用程序，我们将看到以下输出：
- en: '![](img/347d0943-321f-48a9-8fef-e09c7287b163.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/347d0943-321f-48a9-8fef-e09c7287b163.png)'
- en: As you can see from the program output, the first version of our method retrieves
    the by-name parameter value twice, while the second version does it only once.
    The fact that we use a `lazy val` inside the second method also has the possibility
    of not evaluating our expensive expression at all if we don't actually use it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从程序输出中可以看到，我们方法的第一个版本检索了按名称参数值两次，而第二个版本只检索了一次。在第二个方法中使用`lazy val`的事实也意味着如果我们实际上没有使用它，我们可能根本不会评估我们的昂贵表达式。
- en: Alternative lazy evaluation
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代惰性评估
- en: There is another way to implement lazy evaluations in Scala. It is through using
    anonymous functions and taking advantage of the fact that functions are a part
    of unifications in Scala and we can also pass them as parameters easily. This
    is done as follows—a value is represented as `() => value` rather than just the
    value itself. It is somewhat pointless, though, especially because we already
    have two mechanisms that can do quite a lot. Using anonymous functions for a lazy
    evaluation is not recommended.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中实现惰性求值还有另一种方法。这是通过使用匿名函数并利用函数是Scala中统一的一部分以及我们可以轻松地将它们作为参数传递的事实来实现的。这样做的方式如下——一个值被表示为`()
    => value`而不是仅仅是值本身。然而，这有点没有意义，尤其是因为我们已经有了两种可以做到很多事情的机制。使用匿名函数进行惰性求值是不推荐的。
- en: Passing a function to a method can also be considered as a way of lazily evaluating
    some data. This, however, can be useful and should not be confused with what we
    just said about anonymous functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个函数传递给一个方法也可以被认为是一种惰性评估一些数据的方式。然而，这可能是有用的，不应该与我们在匿名函数中提到的内容混淆。
- en: Partial functions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分函数
- en: In mathematics and, as a consequence, in programming, there are functions that
    are not defined for all possible inputs. A simple example is the square root function—it
    will only work for real numbers if they are non-negative. In this section, we
    will look at partial functions and how we can use them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，以及作为结果在编程中，有一些函数并不是对所有可能的输入都定义的。一个简单的例子是平方根函数——它只对非负实数有效。在本节中，我们将探讨部分函数以及我们如何使用它们。
- en: Partial functions are not partially applied functions
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分函数不是部分应用函数
- en: 'There seems to be some confusion around what partial functions are and what
    they are not. It is important for you to understand that these functions are not
    partially applied functions. Partially applied functions are simply functions
    that might take multiple parameters and we''ve specified some of them and then
    they return functions with fewer parameters that we can specify. There is another
    term—**curried functions**—that is related to partially applied functions. In
    terms of functionality, they provide the same functionality. Let''s see a quick
    example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 关于部分函数是什么以及不是什么似乎存在一些混淆。重要的是你要明白，这些函数不是部分应用函数。部分应用函数只是可能接受多个参数的函数，我们指定了一些参数，然后它们返回具有较少参数的函数，我们可以指定这些参数。还有一个与部分应用函数相关的术语——**柯里化函数**。在功能方面，它们提供相同的功能。让我们快速看一个例子：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, we have different definitions of greater and lesser
    or equal functions. First, we have them as normal functions. The second version
    is with multiple parameter lists and the last one is an actual curried function.
    Here is how to use them:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们对大于和小于或等于函数有不同的定义。首先，我们将它们作为普通函数。第二种版本是带有多个参数列表的，最后一个是实际的柯里化函数。以下是它们的用法：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The way we use partially applied functions is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用部分应用函数的方式如下：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This returns a function of `Int` to `Boolean`, which we can use to check whether
    the parameter is greater or equal to the `MIN` value. This is a partially applied
    function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个从 `Int` 到 `Boolean` 的函数，我们可以用它来检查参数是否大于或等于 `MIN` 值。这是一个部分应用函数。
- en: For the curried versions of these functions, as you can see, we have switched
    the parameters. The reason is that curried functions are simply a chain of single
    parameter functions and the parameters are applied in the order we see them. The
    line `greaterOrEqualCurried(MIN) _` partially applies the function and returns
    a curried function that we can use similarly to above. As you can see in the code
    comments, we can actually convert any multiple parameter function into a curried
    function. The reason for `greaterOrEqual` and `lessOrEqual` not working in our
    example is that the parameters are applied in the order they are seen. Finally,
    we have a pure curried version in `greaterOrEqualCurriedVal` and `lessOrEqualCurriedVal`.
    This type of function is returned when we partially apply a function with multiple
    parameter lists.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些函数的柯里化版本，正如你所见，我们已经交换了参数。原因是柯里化函数只是一系列的单参数函数，参数按照我们看到的顺序应用。`greaterOrEqualCurried(MIN)`
    这行代码部分应用了函数，并返回了一个我们可以像上面一样使用的柯里化函数。正如代码注释中所示，我们可以将任何多参数函数转换为柯里化函数。`greaterOrEqual`
    和 `lessOrEqual` 在我们的例子中不工作是因为参数是按照它们出现的顺序应用的。最后，我们在 `greaterOrEqualCurriedVal`
    和 `lessOrEqualCurriedVal` 中有一个纯柯里化版本。当我们部分应用具有多个参数列表的函数时，返回这种类型的函数。
- en: 'If we run the preceding example, we will see the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的例子，我们将看到以下输出：
- en: '![](img/b16ef7c8-238b-46e3-b9a9-48ce1f2df8bb.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b16ef7c8-238b-46e3-b9a9-48ce1f2df8bb.png)'
- en: Choosing whether to use partially applied functions or curried functions depends
    on many things, including personal preference. In both cases, we can achieve the
    same objectives with a slightly different syntax. As you can see, we can go from
    a normal to a curried function using `.curried`. We can also go the other way
    round using the `Function.uncurried` call and passing the function to it. This
    call makes sense when the curried function has more than one function in the chain.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 选择是否使用部分应用函数或柯里化函数取决于许多因素，包括个人偏好。在两种情况下，我们可以用稍微不同的语法达到相同的目标。正如你所见，我们可以使用 `.curried`
    从普通函数到柯里化函数转换。我们也可以使用 `Function.uncurried` 调用并传递函数来实现相反的操作。当柯里化函数链中包含多个函数时，这个调用是有意义的。
- en: Using partially applied functions for dependency injection
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用部分应用函数进行依赖注入
- en: Because of the way partially applied functions and curried functions work, we
    can use them for dependency injection. We can basically apply the dependencies
    to a function and then get another function, which we can use afterward.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于部分应用函数和柯里化函数的工作方式，我们可以将它们用于依赖注入。我们基本上可以将依赖项应用到函数上，然后得到另一个函数，我们可以在之后使用它。
- en: Partially defined functions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分定义的函数
- en: 'We already said that partial functions are only defined for specific subsets
    of all possible values the functions can get. This is quite useful, as we can
    basically perform `filter` and `map` at once. This means fewer CPU cycles and
    more readable code. Let''s see an example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，部分函数只为函数可能得到的所有可能值的一个特定子集定义。这非常有用，因为我们基本上可以同时执行`filter`和`map`。这意味着更少的CPU周期和更易读的代码。让我们看看一个例子：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We defined a partial function from `Int` to `Double`. It checks whether a number
    is non-negative and returns the square root of that number. This partial function
    can be used as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个从`Int`到`Double`的部分函数。它检查一个数字是否为非负数，并返回该数字的平方根。这个部分函数可以这样使用：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We are using the `collect` method that takes a partial function. We''ve also
    shown one of the methods that partial functions have—`isDefinedAt`, whose name
    tells us exactly what it does. The output of our program will be this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了接受部分函数的`collect`方法。我们还展示了部分函数的一个方法——`isDefinedAt`，其名称确切地告诉我们它做什么。我们程序的输出将是这样的：
- en: '![](img/872cb315-f536-4e25-bfb6-485a1951abcb.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/872cb315-f536-4e25-bfb6-485a1951abcb.png)'
- en: Our partial function filtered out the negative numbers and returned the square
    roots of the rest.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的部分函数过滤掉了负数，并返回了其余数的平方根。
- en: 'Partial functions can also be used to chain operations or do something different
    if one operation is not possible. They have the `orElse`, `andThen`, `runWith`,
    and such other methods. It is clear from their names what the first two methods
    do. The third method uses the results of the partially applied function and performs
    an action that could potentially cause side effects. Let''s see an example of
    `orElse`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数也可以用来链式操作，或者在某个操作不可行时执行不同的操作。它们有`orElse`、`andThen`、`runWith`等这样的方法。从它们的名字就可以清楚地知道前两种方法的作用。第三种方法使用部分应用函数的结果并执行可能产生副作用的行为。让我们看看`orElse`的一个例子：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, we define another partial function that squares negative numbers. Then,
    we can add some extra code to our example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义另一个部分函数，它对负数进行平方。然后，我们可以在我们的例子中添加一些额外的代码：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will produce the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/38030e60-b8e4-4760-8624-1dec1a8e53f4.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38030e60-b8e4-4760-8624-1dec1a8e53f4.png)'
- en: We will basically square the negative numbers and square root the positive ones.
    It might not make much sense in terms of the operations we do in this example,
    but it shows how we can chain partial functions. If, after combining the different
    partial functions, we end up covering the whole possible input space, then it
    might make more sense to use pattern matching and a normal function. If we don't
    match all the possible values, however, we can get runtime exceptions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上会对负数进行平方，对正数进行平方根。从我们在本例中进行的操作的角度来看，这可能没有太多意义，但它展示了我们如何链式使用部分函数。如果我们结合不同的部分函数后，最终覆盖了整个可能的输入空间，那么使用模式匹配和普通函数可能更有意义。然而，如果我们没有匹配所有可能的值，我们可能会得到运行时异常。
- en: Implicit injection
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式注入
- en: We already saw implicits in a few places in this book. We used them in the type
    class design pattern and the pimp my library design pattern, and we also mentioned
    that they can be used for dependency injection. Implicits are also used for conversions
    from one type to another silently.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书的几个地方看到了隐式转换。我们在类型类设计模式和“改进我的库”设计模式中使用了它们，我们还提到它们可以用于依赖注入。隐式转换也用于从一种类型到另一种类型的无声转换。
- en: They are nothing more than some objects, values, or methods that the compiler
    knows about and injects for us into methods or places that need them. What we
    need to make sure is to make these implicits available to the scope of the methods
    that will use them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 它们只是编译器所知的某些对象、值或方法，编译器会为我们将它们注入到需要它们的方法或位置。我们需要确保的是，使这些隐式转换对将使用它们的方法的作用域可用。
- en: Implicit conversions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式转换
- en: 'We have already mentioned that implicits can be used for silent conversions.
    Sometimes, it might be useful to be able to assign a `Double` to an `Int` and
    not get an error. Other times, we might want to wrap an object of one type into
    another and take advantage of the methods the new one provides:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，隐式转换可以用于无声转换。有时，可能有用能够将`Double`赋值给`Int`而不出错。在其他时候，我们可能想要将一个类型的对象包装到另一个类型中，并利用新类型提供的方法：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code listing, we have a package object that defines a method,
    which converts a `Double` to `Int`. This will allow us to write and successfully
    compile the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码列表中，我们有一个包对象定义了一个方法，该方法将`Double`转换为`Int`。这将允许我们编写并成功编译以下代码：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We don't have to do anything extra, as long as the `ImplicitExamples` object
    is in the same package as our package object. Another alternative would be to
    define our implicit conversions inside an object and import the object in the
    scope we will need it in.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`ImplicitExamples`对象与我们的包对象在同一个包中，我们就不需要做任何额外的事情。另一种选择是在对象内部定义我们的隐式转换，并在我们需要它的作用域中导入该对象。
- en: 'We can even wrap types in new objects. There are some examples in the `LowPriorityImplicits`
    class that is part of Scala, which can convert strings to sequences and so on.
    Now, let''s add an implicit conversion that will convert a list of `Int` to a
    `String`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将类型包裹在新的对象中。Scala中的`LowPriorityImplicits`类中有一些示例，可以将字符串转换为序列等。现在，让我们添加一个将`Int`列表转换为`String`的隐式转换：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can use our implicit conversion in order to print a list of ASCII character
    codes as a `String`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的隐式转换来打印一个ASCII字符码列表作为`String`：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running this example will produce the following output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个示例将产生以下输出：
- en: '![](img/45d6f69e-a5de-431e-bb58-973850dcfa49.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45d6f69e-a5de-431e-bb58-973850dcfa49.png)'
- en: There are a lot of useful things which we might need implicit conversions for.
    They could help in separating our code nicely, but we should be careful not to
    overuse them because debugging could be problematic and the code's readability
    might suffer.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要隐式转换的有很多有用的东西。它们可以帮助我们很好地分离代码，但我们应该小心不要过度使用它们，因为调试可能会变得困难，代码的可读性可能会受到影响。
- en: Dependency injection using implicits
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐式转换进行依赖注入
- en: 'When we showed dependency injection using the cake design pattern, we also
    mentioned that it is possible to achieve it using implicits. The idea is that
    services are created in one place and then we can write methods that implicitly
    require what the services need. By now, you should have acquired enough knowledge
    to be able to get to the right solution alone, so here we will just show a subset
    of the big example we had previously:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展示了使用蛋糕设计模式的依赖注入时，我们还提到可以使用隐式转换来实现它。想法是服务在一个地方创建，然后我们可以编写需要服务的隐式方法。到现在为止，你应该已经获得了足够的知识，能够独立找到正确的解决方案，所以这里我们只展示之前的大例子的一部分：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After we have a model defined, we can create a `DatabaseService` as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了一个模型之后，我们可以创建一个`DatabaseService`，如下所示：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our database service does not depend on anything. It simply simulates that
    it reads something from a database. Now, let''s create a `UserService`, which
    will depend on the `DatabaseService`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库服务不依赖于任何东西。它只是模拟从数据库中读取某些内容。现在，让我们创建一个`UserService`，它将依赖于`DatabaseService`：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see from the signature of the only method the user service provides,
    it requires an instance of `DatabaseService` to be implicitly available. We can
    also explicitly pass one and override the one we have for the purpose of testing.
    Now that we have these services, we can wire them up:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从用户服务提供的唯一方法签名中看到的那样，它需要一个`DatabaseService`实例隐式可用。我们也可以显式传递一个，并覆盖我们用于测试的目的的现有实例。现在我们有了这些服务，我们可以将它们连接起来：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We have chosen to use a package object, but any object or class is fine, as
    long as we can import it wherever we need the object. Now, the use of our application
    is easy:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用包对象，但任何对象或类都可以，只要我们可以在需要对象的地方导入它。现在，我们应用程序的使用很简单：
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output will be the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是以下内容：
- en: '![](img/1aa5069e-846c-494f-9179-4787d6ec14a3.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1aa5069e-846c-494f-9179-4787d6ec14a3.png)'
- en: As you can see, now we have used less boilerplate code than in the cake design
    pattern. A drawback of this approach is the method signatures, which can get more
    complex when we have more dependencies. In real-world applications, there could
    be a huge amount of dependencies, and also code readability will be affected due
    to the implicit variables. A possible solution to this could be wrapping dependencies
    in objects and implicitly passing them instead. In the end, it's mostly a matter
    of personal preference as to which dependency injection strategy will be used,
    as the same things can be achieved with both.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在我们使用的样板代码比蛋糕设计模式少。这种方法的缺点是方法签名，当有更多依赖项时可能会变得更加复杂。在现实世界的应用中，可能会有大量的依赖项，而且由于隐式变量，代码可读性也会受到影响。可能的解决方案是将依赖项包装在对象中，并隐式传递它们。最后，关于使用哪种依赖注入策略，这主要是一个个人偏好的问题，因为两者都可以实现相同的事情。
- en: Testing with implicit dependency injection
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐式依赖注入进行测试
- en: Testing with implicit dependency injection is similar to testing with the cake
    design pattern. We can have a new object that creates mocks of the services and
    then makes them available to the test classes. When we want to use a concrete
    implementation of a service, we can just override it. We could also pass a dependency
    explicitly here.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隐式依赖注入进行测试与使用蛋糕设计模式进行测试相似。我们可以有一个新对象，它创建服务的模拟并使它们对测试类可用。当我们想要使用服务的具体实现时，我们只需覆盖它。我们也可以在这里显式传递一个依赖项。
- en: Duck typing
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Duck typing
- en: A significant part of the work of a developer is to minimize the amount of code
    duplication. There are multiple different approaches to do this, including inheritance,
    abstraction, generics, type classes, and so on. There are cases, however, where
    strongly typed languages will require some extra work in order to minimize some
    of the duplication. Let's imagine that we have a method that can read and print
    the contents of a file. If we have two different libraries that allow us to read
    a file, in order to use our method, we will have to make sure the methods that
    read the file somehow become the same type. One way would be by wrapping them
    in a class that implements a specific interface. Provided that in both the libraries
    the read method has the same signature, which could easily happen, Scala can use
    duck typing instead, and this way it will minimize the extra work we will have
    to do.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者的工作很大一部分是尽量减少代码重复。有多种不同的方法可以做到这一点，包括继承、抽象、泛型、类型类等等。然而，在某些情况下，强类型语言将需要一些额外的工作来最小化一些重复。让我们想象我们有一个可以读取并打印文件内容的方法。如果我们有两个不同的库允许我们读取文件，为了使用我们的方法，我们必须确保读取文件的方法以某种方式变得相同。一种方法是通过将它们包装在实现特定接口的类中来实现。假设在两个库中读取方法都有相同的签名，这很容易发生，Scala可以使用鸭子类型，这样就可以最小化我们不得不做的额外工作。
- en: Duck typing is a term that comes from dynamic languages and it allows us to
    treat different types of objects in a similar manner based on a common method
    they have.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Duck typing是一个来自动态语言的术语，它允许我们根据它们共有的一个方法以相似的方式处理不同类型的对象。
- en: Another name for duck typing is **structural typing**.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Duck typing的另一个名称是**结构化类型**。
- en: Duck typing example
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Duck typing示例
- en: 'Everything becomes clearer with an example. Let''s imagine that we want to
    have a method which can take a parser and print every word that the parser detects.
    Our parsers will have a method with the following signature:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个例子，一切都会变得清晰。让我们想象我们想要一个可以接受一个解析器并打印出解析器检测到的每个单词的方法。我们的解析器将有一个以下签名的方法：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A good way of doing this would be to have a common interface and make all the
    parsers implement it. However, let's set a condition that we cannot do this. The
    parsers could be coming from two different libraries where we cannot modify or
    connect in any way.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一个好方法是拥有一个公共接口，并让所有解析器实现它。然而，让我们设定一个条件，我们不能这样做。解析器可能来自两个不同的库，我们无法以任何方式修改或连接。
- en: 'We have defined two different parser implementations for this example. The
    first one is as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个例子定义了两种不同的解析器实现。第一个如下所示：
- en: '[PRE57]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This parser makes use of the `StringTokenizer` class and returns an array of
    all the words separated by spaces. Another implementation that does exactly the
    same is shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解析器使用了`StringTokenizer`类，并返回一个由空格分隔的所有单词组成的数组。另一个实现方式如下所示：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we just split the sentence using a regular expression for space.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是使用正则表达式按空格分割句子。
- en: 'As you can see, both the classes have a parse method with the same signature,
    but they have no connection with each other. We, however, want to be able to use
    them in a method and avoid code duplication. Here is how we can do this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个类都有一个具有相同签名的解析方法，但它们之间没有关联。然而，我们希望能够在方法中使用它们并避免代码重复。以下是我们可以这样做的方法：
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding code, we passed both the parsers to the `printSentenceParts`
    method and everything compiles and works fine. The reason things work is because
    of duck typing and this can be seen in the highlighted part of our example. The
    output of our application is the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将两个解析器都传递给了`printSentenceParts`方法，并且一切编译和运行正常。事情之所以能正常工作，是因为鸭子类型，这可以在我们示例的高亮部分中看到。我们应用程序的输出如下：
- en: '![](img/7ce57804-9bc9-4b25-9adc-03c7968c93c3.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ce57804-9bc9-4b25-9adc-03c7968c93c3.png)'
- en: We can use duck typing for requiring even more methods to be available for an
    object by just expanding the parameter signature.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过扩展参数签名来使用鸭子类型（duck typing）来要求对象有更多的方法可用。
- en: Duck typing alternatives
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸭子类型的替代方案
- en: As you can see from the preceding code, duck typing saves us from some extra
    code writing and the need to define common interfaces. Other ways to achieve the
    same would involve creating wrappers, which implement a common interface.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的那样，鸭子类型使我们免去了编写额外代码和定义通用接口的需要。实现相同目的的其他方法可能包括创建实现通用接口的包装器。
- en: When to use duck typing
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用鸭子类型
- en: Overusing duck typing can negatively affect code quality and application performance.
    You should not avoid creating common interfaces in favor of duck typing. It should
    be really only used in cases when we cannot implement a common interface between
    different types. The argument about limiting the use of duck typing is further
    enhanced by the fact that, under the hood, they use reflection, which is slower
    and negatively impacts performance.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 过度使用鸭子类型可能会对代码质量和应用程序性能产生负面影响。你不应该为了避免创建通用接口而使用鸭子类型。它应该真正只在无法在不同类型之间实现通用接口的情况下使用。关于限制鸭子类型使用的论点，还得到了这样一个事实的进一步强化，即它们在底层使用反射，这较慢且对性能产生负面影响。
- en: Memoization
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: Writing high-performance programs is usually a mixture of using good algorithms
    and the smart usage of computer processing power. Caching is one mechanism that
    can help us, especially when a method takes time to calculate or it's called a
    lot of times in our application.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高性能程序通常是将良好的算法与计算机处理能力的智能使用相结合。缓存是我们可以帮助的一种机制，尤其是在方法需要花费时间计算或在我们的应用程序中被频繁调用时。
- en: Memoization is a mechanism of recording a function result based on its arguments
    in order to reduce computation in consecutive calls.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是一种基于函数的参数记录其结果以减少连续调用中计算的方法。
- en: Along with saving CPU cycles, memoization can also be useful to minimize the
    application memory footprint by only having one instance of each result. Of course,
    for this entire mechanism to work, we need to have a function that always returns
    the same result when the same arguments are passed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节省CPU周期外，记忆化还可以通过只保留每个结果的单个实例来最小化应用程序的内存占用。当然，为了使整个机制正常工作，我们需要一个函数，当传递相同的参数时，它总是返回相同的结果。
- en: Memoization example
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化示例
- en: There are different ways to achieve memoization. Some of them use imperative
    programming styles and it's pretty straightforward to get to them. Here, we will
    show an approach which is more suitable for Scala.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 实现记忆化（memoization）的方式有很多。其中一些使用命令式编程风格，并且获取它们相对直接。在这里，我们将展示一个更适合Scala的方法。
- en: Let's imagine that we will need to hash strings millions of times. Each hashing
    takes some time, depending on the underlying algorithm, but if we store some results
    and reuse them for repeated strings, we can save some computation at the expense
    of having a table of results.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们将需要多次对字符串进行哈希处理。每次哈希处理都需要一些时间，这取决于底层算法，但如果我们存储一些结果并重复使用它们来处理重复的字符串，我们就可以在牺牲结果表的情况下节省一些计算。
- en: 'We will start with something as simple as this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下简单内容开始：
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding code is of a class that has a method called `md5`, which returns
    a hash of the string we pass to it. We have mixed in a trait called `Memoizer`,
    which has the following representation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个具有名为`md5`的方法的类，该方法返回我们传递给它的字符串的哈希值。我们混合了一个名为`Memoizer`的特质，其表示如下：
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding trait has a method called `memo`, which uses a mutable map to
    retrieve the result of a function based on its input parameters, or calls the
    actual function passed to it if the result is not already in the map. This method
    returns a new function, which actually uses the aforementioned map and has its
    results memoized.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的特质有一个名为 `memo` 的方法，该方法使用可变映射根据其输入参数检索函数的结果，或者如果结果不在映射中，则调用传递给它的实际函数。此方法返回一个新的函数，实际上使用上述映射并对其结果进行记忆化。
- en: The preceding memoizer example is potentially not thread safe. Multiple threads
    could access the map in parallel and cause the function to be executed twice.
    It's up to the developer to make sure thread safety is in place, if it's needed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的记忆化示例可能不是线程安全的。多个线程可能并行访问映射并导致函数被执行两次。如果需要，确保线程安全是开发者的责任。
- en: 'The fact that we have used generics means that we can actually use this method
    to create a memoized version of any one-parameter function. Now, we can go back
    to our `Hasher` class and add the following line:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了泛型的事实意味着我们可以实际上使用这种方法来创建任何单参数函数的记忆化版本。现在，我们可以回到我们的 `Hasher` 类并添加以下行：
- en: '[PRE62]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This makes `memoMd5` a function that does exactly what `md5` does, but uses
    a map internally to try and retrieve results that we have already calculated.
    We can now use our `Hasher` in the following way:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 `memoMd5` 函数确实与 `md5` 函数做相同的事情，但内部使用映射尝试检索我们已计算的结果。现在，我们可以用以下方式使用我们的 `Hasher`：
- en: '[PRE63]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output of this example will be as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出将如下所示：
- en: '![](img/b9f1df58-2794-4348-b385-3a9c71711af9.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9f1df58-2794-4348-b385-3a9c71711af9.png)'
- en: The preceding output proves that calling our memoized function for the same
    inputs actually retrieves the result from the map, instead of calling the part
    that processes the result again.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出证明，对于相同的输入调用我们的记忆化函数实际上是从映射中检索结果，而不是再次调用处理结果的代码部分。
- en: Memoization alternatives
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化替代方案
- en: 'The `memo` method that we showed previously is quite neat and easy to use,
    but it''s limiting. We can only get memoized versions of functions with one parameter
    (or we have to represent multiple parameters as a tuple). However, the Scalaz
    library already has support for memoization using the `Memo` object. We can simply
    do the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前展示的 `memo` 方法相当简洁且易于使用，但它有限制。我们只能获取具有一个参数的函数的记忆化版本（或者我们必须将多个参数表示为元组）。然而，Scalaz
    库已经通过 `Memo` 对象支持记忆化。我们可以简单地做以下操作：
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The preceding code can go into our `Hasher` class and then we can instead call
    `memoMd5Scalaz` in our example. This would not require us to write the extra `Memoizer`
    trait and it will produce absolutely the same result as what we showed previously.
    Moreover, the Scalaz version gives us much more flexibility in terms of the way
    we cache and so on.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以放入我们的 `Hasher` 类中，然后我们可以在示例中调用 `memoMd5Scalaz` 而不是编写额外的 `Memoizer` 特质。这将不需要我们编写额外的
    `Memoizer` 特质，并且会产生与之前展示完全相同的结果。此外，Scalaz 版本在缓存方式等方面给我们提供了更多的灵活性。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to apply some of the advanced concepts of the Scala
    programming language in order to tackle problems that commonly emerge in actual
    software projects. We looked at the lens design pattern, where we also had our
    first encounter with the brilliant Scalaz library. We saw how to implement dependency
    injection without any extra libraries in Scala, and what it is used for. We also
    learned how we can write extensions to the libraries which we don't have any modification
    access for. Last but not least, we looked at the type class design pattern, lazy
    evaluation in Scala, partial functions (also known as function currying), duck
    typing, memoization, and implicit injection. By now, you should have quite an
    extensive knowledge of the language possibilities of Scala as well as design patterns,
    which can be used together to write exceptional software.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何将 Scala 编程语言的某些高级概念应用于解决实际软件项目中常见的问题。我们探讨了透镜设计模式，在那里我们也首次接触到了卓越的
    Scalaz 库。我们看到了如何在 Scala 中实现依赖注入而无需任何额外库，以及它的用途。我们还学习了如何为我们没有修改权限的库编写扩展。最后但同样重要的是，我们研究了类型类设计模式、Scala
    中的懒加载、部分函数（也称为函数柯里化）、鸭子类型、记忆化和隐式注入。到目前为止，你应该对 Scala 的语言可能性以及设计模式有了相当广泛的知识，这些可以一起用来编写出色的软件。
- en: In the next and last chapter of this book, we will focus a bit more on the Scalaz
    library, and we will show its support for some of the concepts we have already
    seen. We will also go through a final project that will combine our knowledge
    into something that can be used as production code. Finally, we will briefly summarize
    the content covered in this book and give useful pointers.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章和最后一章中，我们将更加关注 Scalaz 库，并展示其对我们已经看到的一些概念的支持。我们还将完成一个最终项目，将我们的知识整合成可以用于生产代码的东西。最后，我们将简要总结本书涵盖的内容，并提供有用的指导。
