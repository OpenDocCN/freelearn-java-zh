- en: '*Chapter 5*: Implementing Domain Logic'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：实现领域逻辑'
- en: To communicate effectively, the code must be based on the same language used
    to write the requirements – the same language that the developers speak with each
    other and with domain experts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地沟通，代码必须基于编写需求所使用的相同语言——开发人员彼此之间以及与领域专家交流的语言。
- en: – Eric Evans
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 埃里克·埃文斯
- en: 'In the *Command Query Responsibility Segregation (CQRS)* section of the book,
    we described how DDD and CQRS complement each other and how the command side (write
    requests) is the home of business logic. In this chapter, we will implement the
    command-side API for the **Letter of Credit** (**LC**) application using Spring
    Boot, Axon Framework, JSR-303 bean validations, and persistence options by contrasting
    between state-stored and event-sourced aggregates. The list of topics to be covered
    is as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的*命令查询责任分离（CQRS）*部分，我们描述了领域驱动设计（DDD）和CQRS如何相互补充，以及命令端（写请求）是业务逻辑的家园。在本章中，我们将使用Spring
    Boot、Axon Framework、JSR-303 Bean验证和持久化选项，通过对比状态存储和事件源聚合来实现**信用证**（**LC**）应用的命令端API。以下是将要涵盖的主题列表：
- en: Identifying aggregates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别聚合
- en: Handling commands and emitting events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理命令和发布事件
- en: Test-driving the application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动应用程序
- en: Persisting aggregates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续聚合
- en: Performing validations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行验证
- en: By the end of this chapter, you will have learned how to implement the core
    of your system (the domain logic) in a robust, well-encapsulated manner. You will
    also learn how to decouple your domain model from persistence concerns. Finally,
    you will be able to appreciate how to perform DDD’s tactical design, using services,
    repositories, aggregates, entities, and value objects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会如何以稳健、封装良好的方式实现系统的核心（领域逻辑）。您还将学会如何将领域模型从持久化关注点中解耦。最后，您将能够欣赏如何使用服务、存储库、聚合、实体和值对象执行DDD的战略设计。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples in this chapter, you will need access to the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的示例，您需要访问以下内容：
- en: JDK 1.8+ (we have used Java 16 to compile sample sources)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+（我们使用 Java 16 编译示例源代码）
- en: Maven 3.x
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 3.x
- en: Spring Boot 2.4.x
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 2.4.x
- en: JUnit 5.7.x (included with Spring Boot)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5.7.x（包含在 Spring Boot 中）
- en: Axon Framework 4.4.7 (DDD and CQRS framework)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Axon Framework 4.4.7（DDD和CQRS框架）
- en: Project Lombok (to reduce verbosity)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Lombok（用于减少冗余）
- en: Moneta 1.4.x (money and currency reference implementation – JSR 354)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moneta 1.4.x（货币和货币参考实现——JSR 354）
- en: Continuing our design journey
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: 'In the previous chapter, we discussed eventstorming as a lightweight method
    to clarify business flows. As a reminder, this is the output produced from our
    eventstorming session:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了事件风暴作为一种轻量级的方法来阐明业务流程。作为提醒，这是我们的事件风暴会议产生的输出：
- en: '![Figure 5.1 – Recap of the eventstorming session'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 事件风暴会议回顾'
- en: '](img/B16716_05_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_05_02.jpg](img/B16716_05_02.jpg)'
- en: Figure 5.1 – Recap of the eventstorming session
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 事件风暴会议回顾
- en: As mentioned previously, the *blue* stickies in this diagram represent *commands*.
    We will be using the **Command Query Responsibility Segregation** (**CQRS**) pattern
    as a high-level architecture approach to implement the domain logic for our LC
    issuance application. Let’s examine the mechanics of using CQRS and how it can
    result in an elegant solution. For a recap of what CQRS is and when it is appropriate
    to apply this pattern, please refer to the *When to use CQRS* section in [*Chapter
    2*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037), *Where and How Does DDD Fit?*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此图中的*蓝色*便签代表*命令*。我们将使用**命令查询责任分离**（**CQRS**）模式作为高级架构方法来实现我们的LC发行应用的领域逻辑。让我们来探讨使用CQRS的机制以及它如何导致优雅的解决方案。有关CQRS是什么以及何时适用此模式的概述，请参阅[*第2章*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037)中的*何时使用CQRS*部分，“DDD如何适应？*”。
- en: Important Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: CQRS is by no means a silver bullet. Although it is general-purpose enough to
    be used in a variety of scenarios, it is a paradigm shift as applied to mainstream
    software problems. Like any other architecture decision, you should apply due
    diligence when choosing to adopt CQRS to your situation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS绝对不是万能的银弹。尽管它足够通用，可以在各种场景中使用，但它对主流软件问题来说是一种范式转变。像任何其他架构决策一样，在决定采用CQRS时，您应该进行适当的尽职调查。
- en: Let’s look at how this works in practice by implementing a representative sliver
    of the command side of the LC application using the Spring and Axon frameworks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用Spring和Axon框架实现LC应用程序命令侧的一个代表性片段来实际看看它是如何工作的。
- en: Implementing the command side
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现命令侧
- en: 'In this section, we will focus on implementing the command side of the application.
    This is where we expect all the business logic of the application to be implemented.
    Logically, it looks like the following figure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于实现应用程序的命令侧。这是我们预期应用程序的所有业务逻辑都将得到实现的地方。从逻辑上看，它看起来像以下图示：
- en: '![Figure 5.2 – Traditional versus CQRS architecture'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 传统与CQRS架构对比'
- en: '](img/B16716_05_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_05_01.jpg]'
- en: Figure 5.2 – Traditional versus CQRS architecture
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 传统与CQRS架构对比
- en: 'The high-level sequence on the command side is described here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 命令侧的高级序列在此描述：
- en: A request to mutate state (command) is received.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收到一个请求来修改状态（命令）。
- en: In an event-sourced system, the command model is constructed by replaying existing
    events that have occurred for that instance. In a state-stored system, we would
    simply restore state by reading state from the persistence store.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件源系统中，通过回放该实例已发生的事件来构建命令模型。在状态存储系统中，我们只需从持久化存储中读取状态来恢复状态。
- en: If business invariants (validations) are satisfied, one or more domain events
    are readied with the intention to be published.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果业务不变量（验证）得到满足，一个或多个领域事件将被准备好以供发布。
- en: In an event-sourced system, the domain event is persisted on the command side.
    In a state-stored system, we would update the state of the instance in the persistence
    store.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件源系统中，领域事件在命令侧被持久化。在状态存储系统中，我们会在持久化存储中更新实例的状态。
- en: The external world is notified by publishing these domain events onto an event
    bus. The event bus is an infrastructure component to which events are published.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将这些领域事件发布到事件总线上来通知外部世界。事件总线是一个基础设施组件，事件被发布到该组件上。
- en: Let’s look at how we can implement this in the context of our LC issuance application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在LC发行应用程序的上下文中实现这一点。
- en: Important Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We depict multiple read models because it is possible (but not necessary) to
    create more than one read model, depending on the kinds of query use cases that
    need to be supported.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描绘了多个读取模型，因为根据需要支持的查询用例类型，可能（但不一定）需要创建多个读取模型。
- en: For this to work predictably, the read model(s) need to be kept in sync with
    the write models (we will examine some of the techniques to do that in detail
    later).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过程能够可预测地工作，读取模型（们）需要与写入模型保持同步（我们将在稍后详细探讨一些实现这一点的技术）。
- en: Tooling choices
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具选择
- en: Implementing CQRS does not require the use of any framework. Greg Young, who
    is considered the father of the CQRS pattern, advises against rolling our own
    CQRS framework in the essay found at [https://ordina-jworks.github.io/domain-driven%20design/2016/02/02/A-Decade-Of-DDD-CQRS-And-Event-Sourcing.html](https://ordina-jworks.github.io/domain-driven%20design/2016/02/02/A-Decade-Of-DDD-CQRS-And-Event-Sourcing.html),
    which is worth taking a look at. Using a good framework can help enhance developer
    effectiveness and accelerate the delivery of business functionality, while abstracting
    the low-level plumbing and non-functional requirements without limiting flexibility.
    In this book, we will make use of Axon Framework ([http://axonframework.org/](http://axonframework.org/))
    to implement application functionality, as we have real-world experience in using
    it in large-scale enterprise development. There are other frameworks that work
    comparably, such as the Lagom framework ([https://www.lagomframework.com/](https://www.lagomframework.com/))
    and Eventuate ([https://eventuate.io/](https://eventuate.io/)), which are worth
    exploring as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实现CQRS不需要使用任何框架。被认为是CQRS模式之父的Greg Young在[https://ordina-jworks.github.io/domain-driven%20design/2016/02/02/A-Decade-Of-DDD-CQRS-And-Event-Sourcing.html](https://ordina-jworks.github.io/domain-driven%20design/2016/02/02/A-Decade-Of-DDD-CQRS-And-Event-Sourcing.html)这篇论文中建议不要自己构建CQRS框架，这篇论文值得一读。使用一个好的框架可以帮助提高开发者的效率并加速业务功能的交付，同时抽象出底层管道和非功能性需求，而不限制灵活性。在本书中，我们将使用Axon框架([http://axonframework.org/](http://axonframework.org/))来实现应用程序功能，因为我们有在大型企业开发中使用它的实际经验。还有其他一些工作得相当好的框架，如Lagom框架([https://www.lagomframework.com/](https://www.lagomframework.com/))和Eventuate([https://eventuate.io/](https://eventuate.io/))，也值得探索。
- en: Bootstrapping the application
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: To get started, let’s create a simple Spring Boot application. There are several
    ways to do this. You can always use the Spring starter application at [https://start.spring.io](https://start.spring.io)
    to create this application. Here, we will make use of the Spring CLI to bootstrap
    the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们创建一个简单的Spring Boot应用程序。有几种方法可以做到这一点。您始终可以使用[https://start.spring.io](https://start.spring.io)上的Spring启动应用程序来创建此应用程序。在这里，我们将使用Spring
    CLI来启动应用程序。
- en: Important Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To install the Spring CLI for your platform, please refer to the detailed instructions
    at [https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.installing](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.installing).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的平台安装Spring CLI，请参阅[https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.installing](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.installing)中的详细说明。
- en: 'To bootstrap the application, use the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动应用程序，请使用以下命令：
- en: '![](img/ch5-1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![img/ch5-1.jpg](img/ch5-1.jpg)'
- en: 'This should create a file named `lc-issuance-api.zip` in the current directory.
    Unzip this file to a location of your choice and add a dependency on Axon Framework
    in the `dependencies` section of the `pom.xml` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在当前目录中创建一个名为`lc-issuance-api.zip`的文件。将此文件解压缩到您选择的位置，并在`pom.xml`文件的`dependencies`部分添加Axon框架的依赖项：
- en: '![](img/ch5-2.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![img/ch5-2.jpg](img/ch5-2.jpg)'
- en: You may need to change the version. We are at version 4.5.3 at the time of writing
    this book.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能需要更改版本。本书编写时，我们处于4.5.3版本。
- en: 'Also, add the following dependency on the `axon-test` library to enable unit
    testing of aggregates:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加以下对`axon-test`库的依赖项以启用聚合的单元测试：
- en: '![](img/ch5-3.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![img/ch5-3.jpg](img/ch5-3.jpg)'
- en: With the preceding setup, you should be able to run the application and start
    implementing the LC issuance functionality.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的设置，您应该能够运行应用程序并开始实现LC发行功能。
- en: Let’s look at how to implement these commands using Axon Framework.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Axon框架实现这些命令。
- en: Identifying commands
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别命令
- en: 'From the eventstorming session in the previous chapter, we have the following
    commands to start with:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章的事件风暴会话中，我们有以下命令作为起点：
- en: '![Figure 5.3 – Identified commands'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 识别出的命令'
- en: '](img/B16716_05_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_05_03.jpg](img/B16716_05_03.jpg)'
- en: Figure 5.3 – Identified commands
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 识别出的命令
- en: Commands are always directed to an aggregate (the root entity) for processing
    (handling). This means that we need to resolve each of these commands to be handled
    by an aggregate. While the sender of the command does not care which component
    within the system handles it, we need to decide which aggregate will handle each
    command. It is also important to note that any given command can only be handled
    by a single aggregate within the system. Let’s look at how to group these commands
    and assign them to aggregates. To be able to do that, we need to identify the
    aggregates in the system first.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 命令总是针对聚合（根实体）进行处理（处理）。这意味着我们需要解决这些命令，以便由聚合处理。虽然命令的发送者不关心系统中的哪个组件处理它，但我们需要决定哪个聚合将处理每个命令。还应注意，任何给定的命令只能由系统中的单个聚合处理。让我们看看如何对这些命令进行分组并将它们分配给聚合。为了能够做到这一点，我们首先需要识别系统中的聚合。
- en: Identifying aggregates
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别聚合
- en: 'Looking at the output of the eventstorming session of our LC application, one
    potential grouping can be as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们LC应用的eventstorming会话的输出，一个潜在的分组可以如下所示：
- en: '![Figure 5.4 – First cut attempt at aggregate design'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 对聚合设计的第一次尝试'
- en: '](img/B16716_05_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_05_04.jpg](img/B16716_05_04.jpg)'
- en: Figure 5.4 – First cut attempt at aggregate design
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 对聚合设计的第一次尝试
- en: 'Some or all of these entities may be aggregates (For a more detailed explanation
    on the difference between aggregates and entities , please refer to [*Chapter
    1*](B16716_01_Final_NM_ePub.xhtml#_idTextAnchor015), *The Rationale for Domain-Driven
    Design*). At first glance, it appears that we have four potential entities to
    handle these commands:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实体中的某些或所有可能是聚合（有关聚合和实体的区别的更详细解释，请参阅[*第1章*](B16716_01_Final_NM_ePub.xhtml#_idTextAnchor015)，*领域驱动设计的原理*）。乍一看，我们似乎有四个潜在的实体来处理这些命令：
- en: '![Figure 5.5 – Potential aggregates at first glance'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 初次观察到的潜在聚合'
- en: '](img/B16716_05_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_05_05.jpg](img/B16716_05_05.jpg)'
- en: Figure 5.5 – Potential aggregates at first glance
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 初次观察到的潜在聚合
- en: 'At first glance, each of these entities may be classified as aggregates in
    our solution. Here, `LC Application` feels like a reasonably good choice for an
    aggregate, given that we are building a solution to manage LC applications. However,
    do the others make sense to be classified as such? `Product` and `Applicant` look
    like potential entities, but we need to ask ourselves whether we will need to
    operate on these outside of the purview of `LC Application`. If the answer is
    *yes*, then `Product` and `Applicant` *may* be classified as aggregates. But both
    `Product` and `Applicant` do not seem to require being operated on without an
    enveloping `LC Application` aggregate within this bounded context. It feels that
    way because both product and applicant details are required to be provided as
    part of the LC application process. At least from what we know of the process
    thus far, this seems to be true. This means that we are left with two potential
    aggregates – `LC` and `LC` `Application`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这些实体中的每一个都可能被分类为我们解决方案中的聚合。在这里，鉴于我们正在构建一个用于管理 LC 应用的解决方案，`LC 应用程序` 似乎是一个相当合适的聚合选择。然而，其他实体是否也适合被分类为聚合呢？`产品`
    和 `申请人` 看起来像潜在的实体，但我们需要问自己是否需要在 `LC 应用程序` 的范围之外对这些实体进行操作。如果答案是 *是*，那么 `产品` 和 `申请人`
    *可能* 被分类为聚合。但 `产品` 和 `申请人` 似乎不需要在没有包含在边界上下文中的 `LC 应用程序` 聚合的情况下进行操作。感觉是这样，因为产品和申请人的详细信息都需要作为
    LC 申请过程的一部分提供。至少从我们目前所了解的过程来看，这似乎是正确的。这意味着我们剩下两个潜在的聚合 – `LC` 和 `LC 应用程序`：
- en: '![Figure 5.6 – Relationship between bounded contexts'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 边界上下文之间的关系]'
- en: '](img/B16716_05_06.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16716_05_06.jpg]'
- en: Figure 5.6 – Relationship between bounded contexts
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 边界上下文之间的关系]'
- en: When we look at the output of our eventstorming session, the `LC Application`
    aggregate transitions to become an `LC` aggregate much later in the life cycle.
    Let’s work on the `LC Application` right now and suspend further analysis on the
    need for an `LC` aggregate to a later time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们的事件风暴会议输出时，`LC 应用程序` 聚合在生命周期中较晚转变为 `LC` 聚合。现在让我们专注于 `LC 应用程序`，并将对 `LC`
    聚合需求的进一步分析推迟到以后。
- en: Important Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Colloquially, the terms aggregate and aggregate root are sometimes used interchangeably
    to mean the same thing. Aggregates can be hierarchical, and it is possible for
    aggregates to contain child aggregates. While both aggregates and aggregate roots
    handle commands, only one aggregate can exist as the root in a given context,
    and it encapsulates access to its child aggregates, entities and value objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通俗地说，术语聚合和聚合根有时可以互换使用，意思相同。聚合可以是分层的，并且聚合可以包含子聚合。虽然聚合和聚合根都处理命令，但在给定上下文中只能有一个聚合作为根，它封装了对其子聚合、实体和值对象的访问。
- en: It is important to note that entities may be required to be treated as aggregates
    in a different bounded context and this kind of treatment is entirely context
    dependent.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，实体可能需要在不同的边界上下文中被视为聚合，这种处理完全取决于上下文。
- en: When we look at the output of our eventstorming session, the LC Application
    transitions to become an LC much later in the lifecycle in the Issuance context.
    Our focus right now is to optimize and automate the LC application flow of the
    overall issuance process. Now that we have settled on working with the LC Application
    aggregate (root), let’s start writing our first command to see how this manifests
    itself in code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们的事件风暴会议输出时，LC 应用程序在发行上下文中在生命周期中较晚转变为 LC。我们现在的重点是优化和自动化整个发行流程的 LC 应用程序流程。既然我们已经决定与
    LC 应用程序聚合（根）合作，让我们开始编写我们的第一个命令，看看它在代码中是如何体现的。
- en: Test-driving the system
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动系统
- en: While we have a reasonably good conceptual understanding of the system, we are
    still in the process of refining this understanding. Test-driving the system allows
    us to exercise our understanding by acting as the first client of the solution
    that we are producing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们对系统有一个相当好的概念性理解，但我们仍在不断细化这种理解。通过测试驱动系统，我们可以通过充当我们正在生产的解决方案的第一个客户来锻炼我们的理解。
- en: Important Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The practice of test-driving the system is very well illustrated in the best-selling
    book *Growing Object-Oriented Software, Guided by Tests* by authors Nat Price
    and Steve Freeman. This is worth looking at to gain a deeper understanding of
    this practice.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动系统的实践在畅销书《由测试引导的面向对象软件开发》中得到了很好的阐述，作者是 Nat Price 和 Steve Freeman。阅读这本书以深入了解这一实践是值得的。
- en: 'So, let’s start with the first test. To the external world, an event-driven
    system typically works in a manner depicted in the following figure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从第一个测试开始。对于外部世界来说，一个事件驱动系统通常以以下图示的方式进行工作：
- en: '![Figure 5.7 – An event-driven system'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 事件驱动系统'
- en: '](img/B16716_05_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_05_07.jpg)'
- en: Figure 5.7 – An event-driven system
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 事件驱动系统
- en: 'This figure can be explained as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图示可以这样解释：
- en: An optional set of domain events may have occurred in the past.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能已经发生了一组可选的领域事件。
- en: A command is received by the system (initiated manually by a user or automatically
    by a part of the system), which acts as a stimulus.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统接收到一个命令（由用户手动发起或由系统的一部分自动发起），它充当刺激。
- en: The command is handled by an aggregate, which then proceeds to validate the
    received command to enforce invariants (structural and domain validations).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令由一个聚合体处理，然后继续验证接收到的命令以强制执行不变性（结构性和领域验证）。
- en: 'The system then reacts in one of two ways:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统随后以两种方式之一做出反应：
- en: Emit one or more events.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发射一个或多个事件。
- en: Throw an exception.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出异常。
- en: Important Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code snippets shown in this chapter are excerpts to highlight significant
    concepts and techniques. For the full working example, please refer to the accompanying
    source code for this chapter (included in the `ch05` directory).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码片段是为了突出显著的概念和技术。对于完整的示例，请参阅本章附带源代码（包含在 `ch05` 目录中）。
- en: 'Axon Framework allows us to express tests in the following form:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Axon 框架允许我们以下形式表达测试：
- en: '![](img/ch5-4.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch5-4.jpg)'
- en: '`FixtureConfiguration` is an Axon Framework utility to aid the testing of aggregate
    behavior using a BDD-style given-when-then syntax.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FixtureConfiguration` 是 Axon 框架的一个实用工具，用于帮助使用 BDD 风格的给定-当-然后语法测试聚合行为。'
- en: '`AggregateTestFixture` is a concrete implementation of `FixtureConfiguration`
    where you need to register your aggregate class – in our case, `LCApplication`
    is the candidate to handle commands directed to our solution.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AggregateTestFixture` 是 `FixtureConfiguration` 的具体实现，其中您需要注册您的聚合类 – 在我们的情况下，`LCApplication`
    是处理指向我们解决方案的命令的候选者。'
- en: Since this is the start of the business process, there are no events that have
    occurred thus far. This is signified by the fact that we do not pass any arguments
    to the given method. In other examples we will discuss later, there will likely
    be events that have already occurred prior to receiving this command.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是业务流程的开始，到目前为止还没有发生任何事件。这一点通过我们没有向给定方法传递任何参数来表示。在稍后讨论的示例中，可能会在接收到此命令之前已经发生了一些事件。
- en: This is where we instantiate a new instance of the command object. Command objects
    are usually similar to data transfer objects, carrying a set of information. This
    command will be routed to our aggregate for handling. We will take a look at how
    this works in detail shortly.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们实例化命令对象的新实例的地方。命令对象通常类似于数据传输对象，携带一组信息。这个命令将被路由到我们的聚合体进行处理。我们将在稍后详细查看这是如何工作的。
- en: Here, we are declaring that we expect events matching an exact sequence.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们声明我们期望匹配确切序列的事件。
- en: Here, we are expecting an event of the `LCApplicationCreated` type to be emitted
    as a result of successfully handling the command.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们期望在成功处理命令后发射一个 `LCApplicationCreated` 类型的事件。
- en: We are finally saying that we do not expect any more events, which means that
    we expect exactly one event to be emitted.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终表示我们不期望有更多的事件，这意味着我们期望恰好发射一个事件。
- en: Implementing the command
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现命令
- en: '`CreateLCApplicationCommand` in the previous simplistic example does not carry
    any state. Realistically, the command will likely look something like what is
    depicted as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的简单示例中，`CreateLCApplicationCommand` 不携带任何状态。现实中，命令可能看起来像以下所示：
- en: '![](img/ch5-5.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch5-5.jpg)'
- en: This is the command class. When naming commands, we typically use an imperative
    style; that is, they usually begin with a verb denoting the action required. Note
    that this is a data transfer object. In other words, it is simply a bag of data
    attributes. Also note how it is devoid of any logic (at least at the moment).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是命令类。在命名命令时，我们通常使用祈使句风格；也就是说，它们通常以一个表示所需动作的动词开头。请注意，这是一个数据传输对象。换句话说，它只是一个数据属性袋。同时请注意，它没有任何逻辑（至少目前是这样）。
- en: This is the identifier for the LC application. We are assuming client-generated
    identifiers in this case. The topic of using server-generated versus client-generated
    identifiers is out of scope for the subject of this book. You may use either,
    depending on what is advantageous in your context. Also note that we are using
    a strong type for the `LCApplicationId` identifier as opposed to a primitive type,
    such as a numeric or a string value. It is also common in some cases to use UUIDs
    as an identifier. However, we prefer using strong types to be able to differentiate
    between identifier types. Note how we are using a `ClientId` type to represent
    the creator of the application.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是LC应用程序的标识符。在这种情况下，我们假设使用客户端生成的标识符。关于使用服务器生成标识符与客户端生成标识符的主题超出了本书的范围。你可以根据你的上下文优势选择使用其中之一。此外，请注意，我们使用强类型`LCApplicationId`标识符，而不是原始类型，如数值或字符串值。在某些情况下，使用UUID作为标识符也很常见。然而，我们更喜欢使用强类型来区分标识符类型。注意我们是如何使用`ClientId`类型来表示应用程序的创建者的。
- en: The `Party` and `AdvisingBank` types are complex types to represent those concepts
    in our solution. Care should be taken to consistently use names that are relevant
    in the problem (business) domain as opposed to using names that only make sense
    in the solution (technology) domain. Note the attempt to make use of the ubiquitous
    language of the domain experts in both cases. This is a practice that we should
    always be conscious of when naming things in the system.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Party`和`AdvisingBank`类型是我们解决方案中代表这些概念的复杂类型。应小心使用与问题（业务）领域相关的名称，而不是使用仅在解决方案（技术）领域有意义的名称。注意在两种情况下都尝试使用领域专家的通用语言。这是我们命名系统中的事物时应该始终意识到的实践。'
- en: It is worth noting that `merchandiseDescription` is left as a primitive `String`
    type. This may feel contradictory to the commentary we presented previously. We
    will address this in the upcoming *Structural validations* section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`merchandiseDescription`被保留为原始的`String`类型。这可能与之前我们提出的评论相矛盾。我们将在接下来的*结构验证*部分解决这个问题。
- en: Now, let’s see what the event we will emit as a result of successfully processing
    the command will look like.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看成功处理命令后我们将发出的事件将是什么样子。
- en: Implementing the event
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现事件
- en: 'In an event-driven system, mutating system state by successfully processing
    a command usually results in a domain event being emitted to signal the state
    mutation to the rest of the system. A simplified representation of a real-world
    `LCApplicationCreatedEvent` event is shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动系统中，通过成功处理命令来改变系统状态通常会导致域事件被发出，以向系统的其余部分信号状态的变化。这里展示了现实世界中的`LCApplicationCreatedEvent`事件的简化表示：
- en: '![](img/ch5-6.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-6.jpg)'
- en: When naming events, we typically use names in the past tense to denote things
    that have already occurred and are to be accepted unconditionally as empirical
    facts that cannot be changed.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当命名事件时，我们通常使用过去时态的名称来表示已经发生并且无条件接受为无法改变的经验事实。
- en: You will likely notice that the structure of the event is currently identical
    to that of the command. While this is true in this case, it may not always be
    that way. The amount of information that we choose to disclose in an event is
    context-dependent. It is important to consult with domain experts when publishing
    information as part of events. You may choose to withhold certain information
    in the event payload. For example, consider `ChangePasswordCommand`, which contains
    the newly changed password. It might be prudent to not include the changed password
    in the resulting `PasswordChangedEvent`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，事件的结构目前与命令的结构完全相同。虽然在这个案例中这是正确的，但并不总是这样。我们在事件中选择的披露信息量是上下文相关的。在将信息作为事件的一部分发布时，与领域专家进行咨询非常重要。你可能会选择在事件有效负载中保留某些信息。例如，考虑`ChangePasswordCommand`，它包含新更改的密码。可能明智的做法是不在结果`PasswordChangedEvent`中包含更改后的密码。
- en: We have looked at the command and the resulting event in the previous test.
    Let’s look at how this is implemented under the hood by looking at the aggregate
    implementation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的测试中，我们已经看到了命令和结果事件。让我们通过查看聚合实现来了解这是如何实现的。
- en: Designing the aggregate
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计聚合
- en: 'The aggregate is the place where commands are handled and events are emitted.
    The good thing about the test that we have written is that it is expressed in
    a manner that hides the implementation details. But let’s look at the implementation
    to be able to appreciate how we can get our tests to pass and meet the business
    requirement:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是处理命令和发出事件的场所。我们编写的测试的好处是它以一种隐藏实现细节的方式表达。但让我们看看实现，以便能够欣赏我们如何让测试通过并满足业务需求：
- en: '![](img/ch5-7.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-7.jpg)'
- en: This is the aggregate identifier for the `LCApplication` aggregate. For an aggregate,
    the identifier uniquely identifies one instance from another. For this reason,
    all aggregates are required to declare an identifier and mark it to use the `@AggregateIdentifier`
    annotation provided by the framework.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`LCApplication`聚合体的聚合标识符。对于聚合体，标识符唯一地标识了一个实例与另一个实例的不同。因此，所有聚合体都需要声明一个标识符，并使用框架提供的`@AggregateIdentifier`注解将其标记为使用。
- en: The method that is handling the command needs to be annotated with the `@CommandHandler`
    annotation. In this case, the command handler happens to be the constructor of
    the class, given that this is the first command that can be received by this aggregate.
    We will see examples of subsequent commands being handled by other methods later
    in the chapter.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理命令的方法需要使用`@CommandHandler`注解进行标注。在这种情况下，命令处理器恰好是这个类的构造函数，因为这是这个聚合体可以接收的第一个命令。我们将在本章后面看到后续命令由其他方法处理的示例。
- en: The `@CommandHandler` annotation marks a method as being a command handler.
    The exact command that this method can handle needs to be passed as a parameter
    to the method. Note that there can only be one command handler in the entire system
    for any given command.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@CommandHandler`注解将一个方法标记为命令处理器。这个方法可以处理的确切命令需要作为参数传递给方法。请注意，对于任何给定的命令，整个系统中只能有一个命令处理器。'
- en: Here, we are emitting `LCApplicationCreatedEvent` using the `AggregateLifecycle`
    utility provided by the framework. In this very simple case, we are emitting an
    event unconditionally on receipt of the command. In a real-world scenario, it
    is conceivable that a set of validations will be performed before deciding to
    either emit one or more events, or failing the command with an exception. We will
    look at more realistic examples later in the chapter.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用框架提供的`AggregateLifecycle`实用工具发出`LCApplicationCreatedEvent`。在这个非常简单的例子中，我们在收到命令后无条件地发出一个事件。在现实世界的场景中，在决定发出一个或多个事件或用异常失败命令之前，可能需要执行一系列验证。我们将在本章后面查看更实际的示例。
- en: The need for `@EventSourcingHandler` and its role is likely very unclear at
    this time. We will explain the need for this in detail in an upcoming section
    of this chapter.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，`@EventSourcingHandler`的需求及其作用可能非常不清楚。我们将在本章的后续部分详细解释这一需求。
- en: This was a whirlwind introduction to a simple event-driven system. We still
    need to understand the role of `@EventSourcingHandler`. To understand that, we
    will need to appreciate how aggregate persistence works and the implications it
    has on our overall design.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对一个简单事件驱动系统的快速介绍。我们仍然需要理解`@EventSourcingHandler`的作用。为了理解这一点，我们需要欣赏聚合持久化的工作方式及其对我们整体设计的影响。
- en: Persisting aggregates
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合持久化
- en: 'When working with any system of even moderate complexity, we are required to
    make interactions durable; that is, interactions need to outlast system restarts,
    crashes, and so on. So the need for persistence is a given. While we should always
    endeavor to abstract persistence concerns from the rest of the system, our persistence
    technology choices can have a significant impact on the way we architect our overall
    solution. We have a couple of choices in terms of how we choose to persist aggregate
    state that are worth mentioning:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当与任何具有适度复杂性的系统一起工作时，我们需要确保交互持久化；也就是说，交互需要超越系统重启、崩溃等情况。因此，持久化的需求是既定的。虽然我们应该始终努力将持久化关注点从系统的其余部分抽象出来，但我们的持久化技术选择可能会对我们整体解决方案的架构产生重大影响。在如何选择持久化聚合状态方面，我们有几个选择值得提及：
- en: State-stored
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态存储
- en: Event-sourced
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件源
- en: Let’s examine each of these techniques in more detail in the following sections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几节中更详细地检查这些技术。
- en: State-stored aggregates
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态存储聚合
- en: 'Saving current values of entities is by far the most popular way to persist
    state – thanks to the immense popularity of relational databases and `LCApplication`,
    it is conceivable that we could use a relational database with a structure that
    would look something like the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 保存实体的当前值到目前为止仍然是持久化状态的最流行方式——得益于关系数据库和 `LCApplication` 的巨大普及，我们可以设想使用一个结构类似于以下的关系数据库：
- en: '![Figure 5.8 – Typical entity relationship model'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – 典型的实体关系模型'
- en: '](img/B16716_05_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_05_08.jpg](img/B16716_05_08.jpg)'
- en: Figure 5.8 – Typical entity relationship model
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 典型的实体关系模型
- en: Irrespective of whether we choose to use a relational database or a more modern
    NoSQL store – for instance, a document store, key-value store, column family store,
    and so on – the style we use to persist information remains more or less the same,
    which is to store the current values of the attributes of the said aggregate/entity.
    When the values of attributes change, we simply overwrite old values with newer
    ones; that is, we store the current state of aggregates and entities – hence the
    name *state-stored*. This technique has served us very well over the years, but
    there is at least one more mechanism that we can use to persist information. We
    will look at this in more detail next.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择使用关系数据库还是更现代的 NoSQL 存储——例如，文档存储、键值存储、列族存储等等——我们用来持久化信息的风格基本上保持不变，即存储该聚合/实体的属性当前值。当属性值发生变化时，我们只需用新的值覆盖旧值；也就是说，我们存储聚合和实体的当前状态——因此得名
    *状态存储*。这种技术在过去的几年里一直为我们服务得很好，但至少还有另一种机制我们可以用来持久化信息。我们将在下一节更详细地探讨这一点。
- en: Event-sourced aggregates
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件源聚合
- en: Developers have also been relying on logs for a variety of diagnostic purposes
    for a very long time. Similarly, relational databases have been employing commit
    logs to store information durably almost since their inception. However, developers’
    use of logs as a first-class persistence solution for structured information in
    mainstream systems remains extremely rare.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者已经非常长时间以来一直在依赖日志来完成各种诊断目的。同样，关系数据库几乎从诞生之初就开始使用提交日志来持久化存储信息。然而，在主流系统中，开发者将日志作为结构化信息的首选持久化解决方案的使用仍然极为罕见。
- en: 'A log is an extremely simple, append-only sequence of immutable records ordered
    by time. The diagram here illustrates the structure of a log where records are
    written sequentially. In essence, a log is an append-only data structure, as depicted
    here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是一个极其简单、只追加且不可变的按时间顺序排列的记录序列。这里的图展示了记录按顺序写入的日志结构。本质上，日志是一个只追加的数据结构，如图所示：
- en: '![Figure 5.9 – The log data structure'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – 日志数据结构'
- en: '](img/B16716_05_09.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_05_09.jpg](img/B16716_05_09.jpg)'
- en: Figure 5.9 – The log data structure
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 日志数据结构
- en: 'Writing to a log compared to a more complex data structure such as a table
    is a relatively simple and fast operation, and can handle extremely high volumes
    of data while providing predictable performance. Indeed, a modern event-streaming
    platform such as Apache Kafka makes use of this pattern to scale to support extremely
    high volumes. We do feel that this can be applied to act as a persistence store
    when processing commands in mainstream systems because this has benefits beyond
    the technical advantages listed previously. Consider the example of an online
    order flow shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与比表等更复杂的数据结构相比，写入日志是一个相对简单且快速的操作，并且可以处理极大量的数据，同时提供可预测的性能。确实，现代事件流平台如 Apache
    Kafka 就利用这种模式来扩展以支持极大量的数据。我们确实觉得这可以应用于在主流系统中处理命令时作为持久化存储，因为这具有超出之前列出的技术优势。考虑以下这里展示的在线订单流程示例：
- en: '![](img/B16716_05_Table_01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![img/B16716_05_Table_01.jpg](img/B16716_05_Table_01.jpg)'
- en: As you can see, in the event store, we continue to have full visibility of all
    user actions performed. This allows us to reason about these behaviors more holistically.
    In the traditional store, we lost the information that the user replaced white
    with wheat bread. While this does not impact the order itself, we lose the opportunity
    to gather insights from this user behavior. We recognize that this information
    can be captured in other ways using specialized analytical solutions; however,
    the event log mechanism provides a natural way to do this without requiring any
    additional effort. It also acts as an audit log, providing a full history of all
    events that have occurred thus far. This fits well with the essence of domain-driven
    design, where we are constantly exploring ways in which to reduce complexity.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在事件存储中，我们继续对所有用户执行的操作保持全面可见。这使我们能够更全面地推理这些行为。在传统存储中，我们失去了用户将白面包替换为小麦面包的信息。虽然这本身不影响订单，但我们失去了从这一用户行为中获取洞察的机会。我们认识到，这种信息可以通过其他方式使用专门的分析解决方案来捕获；然而，事件日志机制提供了一种无需额外努力的自然方式来完成这项工作。它还充当审计日志，提供迄今为止发生的所有事件的完整历史。这与领域驱动设计的本质非常吻合，我们不断探索减少复杂性的方法。
- en: 'However, there are implications to persisting data in the form of a simple
    event log. Before processing any command, we will need to hydrate past events
    in the exact order of occurrence and reconstruct the aggregate state to allow
    us to perform validations. For example, when confirming checkout, just having
    the ordered set of elapsed events will not suffice. We still need to compute the
    exact items that are in the cart before allowing the order to be placed. This
    *event replay* to restore aggregate state (at least those attributes that are
    required to validate said command) is necessary before processing that command.
    For example, we need to know which items are in the cart currently before processing
    `RemoveItemFromCartCommand`. This is illustrated in the following table:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以简单事件日志的形式持久化数据有一些影响。在处理任何命令之前，我们需要按照发生顺序恢复过去的事件，并重建聚合状态，以便我们能够执行验证。例如，在确认结账时，仅仅有已过期的事件集合是不够的。我们仍然需要在允许下单之前计算出购物车中确切的商品。在处理该命令之前，这种*事件回放*以恢复聚合状态（至少是那些需要验证该命令的属性）是必要的。例如，在处理`RemoveItemFromCartCommand`之前，我们需要知道当前购物车中包含哪些商品。这在下表中得到了说明：
- en: '![](img/B16716_05_Table_02.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16716_05_Table_02.jpg)'
- en: 'The corresponding source code for the whole scenario is illustrated in the
    following code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 整个场景的对应源代码在以下代码片段中展示：
- en: '![](img/ch5-8.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-8.jpg)'
- en: Before processing any command, the aggregate loading process commences by first
    invoking the no-args constructor. For this reason, we need the no-args constructor
    to be `state`. Restoration of `state` *must* happen only in those methods that
    trigger an event replay. In the case of Axon Framework, this translates to methods
    embellished with the `@EventSourcingHandler` annotation.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理任何命令之前，聚合加载过程首先通过调用无参构造函数开始。因此，我们需要无参构造函数是`状态`。`状态`的恢复*必须*只发生在触发事件回放的那些方法中。在Axon框架的情况下，这相当于带有`@EventSourcingHandler`注解的方法。
- en: It is important to note that it is possible (but not necessary) to emit `AddItemCommand`
    in the previous code where we emit `CartCreatedEvent` and `ItemAddedEvent`. Command
    handlers do not mutate the state of the aggregate. They only make use of the existing
    aggregate state to enforce invariants (validations) and emit events if those invariants
    hold `true`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要的是要注意，在之前的代码中，在发出`CartCreatedEvent`和`ItemAddedEvent`的地方发出`AddItemCommand`是可能的（但不是必需的）。命令处理器不会改变聚合的状态。它们只利用现有的聚合状态来强制执行不变性（验证）并在这些不变性为`true`时发出事件。
- en: The loading process continues through the invocation of event-sourcing handler
    methods in exactly the order of occurrence for that aggregate instance. Event-sourcing
    handlers are only needed to hydrate aggregate state on the basis of past events.
    This means that they usually are devoid of any business (conditional) logic. It
    goes without saying that these methods do not emit any events. Event emission
    is restricted to happen within command handlers when invariants are successfully
    enforced.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载过程通过调用事件源处理器方法按发生顺序继续进行，这些方法针对该聚合实例。事件源处理器仅需要根据过去的事件来恢复聚合状态。这意味着它们通常不包含任何业务（条件）逻辑。不言而喻，这些方法不会发出任何事件。事件发射仅限于在强制执行不变性成功时在命令处理器中发生。
- en: 'When working with event-sourced aggregates, it is very important to be disciplined
    about the kind of code that one can write:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当与事件源聚合一起工作时，非常重要的一点是要对可以编写的代码类型保持纪律性：
- en: '![](img/B16716_05_Table_03.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16716_05_Table_03.jpg)'
- en: If there is a large number of historic events to restore state, the aggregate
    loading process can become a time-consuming operation – directly proportional
    to the number of elapsed events for that aggregate. There are techniques (such
    as event snapshotting) we can employ to overcome this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有大量历史事件需要恢复状态，聚合加载过程可能会变得耗时——直接与该聚合已过事件的数量成正比。我们可以采用一些技术（如事件快照）来克服这一点。
- en: Persistence technology choices
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化技术选择
- en: If you are using a state store to persist your aggregates, using your usual
    evaluation process for choosing your persistence technology should suffice. However,
    if you are looking at event-sourced aggregates, the decision can be a bit more
    nuanced. In our experience, even a simple relational database can do the trick.
    Indeed, we once made use of a relational database to act as an event store for
    a high-volume transactional application with billions of events. This setup worked
    just fine for us. It is worth noting that we were only using the event store to
    insert new events and loading events for a given aggregate in sequential order.
    However, there is a multitude of specialized technologies that have been purpose-built
    to act as an event store that supports several other value-added features, such
    as time travel, full event replay, event payload introspection, and so on. If
    you have such requirements, it might be worth considering other options, such
    as NoSQL databases (document stores such as MongoDB or column family stores such
    as Cassandra) or purpose-built commercial offerings, such as EventStoreDB and
    Axon Server, to evaluate feasibility in your context.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用状态存储来持久化你的聚合，使用你通常的评估过程来选择你的持久化技术应该足够。然而，如果你正在查看事件源聚合，决策可能会更加微妙。根据我们的经验，即使是简单的关系型数据库也能做到这一点。事实上，我们曾经使用关系型数据库作为具有数十亿事件的超大规模事务性应用的事件存储。这种设置对我们来说效果很好。值得注意的是，我们只使用了事件存储来插入新事件和按顺序加载给定聚合的事件。然而，有许多专门构建来作为事件存储的技术，它们支持其他增值功能，如时间旅行、完整事件回放、事件负载内省等。如果你有这样的需求，考虑其他选项可能值得，例如NoSQL数据库（如MongoDB这样的文档存储或如Cassandra这样的列族存储）或专门构建的商业产品，如EventStoreDB和Axon
    Server，以评估在你的环境中是否可行。
- en: Which persistence mechanism should we choose?
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应该选择哪种持久化机制？
- en: 'Now that we have a reasonably good understanding of the two types of aggregate
    persistence mechanisms (state-stored and event-sourced), it begs the question
    of which one we should choose. We list a few benefits of using event sourcing
    here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对两种聚合持久化机制（状态存储和事件源）有了相当好的理解，这就引出了我们应该选择哪一种的问题。我们在此列出使用事件源的一些好处：
- en: We get to use the events as a **natural audit log** in high-compliance scenarios.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在高合规性场景中将事件用作**自然审计日志**。
- en: It provides the ability to perform **more insightful analytics** on the basis
    of the fine-grained events data.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了在细粒度事件数据的基础上执行**更深入的分析**的能力。
- en: It arguably produces more flexible designs when we work with a system based
    on **immutable events**, because the complexity of the persistence model is capped.
    Also, there is no need to deal with complex ORM impedance mismatch problems.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们与基于**不可变事件**的系统一起工作时，这可能会产生更灵活的设计，因为持久化模型的复杂性受到限制。此外，我们无需处理复杂的ORM阻抗不匹配问题。
- en: The domain model is much more **loosely coupled** with the persistence model,
    enabling it to evolve mostly independently from the persistence model.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域模型与持久化模型之间的耦合更加**松散**，使其能够主要独立于持久化模型而演进。
- en: It enables going back in time to be able to create **ad hoc views and reports**
    without having to deal with upfront complexity.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得能够回到过去，以便能够创建**临时视图和报告**，而无需处理前置复杂性。
- en: 'On the flip side, these are some challenges that you might have to consider
    when implementing an event-sourced solution:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，在实施基于事件源解决方案时，你可能需要考虑以下一些挑战：
- en: Event sourcing requires a **paradigm shift**, which means that development and
    business teams will have to spend time and effort understanding how it works.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件源需要**范式转变**，这意味着开发和业务团队将不得不花费时间和精力去理解它是如何工作的。
- en: The persistence model does not store state directly. This means that **ad hoc
    querying** directly on the persistence model can be a lot more **challenging**.
    This can be alleviated by materializing new views; however, there is added complexity
    in doing that.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化模型不直接存储状态。这意味着在持久化模型上直接进行**临时查询**可能会更加**具有挑战性**。这可以通过实现新的视图来缓解；然而，这样做会增加复杂性。
- en: Event sourcing usually tends to work very well when implemented in conjunction
    with CQRS, which arguably may add more complexity to the application. It also
    requires applications to pay closer attention to **strong versus eventual consistency**
    concerns.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件源通常在结合CQRS实现时工作得非常好，这可能会给应用程序增加更多的复杂性。它还要求应用程序更加关注**强一致性 versus 最终一致性**的问题。
- en: Our experiences indicate that event-sourced systems bring a lot of benefits
    in modern event-driven systems. However, you will need to be cognizant of the
    considerations presented previously in the context of your own ecosystems when
    making persistence choices.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的经验表明，事件源系统在现代事件驱动系统中带来了许多好处。然而，在做出持久化选择时，你需要意识到在你自己的生态系统中所提出的先前考虑。
- en: Enforcing policies
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制执行策略
- en: 'When processing commands, we need to enforce policies or rules. Policies come
    in two broad categories:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理命令时，我们需要强制执行策略或规则。策略分为两大类：
- en: Structural rules – those that enforce that the syntax of the dispatched command
    is valid
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构性规则 – 那些强制执行已发送命令的语法有效性的规则
- en: Domain rules – those that enforce that business rules are adhered to
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域规则 – 那些强制执行业务规则得到遵守的规则
- en: It may also be prudent to perform these validations in different layers of the
    system. And it is also common for some or all of these policy enforcements to
    be repeated in more than one layer of the system. However, the important thing
    to note is that before a command is successfully handled, all these policy enforcements
    are uniformly applied. Let’s look at some examples of these in the upcoming section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统的不同层执行这些验证也可能是明智的。而且，在系统的多个层中重复执行这些策略强制也是常见的。然而，重要的是要注意，在命令成功处理之前，所有这些策略强制都是统一应用的。让我们在接下来的部分中看看这些示例。
- en: Structural validations
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构性验证
- en: Currently, to create an LC application, you are required to dispatch `CreateLCApplicationCommand`.
    While the command dictates a structure, none of it is enforced at the moment.
    Let’s correct that.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，要创建LC应用程序，你需要发送`CreateLCApplicationCommand`。虽然命令规定了结构，但目前没有任何强制执行。让我们纠正这一点。
- en: 'To be able to enable validations declaratively, we will make use of the JSR-303
    bean validation libraries. We can add that easily, using the `spring-boot-starter-validation`
    dependency in our `pom.xml` file, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够声明式地启用验证，我们将使用JSR-303 Bean验证库。我们可以通过在`pom.xml`文件中使用`spring-boot-starter-validation`依赖轻松地添加它，如图所示：
- en: '![](img/ch5-9.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-9.jpg)'
- en: 'Now, we can add validations to the command object using the JSR-303 annotations,
    as depicted here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用JSR-303注解向命令对象添加验证，如图所示：
- en: '![](img/ch5-10.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-10.jpg)'
- en: Most structural validations can be accomplished using built-in validator annotations.
    It is also possible to create custom validators for individual fields or to validate
    the entire object (for example, to validate interdependent attributes). For more
    details on how to do this, please refer to the bean validation specification at
    [https://beanvalidation.org/2.0/](https://beanvalidation.org/2.0/) and the reference
    implementation at [http://hibernate.org/validator/](http://hibernate.org/validator/).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数结构性验证可以使用内置的验证注解来完成。也有可能为单个字段创建自定义验证器，或者验证整个对象（例如，验证相互依赖的属性）。有关如何操作的更多详细信息，请参阅[https://beanvalidation.org/2.0/](https://beanvalidation.org/2.0/)的Bean验证规范和[http://hibernate.org/validator/](http://hibernate.org/validator/)的参考实现。
- en: Business rule enforcements
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 业务规则强制
- en: Structural validations can be accomplished using information that is already
    available in the command. However, there is another class of validations that
    requires information that is not present in the incoming command itself. This
    kind of information can be present in one of two places – within the aggregate
    that we are operating on or outside of the aggregate itself, but made available
    within the bounded context.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 结构性验证可以使用命令中已经存在的信息来完成。然而，还有另一类验证需要的信息并不在传入的命令本身中。这类信息可能存在于两个地方之一 – 在我们正在操作的聚合内，或者不在聚合本身内，但可以在有限范围内提供。
- en: 'Let’s look at an example of a validation that requires state to be present
    within the aggregate. Consider the example of submitting an LC. While we can make
    several edits to the LC when it is in a draft state, no changes can be made after
    it is submitted. This means that we can only submit an LC once. This act of submitting
    the LC is achieved by issuing `SubmitLCApplicationCommand`, as shown in the artifact
    from the eventstorming session:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个需要聚合内存在状态验证的验证示例。考虑提交LC的例子。当LC处于草稿状态时，我们可以对其进行多次编辑，但在提交后就不能再进行任何更改。这意味着我们只能提交一次LC。通过发出`SubmitLCApplicationCommand`来实现提交LC的行为，如事件风暴会议中的工件所示：
- en: '![Figure 5.10 – Validations during the Submit LC Application process'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10 – 提交LC应用程序过程中的验证'
- en: '](img/B16716_05_10.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_05_10.jpg)'
- en: Figure 5.10 – Validations during the Submit LC Application process
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 提交LC应用程序过程中的验证
- en: 'Let’s begin with a test to express our intent:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一个测试来表示我们的意图开始：
- en: '![](img/ch5-11.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-11.jpg)'
- en: It is given that `LCApplicationCreatedEvent` has already occurred – in other
    words, the LC application is already created.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已知`LCApplicationCreatedEvent`已经发生 – 换句话说，LC申请已经创建。
- en: This is when we try to submit the application by issuing `SubmitLCApplicationCommand`
    for the same application.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们尝试通过发出针对同一应用的`SubmitLCApplicationCommand`来提交应用程序的时候。
- en: We expect `LCApplicationSubmittedEvent` to be emitted.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望会发出`LCApplicationSubmittedEvent`事件。
- en: 'The corresponding implementation will look something like the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的实现将类似于以下内容：
- en: '![](img/ch5-12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-12.jpg)'
- en: 'The preceding implementation allows us to submit an LC application unconditionally
    – more than once. However, we want to restrict users to be able to submit only
    once. To be able to do that, we need to remember that the LC application has already
    been submitted. We can do that in the `@EventSourcingHandler` handler of the corresponding
    events, as shown next:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现允许我们无条件地提交LC应用程序 – 超过一次。然而，我们希望限制用户只能提交一次。为了能够做到这一点，我们需要记住LC应用程序已经被提交。我们可以在相应事件的`@EventSourcingHandler`处理程序中做到这一点，如下所示：
- en: '![](img/ch5-13.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-13.jpg)'
- en: When `LCApplicationSubmittedEvent` is replayed, we set the state of the LC application
    to `SUBMITTED`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`LCApplicationSubmittedEvent`被重放时，我们将LC应用程序的状态设置为`SUBMITTED`。
- en: 'While we have remembered that the application has changed to be in the `SUBMITTED`
    state, we are still not preventing more than one submit attempt. We can fix that
    by writing a test, as shown here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经记住应用程序已变为`SUBMITTED`状态，但我们仍然没有阻止多次提交尝试。我们可以通过编写一个测试来修复这个问题，如下所示：
- en: '![](img/ch5-14.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-14.jpg)'
- en: '`LCApplicationCreatedEvent` and `LCApplicationSubmittedEvent` have already
    happened, which means that `LCApplication` has been submitted once.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LCApplicationCreatedEvent`和`LCApplicationSubmittedEvent`已经发生，这意味着`LCApplication`已经被提交过一次。'
- en: We now dispatch another `SubmitLCApplicationCommand` command to the system.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在向系统发送另一个`SubmitLCApplicationCommand`命令。
- en: We expect `AlreadySubmittedException` to be thrown.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望会抛出`AlreadySubmittedException`异常。
- en: We also expect no events to be emitted.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也期望不会发出任何事件。
- en: 'The implementation of the command handler to make this work is shown here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使其工作的命令处理程序的实现如下所示：
- en: '![](img/ch5-15.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch5-15.jpg)'
- en: Note how we are using the state attribute from the `LCApplication` aggregate
    to perform the validation. If the application is not in the `DRAFT` state, we
    fail with the `AlreadySubmittedException` domain exception.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们是如何使用`LCApplication`聚合的状态属性来执行验证的。如果应用程序不在`DRAFT`状态，我们将通过`AlreadySubmittedException`域异常失败。
- en: 'Let’s also look at an example where information needed to perform the validation
    is not part of either the command or the aggregate. Let’s consider the scenario
    where country regulations prohibit transacting with a set of so-called *sanctioned*
    countries. Changes to this list of countries may be affected by external factors.
    Hence it does not make sense to pass this list of sanctioned countries as part
    of the command payload. Neither does it make sense to maintain it as part of every
    single aggregate’s state – given that it can change (albeit very infrequently).
    In such a case, we may want to consider making use of a command handler that is
    outside the confines of the aggregate class. Thus far, we have only seen examples
    of `@CommandHandler` methods within the aggregate. But the `@CommandHandler` annotation
    can appear on any other class external to the aggregate. However, in such a case,
    we need to load the aggregate ourselves. Axon Framework provides an `org.axonframework.modelling.command.Repository`
    interface to allow us to do that. It is important to note that this repository
    is distinct from the Spring Framework interface that is part of the Spring data
    libraries. An example of how this works is shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看一个例子，其中执行验证所需的信息既不是命令的一部分，也不是聚合的一部分。让我们考虑这样一个场景，即国家法规禁止与所谓的*受制裁*国家进行交易。这个国家列表的变化可能受到外部因素的影响。因此，将这个受制裁国家的列表作为命令有效负载的一部分是没有意义的。同样，将其作为每个单个聚合状态的一部分来维护也没有意义——鉴于它可以改变（尽管非常不频繁）。在这种情况下，我们可能想要考虑使用一个位于聚合类之外的命令处理器。到目前为止，我们只看到了聚合内部`@CommandHandler`方法的示例。但是，`@CommandHandler`注解可以出现在任何其他外部于聚合的类上。然而，在这种情况下，我们需要自己加载聚合。Axon框架提供了一个`org.axonframework.modelling.command.Repository`接口，允许我们这样做。重要的是要注意，这个仓库与Spring数据库中作为其一部分的Spring框架接口是不同的。这里展示了如何工作的一个示例：
- en: '![](img/ch5-16.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch5-16.jpg)'
- en: We are injecting the Axon `Repository` interface to allow us to load aggregates.
    This was not required previously because the `@CommandHandler` annotation appeared
    on aggregate methods directly.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在注入Axon `Repository`接口以允许我们加载聚合。之前这并不是必需的，因为`@CommandHandler`注解直接出现在聚合方法上。
- en: We are using the `Repository` interface to load aggregates and work with them.
    The `Repository` interface supports other convenient methods to work with aggregates.
    Please refer to the Axon Framework documentation for more usage examples.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用`Repository`接口来加载聚合并与之交互。`Repository`接口支持其他方便的方法来处理聚合。请参阅Axon框架文档以获取更多使用示例。
- en: 'Coming back to the sanctioned countries example, let’s look at how we need
    to set up the test slightly differently:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 回到受制裁国家的例子，让我们看看我们需要如何稍微不同地设置测试：
- en: '![](img/ch5-17.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch5-17.jpg)'
- en: We are creating a new aggregate fixture as usual.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样创建一个新的聚合夹具。
- en: We are using the fixture to obtain an instance of the Axon `Repository` interface.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用夹具来获取Axon `Repository`接口的一个实例。
- en: We instantiate the custom command handler passing in the `Repository` instance.
    Also, note how we inject the collection of sanctioned countries into the handler
    using simple dependency injection. In real life, this set of sanctioned countries
    will likely be obtained from the external configuration.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实例化了一个自定义命令处理器，传递了`Repository`实例。同时，请注意我们如何通过简单的依赖注入将受制裁国家的集合注入到处理器中。在现实生活中，这组受制裁国家很可能会从外部配置中获得。
- en: We finally need to register the command handler with the fixture so that it
    can route commands to this handler as well.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终需要将命令处理器注册到夹具中，以便它可以路由命令到这个处理器。
- en: 'The tests for this look fairly straightforward:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，看起来相当直接：
- en: '![](img/ch5-18.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch5-18.jpg)'
- en: For the purposes of the test, we mark the country `SOKOVIA` as a sanctioned
    country. In a more realistic scenario, this will likely come from some form of
    external configuration (for example, a lookup table or form of external configuration).
    However, this is appropriate for our unit test.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试的目的，我们将国家`SOKOVIA`标记为受制裁国家。在更现实的场景中，这很可能是来自某种形式的外部配置（例如，查找表或某种形式的外部配置）。然而，这对于我们的单元测试是合适的。
- en: We then inject this set of sanctioned countries into the command handler.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将这组受制裁国家注入到命令处理器中。
- en: When the LC application is created for the sanctioned country, we expect no
    events to be emitted and, furthermore, the `CannotTradeWithSanctionedCountryException`
    exception to be thrown.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当为受制裁国家创建LC应用程序时，我们预计不会发出任何事件，并且还会抛出`CannotTradeWithSanctionedCountryException`异常。
- en: Finally, when the beneficiary belongs to a non-sanctioned country, we emit `LCApplicationCreatedEvent`
    to be emitted.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当受益人属于非制裁国家时，我们发出`LCApplicationCreatedEvent`事件。
- en: 'The implementation of the command handler is shown here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理器的实现如下所示：
- en: '![](img/ch5-19.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch5-19.jpg)'
- en: We mark the class as `@Service` to mark it as a component devoid of encapsulated
    state and enable auto-discovery when using annotation-based configuration or classpath
    scanning. As such, it can be used to perform any “plumbing” activities.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将类标记为`@Service`以标记它为一个没有封装状态的组件，并在使用基于注解的配置或类路径扫描时启用自动发现。因此，它可以用于执行任何“管道”活动。
- en: Do note that the validation for the beneficiary’s country being sanctioned could
    have been performed on line 18 as well. Some would argue that this would be ideal
    because we could avoid a potentially unnecessary invocation of the Axon `Repository`
    method if we did that. However, we prefer encapsulating business validations within
    the confines of the aggregate as much as possible, so that we don’t suffer from
    the problem of creating an anemic domain model.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，受益人所在国家是否被制裁的验证也可以在行18进行。有些人可能会认为这是理想的，因为我们如果那样做可以避免调用Axon `Repository`方法的潜在不必要的调用。然而，我们更喜欢尽可能地将业务验证封装在聚合的范围内，这样我们就不会遭受创建贫血领域模型的问题。
- en: We use an aggregate repository to act as a factory to create a new instance
    of the `LCApplication` domain object.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用聚合存储库作为工厂来创建`LCApplication`领域对象的新的实例。
- en: 'Finally, the aggregate implementation along with the validation is shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里展示了聚合实现以及验证：
- en: '![](img/ch5-20.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch5-20.jpg)'
- en: The validation itself is fairly straightforward. We throw `CannotTradeWithSanctionedCountryException`
    when the validation fails.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证本身相当直接。当验证失败时，我们抛出`CannotTradeWithSanctionedCountryException`异常。
- en: With these examples, we looked at different ways to implement the policy enforcements
    encapsulated within the boundaries of the aggregate.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，我们探讨了在聚合边界内实现策略执行的不同方法。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used the outputs of the eventstorming session and used it
    as a primary aid to create a domain model for our bounded context. We looked at
    how to implement this using the CQRS architecture pattern. We looked at persistence
    options and the implications of using event-sourced versus state-stored aggregates.
    Finally, we rounded off by looking at a variety of ways in which to perform business
    validations. We looked at all this through a set of code examples, using Spring
    Boot and Axon Framework. With this knowledge, we should be able to implement robust,
    well-encapsulated, event-driven domain models.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了事件风暴会议的输出，并将其用作创建我们边界上下文领域模型的主要辅助工具。我们探讨了如何使用CQRS架构模式来实现这一点。我们探讨了持久化选项以及使用基于事件的聚合与存储状态的聚合的后果。最后，我们通过一系列代码示例来查看执行业务验证的多种方式。我们通过Spring
    Boot和Axon框架的代码示例来查看所有这些。有了这些知识，我们应该能够实现健壮、封装良好、事件驱动的领域模型。
- en: In the next chapter, we will look at implementing a UI for these domain capabilities
    and examine a few options, such as CRUD-based versus task-based UIs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨实现这些领域能力的用户界面，并考察一些选项，例如基于CRUD的UI与基于任务的UI。
- en: Further reading
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '![](img/B16716_05_Table_04.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16716_05_Table_04.jpg)'
