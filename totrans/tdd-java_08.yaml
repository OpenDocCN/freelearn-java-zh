- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Test Doubles – Stubs and Mocks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试替身——存根和模拟
- en: In this chapter, we’re going to solve a common testing challenge. How do you
    test an object that depends on another object? What do we do if that collaborator
    is difficult to set up with test data? Several techniques are available to help
    us with this and they build on the SOLID principles we learned previously. We
    can use the idea of dependency injection to enable us to replace collaborating
    objects with ones specially written to help us write our test.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决一个常见的测试挑战。如何测试依赖于另一个对象的对象？如果那个协作者难以设置测试数据，我们该怎么办？有几种技术可以帮助我们做到这一点，并且它们建立在之前学到的SOLID原则之上。我们可以使用依赖注入的概念，使我们能够用专门编写来帮助我们编写测试的对象替换协作对象。
- en: These new objects are called test doubles, and we will learn about two important
    kinds of test double in this chapter. We will learn when to apply each kind of
    test double and then learn two ways of creating them in Java – both by writing
    the code ourselves and by using the popular library Mockito. By the end of the
    chapter, we will have techniques that allow us to write tests for objects where
    it is difficult or impossible to test them with the real collaborating objects
    in place. This allows us to use TDD with complex systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新对象被称为测试替身，在本章中我们将了解两种重要的测试替身。我们将学习何时应用每种类型的测试替身，然后学习两种在Java中创建它们的方法——既可以通过自己编写代码，也可以使用流行的库Mockito。到本章结束时，我们将拥有允许我们为难以或无法使用真实协作对象进行测试的对象编写测试的技术。这使我们能够在复杂系统中使用TDD。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The problems of testing collaborators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试协作者的问题
- en: The purpose of test doubles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试替身的目的
- en: Using stubs for pre-canned results
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根来获取预定义的结果
- en: Using mocks to verify interactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟来验证交互
- en: Understanding when test doubles are appropriate
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解何时使用测试替身是合适的
- en: Working with Mockito – a popular mocking library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mockito——一个流行的模拟库
- en: Driving error handling code using stubs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根驱动错误处理代码
- en: Testing an error condition in Wordz
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Wordz中测试错误条件
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter08](B18384_08.xhtml#_idTextAnchor177).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter08](B18384_08.xhtml#_idTextAnchor177)找到。
- en: The problems collaborators present for testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协作者提出的测试问题
- en: In this section, we will understand the challenges that arise as we grow our
    software into a larger code base. We will review what is meant by a collaborating
    object, then we will take a look at two examples of collaborations that are challenging
    to test.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解随着我们的软件发展成为更大的代码库时出现的挑战。我们将回顾协作对象的意义，然后我们将探讨两个具有挑战性的测试合作示例。
- en: As we grow our software system, we will soon outgrow what can go in a single
    class (or function, for that matter). We will split our code into multiple parts.
    If we pick a single object as our subject under test, any other object that it
    depends on is a collaborator. Our TDD tests must account for the presence of these
    collaborators. Sometimes, this is straightforward, as we’ve seen in earlier chapters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的软件系统的发展，我们很快就会超出单个类（或者函数）所能容纳的内容。我们将把代码分成多个部分。如果我们选择一个对象作为测试对象，那么它所依赖的任何其他对象都是协作者。我们的TDD测试必须考虑到这些协作者的存在。有时，这很简单，就像我们在前面的章节中看到的那样。
- en: Unfortunately, things aren’t always that simple. Some collaborations make tests
    difficult – or impossible – to write. These kinds of collaborators introduce either
    unrepeatable behaviors that we must contend with or present errors that are difficult
    to trigger.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，事情并不总是那么简单。有些协作使测试变得困难——或者不可能——编写。这类协作者引入了我们必须应对的不可重复行为，或者呈现难以触发的错误。
- en: 'Let’s review these challenges with some short examples. We’ll start with a
    common problem: a collaborator that exhibits unrepeatable behavior.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些简短的例子来回顾这些挑战。我们将从一个常见问题开始：一个表现出不可重复行为的协作者。
- en: The challenges of testing unrepeatable behavior
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试不可重复行为的挑战
- en: We’ve learned that the basic steps of a TDD test are Arrange, Act, and Assert.
    We ask the object to act and then assert that an expected outcome happens. But
    what happens when that outcome is unpredictable?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到TDD测试的基本步骤是安排（Arrange）、行动（Act）和断言（Assert）。我们要求对象执行操作，然后断言预期的结果发生。但是，当结果不可预测时会发生什么呢？
- en: 'To illustrate, let’s review a class that rolls a die and presents a text string
    to say what we rolled:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们回顾一个掷骰子并显示文本字符串来说明我们掷了什么数字的类：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is simple enough code, with only a handful of executable lines in it. Sadly,
    *simple to write is not always simple to test*. How would we write a test for
    this? Specifically – how would we write the assert? In previous tests, we’ve always
    known exactly what to expect in the assertion. Here, the assertion will be some
    fixed text plus a random number. We don’t know in advance what that random number
    will be.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很简单，只有几行可执行代码。遗憾的是，*编写简单并不意味着测试简单*。我们该如何为这个编写测试？具体来说——我们该如何编写断言？在之前的测试中，我们总是确切地知道在断言中期望什么。在这里，断言将是一些固定文本加上一个随机数。我们事先不知道那个随机数会是什么。
- en: The challenges of testing error handling
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试错误处理的挑战
- en: Testing code that handles error conditions is another challenge. The difficulty
    here lies not in asserting that the error was handled, but rather the challenge
    is how to trigger that error to happen inside the collaborating object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试处理错误条件的代码是另一个挑战。这里的困难不在于断言错误已被处理，而挑战在于如何在协作对象内部触发该错误发生。
- en: 'To illustrate, let’s imagine a code to warn us when the battery in our portable
    device is getting low:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们想象一段代码，当我们的便携式设备中的电池电量低时，会提醒我们：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code in `BatteryMonitor` features a `DeviceApi` class, which
    is a library class that lets us read how much battery we have left on our phone.
    It provides a static method to do this, called `getBatteryPercentage()`. This
    will return an integer in the range *0* to *100* percent. The code that we want
    to write a TDD test for calls `getBatteryPercentage()` and will display a warning
    message if it is less than *10* percent. But there’s a problem writing this test:
    how can we force the `getBatteryPercentage()` method to return a number less than
    10 as part of our Arrange step? Would we discharge the battery somehow? How would
    we do this?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatteryMonitor`中的前一段代码包含一个`DeviceApi`类，这是一个库类，它允许我们读取手机上剩余的电量。它提供了一个静态方法来完成这个操作，称为`getBatteryPercentage()`。这将返回一个介于*0*到*100*百分比的整数。我们想要为编写TDD测试的代码调用`getBatteryPercentage()`，如果它小于*10*百分比，将显示警告信息。但编写这个测试有一个问题：我们如何在我们的安排步骤中强制`getBatteryPercentage()`方法返回一个小于10的数字？我们会以某种方式放电电池吗？我们该如何做？'
- en: '`BatteryMonitor` provides an example of code that collaborates with another
    object, where it is impossible to force a known response from that collaborator.
    We have no way to change the value that `getBatteryPercentage()` will return.
    We would literally have to wait until the battery had discharged before this test
    could pass. That’s not what TDD is about.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatteryMonitor`提供了一个例子，展示了与另一个对象协作的代码，其中我们无法强制该协作者给出已知响应。我们没有方法改变`getBatteryPercentage()`将返回的值。我们实际上必须等到电池放电后，这个测试才能通过。这并不是TDD的宗旨。'
- en: Understanding why these collaborations are challenging
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解为什么这些协作具有挑战性
- en: When doing TDD, we want *fast* and *repeatable* tests. Any scenario that involves
    unpredictable behavior or requires us to control a situation that we have no control
    over clearly causes problems for TDD.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行TDD（测试驱动开发）时，我们希望测试是*快速*和*可重复*的。任何涉及不可预测行为或需要我们控制我们无法控制的情况的场景，都会给TDD带来明显的问题。
- en: The best way to write tests in these cases is by eliminating the cause of the
    difficulty. Fortunately, a simple solution exists. We can apply the *Dependency
    Injection Principle* we learned about in the previous chapter, along with one
    new idea – the *test double*. We will review test doubles in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下编写测试的最佳方式是消除困难的根源。幸运的是，有一个简单的解决方案。我们可以应用我们在上一章中学到的*依赖注入原则*，以及一个新想法——*测试替身*。我们将在下一节中回顾测试替身。
- en: The purpose of test doubles
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试替身的目的
- en: In this section, we’re going to learn techniques that allow us to test these
    challenging collaborations. We will introduce the idea of test doubles. We will
    learn how to apply the SOLID principles to design code flexible enough to use
    these test doubles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习允许我们测试这些具有挑战性的协作的技术。我们将介绍测试替身的概念。我们将学习如何将SOLID原则应用于设计足够灵活的代码，以便使用这些测试替身。
- en: The challenges of the previous section are solved by using **test doubles**.
    A test double replaces one of the collaborating objects in our test. By design,
    this test double avoids the difficulties of the replaced object. Think of them
    as the stunt doubles in movies, replacing the real actors to help safely get an
    action shot.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**测试替身**解决了上一节中的挑战。测试替身替换了我们测试中的协作对象之一。按照设计，这个测试替身避免了被替换对象的困难。想想电影中的替身，他们取代了真正的演员，以帮助安全地拍摄动作镜头。
- en: A software test double is an object we have written specifically to be easy
    to use in our unit test. In the test, we inject our test double into the SUT in
    the Arrange step. In production code, we inject in the production object that
    our test double had replaced.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试替身是我们专门编写的一个对象，以便在单元测试中易于使用。在测试中，我们在安排步骤中将我们的测试替身注入到SUT中。在生产代码中，我们注入了测试替身所取代的生产对象。
- en: Let’s reconsider our `DiceRoll` example earlier. How would we refactor that
    code to make it easier to test?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新考虑之前的`DiceRoll`示例。我们将如何重构这段代码以使其更容易测试？
- en: 'Create an interface that abstracts the source of random numbers:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个抽象随机数来源的接口：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Apply the *Dependency Inversion Principle* to `class DiceRoll` to make use
    of this abstraction:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*依赖倒置原则*应用于`class DiceRoll`以利用这个抽象：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have inverted the dependency on the random number generator by replacing
    it with the `RandomNumbers` interface. We added a constructor that allows a suitable
    `RandomNumbers` implementation to be injected. We assign that to the `rnd` field.
    The `asText()` method now calls the `nextInt()` method on whatever object we passed
    to the constructor.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过用`RandomNumbers`接口替换随机数生成器来反转了对随机数生成器的依赖。我们添加了一个构造函数，允许注入合适的`RandomNumbers`实现。我们将其分配给`rnd`字段。`asText()`方法现在调用我们传递给构造函数的任何对象的`nextInt()`方法。
- en: 'Write a test, using a test double to replace the `RandomNumbers` source:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个使用测试替身替换`RandomNumbers`来源的测试：
- en: '[PRE19]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We see the usual Arrange, Act, and Assert sections in this test. The new idea
    here is `class StubRandomNumbers`. Let’s look at the stub code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个测试中看到了常见的安排、行动和断言部分。这里的新想法是`class StubRandomNumbers`。让我们看看这个存根代码：
- en: '[PRE32]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are a few things to notice about this stub. Firstly, it implements our
    `RandomNumbers` interface, making it an LSP-compliant substitute for that interface.
    This allows us to inject it into the constructor of `DiceRoll`, our SUT. The second
    most important aspect is that every call to `nextInt()` will *return the* *same
    number*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个存根有一些需要注意的事情。首先，它实现了我们的`RandomNumbers`接口，使其成为该接口的LSP兼容替身。这允许我们将它注入到`DiceRoll`的构造函数中，我们的SUT。第二个最重要的方面是，每次对`nextInt()`的调用都将*返回相同的数字*。
- en: By replacing the real `RandomNumbers` source with a stub that delivers a known
    value, we have made our test assertion easy to write. The stub eliminates the
    problem of unrepeatable values from the random generator.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用提供已知值的存根替换真实的`RandomNumbers`来源，我们已经使测试断言变得容易编写。存根消除了随机生成器不可重复值的问题。
- en: We can now see how the `DiceRollTest` works. We supply a test double to our
    SUT. The test double always returns the same value. As a result, we can assert
    against a known outcome.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到`DiceRollTest`是如何工作的。我们向我们的SUT提供一个测试替身。测试替身总是返回相同的值。因此，我们可以对已知结果进行断言。
- en: Making the production version of the code
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作代码的生产版本
- en: 'To make `class DiceRoll` work properly in production, we would need to inject
    a genuine source of random numbers. A suitable class would be the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`class DiceRoll`在生产中正常工作，我们需要注入一个真正的随机数来源。一个合适的类可能是以下内容：
- en: '[PRE33]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There isn’t much work to do here – the preceding code simply implements the
    `nextInt()` method using the `RandomGenerator` library class built into Java.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多工作要做——前面的代码只是简单地使用内置在Java中的`RandomGenerator`库类实现了`nextInt()`方法。
- en: We can now use this to create our production version of the code. We already
    changed our `DiceRoll` class to allow us to inject in any suitable implementation
    of the `RandomNumbers` interface. For our test code, we injected in a test double
    – an instance of the `StubRandomNumbers` class. For our production code, we will
    instead inject in an instance of the `RandomlyGeneratedNumbers` class. The production
    code will use that object to create real random numbers – and there will be no
    code changes inside the `DiceRoll` class. We have used the Dependency Inversion
    Principle to make `class DiceRoll` configurable by dependency injection. This
    means that `class DiceRoll` now follows the Open/Closed Principle – it is *open*
    to new kinds of random number generation behavior but *closed* to code changes
    inside the class itself.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个方法来创建我们的代码生产版本。我们已经将我们的`DiceRoll`类修改为允许我们注入任何适合的`RandomNumbers`接口的实现。对于我们的测试代码，我们注入了一个测试替身——`StubRandomNumbers`类的实例。对于我们的生产代码，我们将注入`RandomlyGeneratedNumbers`类的实例。生产代码将使用该对象来创建真实的随机数——并且`DiceRoll`类内部将不会有任何代码更改。我们已经使用了依赖倒置原则，通过依赖注入使`DiceRoll`类可配置。这意味着`DiceRoll`类现在遵循开放/封闭原则——它对新类型的随机数生成行为是开放的，但对类内部的代码更改是封闭的。
- en: Dependency inversion, dependency injection, and inversion of control
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置、依赖注入和控制反转
- en: The preceding example shows these three ideas in action. *Dependency inversion*
    is the design technique where we create an abstraction in our code. *Dependency
    injection* is the runtime technique where we supply an implementation of that
    abstraction to code that depends on it. Together, these ideas are often termed
    **Inversion of Control** (**IoC**). Frameworks such as Spring are sometimes called
    IoC containers because they provide tools to help you manage creating and injecting
    dependencies in an application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了这三个想法的实际应用。*依赖倒置*是一种设计技术，我们在代码中创建一个抽象。*依赖注入*是一种运行时技术，我们向依赖于它的代码提供该抽象的实现。这两个想法通常被称为**控制反转**（**IoC**）。例如，Spring这样的框架有时被称为IoC容器，因为它们提供了帮助您管理在应用程序中创建和注入依赖项的工具。
- en: 'The following code is an example of how we would use `DiceRoll` and `RandomlyGeneratedNumbers`
    in production:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们在生产环境中使用`DiceRoll`和`RandomlyGeneratedNumbers`的示例：
- en: '[PRE34]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can see in the previous code that we inject an instance of the production-version
    `RandomlyGeneratedNumbers` class into the `DiceRoll` class. This process of creating
    and injecting objects is often termed **object wiring**. Frameworks such as *Spring*
    ([https://spring.io/](B18384_08.xhtml#_idTextAnchor175)), *Google Guice* ([https://github.com/google/guice](B18384_08.xhtml#_idTextAnchor172)),
    and the built-in *Java CDI* ([https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html](B18384_08.xhtml#_idTextAnchor171))
    provide ways to minimize the boilerplate of creating dependencies and wiring them
    up, using annotations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从之前的代码中看到，我们将生产版本的`RandomlyGeneratedNumbers`类的实例注入到`DiceRoll`类中。创建和注入对象的过程通常被称为**对象配置**。例如，*Spring*（[https://spring.io/](B18384_08.xhtml#_idTextAnchor175)）、*Google
    Guice*（[https://github.com/google/guice](B18384_08.xhtml#_idTextAnchor172)）和内置的*Java
    CDI*（[https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html](B18384_08.xhtml#_idTextAnchor171)）等框架提供了使用注解来最小化创建依赖项和配置它们所需样板代码的方法。
- en: Using DIP to swap a production object for a test double is a very powerful technique.
    This test double is an example of a kind of double known as a stub. We’ll cover
    what a stub is along with when to use one in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖倒置原则来交换生产对象和测试替身是一个非常强大的技术。这个测试替身是一种称为存根的双面实例。在下一节中，我们将介绍存根是什么以及何时使用它。
- en: Using stubs for pre-canned results
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存根进行预定义结果
- en: The previous section explained that test doubles were a kind of object that
    could stand in for a production object so that we could write a test more easily.
    In this section, we will take a closer look at that test double and generalize
    it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节解释了测试替身是一种可以替代生产对象的物体，这样我们就可以更容易地编写测试。在本节中，我们将更详细地研究这个测试替身并对其进行泛化。
- en: In the preceding `DiceRoll` example, the test was simpler to write because we
    replaced the random number generation with a known, fixed value. Our genuine random
    number generator made it difficult to write an assertion, as we were never sure
    what the expected random number should be. Our test double was an object that
    instead supplied a well-known value. We can then work out the expected value for
    our assertion, making our test easy to write.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 `DiceRoll` 示例中，测试编写起来更简单，因为我们用已知、固定的值替换了随机数生成。我们的真实随机数生成器使得编写断言变得困难，因为我们从未确定预期的随机数应该是什么。我们的测试替身是一个提供已知值的对象。然后我们可以计算出断言的预期值，使测试易于编写。
- en: 'A test double that supplies values like this is called a **stub**. Stubs always
    replace an object that we cannot control with a test-only version that we can
    control. They always produce known data values for our code under test to consume.
    Graphically, a stub looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提供此类值的测试替身被称为 **存根**。存根总是用我们可以控制的测试版本替换我们无法控制的对象。它们总是为我们的测试代码提供已知的数据值。图形上，存根看起来像这样：
- en: '![Figure 8.1 – Replacing a collaborator with a stub](img/Figure_8.1_B18384.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 用存根替换协作者](img/Figure_8.1_B18384.jpg)'
- en: Figure 8.1 – Replacing a collaborator with a stub
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 用存根替换协作者
- en: In the diagram, our test class is responsible for wiring up our SUT to an appropriate
    stub object in the Arrange step. When the Act step asks our SUT to execute the
    code we want to test, that code will pull the known data values from the stub.
    The Assert step can be written based on the expected behavior that these known
    data values will cause.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们的测试类负责在 Arrange 步骤中将我们的系统单元（SUT）连接到适当的存根对象。当 Act 步骤要求我们的 SUT 执行我们想要测试的代码时，该代码将从存根中拉取已知的数据值。Assert
    步骤可以根据这些已知数据值将导致的行为来编写。
- en: It is important to note why this works. One objection to this arrangement is
    that we are not testing the real system. Our SUT is wired up to some object that
    will never be part of our production system. That is true. But this works because
    our test is only testing the logic within the SUT. This test is *not* testing
    the behavior of the dependencies themselves. Indeed, it must not attempt to do
    that. Testing the test double is a classic anti-pattern for unit tests.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意为什么这行得通。对这个安排的反对意见之一是我们没有测试真实的系统。我们的 SUT 连接到一些永远不会成为我们生产系统一部分的对象。这是真的。但这是因为我们的测试只测试
    SUT 内部的逻辑。这个测试**不是**测试依赖项的行为。实际上，它必须不尝试这样做。测试测试替身是单元测试的一个经典反模式。
- en: Our SUT has used the Dependency Inversion Principle to fully isolate itself
    from the object the stub is standing in for. It makes no difference to the SUT
    how it gets its data from its collaborator. That’s why this testing approach is
    valid.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 SUT 已经使用依赖倒置原则完全隔离了自己，从存根所代表的对象中。对于 SUT 来说，它如何从其协作者那里获取数据没有区别。这就是为什么这种测试方法有效的原因。
- en: When to use stub objects
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用存根对象
- en: 'Stubs are useful whenever our SUT uses a *pull model* of collaborating with
    a dependency. Some examples of when using stubs makes sense are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 SUT 使用与依赖项协作的 *拉模型* 时，存根是有用的。以下是一些使用存根有意义的例子：
- en: '**Stubbing a repository interface/database**: Using a stub instead of calling
    to a real database for data access code'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根存储库接口/数据库**：使用存根而不是调用真实数据库进行数据访问代码'
- en: '**Stubbing reference data sources**: Replacing properties files or web services
    containing reference data with stub data'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根参考数据源**：用存根数据替换包含参考数据的属性文件或网络服务'
- en: '**Providing application objects to code that converts to HTML or JSON formats**:
    When testing code that converts to HTML or JSON, supply input data with a stub'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为将代码转换为 HTML 或 JSON 格式的代码提供应用程序对象**：当测试将代码转换为 HTML 或 JSON 时，用存根提供输入数据'
- en: '**Stubbing the system clock to test time-dependent behavior**: To get repeatable
    behavior out of a time call, stub the call with known times'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根系统时钟以测试时间依赖行为**：为了从时间调用中获得可重复的行为，用已知的时间存根调用'
- en: '**Stubbing random number generators to create predictability**: Replace a call
    to a random number generator with a call to a stub'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根随机数生成器以创建可预测性**：用一个存根的调用替换对随机数生成器的调用'
- en: '**Stubbing authentication systems to always allow a test user to log in**:
    Replace calls to authentication systems with simple “login succeeded” stubs'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根认证系统以始终允许测试用户登录**：用简单的“登录成功”存根替换对认证系统的调用'
- en: '**Stubbing responses from a third-party web service such as a payment provider**:
    Replace real calls to third-party services with calls to a stub'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从第三方网络服务（如支付提供者）中模拟响应**：将调用第三方服务的真实调用替换为对模拟的调用'
- en: '**Stubbing a call to an operating system command**: Replace a call to the OS
    to, for example, list a directory with pre-canned stub data'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟对操作系统命令的调用**：用预制的模拟数据替换对操作系统调用，例如列出目录'
- en: In this section, we have seen how using stubs allows us to control data that
    gets supplied to an SUT. It supports a *pull model* of fetching objects from elsewhere.
    But that’s not the only mechanism by which objects can collaborate. Some objects
    use a *push model*. In this case, when we call a method on our SUT, we expect
    it to call another method on some other object. Our test must confirm that this
    method call actually took place. This is something that stubs cannot help with
    and needs a different approach. We will cover this approach in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用存根来控制提供给SUT的数据。它支持从其他地方获取对象的*拉模型*。但这并不是唯一一种对象协作的机制。有些对象使用*推模型*。在这种情况下，当我们调用SUT上的方法时，我们期望它调用另一个对象上的方法。我们的测试必须确认这个方法调用确实发生了。这是存根无法帮助解决的问题，需要不同的方法。我们将在下一节中介绍这种方法。
- en: Using mocks to verify interactions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟来验证交互
- en: 'In this section, we’ll take a look at another important kind of test double:
    the mock object. Mock objects solve a slightly different problem than stub objects
    do, as we shall see in this section.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨另一种重要的测试替身：模拟对象。模拟对象解决的问题与存根对象略有不同，正如我们将在本节中看到的那样。
- en: '**Mock objects** are a kind of test double that *record interactions*. Unlike
    stubs, which supply well-known objects to the SUT, a mock will simply record interactions
    that the SUT has with the mock. It is the perfect tool to answer the question,
    “*Did the SUT call the method correctly?*” This solves the problem of *push model*
    interactions between the SUT and its collaborator. The SUT commands the collaborator
    to do something rather than requesting something from it. A mock provides a way
    to verify that it issued that command, along with any necessary parameters.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟对象**是一种测试替身，它能够*记录交互*。与提供已知对象给SUT的存根不同，模拟对象将简单地记录SUT与模拟对象之间的交互。这是回答“*SUT是否正确调用了方法？*”这一问题的完美工具。这解决了SUT与其协作者之间的*推送模型*交互问题。SUT命令协作者做某事，而不是从它那里请求某物。模拟提供了一种验证它是否发出了该命令以及任何必要参数的方法。'
- en: 'The following UML object diagram shows the general arrangement:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的UML对象图显示了一般的安排：
- en: '![Figure 8.2 – Replace collaborator with mock](img/Figure_8.2_B18384.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 用模拟替换协作者](img/Figure_8.2_B18384.jpg)'
- en: Figure 8.2 – Replace collaborator with mock
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 用模拟替换协作者
- en: We see our test code wiring up a mock object to the SUT. The Act step will make
    the SUT execute code that we expect to interact with its collaborator. We have
    swapped out that collaborator for a mock, which will record the fact that a certain
    method was called on it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到测试代码将一个模拟对象连接到SUT。执行步骤将使SUT执行我们期望与它的协作者交互的代码。我们已经用模拟对象替换了那个协作者，该模拟对象将记录某个方法被调用的事实。
- en: 'Let’s look at a concrete example to make this easier to understand. Suppose
    our SUT is expected to send an email to a user. Once again, we will use the Dependency
    Inversion Principle to create an abstraction of our mail server as an interface:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来使这个问题更容易理解。假设我们的SUT预期向用户发送电子邮件。再次使用依赖倒置原则，将我们的邮件服务器抽象为一个接口：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code shows a simplified interface only suitable for sending a
    short text email. It is good enough for our purposes. To test the SUT that called
    the `sendEmail()` method on this interface, we would write a `MockMailServer`
    class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了一个简化的接口，仅适用于发送简短的文本电子邮件。对于我们的目的来说已经足够好了。为了测试调用此接口上的`sendEmail()`方法的SUT，我们将编写一个`MockMailServer`类：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding `MockMailServer` class implements the `MailServer` interface.
    It has a single responsibility – to record the fact that the `sendEmail()` method
    was called and to capture the actual parameter values sent to that method. It
    exposes these as simple fields with package-public visibility. Our test code can
    use these fields to form the assertion. Our test simply has to wire up this mock
    object to the SUT, cause the SUT to execute code that we expect to call the `sendEmail()`
    method, and then check that it did do that:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `MockMailServer` 类实现了 `MailServer` 接口。它只有一个职责——记录 `sendEmail()` 方法被调用的事实，并捕获发送给该方法的实际参数值。它将这些值以包公共可见性的简单字段形式暴露出来。我们的测试代码可以使用这些字段来形成断言。我们的测试只需将这个模拟对象连接到系统单元（SUT），让系统单元执行我们期望调用
    `sendEmail()` 方法的代码，然后检查它是否真的那样做了：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can see that this test wires up the mock to our SUT, then causes the SUT
    to execute the `welcomeNewUser()` method. We expect this method to call the `sendEmail()`
    method on the `MailServer` object. Then, we need to write assertions to confirm
    that call was made with the correct parameter values passed. We’re using the idea
    of four assert statements logically here and testing one idea – effectively a
    single assert.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个测试将模拟对象连接到我们的系统单元（SUT），然后让系统单元执行 `welcomeNewUser()` 方法。我们期望这个方法在 `MailServer`
    对象上调用 `sendEmail()` 方法。然后，我们需要编写断言来确认调用确实使用了正确的参数值。我们在这里逻辑上使用了四个断言语句，测试了一个想法——实际上是一个单独的断言。
- en: The power of mock objects is that we can *record interactions* with objects
    that are difficult to control. In the case of a mail server, such as the one seen
    in the preceding code block, we would not want to be sending actual emails to
    anybody. We also would not want to write a test that waited around monitoring
    the mailbox of a test user. Not only is this slow and can be unreliable, but it
    is also not what we intend to test. The SUT only has the responsibility of making
    the call to `sendEmail()` – what happens after that is out of the scope of the
    SUT. It is, therefore, out of scope for this test.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象的力量在于我们可以记录与难以控制的对象的交互。在邮件服务器的例子中，比如前面代码块中看到的，我们不想向任何人发送实际邮件。我们也不希望编写一个等待监控测试用户邮箱的测试。这不仅速度慢且可能不可靠，而且这也不是我们想要测试的内容。系统单元只负责调用
    `sendEmail()` 方法——之后发生的事情超出了系统单元的职责范围。因此，这也超出了这个测试的范围。
- en: As in the previous examples with other test doubles, the fact that we have used
    the `MailServer` that uses the SMTP protocol to talk to a real mail server. We
    would most likely search for a library class that does that for us already, then
    we would need to make a very simple adapter object that binds that library code
    to our interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前其他测试替身的例子一样，我们使用了使用 SMTP 协议与真实邮件服务器通信的 `MailServer`。我们很可能会寻找一个库类来为我们完成这项工作，然后我们需要创建一个非常简单的适配器对象，将库代码绑定到我们的接口上。
- en: This section has covered two common kinds of test double, stubs, and mocks.
    But test doubles are not always appropriate to use. In the next section, we’ll
    discuss some issues to be aware of when using test doubles.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已涵盖两种常见的测试替身类型，即存根和模拟。但测试替身并不总是适合使用。在下一节中，我们将讨论使用测试替身时应注意的一些问题。
- en: Understanding when test doubles are appropriate
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解何时使用测试替身是合适的
- en: Mock objects are a useful kind of test double, as we have seen. But they are
    not always the right approach. There are some situations where we should actively
    avoid using mocks. These situations include over-using mocks, using mocks for
    code you don’t own, and mocking value objects. We’ll look at these situations
    next. Then, we’ll recap with general advice for where mocks are typically useful.
    Let’s start by considering the problems caused when we overuse mock objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，模拟对象是一种有用的测试替身。但它们并不总是正确的做法。有些情况下，我们应该积极避免使用模拟。这些情况包括过度使用模拟、使用不属于你的代码的模拟，以及模拟值对象。我们将在下一节中探讨这些情况。然后，我们将总结一般性的建议，说明模拟通常在哪些情况下有用。让我们首先考虑过度使用模拟对象所引起的问题。
- en: Avoiding the overuse of mock objects
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免过度使用模拟对象
- en: At a first glance, using mock objects seems to solve a number of problems for
    us. Yet if used without care, we can end up with very poor-quality tests. To understand
    why, let’s go back to our basic definition of a TDD test. It is a test that verifies
    *behaviors* and is independent of *implementations*. If we use a mock object to
    stand in for a genuine abstraction, then we are complying with that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，使用模拟对象似乎能为我们解决许多问题。然而，如果不加注意地使用，我们可能会得到质量很差的测试。为了理解原因，让我们回顾一下TDD测试的基本定义。它是一种验证*行为*且与*实现*无关的测试。如果我们使用模拟对象来代替一个真正的抽象，那么我们就遵守了这一点。
- en: The potential problem happens because it is all too easy to create a mock object
    for an implementation detail, not an abstraction. If we do this, we end up locking
    our code into a specific implementation and structure. Once a test is coupled
    to a specific implementation detail, then changing that implementation requires
    a change to the test. If the new implementation has the same outcomes as the old
    one, the test really should still pass. Tests that depend on specific implementation
    details or code structures actively impede refactoring and adding new features.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的问题发生是因为创建一个模拟对象来代替实现细节，而不是抽象，实在太容易了。如果我们这样做，我们最终会将我们的代码锁定在特定的实现和结构上。一旦测试与特定的实现细节耦合，那么更改该实现就需要更改测试。如果新的实现与旧的一个有相同的结果，那么测试实际上应该仍然通过。依赖于特定实现细节或代码结构的测试会积极阻碍重构和添加新功能。
- en: Don’t mock code you don’t own
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要模拟你拥有的代码
- en: Another area where mocks should not be used is as a stand-in for a concrete
    class written outside of your team. Suppose we are using a class called `PdfGenerator`
    from a library to create a PDF document. Our code would call methods on the `PdfGenerator`
    class. We might think it would be easy to test our code if we use a mock object
    to stand in for the `PdfGenerator` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不应该使用模拟的地方是作为你团队外部编写的具体类的替代品。假设我们正在使用一个名为`PdfGenerator`的库中的类来创建PDF文档。我们的代码会在`PdfGenerator`类上调用方法。我们可能会认为，如果我们使用模拟对象来代替`PdfGenerator`类，测试我们的代码会很容易。
- en: This approach has a problem that will only arise in the future. The class in
    the external library will quite likely change. Let’s say that the `PdfGenerator`
    class removes one of the methods our code is calling. We will be forced to update
    the library version at some point as part of our security policy if nothing else.
    When we pull in the new version, our code will no longer compile against this
    changed class – *but our tests will still pass because the mock object still has
    the old method in it*. This is a subtle trap that we have laid for future maintainers
    of the code. It is best avoided. A reasonable approach is to wrap the third-party
    library, and ideally place it behind an interface to invert the dependency on
    it, isolating it fully.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个问题，这个问题可能只会出现在未来。外部库中的类很可能发生变化。比如说，`PdfGenerator`类移除了我们代码中调用的一种方法。如果我们不更新库版本，那么根据我们的安全策略，我们最终被迫更新库版本。当我们引入新版本时，我们的代码将无法编译这个已更改的类——*但我们的测试仍然会通过，因为模拟对象中仍然有旧方法*。这是我们为代码的未来维护者设置的微妙陷阱。最好避免这种情况。一个合理的方法是包装第三方库，理想情况下将其放在接口后面，以反转对它的依赖，完全隔离它。
- en: Don’t mock value objects
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要模拟值对象
- en: A **value object** is an object that has no specific identity, it is defined
    only by the data it contains. Some examples would include an integer or a string
    object. We consider two strings to be the same if they contain the same text.
    They might be two separate string objects in memory, but if they hold the same
    value, we consider them to be equal.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**值对象**是一个没有特定身份的对象，它只由包含的数据定义。一些例子包括整数或字符串对象。我们认为两个字符串相同，如果它们包含相同的文本。它们可能在内存中是两个不同的字符串对象，但如果它们持有相同的值，我们认为它们是相等的。'
- en: The clue that something is a value object in Java is the presence of a customized
    `equals()` and `hashCode()` method. By default, Java compares the equality of
    two objects using their identity – it checks that two object references are referring
    to the same object instance in memory. We must override the `equals()` and `hashCode()`
    methods to provide the correct behavior for value objects, based on their content.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，一个对象是值对象的线索是存在自定义的`equals()`和`hashCode()`方法。默认情况下，Java使用对象的身份来比较两个对象的相等性——它检查两个对象引用是否指向内存中的相同对象实例。我们必须重写`equals()`和`hashCode()`方法，以根据其内容为值对象提供正确的行为。
- en: A value object is a simple thing. It may have some complex behaviors inside
    its methods but, in principle, value objects should be easy to create. There is
    no benefit in creating a mock object to stand in for one of these value objects.
    Instead, create the value object and use it in your test.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: You can’t mock without dependency injection
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test doubles can only be used where we can inject them. This is not always
    possible. If the code we want to test creates a concrete class using the `new`
    keyword, then we cannot replace it with a double:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We see that the `profiles` field has been initialized using a concrete class
    `UserProfilesPostgres()`. There is no direct way to inject a test double with
    this design. We could attempt to get around this, using Java Reflection, but it
    is best to consider this as TDD feedback on a limitation of our design. The solution
    is to allow the dependency to be injected, as we have seen in previous examples.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: This is often a problem with **legacy code**, which is simply code that has
    been written before we work on it. If this code has created concrete objects –
    and the code cannot be changed – then we cannot apply a test double.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Don’t test the mock
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Testing the mock* is a phrase used to describe a test with too many assumptions
    built into a test double. Suppose we write a stub that stands in for some database
    access, but that stub contains hundreds of lines of code to emulate detailed specific
    queries to that database. When we write the test assertions, they will all be
    based on those detailed queries that we emulated in the stub.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: That approach will prove that the SUT logic responds to those queries. But our
    stub now assumes a great deal about how the real data access code will work. The
    stub code and the real data access code can quickly get out of step. This results
    in an invalid unit test that passes but with stubbed responses that can no longer
    happen in reality.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: When to use mock objects
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mocks are useful whenever our SUT is using a push model and requesting an action
    from some other component, where there is no obvious response such as the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Requesting an action from a remote service, such as sending an email to a mail
    server
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting or deleting data from a database
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a command over a TCP socket or serial interface
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalidating a cache
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing logging information either to a log file or distributing logging endpoint
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve learned some techniques in this section that allow us to verify that an
    action was requested. We have seen how we can use the Dependency Inversion Principle
    once again to allow us to inject a test double which we can query. We’ve also
    seen an example of hand-written code to do this. But must we always write test
    doubles by hand? In the next section, we will cover a very useful library that
    does most of the work for us.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Working with Mockito – a popular mocking library
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sections have shown examples of using stubs and mocks to test code.
    We have been writing these test doubles by hand. It’s obviously quite repetitive
    and time-consuming to do this. It begs the question of if this repetitive boilerplate
    code can be automated away. Thankfully for us, it can. This section will review
    the help available in the popular Mockito library.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Mockito is a free-of-charge open source library under the MIT license. This
    license means we can use this for commercial development work, subject to agreement
    by those we work for. Mockito provides a large range of features aimed at creating
    test doubles with very little code. The Mockito website can be found at [https://site.mockito.org/](B18384_08.xhtml#_idTextAnchor174).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Mockito
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting started with Mockito is straightforward. We pull in the `Mockito` library
    and an extension library in our Gradle file. The extension library allows `Mockito`
    to integrate closely with *JUnit5*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The excerpt of `build.gradle` looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Writing a stub with Mockito
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see how Mockito helps us create a stub object. We’ll use TDD to create
    a `UserGreeting` class that delivers a personalized greeting, after fetching our
    nickname from `interface UserProfiles`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write this using small steps, to see how TDD and Mockito work together:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the basic JUnit5 test class and integrate it with Mockito:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`@ExtendWith(MockitoExtension.class)` marks this test as using Mockito. When
    we run this JUnit5 test, the annotation ensures that the Mockito library code
    is run.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a test confirming the expected behavior. We will capture this in an assertion:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is standard usage of the *JUnit* and *AssertJ* frameworks as we have seen
    before. If we run the test now, it will fail.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Drive out our SUT – the class we want to write – with an Act step:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This step drives out the two new production code classes, as shown in the following
    steps.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `class` `UserGreeting` skeleton:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As usual, we add no code beyond what is required to make our test compile. The
    design decision captured here shows that our behavior is provided by a `formatGreeting()`method,
    which identifies a user by a `UserId` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `class` `UserId` skeleton:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Again, we get an empty shell just to get the test to compile. Then, we run
    the test and it still fails:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Test failure](img/Figure_8.3_B18384.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Test failure
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Another design decision to capture is that the `UserGreeting` class will depend
    on a `UserProfiles` interface. We need to create a field, create the interface
    skeleton, and inject the field in a new constructor for the SUT:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We continue by adding the bare minimum code to get the test to compile. If
    we run the test, it will still fail. But we’ve progressed further so the failure
    is now an `UnsupportedOperationException` error. This confirms that `formatGreeting()`
    has been called:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Failure confirms method call](img/Figure_8.4_B18384.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Failure confirms method call
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Add behavior to the `formatGreeting()` method:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Add `fetchNicknameFor()` to the `UserProfiles` interface:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Run the test. It will fail with a null exception:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Null exception failure](img/Figure_8.5_B18384.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Null exception failure
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The test fails because we passed the `profiles` field as a dependency into our
    SUT, but that field has never been initialized. This is where Mockito comes into
    play (finally).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `@Mock` annotation to the `profiles` field:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Running the test now produces a different failure, as we have not yet configured
    the Mockito mock:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Added mock, not configured](img/Figure_8.6_B18384.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Added mock, not configured
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure `@Mock` to return the correct stub data for our test:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'If you run the test again, it will fail due to a mistake in the greeting text.
    Fix this and then re-run the test, and it will pass:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Test pass](img/Figure_8.7_B18384.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Test pass
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: We’ve just created `class UserGreeting`, which accesses some stored nicknames
    for the user, via `interface UserProfiles`. That interface used DIP to isolate
    `UserGreeting` from any implementation details of that store. We used a stub implementation
    to write the test. We’ve followed TDD and leveraged Mockito to write that stub
    for us.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also notice that the test failed in the final step. I expected that step
    to pass. It didn’t because I had typed the greeting message incorrectly. Once
    again, TDD came to my rescue.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Writing a mock with Mockito
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mockito can create mock objects just as easily as stubs. We can still use the
    `@Mock` annotation on a field we wish to become a mock – perhaps making sense
    of the annotation, at last. We use the Mockito `verify()` method to check that
    our SUT called an expected method on a collaborator.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how a mock is used. We’ll write a test for some SUT code that
    we expect to send an email via `MailServer`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: In this test, we see the `@ExtendWith(MockitoExtension.class)` annotation to
    initialize Mockito, and the familiar Arrange, Act and Assert format of our test
    method. The new idea here is in the assertion. We use the `verify()` method from
    the Mockito library to check that the `sendEmail()` method was called correctly
    by our SUT. The check also verifies that it was called with the correct parameter
    values.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Mockito uses code generation to achieve all this. It wraps the interface we
    labeled with the `@Mock` annotation and intercepts each and every call. It stores
    parameter values for each call. When we come to using the `verify()` method to
    confirm that the method was called correctly, Mockito has all the data it needs
    to do this.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Beware Mockito’s when() and verify() syntax!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Mockito has subtly different syntax for `when()` and `verify()`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '* `when(``).thenReturn(expected value);`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '* `verify(``).method();`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Blurring the distinction between stubs and mocks
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to note about Mockito terminology is that it blurs the distinction
    between a stub and a mock object. In Mockito, we create test doubles that are
    labeled as mock objects. But in our test, we can use these doubles as either a
    stub, a mock, or even a mixture of both.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a test double to be both a stub and a mock is a test code smell.
    It’s not wrong, but it’s worth a pause for thought. We should consider if the
    collaborator that we are both mocking and stubbing has mixed up some responsibilities.
    It may be beneficial to split that object up.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Argument matchers – customizing behavior of test doubles
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have configured Mockito test doubles to respond to very specific
    inputs to the methods they replace. The previous MailServer example checked for
    three specific parameter values being passed to the `sendEmail()` method call.
    But we sometimes want more flexibility in our test doubles.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Mockito provides library methods called argument matchers. These are static
    methods that are used inside `when()` and `verify()` statements. Argument matchers
    are used to instruct Mockito to respond to a range of parameter values – including
    nulls and unknown values – that might get passed into a method under test.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test uses an argument matcher that accepts any value of `UserId`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: We’ve added an `any()` argument matcher to the stubbing of the `fetchNicknameFor()`
    method. This instructs Mockito to return the expected value `Alan` no matter what
    parameter value is passed into `fetchNicknameFor()`. This is useful when writing
    tests to guide our readers and help them to understand what is important and what
    is not for a particular test.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Mockito offers a number of argument matchers, described in the Mockito official
    documentation. These argument matchers are especially useful when creating a stub
    to simulate an error condition. This is the subject of the next section.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Driving error handling code with tests
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to look into a great use of stub objects, which
    is their role in testing error conditions.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: As we create our code, we need to ensure that it handles error conditions well.
    Some error conditions are easy to test. An example might be a user input validator.
    To test that it handles the error caused by invalid data, we simply write a test
    that feeds it invalid data and then write an assertion to check it successfully
    reported the data was invalid. But what about the code that uses it?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: If our SUT is code that responds to an error condition raised by one of its
    collaborators, we need to test that error response. How we test it depends on
    the mechanism we chose to report that error. We may be using a simple status code,
    in which case returning that error code from a stub will work very well.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: We may also have chosen to use Java exceptions to report this error. Exceptions
    are controversial. If misused, they can lead to very unclear control flow in your
    code. We need to know how to test them, however, as they appear in several Java
    libraries and in-house coding styles. Fortunately, there’s nothing difficult about
    writing the test for exception-handling code.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with creating a stub, using any of the approaches covered in this
    chapter. We then need to arrange for the stub to throw the appropriate exception
    when we call a method. Mockito has a nice feature to do this, so let’s see an
    example Mockito test that uses exceptions:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: At the start of this test, we use Mockito `doThrow()` to configure our mock
    object. This configures the Mockito mock object `mailServer` to throw `IllegalArgumentException`
    whenever we call `sendEmail()`, no matter what parameter values we send. This
    reflects a design decision to make `sendEmail()` throw that exception as a mechanism
    to report that the email address was not valid. When our SUT calls `mailServer.sendEmail()`,
    that method will throw `IllegalArgumentExeption`. We can exercise the code that
    handles this.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we decided to make the SUT wrap and rethrow `IllegalArgumentException`.
    We choose to create a new exception that relates to the responsibility of user
    notifications. We will call it `NotificationFailureException`. The assertion step
    of the test then uses the AssertJ library feature `assertThatExceptionOfType()`.
    This performs the Act and Assert steps together. We call our SUT `welcomeNewUser()`
    method and assert that it throws our `NotificationFailureException` error.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: We can see how this is enough to trigger the exception-handling response in
    our SUT code. This means we can write our test and then drive out the required
    code. The code we write will include a catch handler for `InvalidArgumentException`.
    In this case, all the new code has to do is throw a `NotificationFailureException`
    error. This is a new class that we will create that extends `RuntimeException`.
    We do this to report that something went wrong by sending a notification. As part
    of normal system layering considerations, we want to replace the original exception
    with a more general one, which is better suited to this layer of code.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: This section has examined features of Mockito and AssertJ libraries that help
    us use TDD to drive out exception-handling behavior. In the next section, let’s
    apply this to an error in our Wordz application.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Testing an error condition in Wordz
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will apply what we’ve learned by writing a test for a class
    that will choose a random word for the player to guess, from a stored set of words.
    We will create an interface called `WordRepository` to access stored words. We
    will do this through a `fetchWordByNumber(wordNumber)` method, where `wordNumber`
    identifies a word. The design decision here is that every word is stored with
    a sequential number starting from *1* to help us pick one at random.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: We will be writing a `WordSelection` class, which is responsible for picking
    a random number and using that to fetch a word from storage that is tagged with
    that number. We will be using our `RandomNumbers` interface from earlier. For
    this example, our test will cover the case where we attempt to fetch a word from
    the `WordRepository` interface, but for some reason, it isn’t there.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the test as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The test captures a few more design decisions relating to how we intend `WordRepository`
    and `WordSelection` to work. Our `fetchWordByNumber(wordNumber)` repository method
    will throw `WordRepositoryException` if there are any problems retrieving the
    word. Our intention is to make `WordSelection` throw its own custom exception
    to report that it cannot complete the `getRandomWord()` request.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: To set this situation up in the test, we first arrange for the repository to
    throw. This is done using the Mockito `doThrow()` feature. Whenever the `fetchWordByNumber()`
    method is called, whatever parameter we pass into it Mockito will throw the exception
    we asked it to throw, which is `WordRepositoryException`. This allows us to drive
    out the code that handles this error condition.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Arrange step is completed by creating the `WordSelection` SUT class. We
    pass in two collaborators to the constructor: the `WordRepository` instance and
    a `RandomNumbers` instance. We have asked Mockito to create stubs for both interfaces
    by adding the `@Mock` annotation to test double the `repository` and `random`
    fields.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: With the SUT now properly constructed, we are ready to write the Act and Assert
    steps of the test. We are testing that an exception is thrown, so we need to use
    the `assertThatExceptionOfType()` AssertJ facility to do this. We can pass in
    the class of the exception that we are expecting to be thrown, which is `WordSelectionException`.
    We chain the `isThrownBy()` method to perform the Act step and make our SUT code
    run. This is provided as a Java lambda function as a parameter to the `isThrownBy()`
    method. This will call the `getRandomWord()` method, which we intend to fail and
    throw an exception. The assertion will confirm that this has happened and that
    the expected kind of exception class has been thrown. We will run the test, see
    it fail, and then add the necessary logic to make the test pass.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The test code shows us that we can use test doubles and verification of error
    conditions with test-first TDD. It also shows that tests can become easily coupled
    to a specific implementation of a solution. There are a lot of design decisions
    in this test about which exceptions happen and where they are used. These decisions
    even include the fact that exceptions are being used at all to report errors.
    All that said, this is still a reasonable way to split responsibilities and define
    contracts between components. It is all captured in the test.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at how to solve the problem of testing problematic
    collaborators. We have learned how to use stand-in objects for collaborators called
    test doubles. We’ve learned that this gives us simple control over what those
    collaborators do inside our test code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Two kinds of test double are especially useful to us: the stub and the mock.
    Stubs return data. Mocks verify that methods were called. We’ve learned how to
    use the Mockito library to create stubs and mocks for us.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: We’ve used AssertJ to verify the SUT behaved correctly under the various conditions
    of our test doubles. We’ve learned how to test error conditions that throw exceptions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: These techniques have expanded our toolkit for writing tests.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to cover a very useful system design technique
    that allows us to get most of our code under FIRST unit test, and at the same
    time avoid the problems of testing collaborations with external systems that we
    cannot control.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are the terms stub and mock used interchangeably?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, even though they have different meanings. In normal conversation, we tend
    to trade precision for fluency, and that’s okay. It’s important to understand
    the different uses that each kind of test double has. When speaking, it’s usually
    better to not be pedantic whenever a group of people knows what is meant. So long
    as we stay aware that a test double is the proper general term and that the specific
    types of doubles have different roles, all will be well.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: What is the problem known as “testing the mock”?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This happens when the SUT has no real logic in it, yet we try to write a unit
    test anyway. We wire up a test double to the SUT and write the test. What we will
    find is that the assertions only check that the test double-returned the right
    data. It’s an indication that we have tested at the wrong level. This kind of
    error can be driven by setting unwise code coverage targets or forcing an equally
    unwise test-per-method rule. This test adds no value and should be removed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Can test doubles be used anywhere?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. This only works if you have designed your code using the Dependency Inversion
    Principle so that a test double can be swapped in place of a production object.
    Using TDD certainly forces us to think about this kind of design issue early.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests later is made more difficult if there is insufficient access to
    inject test doubles where they are needed. Legacy code is particularly difficult
    in this respect, and I recommend reading the book *Working Effectively with Legacy
    Code* by Michael Feathers for techniques to aid in adding tests to code that lacks
    the necessary test access points. (See the *Further* *reading* list.)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法在需要的地方注入测试替身，那么后续编写测试将变得更加困难。在这一点上，遗留代码尤其困难，我建议阅读迈克尔·费瑟斯的书籍《与遗留代码有效工作》，以获取帮助添加测试到缺乏必要测试访问点的代码的技术。（参见*进一步阅读*列表。）
- en: Further reading
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://site.mockito.org/](B18384_08.xhtml#_idTextAnchor174)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://site.mockito.org/](B18384_08.xhtml#_idTextAnchor174)'
- en: Mockito library home page
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 库主页
- en: '*Working Effectively with Legacy Code, Michael C. Feathers* *ISBN 978-0131177055*'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《与遗留代码有效工作》，迈克尔·C·费瑟斯* *ISBN 978-0131177055*'
- en: This book explains how you can work with legacy code written without Dependency
    Inversion access points for test doubles. It shows a range of techniques to safely
    rework the legacy code so that test doubles can be introduced.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书解释了如何处理没有为测试替身提供依赖倒置访问点的遗留代码。它展示了一系列技术，以安全地重构遗留代码，从而可以引入测试替身。
