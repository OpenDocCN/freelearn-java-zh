<html><head></head><body>
		<div id="_idContainer107">
			<h1 class="chapter-number" id="_idParaDest-333"><a id="_idTextAnchor365"/>8</h1>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor366"/>Spring Reactive and Spring Cloud Stream</h1>
			<p>A different approach to applications may be necessary in high concurrency scenarios, with resource-intensive operations such as <strong class="bold">Input/Output</strong> (<strong class="bold">I/O</strong>)-bounded tasks that require low latency and responsiveness. In this chapter, we’ll learn about two Spring Boot projects that address such <span class="No-Break">a scenario.</span></p>
			<p><strong class="bold">Spring Reactive</strong> is Spring’s response to reactive processing scenarios. Reactive processing is a paradigm that allows developers to build <strong class="bold">non-blocking</strong>, asynchronous applications that can handle <strong class="bold">backpressure</strong>. Non-blocking means that when an application waits for an external resource to respond, for instance, when calling an external web service or database, the application doesn’t block the processing thread. Instead, it reuses the processing threads to handle new requests. Backpressure is a mechanism for handling situations where a downstream component cannot keep up with the rate of data production from an upstream component. For these mechanisms, Spring Reactive can be used in high-concurrency scenarios with <span class="No-Break">resource-intensive operations.</span></p>
			<p><strong class="bold">Spring WebFlux</strong> is the reactive web framework equivalent to the Spring <strong class="bold">model-view-controller</strong> (<strong class="bold">MVC</strong>) we used in the previous chapters. To facilitate the transition between web frameworks, Spring WebFlux mirrors the names and annotations from the <span class="No-Break">Spring MVC.</span></p>
			<p>Spring Data <strong class="bold">Reactive Relational Database Connectivity</strong> (<strong class="bold">R2DBC</strong>) is the specification for integrating relational databases using reactive drivers. Compared to traditional blocking drivers, it also applies <span class="No-Break">familiar abstractions.</span></p>
			<p><strong class="bold">Spring Cloud Stream</strong> is a framework for building highly scalable event-driven distributed applications connected with shared messaging systems. You can use reactive programming with Spring Cloud Stream, but the main goal of Spring Cloud Stream is to create loosely coupled distributed applications that can scale independently. Rather than trying to optimize the runtime execution as reactive does, Spring Cloud Stream provides the foundations for creating distributed applications that can work with some asynchronous degree. Spring Reactive and Spring Cloud Stream can be combined and complementary in <span class="No-Break">high-concurrency scenarios.</span></p>
			<p>In the first part of this chapter, we’ll explore Spring Reactive by learning how to use Spring WebFlux and Spring Data R2DBC with PostgreSQL. In the second part, we’ll learn how to use Spring Cloud Stream while using RabbitMQ as the messaging service. What you’ll learn can be applied to other messaging services, such as Kafka, or other services provided by cloud providers, such as Amazon Kinesis, Azure Event Hub, or <span class="No-Break">Google PubSub.</span></p>
			<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Creating a reactive <span class="No-Break">RESTful API</span></li>
				<li>Using a reactive <span class="No-Break">API client</span></li>
				<li>Testing <span class="No-Break">reactive applications</span></li>
				<li>Connecting to PostgreSQL using Spring <span class="No-Break">Data R2DBC</span></li>
				<li>Event-driven applications with Spring Cloud Stream <span class="No-Break">and RabbitMQ</span></li>
				<li>Routing messages with Spring Cloud Stream <span class="No-Break">and RabbitMQ</span></li>
				<li>Error handling with Spring <span class="No-Break">Cloud Stream</span></li>
			</ul>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor367"/>Technical requirements</h1>
			<p>In this chapter, we’ll need a PostgreSQL server and a RabbitMQ server. The easiest way to run them on your computer is by using Docker. You can get Docker from the official site at <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a>. I will explain how to deploy each tool in its <span class="No-Break">corresponding recipe.</span></p>
			<p>All the recipes that will be demonstrated in this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter8"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter8</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor368"/><a id="_idTextAnchor369"/><a id="_idTextAnchor370"/>Creating a reactive RESTful API</h1>
			<p>Spring Reactive is the Spring<a id="_idIndexMarker855"/> initiative that provides reactive programming features and capabilities that can be used in our Spring Boot applications. It is designed to support asynchronous and non-blocking programming. But what are asynchronous and non-blocking programming? To understand these concepts, it is better to start with the traditional model, the non-reactive <span class="No-Break">programming model.</span></p>
			<p>In a traditional model, when a Spring Boot application receives a request, a dedicated thread processes that request. If that request requires communicating with another service, such as a database, the processing thread is blocked until it receives a response from the other service. The number of available threads is limited, so if your application requires high concurrency but mostly waits for its dependent services to finish, this synchronous blocking model may <span class="No-Break">have limitations.</span></p>
			<p>In the reactive model, asynchronous and non-blocking programming reuses the threads across the concurrent requests and is not blocked by I/O operations, such as network calls or <span class="No-Break">file operations.</span></p>
			<p>Reactive programming is particularly well suited for building applications requiring high concurrency and scalability, such <a id="_idIndexMarker856"/>as web applications that handle many concurrent connections or real-time data <span class="No-Break">processing systems.</span></p>
			<p>In this recipe, we will use Spring WebFlux to build a RESTful API using reactive programming. Spring WebFlux is a module within Spring that enables reactive programming for building <span class="No-Break">web applications.</span></p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor371"/>Getting ready</h2>
			<p>This recipe doesn’t have additional requirements. We will generate the project using the <strong class="bold">Spring Initializr</strong> tool and, once <a id="_idIndexMarker857"/>downloaded, you can<a id="_idIndexMarker858"/> make the changes with your favorite <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) <span class="No-Break">or editor.</span></p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor372"/>How to do it...</h2>
			<p>In this recipe, we will create a RESTful API application. This time, we will create it using reactive programming, unlike the recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Open <a href="https://start.spring.io">https://start.spring.io</a> and use the same parameters as in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, in the <em class="italic">Creating a RESTful API</em> recipe, except changing the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">cards</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring </strong><span class="No-Break"><strong class="bold">Reactive Web</strong></span></li></ul></li>
				<li>In the <strong class="source-inline">cards</strong> project, add a record named <strong class="source-inline">Card</strong>. Define the record <span class="No-Break">as follows:</span><pre class="source-code">
public record Card(String cardId, String album,
                   String player, int ranking) {
}</pre></li>				<li>In the same folder, add a controller <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">CardsController</strong></span><span class="No-Break">:</span><pre class="source-code">
@RequestMapping("/cards")
@RestController
public class CardsController</pre><ul><li>Add a method named <strong class="source-inline">getCards</strong> that retrieves <span class="No-Break">all cards:</span><pre class="source-code">@GetMapping
public <strong class="bold">Flux&lt;Card&gt;</strong> getCards() {
    return Flux.fromIterable(
            List.of(
                new Card("1", "WWC23", "Ivana Andres", 7),
                new Card("2", "WWC23", "Alexia Putellas", 1)));
}</pre></li><li>And add another<a id="_idIndexMarker859"/> method to retrieve <span class="No-Break">a card:</span><pre class="source-code">@GetMapping("/{cardId}")
public <strong class="bold">Mono&lt;Card&gt;</strong> getCard(@PathVariable String cardId) {
   return Mono.just(new Card(cardId, "WWC23", "Superplayer", 1));
}</pre></li></ul><p class="list-inset">In WebFlux, <strong class="source-inline">Flux&lt;T&gt;</strong> is used to return a stream of objects, while <strong class="source-inline">Mono&lt;T&gt;</strong> is used to return a single object. In non-reactive programming, they would be the equivalents to returning <strong class="source-inline">List&lt;T&gt;</strong> for <strong class="source-inline">Flux&lt;T&gt;</strong> and <strong class="source-inline">T</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Mono&lt;T&gt;</strong></span><span class="No-Break">.</span></p><p class="list-inset">In this controller, <strong class="source-inline">Flux&lt;Card&gt; getCards()</strong> returns multiple objects of the <strong class="source-inline">Card</strong> type, and <strong class="source-inline">Mono&lt;Card&gt; getCard</strong> returns just <span class="No-Break">one card.</span></p></li>				<li>Now, add an <a id="_idIndexMarker860"/>exception class named <strong class="source-inline">SampleException</strong>, implementing a new <span class="No-Break">custom exception:</span><pre class="source-code">
public class SampleException extends RuntimeException {
    public SampleException(String message) {
        super(message);
    }
}</pre></li>				<li>Then, add two more methods to <strong class="source-inline">CardsController</strong> to demonstrate how to implement error handling <span class="No-Break">in WebFlux:</span><pre class="source-code">
@GetMapping("/exception")
public Mono&lt;Card&gt; getException() {
    throw new SampleException("This is a sample exception");
}
<strong class="bold">@ExceptionHandler(SampleException.class)</strong>
public ProblemDetail handleSampleException(SampleException e) {
    ProblemDetail problemDetail = ProblemDetail
               .forStatusAndDetail(HttpStatus.BAD_REQUEST,
                                   e.getMessage());
    problemDetail.setTitle("sample exception");
    return problemDetail;
}</pre><p class="list-inset">The <strong class="source-inline">getException</strong> method always throws the exception, and <strong class="source-inline">handleSampleException</strong> handles exceptions of the <span class="No-Break"><strong class="source-inline">SampleException</strong></span><span class="No-Break"> type.</span></p></li>				<li>Now, open a terminal in the <a id="_idIndexMarker861"/>root folder of the cards project and execute the <span class="No-Break">following command:</span><pre class="source-code">
./mvnw spring-boot:run</pre><p class="list-inset">We now have the RESTful API <span class="No-Break">server running.</span></p></li>				<li>You can test the application by executing a request to <strong class="source-inline">http://locahost:8080/cards</strong>. You can use <strong class="source-inline">curl</strong> for <span class="No-Break">this purpose:</span><pre class="source-code">
curl http://localhost:8080/cards</pre><p class="list-inset">You can also test how error handling works by requesting <strong class="source-inline">http://localhost:8080/exception</strong>. You will see that it will return an <strong class="source-inline">HTTP </strong><span class="No-Break"><strong class="source-inline">400</strong></span><span class="No-Break"> result.</span></p></li>			</ol>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor373"/>How it works...</h2>
			<p>We used the same annotations as Spring Web to define the controllers in this recipe. However, the methods return the <strong class="source-inline">Mono</strong> and <strong class="source-inline">Flux</strong> types instead of traditional objects, indicating that the responses will be generated asynchronously. <strong class="source-inline">Mono</strong> and <strong class="source-inline">Flux</strong> are the core interfaces of the reactive programming model in WebFlux. <strong class="source-inline">Mono</strong> is used for asynchronous operations that produce at most one result, while <strong class="source-inline">Flux</strong> is used for asynchronous operations that return zero or <span class="No-Break">more elements.</span></p>
			<p>Reactive programming is centered around the concept of reactive streams. Reactive streams model asynchronous data flows with non-blocking backpressure. I mentioned some terms that may sound<a id="_idIndexMarker862"/> strange, so let me <span class="No-Break">clarify them:</span></p>
			<ul>
				<li><strong class="bold">Non-blocking</strong>: This refers to operations related to I/O, such as making an HTTP request, that avoid blocking threads. This<a id="_idIndexMarker863"/> enables the execution of a large number of concurrent requests without a dedicated thread <span class="No-Break">per request.</span></li>
				<li><strong class="bold">Backpressure</strong>: This is a mechanism to<a id="_idIndexMarker864"/> ensure that data is only produced as fast as it can be consumed, preventing resource exhaustion. For instance, this situation may happen when a <a id="_idIndexMarker865"/>downstream component cannot keep up with the data emitted by an upstream component. WebFlux manages the <span class="No-Break">backpressure automatically.</span></li>
			</ul>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor374"/>There’s more...</h2>
			<p>In addition to the annotation-based programming model used in this recipe, WebFlux also supports the <strong class="bold">functional programming</strong> model in<a id="_idIndexMarker866"/> defining the routes and handling requests. For instance, we can achieve the same result as the <strong class="source-inline">cards</strong> RESTful API with the <span class="No-Break">following code:</span></p>
			<ol>
				<li>First, create a class handling <span class="No-Break">the logic:</span><pre class="source-code">
public class CardsHandler {
    public Flux&lt;Card&gt; getCards() {
        return Flux.fromIterable(List.of(
                  new Card("1", "WWC23", "Ivana Andres", 7),
                  new Card("2", "WWC23", "Alexia Putellas", 1)));
    }
    public Mono&lt;Card&gt; getCard(String cardId) {
        return Mono.just(
             new Card(cardId, "WWC23", "Superplayer", 1));
    }
}</pre></li>				<li>And another one to configure <span class="No-Break">the application:</span><pre class="source-code">
@Configuration
public class CardsRouterConfig {
    @Bean
    CardsHandler cardsHandler() {
        return new CardsHandler();
    }
    <strong class="bold">@Bean</strong>
<strong class="bold">    RouterFunction&lt;ServerResponse&gt; getCards() {</strong>
<strong class="bold">        return route(GET("/cards"), req -&gt;</strong>
<strong class="bold">             ok().body(cardsHandler().getCards(), Card.class));</strong>
<strong class="bold">    }</strong>
    <strong class="bold">@Bean</strong>
<strong class="bold">    RouterFunction&lt;ServerResponse&gt; getCard(){</strong>
<strong class="bold">        return route(GET("/cards/{cardId}"), req -&gt;</strong>
<strong class="bold">             ok().body(</strong>
<strong class="bold">                cardsHandler().getCard(</strong>
<strong class="bold">                    req.pathVariable("cardId")), Card.class));</strong>
<strong class="bold">    }</strong>
}</pre></li>			</ol>
			<p><strong class="bold">Annotation-based programming</strong> is more like a traditional non-reactive programming model, while functional programming <a id="_idIndexMarker867"/>can be more expressive, especially for complex routing scenarios. The functional style is better suited for handling high concurrency and non-blocking scenarios because it naturally integrates with <span class="No-Break">reactive programming.</span></p>
			<p>Using annotation-based or<a id="_idIndexMarker868"/> functional is a matter of <span class="No-Break">personal preference.</span></p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor375"/>Using a reactive API client</h1>
			<p>We have a RESTful API, now it’s time to <a id="_idIndexMarker869"/>use it in a non-blocking fashion. We’ll create a reactive RESTful API that calls another <span class="No-Break">RESTful API.</span></p>
			<p>In this recipe, we’ll create a reactive application that consumes an API. We’ll learn how to use the reactive WebClient to perform requests to the target <span class="No-Break">RESTful API.</span></p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor376"/>Getting ready</h2>
			<p>In this recipe, we’ll consume the application created in the <em class="italic">Creating a reactive RESTful API</em> recipe. If you haven’t completed it yet, I prepared a working version that you can use as a starting point for this recipe. You can find it on the<a id="_idTextAnchor377"/> book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter8/recipe8-2/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>You can run the target project and keep it for the rest of <span class="No-Break">the recipe.</span></p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor378"/>How to do it...</h2>
			<p>We’ll create an efficient consumer application for our <span class="No-Break">RESTful API:</span></p>
			<ol>
				<li>First, we’ll create a new application using the Spring Boot Initializr tool. You can use the same options as in the <em class="italic">Creating a RESTful API</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, except changing the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">consumer</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring </strong><span class="No-Break"><strong class="bold">Reactive Web</strong></span></li></ul></li>
				<li>As we run the consumer application alongside the <strong class="source-inline">cards</strong> application, we’ll need to change the port where the application listens for requests. We’ll set <strong class="source-inline">8090</strong> as the server port. We will also create a configuration for the target football service URL. For that, open the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder and set the <span class="No-Break">following content:</span><pre class="source-code">
server:
    port: 8090
footballservice:
    url: http://localhost:8080</pre></li>				<li>Now, create a record <a id="_idIndexMarker870"/>named <strong class="source-inline">Card</strong> with the <span class="No-Break">following content:</span><pre class="source-code">
public record Card(String cardId, String album,
                   String player, int ranking) {
}</pre></li>				<li>Then, we’ll create a controller class named <strong class="source-inline">ConsumerController</strong> that will consume the target RESTful API. So, this controller will need a WebClient. For that, set the <strong class="source-inline">ConsumerController</strong> <span class="No-Break">as follows:</span><pre class="source-code">
@RequestMapping("/consumer")
@RestController
public class ConsumerController {
    private final WebClient webClient;
    public ConsumerController(@Value("${footballservice.url}")
                               String footballServiceUrl) {
        this.webClient = WebClient.create(footballServiceUrl);
    }
}</pre><p class="list-inset">The controller now has a WebClient that allows us to perform requests in a non-blocking fashion in our <span class="No-Break">client application.</span></p></li>				<li>Create a method to consume<a id="_idIndexMarker871"/> the operation from the other application that returns a stream of <strong class="source-inline">Card</strong> instances. For that, in <strong class="source-inline">ConsumerController</strong>, add the <span class="No-Break">following method:</span><pre class="source-code">
@GetMapping("/cards")
public <strong class="bold">Flux&lt;Card&gt;</strong> getCards() {
    return <strong class="bold">webClient.get()</strong>
<strong class="bold">            .uri("/cards").retrieve()</strong>
<strong class="bold">            .bodyToFlux(Card.class);</strong>
}</pre></li>				<li>Create a method to consume the method returning a single object by adding the following method to the <span class="No-Break"><strong class="source-inline">ConsumerController</strong></span><span class="No-Break"> class:</span><pre class="source-code">
@GetMapping("/cards/{cardId}")
public <strong class="bold">Mono&lt;Card&gt;</strong> getCard(@PathVariable String cardId) {
    return <strong class="bold">webClient.get()</strong>
<strong class="bold">            .uri("/cards/" + cardId).retrieve()</strong>
<strong class="bold">            .onStatus(code -&gt; code.is4xxClientError(),</strong>
<strong class="bold">                    response -&gt; Mono.empty())</strong>
<strong class="bold">            .bodyToMono(Card.class);</strong>
}</pre></li>				<li>Then, create a method that manages different response codes from the <span class="No-Break">remote server:</span><pre class="source-code">
@GetMapping("/error")
public Mono&lt;String&gt; getFailedRequest() {
    return webClient.get()
            .uri("/invalidpath")
            .exchangeToMono(response -&gt; {
                if (response.statusCode()
                       .equals(HttpStatus.NOT_FOUND))
                    return Mono.just("Server returned 404");
                else if (response.statusCode()
                       .equals(HttpStatus.INTERNAL_SERVER_ERROR))
                    return Mono.just("Server returned 500: "
                            + response.bodyToMono(String.class));
                else
                    return response.bodyToMono(String.class);
            });
}</pre></li>				<li>Let’s run the consumer application now. When we perform requests to the client application, it will call the server RESTful API server application. Remember that we have the server RESTFul API <a id="_idIndexMarker872"/>server already running, as explained in the <em class="italic">Getting ready</em> section. Open a terminal in the root folder of the <strong class="source-inline">consumer</strong> project and execute <span class="No-Break">the following:</span><pre class="source-code">
./mvnw spring-boot:run</pre></li>				<li>Now, test the <strong class="source-inline">consumer</strong> application. Remember that it listens on port <strong class="source-inline">8090</strong>, and the server application listens on port <strong class="source-inline">8080</strong>. In the terminal, execute the <span class="No-Break">following command:</span><pre class="source-code">
curl http://localhost:8090/consumer/cards</pre><p class="list-inset">It will return a list of cards. The consumer application calls the server application to get the list <span class="No-Break">of cards.</span></p><p class="list-inset">Now, execute the <span class="No-Break">following command:</span></p><pre class="source-code">curl http://localhost:8090/consumer/cards/7</pre><p class="list-inset">It will return just a single <strong class="source-inline">Card</strong>. Again, the consumer application retrieved the <strong class="source-inline">Card</strong> with id number 7 from the RESTful API <span class="No-Break">server application.</span></p><pre class="source-code">curl http://localhost:8090/consumer/error</pre><p class="list-inset">It will return <strong class="source-inline">Remote Server return 404</strong>. The <strong class="source-inline">consumer</strong> application tried to call a <a id="_idIndexMarker873"/>method that does not exist in the server RESTful API server application. The consumer application handles the HTTP response codes from the server, in this case, <strong class="source-inline">HttpStatus.NOT_FOUND</strong> to return the final response message, which is <strong class="source-inline">Remote Server</strong> <span class="No-Break"><strong class="source-inline">return 404</strong></span><span class="No-Break">.</span></p></li>			</ol>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor379"/>How it works...</h2>
			<p>In this example, we consumed a RESTful API that is implemented using reactive technologies, but from the consumer’s point of view, it doesn’t matter. We can consume any RESTful API, regardless of the <span class="No-Break">internal implementation.</span></p>
			<p>What’s important is that as we take advantage of a non-blocking client, the consumer application will benefit if it’s also reactive. When we request against the consumer application, it will perform another request to the <strong class="source-inline">cards</strong> application. As we use a reactive client in the <strong class="source-inline">consumer</strong> application, it won’t block a thread while the <strong class="source-inline">cards</strong> application responds, making that thread available to process other requests. This way, the application can manage higher concurrency than traditional blocking <span class="No-Break">threads applications.</span></p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor380"/>Testing reactive applications</h1>
			<p>As with non-reactive Spring Boot applications, we want to automate the testing of our reactive applications, and <a id="_idIndexMarker874"/>Spring Boot provides excellent support for testing <span class="No-Break">such scenarios.</span></p>
			<p>In this recipe, we’ll learn how to create the tests using the components provided by default by Spring Boot when we add the <strong class="bold">Spring Reactive </strong><span class="No-Break"><strong class="bold">Web</strong></span><span class="No-Break"> starter.</span></p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor381"/>Getting ready</h2>
			<p>In this recipe, we’ll create the tests for the projects used in the <em class="italic">Using a reactive API client</em> recipe. If you haven’t completed that recipe yet, you can use the completed version that I prepared as a starting point for this recipe. You can find it in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter8/recipe8-3/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor382"/>How to do it...</h2>
			<p>We like robust and reliable applications. We’ll do it with our <span class="No-Break">Reactive applications:</span></p>
			<ol>
				<li>As the applications from the <em class="italic">Using a reactive API client</em> recipe<span class="Annotation-reference"> </span>were created with the Spring Boot Initializr tool, just by adding Spring Reactive Web starter the testing dependencies are already included. You can check that the <strong class="source-inline">pom.xml</strong> file contains the <span class="No-Break">following dependencies:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></li>				<li>Now, we’ll start the tests with the <strong class="source-inline">cards</strong> application. Create a new test class named <strong class="source-inline">CardsControllerTest</strong>. Remember, it should be created under the <strong class="source-inline">test</strong> folder; you can create it in the <span class="No-Break"><strong class="source-inline">src/test/java/com/packt/cards</strong></span><span class="No-Break"> folder:</span><ul><li>The test class should be annotated <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@WebFluxTest</strong></span><span class="No-Break">:</span><pre class="source-code">
@WebFluxTest(CardsController.class)
public class CardsControllerTests</pre></li><li>Then, we’ll inject<a id="_idIndexMarker875"/> a <strong class="source-inline">WebTestClient</strong> field. For that, annotate the new field <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Autowired</strong></span><span class="No-Break">:</span><pre class="source-code">@Autowired
WebTestClient webTestClient;</pre></li><li>Now, we can use the <strong class="source-inline">webTestClient</strong> field to emulate the calls to the reactive RESTful API. For instance, let’s create a test for the <strong class="source-inline">/cards</strong> path that returns a list of type <strong class="source-inline">Card</strong>. For that, create a new method annotated <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Test</strong></span><span class="No-Break">:</span><pre class="source-code">@Test
void testGetCards() {
    <strong class="bold">webTestClient</strong>.get()
            .uri("/cards").exchange()
            .expectStatus().isOk()
            <strong class="bold">.expectBodyList(Card.class)</strong>;
}</pre></li><li>Let’s test the <strong class="source-inline">/cards/exception</strong> path. For learning purposes, this path always returns <strong class="source-inline">a 404 code</strong>, a bad request result; and the body is of type <strong class="source-inline">ProblemDetail</strong>. The test <a id="_idIndexMarker876"/>method may look <span class="No-Break">as follows:</span><pre class="source-code">@Test
void testGetException() {
    webTestClient.get()
            .uri("/cards/exception").exchange()
            <strong class="bold">.expectStatus().isBadRequest()</strong>
            <strong class="bold">.expectBody(ProblemDetail.class)</strong>;
}</pre></li></ul></li>				<li>Next, we’ll create the tests for the <strong class="source-inline">consumer</strong> application. As we want to test this application independently of the <strong class="source-inline">cards</strong> application, we’ll need to mock the <strong class="source-inline">cards</strong> application server. As we learned in the <em class="italic">Mocking a RESTful API</em> recipe, in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, we’ll use the WireMock library. For that, open the <strong class="source-inline">pom.xml</strong> file of the project <strong class="source-inline">consumer</strong> and add the <span class="No-Break">following dependency:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt;
    &lt;artifactId&gt;wiremock-standalone&lt;/artifactId&gt;
    &lt;version&gt;3.0.1&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></li>				<li>Now that we have all the dependencies, we’ll create a new test class named <strong class="source-inline">ConsumerControllerTest</strong> and prepare it before writing <span class="No-Break">the tests:</span><ol><li class="upper-roman">First, annotate the class with <strong class="source-inline">@SpringBootTest</strong> and set a few configuration options <span class="No-Break">as follows:</span></li></ol><pre class="source-code">
<strong class="bold">@SpringBootTest</strong>(
      webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
      classes = {ConsumerApplication.class,
              ConsumerController.class,
              <strong class="bold">ConsumerControllerTests.Config</strong>.class})
public class ConsumerControllerTests</pre><ol><li class="upper-roman" value="2">Note that we set a new class in the <strong class="source-inline">classes</strong> field that doesn’t exist yet, <strong class="source-inline">ConsumerControllerTests.Config</strong>. It’s used to configure the MockServer, as you’ll <span class="No-Break">see soon.</span></li><li class="upper-roman">Next, we’ll need to <a id="_idIndexMarker877"/>set up the WireMock server. For that, we’ll create a configuration subclass class named <strong class="source-inline">Config</strong>; it will define a <span class="No-Break"><strong class="source-inline">WireMockServer</strong></span><span class="No-Break"> bean:</span></li></ol><pre class="source-code"><strong class="bold">@TestConfiguration</strong>
static class Config {
    <strong class="bold">@Bean</strong>
    public <strong class="bold">WireMockServer</strong> webServer() {
        WireMockServer wireMockServer = new WireMockServer(<strong class="bold">7979</strong>);
        wireMockServer.start();
        return wireMockServer;
    }
}</pre><ol><li class="upper-roman" value="4">Then, we need to configure the URI of the new remote server for the reactive WebClient. We need to set the <strong class="source-inline">footballservice.url</strong> application context variable. To perform this dynamic configuration, we’ll use the <strong class="source-inline">@DynamicPropertySource</strong> annotation. For that, define a static method in the <span class="No-Break"><strong class="source-inline">ConsumerControllerTests</strong></span><span class="No-Break"> class:</span></li></ol><pre class="source-code"><strong class="bold">@DynamicPropertySource</strong>
static void setProperties(DynamicPropertyRegistry registry) {
    registry.add("<strong class="bold">footballservice.url</strong>",
                 () -&gt; "http://localhost:7979");
}</pre><ol><li class="upper-roman" value="5">To complete the test preparation, we’ll inject <strong class="source-inline">WebTestClient</strong> and <strong class="source-inline">WireMockServer</strong>, which <a id="_idIndexMarker878"/>we’ll use in the tests. For that, define the fields with the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Autowired</strong></span><span class="No-Break"> annotation:</span></li></ol><pre class="source-code">@Autowired
private WebTestClient webTestClient;
@Autowired
private WireMockServer server;</pre></li>				<li>We can write the tests now. For instance, we’ll create a test to get <span class="No-Break">the cards:</span><ol><li class="upper-roman">We can name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">getCards</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
@Test
public void getCards()</pre><ol><li class="upper-roman" value="2">First, we’ll arrange what the mocked cards server will return. For that, we’ll mock a small set of results for <span class="No-Break">learning purposes:</span></li></ol><pre class="source-code">server.stubFor(WireMock.get(WireMock.urlEqualTo("/cards"))
        .willReturn(
                WireMock.aResponse()
                  .withStatus(200)
                  .withHeader("Content-Type", "application/json")
                  .withBody("""
                  [
                      {
                          "cardId": "1",
                          "album": "WWC23",
                          "player": "Ivana Andres",
                          "ranking": 7
                      },
                      {
                          "cardId": "2",
                          "album": "WWC23",
                          "player": "Alexia Putellas",
                          "ranking": 1
                       }
                  ]""")));</pre><ol><li class="upper-roman" value="3">Then, we can <a id="_idIndexMarker879"/>perform the request using <strong class="source-inline">webTestClient</strong> and validate <span class="No-Break">the results:</span></li></ol><pre class="source-code"><strong class="bold">webTestClient</strong>.get().uri("/consumer/cards")
        .exchange().expectStatus().isOk()
        .expectBodyList(Card.class).hasSize(2)
        .contains(new Card("1", "WWC23", "Ivana Andres", 7),
                new Card("2", "WWC23", "Alexia Putellas", 1));</pre></li>				<li>You can write tests for the rest of the application’s features. I created some sample tests, which you can find in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter8/recipe8-3/end</strong></span><span class="No-Break"> folder.</span></li>
			</ol>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor383"/>How it works...</h2>
			<p>With the <strong class="source-inline">@WebFluxTest</strong> annotation, we can define test classes focusing only on WebFlux-related components. This means that it will disable the configuration of all components save for those relevant to WebFlux. For instance, it will configure the classes annotated with <strong class="source-inline">@Controller</strong> or <strong class="source-inline">@RestController</strong>, but it won’t configure classes annotated with <strong class="source-inline">@Service</strong>. With that, Spring Boot can inject <strong class="source-inline">WebTestClient</strong>, which we can use to perform requests to our <span class="No-Break">application server.</span></p>
			<p>In the consumer application, we <a id="_idIndexMarker880"/>need to mock the <strong class="source-inline">cards</strong> service. I won’t go deeply into the details, as the mechanism is the same as explained in the <em class="italic">Mocking a RESTful API</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. We used a configuration subclass annotated with <strong class="source-inline">@TestConfiguration</strong>. This annotation allows the configuration of beans that can be used alongside the tests. In our case, we just needed <strong class="source-inline">WireMockServer</strong>. Then, we dynamically configured the URI of the mocked server using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">DynamicPropertySource</strong></span><span class="No-Break"> annotation.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">To reference the <strong class="source-inline">Config</strong> class, we used <strong class="source-inline">ConsumerControllerTests.Config</strong> instead of just <strong class="source-inline">Config</strong>. The reason for this is that it’s a subclass of the <span class="No-Break"><strong class="source-inline">ConsumerControllerTests</strong></span><span class="No-Break"> class.</span></p>
			<p class="callout">We used the <strong class="source-inline">webEnvironment</strong> field, assigning <strong class="source-inline">SpringBootTest.WebEnvironment.RANDOM_PORT</strong>. This means that the test will host the application as a service on a random port. We used that to avoid port collisions with the <span class="No-Break">remote server.</span></p>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor384"/>Connecting to PostgreSQL using Spring Data R2DBC</h1>
			<p>Using a Reactive database driver<a id="_idIndexMarker881"/> makes sense as we need to <a id="_idIndexMarker882"/>connect our Reactive application to PostgreSQL. This means the application is not blocked when it makes requests to the database. There is a Java specification to integrate SQL databases using reactive drivers named <strong class="bold">R2DBC</strong>. Spring Framework supports R2DBC with Spring Data R2DBC, which is <a id="_idIndexMarker883"/>part of the larger Spring <span class="No-Break">Data family.</span></p>
			<p>Spring Data R2DBC applies familiar Spring abstractions for R2DBC. You may use <strong class="source-inline">R2dbcEntityTemplate</strong>, running statements using the Criteria API and Reactive Repositories, among <span class="No-Break">other features.</span></p>
			<p>In this recipe, we’ll learn how to <a id="_idIndexMarker884"/>connect to PostgreSQL using Reactive Repositories and some of the differences between Reactive <a id="_idIndexMarker885"/>and non-reactive Repositories. We’ll also learn how to configure Flyway for <span class="No-Break">database migrations.</span></p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor385"/>Getting ready</h2>
			<p>For this recipe, we’ll need a PostgreSQL database. You can use the instructions from the <em class="italic">Getting ready</em> section of the <em class="italic">Connecting your application to PostgreSQL</em> recipe, in <a href="B21646_05.xhtml#_idTextAnchor203"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. Once you have Docker installed, as explained in the aforementioned recipe, you can execute the following command to run a PostgreSQL server <span class="No-Break">on Docker:</span></p>
			<pre class="console">
docker run -itd -e POSTGRES_USER=packt -e POSTGRES_PASSWORD=packt -p 5432:5432 --name postgresql postgres</pre>			<p>I also prepared a starting project for this recipe that contains the classes that we’ll use as data entities to map with the database tables and the database initialization scripts that we’ll use in the <em class="italic">There’s more</em> section for the Flyway migration. You can find the project in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter8/recipe8-4/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor386"/>How to do it...</h2>
			<p>We’ll configure an application to connect to use PostgreSQL. Let’s <span class="No-Break">go Reactive:</span></p>
			<ol>
				<li>First, we’ll ensure we have all the required dependencies. For that, open the project’s <strong class="source-inline">pom.xml</strong> file and add the <span class="No-Break">following dependencies:</span><ul><li><span class="No-Break"><strong class="source-inline">org.springframework.boot:spring-boot-starter-webflux</strong></span></li><li><span class="No-Break"><strong class="source-inline">org.springframework.boot:spring-boot-starter-test</strong></span></li><li><span class="No-Break"><strong class="source-inline">io.projectreactor:reactor-test</strong></span></li><li><span class="No-Break"><strong class="source-inline">org.springframework.boot:spring-boot-starter-data-r2dbc</strong></span></li><li><span class="No-Break"><strong class="source-inline">org.postgresql:r2dbc-postgresql</strong></span></li></ul></li>
				<li>Next, we’ll configure the <a id="_idIndexMarker886"/>connection to the database using the R2DBC driver. For that, open the <strong class="source-inline">application.yml</strong> file and add the <span class="No-Break">following configuration:</span><pre class="source-code">
spring:
    application:
        name: football
    <strong class="bold">r2dbc</strong>:
        url: <strong class="bold">r2dbc</strong>:postgresql://localhost:5432/football
        username: packt
        password: packt</pre><p class="list-inset">Note that the database URL doesn’t start with <strong class="source-inline">jdbc:</strong> but <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">r2dbc:</strong></span><span class="No-Break">.</span></p></li>				<li>Then, we’ll configure <a id="_idIndexMarker887"/>the entity classes we want to map to the database. These classes are in the <strong class="source-inline">repo</strong> folder. To prepare the classes, follow these steps for each <span class="No-Break">of them:</span><ol><li class="upper-roman">Add the <strong class="source-inline">@Table</strong> annotation to the class. You can set the name as it’s defined on <span class="No-Break">the database.</span></li><li class="upper-roman">Add the <strong class="source-inline">@Id</strong> annotation to the identifier field. I named this field <strong class="source-inline">Id</strong> in all <span class="No-Break">entity classes.</span></li></ol><p class="list-inset">You can see the <strong class="source-inline">CardEntity</strong> class as an <span class="No-Break">example here:</span></p><pre class="source-code">
<strong class="bold">@Table</strong>(name = "cards")
public class CardEntity {
    <strong class="bold">@Id</strong>
    private Long id;
    private Optional&lt;Long&gt; albumId;
    private Long playerId;
    private Long ownerId;
}</pre></li>				<li>We can create the repositories for<a id="_idIndexMarker888"/> our entities. For instance, for the <strong class="source-inline">CardEntity</strong>, we’ll create <a id="_idIndexMarker889"/>the <strong class="source-inline">CardsRepository</strong> <span class="No-Break">as follows:</span><pre class="source-code">
public interface CardsRepository extends
                       <strong class="bold">ReactiveCrudRepository</strong>&lt;CardEntity, Long&gt; {
}</pre><p class="list-inset">You can do the same for the rest of <span class="No-Break">the entities.</span></p></li>				<li>We’ll add a method to <strong class="source-inline">PlayersRepository</strong> to find a player by their name. For that, just add the following method definition to the <span class="No-Break"><strong class="source-inline">PlayersRepository</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
public Mono&lt;PlayerEntity&gt; findByName(String name);</pre></li>				<li>Let’s create a new service to manage players. You can name it <strong class="source-inline">PlayersService</strong>, and as it uses <strong class="source-inline">PlayersRepository</strong>, we’ll add it as a parameter to the constructor, and we’ll let Spring Boot do its magic to <span class="No-Break">inject it:</span><pre class="source-code">
<strong class="bold">@Service</strong>
public class PlayersService {
    private final PlayersRepository playersRepository;
    public PlayersService(<strong class="bold">PlayersRepository playersRepository</strong>) {
        this.playersRepository = playersRepository;
    }
}</pre></li>				<li>Now, we’ll create a couple of <a id="_idIndexMarker890"/>methods using the repository. For instance, one method to get a player by the ID, and another one to get the player by <span class="No-Break">the name:</span><pre class="source-code">
public Mono&lt;Player&gt; getPlayer(Long id) {
    return playersRepository.findById(id)
            .map(PlayerMapper::map);
}
public Mono&lt;Player&gt; getPlayerByName(String name) {
    return playersRepository.findByName(name)
            .map(PlayerMapper::map);
}</pre><p class="list-inset">Note that both methods use a class named <strong class="source-inline">PlayerMapper</strong>. I provided this class as part of the starting <a id="_idIndexMarker891"/>project to create the mappings between the entities and the objects returned by <span class="No-Break">the application.</span></p></li>				<li>Let’s make something more complex now. We’ll retrieve a card and its related data, that is, <strong class="source-inline">Album</strong>, if it is already assigned, and <strong class="source-inline">Player</strong> in <span class="No-Break">the card.</span><ol><li class="upper-roman">Let’s create a new service class named <strong class="source-inline">CardsService</strong>. This service requires <strong class="source-inline">CardsRepository</strong>, <strong class="source-inline">PlayersRepository</strong>, and <strong class="source-inline">AlbumsRepository</strong>. We’ll create a constructor with an argument of <span class="No-Break">each type:</span></li></ol><pre class="source-code">
@Service
public class CardsService {
    private final CardsRepository cardsRepository;
    private final PlayersRepository playersRepository;
    private final AlbumsRepository albumsRepository;
    public CardsService(CardsRepository cardRepository,
                        PlayersRepository playersRepository,
                        AlbumsRepository albumsRepository) {
        this.cardsRepository = cardRepository;
        this.playersRepository = playersRepository;
        this.albumsRepository = albumsRepository;
    }
}</pre><ol><li class="upper-roman" value="2">Now, add a method to <a id="_idIndexMarker892"/>get an item of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">Card</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">public Mono&lt;Card&gt; getCard(Long cardId) {
    return cardsRepository.findById(cardId)
            <strong class="bold">.flatMap(this::retrieveRelations)</strong>
            .switchIfEmpty(Mono.empty());
}</pre><ol><li class="upper-roman" value="3">As you can see in<a id="_idIndexMarker893"/> the <strong class="source-inline">getCard</strong> method, there is a reference to <strong class="source-inline">retrieveRelations</strong>. The <strong class="source-inline">retrieveRelations</strong> method retrieves <strong class="source-inline">Player</strong> from the database and <strong class="source-inline">Album</strong> in case it’s defined. Of course, we’ll do all this using a <span class="No-Break">reactive approach:</span></li></ol><pre class="source-code">protected Mono&lt;Card&gt; retrieveRelations(CardEntity cardEntity) {
    Mono&lt;PlayerEntity&gt; playerEntityMono =
           playersRepository.findById(cardEntity.getPlayerId());
    Mono&lt;Optional&lt;AlbumEntity&gt;&gt; albumEntityMono;
    if(cardEntity.getAlbumId() != null
       &amp;&amp; cardEntity.getAlbumId().isPresent()){
        albumEntityMono = albumsRepository.findById(
                        cardEntity.getAlbumId().get())
                .map(Optional::of);
    } else {
        albumEntityMono = Mono.just(Optional.empty());
    }
    return Mono.zip(playerEntityMono, albumEntityMono)
            .map(tuple -&gt;
                    CardMapper.map(cardEntity,
                            tuple.getT2(), tuple.getT1()));
}</pre></li>				<li>You can implement the<a id="_idIndexMarker894"/> Reactive RESTful endpoints to expose this functionality, as explained in the <em class="italic">Creating a Reactive RESTful API</em> recipe in this chapter. I prepared some examples <a id="_idIndexMarker895"/>that you can find in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a> in the <strong class="source-inline">chapter8/recipe8-4/end</strong> folder. I recommend you check out the <em class="italic">There’s more</em> section, as it includes Flyway to initialize the database and some tests <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Testcontainers</strong></span><span class="No-Break">.</span></li>
			</ol>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor387"/>How it works...</h2>
			<p>Apparently, the Reactive entities and <strong class="source-inline">ReactiveCrudRepository</strong> are very similar to their non-reactive counterparts. <strong class="source-inline">ReactiveCrudRepository</strong> provides the same base methods with basic<a id="_idIndexMarker896"/> functionality such as <strong class="source-inline">findById</strong> and <strong class="source-inline">save</strong>, but there are <span class="No-Break">important differences:</span></p>
			<ul>
				<li>The Reactive repositories <a id="_idIndexMarker897"/>don’t manage relations between entities. For that reason, we haven’t defined any <strong class="source-inline">@OneToMany</strong> or <strong class="source-inline">@ManyToOne</strong> fields. The relations between entities should be managed explicitly in our application, as we did in the <strong class="source-inline">getCard</strong> and <span class="No-Break"><strong class="source-inline">retrieveRelations</strong></span><span class="No-Break"> methods.</span></li>
				<li>The reactive repositories allow you to define methods following the same naming convention as the non-reactive repositories but returning <strong class="source-inline">Mono</strong> for single results and <strong class="source-inline">Flux</strong> for multiple results. These methods are transformed into queries in the database. You can find more details about the naming convention on the R2DBC web page <span class="No-Break">at </span><a href="https://docs.spring.io/spring-data/relational/reference/r2dbc/query-methods.html"><span class="No-Break">https://docs.spring.io/spring-data/relational/reference/r2dbc/query-methods.html</span></a><span class="No-Break">.</span></li>
				<li>We haven’t used it in this recipe, but it’s possible to use the <strong class="source-inline">@Query</strong> annotation and provide an SQL query. It is a native query; JPQL is <span class="No-Break">not supported.</span></li>
			</ul>
			<p>The reactive programming model leverages the request’s asynchronous and non-blocking process. Note that in the <strong class="source-inline">getCard</strong> method, the album and the player are retrieved asynchronously and simultaneously when the card is found. Parallelism is achieved using the <strong class="source-inline">Mono.zip</strong> method, which allows several non-blocking processes to be <span class="No-Break">executed simultaneously.</span></p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor388"/>There’s more...</h2>
			<p>Flyway is not directly supported with R2DBC drivers, but it can be used with some adjustments. Let’s see how to <span class="No-Break">do it:</span></p>
			<ol>
				<li>First, you must add the Flyway dependency in your <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li>				<li>As we want to validate the<a id="_idIndexMarker898"/> database migration<a id="_idIndexMarker899"/> automatically, we’ll also include the <strong class="source-inline">Testcontainers</strong> support. For <strong class="source-inline">Testcontainers</strong>, there are no specific reactive adjustments <span class="No-Break">to make.</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></li>				<li>Now, we’ll need to configure the connection for Flyway explicitly. The reason for this is that Flyway only supports the JDBC driver; for that reason, we’ll need to specify the <strong class="source-inline">jdbc:</strong> version of the database URL. This configuration can be applied in the <strong class="source-inline">application.yml</strong> file. It should look <span class="No-Break">like this:</span><pre class="source-code">
spring:
    <strong class="bold">r2dbc:</strong>
        url: <strong class="bold">r2dbc:</strong>postgresql://localhost:5432/football
        username: packt
        password: packt
    <strong class="bold">flyway:</strong>
        url: <strong class="bold">jdbc:</strong>postgresql://localhost:5432/football
        user: packt
        password: packt</pre><p class="list-inset">We can set this <a id="_idIndexMarker900"/>configuration in a<a id="_idIndexMarker901"/> test supporting <strong class="source-inline">Testcontainers</strong>. Let’s see what the class to test the <strong class="source-inline">PlayersService</strong> may <span class="No-Break">look like:</span></p><pre class="source-code">@Testcontainers
@SpringBootTest
@ContextConfiguration(initializers = PlayersServiceTest.Initializer.class)
class PlayersServiceTest {
    @Autowired
    private PlayersService playersService;
    static PostgreSQLContainer&lt;?&gt; postgreSQLContainer = new PostgreSQLContainer&lt;&gt;("postgres:latest")
            .withDatabaseName("football")
            .withUsername("football")
            .withPassword("football");
    static class Initializer
            implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {
        public void initialize(ConfigurableApplicationContext configurableApplicationContext) {
            TestPropertyValues.of(
                    "<strong class="bold">spring.flyway.url=" + postgreSQLContainer.getJdbcUrl()</strong>,
                    "spring.flyway.user=" + postgreSQLContainer.getUsername(),
                    "spring.flyway.password=" + postgreSQLContainer.getPassword(),
                    <strong class="bold">"spring.r2dbc.url=" + postgreSQLContainer.getJdbcUrl().replace("jdbc:", "r2dbc:")</strong>,
                    "spring.r2dbc.username=" + postgreSQLContainer.getUsername(),
                    "spring.r2dbc.password=" + postgreSQLContainer.getPassword())
                    .applyTo(configurableApplicationContext.getEnvironment());
        }
    }
    @BeforeAll
    public static void startContainer() {
        postgreSQLContainer.start();
    }</pre></li>			</ol>
			<p>Note that the context <a id="_idIndexMarker902"/>configuration gets the database configuration from the PostgreSQL test container. As <strong class="source-inline">PostgreSQLContainer</strong> only returns <a id="_idIndexMarker903"/>the JDBC version of the URL, we replaced the <strong class="source-inline">jdbc:</strong> string with <strong class="source-inline">r2dbc:</strong> for the R2DBC driver, while keeping the JDBC URL version <span class="No-Break">for Flyway.</span></p>
			<p>The rest is just standard Flyway configuration. The sample project provides the database initialization scripts in the default folder <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">resources/db/migration</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor389"/>Event-driven applications with Spring Cloud Stream and RabbitMQ</h1>
			<p>We want to enhance the experience of our<a id="_idIndexMarker904"/> football application by using facts from a match, such as a goal or a red card. We can use the information to prepare a timeline with all events happening during the match or update the match score. We foresee that in the future, we can use this information for other features, such as preparing player statistics in real time or creating a player’s ranking using<a id="_idIndexMarker905"/> <span class="No-Break">the statistics.</span></p>
			<p>For this scenario, we can apply an <strong class="bold">event-driven architecture</strong> design. This type of design consists of detecting, processing, and <a id="_idIndexMarker906"/>reacting to real-time events as they happen. Usually, there are two types of components: the event producers <a id="_idIndexMarker907"/>and the event consumers, and they are loosely coupled. Spring Cloud Stream is the Spring project that supports event-driven applications that communicate using a shared messaging system, such as Kafka <span class="No-Break">or RabbitMQ.</span></p>
			<p>In this recipe, we’ll learn how to use Spring Cloud Stream to create one application that emits football match events and one that is subscribed to those events. We’ll also learn how to configure the applications to use RabbitMQ as the <span class="No-Break">messaging system.</span></p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor390"/>Getting ready</h2>
			<p>In this recipe, we’ll use RabbitMQ. You can install it on your computer by following the instructions of the official website at <a href="https://www.rabbitmq.com/docs/download">https://www.rabbitmq.com/docs/download</a>. I recommend running it on Docker locally. With the following command in your terminal, you can download and run RabbitMQ <span class="No-Break">on Docker:</span></p>
			<pre class="console">
docker run -p 5672:7672 -p 15672:15672 \
-e RABBITMQ_DEFAULT_USER=packt \
-e RABBITMQ_DEFAULT_PASS=packt \
rabbitmq:3-management</pre>			<p>The image used includes the management portal. You can access it at <strong class="source-inline">http://localhost:15672</strong> using <strong class="source-inline">packt</strong> as <a id="_idIndexMarker908"/>username <span class="No-Break">and password.</span></p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor391"/>How to do it...</h2>
			<p>We’ll create two applications and <a id="_idIndexMarker909"/>we’ll connect them using RabbitMQ. We’ll use the power of Spring Cloud Stream to make <span class="No-Break">it possible:</span></p>
			<ol>
				<li>We’ll start by creating two applications using the Spring Boot <span class="No-Break">Initializr tool:</span><ul><li><strong class="source-inline">matches</strong>: This application will produce the match events and will publish them <span class="No-Break">on RabbitMQ</span></li><li><strong class="source-inline">timeline</strong>: This application will process all events published to create a <span class="No-Break">match timeline</span></li></ul><p class="list-inset">For that, repeat this step for each application. Open <a href="https://start.spring.io">https://start.spring.io</a> in your browser and use the same options as in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, in <em class="italic">Creating a RESTful API</em>, save for the <span class="No-Break">following options:</span></p><ul><li>For <strong class="bold">Artifact</strong>, type the name of the application, which is <strong class="source-inline">matches</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">timeline</strong></span><span class="No-Break">.</span></li><li>For <strong class="bold">Dependencies</strong>, don’t select <span class="No-Break">any starter</span></li></ul><p class="list-inset">We’ll add the following dependency to the <span class="No-Break">three applications:</span></p><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li>				<li>The next step will be configuring the <strong class="source-inline">matches</strong> application to <span class="No-Break">emit events:</span><ol><li class="upper-roman">First, we’ll define a record <a id="_idIndexMarker910"/>that will be used to represent the <span class="No-Break">match events:</span></li></ol><pre class="source-code">
public record MatchEvent(Long id, Long matchId,
                         LocalDateTime eventTime, int type,
                         String description, Long player1,
                         Long player2) { }</pre><ol><li class="upper-roman" value="2">You can create a<a id="_idIndexMarker911"/> nested builder class to facilitate the manipulation. I’m not including the builder code in this sample for brevity, but you can find an implementation on the book’s <span class="No-Break">GitHub repository.</span></li><li class="upper-roman">Next, we’ll define a bean in the <strong class="source-inline">MatchesApplication</strong> class that <span class="No-Break">configures </span><span class="No-Break"><strong class="source-inline">Supplier&lt;Message&lt;MatchEvent&gt;&gt;</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">@Bean
public Supplier&lt;MatchEvent&gt; matchEvents() {
    Random random = new Random();
    return () -&gt; {
        return MatchEvent.builder()
                .withMatchId(1L)
                .withType(random.nextInt(0, 10))
                .withEventTime(LocalDateTime.now())
                .withDescription("random event")
                .withPlayer1(null)
                .withPlayer2(null)
                .build();
    };
}</pre><ol><li class="upper-roman" value="4">This bean generates the <strong class="source-inline">MatchEvent</strong> messages with a random value assigned to the <span class="No-Break"><strong class="source-inline">type</strong></span><span class="No-Break"> field.</span></li><li class="upper-roman">Finally, we’ll configure <a id="_idIndexMarker912"/>the application to use RabbitMQ. We’ll bind the bean we just created to a RabbitMQ exchange <a id="_idIndexMarker913"/>named <strong class="source-inline">match-events-topic</strong> and configure the binding to map the <em class="italic">routing key</em> message property to the <strong class="source-inline">eventType</strong> message header. For that, open the <strong class="source-inline">application.yml</strong> file and set the <span class="No-Break">following configuration:</span></li></ol><pre class="source-code">spring:
  rabbitmq:
    host: localhost
    username: packt
    password: packt
    port: 5672
  cloud:
    stream:
      bindings:
        <strong class="bold">matchEvents</strong>-out-0:
          destination: match-events-topic</pre><p class="list-inset">Check that the <strong class="source-inline">spring.rabbitmq</strong> properties are aligned with the parameters used to start the RabbitMQ container in the <em class="italic">Getting ready</em> section. Verify that the binding name matches the method that exposes <span class="No-Break">the bean.</span></p><p class="list-inset">Now, the <strong class="source-inline">matches</strong> application is <a id="_idIndexMarker914"/>ready to start producing events. You can start <span class="No-Break">it now.</span></p></li>				<li>Next, we’ll configure<a id="_idIndexMarker915"/> the <strong class="source-inline">timeline</strong> application. This application will consume all events produced by the <strong class="source-inline">matches</strong> application. For that, do <span class="No-Break">the following:</span><ol><li class="upper-roman">First, create a <strong class="source-inline">Consumer&lt;MatchEvent&gt;</strong> bean. Open the <strong class="source-inline">TimelineApplication</strong> class and add the <span class="No-Break">following code:</span></li></ol><pre class="source-code">
<strong class="bold">@Bean</strong>
public <strong class="bold">Consumer&lt;MatchEvent&gt;</strong> processMatchEvent() {
    return value -&gt; {
        System.out.println("Processing MatchEvent: "
                           + value.type());
    };
}</pre><ol><li class="upper-roman" value="2">For the sake of clarity, we haven’t created a library with shared code across the three applications. Therefore, you will need to define the <strong class="source-inline">MatchEvent</strong> record in this <span class="No-Break">project, too.</span></li><li class="upper-roman">For this project, we only need to configure the RabbitMQ configuration to bind an input queue named <strong class="source-inline">timeline</strong> to the <strong class="source-inline">match-events-topic</strong> exchange created in <em class="italic">Step 2</em> and the <strong class="source-inline">processMatchEvent</strong> function to the input queue. That can be done by configuring the <strong class="source-inline">application.yml</strong> file <span class="No-Break">as follows:</span></li></ol><pre class="source-code">spring:
  rabbitmq:
    host: localhost
    username: packt
    password: packt
    port: 5672
  cloud:
    stream:
      function:
        bindings:
          <strong class="bold">processMatchEvent</strong>-in-0: input
      bindings:
        input:
          destination: <strong class="bold">match-events-topic</strong>
          group: timeline</pre><p class="list-inset">The timeline application<a id="_idIndexMarker916"/> is now ready to process messages. Just run the application, and it will start processing messages. You will see the messages when the events are processed in <span class="No-Break">the console.</span></p></li>			</ol>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor392"/>How it works...</h2>
			<p>The <strong class="source-inline">spring-cloud-stream-binder-rabbit</strong> dependency includes the Spring Cloud Stream starter, with specific<a id="_idIndexMarker917"/> bindings for RabbitMQ. The Spring Cloud Stream starter provides the necessary abstractions to create event-driven applications with no specific references to the underlying messaging technology. In our application, we haven’t used any explicit RabbitMQ component in the code. For that reason, we could switch to another messaging system, such as Kafka, just by changing the dependencies and the configuration, but with no <span class="No-Break">code changes.</span></p>
			<p>Spring Cloud Stream allows binding a <strong class="source-inline">Supplier</strong> function registered as a bean to a given destination, in our case, <strong class="source-inline">match-events-topic</strong>. That means that the messages produced by the <strong class="source-inline">Supplier</strong> function are sent to that destination. We use <strong class="source-inline">spring-cloud-stream-binder-rabbit</strong>, which includes the bindings to RabbitMQ. When we start the <strong class="source-inline">matches</strong> application, RabbitMQ creates<a id="_idIndexMarker918"/> an <strong class="bold">exchange</strong>. An exchange is an intermediary component between the producer and the consumer applications. Producer applications never send messages directly to consumers. Then, depending on the type of exchange, the messages are<a id="_idIndexMarker919"/> sent to one or multiple queues or discarded. When we started the matches <a id="_idIndexMarker920"/>application and the timeline application was not running yet, the exchange was created in RabbitMQ, but as there were no subscribers, the messages were discarded. In the <strong class="bold">RabbitMQ</strong> portal, you would see something <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer101">
					<img alt="Figure 8.1: match-events-topic in RabbitMQ" src="image/B21646_08_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: match-events-topic in RabbitMQ</p>
			<p>As you can see, the application calls the <strong class="source-inline">Supplier</strong> function once every second, which is the default configuration in Spring Cloud Stream. Still, the messages are discarded as it’s not defined yet how to route the<a id="_idIndexMarker921"/> messages. Indeed, if you check the <strong class="bold">Queues and Streams</strong> tab, you will see <a id="_idIndexMarker922"/>that there are no <span class="No-Break">queues defined.</span></p>
			<p>In the <strong class="source-inline">timeline</strong> application, we configured the binding between the <strong class="source-inline">match-event-topic</strong> exchange and the destination queue where the messages are forwarded. It’s defined in the <strong class="source-inline">spring.cloud.stream.binding.input</strong> properties. We specified <strong class="source-inline">match-events-topic</strong> with the <strong class="source-inline">destination</strong> property, and we defined the target queue with the <strong class="source-inline">group</strong> property. Then, with the <strong class="source-inline">spring.cloud.stream.function.bindings</strong> properties, we defined the link between that queue and the function registered as a bean to process the messages. After starting the <strong class="source-inline">timeline</strong> application, you <a id="_idIndexMarker923"/>will see that <strong class="source-inline">match-events-topic</strong> has a binding that connects<a id="_idIndexMarker924"/> the <strong class="source-inline">match-events-topic</strong> exchange to a queue named <strong class="source-inline">match-events-topic.timeline</strong>. You can check that in RabbitMQ. It should look <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer102">
					<img alt="Figure 8.2: Timeline queue bound to match-events-topic" src="image/B21646_08_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: Timeline queue bound to match-events-topic</p>
			<p>As you can see in the RabbitMQ portal, Spring Cloud Stream created the exchange and the queue and configured the binding to route all messages to <span class="No-Break">the queue.</span></p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor393"/>There’s more...</h2>
			<p>In this recipe, we used the functional approach to send messages, letting the Spring Stream Cloud invoke the <strong class="source-inline">Supplier</strong> function to generate messages. In many scenarios, we must decide when to send messages more explicitly. For this purpose, you can use the <strong class="source-inline">StreamBridge</strong> component. This <a id="_idIndexMarker925"/>component lets you send messages while only specifying the binding <span class="No-Break">to use.</span></p>
			<p>Let’s see an example. You<a id="_idIndexMarker926"/> can create a service component that receives a <strong class="source-inline">StreamBridge</strong> in the constructor, then Spring Boot will inject an instance <span class="No-Break">in runtime:</span></p>
			<pre class="source-code">
@Service
public class MatchService {
    private <strong class="bold">StreamBridge</strong> streamBridge;
    private final String bindingName;
    public MatchService(StreamBridge streamBridge,
            @Value("${spring.cloud.stream.bindings.matchEvents-out-0.destination}") String bindingName) {
        this.streamBridge = streamBridge;
        this.bindingName = bindingName;
    }
}</pre>			<p>Then, you can use <strong class="source-inline">StreamBridge</strong> to send <span class="No-Break">the message:</span></p>
			<pre class="source-code">
public void createEvent(MatchEvent matchEvent) {
    streamBridge.send(bindingName, matchEvent);
}</pre>			<h2 id="_idParaDest-359"><a id="_idTextAnchor394"/>See also</h2>
			<p>RabbitMQ provides different types of exchanges, depending on how the messages <span class="No-Break">are routed:</span></p>
			<ul>
				<li><strong class="bold">Direct</strong>: The messages are forwarded to<a id="_idIndexMarker927"/> a queue based on a <span class="No-Break">routing key.</span></li>
				<li><strong class="bold">Fanout</strong>: The messages are forwarded to <a id="_idIndexMarker928"/>all bounded queues, regardless of the <span class="No-Break">routing key.</span></li>
				<li><strong class="bold">Topic</strong>: The messages are routed to the<a id="_idIndexMarker929"/> bounded queues depending on a pattern defined in the exchange and the routing keys defined in the queues. This is the default type. In the next recipe, we’ll explore this <span class="No-Break">scenario further.</span></li>
				<li><strong class="bold">Headers</strong>: This is similar to the topic <a id="_idIndexMarker930"/>exchange, but Rabbi<a id="_idTextAnchor395"/>tMQ routes messages using the message headers instead of the <span class="No-Break">routing key.</span></li>
			</ul>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor396"/>Routing messages with Spring Cloud Stream and RabbitMQ</h1>
			<p>We decided to utilize the match events generated in the previous recipe to update the football match score. We’ll create a new<a id="_idIndexMarker931"/> application that subscribes to the goal events to implement <span class="No-Break">this functionality.</span></p>
			<p>In this recipe, we’ll learn how to <a id="_idIndexMarker932"/>configure our Spring Cloud Stream producer application to set the routing key based on the message headers. Then, we’ll learn how to configure the consumer applications to set up the queue bindings based on pattern matches for the <span class="No-Break">routing key.</span></p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor397"/>Getting ready</h2>
			<p>This recipe starts with the outcome of the <em class="italic">Event-driven applications with Spring Cloud Stream and RabbitMQ</em> recipe. I prepared a working version in case you haven’t yet completed that recipe. You can find it in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter8/recipe8-6/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>As in the <em class="italic">Event-driven applications with Spring Cloud Stream and RabbitMQ</em> recipe, you will need a RabbitMQ server. To set up the RabbitMQ service on your computer, follow the<a id="_idIndexMarker933"/> instructions in the <em class="italic">Getting ready</em> section of <span class="No-Break">that recipe.</span></p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor398"/>How to do it...</h2>
			<p>Let’s make the few necessary adjustments to the producer application, and then we’ll use Spring Cloud Stream’s powerful <a id="_idIndexMarker934"/>capabilities to set up all RabbitMQ bindings <span class="No-Break">for us:</span></p>
			<ol>
				<li>First, we’ll modify the <strong class="source-inline">matches</strong> producer application to include some headers in the messages. For that, open the <strong class="source-inline">MatchesApplication</strong> class and modify the <strong class="source-inline">matchEvents</strong> method <span class="No-Break">as follows:</span><ul><li>Modify the method’s signature; instead of returning <strong class="source-inline">MatchEvent</strong>, we’ll <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">Message&lt;MatchEvent&gt;</strong></span><span class="No-Break">.</span></li><li>We’ll use <strong class="source-inline">MessageBuilder</strong> to create the <span class="No-Break">returning </span><span class="No-Break"><strong class="source-inline">Message&lt;MatchEvent&gt;</strong></span><span class="No-Break">.</span></li><li>We’ll include a new header named <strong class="source-inline">eventType</strong>. We’ll assume that events with the <strong class="source-inline">type</strong> field equal to <strong class="source-inline">2</strong> <span class="No-Break">are goals.</span></li></ul><p class="list-inset">The method should look <span class="No-Break">like this:</span></p><pre class="source-code">
@Bean
public Supplier&lt;<strong class="bold">Message&lt;MatchEvent&gt;</strong>&gt; matchEvents() {
    Random random = new Random();
    return () -&gt; {
        MatchEvent matchEvent = MatchEvent.builder()
                .withMatchId(1L)
                .withType(random.nextInt(0, 10))
                .withEventTime(LocalDateTime.now())
                .withDescription("random event")
                .withPlayer1(null)
                .withPlayer2(null)
                .build();
        <strong class="bold">MessageBuilder&lt;MatchEvent&gt; messageBuilder =</strong>
<strong class="bold">                       MessageBuilder.withPayload(matchEvent);</strong>
        if (matchEvent.type() == 2) {
             messageBuilder.<strong class="bold">setHeader</strong>("eventType",
                                      "football.goal");
        } else {
             messageBuilder.<strong class="bold">setHeader</strong>("eventType",
                                      "football.event");
        }
        return messageBuilder.build();
      };
}</pre></li>				<li>Next, we’ll change the <strong class="source-inline">matches</strong> application’s configuration to assign the <strong class="source-inline">eventType</strong> header’s value to the <a id="_idIndexMarker935"/>routing key. For that, we’ll configure the rabbit producer binding <a id="_idIndexMarker936"/>with the <strong class="source-inline">routing-key-expression</strong> property in the <strong class="source-inline">application.yml</strong> file. The Spring Cloud configuration should look <span class="No-Break">like this:</span><pre class="source-code">
spring:
  cloud:
    stream:
      <strong class="bold">rabbit</strong>:
        <strong class="bold">bindings</strong>:
          matchEvents-out-0:
            producer:
              <strong class="bold">routing-key-expression: headers.eventType</strong></pre><p class="list-inset">I omitted parts <a id="_idIndexMarker937"/>already defined in the previous recipe, such as the RabbitMQ host parameters, <span class="No-Break">for readability.</span></p></li>				<li>Then, we’ll create a new <a id="_idIndexMarker938"/>consumer application. For that, use the same parameters as in the <em class="italic">Event-driven applications with Spring Cloud Stream and RabbitMQ</em> recipe; just change the name and <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">score</strong></span><span class="No-Break">.</span></li>
				<li>Next, create a bean that returns <strong class="source-inline">Consumer&lt;MatchEvent&gt;</strong>. You can define it in the <strong class="source-inline">ScoreApplication</strong> class. This function will process the events received. It could look <span class="No-Break">like this:</span><pre class="source-code">
@Bean
public Consumer&lt;MatchEvent&gt; processGoals() {
    return value -&gt; {
        logger.info("Processing goal from player {} at {} ",
                     value.player1(), value.eventTime());
    };
}</pre></li>				<li>Now, configure the bindings to the <strong class="source-inline">match-event-topic</strong> exchange. In this application, we’ll set the binding<a id="_idIndexMarker939"/> route key using pattern matching. As we defined in <em class="italic">Steps 1</em> and <em class="italic">2</em>, the<a id="_idIndexMarker940"/> goals will have the <strong class="source-inline">football.goal</strong> value. So, the configuration will look <span class="No-Break">like this:</span><pre class="source-code">
spring:
  cloud:
    stream:
      rabbit:
        bindings:
          input:
            consumer:
              <strong class="bold">bindingRoutingKey: football.goal.#</strong>
      function:
        bindings:
          processGoals-in-0: input
      bindings:
        input:
          destination: match-events-topic
          group: score</pre></li>				<li>You can run the <strong class="source-inline">score</strong> application. You should check that it only receives the goal events. If you run the <strong class="source-inline">timeline</strong> application we created in the <em class="italic">Event-driven applications with Spring Cloud Stream and RabbitMQ</em> recipe, you will see that it receives all events, including <span class="No-Break">the goals.</span></li>
			</ol>
			<p class="callout-heading">Tip</p>
			<p class="callout">Keep in mind that the Spring Cloud Stream doesn’t automatically remove the bindings when you stop the application. For that reason, you may need to manually remove the bindings, exchanges, or queues of previous executions. You can do that from the <span class="No-Break">RabbitMQ portal.</span></p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor399"/>How it works...</h2>
			<p>The key concept in this recipe is the <strong class="bold">routing key</strong>, which is an<a id="_idIndexMarker941"/> attribute added by the producer to the message header. The exchange can then use the routing key to decide how to route the message. On <a id="_idIndexMarker942"/>the consumer side, it’s possible to define a binding to link a queue with an exchange <a id="_idIndexMarker943"/>based on the <span class="No-Break">routing keys.</span></p>
			<p>In this recipe, we used the <strong class="source-inline">routing-key-expression</strong> to set the routing key based on the message’s properties, such as <strong class="source-inline">header</strong> or <strong class="source-inline">payload</strong>. The Spring RabbitMQ binder allows the use of <strong class="bold">Spring Expression Language</strong> (<strong class="bold">SpEL</strong>) to define the message’s routing key. The binder <a id="_idIndexMarker944"/>evaluates the expression and sets the value of the <span class="No-Break">routing key.</span></p>
			<p>If you look at the messages generated in RabbitMQ, you will see the values of <strong class="bold">Routing Key</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">headers</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer103">
					<img alt="Figure 8.3: Message in RabbitMQ showing the routing key" src="image/B21646_08_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: Message in RabbitMQ showing the routing key</p>
			<p>On the consumer side, it’s possible to use<a id="_idIndexMarker945"/> pattern-matching values when binding the queue to the exchange. The <a id="_idIndexMarker946"/>messages whose routing key matches the given pattern will be forwarded to the corresponding queue. If you look at the bindings of <strong class="source-inline">match-events-topic</strong> in the RabbitMQ portal, you will see that two queues are bound, each using a different <span class="No-Break">routing key.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer104">
					<img alt="Figure 8.4: Queues bound with different routing keys" src="image/B21646_08_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4: Queues bound with different routing keys</p>
			<p>With this <a id="_idIndexMarker947"/>configuration, RabbitMQ will send to the <strong class="source-inline">match-events-topic.score</strong> queue only the messages that match the <strong class="source-inline">football.goal.#</strong> routing key. That is, all messages whose routing key starts with <strong class="source-inline">football.goal</strong>. It will<a id="_idIndexMarker948"/> send to the <strong class="source-inline">match-events-topic.timeline</strong> queue all messages, as the <strong class="source-inline">#</strong> symbol acts as <span class="No-Break">a wildcard.</span></p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor400"/>See also</h2>
			<p>You can find more information about SpEL on the project page at <a href="https://docs.spring.io/spring-framework/reference/core/expressions.html">https://docs.spring.io/spring-framework/reference/core/expressions.html</a>. It supports querying and manipulating an object graph at runtime, and all Spring projects widely <span class="No-Break">use it.</span></p>
			<h1 id="_idParaDest-365"><a id="_idTextAnchor401"/>Error handling with Spring Cloud Stream</h1>
			<p>The score application we developed in the previous recipe has become critical for football matches as it manages the final match score. For that reason, we need to ensure the <span class="No-Break">solution’s robustness.</span></p>
			<p>Spring Cloud Stream<a id="_idIndexMarker949"/> can implement highly available, loosely coupled, resilient systems. The reason is that the underlying messaging systems, such as RabbitMQ, provide different mechanisms to ensure the message is delivered to the intended destination. First, the messages can be queued before they are delivered. If, for any reason, the consumer application is not ready yet or has a transient failure, it will process the <a id="_idIndexMarker950"/>queued messages once it’s ready again. You can use the same mechanism to increase the number of consumers to increase the throughput of your system. You can also configure a retry policy in case of a transient failure<a id="_idIndexMarker951"/> in your application or forward it to a special queue, which is named a <strong class="bold">dead-letter queue</strong> (<strong class="bold">DLQ</strong>). The DLQ is a common mechanism in messaging systems; the DLQ can receive all messages that cannot be processed normally for whatever reason; the main purpose is to provide the capability to keep messages that cannot be processed, not only due to technical transient errors but those related to software issues <span class="No-Break">as well.</span></p>
			<p>In this recipe, we’ll learn how to configure a DLQ and retry policies for our application, and we’ll see how the application behaves in case <span class="No-Break">of errors.</span></p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor402"/>Getting ready</h2>
			<p>This recipe uses the <em class="italic">Routing messages with Spring Cloud Stream and RabbitMQ</em> recipe outcomes as the starting point. If you haven’t completed it yet, you can use the version I prepared, which can be found in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter8/recipe8-7/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>As in the <em class="italic">Event-driven applications with Spring Cloud Stream and RabbitMQ</em> recipe, you will need a RabbitMQ server. To set up the RabbitMQ service on your computer, follow the instructions in the <em class="italic">Getting ready</em> section of <span class="No-Break">that recipe.</span></p>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor403"/>How to do it...</h2>
			<p>Before we configure the application for error handling, we’ll simulate some transient errors in <span class="No-Break">our application:</span></p>
			<ol>
				<li>Let’s modify our score <a id="_idIndexMarker952"/>application to introduce random <a id="_idIndexMarker953"/>errors when message processing. We’ll simulate an error happening 80% of the time. For that, open the <strong class="source-inline">processGoals</strong> method of the <strong class="source-inline">ScoreApplication</strong> class and replace the code with <span class="No-Break">the following:</span><pre class="source-code">
@Bean
public Consumer&lt;MatchEvent&gt; processGoals() {
    Random random = new Random();
    return value -&gt; {
        <strong class="bold">if (random.nextInt(0, 10) &lt; 8) {</strong>
            logger.error("I'm sorry, I'm crashing...");
            <strong class="bold">throw new RuntimeException("Error processing goal");</strong>
<strong class="bold">        }</strong>
        logger.info("Processing a goal from player {} at {} ",
                     value.player1(), value.eventTime());
    };
}</pre></li>				<li>Now, we’ll configure the application to automatically create a DLQ. To do that, open the <strong class="source-inline">score</strong> application’s <strong class="source-inline">application.yml</strong> and set the <strong class="source-inline">autoBindDlq</strong> property in the <strong class="source-inline">spring.cloud.string.rabbit.bindings.input.consumer</strong> section to <strong class="source-inline">true</strong>. It should look <span class="No-Break">like this:</span><pre class="source-code">
spring:
  cloud:
    stream:
      rabbit:
        bindings:
          input:
            consumer:
              bindingRoutingKey: football.goal.#
              <strong class="bold">autoBindDlq: true</strong></pre><p class="list-inset">I omitted the rest of the settings for <a id="_idIndexMarker954"/>brevity, but you should keep them as they are; you only need to add <a id="_idIndexMarker955"/>the <span class="No-Break">highlighted property.</span></p><p class="list-inset">If you run the application now, you’ll see<a id="_idIndexMarker956"/> a new queue named <strong class="source-inline">match-events-topic.score.dlq</strong>. It’s bound to the <strong class="bold">dead-letter </strong><span class="No-Break"><strong class="bold">exchange</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DLX</strong></span><span class="No-Break">).</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer105">
					<img alt="Figure 8.5: DLQ" src="image/B21646_08_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5: DLQ</p>
			<ol>
				<li value="3">Now, we’ll configure the retry<a id="_idIndexMarker957"/> policy. For instance, we can <a id="_idIndexMarker958"/>configure three attempts before a message is routed to the DLQ and one second as the maximum time to process a <a id="_idIndexMarker959"/>message, which is its <strong class="bold">time to live</strong> (<strong class="bold">TTL</strong>). We’ll do that by setting the following <span class="No-Break">two properties:</span><ul><li><strong class="source-inline">spring.cloud.string.rabbit.bindings.input.consumer.maxAttempts</strong> = <span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">spring.cloud.string.rabbit.bindings.input.consumer.ttl</strong> = <strong class="source-inline">1000</strong>. This property is expressed <span class="No-Break">in milliseconds.</span></li></ul></li>
				<li>You can run the application now. If you<a id="_idIndexMarker960"/> keep it running for a while, you will see some errors in the score <a id="_idIndexMarker961"/>application, and some messages will reach <span class="No-Break">the DLQ.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer106">
					<img alt="Figure 8.6: DLQ messages" src="image/B21646_08_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6: DLQ messages</p>
			<ol>
				<li value="5">You can also stop and restart the <strong class="source-inline">score</strong> application. In the RabbitMQ portal, you can verify that the messages are queued in the <strong class="source-inline">match-events-topic.score</strong> queue and that once the application is ready again, it will process all <span class="No-Break">pending messages.</span></li>
			</ol>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor404"/>How it works...</h2>
			<p>When a queue is bound to an <a id="_idIndexMarker962"/>exchange, a new message is forwarded to the<a id="_idIndexMarker963"/> queue every time there’s a new message in the exchange. The message lasts in the queue until it’s processed or the TTL expires. The consumer application, in our case, the <strong class="source-inline">score</strong> application, tries to read and process; if, for any reason, it fails before completing the process, the message returns to the queue. This process can be executed with the number of attempts configured, in our case, three attempts. Finally, if the message cannot be processed or the TTL expires, then the message is forwarded to <span class="No-Break">the DLQ.</span></p>
			<p>In our example, we configured an 80% failure rate for demonstration purposes. If we reduce the failure rate, fewer messages will reach <span class="No-Break">the DLQ.</span></p>
			<p>The solution is more resilient because once the message is queued, we can ensure that it will be processed, regardless of the availability of the <strong class="source-inline">score</strong> application. The <strong class="source-inline">score</strong> application may be unavailable for a given time for many reasons, including a transient error and planned maintenance. For features like these, this kind of solution is so popular in microservices architectures and cloud solutions. The assumption is that the messaging service is highly available, for instance, by deploying a cluster with redundant servers or just by using the <strong class="bold">platform as a service</strong> (<strong class="bold">PaaS</strong>) provided by cloud providers. On the Spring Cloud Stream page at <a href="https://spring.io/projects/spring-cloud-stream">https://spring.io/projects/spring-cloud-stream</a>, you can find the<a id="_idIndexMarker964"/> compatible binders; some are maintained directly by the Spring Cloud Team, while partners <span class="No-Break">maintain others.</span></p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor405"/>See also</h2>
			<p>You can configure more than one consumer application. If one consumer instance cannot process one message, another instance can process it. With this approach, scaling out the application by adding more consumers is possible. This design is known as <strong class="bold">Competing Consumers</strong>. You can find a <a id="_idIndexMarker965"/>good description of this scenario in the Azure Architecture Center at <a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers">https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers</a>. The implementation suggests Azure products, but you can apply the same principles with other technologies, such <span class="No-Break">as RabbitMQ.</span></p>
			<p>Other design patterns rely on queue systems that are worth having in our toolbox. <span class="No-Break">For instance:</span></p>
			<ul>
				<li><strong class="bold">Asynchronous Request-Reply</strong>: In this pattern, you may need to respond quickly to client applications, such <a id="_idIndexMarker966"/>as web browsers. However, operations may take much longer to<a id="_idIndexMarker967"/> respond. To solve this situation, the application saves the request in a queue and processes it asynchronously. The application exposes an endpoint to get the request status; then, the clients can periodically check the <span class="No-Break">request status.</span></li>
				<li><strong class="bold">Queue-Based Load Leveling</strong>. Some applications may rely on a backend with limited capacity, but load spikes can occur. In those scenarios with unpredictable demand, the queue acts as a buffer, and the consumer application processes the requests at a pace that doesn’t overflow <span class="No-Break">the backend.</span></li>
			</ul>
		</div>
	

		<div class="Content" id="_idContainer108">
			<h1 id="_idParaDest-370" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor406"/>Part 4: Upgrading to Spring Boot 3 from Previous Versions</h1>
			<p>Most of the time invested in an application over its lifetime is related to maintenance. A successful application may last for years or decades. During this time, it may require upgrades for its evolution. You probably have an application that you want to evolve and take advantage of the Spring Boot 3 features. In this part, we’ll learn how to upgrade an existing application from Spring Boot 2 to Spring <span class="No-Break">Boot 3.</span></p>
			<p>This part has the <span class="No-Break">following chapter:</span></p>
			<ul>
				<li><a href="B21646_09.xhtml#_idTextAnchor407"><em class="italic">Chapter 9</em></a><em class="italic">, </em><em class="italic">Upgrading from Spring Boot 2.x to Spring Boot 3.0</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer109">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer110">
			</div>
		</div>
	</body></html>