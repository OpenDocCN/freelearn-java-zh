- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Missing Guide for jOOQ Adoption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) is the most popular approach when
    discussing enterprise architecture; however, there are more, such as data-driven.
    In today’s data-driven world, jOOQ has emerged as a powerful tool for developers
    to use to interact with databases, offering a seamless and efficient approach
    to working with SQL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let’s address the fundamental question: what is jOOQ? **jOOQ**, which
    stands for **Java Object Oriented Querying**, is a lightweight yet robust Java
    library that empowers developers to write type-safe SQL queries fluently and intuitively.
    It provides a **domain-specific language** (**DSL**) that encapsulates the complexities
    of SQL, allowing developers to focus on writing concise and readable code.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might wonder why jOOQ has gained significant traction among developers.
    The answer lies in its ability to bridge the gap between the relational world
    of databases and the object-oriented paradigm of modern application development.
    jOOQ enables developers to leverage the full power of SQL within their Java code,
    providing flexibility, performance, and maintainability that is often difficult
    to achieve with traditional **object-relational mapping** (**ORM**) frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: As we dive deeper into the world of jOOQ, we will explore the concept of data-driven
    design and its implications. Unlike traditional OOP, which primarily revolves
    around manipulating objects and their behaviors, data-driven design emphasizes
    the underlying data structures and their relationships. We will examine how jOOQ
    embraces this approach, empowering developers to efficiently handle complex database
    interactions while maintaining the benefits of strong typing and compile-time
    safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the jOOQ framework and how to use it in an
    enterprise architecture with both Jakarta EE and MicroProfile:'
  prefs: []
  type: TYPE_NORMAL
- en: Data-driven and object-oriented programming in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is jOOQ?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using jOOQ with Jakarta/MicroProfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s embark on this journey to discover the power of jOOQ and understand
    how it revolutionizes how we interact with databases, bridging the gap between
    the world of SQL and OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are required for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any preferred IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at: [https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-07](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-07)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data-driven and object-oriented programming in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java, **data-driven** programming refers to an approach where the underlying
    data and its structure primarily drive the design and functionality of a program.
    It focuses on manipulating and processing data in a way that allows for flexibility,
    extensibility, and easy modification without heavily relying on the behavior of
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, OOP is a programming paradigm that revolves around objects, which
    are instances of classes. OOP emphasizes encapsulating data and related behavior
    within objects, promoting concepts such as inheritance, polymorphism, and abstraction.
    It focuses on modeling real-world entities as objects and defining their behaviors
    through methods and relationships.
  prefs: []
  type: TYPE_NORMAL
- en: The critical difference between data-driven programming and OOP lies in their
    approach to program design. In OOP, the emphasis is on modeling entities and their
    behavior, organizing code around objects and their interactions. This approach
    works well when the behavior of objects is complex or when there is a need to
    represent the real-world entities in the system.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, data-driven programming prioritizes manipulating and processing
    data structures. It is beneficial when dealing with large amounts of data, such
    as databases or data-centric applications. Data-driven programming allows for
    efficient querying, filtering, and transformation of data, often leveraging declarative
    approaches such as SQL or other query languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, a data-driven approach may be more suitable than an object-oriented
    one. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data processing and analysis**: A data-driven approach with specialized libraries
    or frameworks can offer better performance and flexibility when dealing with extensive
    datasets or performing complex analytical tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database-driven applications**: When developing applications that interact
    heavily with databases or rely on data from external sources, a data-driven approach
    such as jOOQ can simplify database interactions and optimize query execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration-driven systems**: In systems where the behavior is primarily
    determined by configuration files or external data, a data-driven approach allows
    easy modifications and customization without requiring code changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule-based systems**: In applications that involve complex rule evaluation
    or decision-making based on data, a data-driven approach can provide a transparent
    and manageable way to express and process rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that OOP and data-driven programming are not mutually
    exclusive, and they can often be combined to achieve the desired functionality
    and maintainability in a Java application. The choice between the two approaches
    depends on the specific requirements of the system and the nature of the problem
    being solved.
  prefs: []
  type: TYPE_NORMAL
- en: 'While data-driven programming offers several advantages, it also comes with
    inevitable trade-offs. Here are some of the trade-offs associated with data-driven
    programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased complexity**: Data-driven programming can introduce additional
    complexity, especially when dealing with large and complex data structures. Managing
    and manipulating data at a granular level may require intricate code and logic,
    making the system harder to understand and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced encapsulation**: In data-driven programming, the focus is primarily
    on the data and its manipulation rather than encapsulating behavior within objects.
    This can lead to reduced encapsulation and increased data exposure, potentially
    compromising the security and integrity of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited expressiveness**: While data-driven programming provides powerful
    data manipulation and querying mechanisms, it may have limitations when expressing
    complex business logic or relationships between data. OOP, emphasizing behavior
    and encapsulation, can often provide more expressive and intuitive solutions for
    such scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite these trade-offs, data-driven programming can be highly beneficial when
    efficient data manipulation, querying, and flexibility are crucial. By understanding
    these trade-offs, developers can make informed decisions when choosing between
    object-oriented and data-driven approaches, considering their applications’ specific
    requirements and constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented is the most popular paradigm when discussing enterprise applications;
    however, we can explore more paradigms, such as a data-driven design.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gives a brief overview of this topic, but if you want to go deep,
    there are two recommended materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the book *Data-Oriented Programming* by Yehonathan Sharvit,
    which talks about this pattern, for which we can summarize three principles:'
  prefs: []
  type: TYPE_NORMAL
- en: The code is data-separated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data has flexible access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is an article called *Data-Oriented Programming* by Brian Goetz,
    where Brian explains more about new features of Java, mainly records, and how
    to take advantage of Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this overview of data-oriented programming, let’s go deep with one of
    the most popular frameworks that can help you to design and create data-oriented
    applications: jOOQ.'
  prefs: []
  type: TYPE_NORMAL
- en: What is jOOQ?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jOOQ is a powerful Java library that bridges the gap between OOP and data-oriented
    programming in the context of enterprise applications. While OOP has long been
    the dominant paradigm in developing enterprise applications, there are cases where
    a data-oriented approach can offer unique advantages. jOOQ provides an elegant
    solution for developers to use to harness the power of SQL and leverage data-driven
    design principles within their Java code.
  prefs: []
  type: TYPE_NORMAL
- en: OOP has been widely adopted for its ability to model complex systems by encapsulating
    data and behavior within objects. It emphasizes code organization, reusability,
    and modularity. However, as enterprise applications deal with vast amounts of
    data and complex database interactions, a purely object-oriented approach can
    sometimes be limiting.
  prefs: []
  type: TYPE_NORMAL
- en: This is where jOOQ comes into play. jOOQ enables developers to seamlessly integrate
    SQL and relational database operations into their Java code. It provides a fluent,
    type-safe, and intuitive DSL for constructing SQL queries and interacting with
    databases. By embracing a data-oriented approach, jOOQ empowers developers to
    work directly with data structures and leverage the full power of SQL for querying,
    aggregating, and transforming data.
  prefs: []
  type: TYPE_NORMAL
- en: With jOOQ, developers can break free from the constraints of traditional ORM
    frameworks and gain fine-grained control over their database interactions. By
    embracing a data-oriented mindset, they can optimize performance, handle complex
    data manipulations, and take advantage of the features and optimizations offered
    by the underlying database system.
  prefs: []
  type: TYPE_NORMAL
- en: By using jOOQ, developers can tap into the benefits of OOP and data-oriented
    programming paradigms. They can continue to utilize the proven principles of object-oriented
    design for encapsulating behavior within objects while also benefiting from the
    efficiency and flexibility of data-oriented programming for handling large datasets
    and complex database operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will explore the features and capabilities of
    jOOQ in greater detail. We will delve into the DSL provided by jOOQ for constructing
    SQL queries, discuss its integration with Java code, and showcase its benefits
    for data-driven design. Together, we will discover how jOOQ can revolutionize
    how we interact with databases and enable a seamless fusion of OOP and data-oriented
    programming in enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'While jOOQ offers many benefits and advantages, it also has inevitable trade-offs.
    Here are some of the trade-offs associated with using jOOQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learning curve**: jOOQ introduces a new DSL for constructing SQL queries,
    which requires developers to familiarize themselves with its syntax and concepts.
    There is a learning curve involved in understanding the intricacies of jOOQ and
    utilizing it effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased code complexity**: Using jOOQ can introduce additional code complexity
    compared to traditional ORM frameworks or direct SQL queries. The DSL syntax and
    the need to map between Java objects and database records may result in more code
    and potential complexity, especially for complex database interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited database portability**: jOOQ generates SQL queries based on the underlying
    database dialect and its specific features. While jOOQ aims to provide a unified
    API across different databases, some differences in supported features and behavior
    may still exist. It can limit the portability of code between other database systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance considerations**: While jOOQ offers efficient query construction
    and execution, the performance may still be influenced by factors such as database
    schema design, indexing, and query optimization. It is crucial to consider the
    performance implications of jOOQ-generated queries and optimize the database schema
    accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance and upgrades**: As with any third-party library, using jOOQ introduces
    a dependency that needs to be managed and maintained. Keeping up with new releases,
    compatibility with different Java versions, and resolving potential issues or
    bugs may require additional effort during maintenance and upgrades.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited abstraction of an underlying database**: Unlike ORM frameworks that
    provide a higher level of abstraction, jOOQ requires developers to understand
    SQL and the underlying database schema well. It may be a disadvantage if you prefer
    a more abstract approach with hidden database-specific details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential impedance mismatch**: There may be cases where the object-oriented
    nature of the application clashes with the data-oriented approach of jOOQ. Balancing
    the two paradigms and maintaining consistency between the object model and the
    database schema can be challenging and may require careful design considerations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While jOOQ provides powerful capabilities for data-driven programming in Java,
    there may be better choices in some situations. It’s essential to weigh these
    trade-offs against your project’s specific requirements and constraints. Consider
    project complexity, team experience, performance needs, and database requirements
    when deciding whether jOOQ is the right tool for your application.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about a new tool, we compare it with the one we know; thus, let’s
    discuss more the difference between jOOQ and the **Java Persistence API** (**JPA**)
    and when we should choose one over the other.
  prefs: []
  type: TYPE_NORMAL
- en: JPA versus jOOQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both jOOQ and JPA are popular choices for database access in Java applications,
    but they have different approaches and use cases. Here is a comparison between
    the two and when you might choose one over the other:'
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL-centric approach**: jOOQ provides a fluent DSL that allows developers
    to construct SQL queries in a type-safe and intuitive manner. It gives fine-grained
    control over the SQL statements and allows leveraging the full power of SQL. jOOQ
    is well suited to scenarios where complex querying, database-specific features,
    and performance optimizations are essential.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-driven design**: jOOQ embraces a data-oriented programming paradigm,
    making it suitable for working with large datasets and intricate database operations.
    It provides efficient data manipulation capabilities and allows developers to
    work closely with the underlying data structures. jOOQ is a good fit for applications
    with central data processing and analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database-specific features**: jOOQ supports various database-specific features
    and functions, allowing developers to take advantage of the specific capabilities
    offered by different database systems. It makes it a suitable choice when working
    closely with a particular database and using its unique features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA
  prefs: []
  type: TYPE_NORMAL
- en: '**ORM**: JPA focuses on mapping Java objects to relational database tables,
    providing a higher level of abstraction. It allows developers to work with persistent
    entities and automatically maps objects to database records. JPA is a good fit
    for applications that heavily rely on object-oriented design and require a seamless
    integration between objects and the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-database portability**: JPA aims to provide a portable API that can
    work with different databases. It abstracts away database-specific details, allowing
    applications to switch between database systems with minimal code changes. JPA
    is a suitable choice when you need flexibility regarding the database backend
    and want to avoid vendor lock-in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rapid application development**: JPA offers features such as automatic CRUD
    operations, caching, and transaction management, simplifying and accelerating
    application development. It provides a higher level of abstraction, reducing the
    need for writing low-level SQL queries. JPA is beneficial when you prioritize
    rapid prototyping, productivity, and a focus on business logic over database-specific
    optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between jOOQ and JPA depends on your specific project requirements.
    If your application is data-intensive, requires complex querying, and needs fine-grained
    control over SQL, jOOQ might be a better choice. On the other hand, JPA may be
    the more suitable option if you prioritize object-oriented design, portability
    across different databases, and rapid application development. It’s also worth
    considering hybrid approaches where you can use both jOOQ and JPA together in
    different parts of your application, leveraging the strengths of each library
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Given an introduction about jOOQ, let’s put this into practice, this time combined
    with Jakarta EE. This book shows Jakarta EE in several persistence frameworks;
    in this chapter, we’ll show you Jakarta EE with jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: Using jOOQ with Jakarta/MicroProfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will explore the integration of jOOQ with Jakarta EE and
    MicroProfile, two powerful frameworks in the Java ecosystem. jOOQ, with its data-driven
    approach and SQL-centric capabilities, can seamlessly complement the enterprise-grade
    features provided by Jakarta EE and the microservices-oriented practice of MicroProfile.
    By combining these technologies, developers can unlock a powerful toolkit for
    building robust, scalable, and data-driven Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta EE, formerly Java EE, is a set of specifications and APIs that provides
    a standardized platform for building enterprise applications in Java. It offers
    a wide range of features, including servlets, **JavaServer Faces** (**JSF**),
    **Enterprise JavaBeans** (**EJB**), and JPA. Developers can leverage a mature
    ecosystem and industry standards with Jakarta EE to create scalable and maintainable
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, MicroProfile is a community-driven initiative that focuses
    on building microservices-based applications in Java. It provides a lightweight
    and modular set of specifications and APIs tailored for microservice architectures.
    MicroProfile enables developers to leverage technologies such as JAX-RS, JSON-P,
    and CDI in microservices, allowing for greater flexibility and agility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining jOOQ with Jakarta EE and MicroProfile can bring the best of both
    worlds to your Java applications. Here are some benefits and use cases of this
    combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced database interactions**: jOOQ’s SQL-centric approach allows you
    to write complex and optimized SQL queries directly in your Java code. It enables
    efficient and fine-grained control over database interactions, allowing for optimized
    data retrieval, updates, and analysis. Integrating jOOQ with Jakarta EE and MicroProfile
    will enable you to seamlessly leverage jOOQ’s powerful query-building capabilities
    within your enterprise or microservices applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-driven microservices**: Architectures often require efficient data access
    and manipulation across multiple services. Combining jOOQ with MicroProfile allows
    you to design microservices that leverage jOOQ’s data-driven approach for seamless
    database integration. It enables each microservice to independently handle its
    data operations, benefiting from the performance and flexibility offered by jOOQ’s
    DSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with JPA and ORM**: Jakarta EE applications often utilize JPA
    and ORM frameworks for database interactions. By integrating jOOQ with Jakarta
    EE and its persistence capabilities, you can leverage the benefits of both jOOQ’s
    SQL-centric approach and JPA’s object-oriented design. It allows you to efficiently
    handle complex queries and leverage JPA’s entity management, transactions, and
    caching features, resulting in a powerful and flexible data access layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-cutting concerns and scalability**: Jakarta EE and MicroProfile provide
    a wealth of features for cross-cutting concerns such as security, logging, and
    monitoring. By integrating jOOQ with these frameworks, you can leverage their
    capabilities to ensure consistent security policies, efficient logging, and monitoring
    of database interactions across your application or microservices architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this section, we will explore practical examples and demonstrate
    how to combine jOOQ with Jakarta EE and MicroProfile effectively. We will showcase
    the integration of jOOQ with Jakarta EE’s Persistence API, illustrate the use
    of jOOQ in microservices architectures with MicroProfile, and discuss best practices
    for leveraging the combined power of these technologies.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, you will have a solid understanding of how to work
    with jOOQ, Jakarta EE, and MicroProfile together, enabling you to build robust
    and data-driven Java applications in enterprise and microservices contexts. Let’s
    dive in and explore the possibilities of this powerful combination.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the combination potential, we’ll create a simple project using
    Java SE with Maven, but as a highlight, we can convert this code smoothly into
    microservices. This project is a CRUD with a single table, `Book`, where we’ll
    execute operations within, as in an executable class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll still use a simple database project, the H2, to reduce our project’s
    requirements. But you can replace it on production with PostgreSQL, MariaDB, and
    so on. Indeed, that is the beauty of relational databases; we can change easier
    between databases without much impact if we compare them with NoSQL databases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the configurations on the Maven project, where we’ll include
    the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the Maven dependencies, the next step is to include the plugins to generate
    the database structure and then create the jOOQ based on this table. We’ll start
    the data structure and, using the plugin, we’ll execute the following query; as
    you’ll see, we’ll make the schema and include some books in it. We’ll not show
    the plugin source code; see the repository source for more details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Maven infrastructure is ready, and the next step is to define the configuration
    to get the connection to the database and make it available to the CDI context.
    We’ll combine Jakarta CDI with Eclipse MicroProfile Config and extract the properties
    such as the JDBC URL and credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll put this credentials information, such as the username and password,
    in `microprofile-config.properties`; however, remember that you should not do
    so with production credentials. One thing I do is overwrite those configurations
    by the environment. Thus, the developer will understand this at production without
    knowing about it; a developer knows about those properties without comprehending
    the production properties. This is one of the advantages of taking the implementation
    to the edge of the Twelve-Factor App ([https://12factor.net](https://12factor.net)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'CDI can create and destroy bean instances in your container context. We’ll
    use this to develop and close connections, avoiding any connection leaks in our
    application. Once we have the connection, let’s create the `DSLContext` instance
    – this is the bridge between our data and Java, providing an easy and safe way
    through `fluent-API`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We could make both `Connection` and `DSLContext` available and handled by CDI;
    the next step is using both to work with the relational database. You could inject
    `DSLContext` as a field, but since we have created it using Java SE, we’ll create
    a `SeContainer` and select it, as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Are you ready for action? Let’s do a CRUD operation without creating an entity
    thanks to jOOQ, which, based on the database schema, will generate the data structure
    we can work with. The first step in the operation is the insertion. The code shows
    the record creation where we can set attributes and store them based on the setter
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the data, we can read that information from the database; using fluent-API
    and the `select` method with the `DSLContext` class, we can do several select
    query operations. The query will select the books ordered by title. The advantage
    of this approach is that we’ll see whether the query is compatible at the application
    level most of the time because it won’t compile if you do any irregular operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last two steps are `update` and `delete`; you can execute the other operations,
    exploring the fluent-API capability. We can define as many parameters and conditions
    as we wish. The sample we’re using will set the `where` condition at the `ID`
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could explore the whole CRUD operation based on the data without creating
    entities thanks to the jOOQ API. The data approach allows for generating the structure
    from the schema. We can guarantee that my application will work with the last
    entity without needing any work. That ends our jOOQ journey for today.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delved into data-driven programming and its trade-offs compared
    to the object-oriented approach. We explored the benefits and challenges of embracing
    a data-driven mindset, understanding that there are scenarios where a data-oriented
    approach can provide unique advantages over the traditional object-oriented paradigm.
    We then witnessed how jOOQ, a powerful Java library, bridges the gap between OOP
    and data-driven programming, allowing developers to leverage the full power of
    SQL and data manipulation within their Java code.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined the integration of jOOQ with Jakarta EE and MicroProfile, two
    frameworks widely used in developing enterprise and microservices applications.
    By combining these technologies, developers can take advantage of both the data-driven
    capabilities of jOOQ and the enterprise-grade features provided by Jakarta EE
    and the microservices-oriented approach of MicroProfile. This integration enables
    efficient database interactions, fine-grained control over SQL queries, and the
    ability to leverage object-oriented and data-oriented design principles in a unified
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: By combining the data-driven approach enabled by jOOQ with the enterprise-grade
    features of Jakarta EE and MicroProfile, and exploring the groundbreaking capabilities
    of MicroStream, we can take our applications to new heights of performance, scalability,
    and efficiency. We are on the brink of a new era in database-driven application
    development, where the power of data meets the speed of execution.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s embark on the next chapter of our journey, where we dive into the
    world of MicroStream and unleash the true potential of our persistence layer,
    Jakarta EE, and MicroProfile-powered applications. Exciting times lie ahead as
    we embrace this cutting-edge technology and witness the transformation it brings
    to our development process and the performance of our applications.
  prefs: []
  type: TYPE_NORMAL
