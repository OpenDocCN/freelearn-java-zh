<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Securing WildFly"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Securing WildFly</h1></div></div></div><p>Security<a id="id1135" class="indexterm"/> is a key element of any enterprise application. You must be able to control and restrict who is permitted to access your applications and what operations users may perform.</p><p>The <span class="strong"><strong>Java Enterprise Edition</strong></span> (<span class="strong"><strong>Java EE</strong></span>) <a id="id1136" class="indexterm"/>specification defines a simple, role-based security model for <span class="strong"><strong>Enterprise Java Beans</strong></span> (<span class="strong"><strong>EJBs</strong></span>) and <a id="id1137" class="indexterm"/>web components. The implementation of JBoss security is delivered by the PicketBox framework (formerly known as the JBoss security), which provides authentication, authorization, auditing, and mapping capabilities to Java applications.</p><p>As the number of<a id="id1138" class="indexterm"/> topics concerned with security requires a book in its own right, this chapter will focus on the topics that are of interest to the majority of administrators and developers. We will cover the following topics in detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A short introduction to the Java security API</li><li class="listitem" style="list-style-type: disc">The basics of the WildFly security subsystem</li><li class="listitem" style="list-style-type: disc">Defining login modules and their integration with various enterprise components (for example, web application EJB)</li><li class="listitem" style="list-style-type: disc">Securing the management interfaces</li><li class="listitem" style="list-style-type: disc">Using <span class="strong"><strong>Secure Sockets Layer</strong></span> (<span class="strong"><strong>SSL</strong></span>)<a id="id1139" class="indexterm"/> to encrypt network calls to web applications</li></ul></div><div class="section" title="Approaching Java security API"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec59"/>Approaching Java security API</h1></div></div></div><p>Java EE security <a id="id1140" class="indexterm"/>services<a id="id1141" class="indexterm"/> provide a robust and easily<a id="id1142" class="indexterm"/> configurable security mechanism to authenticate users and authorize access to application functions and associated data. To better understand the topics related to security, we will first provide some basic definitions:</p><p>
<span class="strong"><strong>Authentication</strong></span><a id="id1143" class="indexterm"/> is the process of ensuring that a person is who he claims to be. Authentication is usually performed by checking that a user's login credentials match those stored in a datastore. Login credentials typically consist of a username and password but can also be in the form of an X.509 certificate or <a id="id1144" class="indexterm"/>
<span class="strong"><strong>one-time password</strong></span> (<span class="strong"><strong>OTP</strong></span>). The following figure demonstrates the flow of a login process. The end user provides a username and password, which is submitted to the application server. The login module checks the user's details against those stored in a datastore. If the credentials match, the user is logged in; if the credentials do not match, then the login process will fail. Have a look at the following diagram:</p><div class="mediaobject"><img src="graphics/6232OS_10_01.jpg" alt="Approaching Java security API"/></div><p>
<span class="strong"><strong>Authorization</strong></span><a id="id1145" class="indexterm"/> is the process by which you verify that a user has the permission to access a particular system resource. Authorization should occur after authentication has taken place. Have a look at the following diagram:</p><div class="mediaobject"><img src="graphics/6232OS_10_02.jpg" alt="Approaching Java security API"/></div><p>In Java EE, the component containers are responsible for providing application security. A container basically provides two types of security: <span class="strong"><strong>declarative</strong></span> and <span class="strong"><strong>programmatic</strong></span>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Declarative security</strong></span> defines<a id="id1146" class="indexterm"/> an application<a id="id1147" class="indexterm"/> component's security requirements by means of deployment descriptors and/or annotations. A deployment descriptor is an external file that can be modified without the need to recompile the source code.<p>For example, Enterprise JavaBeans components can use an EJB deployment descriptor that must be named <code class="literal">ejb-jar.xml</code> and placed in the <code class="literal">META-INF</code> folder of the EJB JAR file.</p><p>Web components use a web application deployment descriptor named <code class="literal">web.xml</code> located in the <code class="literal">WEB-INF</code> directory.</p><p>Annotations are specified within a class file, which means any changes will require the code to be recompiled.</p><p>Using annotations provides many benefits over deployment descriptors. First, it is clearer in the source code as to what is happening rather than having this information scattered over various XML files. Second, it is easier to maintain as there are fewer configuration files.</p><p>The use of annotations also means less boilerplate code for the developer.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Programmatic security</strong></span> comes<a id="id1148" class="indexterm"/> into<a id="id1149" class="indexterm"/> the picture when security checks are embedded within an application code. It can be used when declarative security alone is not sufficient to express the security model of an application. For example, the Java EE security API allows the developer to test whether or not the current user has a specific role, using the following methods:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isUserInRole()</code>: Use this method within servlets and JSPs (adopted in <code class="literal">javax.servlet.http.HttpServletRequest</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">isCallerInRole()</code>: Use this method in EJBs (adopted in <code class="literal">javax.ejb.SessionContext</code>)</li></ul></div><p>In addition, there are other API calls that provide access to the user's identity, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getUserPrincipal()</code>: Use this method within servlets and JSPs (adopted in <code class="literal">javax.servlet.http.HttpServletRequest</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">getCallerPrincipal()</code>: Use this method in EJBs (adopted in <code class="literal">javax.ejb.SessionContext</code>)</li></ul></div><p>Using these APIs, you can develop a complex authorization model programmatically.</p></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note72"/>Note</h3><p>While annotations themselves are programmatic, they enable a declarative style of security. For this reason, annotations are considered to encompass both the declarative and programmatic security concepts.</p></div></div><p>The Java EE security <a id="id1150" class="indexterm"/>model is declarative, due to which embedding the security code into your business component is not an option. The term declarative here means that you describe the security roles and permissions in a standard XML descriptor. Declarative security allows the logic from this cross-cutting concern to be extracted away from core business logic. This results in a clearer and more readable code.</p><p>The default implementation of the declarative security model is based on <span class="strong"><strong>Java Authentication and Authorization Service</strong></span> (<span class="strong"><strong>JAAS</strong></span>) login <a id="id1151" class="indexterm"/>modules and subjects. WildFly security has a security proxy layer that allows the developer to create custom security services if the default implementation does not suffice. This allows custom security to be built independently of the bean object using it, without polluting the business code.</p><p>WildFly uses the PicketBox framework, which builds on JAAS. PicketBox is used to secure all the Java EE technologies running in the application server.</p><div class="section" title="The WildFly security subsystem"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec108"/>The WildFly security subsystem</h2></div></div></div><p>The<a id="id1152" class="indexterm"/> WildFly security subsystem is an <a id="id1153" class="indexterm"/>extension of the application server and is included by default in both the standalone servers and domain servers. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;extension module="org.jboss.as.security"/&gt;</pre></div><p>The following<a id="id1154" class="indexterm"/> is the default security subsystem contained in the server configuration file:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
  &lt;security-domains&gt;
    &lt;security-domain name="other" cache-type="default"&gt;
      &lt;authentication&gt;
        &lt;login-module code="Remoting" flag="optional"&gt;
          &lt;module-option name="password-stacking"    value="useFirstPass"/&gt;
        &lt;/login-module&gt;
        &lt;login-module code="RealmDirect" flag="required"&gt;
          &lt;module-option name="password-stacking" value="useFirstPass"/&gt;
        &lt;/login-module&gt;
      &lt;/authentication&gt;
    &lt;/security-domain&gt;
    &lt;security-domain name="jboss-web-policy" cache-type="default"&gt;
      &lt;authorization&gt;
        &lt;policy-module code="Delegating" flag="required"/&gt;
      &lt;/authorization&gt;
    &lt;/security-domain&gt;
    &lt;security-domain name="jboss-ejb-policy" cache-type="default"&gt;
      &lt;authorization&gt;
        &lt;policy-module code="Delegating" flag="required"/&gt;
      &lt;/authorization&gt;
    &lt;/security-domain&gt;
  &lt;/security-domains&gt;
&lt;/subsystem&gt;</pre></div><p>As you can see, the configuration is pretty short, as it relies largely on default values, especially for high-level structures, such as the security management area.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note73"/>Note</h3><p>A security domain does not explicitly require an authorization policy. If a security domain does not define an authorization module, the default <code class="literal">jboss-web-policy</code> and <code class="literal">jboss-ejb-policy</code> authorizations are used. In such a case, the delegating authorization policy is applied, which simply delegates the authorization to another module declared as <code class="literal">&lt;module-option&gt;</code>.</p></div></div><p>You can override the default authentication/authorization managers with your own implementation by defining your own security management configuration. It is unlikely that you will have to override these interfaces, so we will concentrate on the <code class="literal">security-domain</code> element, which is a core aspect of the WildFly security subsystem.</p><p>A<a id="id1155" class="indexterm"/> <span class="strong"><strong>security domain</strong></span><a id="id1156" class="indexterm"/> can be imagined as a customs office for foreigners. Before the request crosses the WildFly borders, the security domain performs all the required authorization and authentication checks and notifies the caller whether they can proceed or not.</p><p>Security domains <a id="id1157" class="indexterm"/>are generally configured at server startup or in a running server and subsequently bound to the JNDI tree under the key <code class="literal">java:/jaas/</code>. Within the security domain, you can configure login authentication modules so that you can easily change your authentication provider by simply changing its login module.</p><p>The following table describes all the available<a id="id1158" class="indexterm"/> login modules, including a short description of them:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Login module</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Client</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1159" class="indexterm"/>login module<a id="id1160" class="indexterm"/> is designed to establish caller identity and credentials when AS is acting as a client. It should never be used as part of a security domain for actual server authentication.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Database</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1161" class="indexterm"/> login module<a id="id1162" class="indexterm"/> loads user/role information from a database.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Certificate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1163" class="indexterm"/>login module<a id="id1164" class="indexterm"/> is designed to authenticate users based on the X.509 certificates.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CertificateRoles</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1165" class="indexterm"/> login<a id="id1166" class="indexterm"/> module extends the <code class="literal">Certificate</code> login module to add role-mapping capabilities from a properties file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DatabaseCertificate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1167" class="indexterm"/> login module extends the <code class="literal">Certificate</code> login<a id="id1168" class="indexterm"/> module to add role-mapping capabilities from a database table.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DatabaseUsers</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1169" class="indexterm"/> is a <a id="id1170" class="indexterm"/>JDBC-based login module that supports authentication and role mapping.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Identity</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1171" class="indexterm"/>login module<a id="id1172" class="indexterm"/> simply associates the principles specified in the module options with any subject authenticated against the module.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Ldap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1173" class="indexterm"/>login module<a id="id1174" class="indexterm"/> loads user/role information from an LDAP server.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LdapExtended</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1175" class="indexterm"/>login<a id="id1176" class="indexterm"/> module is an alternate LDAP login module implementation that uses searches to locate both the user as well as the associated roles to bind the authentication.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">RoleMapping</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1177" class="indexterm"/>login<a id="id1178" class="indexterm"/> module is used to map roles that are the end result of the authentication process to one or more declarative roles.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">RunAs</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1179" class="indexterm"/> login<a id="id1180" class="indexterm"/> module can be used to allow another login module to interact with a secured EJB that provides authentication services.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Simple</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1181" class="indexterm"/> login module<a id="id1182" class="indexterm"/> is used to quickly set up the security for testing purposes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ConfigureIdentity</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1183" class="indexterm"/> is a<a id="id1184" class="indexterm"/> login module that associates the principles specified in the module options with any subject authenticated against the module.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PropertiesUsers</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1185" class="indexterm"/>login module <a id="id1186" class="indexterm"/>uses a properties file to store the username and password for authentication. No roles are mapped.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SimpleUsers</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1187" class="indexterm"/> login module<a id="id1188" class="indexterm"/> stores username and password as options.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LdapUsers</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1189" class="indexterm"/>login module authenticates <a id="id1190" class="indexterm"/>users using a LDAP server.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Kerberos</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This login module <a id="id1191" class="indexterm"/>uses <a id="id1192" class="indexterm"/>Sun's <code class="literal">Kerberos</code> login module as a mechanism for authentication.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SPNEGOUsers</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1193" class="indexterm"/> login module <a id="id1194" class="indexterm"/>works in conjunction with <code class="literal">SPNEGOAuthenticator</code> to handle the authentication.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AdvancedLdap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1195" class="indexterm"/> login module<a id="id1196" class="indexterm"/> is a refactoring of the <code class="literal">LdapExtLoginModule</code>, which is able to separate the login steps (find, authenticate, or map roles) so that any of the actions can be undertaken separately.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AdvancedADLdap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1197" class="indexterm"/>login module<a id="id1198" class="indexterm"/> is an extension of the <code class="literal">AdvancedLdap</code> login module, which is also able to query the primary group of the user being authenticated.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">UsersRoles</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1199" class="indexterm"/>login module is a simple properties-map-based login<a id="id1200" class="indexterm"/> module that consults two Java properties-formatted text files to map the username to the password (<code class="literal">users.properties</code>) and username to roles (<code class="literal">roles.properties</code>).</p>
</td></tr></tbody></table></div><p>Activating a<a id="id1201" class="indexterm"/> login module is a two-step <a id="id1202" class="indexterm"/>procedure, which is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, you need to define the login module within your <code class="literal">standalone.xml/domain.xml</code> configuration file.</li><li class="listitem">Then, you need to tell your applications to use a login module to perform authentication and authorization.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note74"/>Note</h3><p>In earlier releases of the application server, the login module was configured in a separate file named <code class="literal">login-config.xml</code>. Porting earlier login modules into the new application server is not too complex, as the format of the login module is pretty much the same as the new application server.</p></div></div><p>We will now expand these points in more detail. Let's see first how to define some commonly-used login modules, and then we will apply them to the Java EE components, such as servlets, EJB, and web services.</p></div><div class="section" title="Using the UsersRoles login module"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec109"/>Using the UsersRoles login module</h2></div></div></div><p>The <a id="id1203" class="indexterm"/>
<code class="literal">UsersRoles</code> login <a id="id1204" class="indexterm"/>module is one of the simplest security domains that can be implemented for testing purposes in your applications. It is based on two files, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">users.properties</code>: This<a id="id1205" class="indexterm"/> file contains the list of usernames and passwords</li><li class="listitem" style="list-style-type: disc"><code class="literal">roles.properties</code>: This <a id="id1206" class="indexterm"/>file contains the mapping between the users and the roles</li></ul></div><p>Here is a <a id="id1207" class="indexterm"/>sample <code class="literal">UsersRoles</code> configuration that stores the security files in the application server's configuration directory: </p><div class="informalexample"><pre class="programlisting">&lt;security-domain name="basic" cache-type="default"&gt;
 &lt;authentication&gt;
   &lt;login-module code="UsersRoles" flag="required"&gt;
       &lt;module-option name="usersProperties" value="${jboss.server.config.dir}/users.properties"/&gt;
       &lt;module-option name="rolesProperties" value="${jboss.server.config.dir}/roles.properties"/&gt;
   &lt;/login-module&gt;
 &lt;/authentication&gt;
&lt;/security-domain&gt;</pre></div><p>All you need<a id="id1208" class="indexterm"/> to do to start using your security domain is add the two properties files into the specified path (for a standalone system, the default is <code class="literal">JBOSS_HOME/standalone/configuration</code>) and add your username and password within it. This login module does not support hashed passwords; only clear passwords are supported. For example, the <code class="literal">users.properties</code> file can contain something like the following:</p><div class="informalexample"><pre class="programlisting">myusername=mypassword</pre></div><p>The <code class="literal">roles.properties</code> file contains the sets of roles for a given username. Adding a suffix to the username, as shown in the second line of the following code, allows you to assign the username roles to a group of roles:</p><div class="informalexample"><pre class="programlisting">myusername=myrole1,myrole2
myusername.MyRoleGroup1=myrole3,myrole4</pre></div><p>This means that authenticating with the admin/admin credentials will assign the role of manager to the user.</p></div><div class="section" title="Using the Database login module"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec110"/>Using the Database login module</h2></div></div></div><p>A <a id="id1209" class="indexterm"/>database <a id="id1210" class="indexterm"/>security domain follows the same logic exposed in the earlier example, the difference being that it stores the credentials <a id="id1211" class="indexterm"/>within the database. In order to run this example, we need to refer to the <code class="literal">MySqlDS</code> datasource that we created earlier, in <a class="link" href="ch03.html" title="Chapter 3. Configuring Enterprise Services">Chapter 3</a>, <span class="emphasis"><em>Configuring Enterprise Services</em></span>. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;security-domain name="mysqldomain" cache-type="default"&gt;
    &lt;authentication&gt;
         &lt;login-module code="<span class="strong"><strong>Database</strong></span>" flag="required"&gt;
               &lt;module-option name="dsJndiName" value="java:/MySqlDS"/&gt;
               &lt;module-option name="principalsQuery" value="select passwd from USERS where user=?"/&gt;
               &lt;module-option name="rolesQuery" value="select role, 'Roles' from USER_ROLES where user=?"/&gt;
         &lt;/login-module&gt;
     &lt;/authentication&gt;
&lt;/security-domain&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note75"/>Note</h3><p>You will notice in the <code class="literal">rolesQuery</code> module option that there is a second select item (<code class="literal">Roles</code>). This corresponds to a <code class="literal">RoleGroup</code> column and must always be supplied with "R" (in capital letters)..</p></div></div><p>In order to start <a id="id1212" class="indexterm"/>using this configuration, you first have to create the required tables and insert some sample data into it:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE USERS(user VARCHAR(64) PRIMARY KEY, passwd VARCHAR(64));
CREATE TABLE USER_ROLES(user VARCHAR(64), role VARCHAR(32));

INSERT INTO USERS VALUES('admin', 'admin');
INSERT INTO USER_ROLES VALUES('admin', 'Manager');</pre></div><p>As you can see, the admin user will map to the <code class="literal">Manager</code> role. One caveat of this configuration is that it uses clear-text passwords in the database so, before rolling this module production, you should consider additional security for your login module. Let's see how you can do this in the next section.</p><div class="section" title="Encrypting passwords"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec76"/>Encrypting passwords</h3></div></div></div><p>Storing passwords<a id="id1213" class="indexterm"/> in the database as clear-text strings is not considered a good practice. As a matter of fact, a database has even more potential security issues than a regular filesystem.</p><p>Fortunately, securing application passwords is relatively easy and can be achieved by adding a few extra options to your login module. As a minimum, you need to specify that the stored passwords are encrypted using a <a id="id1214" class="indexterm"/>
<span class="strong"><strong>message digest algorithm</strong></span>. For example, in the <code class="literal">mysqlLogin</code> module, you can add the highlighted lines at the end:</p><div class="informalexample"><pre class="programlisting">&lt;login-module code="Database" flag="required"&gt;
    &lt;module-option name="dsJndiName" value="java:/MySqlDS"/&gt;
    &lt;module-option name="principalsQuery" value="SELECT passwd FROMUSERS WHERE user=?"/&gt;
    &lt;module-option name="rolesQuery" value="SELECT role, 'Roles' FROMUSER_ROLES WHERE user=?"/&gt;
<span class="strong"><strong>     &lt;module-option name="hashAlgorithm" value="MD5"/&gt;</strong></span>
<span class="strong"><strong>     &lt;module-option name="hashEncoding" value="BASE64"/&gt;</strong></span>
<span class="strong"><strong>     &lt;module-option name="hashStorePassword" value="true"/&gt;</strong></span>
&lt;/login-module&gt;</pre></div><p>Here, we specified that the password will be hashed against an <code class="literal">MD5</code> hash algorithm; you can alternatively use any other algorithm allowed by your JCA provider, such as SHA.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip36"/>Tip</h3><p>For a production environment, you should avoid MD5 hashing, as it is a very weak hash. Ideally, you should use something like SHA-512 with a large number of hash iterations. You should also use a single, randomly generated salt per user. At the time of writing, one of the best hashing algorithms is bcrypt, which generates the salt for you. You should do your research before making a final decision. These encryptions are not supported by the <code class="literal">DatabaseServerLoginModule</code>, so you will need to create your own custom login module. Refer to the following link to write a <a id="id1215" class="indexterm"/>custom login module: <a class="ulink" href="https://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Writing_Custom_Login_Modules-A_Custom_LoginModule_Example.html">https://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Writing_Custom_Login_Modules-A_Custom_LoginModule_Example.html</a>.</p></div></div><p>For the sake of completeness, we include here a small application, which uses the <code class="literal">java.security.MessageDigest</code> and the <code class="literal">org.jboss.security.Base64Util</code> classes to generate the base-64 hashed password to be inserted in the database. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">public class Hash {

    public static void main(String[] args) throws Exception {
        String password = args[0];

        MessageDigest md = MessageDigest.getInstance("MD5");

        byte[] passwordBytes = password.getBytes();
        byte[] hash = md.digest(passwordBytes);
        String passwordHash = Base64.getEncoder().encodeToString(hash);
        System.out.println("password hash: "+passwordHash);
    }
}</pre></div><p>Running<a id="id1216" class="indexterm"/> the main program with <code class="literal">admin</code> as the argument generates the hash <span class="strong"><strong>X8oyfUbUbfqE9IWvAW1/3</strong></span>. This hash will be the updated password for the admin user of our database. Have a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/6232OS_10_03.jpg" alt="Encrypting passwords"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip37"/>Tip</h3><p>If you are not using Java 8, you can use the <code class="literal">org.jboss.security.Base64Utils</code> library instead of <code class="literal">Java 8</code> as shown in this section.</p></div></div></div></div><div class="section" title="Using an LDAP login module"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec111"/>Using an LDAP login module</h2></div></div></div><p>The<a id="id1217" class="indexterm"/> <span class="strong"><strong>Lightweight Directory Access Protocol</strong></span> (<span class="strong"><strong>LDAP</strong></span>) is <a id="id1218" class="indexterm"/>the <span class="emphasis"><em>de facto</em></span> standard<a id="id1219" class="indexterm"/> for providing <a id="id1220" class="indexterm"/>directory services to applications. An LDAP server can provide central directory information <a id="id1221" class="indexterm"/>for the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User credentials (login and password)</li><li class="listitem" style="list-style-type: disc">User directory information (such as names and e-mail addresses)</li><li class="listitem" style="list-style-type: disc">Web directories</li></ul></div><p>The working of LDAP revolves around a d<a id="id1222" class="indexterm"/>ata structure known as <span class="strong"><strong>entry</strong></span>. An<a id="id1223" class="indexterm"/> entry has a set of named component parts called <a id="id1224" class="indexterm"/>
<span class="strong"><strong>attributes</strong></span> <a id="id1225" class="indexterm"/>that hold the data for that entry. These attributes are like the fields in a database record.</p><p>An entry's <a id="id1226" class="indexterm"/>content and structure are defined by its object class. The object class (along with server and user settings) specifies which attributes must exist and which may exist in that particular entry.</p><p>All entries stored in an LDAP directory have a unique <a id="id1227" class="indexterm"/>
<span class="strong"><strong>distinguished name</strong></span> or <span class="strong"><strong>DN</strong></span>. The DN for <a id="id1228" class="indexterm"/>each LDAP entry is composed of two parts: the <a id="id1229" class="indexterm"/>
<span class="strong"><strong>relative distinguished name</strong></span> (<span class="strong"><strong>RDN</strong></span>) and<a id="id1230" class="indexterm"/> the location within the LDAP directory where the record resides.</p><p>In practice, the RDN is the portion of your DN that is not related to the directory tree structure and, in turn, is composed of one or several attribute names/value pairs. Let's see a concrete example of an organization, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/6232OS_10_04.jpg" alt="Using an LDAP login module"/></div><p>In the <a id="id1231" class="indexterm"/>preceding diagram, <code class="literal">cn=John Smith</code> (where <code class="literal">cn</code> stands for "common name") could be an RDN. The attribute name is <code class="literal">cn</code>, and the value is <code class="literal">John Smith</code>.</p><p>On the other hand, the DN for <code class="literal">John Smith</code> would be <code class="literal">cn=John Smith</code>, <code class="literal">ou=Marketing</code>, <code class="literal">o=Acme</code>, and <code class="literal">c=US</code> (where <code class="literal">ou</code> is short for organizational unit, <code class="literal">o</code> is short for organization, and <code class="literal">c</code> is for country).</p><div class="section" title="Connecting LDAP to WildFly"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec77"/>Connecting LDAP to WildFly</h3></div></div></div><p>Connecting <a id="id1232" class="indexterm"/>WildFly and LDAP can be done by means of several LDAP login modules. The first and obvious thing we need to do is run an instance of an LDAP server. Today, there are a huge number of LDAP servers available (both commercial and open source), and maybe you already configured one to run in your company. Just in case you don't have one, or simply don't want to add sample data to it, we suggest you have a look at the <a id="id1233" class="indexterm"/>Apache Directory project (<a class="ulink" href="http://directory.apache.org/">http://directory.apache.org/</a>). It provides an excellent solution to get started with LDAP and to build complex directory infrastructures.</p><p>Once installed, we suggest that you use the Apache Directory Studio (available at the same link), as it allows you to quickly create a directory infrastructure. The simplest way to create a directory from scratch is by means of an <a id="id1234" class="indexterm"/>
<span class="strong"><strong>LDAP Data Interchange Format</strong></span> (<span class="strong"><strong>LDIF</strong></span>) file. Within this file, you can specify all entries that will be loaded by the LDAP engine.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note76"/>Note</h3><p>A quick shortcut to import an LDIF file from the Apache studio is in the file menu <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Import</strong></span> | <span class="strong"><strong>LDIF</strong></span> into <span class="strong"><strong>LDAP</strong></span>.</p></div></div><p>Here's a basic <a id="id1235" class="indexterm"/>LDIF file we will use:</p><div class="informalexample"><pre class="programlisting">dn: dc=example,dc=com
objectclass: top
objectclass: dcObject
objectclass: organization
dc: example
o: MCC

dn: ou=People,dc=example,dc=com
objectclass: top
objectclass: organizationalUnit
ou: People

dn: uid=admin,ou=People,dc=example,dc=com
objectclass: top
objectclass: uidObject
objectclass: person
uid: admin
cn: Manager
sn: Manager
userPassword: secret

dn: ou=Roles,dc=example,dc=com
objectclass: top
objectclass: organizationalUnit
ou: Roles

dn: cn=Manager,ou=Roles,dc=example,dc=com
objectClass: top
objectClass: groupOfNames
cn: Manager
description: the JBossAS7 group
member: uid=admin,ou=People,dc=example,dc=com</pre></div><p>Once you <a id="id1236" class="indexterm"/>import this information into the LDAP server, you will end up with a small directory, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6232OS_10_05.jpg" alt="Connecting LDAP to WildFly"/></div><p>Within this directory, we have just one user registered as <code class="literal">admin</code>, belonging to the <code class="literal">Manager</code> role, as in other login modules we have seen in the earlier sections.</p><p>Now, we will configure the LDAP connection on WildFly. For our purposes, we will use the <code class="literal">LdapExtended</code> login module implementation, as shown in the following code. This implementation uses searches to locate both the user and the associated roles to bind as per authentication. The <code class="literal">roles</code> query will follow distinguished names (DNs) recursively to navigate a hierarchical role structure. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;login-module code="LdapExtended" flag="required"&gt;

    &lt;module-option name="java.naming.factory.initial"  value="com.sun.jndi.ldap.LdapCtxFactory"/&gt;
    &lt;module-option name="java.naming.provider.url" value="ldap://localhost:10389"/&gt;
    &lt;module-option name="java.naming.security.authentication" value="simple"/&gt;
    &lt;module-option name="bindDN" value="uid=admin,ou=system"/&gt;
    &lt;module-option name="bindCredential" value="secret"/&gt;
    &lt;module-option name="baseCtxDN" value="ou=People,dc=example,dc=com"/&gt;
    &lt;module-option name="baseFilter" value="(uid={0})"/&gt;
    &lt;module-option name="rolesCtxDN" value="ou=Roles,dc=example,dc=com"/&gt;
    &lt;module-option name="roleFilter" value="(member={1})"/&gt;
    &lt;module-option name="roleAttributeID" value="cn"/&gt;
    &lt;module-option name="searchScope" value="ONELEVEL_SCOPE"/&gt;
    &lt;module-option name="allowEmptyPasswords" value="true"/&gt;
&lt;/login-module&gt;</pre></div><p>Here is a <a id="id1237" class="indexterm"/>brief description of the <code class="literal">LdapExtended</code> module's properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">bindDN</code>: This<a id="id1238" class="indexterm"/> is the DN used to bind against the LDAP server for the user and roles queries, which, in our case, is "<code class="literal">uid=admin,ou=system</code>".</li><li class="listitem" style="list-style-type: disc"><code class="literal">baseCtxDN</code>: This<a id="id1239" class="indexterm"/> is the fixed DN of the context to start the user search from. In our example, it is "<code class="literal">ou=People,dc=example,dc=com</code>.".</li><li class="listitem" style="list-style-type: disc"><code class="literal">baseFilter</code>: This<a id="id1240" class="indexterm"/> is a search filter used to locate the context of the user to be authenticated. The input <code class="literal">username</code> or <code class="literal">userDN</code>, as obtained from the login module, will be substituted into the filter anywhere a <code class="literal">{0}</code> expression is seen.</li><li class="listitem" style="list-style-type: disc"><code class="literal">rolesCtxDN</code>: This<a id="id1241" class="indexterm"/> is the fixed DN of the context to search for user roles. Consider that this is not the DN of the location of the actual roles; rather, this is the DN of where the objects containing the user roles are.</li><li class="listitem" style="list-style-type: disc"><code class="literal">roleFilter</code>: This <a id="id1242" class="indexterm"/>is a search filter used to locate the roles associated with the authenticated user. An example search filter that matches on the input username is <code class="literal">(member={0})</code>. An alternative that matches on the authenticated user DN is <code class="literal">(member={1})</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">roleAttributeID</code>: This <a id="id1243" class="indexterm"/>is the name of the role attribute of the context that corresponds to the name of the role.</li><li class="listitem" style="list-style-type: disc"><code class="literal">searchScope</code>: This sets the <a id="id1244" class="indexterm"/>search scope to one of the following strings:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ONELEVEL_SCOPE</code>: This<a id="id1245" class="indexterm"/> scope searches for users and associated roles directly under the named roles context.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SUBTREE_SCOPE</code>: If <a id="id1246" class="indexterm"/>the role's context is <code class="literal">DirContext</code>, this scope searches the subtree rooted at the named object, including the named object itself. If the role's context is not <code class="literal">DirContext</code>, this scope searches only the object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OBJECT_SCOPE</code>: This<a id="id1247" class="indexterm"/> scope searches the named roles context only.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">allowEmptyPasswords</code>: This<a id="id1248" class="indexterm"/> is a flag indicating whether <code class="literal">empty(length==0)</code> passwords should be passed to the LDAP server.</li></ul></div></div></div><div class="section" title="Securing web applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec112"/>Securing web applications</h2></div></div></div><p>Okay! So, we<a id="id1249" class="indexterm"/> touched upon some of the<a id="id1250" class="indexterm"/> commonly used login modules. These login modules can be used by any Java EE application, so it's time to show a concrete example. In this section, we will show you how to apply a login module to a web application in order to show an implementation of basic web authentication.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note77"/>Note</h3><p>Basic access authentication<a id="id1251" class="indexterm"/> is the simplest way to provide a username and password when making a request through a browser.</p><p>It works by sending an encoded string containing the user credentials. This Base64-encoded string is transmitted and decoded by the receiver, resulting in a colon-separated username and password string.</p></div></div><p>The first thing we need to do is turn on web authentication. This requires you to define the <code class="literal">security-constraints</code> in the web application configuration file (<code class="literal">web.xml</code>). Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;web-app&gt;
...
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;HtmlAuth&lt;/web-resource-name&gt;
      &lt;description&gt;application security constraints
      &lt;/description&gt;
<span class="strong"><strong>      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</strong></span>
      &lt;http-method&gt;GET&lt;/http-method&gt;
      &lt;http-method&gt;POST&lt;/http-method&gt;
      &lt;http-method&gt;PUT&lt;/http-method&gt;
      &lt;http-method&gt;DELETE&lt;/http-method&gt;
    &lt;/web-resource-collection&gt;
<span class="strong"><strong>    &lt;auth-constraint&gt;</strong></span>
<span class="strong"><strong>      &lt;role-name&gt;Manager&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>    &lt;/auth-constraint&gt;</strong></span>
  &lt;/security-constraint&gt;
  &lt;login-config&gt;
     &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
     &lt;realm-name&gt;Sample Realm&lt;/realm-name&gt;
  &lt;/login-config&gt;

<span class="strong"><strong>  &lt;security-role&gt;</strong></span>
<span class="strong"><strong>     &lt;role-name&gt;Manager&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>  &lt;/security-role&gt;</strong></span>
&lt;/web-app&gt;</pre></div><p>The preceding<a id="id1252" class="indexterm"/> configuration will add a security constraint to all URLs, which obviously includes all your JSP servlets. Access will be restricted to users authenticated with the <code class="literal">Manager</code> role.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note78"/>Note</h3><p>Considering that we are using the <code class="literal">Database</code> login module, the <code class="literal">Manager</code> role will be granted to users that have authenticated with the admin credentials.</p></div></div><p>The next <a id="id1253" class="indexterm"/>configuration tweak needs to be performed in JBoss web deployment's descriptor <code class="literal">WEB-INF/jboss-web.xml</code>. There, you need to declare the security domain that will be used to authenticate the users. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;jboss-web&gt;
<span class="strong"><strong>    &lt;security-domain&gt;java:/jboss/env/mysqldomain&lt;/security-domain&gt;</strong></span>
&lt;/jboss-web&gt;</pre></div><p>Pay attention to the <code class="literal">security-domain</code> element. The value of this element must be exactly the same as the one you typed into the security domain's <code class="literal">name</code> attribute. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip38"/>Tip</h3><p>For an overview of which JNDI names are valid in WildFly, please refer to the following link: <a class="ulink" href="https://docs.jboss.org/author/display/WFLY8/Developer+Guide#DeveloperGuide-ReviewtheJNDINamespaceRules">https://docs.jboss.org/author/display/WFLY8/Developer+Guide#DeveloperGuide-ReviewtheJNDINamespaceRules</a>.</p></div></div><p>The following <a id="id1254" class="indexterm"/>diagram outlines the whole configuration sequence as <a id="id1255" class="indexterm"/>applied to a <code class="literal">Database</code> login module. Have a look at the following diagram:</p><div class="mediaobject"><img src="graphics/6232OS_10_06.jpg" alt="Securing web applications"/></div><p>Once you deploy <a id="id1256" class="indexterm"/>your application, the outcome of this action should be a popup, requesting user authentication, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6232OS_10_07.jpg" alt="Securing web applications"/></div><p>Logging in with <code class="literal">admin</code>/<code class="literal">admin</code> will grant access to the application with the <code class="literal">Manager</code> role.</p></div><div class="section" title="Securing EJBs"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec113"/>Securing EJBs</h2></div></div></div><p>Securing <a id="id1257" class="indexterm"/>applications by means of a web login form is the <a id="id1258" class="indexterm"/>most frequent option in enterprise applications. Nevertheless, the HTTP protocol is not the only choice available to access applications. For example, EJBs can be accessed by remote clients using the RMI-IIOP protocol. In such a case, you should further refine your security policies by restricting access to the EJB components, which are usually involved in the business layer of your applications.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip39"/>Tip</h3><p>
<span class="strong"><strong>How does security happen at EJB level?</strong></span>
</p><p>Authentication must be performed before any EJB method is called, and authorization should be performed at the beginning of each EJB method call.</p></div></div><p>The basic security checks can be achieved using the following five annotations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@org.jboss.ejb3.annotation.SecurityDomain</code>: This annotation specifies the <a id="id1259" class="indexterm"/>security domain, which is associated with a specific class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@javax.annotation.security.RolesAllowed</code>: This <a id="id1260" class="indexterm"/>annotation specifies the list of roles permitted to access a method(s) in an EJB.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@javax.annotation.security.RunAs</code>: This <a id="id1261" class="indexterm"/>annotation assigns a role dynamically to the EJB during the invocation of a method. It can be used if you need to <span class="emphasis"><em>temporarily</em></span> allow permission to access a certain method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@javax.annotation.security.PermitAll</code>: This <a id="id1262" class="indexterm"/>annotation allows all roles to access a particular bean method. The purpose of this annotation is to widen security access to some methods in a situation where you don't exactly know what role will access the EJB. (Imagine that some modules have been developed by a third party and they access your EJB with some poorly identified roles).</li><li class="listitem" style="list-style-type: disc"><code class="literal">@javax.annotation.security.DenyAll</code>: This<a id="id1263" class="indexterm"/> annotation denies access to all roles. It has a purpose similar to that of <code class="literal">PermitAll</code>.</li></ul></div><p>In the following<a id="id1264" class="indexterm"/> example, we are restricting access to the EJB named <code class="literal">SecureEJB</code> only to the authorized role of Manager:</p><div class="informalexample"><pre class="programlisting">import org.jboss.ejb3.annotation.SecurityDomain;
import javax.annotation.security.RolesAllowed;

@Stateless
<span class="strong"><strong>@SecurityDomain("mysqldomain")</strong></span>
<span class="strong"><strong>@RolesAllowed( { "Manager" })</strong></span>
public  class SecureEJB {
  ...
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip40"/>Tip</h3><p>Be careful! There is more than one <code class="literal">SecurityDomain</code> annotation available in the server's classpath. As shown here, you have to include <code class="literal">org.jboss.ejb3.annotation.SecurityDomain</code>. The <code class="literal">@RolesAllowed</code> annotation, on the other hand, calls for importing <code class="literal">javax.annotation.security.RolesAllowed</code>.</p></div></div><p>Annotations<a id="id1265" class="indexterm"/> can also be applied at the method level. For example, if we need a special role named <code class="literal">SuperUser</code> to insert a new user, then we tag the method, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@RolesAllowed({"SuperUser"})</strong></span>
public void createUser(String country,String name) {
    User customer = new User ();  
    customer.setCountry(country);
    customer.setName(name);
    em.persist(customer);
}</pre></div></div><div class="section" title="Securing web services"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec114"/>Securing web services</h2></div></div></div><p>Web services <a id="id1266" class="indexterm"/>authorization can be carried out in two ways, depending on whether we are dealing with a POJO-based web service or EJB-based web services.</p><p>Security<a id="id1267" class="indexterm"/> changes to POJO web services are identical to those that we introduced for servlets or JSP, which include defining <code class="literal">security-constraints</code> into <code class="literal">web.xml</code> and login modules into <code class="literal">jboss-web.xml</code>.</p><p>If you are using a web client to access your web service, that's all you need to get authenticated. If you are using a standalone client, you will need to specify the credentials to the JAX-WS factory, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">  JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();

  factory.getInInterceptors().add(new LoggingInInterceptor());
  factory.getOutInterceptors().add(new LoggingOutInterceptor());

  factory.setServiceClass(POJOWebService.class);
  factory.setAddress("http://localhost:8080/pojoService");
<span class="strong"><strong>  factory.setUsername("admin");</strong></span>
<span class="strong"><strong>  factory.setPassword("admin");</strong></span>
  POJOWebService client = (POJOWebService) factory.create();

  client.doSomething();</pre></div><p>What about <a id="id1268" class="indexterm"/>EJB-based web services? The configuration is slightly different. As the security domain is not specified in the web descriptors, we have to provide it by means of annotations:</p><div class="informalexample"><pre class="programlisting">@Stateless
@WebService(targetNamespace = "http://www.packtpub.com/", 
    serviceName = "SecureEJBService")
<span class="strong"><strong>@WebContext(authMethod = "BASIC",</strong></span>
<span class="strong"><strong>    secureWSDLAccess = false)</strong></span>
<span class="strong"><strong>@SecurityDomain(value = "mysqldomain")</strong></span>
public  class SecureEJB {
  ...
}</pre></div><p>As you can see, the <a id="id1269" class="indexterm"/>
<code class="literal">@WebContext</code> annotation <a id="id1270" class="indexterm"/>reflects the same configuration options as POJO-based web services, with BASIC authentication and unrestricted WSDL access.</p><p>The <code class="literal">@SecurityDomain</code> annotation<a id="id1271" class="indexterm"/> should be familiar to you now, as we introduced it when showing you how to secure an EJB. As you can see in the preceding web service example, it is the equivalent of the information contained in the <code class="literal">jboss-web.xml</code> file (it references the <code class="literal">mysqldomain</code> security domain).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip41"/>Tip</h3><p>If you prefer using XML deployment descriptors, the previous security configuration can also be specified by means of the <code class="literal">META-INF/ejb-jar.xml</code> and <code class="literal">META-INF/jboss-ejb3.xml</code> files.</p></div></div></div></div></div>
<div class="section" title="Securing the management interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec60"/>Securing the management interfaces</h1></div></div></div><p>One of the <a id="id1272" class="indexterm"/>most important tasks for the system administrator is restricting access to the server management interfaces. Without<a id="id1273" class="indexterm"/> a security policy, every user can gain access to the application server and modify its properties.</p><p>The attribute that is used to switch on security on the management interface is a security realm that needs <a id="id1274" class="indexterm"/>to be defined within the <code class="literal">security-realms</code> section. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;management&gt;
    &lt;security-realms&gt;
<span class="strong"><strong>        &lt;security-realm name="ManagementRealm"&gt;</strong></span>
            &lt;authentication&gt;
                &lt;local default-user="$local" skip-group-loading="true"/&gt;
                &lt;properties path="mgmt-users.properties" relative-to="jboss.server.config.dir"/&gt;
            &lt;/authentication&gt;
            &lt;authorization map-groups-to-roles="false"&gt;
                &lt;properties path="mgmt-groups.properties" relative-to="jboss.server.config.dir"/&gt;
            &lt;/authorization&gt;
        &lt;/security-realm&gt;
    &lt;/security-realms&gt;
    ...
    &lt;management-interfaces&gt;
<span class="strong"><strong>        &lt;http-interface security-realm="ManagementRealm" http-upgrade-enabled="true"&gt;</strong></span>
            &lt;socket-binding http="management-http"/&gt;
        &lt;/http-interface&gt;
    &lt;/management-interfaces&gt;
&lt;/management&gt;</pre></div><p>With the default configuration, the user properties are stored in the <code class="literal">mgmt-users.properties</code> file and the group properties in the <code class="literal">mgmt-groups.properties</code> file. Both these files can be found in the <code class="literal">configuration</code> directory of your server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note79"/>Note</h3><p>Users and groups can be added to these property files at any time. Any updates after the server has started are detected automatically.</p></div></div><p>By default, this management realm expects the entries to be in the following format:</p><div class="informalexample"><pre class="programlisting">username=HEX( MD5( username ':' realm ':' password))</pre></div><p>This means<a id="id1275" class="indexterm"/> that each user is associated with a hex-encoded hash that consists of the username, the name of the realm, and the password.</p><p>To add new users, you can use the utility script contained in the <code class="literal">bin</code> folder of your WildFly installation named <code class="literal">add-user.sh</code> (Linux) or <code class="literal">add-user.bat</code> (Windows). As you can see from the following screenshot, the <code class="literal">add-user</code> script requires the following pieces of information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Realm</strong></span>: This is <a id="id1276" class="indexterm"/>the name of the realm used to secure the management interfaces. If you just press <span class="emphasis"><em>Enter</em></span>, the user will be added in the default realm named <code class="literal">ManagementRealm</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Username</strong></span>: This is<a id="id1277" class="indexterm"/> the username we are going to add (it needs to be alphanumeric).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Password</strong></span>: This <a id="id1278" class="indexterm"/>is the password field, which needs to be different from the username.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Groups</strong></span>: This is<a id="id1279" class="indexterm"/> the name of the group you want the user to be part of. If you leave this blank, you will not be added to any groups.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>AS process</strong></span>: This<a id="id1280" class="indexterm"/> determines whether you want the user to be used to connect to another WildFly instance.</li></ul></div><div class="mediaobject"><img src="graphics/6232OS_10_08.jpg" alt="Securing the management interfaces"/></div><p>Here, we have just added the user <code class="literal">chris</code> to the default realm. This resulted in the following <a id="id1281" class="indexterm"/>property being added to <code class="literal">mgmt-users.properties</code> of your standalone and domain configurations:</p><div class="informalexample"><pre class="programlisting">chris=554dadf6fa222d6ea11a470f3dea7a94</pre></div><p>You will now be <a id="id1282" class="indexterm"/>able to connect to a remote WildFly management interface using this user, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6232OS_10_09.jpg" alt="Securing the management interfaces"/></div><p>A much easier way to add users is to use a non-interactive shell. This approach works by passing the username, password, and optionally the realm name to the <code class="literal">add-user</code> script:</p><div class="informalexample"><pre class="programlisting">add-user.sh myuser mypassword realm1</pre></div><div class="section" title="Role-based access control"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec115"/>Role-based access control</h2></div></div></div><p>
<span class="strong"><strong>Role-based access control</strong></span> (<span class="strong"><strong>RBAC</strong></span>)<a id="id1283" class="indexterm"/> is <a id="id1284" class="indexterm"/>a new feature introduced in WildFly 8. It allows system administrators to create users for the administration console but with restrictions to certain parts of the system. In JBoss AS 7, an admin console user had access to everything, which is equivalent to the SuperUser role in WildFly 8.</p><p>RBAC is <a id="id1285" class="indexterm"/>not enabled by default. To enable it, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jboss-cli.sh --connect --command="/core-service=management/access=authorization:write-attribute(name=provider,value=rbac)"</strong></span>
</pre></div><p>Then, reload the server config:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jboss-cli.sh --connect --command=":reload"</strong></span>
</pre></div><p>If you have existing users before enabling RBAC, you need to manually configure each user by mapping that user to a role. If we had a user called Yevai and wanted to assign her the role of SuperUser, we would do the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jboss-cli.sh --connect --command="/core-service=management/access=authorization/role-mapping=SuperUser/include=user-yevai:add(name=yevai,type=USER)"</strong></span>
</pre></div><p>There are seven <a id="id1286" class="indexterm"/>predefined roles in WildFly 8. Each of them is outlined in the following table. They are ordered with the most restrictive roles at the top and the least restrictive at the bottom.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Role</p>
</th><th style="text-align: left" valign="bottom">
<p>Permissions</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Monitor</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1287" class="indexterm"/>user can read the configuration and the current runtime state</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Operator</p>
</td><td style="text-align: left" valign="top">
<p>This user has all <a id="id1288" class="indexterm"/>the permissions of the preceding role, and can modify the runtime state, such as restarting or reloading the server, and flushing the database connection pool</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Maintainer</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1289" class="indexterm"/>user has all the permissions of all the preceding roles, and can modify the persistent state, such as deploying applications and setting up new datasources</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Deployer</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1290" class="indexterm"/>user has all the permissions of all the preceding roles, but with permissions to applications only. This user cannot change the configuration of the server</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Administrator</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1291" class="indexterm"/>user has all the permissions of all the preceding roles, and can view and modify sensitive data, such as the access control system</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Auditor</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id1292" class="indexterm"/>user has all the permissions of all the preceding roles, and can view and modify resources to administer the audit-logging system</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SuperUser</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1293" class="indexterm"/> user has all permissions</p>
</td></tr></tbody></table></div></div><div class="section" title="Configuring groups"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec116"/>Configuring groups</h2></div></div></div><p>One of the <a id="id1294" class="indexterm"/>new features in WildFly is the ability to assign users to groups. This means that you can assign a bunch of users to a group and then the group to a role. To create a new user and assign them to a group, you can run the following noninteractive command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user-add.sh -u tavonga -p mypassword -g MyGroup</strong></span>
</pre></div><p>Users can be managed via the admin console by a user who has the role of either Administrator or SuperUser. To do this, log in to the admin console, and navigate to the <span class="strong"><strong>Administration</strong></span> tab. Here, you <a id="id1295" class="indexterm"/>can add users to groups, create groups, and finally view members of each role. Have a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/6232OS_10_09a.jpg" alt="Configuring groups"/></div></div></div>
<div class="section" title="Securing the transport layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec61"/>Securing the transport layer</h1></div></div></div><p>If you<a id="id1296" class="indexterm"/> create a mission-critical application with just the bare concepts we covered until now, you will not be guaranteed to be shielded from <a id="id1297" class="indexterm"/>all security threats. For example, if you need to design a payment gateway, where credit card information is transmitted by means of an EJB or servlet, using just the authorization and authentication stack is really not enough.</p><p>In order to prevent disclosure of information, you have to use a protocol that provides data <span class="strong"><strong>encryption</strong></span>. Encryption <a id="id1298" class="indexterm"/>is the conversion of data into a form that cannot be understood by people or systems eavesdropping on your network. Conversely, <span class="strong"><strong>decryption</strong></span> is <a id="id1299" class="indexterm"/>the process of converting encrypted data back into its original form, so it can be understood.</p><p>The protocols used to secure communication are SSL and TLS, the latter being considered a replacement for the older SSL.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note80"/>Note</h3><p>The differences between the two protocols are minor. TLS uses <span class="emphasis"><em>stronger</em></span> encryption algorithms and has the ability to work on different ports. For the rest of our chapter, we will refer to SSL for both protocols.</p></div></div><p>There are <a id="id1300" class="indexterm"/>two basic techniques to encrypt information: <span class="strong"><strong>symmetric encryption</strong></span> (also called <span class="strong"><strong>secret key</strong></span> encryption) and <span class="strong"><strong>asymmetric encryption</strong></span> (also called <span class="strong"><strong>public key</strong></span> encryption).</p><p>Symmetric encryption<a id="id1301" class="indexterm"/> is the oldest and best-known technique. It is based on a secret key, which is applied to the text of a message to change the content in a particular way. As long as both the sender and recipient know the secret key, they can encrypt and decrypt all messages that use this key. These encryption algorithms typically work fast and are well-suited to encrypting blocks of messages at once.</p><p>One significant issue with symmetric algorithms is the requirement of an organization to distribute keys to users. This generally results in more overhead from the administrative aspect, while the keys remain vulnerable to unauthorized disclosure and potential misuse.</p><p>For this reason, a mission-critical enterprise system usually relies on asymmetric encryption algorithms. These tend to be easier to employ, manage, and make the system ultimately more secure.</p><p>Asymmetric <a id="id1302" class="indexterm"/>cryptography, also known as <a id="id1303" class="indexterm"/>public key cryptography, is <a id="id1304" class="indexterm"/>based on the concept that the key used to encrypt the message is not the one used to decrypt the message. Each user holds a couple of keys: the public key, which is distributed to other parties, and the private key, which is kept in secret. Each message is encrypted with the recipient's public key and can only be decrypted (by the recipient) with their private key. Have a look at the following diagram:</p><div class="mediaobject"><img src="graphics/6232OS_10_10.jpg" alt="Securing the transport layer"/></div><p>Using asymmetric encryption, you can be sure that your message cannot be disclosed by a third party. However, you <span class="emphasis"><em>still</em></span> have one vulnerability.</p><p>Let's suppose <a id="id1305" class="indexterm"/>you want to exchange information with a business partner, so you are requesting their public key by telephone or by e-mail. A fraudulent user intercepts your e-mail or simply listens to your conversation and quickly sends you a fake e-mail with their public key. Now, even if your data transmission is secured, it will be directed to the wrong person! This type of eavesdropping is called the man-in-the-middle attack.</p><p>In order to solve <a id="id1306" class="indexterm"/>this issue, we need a document that verifies that the public key belongs to an individual. This document is called a <a id="id1307" class="indexterm"/>
<span class="strong"><strong>digital certificate</strong></span> or the public key certificate. A digital certificate consists of a formatted block of data that contains the name of the certificate holder (which may be either a username or a system name), the holder's public key, and the digital signature of a <span class="strong"><strong>Certification Authority</strong></span> (<span class="strong"><strong>CA</strong></span>)<a id="id1308" class="indexterm"/> for authentication. The certification authority attests that the sender's name is the one associated with the public key in the document.</p><p>A prototype of a digital certificate is shown here:</p><div class="mediaobject"><img src="graphics/6232OS_10_11.jpg" alt="Securing the transport layer"/></div><p>Public key certificates are commonly used for secure interaction with websites. By default, web browsers ship with a set of predefined CAs. They are used to verify that the public certificate served to the browser when you enter a secure site has been actually issued by the owner of the website. In short, if you connect your browser to <code class="literal">https://www.abc.com</code> and your browser doesn't give certificate warning, you can be sure that you can safely interact with the entity in charge of the site.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note81"/>Note</h3><p>
<span class="strong"><strong>Simple authentication and client authentication</strong></span>
</p><p>In the previous example, we depicted a simple server authentication. In this scenario, the only party that needs to prove its identity is the server.</p><p>However, SSL is also able to perform a<a id="id1309" class="indexterm"/> <span class="strong"><strong>mutual</strong></span> <span class="strong"><strong>authentication</strong></span> (also called client or two-way authentication) in case the server requests a client certificate during the SSL handshake over the network.</p><p>The client authentication<a id="id1310" class="indexterm"/> requires a client certificate in the X.509 format from a CA. The X.509 format is an industry-standard format for SSL certificates. In the next section, we will explore the available tools to generate digital certificates and also how you can have your certificates signed by a CA.</p></div></div><div class="section" title="Enabling the Secure Socket Layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec117"/>Enabling the Secure Socket Layer</h2></div></div></div><p>WildFly uses <a id="id1311" class="indexterm"/>the <a id="id1312" class="indexterm"/>
<span class="strong"><strong>Java Secure Socket Extension</strong></span> (<span class="strong"><strong>JSSE</strong></span>), which is bundled in the Java Standard Edition to leverage the SSL/TLS communication.</p><p>An enterprise <a id="id1313" class="indexterm"/>application can secure two protocols: HTTP and RMI. HTTP communication is handled by the Undertow subsystem within the <code class="literal">standalone.xml</code>/<code class="literal">domain.xml</code> file. Securing the RMI transport is not always a compelling requirement for your applications as, in most production environments, WildFly is placed behind a firewall.</p><p>As you can see from the following diagram, your EJBs are not directly exposed to untrusted networks and are usually connected via a web server.</p><div class="mediaobject"><img src="graphics/6232OS_10_12.jpg" alt="Enabling the Secure Socket Layer"/></div><p>In order to configure WildFly to use SSL, we need a tool that generates a public key/private key pair in the form of an X.509 certificate for use by the SSL server sockets. This is covered in the next section.</p></div><div class="section" title="Certificate management tools"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec118"/>Certificate management tools</h2></div></div></div><p>One tool <a id="id1314" class="indexterm"/>that can be used to set up a <a id="id1315" class="indexterm"/>digital certificate is <code class="literal">keytool</code>, a key and certificate management utility that ships with the Java SE. It enables users to administer their own public/private key pairs and associated certificates for use in self-authentication (where the user authenticates himself or herself to other users or services) or data integrity and authentication services using digital signatures. It also allows users to cache the public keys (in the form of certificates) of their communicating peers.</p><p>The <code class="literal">keytool</code> certificate<a id="id1316" class="indexterm"/> stores the keys and certificates in a file termed as <code class="literal">keystore</code>, a repository of certificates used to identify a client or a server. Typically, a <code class="literal">keystore</code> contains a single client or server's identity, which is password protected. Let's see an example of <code class="literal">keystore</code> generation:</p><div class="informalexample"><pre class="programlisting">keytool -genkeypair -keystore wildfly.keystore -storepass mypassword -keypass mypassword -keyalg RSA -validity 180 -alias wildfly -dname "cn=packtpub,o=PackPub,c=GB"</pre></div><p>This command creates the <code class="literal">keystore</code> named <code class="literal">wildfly.keystore</code> in the working directory and assigns it the password <code class="literal">mypassword</code>. It generates a public/private key pair for the entity whose "distinguished name" has a common name <code class="literal">packtpub</code>, the organization <code class="literal">PacktPub</code>, and a two-letter country code of <code class="literal">GB</code>.</p><p>This results in a self-signed certificate (using the RSA signature algorithm) that includes the public key and the distinguished-name information. This certificate will be valid for 180 days and is associated with the private key in a <code class="literal">keystore</code> entry referred to by the alias as <code class="literal">wildflybook</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note82"/>Note</h3><p>A self-signed certificate is a certificate that has not been verified by a CA and hence leaves you vulnerable to the classic man-in-the-middle attack. A self-signed certificate is only suitable for in-house use or for testing while you wait for the official certificate to arrive.</p></div></div></div><div class="section" title="Securing HTTP communication with a self-signed certificate"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec119"/>Securing HTTP communication with a self-signed certificate</h2></div></div></div><p>Now let's <a id="id1317" class="indexterm"/>see how you can use this <code class="literal">keystore</code> file to secure your WildFly web channel. Open the server configuration file (<code class="literal">standalone.xml/domain.xml</code>), and navigate to the undertow subsystem.</p><p>First, we need to add an <code class="literal">https-listener</code> element to the server configuration, as shown in bold in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
    &lt;buffer-cache name="default"/&gt;
    &lt;server name="default-server"&gt;
        <span class="strong"><strong>&lt;https-listener name="https" socket-binding="https" security-realm="CertificateRealm"/&gt;</strong></span>
        &lt;http-listener name="default" socket-binding="http"/&gt;
        &lt;host name="default-host" alias="localhost"&gt;
            &lt;location name="/" handler="welcome-content"/&gt;
            &lt;filter-ref name="server-header"/&gt;
            &lt;filter-ref name="x-powered-by-header"/&gt;
        &lt;/host&gt;
    &lt;/server&gt;
&lt;/subsystem&gt;</pre></div><p>Now, create<a id="id1318" class="indexterm"/> a new security realm within the <code class="literal">management</code> element. The mandatory attributes are highlighted in bold in the following code. There is the path of the keystore, along with its password. The <code class="literal">keystore</code> element also takes <code class="literal">alias</code>, <code class="literal">relative-to</code>, and <code class="literal">key-password</code> attributes, all of which are optional:</p><div class="informalexample"><pre class="programlisting">&lt;management&gt;
    &lt;security-realms&gt;
        &lt;security-realm name="CertificateRealm"&gt;
            &lt;server-identities&gt;
                &lt;ssl&gt;
                   &lt;keystore path="wildfly.keystore" relative-to="jboss.server.config.dir" keystore-password="mypassword"/&gt;  
                &lt;/ssl&gt;
            &lt;server-identities&gt;
        &lt;/security-realm&gt;
    &lt;/security-realms&gt;
&lt;/management&gt;</pre></div><p>Last of all, you will need to copy the <code class="literal">wildfly.keystore</code> file to your <code class="literal">JBOSS_HOME/standalone/configuration</code> folder.</p><p>Restart WildFly to load these changes. At the bottom of your console logs, during server startup, you should see the following printout (<span class="strong"><strong>Undertow HTTPS listener https listening on /127.0.0.1:8443</strong></span>).</p><div class="mediaobject"><img src="graphics/6232OS_10_12a.jpg" alt="Securing HTTP communication with a self-signed certificate"/></div><p>If you try to<a id="id1319" class="indexterm"/> access a web application via HTTPS on your SSL-configured WildFly server, for example, if you deploy <code class="literal">chapter4</code> and access it via <code class="literal">https://localhost:8443/chapter4</code>, you will be greeted by the following screen (the screen displayed will depend on your browser):</p><div class="mediaobject"><img src="graphics/6232OS_10_13.jpg" alt="Securing HTTP communication with a self-signed certificate"/></div><p>If you are unfamiliar with how certificates work, once the browser has established a secure connection with the web server, the web server sends a certificate back to the browser. Because the certificate we just installed has <span class="emphasis"><em>not been</em></span> signed by any recognized CA, the browser security sandbox warns the user about the potential security threat.</p><p>As this is an in-house test, we <a id="id1320" class="indexterm"/>can safely proceed by choosing <span class="strong"><strong>I Understand the Risks</strong></span> | <span class="strong"><strong>Add Exception</strong></span> | <span class="strong"><strong>Confirm Security Exception</strong></span>. That's all you need to do in order to activate the SSL with a self-signed certificate.</p></div><div class="section" title="Securing the HTTP communication with a certificate signed by a CA"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec120"/>Securing the HTTP communication with a certificate signed by a CA</h2></div></div></div><p>In order to get a <a id="id1321" class="indexterm"/>certificate that your browser recognizes, you need to<a id="id1322" class="indexterm"/> issue a <span class="strong"><strong>certificate-signing request</strong></span> (<span class="strong"><strong>CSR</strong></span>) to a CA. The CA will then return a signed certificate that can be installed on your server. Most of these services are not free. The cost depends on the number of certificates you are requesting, the encryption strength, and other factors. StartSSL provides a free, low assurance certificate for servers on a public domain name.</p><p>So, to generate a CSR, you need to use the <code class="literal">keystore</code> that you created earlier and <code class="literal">keyentry</code>. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">keytool -certreq -keystore wildfly.keystore -alias wildfly -storepass mypassword -keypass mypassword  -keyalg RSA  -file certreq.csr</pre></div><p>This will create a new certificate request named <code class="literal">certreq.csr</code>, with the format shown here:</p><div class="informalexample"><pre class="programlisting">-----BEGIN NEW CERTIFICATE REQUEST-----
  ...
-----END NEW CERTIFICATE REQUEST-----</pre></div><p>The following certificate needs to be sent to a CA assuming, for example, you have chosen<a id="id1323" class="indexterm"/> <span class="strong"><strong>Verisign</strong></span> (<a class="ulink" href="http://www.verisign.com">http://www.verisign.com</a>) as the CA:</p><div class="mediaobject"><img src="graphics/6232OS_10_14.jpg" alt="Securing the HTTP communication with a certificate signed by a CA"/></div><p>After submitting <a id="id1324" class="indexterm"/>your CSR, the CA will return a signed certificate that needs to be imported into your keychain. Let's suppose that you have saved your CA certificate in a file named <code class="literal">signed_ca.txt</code>. Have a look at the following command:</p><div class="informalexample"><pre class="programlisting">keytool -import -keystore wildfly.keystore -alias testkey1 -storepass mypassword -keypass mypassword -file signed_ca.txt</pre></div><p>Here, the <code class="literal">-import</code> option is used to add a certificate or certificate chain to the list of trusted certificates as specified by the <code class="literal">-keystore</code> parameter and identified by the <code class="literal">-alias</code> parameter. The parameter <code class="literal">-storepass</code> specifies the password that is used to protect the <code class="literal">keystore</code>. If the <code class="literal">-keypass</code> option is not provided, and the private key password is different from the <code class="literal">keystore</code> password, you will be prompted for it.</p><p>Now, your web browser will recognize your new certificate as being signed by a CA and will no longer complain that it cannot validate the certificate.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec62"/>Summary</h1></div></div></div><p>We began this chapter discussing the basic concepts of security and the difference between authentication and authorization.</p><p>Authentication is used to verify the identity of a user, while authorization is used to check if the user has the rights to access a particular resource.</p><p>WildFly uses the PicketBox framework. PicketBox sits at the top of the Java Authentication and Authorization Service (JAAS) and secures all the Java EE technologies running in the application. The core section of the security subsystem is contained in the security-domain element, which performs all the required authorization and authentication checks.</p><p>We then took a look at some of the login modules used to check user credentials against different datastores. Each login module can be used by enterprise applications in either a programmatic or a declarative way. While programmatic security can provide a fine-grained security model, you should consider using declarative security, which allows a clean separation between the business layer and the security policies.</p><p>Later in the chapter, you saw how you can secure the management interfaces, namely, the new command-line interface, by adding a security realm to them.</p><p>In the last section of this chapter, we looked at how you can encrypt the communication channel using the Secure Socket Layer and how you can use certificates produced by the <code class="literal">keytool</code> Java utility.</p><p>In the next chapter, we will end our discussion of WildFly by showing how you can configure and distribute enterprise applications on OpenShift, a JBoss cloud solution.</p></div></body></html>