<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Idea of the Type Classes</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we saw the views of functional programming on data representation. In functional programming, data is most often encountered in the form of what a function returns. This result is usually a data structure that includes both the results of the function and data about the side effects that have occurred in the function. Different side effects are represented with different data structures.</p>
<p>We also saw how analyzing and working with these data structures can become tedious, so functional programming gives rise to patterns such as map and <kbd>flatMap</kbd>. There are many more patterns for working with effect types. The <kbd>map</kbd> and <kbd>flatMap</kbd> are just utility methods that are used in a specific context. However, they are general enough to repeat from one data type to another.</p>
<p>In this chapter, we will see how functional programming treats the behavior of data structures. We will see how things such as <kbd>map</kbd> and <kbd>flatMap</kbd> are organized into logical units, and show how these types represent the behavior of data structures.</p>
<p>We will introduce a notion of type classes, and we will cover the reasoning behind it in order to better understand this pattern.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Rich Wrapper pattern</li>
<li>The Type Class pattern</li>
<li>Interpretation of the Type Class pattern</li>
<li>Type Classes in different languages</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rich Wrapper pattern</h1>
                </header>
            
            <article>
                
<p><span>In this section, we will start our journey to understand the pattern of type classes. We'll start by covering the idea of the </span><em>Rich Wrapper</em><span> pattern. The pattern is specific to Scala, but it introduces the problem of separating data from behavior, which becomes important in the Type Class pattern.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Motivation</h1>
                </header>
            
            <article>
                
<p>Consider the following problem. Scala is a language built on top of JVM, so it has access to the Core Java library, and you can use the Java Core classes. You can also use any Java library in your Scala programs.</p>
<p>In this manner, Scala String and Array data types come from the Java Core. However, if you are familiar with Scala, you know that String and Array are more like Scala collections than Java strings and arrays. They are treated this way because Scala provides you with a set of extra methods, such as <kbd>map</kbd>, <kbd>flatMap</kbd>, and <kbd>filter</kbd>, on top of these types. So all the methods that ordinary Scala collections have are also available when working with strings and arrays. Strings are treated as collections of characters, and arrays as indexed sequences of elements.</p>
<p>How is it possible that in Scala we have collections methods on strings and arrays that come from Java? The answer is that Scala has a mechanism to simulate method injection into classes. We can have a class that comes from a third-party library in Scala and be able to inject additional methods into this class, without modifying <span>its original implementation and not extending the original class via subtyping</span>. This mechanism for method-injection is handy in the context of separating data from its behavior in the functional world.</p>
<p>This solution is called the <strong>Rich Wrapper</strong> pattern. To understand it, you need to understand the mechanism of implicit conversions that Scala has. This mechanism provides a way to make the compiler do extra work that ordinarily is done manually. The easiest way to understand the implicit conversions is with an example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit conversions</h1>
                </header>
            
            <article>
                
<p>Imagine that you have two different models of the same domain. Some methods expect the domain objects of one domain, but you want to call them with the domain objects of another domain.</p>
<p class="mce-root"/>
<p>Concretely, imagine a web API that responds to HTTP requests with JSON. You may want to have two versions of the object that represents your users. One version is a full version of this entity. It contains the password hash and all the other data. Here is the full version is the internal representation of the entity, meant to be used on the backend and not meant to be leaked to the end user:</p>
<pre>case class FullUser(name: String, id: Int, passwordHash: String)</pre>
<p>Another version of this object is supposed to be sent to the end user upon their HTTP requests to the web API. We don't want to expose too much information, so we are going to return a shortened version of this object. This version does not expose any sensitive information:</p>
<pre>case class ShortUser(name: String, id: Int)</pre>
<p>Consider that you need to return an object from a server from a request handler. Since the backend represents users with the <kbd>FullUser</kbd> class, we'll first need to convert it into <kbd>ShortUser</kbd> using a conversion method:</p>
<pre>def full2short(u: FullUser): ShortUser =<br/>  ShortUser(u.name, u.id)</pre>
<p>Consider also that the following method must be executed in order to return an object from a request handler in response to the HTTP request:</p>
<pre>def respondWith(user: ShortUser): Unit = ???</pre>
<p>Let's assume we have a <kbd>root</kbd> user and we need to be able to return it upon request:</p>
<pre>val rootUser = FullUser("root", 0, "acbd18db4cc2f85cedef654fccc4a4d8")</pre>
<p>From the preceding code snippet, we can imagine an HTTP request handler defined along the following lines:</p>
<pre>val handlerExplicit: PartialFunction[String, Unit] = {<br/>  case "/root_user" =&gt; respondWith(full2short(rootUser))<br/>}</pre>
<p>You don't want to explicitly perform the conversion from the backend representation each time you need to return this object. There may be many contexts in which you may want to do so. For example, you can associate the <kbd>User</kbd> entity with forum posts of that user or their comments when these are requested.</p>
<p class="mce-root"/>
<p>The concept of implicit conversions exists p<span>recisely for these situations</span><span>. In Scala, you can define a method as follows:</span></p>
<pre>implicit def full2short(u: FullUser): ShortUser =<br/> ShortUser(u.name, u.id)</pre>
<p>Whenever we use a <kbd>FullUser</kbd> instance in a place where <kbd>ShortUser</kbd> is expected, the conversion from the full object into the short object will be done automatically by the compiler using the <kbd>implicit</kbd> method in scope. This way, you can convert one value to another implicitly, without cluttering the code with irrelevant details.</p>
<p>With the implicit conversion in scope, we can write the code as follows:</p>
<pre>val handlerImplicit: PartialFunction[String, Unit] = {<br/>  case "/root_user" =&gt; respondWith(rootUser)<br/>}</pre>
<p>The preceding code is equivalent to the original code where the conversion is done explicitly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rich Wrapper</h1>
                </header>
            
            <article>
                
<p>How are implicit conversions related to the example when we need to inject methods into classes? We can treat method-injection as a conversion problem. We can use the wrapper pattern to define a class that wraps the target class (that is, accepts it as a constructor argument) and defines the methods that we need. We can then implicitly convert the original class to the wrapper whenever are we are calling any of the methods that are not initially present in the wrapper.</p>
<p><span>Consider</span><span> the following example. We are calling a</span> <kbd>filter</kbd><span> method on a String:</span></p>
<pre>println("Foo".filter(_ != 'o'))  // "F"</pre>
<p>This method is not a member of the <kbd>String</kbd> class, as the <kbd>String</kbd> class here is <kbd>java.lang.String</kbd>. However, Scala collections have this method. What happens next is that the compiler realizes that the object does not have this method, but it does not fail right away. Instead, the compiler starts to look for implicit conversions in scope that can convert this object into some other object that does have the required method. The mechanics here are the same as in the case when we are passing the user object to a method as an argument. The point is that the compiler expects one type but receives another type in its place.</p>
<p class="mce-root"/>
<p>In our case, the compiler expects the type with the <kbd>filter</kbd> method defined on it but receives a <kbd>String</kbd> type that does not have this method. Hence, it will try to convert it to the type that matches its expectations, that is, the existence of the <kbd>filter</kbd> method in the class. It turns out that we do have such a method in scope:</p>
<pre>implicit def augmentString(x: String): StringOps</pre>
<p>There is an implicit conversion defined in the <kbd>Predef</kbd> object in Scala that converts strings into a Rich Wrapper with all the collections methods, including <kbd>filter</kbd>. The same technique is used to inject the Scala collection methods into Java's arrays.</p>
<div class="packt_infobox">This technique is not specific to Scala, although the underlying mechanism is. In one form or another, it is present in many languages. For example, in C#, you have the concept of implicit conversions and can convert one type to another implicitly. In Haskell, we have a more powerful, functional version of the same technique.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Type Class pattern</h1>
                </header>
            
            <article>
                
<p>Sometimes, the effect type that we are going to use is not known in advance. Consider the problem of logging. Logging can be performed to a list or a file. Logging to a list can be implemented using the Writer effect type.</p>
<p>A Writer is an abstraction of a pair of a result and a log generated by a computation. In its simplest form, a Writer can be understood as a pair of a list of strings and an arbitrary result. We can define the Writer effect type as follows:</p>
<pre>case class SimpleWriter[A](log: List[String], value: A) {<br/>  def flatMap[B](f: A =&gt; SimpleWriter[B]): SimpleWriter[B] = {<br/>    val wb: SimpleWriter[B] = f(value)<br/>    SimpleWriter(log ++ wb.log, wb.value)<br/>  }<br/>  def map[B](f: A =&gt; B): SimpleWriter[B] =<br/>   SimpleWriter(log, f(value)<br/>}</pre>
<p>Notice that we have also defined the familiar <kbd>map</kbd> and <kbd>flatMap</kbd> methods for this effect type.</p>
<p>A few words should be said about how we have implemented the <kbd>flatMap</kbd> method. We are using a simplified version of the Writer type, in fact. In its simplified form, it is a data structure that contains a result and a list of strings—the log entries—in one data structure.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>flatMap</kbd> method answers the question of how to combine sequential computations whose effect is <kbd>SimpleWriter</kbd>. So, given two such computations, one being a continuation of another (that is, the result of the previous computation parameterizes it), the question is—how do we produce the result of that continuation so that the log of the previous computation is preserved in that result?</p>
<p>In the preceding code snippet, you can see how the implementation of the <kbd>flatMap</kbd> method is done for the <kbd>SimpleWriter</kbd> data structure. So, first, we run the continuation with the result of the current data structure as an input. This run produces another result under the side effect of <kbd>SimpleWriter</kbd>, that is, a result with a log of the computation. After that, we produce a combined Writer with the result of the second computation and the combined logs of the first and second computations.</p>
<p>We can also define a companion object for this data type that contains convenience methods to lift any value to the effect type and to create an empty structure with a single log message:</p>
<pre>object SimpleWriter {<br/>  // Wraps a value into SimpleWriter<br/>  def pure[A](value: A): SimpleWriter[A] =<br/>    SimpleWriter(Nil, value)<br/>  // Wraps a log message into SimpleWriter<br/>  def log(message: String): SimpleWriter[Unit] =<br/>    SimpleWriter(List(message), ())<br/>}</pre>
<p>Using the Writer effect type, we can use logging from an operation as follows:</p>
<pre>import SimpleWriter.log<br/>def add(a: Double, b: Double): SimpleWriter[Double] =<br/>for {<br/>  _ &lt;- log(s"Adding $a to $b")<br/>  res = a + b<br/>  _ &lt;- log(s"The result of the operation is $res")<br/>} yield res<br/>println(add(1, 2))  // SimpleWriter(List(Adding 1.0 to 2.0, The result<br/>of the operation is 3.0),3.0</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Logging to a file can be implemented with the help of another effect, <kbd>IO</kbd>. The <kbd>IO</kbd> type stands for an input-output effect, which means that the computation exchanges information with some external resources. We can define a dummy version of IO that just suspends a computation, as follows:</p>
<pre>case class IO[A](operation: () =&gt; A) {<br/>  def flatMap[B](f: A =&gt; IO[B]): IO[B] =<br/>   IO.suspend { f(operation()).operation() }<br/>  def map[B](f: A =&gt; B): IO[B] =<br/>   IO.suspend { f(operation()) }<br/>}<br/>object IO {<br/>  def suspend[A](op: =&gt; A): IO[A] = IO(() =&gt; op)<br/>  def log(str: String): IO[Unit] =<br/>   IO.suspend { println(s"Writing message to log file: $str") }<br/>}</pre>
<p>The preceding definition follows the same pattern as the <kbd>SimpleWriter</kbd> type. The <kbd>log</kbd> method does not actually write to any file, but simulates this operation by outputting to the terminal. With the help of this effect type, we can use logging as follows:</p>
<pre>import IO.log<br/>def addIO(a: Double, b: Double): IO[Double] =<br/>for {<br/>  _ &lt;- log(s"Adding $a to $b")<br/>  res = a + b<br/>  _ &lt;- log(s"The result of the operation is $res")<br/>} yield res<br/>addIO(1, 2).operation()<br/>// Outputs:<br/>// Writing message to log file: Adding 1.0 to 2.0<br/>// Writing message to log file: The result of the operation is 3.0</pre>
<p>What if we do not know beforehand where we are going to log? What if sometimes we need to log to a file and sometimes we need to log to a list? The preceding can be the case if we are working in different environments, for example, stage, test, or production. The question is: how exactly should we proceed with generalizing the preceding code so that it is effect-independent? The problem here is that the preceding two snippets differ only in the effect type they are using to log. In programming, whenever we see a pattern, it is a good idea to extract it.</p>
<p class="mce-root"/>
<p>One way to abstract away the effect type is as follows:</p>
<pre>// Does not compile<br/>// def add[F[_]](a: Double, b: Double): F[Double] =<br/>//   for {<br/>//     _ &lt;- log(s"Adding $a to $b")<br/>//     res = a + b<br/>//     _ &lt;- log(s"The result of the operation is $res")<br/>//   } yield res</pre>
<p>So, the effect type becomes an <kbd>F</kbd> type parameter. The function becomes parameterized on the type level. However, when we try to implement the body of the method, we will quickly run into difficulties. The preceding code does not compile because the compiler knows nothing about the <kbd>F</kbd> type parameter. We are calling the <kbd>map</kbd> and <kbd>flatMap</kbd> methods on this type, and the compiler has no way of knowing which methods are implemented on this type.</p>
<p>The solution to this problem comes in the form of the Type Class pattern. Under the Type Class pattern, the method looks as follows:</p>
<pre>import Monad.Ops<br/>def add[F[_]](a: Double, b: Double)(implicit M: Monad[F], L: Logging[F]): F[Double] =<br/>for {<br/>  _ &lt;- L.log(s"Adding $a to $b")<br/>  res = a + b<br/>  _ &lt;- L.log(s"The result of the operation is $res")<br/>} yield res<br/>println(add[SimpleWriter](1, 2))  // SimpleWriter(List(Adding 1.0 to 2.0, The result of the operation is 3.0),3.0)<br/>println(add[IO](1, 2).operation())<br/>// Outputs:<br/>// Writing message to log file: Adding 1.0 to 2.0<br/>// Writing message to log file: The result of the operation is 3.0<br/>// 3.0</pre>
<p>The reason we can use the <kbd>map</kbd> and <kbd>flatMap</kbd> methods here is that we now have an implicit dependency in the method's arguments list. The dependency in question is on the type class called <kbd>Monad</kbd>. <kbd>Monad</kbd> is one of the most common type classes in functional programming. One more dependency is Logging, which provides the <kbd>log</kbd> method, which is also a common method available for both effect types we are interested in.</p>
<p class="mce-root"/>
<p>Let's look at what type classes are and how they work on the example of <kbd>Monad</kbd>.</p>
<p>In the body of the function, we can use the <kbd>map</kbd> and <kbd>flatMap</kbd> functions, and the compiler can resolve them. Previously, we saw the same method-injection trick done with the help of implicit dependencies. In that case, we had an implicit conversion that converts the target type to a Rich Wrapper. In this case, a similar pattern is used. However, it is more complex. The complexity is because Rich Wrapper wrapped concrete classes, but we are now targeting abstract type variables, in our example, it is <kbd>F</kbd>.</p>
<p>Just as in the case of Rich Wrappers, the <kbd>map</kbd> and <kbd>flatMap</kbd> methods are injected into the preceding code using implicit conversions. Let's have a look at the methods and classes that enable this conversion:</p>
<pre>trait Monad[F[_]] {<br/>  def pure[A](a: A): F[A]<br/>  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]<br/>  def flatMap[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]<br/>}<br/>object Monad {<br/>  implicit class Ops[F[_], A](fa: F[A])(implicit m: Monad[F]) {<br/>    def map[B](f: A =&gt; B): F[B] = m.map(fa)(f)<br/>    def flatMap[B](f: A =&gt; F[B]): F[B] = m.flatMap(fa)(f)<br/>  }<br/>  implicit val writerMonad: Monad[SimpleWriter] = <br/>   new Monad[SimpleWriter] {<br/>     def pure[A](a: A): SimpleWriter[A] =<br/>      SimpleWriter.pure(a)<br/>    def map[A, B](fa: SimpleWriter[A])(f: A =&gt; B): SimpleWriter[B] =<br/>      fa.map(f)<br/>    def flatMap[A, B](fa: SimpleWriter[A])(f: A =&gt; SimpleWriter[B]):<br/>      SimpleWriter[B] = fa.flatMap(f)<br/>  }<br/>  implicit val ioMonad: Monad[IO] = new Monad[IO] {<br/>    def pure[A](a: A): IO[A] =<br/>     IO.suspend(a)<br/>    def map[A, B](fa: IO[A])(f: A =&gt; B): IO[B] =<br/>     fa.map(f)<br/>    def flatMap[A, B](fa: IO[A])(f: A =&gt; IO[B]): IO[B] =<br/>     fa.flatMap(f)<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the preceding code snippet, you can see the entire code that enables the required conversion. This code implements the Type Class pattern. Let's have a look at it step by step:</p>
<pre>trait Monad[F[_]] {<br/>  def pure[A](a: A): F[A]<br/>  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]<br/>  def flatMap[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]<br/>}</pre>
<p><span>In the preceding code snippet, </span>you can see the definition of the trait that contains all the methods that a particular set of effect types must implement. The concrete implementations of the trait will have the trait's type parameter set to the type for which the class is implemented. The trait consists of the declaration of all the methods that the type in question is supposed to support. Notice that all of the methods expect the object on which they are supposed to be called. This means this trait is not supposed to be implemented by the target object. Instead, the instances of this trait are supposed to be a sort of toolbox that defines certain behaviors for the type in question, without making that type extend the trait.</p>
<p>Next, we have a companion object of this trait. This companion object defines specific methods that are also part of the pattern:</p>
<pre>implicit class Ops[F[_], A](fa: F[A])(implicit m: Monad[F]) {<br/>  def map[B](f: A =&gt; B): F[B] = m.map(fa)(f)<br/>  def flatMap[B](f: A =&gt; F[B]): F[B] = m.flatMap(fa)(f)<br/>}</pre>
<p>First of all, there is a Rich Wrapper, as you can see in the preceding code. The pattern works the same way as we have seen previously, in the case of wrappers for strings and arrays. However, there is one little difference. It is defined on an <kbd>F[A]</kbd> abstract type. In principle, it can be any effect type. It may seem at first that we are defining a set of methods for every type possible. However, there are constraints on the types for which the methods are implemented. The constraints are enforced by the implicit argument that follows a constructor of the Rich Wrapper:</p>
<pre>implicit m: Monad[F]</pre>
<p>So, to construct the wrapper, we need to satisfy an implicit dependency on the type class defined in the preceding code snippet. This means that for the <kbd>F</kbd> type to be able to use the Rich Wrapper pattern, we need to have an instance of the trait defined in the preceding code in scope implicitly for this <kbd>F</kbd> type. When we say <em>an instance of the type class for the F type</em>, we mean a concrete object that extends the type class trait where the type parameter is set to <kbd>F</kbd>.</p>
<p class="mce-root"/>
<p>For example, a <kbd>Monad for Writer</kbd> instance is an object whose type conforms to <kbd>Monad[Writer]</kbd>.</p>
<p>All the Rich Wrapper's methods mimic that of the type class and are delegated to it.</p>
<p>After that, we have some default implementations of the type class for certain common classes. For example, we can define ones for our Writer and IO types:</p>
<pre>implicit val writerMonad: Monad[SimpleWriter] = new Monad[SimpleWriter] {<br/>  def pure[A](a: A): SimpleWriter[A] =<br/>   SimpleWriter.pure(a)<br/>  def map[A, B](fa: SimpleWriter[A])(f: A =&gt; B): SimpleWriter[B] =<br/>   fa.map(f)<br/>  def flatMap[A, B](fa: SimpleWriter[A])(f: A =&gt; SimpleWriter[B]):<br/>   SimpleWriter[B] = fa.flatMap(f)<br/>}<br/>implicit val ioMonad: Monad[IO] = new Monad[IO] {<br/>  def pure[A](a: A): IO[A] =<br/>   IO.suspend(a)<br/>  def map[A, B](fa: IO[A])(f: A =&gt; B): IO[B] =<br/>   fa.map(f)<br/>  def flatMap[A, B](fa: IO[A])(f: A =&gt; IO[B]): IO[B] =<br/>   fa.flatMap(f)<br/>}</pre>
<p>Note that in the preceding examples, we implement the <kbd>map</kbd> and <kbd>flatMap</kbd> methods by delegating them to the implementations owned by the <kbd>SimpleWrapper</kbd> and IO classes. This is because we have already implemented these classes with the methods in question. In the real world, it is often the case that the classes will not have the required methods. So you will write the entire implementation of them instead of delegating them to the methods owned by the classes.</p>
<p>Similar to the <kbd>Monad</kbd>, the <kbd>Logging</kbd> type class encapsulates the <kbd>log</kbd> method common to the two effect types:</p>
<pre>trait Logging[F[_]] {<br/>  def log(msg: String): F[Unit]<br/>}<br/>object Logging {<br/>  implicit val writerLogging: Logging[SimpleWriter] =<br/>  new Logging[SimpleWriter] {<br/>    def log(msg: String) = SimpleWriter.log(msg)<br/>  }<br/>  implicit val ioLogging: Logging[IO] = new Logging[IO] {<br/>    def log(msg: String) = IO.log(msg)<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>It follows the same pattern as the <kbd>Monad</kbd> type class. First, the trait declares the methods the type class will have. Next, we have the companion object with some default implementations for our effect types.</p>
<p>Let's see how the preceding code enables the logging example to use the <kbd>flatMap</kbd> and <kbd>map</kbd> methods, and how the mechanics of implicit resolution work here.</p>
<p>First of all, the compiler sees that we are trying to call the <kbd>flatMap</kbd> method on an <kbd>F</kbd> type. The compiler doesn't know anything about the <kbd>F</kbd> type—it is not aware of whether it has the method in question. In an ordinary programming language, a compile-time error would have occurred at this point. However, in Scala, implicit conversions kick in. The compiler will try to convert this <kbd>F</kbd> type to something that has the required <kbd>flatMap</kbd> method. It will start the implicit lookup to find the implicit conversion that would convert an arbitrary <kbd>F</kbd> type into something that has the required method. It will find such a conversion. The conversion will be the Rich Wrapper of the <kbd>Monad</kbd> type class, as discussed previously. The compiler will see that it can convert any <kbd>F[A]</kbd> effect type into a wrapper that has the required methods. However, it will see that it is not able to do so unless it can provide the constructor of the Rich Wrapper with an implicit dependency on the type class. This type class, <kbd>Monad</kbd>, defines the <kbd>map</kbd> and <kbd>flatMap</kbd> methods for the effect types for which it is implemented. So, in other words, only the effect types for which there is an implementation of the type class in scope can be converted into this Rich Wrapper. If a type does not have an implementation of the <kbd>Monad</kbd> type class, it will not be wrapped by the Monad's Rich Wrapper, and hence it will not have the <kbd>map</kbd> and <kbd>flatMap</kbd> methods injected into it, and a compile-time error will be generated.</p>
<p>So, the compiler will see that it can inject the required methods implicitly, but only if it finds an implicit implementation of the necessary type class. Hence, it will try to find this implementation. If you are calling it with the Writer or IO types, it will be able to find the instances of the type class because they are defined inside the Monad companion object. The companion objects are searched for the implicit implementations of their companion classes.</p>
<p>Here, we have covered a few details specific to Scala—the <em>Rich Wrapper</em> pattern is more specific to Scala than anything else. However, the Type Class pattern repeats in many languages. Next, we will cover some reasoning for the type classes so that you know how to think about this pattern.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpretation of the Type Class pattern</h1>
                </header>
            
            <article>
                
<p>Since the idea of a type class is highly abstract, it is necessary to develop an understanding of what it is and how it can be used in practice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injectable interfaces</h1>
                </header>
            
            <article>
                
<p>One way to think about the Type Class pattern is as of a way of injecting entire interfaces into existing classes.</p>
<p>In ordinary imperative languages, interfaces facilitate polymorphism. They allow you to treat classes that exhibit similar behavior uniformly. So for example, if you have classes for a car, a motorcycle, and a truck, you can define an interface vehicle, and treat all these classes as instances of that interface. No longer do you care about the peculiarities of the implementations of each class, all you care about is that all of its entities can drive. That is, they exhibit one behavior typical to all of them. An interface is a way to encapsulate a common behavior. When programming to interfaces, you are grounding your programs on the assumption that a set of entities of your program exhibits a behavior that is the same in its nature, although may differ in its details for each implementation.</p>
<p>However, in ordinary imperative languages, such as Java, you must declare the interfaces at definition-time. This means, that once the class is defined, you are not able to make it implement additional interfaces. This fact makes you struggle with polymorphism in certain situations. For example, if you have a bunch of third-party libraries and you want the classes of this library to implement specific interfaces defined in your program, you will not be able to do that.</p>
<p>If you have a look at the example with the logging, we will see that the example is precisely about the polymorphism. We take a random <kbd>F</kbd> effect type and define the example based on the assumption that it has certain behaviors—<kbd>flatMap</kbd> and <kbd>map</kbd>. Although these behaviors may differ from effect type to effect type, their nature remains the same—the sequential composition of side-effecting computations. All we care about is that an effect type we are using supports these methods. As long as this condition is met, we don't care about other details of an effect type.</p>
<p class="mce-root"/>
<p>This technique is of particular help in the functional programming world. Let's recall—how did the need for <kbd>map</kbd> and <kbd>flatMap</kbd> emerge in the first place? There is a theoretical foundation for them from a mathematical perspective. However, for engineering purposes, the need for the <kbd>map</kbd> and <kbd>flatMap</kbd> methods is quite pragmatic. Functional programmers need to frequently analyze the data structures of effect types in code in order to compose pure side-effecting computations sequentially, and this quickly becomes quite tedious. So, for us to avoid the boilerplate of analyzing the data structures every time, we have abstracted away the problem of sequential composition into the <kbd>map</kbd> and <kbd>flatMap</kbd> methods.</p>
<p>The general pattern here is that we need to do various things with functional data structures. The <kbd>map</kbd> and <kbd>flatMap</kbd> functions define how to do sequential composition of computations. However, we may want to do much more than that. The general pattern is that we should be able to abstract away common repeating operations that we have, and we may not know beforehand all the operations we may want to support. This situation makes a case for separating data from behavior. In the modern functional programming libraries, effect types (data structures with information about the side effects of a computation) are separated from their behavior (what you can do with them). This means that the effect types contain only the data that represents the side effects. Whenever we need to do something with the effect types, we inject the required behavior into them using the Type Class pattern discussed previously. Many functional libraries are divided into two parts—the data part that describes the effect types, and the type class part that represents what you can do with the data, its behavior. The two parts are unified using the type class mechanism specific to the programming language the library is written for. For example, in Scala, the mechanism of implicit conversions powers the Type Class pattern and method-injection. The Scala compiler itself has no notion of the Type Class pattern, but you can express it effectively using the tools the language provides. </p>
<div class="packt_infobox"><span>Haskell has language-level support for type classes. </span>In Haskell, there is a language-level separation between data and the type classes. You are not able to define any behavior on data. Haskell implements the philosophy of the separation of data and behavior at the language level. This cannot be said about Scala. In Scala, you can have ordinary OOP classes that can have both data (variables) and behavior (methods).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Toolboxes</h1>
                </header>
            
            <article>
                
<p>Another useful metaphor for the Type Class pattern is that there are toolboxes that allow you to do things to your data.</p>
<p>Imagine yourself as a carpenter. A carpenter is a person who creates things from wood. How does one go about creating useful things from wood? They take raw wood and go to their workshop, where they have a bunch of tools to work with wood. They use hammers, saws, and so on to turn wood into tables, chairs, and other goods. If the carpenter is sophisticated, they will probably differentiate between different types of wood. For example, certain trees have robust wood, and other trees have soft wood. The same saw is more effective with one type of wood than with another. So, the carpenter has different types of saws for different types of wood. However, the fact that the carpenter needs a saw to cut the trees remains constant, no matter the type of wood.</p>
<p>Back in the programming world, the effect types are wood. They are the raw material of the functional programming from which you compose your program. In the raw state, they are hard to process without tools—it is hard to analyze, compose, and process effect types by hand, precisely the same way it is hard to carve goods from wood without saws and hammers.</p>
<p>For this reason, there are tools to process effect types. Type classes are to effect types what saws are to wood. They are tools that allow you to process your raw material.</p>
<p>The same saw may not apply to different types of wood. In the same way, different effect types need different implementations of one type class. For example, the Writer and IO effect types need separate implementations of the <kbd>Monad</kbd> type class. The purpose of the type class, the sequential composition, remains the same; it is the way the sequential composition is done in each case that is different. This can be compared with the fact that the purpose of sawing remains the same for a wide variety of raw material, that is, to cut wood. However, the details of how it is done vary, hence separate saws for separate types of raw material.</p>
<p>This is why in the Type Class pattern, we first declare what behavior must be exhibited in a trait, and only then do we implement this behavior for each type individually.</p>
<p>Just as a carpenter has a toolbox to process raw wood, a functional programmer has a type class to process raw effect types. And just as a carpenter has an entire workshop full of tools, a functional programmer has libraries full of type classes for different purposes. We will cover these libraries in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type classes in different languages</h1>
                </header>
            
            <article>
                
<p>In principle, the idea of type classes is present even in Java. For example, Java has the <kbd>Comparator</kbd> interface, which defines how to compare two arbitrary types. It defines a relationship of order on a type. The type that is used with collections defines the order in which they are sorted.</p>
<p>However, a language such as Java lacks a mechanism for applying that class to types conveniently. So, for example, when you are sorting a collection, you need to explicitly provide an instance of the type class to the sorting method. This is unlike Scala, where it is possible to use implicit conversions and implicit lookup for the compiler to look up the implementation of the type class by itself, so as not to clutter the code.</p>
<p>In Scala, the compiler is much smarter than in Java, in part due to the presence of the implicit resolution mechanism. So, when we want to inject a specific set of methods into a class, we can do so with the help of the implicit conversions. If in Java we are required to provide all the type classes explicitly, in Scala we can leave most of this work to the compiler.</p>
<p>In Haskell, a similar mechanism is present to perform the implicit lookup of type classes. Also, Haskell follows the separation between data and behavior. So, in general, you are not able to declare methods on data, and you are not able to define classes that have both variables and methods. This is to enforce the purely functional style of programming. In Scala, which is a mix between purely functional and object-oriented programming, you can have classes that have both variables and methods.</p>
<p>Talking about the implicit resolution mechanism, we should note that it is a relatively advanced feature, and not every programming language has it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we introduced the idea of a type class, which is central to modern functional programming. We built up to this idea by introducing the Rich Wrapper pattern first, which facilitates type classes in Scala. A type class can be understood as a toolbox to process raw effect types. Another understanding of the Type Class pattern is that it is an injectable interface that you can inject into your classes to achieve polymorphism. Finally, we had a look at how type classes are used in languages other than Scala. In the next chapter, we will learn about the commonly used type classes and the libraries they are organized in.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the <em>Rich Wrapper</em> pattern for in Scala?</li>
<li>How is the Rich Wrapper implemented in Scala? What is the implicit conversions mechanism in Scala?</li>
<li>Explain the Type Class pattern.</li>
<li>What is the motivation behind the Type Class pattern?</li>
<li>Do imperative languages have type classes?</li>
</ol>


            </article>

            
        </section>
    </body></html>