<html><head></head><body>
		<div id="_idContainer234">
			<h1 id="_idParaDest-165"><em class="italic"><a id="_idTextAnchor164"/>Chapter 11</em>: Decomposing into Finer-Grained Components</h1>
			<p>In the previous chapter, we decomposed the <em class="italic">LC Application Processing</em> functionality out of the monolith. In this chapter, we will further decompose these components into even more fine-grained components. In addition, we will examine if and when such a decomposition is justified.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Continuing our design journey</li>
				<li>Even more fine-grained decomposition</li>
				<li>Decomposing the frontend</li>
				<li>Where to draw the line</li>
			</ul>
			<p>At the end of this chapter, you will be able to appreciate both technical and non-technical factors that play toward where we should draw the line on decomposing these components.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor165"/>Continuing our design journey</h1>
			<p>Currently, our application <a id="_idIndexMarker663"/>resembles the diagram depicted here:</p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/B16716_Figure_11.1.jpg" alt="Figure 11.1 – Independent data persistence &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Independent data persistence </p>
			<p>The <em class="italic">LC Application Processing</em> functionality lives as its own independent component from the rest of the <a id="_idIndexMarker664"/>application. It communicates with the monolith through the exchange of domain events using the event bus. It makes use of its own persistence store and exposes HTTP-based APIs that the frontend consumes. Let’s examine whether it is possible to further decompose the application into finer-grained components. The <strong class="source-inline">AutoApprovalSaga</strong> component currently lives within the confines of the monolith, but this is mostly an artifact of our previous design as opposed to an intentional design choice. Let’s look at how we can extract this into its own component next.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Saga as a standalone component</h2>
			<p>Currently, the <strong class="source-inline">AutoApprovalSaga</strong> component (discussed<a id="_idIndexMarker665"/> in detail in <a href="B16716_08_Final_NM_ePub.xhtml#_idTextAnchor129"><em class="italic">Chapter 8</em></a>, Implementing <em class="italic">Long-Running Workflows</em>) works by <a id="_idIndexMarker666"/>listening to domain events, as shown here:</p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/B16716_Figure_11.2.jpg" alt="Figure 11.2 – The AutoApprovalSaga functionality dissected&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The AutoApprovalSaga functionality dissected</p>
			<p>Given that these events are published by different bounded contexts onto the event bus, there is no need for <strong class="source-inline">AutoApprovalSaga</strong> to be embedded within the monolith. This means that it can be safely pulled out into its own deployable unit along with its private data store. This means that our system now looks like the diagram depicted here:</p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="image/B16716_Figure_11.3.jpg" alt="Figure 11.3 – AutoApprovalSaga extracted into an independent component&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – AutoApprovalSaga extracted into an independent component</p>
			<p>Saga components can be characterized as a collection of stateful event listeners listening to events from more than one aggregate that can issue commands to more than aggregate. We saw earlier that we form bounded contexts along aggregate boundaries. Given that sagas tend to require interaction with more than one aggregate, they may not fall within the confines of those bounded contexts. In a lot of ways, sagas are components that can be viewed as their own bounded contexts. This makes it natural to have sagas work as standalone components that exist distinctly (both from a logical and physical perspective) from other parts of a solution.</p>
			<p>As you can see, commands<a id="_idIndexMarker667"/> and queries within the <em class="italic">LC Application Processing</em> component <a id="_idIndexMarker668"/>continue to use a common data store. Let’s look at what is involved in segregating them into their own data store.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Commands and queries as standalone components</h2>
			<p>As we saw in<a id="_idIndexMarker669"/> the <em class="italic">CQRS pattern</em> section in <a href="B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Where and How Does DDD Fit?</em>, the <a id="_idIndexMarker670"/>primary benefit that we derive is the ability to evolve and scale these components independently of each other. This is important because commands and queries have completely different usage patterns and thus require the use of distinct domain models. This makes it fairly natural to further split our bounded contexts along these boundaries. Thus far, the segregation is logical. A physical separation will enable us to truly scale these components independently, as shown here:</p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="image/B16716_Figure_11.4.jpg" alt="Figure 11.4 – Commands and queries as independent components&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Commands and queries as independent components</p>
			<p>It is pertinent to note that the command processing component is now shown to have access to two distinct data stores:</p>
			<ul>
				<li>The <strong class="bold">aggregate store</strong>, which <a id="_idIndexMarker671"/>stores either an event-sourced or state-stored representation of an aggregate state.</li>
				<li>The <strong class="bold">lookup store</strong>, which can <a id="_idIndexMarker672"/>be used to store lookup data when performing business validations when processing commands. This is applicable when we need to access data that is/cannot be stored as part of the aggregate state.</li>
			</ul>
			<p>The <a id="_idIndexMarker673"/>reason <a id="_idIndexMarker674"/>we bring this up is that we may have to continue making lookups for data that still remains in the monolith. To achieve full independence, this lookup data must also be migrated using techniques such as a historic event replay (as discussed in <a href="B16716_07_Final_NM_ePub.xhtml#_idTextAnchor112"><em class="italic">Chapter 7</em></a>, <em class="italic">Implementing Queries</em>) or other conventional data migration techniques (as discussed in <a href="B16716_10_Final_NM_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 10</em></a>, <em class="italic">Beginning the Decomposition Journey</em>).</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Distributing individual query components</h2>
			<p>At this <a id="_idIndexMarker675"/>point, we have achieved segregation along command and query boundaries. But we do not need to stop here. Each of the queries we service need not necessarily remain a single component. Let’s consider an example where we need to implement a fuzzy LC search feature for the UI and a view of LC facts for analytical use cases. It is conceivable that these requirements may be implemented by a different set of teams, thereby necessitating the need for distinct components. Even if these are not distinct teams, the disparity in usage patterns may warrant the use of different persistence stores and APIs, again requiring us to look at <a id="_idIndexMarker676"/>implementing at least a subset of these as distinct components, as shown here:</p>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="image/B16716_Figure_11.5.jpg" alt="Figure 11.5 – Queries split into individual components&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Queries split into individual components</p>
			<p>Owning domains should strive to create query APIs that exhibit the characteristics of a good domain data product. Some of these characteristics include being discoverable, trustworthy, valuable in their own right, and self-describing. For more information, please refer to this article on moving from a monolithic data lake to a distributed data mesh. Specifically, the section on domain <a id="_idIndexMarker677"/>data as a product is relevant in this context: <a href="https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct">https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct</a>.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Even more fine-grained decomposition</h1>
			<p>At this stage, is <a id="_idIndexMarker678"/>there any further decomposition that is required and feasible? These days, whether rightfully or otherwise, serverless architecture (specifically, <em class="italic">functions as a service</em>) is arguably becoming all the rage. As we pointed out in <a href="B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Where and How Does DDD Fit?</em>, this means that we may be able to decompose our command side in a manner that each command becomes its own independently deployable unit (hence a bounded context). In other words, <strong class="source-inline">LCApplicationSubmitCommand</strong> and the <strong class="source-inline">LCApplicationCancelCommand</strong> can be deployed independently.</p>
			<p>But just because this is technically possible, should we do it? While it is easy to dismiss this as a passing fad, there may be good reasons to split applications along command boundaries:</p>
			<ul>
				<li><strong class="bold">Risk profile</strong>: Certain pieces <a id="_idIndexMarker679"/>of functionality present a higher risk when changes are made. For example, submitting an LC application may be deemed a lot more critical than the ability to cancel it. However, that is not to say that <em class="italic">canceling</em> is unimportant. Being decoupled from <em class="italic">submit</em> allows <em class="italic">cancel</em> changes to be made with a lot less scrutiny. This may make it easier to innovate quickly with more experimental features, with minimal fear of causing large disruptions.</li>
				<li><strong class="bold">Scalability needs</strong>: Scaling needs can differ wildly for various commands in a system. For example, <em class="italic">submit</em> may need to scale a lot more than <em class="italic">cancel</em>. However, being coupled will force us to treat them as equals, which can be inefficient.</li>
				<li><strong class="bold">Cost attribution</strong>: Having fine-grained components allows us to more accurately measure the amount of effort and the resulting ROI dedicated to each individual command. This can make it easier to focus our efforts on the most critical functionality (the “core” of the core) and<a id="_idIndexMarker680"/> minimize waste.</li>
			</ul>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>Effects on the domain model</h2>
			<p>These finer grainer <a id="_idIndexMarker681"/>components are leading us to a<a id="_idIndexMarker682"/> point where it may appear that the deployment model is starting to have a big influence on the design. The fact that it is now feasible to deploy individual “tasks” independently requires us to reexamine how we arrive at bounded contexts. For example, we started by working on the <em class="italic">LC Application Processing</em> bounded context, and our aggregate design was based on all functionality included in the scope of application processing. Now, our aggregate design can be a lot more fine-grained. This means that we can have an aggregate specifically for <em class="italic">start</em> functionality and another for <em class="italic">cancel</em>, as shown here:</p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="image/B16716_Figure_11.6.jpg" alt="Figure 11.6 – A fine-grained bounded contexts example&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – A fine-grained bounded contexts example</p>
			<p>The most fine-grained <a id="_idIndexMarker683"/>decomposition may lead us<a id="_idIndexMarker684"/> to a bounded context per command, but that does not necessarily mean that we have to decompose the system this way. In the preceding example, we have chosen to create a single bounded context for the <em class="italic">submit</em> and <em class="italic">approve</em> commands. However, <em class="italic">start</em> and <em class="italic">cancel</em> have their own bounded contexts. The actual decision that you make in your own ecosystems will depend on maintaining a balance among reuse, coupling, transactional consistency, and other considerations that we discussed earlier. It is important to note that the aggregate labeled as <strong class="source-inline">LCApplication</strong>, although named identically, is distinct from a domain model perspective in its respective bounded context. The only attribute they will need to <a id="_idIndexMarker685"/>share is a <strong class="bold">common identifier</strong>. If we choose to decompose the system into a bounded context per command, our overall solution will look like the diagram shown here:</p>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="image/B16716_Figure_11.7.jpg" alt="Figure 11.7 – Decomposition per command&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Decomposition per command</p>
			<p>It is pertinent to note <a id="_idIndexMarker686"/>that the <em class="italic">command</em> functions <a id="_idIndexMarker687"/>continue to share a single event store, although they may make use of their own individual lookup stores. We understand that this decomposition likely feels unnecessary and forced. However, this does allow us to focus our energies on the <em class="italic">core of the core</em>. For example, LC application processing may be our business differentiator. However, an even more careful examination may reveal that it is our ability to <em class="italic">decision</em> LCs near real time that is our real business differentiator. This means that it may be prudent to isolate that functionality from the rest of the system. In fact, doing so may enable us to optimize our business process without adding risk to the overall solution. While it is not strictly necessary to decompose the system in this way to arrive at such insights, a fine-grained decomposition may enable us to refine the idea of what is most important to our business. Having to share a persistent store can be a wrinkle to achieve complete independence. Therefore, a final decomposition may look something like the following:</p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="image/B16716_Figure_11.8.jpg" alt="Figure 11.8 – Command components with individual event stores&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Command components with individual event stores</p>
			<p>Obviously, there is no free lunch! This fine-grained decomposition may require additional coordination and <a id="_idIndexMarker688"/>duplication of data among these <a id="_idIndexMarker689"/>components – to a point where it may not be attractive anymore. However, we feel that it is important to illustrate the art of the possible.</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/>Decomposing the frontend</h1>
			<p>Thus far, we have<a id="_idIndexMarker690"/> focused on decomposing and distributing the backend components while keeping the frontend untouched as part of the existing monolithic system. It is worth considering breaking down the frontend to align it more closely along functional boundaries. Patterns <a id="_idIndexMarker691"/>such as micro-frontends (<a href="https://micro-frontends.org/">https://micro-frontends.org/</a>, <a href="https://martinfowler.com/articles/micro-frontends.html">https://martinfowler.com/articles/micro-frontends.html</a>) extend the concepts of microservices to the frontend. Micro-frontends promote team structures to support end-to-end ownership of a set of features. It is conceivable that a cross-functional, polyglot team owns both the experience (frontend) and the business logic (backend) functions, eliminating communication overheads drastically (along the lines of the vertical slice architecture conversation, as discussed in <a href="B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Where and How Does DDD Fit?</em>). Even if such a team organization where the frontend and backend are one team is not feasible in your current ecosystem, this approach still has many merits, such as the following:</p>
			<ul>
				<li><strong class="bold">Increased end-to-end collaboration</strong>: Creating <a id="_idIndexMarker692"/>solutions that work end to end is what ultimately provides value. Having a set of backend services isolated from their respective customer experiences will only cause us to accumulate unused inventory. To reduce the possibility of failure, the closer the collaboration between the backend capability and frontend experience teams, the greater our chance of reducing waste due to misaligned requirements. Including the customer experiences as part of the vertical slice allows us to apply the ubiquitous language through the entire stack.</li>
				<li><strong class="bold">Uniform omnichannel experiences</strong>: These days, it is very common to surface the same functionality across more than one experience channel. Having an inconsistent experience across channels can lead to customer dissatisfaction and/or adverse business consequences. Aligning teams closely along functional boundaries (within the same <em class="italic">swim lane</em>) can promote high levels of collaboration and consistency when exposing business functionality. Consider the example shown here. Within a vertical slice, the allegiance is to the functionality being developed, although there may be a need to use disparate technologies to build each channel (iOS, Android, web, and so on). Within a vertical slice, each box depicted in the diagram may operate as a team of its own, while<a id="_idIndexMarker693"/> maintaining<a id="_idIndexMarker694"/> strong cohesion with the functional team within the same swim lane, as shown here:</li>
			</ul>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="image/B16716_Figure_11.9_NEW.jpg" alt="Figure 11.9 – Teams aligned along functional boundaries&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Teams aligned along functional boundaries</p>
			<p>While there are many advantages in employing this approach, as with everything else, it does come with a few gotchas that you may need to be mindful of:</p>
			<ul>
				<li><strong class="bold">End-to-end testing complexity</strong>: While this is true for a lot of distributed architectures, this <a id="_idIndexMarker695"/>problem is exacerbated in the case of user experiences because of it being a visual medium. Especially if real components come together close to the end of the cycle, it may become harder to visualize the end-to-end flow until almost all the visual elements are in place. This may also be in conflict with how end users interact with a system as a whole. This may make end-to-end testing complex because it needs components from multiple teams to come together, possibly close to the end of the cycle.</li>
				<li><strong class="bold">Deployment complexity</strong>: In the<a id="_idIndexMarker696"/> preceding example, we have split the application along functional boundaries. However, they have to come together as a single artifact at the time of deployment (this is especially true in the case of mobile applications). This can add quite a bit of deployment complexity when the complete application is assembled. It is important to be cognizant of the relationship patterns between teams (as covered in <a href="B16716_09_Final_NM_ePub.xhtml#_idTextAnchor138"><em class="italic">Chapter 9</em></a>, <em class="italic">Integrating with External Systems</em>) to work through kinks.</li>
				<li><strong class="bold">Dependency management</strong>: Given that<a id="_idIndexMarker697"/> teams may need to ultimately deploy the application as a <a id="_idIndexMarker698"/>unit, managing dependencies between individual modules may become cumbersome. This may manifest itself in the form of conflicting dependency versions, leading to unpredictable and inefficient runtime behavior and performance. For example, two teams may use different versions of the same frontend library, which may add to the overall payload that gets downloaded to the browser. In addition to being wasteful, this may also result in unpredictable, hard-to-diagnose errors, and eventually, poor customer experience.</li>
				<li><strong class="bold">Inconsistent user experiences</strong>: Although we may have split the application in a seemingly logical<a id="_idIndexMarker699"/> manner, if we don’t do it in a manner that is transparent to the end users, it may result in a confusing and likely frustrating experience. To mitigate this, there may be a need to build common assets, widgets, and so on. which may further add to the overall complexity and coordination required when shipping out the end product.</li>
			</ul>
			<p>If we proceed to continue decomposing our application as suggested previously, our application will end up looking like the diagram shown here:</p>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="image/B16716_Figure_11.10.jpg" alt="Figure 11.10 – Commands and query frontends decomposed into individual functions&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Commands and query frontends decomposed into individual functions</p>
			<p>As we saw, there are multiple ways to approach decomposing an application into finer-grained components. Just<a id="_idIndexMarker700"/> because it is possible to do it, it doesn’t mean that we should. Let’s look at when decomposition starts to become too expensive to sustain productivity.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Where to draw the line</h1>
			<p>In general, the smaller <a id="_idIndexMarker701"/>the size of our bounded contexts, the easier it becomes to manage complexity. Does that mean we should decompose our systems into as fine-grained a granularity as possible? On the other hand, having extremely fine-grained components can increase coupling among them to the extent where it becomes very hard to manage operational complexity. Hence, decomposing a system into well-factored, collaborating components can be a bit tricky, seeming to work more like an art rather than an exact science. There is no right or wrong answer here. In general, if things feel and become painful, you most likely got it more wrong than right. Here are some non-technical heuristics that might help guide this process:</p>
			<ul>
				<li><strong class="bold">Existing organization boundaries</strong>: Look <a id="_idIndexMarker702"/>to align along with current organizational structures. Identify which applications your business unit/department/team already owns and assign responsibilities in a manner that causes minimal disruption.</li>
				<li><strong class="bold">End-user roles and responsibilities</strong>: What work do your end users carry out? What enables them to do their work with the least friction possible? If too many people need to get involved to get a piece of work done, that may be a sign that the current decomposition may be suboptimal. On the other hand, if it is hard to assign a task to a specific user, it may again be a sign of incorrect decomposition.</li>
				<li><strong class="bold">Change in vernacular</strong>: Look for subtle changes in the usage of common terms (the <em class="italic">ubiquitous language</em>). Does someone call something that is/feels the same in the physical world by different names? For example, a credit card can be called “plastic,” “payment instrument,” and “account” by different people or the same people in a different context. The point at which the vernacular changes may be the time to split functionality.</li>
				<li><strong class="bold">Existing (modular/monolithic/distributed) applications</strong>: How are your current<a id="_idIndexMarker703"/> applications<a id="_idIndexMarker704"/> segregated logically? How are they segregated physically? This might provide some inspiration.</li>
			</ul>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Team organization</h1>
			<p>All of the<a id="_idIndexMarker705"/> preceding techniques draw inspiration from existing constructs. However, what if one or more of the preceding are wrong/cumbersome/suboptimal? In such a case, our work as developers/architects is a bit more involved.</p>
			<p>It is also pertinent to note that it is not uncommon to get domain boundaries wrong. Coming up with an initial breakdown that seems to make more sense and applying a series of <em class="italic">what if</em> questions to assess suitability can help. If the reasoning is able to stand up to scrutiny by domain experts, architects, and other stakeholders, you might be in a good place. If you do choose to go down this route, it may be prudent to adjust existing organizational structures to match your proposed architecture. This will help reduce friction (in other words, apply what is called<a id="_idIndexMarker706"/> the <em class="italic">inverse Conway maneuver</em> (<a href="https://www.thoughtworks.com/en-us/radar/techniques/inverse-conway-maneuver">https://www.thoughtworks.com/en-us/radar/techniques/inverse-conway-maneuver</a>).</p>
			<p>This style of team organization can be quite complex. The people at Spotify popularized the idea of a multidisciplinary, mostly autonomous team structure aligning closely along functional boundaries (called <em class="italic">squads</em>), as shown <a id="_idIndexMarker707"/>here:</p>
			<div>
				<div id="_idContainer231" class="IMG---Figure">
					<img src="image/B16716_Figure_11.11.jpg" alt="Figure 11.11 – The Spotify model of team organization&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – The Spotify model of team organization</p>
			<p>The team structure has other <a id="_idIndexMarker708"/>components such as chapters, tribes, and guilds, which enable a better flow of change, clarify team responsibilities, promote better intra- and inter-team collaboration, and so on. You can find out more about it in this post: <a href="https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf">https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf</a>. However, there is no one-size-fits-all <a id="_idIndexMarker709"/>approach, and you will need to account for your own organizational structures and realities before looking to adopt this style. To find out more about the <em class="italic">limitations of the Spotify model</em> (<a href="https://www.youtube.com/watch?v=4GK1NDTWbkY">https://www.youtube.com/watch?v=4GK1NDTWbkY</a>) and how you can arrive at a team organization that better suits your own requirements, you may want to take a look at the work done by Matthew Skelton and Manuel Pais in their popular book <em class="italic">Team Topologies</em> (<a href="https://teamtopologies.com/book">https://teamtopologies.com/book</a>). On a related note, it may also be helpful to look at the chapter on team design from the book <em class="italic">Agile IT Organization Design</em> (<a href="https://www.amazon.com/Agile-Organization-Design-Transformation-Continuous/dp/0133903354">https://www.amazon.com/Agile-Organization-Design-Transformation-Continuous/dp/0133903354</a>) by Sriram Narayan, where he talks about outcome-oriented versus activity-oriented teams.</p>
			<p>Despite all our due diligence and noble intentions, it is still possible to get these boundaries wrong, or a change in business priorities or competitor offerings may render decisions that appeared perfectly valid at the time to become incorrect. Instead of looking to arrive at the perfect decomposition, it might be prudent to embrace change and invest in building designs that are flexible while being prepared to evolve and refactor the architecture iteratively. This book on building evolutionary architectures has some great advice on how to do precisely that: <a href="https://evolutionaryarchitecture.com/">https://evolutionaryarchitecture.com/</a>.</p>
			<p>In order to attain a reasonable level of success, there will be a need to maintain a fine balance between how domains are modeled, what the team organizations are, and how applications are architected. When all of these are in agreement, it is likely that you get pretty close to achieving high levels of <a id="_idIndexMarker710"/>success, as depicted in the following diagram:</p>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="image/B16716_Figure_11.12.jpg" alt="Figure 11.12 – Forces influencing component decomposition&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Forces influencing component decomposition</p>
			<p>As a general guideline, it helps to start with a coarse-grained decomposition at the outset when requirements and/or our understanding are likely still unclear, leaving finer-grained decomposition<a id="_idIndexMarker711"/> to a time when our understanding improves.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>Summary</h1>
			<p>In this chapter, we learned how an already fine-grained application can be further decomposed to the level of individual functions, each of which may be deployed as its own independent unit. We looked at how we stand to benefit from keeping end-to-end functionality (a thin vertical slice) as a cohesive unit, which includes components from the frontend experience all the way to the backend.</p>
			<p>Further, we looked at how Conway’s law can play an important role in the evolution of our architecture. We also looked at how we may be able to course correct cumbersome organizational structures by applying the inverse Conway maneuver. Finally, we briefly touched on popular methods of team organization that you can take inspiration from when designing your own organizational structures.</p>
			<p>In the next chapter, we will look at a variety of non-functional characteristics that play a significant role in how we can decompose and distribute applications.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Further reading</h1>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/B16716_11_Table_01.jpg" alt=""/>
				</div>
			</div>
		</div>
	</body></html>