["```java\npackage retcalc\n\nimport org.scalactic.{Equality, TolerantNumerics, TypeCheckedTripleEquals}\nimport org.scalatest.{Matchers, WordSpec}\n\nclass RetCalcSpec extends WordSpec with Matchers with TypeCheckedTripleEquals {\n\n  implicit val doubleEquality: Equality[Double] = \n    TolerantNumerics.tolerantDoubleEquality(0.0001)\n\n  \"RetCalc.futureCapital\" should {\n    \"calculate the amount of savings I will have in n months\" in {\n      val actual = RetCalc.futureCapital(\n        interestRate = 0.04 / 12, nbOfMonths = 25 * 12, \n        netIncome = 3000, currentExpenses = 2000, \n        initialCapital = 10000)\n      val expected = 541267.1990\n      actual should ===(expected)\n  }\n}\n```", "```java\nimplicit val doubleEquality: Equality[Double] =\n  TolerantNumerics.tolerantDoubleEquality(0.0001)\n```", "```java\nscala> val double1 = 0.01 -0.001 + 0.001\ndouble1: Double = 0.010000000000000002\n\nscala> double1 == 0.01\nres2: Boolean = false\n```", "```java\npackage retcalc\n\nobject RetCalc {\n  def futureCapital(interestRate: Double, nbOfMonths: Int, netIncome:     \n  Int, currentExpenses: Int, initialCapital: Double): Double = ???\n}\n```", "```java\ndef futureCapital(interestRate: Double, nbOfMonths: Int, netIncome: Int, currentExpenses: Int, initialCapital: Double): Double = {\n  val monthlySavings = netIncome - currentExpenses\n\n  def nextCapital(accumulated: Double, month: Int): Double =\n    accumulated * (1 + interestRate) + monthlySavings\n\n  (0 until nbOfMonths).foldLeft(initialCapital)(nextCapital)\n}\n```", "```java\ndef foldLeft[B](z: B)(op: (B, A) => B): B\n```", "```java\ndef futureCapital(interestRate: Double, nbOfMonths: Int, netIncome: Int, currentExpenses: Int, initialCapital: Double): Double = {\n  val monthlySavings = netIncome - currentExpenses\n  (0 until nbOfMonths).foldLeft(initialCapital)(\n    (accumulated, _) => accumulated * (1 + interestRate) + \n     monthlySavings)\n}\n```", "```java\n(param1, param2, ..., paramN) => function body.\n```", "```java\n\"RetCalc.futureCapital\" should {\n  \"calculate how much savings will be left after having taken a pension \n    for n months\" in {\n    val actual = RetCalc.futureCapital(\n      interestRate = 0.04/12, nbOfMonths = 40 * 12,\n      netIncome = 0, currentExpenses = 2000, initialCapital = \n      541267.1990)\n    val expected = 309867.53176\n    actual should ===(expected)\n  }\n}\n```", "```java\n\"RetCalc.simulatePlan\" should {\n  \"calculate the capital at retirement and the capital after death\" in {\n    val (capitalAtRetirement, capitalAfterDeath) = \n    RetCalc.simulatePlan(\n      interestRate = 0.04 / 12,\n      nbOfMonthsSaving = 25 * 12, nbOfMonthsInRetirement = 40 * 12,\n      netIncome = 3000, currentExpenses = 2000,\n      initialCapital = 10000)\n    capitalAtRetirement should === (541267.1990)\n    capitalAfterDeath should === (309867.5316)\n  }\n}\n```", "```java\ndef simulatePlan(interestRate: Double,\n                 nbOfMonthsSavings: Int, nbOfMonthsInRetirement: Int,\n                 netIncome: Int, currentExpenses: Int, initialCapital: \n                 Double) : (Double, Double) = ???\n```", "```java\nscala> val tuple3 = (1, \"hello\", 2.0)\ntuple3: (Int, String, Double) = (1,hello,2.0)\n\nscala> tuple3._1\nres1: Int = 1\n\nscala> tuple3._2\nres2: String = hello\n\nscala> val (a, b, c) = tuple3\n\na: Int = 1\nb: String = hello\nc: Double = 2.0\n```", "```java\ndef simulatePlan(interestRate: Double,\n                 nbOfMonthsSaving: Int, nbOfMonthsInRetirement: Int,\n                 netIncome: Int, currentExpenses: Int, initialCapital: \n                  Double) : (Double, Double) = {\n  val capitalAtRetirement = futureCapital(\n    interestRate = interestRate, nbOfMonths = nbOfMonthsSaving,\n    netIncome = netIncome, currentExpenses = currentExpenses,\n    initialCapital = initialCapital)\n\n  val capitalAfterDeath = futureCapital(\n    interestRate = interestRate, nbOfMonths = nbOfMonthsInRetirement,\n    netIncome = 0, currentExpenses = currentExpenses,\n    initialCapital = capitalAtRetirement)\n\n  (capitalAtRetirement, capitalAfterDeath)\n}\n```", "```java\n\"RetCalc.nbOfMonthsSaving\" should {\n  \"calculate how long I need to save before I can retire\" in {\n    val actual = RetCalc.nbOfMonthsSaving(\n      interestRate = 0.04 / 12, nbOfMonthsInRetirement = 40 * 12,\n      netIncome = 3000, currentExpenses = 2000, initialCapital = 10000)\n    val expected = 23 * 12 + 1\n    actual should ===(expected)\n  }\n}\n```", "```java\ndef nbOfMonthsSaving(interestRate: Double, nbOfMonthsInRetirement: Int,\n                     netIncome: Int, currentExpenses: Int, initialCapital: Double): Int = {\n  def loop(months: Int): Int = {\n    val (capitalAtRetirement, capitalAfterDeath) = simulatePlan(\n      interestRate = interestRate,\n      nbOfMonthsSaving = months, nbOfMonthsInRetirement = \n      nbOfMonthsInRetirement,\n      netIncome = netIncome, currentExpenses = currentExpenses,\n      initialCapital = initialCapital)\n\n    val returnValue =\n      if (capitalAfterDeath > 0.0)\n        months\n      else\n        loop(months + 1)\n    returnValue\n  }\n  loop(0)\n}\n```", "```java\n\"RetCalc.nbOfMonthsSaving\" should {\n  \"calculate how long I need to save before I can retire\" in {...}\n\n  \"not crash if the resulting nbOfMonths is very high\" in {\n     val actual = RetCalc.nbOfMonthsSaving(\n      interestRate = 0.01 / 12, nbOfMonthsInRetirement = 40 * 12,\n      netIncome = 3000, currentExpenses = 2999, initialCapital = 0)\n    val expected = 8280\n    actual should ===(expected)\n  }\n\n  \"not loop forever if I enter bad parameters\" in pending\n```", "```java\n@tailrec\ndef loop(months: Int): Int = {\n  val (capitalAtRetirement, capitalAfterDeath) = simulatePlan(\n    interestRate = interestRate,\n    nbOfMonthsSaving = months, nbOfMonthsInRetirement = \n    nbOfMonthsInRetirement,\n    netIncome = netIncome, currentExpenses = currentExpenses,\n    initialCapital = initialCapital)\n\n  if (capitalAfterDeath > 0.0)\n    months\n  else\n    loop(months + 1)\n```", "```java\n\"RetCalc.nbOfMonthsSaving\" should {\n  \"calculate how long I need to save before I can retire\" in {...}\n\n  \"not crash if the resulting nbOfMonths is very high\" in {...}\n\n  \"not loop forever if I enter bad parameters\" in {\n    val actual = RetCalc.nbOfMonthsSavingV2(\n      interestRate = 0.04 / 12, nbOfMonthsInRetirement = 40 * 12,\n      netIncome = 1000, currentExpenses = 2000, initialCapital = 10000)\n    actual should === (Int.MaxValue)\n  }\n}\n```", "```java\ndef nbOfMonthsSaving(interestRate: Double, nbOfMonthsInRetirement: Int,\n                     netIncome: Int, currentExpenses: Int, initialCapital: Double): Int = {\n  @tailrec\n  def loop(nbOfMonthsSaving: Int): Int = {...}\n\n  if (netIncome > currentExpenses)\n    loop(0)\n  else\n    Int.MaxValue\n}\n```", "```java\nsealed trait Shape\ncase class Circle(diameter: Double) extends Shape\ncase class Rectangle(width: Double, height: Double) extends Shape\n```", "```java\npackage retcalc\n\nsealed trait Returns\ncase class FixedReturns(annualRate: Double) extends Returns\ncase class VariableReturns(returns: Vector[VariableReturn]) extends Returns\ncase class VariableReturn(monthId: String, monthlyRate: Double)\n```", "```java\n\"VariableReturns.fromUntil\" should {\n  \"keep only a window of the returns\" in {\n    val variableReturns = VariableReturns(Vector.tabulate(12) { i =>\n      val d = (i + 1).toDouble\n      VariableReturn(f\"2017.$d%02.0f\", d)\n    })\n\n    variableReturns.fromUntil(\"2017.07\", \"2017.09\").returns should ===\n    (Vector(\n      VariableReturn(\"2017.07\", 7.0),\n      VariableReturn(\"2017.08\", 8.0)\n    ))\n\n    variableReturns.fromUntil(\"2017.10\", \"2018.01\").returns should ===\n    (Vector(\n      VariableReturn(\"2017.10\", 10.0),\n      VariableReturn(\"2017.11\", 11.0),\n      VariableReturn(\"2017.12\", 12.0)\n    ))\n  }\n}\n```", "```java\ncase class VariableReturns(returns: Vector[VariableReturn]) extends Returns {\n  def fromUntil(monthIdFrom: String, monthIdUntil: String): \n    VariableReturns =\n    VariableReturns(\n      returns\n        .dropWhile(_.monthId != monthIdFrom)\n        .takeWhile(_.monthId != monthIdUntil))\n}\n```", "```java\n\"RetCalc.futureCapital\" should {\n    \"calculate the amount of savings I will have in n months\" in {\n      // Excel =-FV(0.04/12,25*12,1000,10000,0)\n      val actual = RetCalc.futureCapital(FixedReturns(0.04), \n        nbOfMonths = 25 * 12, netIncome = 3000, \n        currentExpenses = 2000, initialCapital = 10000).right.value\n      val expected = 541267.1990\n      actual should ===(expected)\n    }\n\n    \"calculate how much savings will be left after having taken a \n     pension for n months\" in {\n      val actual = RetCalc.futureCapital(FixedReturns(0.04), \n        nbOfMonths = 40 * 12, netIncome = 0, currentExpenses = 2000, \n        initialCapital = 541267.198962).right.value\n      val expected = 309867.5316\n      actual should ===(expected)\n    }\n  }\n```", "```java\ndef futureCapital(returns: Returns, nbOfMonths: Int, netIncome: Int, currentExpenses: Int,\n                  initialCapital: Double): Double = {\n  val monthlySavings = netIncome - currentExpenses\n  (0 until nbOfMonths).foldLeft(initialCapital) {\n    case (accumulated, month) =>\n      accumulated * (1 + Returns.monthlyRate(returns, month)) + \n      monthlySavings\n  }\n}\n```", "```java\nobject Returns {\n  def monthlyRate(returns: Returns, month: Int): Double = ???\n}\n```", "```java\nclass ReturnsSpec extends WordSpec with Matchers with TypeCheckedTripleEquals {\n\n  implicit val doubleEquality: Equality[Double] =\n    TolerantNumerics.tolerantDoubleEquality(0.0001)\n\n  \"Returns.monthlyRate\" should {\n    \"return a fixed rate for a FixedReturn\" in {\n      Returns.monthlyRate(FixedReturns(0.04), 0) should ===(0.04 / 12)\n      Returns.monthlyRate(FixedReturns(0.04), 10) should ===(0.04 / 12)\n    }\n\n    val variableReturns = VariableReturns(Vector(\n      VariableReturn(\"2000.01\", 0.1), \n      VariableReturn(\"2000.02\", 0.2)))\n    \"return the nth rate for VariableReturn\" in {\n      Returns.monthlyRate(variableReturns, 0) should ===(0.1)\n      Returns.monthlyRate(variableReturns, 1) should ===(0.2)\n    }\n\n    \"roll over from the first rate if n > length\" in {\n      Returns.monthlyRate(variableReturns, 2) should ===(0.1)\n      Returns.monthlyRate(variableReturns, 3) should ===(0.2)\n      Returns.monthlyRate(variableReturns, 4) should ===(0.1)\n    }\n  }\n```", "```java\ndef monthlyRate(returns: Returns, month: Int): Double = returns match {\n  case FixedReturns(r) => r / 12\n  case VariableReturns(rs) => rs(month % rs.length).monthlyRate\n}\n```", "```java\nscala> Vector(1, 2, 3, 4) match {\n  case head +: second +: tail => tail\n}\nres0: scala.collection.immutable.Vector[Int] = Vector(3, 4)\n\nscala> Vector(1, 2, 3, 4) match {\n  case head +: second +: tail => second\n}\n\nscala> (\"0\", 1, (2.0, 3.0)) match {\n  case (\"0\", int, (d0, d1)) => d0 + d1\n}\nres2: Double = 5.0\n\nscala> \"hello\" match {\n  case \"hello\" | \"world\" => 1\n  case \"hello world\" => 2\n}\nres3: Int = 1\n\nscala> def present(p: Person): String = p match {\n  case Person(name, age) if age < 18 => s\"$name is a child\"\n  case p => s\"${p.name} is an adult\" \n}\npresent: (p: Person)String\n```", "```java\n  def monthlyRate(returns: Returns, month: Int): Double = returns match {\n//    case FixedReturns(r) => r / 12\n    case VariableReturns(rs) => rs(month % rs.length).monthlyRate\n  }\n```", "```java\nWarning:(27, 59) match may not be exhaustive.\nIt would fail on the following input: FixedReturns(_)\n  def monthlyRate(returns: Returns, month: Int): Double = returns match {\n```", "```java\nval params = RetCalcParams(\n  nbOfMonthsInRetirement = 40 * 12,\n  netIncome = 3000,\n  currentExpenses = 2000,\n  initialCapital = 10000)\n\n\"RetCalc.simulatePlan\" should {\n  \"calculate the capital at retirement and the capital after death\" in {\n    val (capitalAtRetirement, capitalAfterDeath) = \n    RetCalc.simulatePlan(\n      returns = FixedReturns(0.04), params, nbOfMonthsSavings = 25*12)\n\n    capitalAtRetirement should === (541267.1990)\n    capitalAfterDeath should === (309867.5316)\n  }\n\n  \"use different returns for capitalisation and drawdown\" in {\n    val nbOfMonthsSavings = 25 * 12\n    val returns = VariableReturns(\n      Vector.tabulate(nbOfMonthsSavings + \n        params.nbOfMonthsInRetirement)(i =>\n        if (i < nbOfMonthsSavings)\n          VariableReturn(i.toString, 0.04 / 12)\n        else\n          VariableReturn(i.toString, 0.03 / 12)))\n    val (capitalAtRetirement, capitalAfterDeath) =\n      RetCalc.simulatePlan(returns, params, nbOfMonthsSavings)\n    capitalAtRetirement should ===(541267.1990)\n    capitalAfterDeath should ===(-57737.7227)\n  }\n}\n```", "```java\ncase class RetCalcParams(nbOfMonthsInRetirement: Int,\n                         netIncome: Int,\n                         currentExpenses: Int,\n                         initialCapital: Double)\n\nobject RetCalc {\n  def simulatePlan(returns: Returns, params: RetCalcParams, \n  nbOfMonthsSavings: Int)\n  : (Double, Double) = {\n    import params._\n    val capitalAtRetirement = futureCapital(\n      returns = returns,\n      nbOfMonths = nbOfMonthsSavings,\n      netIncome = netIncome, currentExpenses = currentExpenses,\n      initialCapital = initialCapital)\n\n    val capitalAfterDeath = futureCapital(\n      returns = OffsetReturns(returns, nbOfMonthsSavings),\n      nbOfMonths = nbOfMonthsInRetirement,\n      netIncome = 0, currentExpenses = currentExpenses,\n      initialCapital = capitalAtRetirement)\n\n    (capitalAtRetirement, capitalAfterDeath)\n  }\n```", "```java\n\"Returns.monthlyReturn\" should {\n  \"return a fixed rate for a FixedReturn\" in {...}\n\n  val variableReturns = VariableReturns(\n    Vector(VariableReturn(\"2000.01\", 0.1), VariableReturn(\"2000.02\", 0.2)))\n\n  \"return the nth rate for VariableReturn\" in {...}\n\n  \"return an error if n > length\" in {...}\n\n  \"return the n+offset th rate for OffsetReturn\" in {\n      val returns = OffsetReturns(variableReturns, 1)\n      Returns.monthlyRate(returns, 0).right.value should ===(0.2)\n    }\n}\n```", "```java\nsealed trait Returns\ncase class FixedReturns(annualRate: Double) extends Returns\ncase class VariableReturn(monthId: String, monthlyRate: Double)\ncase class OffsetReturns(orig: Returns, offset: Int) extends Returns\n\nobject Returns {\n  def monthlyRate(returns: Returns, month: Int): Double = returns match {\n    case FixedReturns(r) => r / 12\n    case VariableReturns(rs) => rs(month % rs.length).monthlyRate\n    case OffsetReturns(rs, offset) => monthlyRate(rs, month + offset)\n  }\n}\n```", "```java\npackage retcalc\n\nimport org.scalatest.{Matchers, WordSpec}\n\nclass EquityDataSpec extends WordSpec with Matchers {\n  \"EquityData.fromResource\" should {\n    \"load market data from a tsv file\" in {\n      val data = EquityData.fromResource(\"sp500_2017.tsv\")\n      data should ===(Vector(\n        EquityData(\"2016.09\", 2157.69, 45.03),\n        EquityData(\"2016.10\", 2143.02, 45.25),\n        EquityData(\"2016.11\", 2164.99, 45.48),\n        EquityData(\"2016.12\", 2246.63, 45.7),\n        EquityData(\"2017.01\", 2275.12, 45.93),\n        EquityData(\"2017.02\", 2329.91, 46.15),\n        EquityData(\"2017.03\", 2366.82, 46.38),\n        EquityData(\"2017.04\", 2359.31, 46.66),\n        EquityData(\"2017.05\", 2395.35, 46.94),\n        EquityData(\"2017.06\", 2433.99, 47.22),\n        EquityData(\"2017.07\", 2454.10, 47.54),\n        EquityData(\"2017.08\", 2456.22, 47.85),\n        EquityData(\"2017.09\", 2492.84, 48.17)\n      ))\n    }\n  }\n\n  \"EquityData.monthlyDividend\" should {\n    \"return a monthly dividend\" in {\n      EquityData(\"2016.09\", 2157.69, 45.03).monthlyDividend should === \n      (45.03 / 12)\n    }\n  }\n}\n```", "```java\nmonth   SP500  dividend\n2016.09    2157.69    45.03\n2016.10    2143.02    45.25\n2016.11    2164.99    45.48\n```", "```java\npackage retcalc\n\nimport scala.io.Source\n\ncase class EquityData(monthId: String, value: Double, annualDividend: Double) {\n  val monthlyDividend: Double = annualDividend / 12\n}\n\nobject EquityData {\n  def fromResource(resource: String): Vector[EquityData] =\n    Source.fromResource(resource).getLines().drop(1).map { line =>\n      val fields = line.split(\"\\t\")\n      EquityData(\n        monthId = fields(0), \n        value = fields(1).toDouble, \n        annualDividend = fields(2).toDouble)\n    }.toVector\n}\n```", "```java\nscala> val iterator = (1 to 3).iterator\niterator: Iterator[Int] = non-empty iterator\n\nscala> iterator foreach println\n1\n2\n3\n\nscala> iterator foreach println\n\nscala> \n```", "```java\npackage retcalc\n\nimport org.scalatest.{Matchers, WordSpec}\n\nclass InflationDataSpec extends WordSpec with Matchers {\n  \"InflationData.fromResource\" should {\n    \"load CPI data from a tsv file\" in {\n      val data = InflationData.fromResource(\"cpi_2017.tsv\")\n      data should ===(Vector(\n        InflationData(\"2016.09\", 241.428),\n        InflationData(\"2016.10\", 241.729),\n        InflationData(\"2016.11\", 241.353),\n        InflationData(\"2016.12\", 241.432),\n        InflationData(\"2017.01\", 242.839),\n        InflationData(\"2017.02\", 243.603),\n        InflationData(\"2017.03\", 243.801),\n        InflationData(\"2017.04\", 244.524),\n        InflationData(\"2017.05\", 244.733),\n        InflationData(\"2017.06\", 244.955),\n        InflationData(\"2017.07\", 244.786),\n        InflationData(\"2017.08\", 245.519),\n        InflationData(\"2017.09\", 246.819)\n      ))\n    }\n  }\n}\n```", "```java\npackage retcalc\n\nimport scala.io.Source\n\ncase class InflationData(monthId: String, value: Double)\n\nobject InflationData {\n  def fromResource(resource: String): Vector[InflationData] =\n    Source.fromResource(resource).getLines().drop(1).map { line =>\n      val fields = line.split(\"\\t\")\n      InflationData(monthId = fields(0), value = fields(1).toDouble)\n    }.toVector\n}\n```", "```java\n\"Returns.fromEquityAndInflationData\" should {\n  \"compute real total returns from equity and inflation data\" in {\n    val equities = Vector(\n      EquityData(\"2117.01\", 100.0, 10.0),\n      EquityData(\"2117.02\", 101.0, 12.0),\n      EquityData(\"2117.03\", 102.0, 12.0))\n\n    val inflations = Vector(\n      InflationData(\"2117.01\", 100.0),\n      InflationData(\"2117.02\", 102.0),\n      InflationData(\"2117.03\", 102.0))\n\n    val returns = Returns.fromEquityAndInflationData(equities, \n    inflations)\n    returns should ===(VariableReturns(Vector(\n      VariableReturn(\"2117.02\", (101.0 + 12.0 / 12) / 100.0 - 102.0 / \n      100.0),\n      VariableReturn(\"2117.03\", (102.0 + 12.0 / 12) / 101.0 - 102.0 / \n      102.0))))\n  }\n}\n```", "```java\nobject Returns {\n  def fromEquityAndInflationData(equities: Vector[EquityData],\n    inflations: Vector[InflationData]):\n      VariableReturns = {\n        VariableReturns(equities.zip(inflations).sliding(2).collect {\n          case (prevEquity, prevInflation) +: (equity, inflation) +:\n            Vector() =>\n            val inflationRate = inflation.value / prevInflation.value\n            val totalReturn =\n            (equity.value + equity.monthlyDividend) / prevEquity.value\n            val realTotalReturn = totalReturn - inflationRate\n\n            VariableReturn(equity.monthId, realTotalReturn)\n          }.toVector)\n}\n```", "```java\nscala> Vector(1,2).zip(Vector(\"a\", \"b\", \"c\"))\nres0: scala.collection.immutable.Vector[(Int, String)] = Vector((1,a), (2,b))\n```", "```java\nscala> val it = Vector(1, 2, 3, 4).sliding(2)\nit: Iterator[scala.collection.immutable.Vector[Int]] = non-empty iterator\n\nscala> it.toVector\nres0: Vector[scala.collection.immutable.Vector[Int]] = \nVector(Vector(1, 2), Vector(2, 3), Vector(3, 4))\n\nscala> Vector(1).sliding(2).toVector\nres12: Vector[scala.collection.immutable.Vector[Int]] = Vector(Vector(1))\n```", "```java\nscala> val v = Vector(1, 2, 3)\nv: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)\n\nscala> v.filter(i => i != 2).map(_ + 1)\nres15: scala.collection.immutable.Vector[Int] = Vector(2, 4)\n\nscala> v.collect { case i if i != 2 => i + 1 }\nres16: scala.collection.immutable.Vector[Int] = Vector(2, 4)\n```", "```java\ncase (prevEquity, prevInflation) +: (equity, inflation) +: Vector() =>\n```", "```java\npackage retcalc\n\nimport org.scalactic.TypeCheckedTripleEquals\nimport org.scalatest.{Matchers, WordSpec}\n\nclass SimulatePlanAppIT extends WordSpec with Matchers with TypeCheckedTripleEquals {\n  \"SimulatePlanApp.strMain\" should {\n    \"simulate a retirement plan using market returns\" in {\n      val actualResult = SimulatePlanApp.strMain(\n        Array(\"1997.09,2017.09\", \"25\", \"40\", \"3000\", \"2000\", \"10000\"))\n\n      val expectedResult =\n        s\"\"\"\n          |Capital after 25 years of savings:    499923\n          |Capital after 40 years in retirement: 586435\n        \"\"\".stripMargin\n      actualResult should === (expectedResult)\n    }\n  }\n}\n```", "```java\npackage retcalc\n\nobject SimulatePlanApp extends App {\n  println(strMain(args))\n\n  def strMain(args: Array[String]): String = {\n    val (from +: until +: Nil) = args(0).split(\",\").toList\n    val nbOfYearsSaving = args(1).toInt\n    val nbOfYearsInRetirement = args(2).toInt\n\n    val allReturns = Returns.fromEquityAndInflationData(\n      equities = EquityData.fromResource(\"sp500.tsv\"),\n      inflations = InflationData.fromResource(\"cpi.tsv\"))\n    val (capitalAtRetirement, capitalAfterDeath) = \n    RetCalc.simulatePlan(\n      returns = allReturns.fromUntil(from, until),\n      params = RetCalcParams(\n        nbOfMonthsInRetirement = nbOfYearsInRetirement * 12,\n        netIncome = args(3).toInt,\n        currentExpenses = args(4).toInt,\n        initialCapital = args(5).toInt),\n      nbOfMonthsSavings = nbOfYearsSaving * 12)\n\n    s\"\"\"\n       |Capital after $nbOfYearsSaving years of savings:    \n    ${capitalAtRetirement.round}\n       |Capital after $nbOfYearsInRetirement years in retirement: \n    ${capitalAfterDeath.round}\n        \"\"\".stripMargin\n  }\n}\n```", "```java\n1997.09,2017.09 25 40 3000 2000 10000\n```", "```java\naddSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.14.6\")\n```", "```java\nname := \"retirement_calculator\"\n\nversion := \"0.1\"\n\nscalaVersion := \"2.12.4\"\n\nlibraryDependencies += \"org.scalatest\" %% \"scalatest\" % \"3.0.4\" % \"test\"\n\nmainClass in Compile := Some(\"retcalc.SimulatePlanApp\")\n```", "```java\n[info] Checking every *.class/*.jar file's SHA-1.\n[info] Merging files...\n[warn] Merging 'META-INF/MANIFEST.MF' with strategy 'discard'\n[warn] Strategy 'discard' was applied to a file\n[info] SHA-1: 7b7710bf370159c549a11754bf66302a76c209b2\n[info] Packaging /home/mikael/projects/scala_fundamentals/retirement_calculator/target/scala-2.12/retirement_calculator-assembly-0.1.jar ...\n[info] Done packaging.\n[success] Total time: 11 s, completed 14-Jan-2018 12:23:39\n```", "```java\n$ java -jar <path to your .jar file> 1997.09,2017.09 25 40 3000 2000 10000\n\nCapital after 25 years of savings: 499923\nCapital after 40 years in retirement: 586435\n```", "```java\n$ java -jar <path to your .jar file> 2000.01,2010.01 25 40 3000 2000 10000\n\nCapital after 25 years of savings:    225209\nCapital after 40 years in retirement: -510074\n\n$ java -jar <path to your .jar file> 1950.01,1960.01 25 40 3000 2000 10000\n\nCapital after 25 years of savings:    4505196\nCapital after 40 years in retirement: 2077953853\n```"]