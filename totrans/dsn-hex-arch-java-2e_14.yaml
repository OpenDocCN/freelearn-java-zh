- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Dockerfile and Kubernetes Objects for Cloud Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We spent the previous chapters exploring some of the amazing features that Quarkus
    provides to help us create cloud-native applications. Going even further, we also
    learned how to integrate Quarkus into a hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to prepare the hexagonal system so that it can be deployed in cloud
    environments. Docker and Kubernetes are the leading technologies that dominate
    the cloud scene nowadays. If your application is prepared to run on these technologies,
    you’re safe to make it run on most cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we’ll learn how to wrap the hexagonal system in a Docker
    image and run it on a Kubernetes cluster. For Docker images, we’ll explore two
    techniques for creating such images: one that relies on an executable `.jar` and
    another that uses a native executable. We’ll also learn how to deploy the hexagonal
    system in a local **minikube**-based Kubernetes cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Kubernetes objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying on minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll know how to make the hexagonal system run
    in a cloud-native environment based on Docker and Kubernetes. Nowadays, most modern
    applications run on the cloud. By turning the hexagonal system into a cloud-native
    one, you’ll be able to tap into the advantages that exist when you’re on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are available for the Linux, macOS, and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need **Docker** and **minikube** installed on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container-based virtualization technology is not something new. Long before
    Docker, there were technologies such as OpenVZ, which applied the same fundamental
    concepts that are applied by Docker as well. Even today, we have alternatives
    such as **Linux Containers** (**LXC**), which provides a robust container-based
    solution. What sets Docker apart is how easy and intuitive it makes handling containerized
    applications. Docker takes portability to another level, simplifying and making
    containers a viable technology for larger audiences.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, other container platforms were not as straightforward to use as
    Docker is today. Containers were a topic more related to system administrators
    than to software developers. Today, the scenario is different because of the simple
    yet powerful container-based solution we have with Docker. Because of its simplicity,
    Docker rapidly became popular among developers, who started to incorporate it
    into their projects.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, Docker’s strength is in its simplicity to use and
    learn. Take, for example, how Docker abstracts the complexity required to wrap
    an application inside a container. You just need to define a Dockerfile describing
    how the application should be configured and executed inside the container. You
    can do this by using a simple set of instructions. So, Docker shields the user
    from low-level complexities that existed in previous container technologies.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that makes Quarkus so special is that it’s a container-first
    framework. It’s designed to build container-based applications. So, Quarkus is
    an excellent choice if you’re targeting container-based environments.
  prefs: []
  type: TYPE_NORMAL
- en: With Quarkus, we can generate Docker images using `.jar` artifacts or native
    executable artifacts. We’ll explore both of these approaches next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Docker image with an uber .jar artifact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our approach here is to wrap the uber `.jar` artifact in the Docker image so
    that the container can start and run the application by executing that `.jar`
    file. To build a Docker image, we need to create a Dockerfile with instructions
    to build such an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to create a Dockerfile for the topology and inventory
    system that uses the uber `.``jar` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile should be placed in the project’s root directory.
  prefs: []
  type: TYPE_NORMAL
- en: The first line is the base `APP_FILE_RUNNER` and `APP_HOME` environment variables
    to define the artifact’s name and path, respectively. Because Quarkus is configured
    to run on port `8080`, we have to use the `EXPOSE` property to expose this port
    externally. The `COPY` command will copy the artifact generated by Maven. `WORKDIR`
    defines the path that the commands will be executed from within the container.
    With `ENTRYPOINT` and `CMD`, we can define how the container will execute the
    application’s uber `.``jar` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to generate the Docker image and start the container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to compile and generate an uber `.``jar` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can generate the Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can start the container with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To confirm that the application is running on the Docker container, we can access
    the Swagger UI URL at `http://localhost:5555/q/swagger-ui`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s learn how to generate a Docker image using the native executable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Docker image with a native executable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B19777_10.xhtml#_idTextAnchor213), *Adding Quarkus to a Modularized
    Hexagonal Application*, we learned that Quarkus uses **Ahead-Of-Time** (**AOT**)
    compilation techniques to optimize the bytecode and generate native code that
    offers improved performance, mainly during application startup.
  prefs: []
  type: TYPE_NORMAL
- en: This native executable is a product of the AOT compilation that’s performed
    by Quarkus. Contrary to the uber `.jar` file, which can be distributed to run
    on different operating systems and CPU architectures, the native executable file
    is platform-dependent. But we can overcome this limitation by wrapping the native
    executable into a Docker image that can be distributed to different operating
    systems and CPU architectures.
  prefs: []
  type: TYPE_NORMAL
- en: There are different approaches to generating a native executable. Some of them
    require us to install a **GraalVM** distribution and other software. However,
    to keep things simple, we’ll follow an uncomplicated and convenient approach where
    Quarkus generates the native executable for us inside a Docker container that
    contains GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to generate a Docker image with a native executable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `pom.xml` file from the project’s root directory, we need to include
    the following code before the `</``project>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding configuration creates a profile that sets the `quarkus.package.type`
    property to `native`, causing Quarkus to build a native executable artifact.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we must create the `ReflectionConfiguration` class on the `bootstrap`
    hexagon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One of the limitations of the native executable is that it offers partial support
    for reflection. `.json` configuration file, or we can create a class annotated
    with the `@RegisterForReflection` annotation containing the classes we want to
    register for reflection. In the preceding code, we are using the latter approach,
    which relies on the annotated class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To generate a native executable, we have to run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must create a file called `Dockerfile-native` that contains instructions
    for building a Docker image with the native executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of the JDK 17 base image, we’re using the `ubi-minimal` image from the
    official **Red Hat** registry. This image is suitable for running native executables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we must generate the Docker image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tag and upload your image to your personal Docker registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll use the system’s native image when deploying the application on a minikube
    cluster.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can start the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have configured the Docker images for both the uber `.jar` and
    native executable artifacts. These Docker images can be deployed on a Kubernetes
    cluster. However, to do that, we need to create the required Kubernetes objects
    to allow the deployment. So, in the next section, we’ll learn how to create Kubernetes
    objects for the containerized hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Kubernetes objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Engine does not provide any fault-tolerance or high availability mechanism.
    It only offers container-based virtualization technology. So, if you plan on running
    a critical-mission application using Docker, you may either need to work out your
    solution to ensure the containers are reliable while running or delegate this
    responsibility to a container orchestrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Container orchestrators arose as a response to the increased use of containers
    in the IT industry. Among these orchestrators, we can quote Docker Swarm, Rancher,
    and the one that dominates the industry: **Kubernetes**.'
  prefs: []
  type: TYPE_NORMAL
- en: Initially conceived at Google as a closed source software called Borg, it was
    open-sourced with the name Kubernetes. It’s a powerful technology that can run
    on your computer for development purposes or control a fleet of hundreds, even
    thousands, of server nodes, providing Pods for the running applications.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering, *what is a Pod?* We’ll find out soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not our intent here to dive deep into Kubernetes' internals, but we’ll
    review some basic concepts to ensure we’re on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing Kubernetes' main objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw earlier, Kubernetes is a container orchestrator that helps us manage
    containers. To accomplish this, most – if not all – Kubernetes configuration can
    be done through `.yaml` files. In Kubernetes, we have the notion of the current
    state and the desired state. When the former meets the latter, we’re fine. Otherwise,
    we have problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backbone of this currently desired state approach is the Kubernetes configuration
    mechanism based on YAML files. With these files, we can express the desired state
    of things inside the cluster. Kubernetes will do its magic to ensure that the
    current state always matches the desired state. But, you may be wondering, *the
    state of what?* The answer is the state of Kubernetes objects. Let’s look at some
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pod**: A Pod is a Kubernetes object that controls the life cycle of containers
    in a Kubernetes cluster. It’s possible to attach more than one container to the
    same Pod, although this is not a common practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Deployment` object controls the life cycle of Pods. With a Deployment, you
    can specify how many Pods you want to provide for your application. Kubernetes
    will take care of finding the available resources in the cluster to bring up these
    Pods. If, for some reason, one of the Pods goes down, Kubernetes will try to bring
    a brand-new Pod to ensure the desired state is being met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service` object attached to that Pod. This `Service` object acts as a DNS
    entry point that provides basic load balancing access to the Pods. For example,
    if you have an application running on three Pods, the `Service` object will handle
    application requests for one of the three Pods sitting behind the `Service` object.
    More sophisticated load balancing features can be achieved by using service mesh
    technologies such as **Istio**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigMap` is the object that can help you with that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigMap` but can be used to store sensitive information such as credentials
    or private keys. The data in a `Secret` object should be encoded with `base64`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’re more acquainted with some of the most important Kubernetes objects,
    let’s see how we can use them to prepare our hexagonal system to be deployed on
    a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Kubernetes objects for the hexagonal system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before creating the Kubernetes objects, first, let’s configure Quarkus to enable
    YAML configuration and also a health check mechanism. We’ll need both of these
    when we’re deploying the application on Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With `quarkus-config-yaml`, we can use the `application.yaml` file for most
    of the Quarkus configurations. And to enable health checks endpoints, we can use
    `quarkus-smallrye-health`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the Kubernetes objects, let’s configure the `application.yaml`
    file on the `bootstrap` hexagon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This `.yaml` file allows us to use most, but not all, of the configurations
    available on Quarkus. So, it’s normal to use both `application.yaml` and `application.properties`.
    We’re using the YAML configuration because we can employ a technique called **variable
    interpolation**. Take, for example, the following configuration entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the application starts, it will try to resolve an environment variable
    named `QUARKUS_DATASOURCE_USERNAME`. If the application can’t resolve the variable
    name, it will fall back to the default value of `root`. This technique is very
    useful for defining default configurations for local development where environment
    variables may not be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed the presence of the `QUARKUS_DATASOURCE_USERNAME`, `QUARKUS_DATASOURCE_PASSWORD`,
    and `QUARKUS_DATASOURCE_REACTIVE_URL` environment variables. Kubernetes will provide
    these environment variables with the `Secret` and `ConfigMap` objects. So, let’s
    learn how to configure these and the other Kubernetes objects that are required
    to deploy the topology and inventory system (the files we will describe here are
    put inside a directory called `k8s` in the project’s root directory):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by configuring the `configmap.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `ConfigMap` provides a `QUARKUS_DATASOURCE_REACTIVE_URL` environment variable
    with the reactive database URL that the application needs to connect to the MySQL
    database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we must configure the `secret.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding `Secret`, we define the `QUARKUS_DATASOURCE_USERNAME` and `QUARKUS_DATASOUCE_PASSWORD`
    environment variables as the credentials to connect to the system’s MySQL database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To generate `base64`, you can execute the following command on Unix-based systems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s configure the `deployment.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we describe some of the metadata entries from the `deployment.yaml` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `metadata.labels.app` field: A Kubernetes `Service` object can apply load
    balancing by using the `labels` property to identify the Pods that are part of
    the same `Deployment`. We’ll see how the `Service` object references that label
    shortly.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `replicas` field: This defines that this `Deployment` will provide just
    one Pod.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Still in the `deployment.yaml` file, we can start defining the entries for
    the container configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at the entries that are used for the container configuration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `initContainers` field: This is used when we need to execute some tasks
    or wait for something before the main container starts. Here, we’re using an `init`
    container to wait for a MySQL database to be available. The `.yaml` file that
    loads the database is available in this book’s GitHub repository for this chapter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Containers` field: This is where we set the configuration for the container
    that the Pod runs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `image` field: This is where we inform the image location of our application.
    It can be a public or private registry.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `configMapRef` field: This is used to inject `ConfigMap` data into the
    container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `livenessProbe` field: Kubernetes can send probe packets to check whether
    the application is alive. This is where we’ll use the health check mechanism we
    configured earlier.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `containerPort` field: This is where we’ll inform the port about the exposed
    Docker container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we will configure the `service.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Kubernetes provides three different Service types: `ClusterIP` for internal
    communication, and `NodePort` and `LoadBalance` for external communication. We’re
    using `NodePort` to access the application from outside the Kubernetes cluster.
    Let’s take a look at the most important fields:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `port` field: This field declares the Service port that is available internally
    for other Pods in the Kubernetes cluster'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `targetPort` field: This field specifies the port that the container is
    exposing'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `nodePort` field: This field specifies the external port, which allows
    external clients to access the application'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not a trivial undertaking to prepare an application to be deployed on a
    Kubernetes cluster. In this section, we learned about the main objects of Kubernetes.
    Understanding these objects is essential because they are the building blocks
    for any application running on a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: With all the required Kubernetes objects adequately configured, we can deploy
    the hexagonal system in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**minikube** is a Kubernetes cluster that was made for development purposes.
    It allows us to create and destroy clusters with ease. Because of its simplicity,
    we’ll use minikube to deploy our hexagonal system by following these steps (I
    recommend following the instructions at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    to install minikube on your machine):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed minikube, you can start your cluster by issuing the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The default cluster configuration consumes 2 CPUs, 2 GB of RAM, and 20 GB of
    disk space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To confirm that your cluster is alive, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Nice!* Now, we can deploy the topology and inventory system to our local Kubernetes
    cluster.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Deployment process is fairly simple. All we have to do is apply the Kubernetes
    YAML files we created in the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can run the following command to see whether the topology and inventory
    system is up and running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To access the application, we need to use the minikube cluster IP. You can
    use the following code to retrieve that IP on a Unix-based operating system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that IP, we can query the health check endpoint to see whether the topology
    and inventory system is alive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 14.1 – Swagger UI from topology and inventory running on minikube](img/B19777_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Swagger UI from topology and inventory running on minikube
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using port `30080` to access the Swagger UI URL on minikube.
    `30080` is the Kubernetes node port that we configured to enable external access
    to the application.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have completed the fundamental steps to turn the hexagonal system
    into a cloud-native one. Our application is ready to be deployed on a local minikube
    cluster and any cloud provider that offers Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by learning about the building blocks that we can use
    to create a Docker image for the hexagonal system. Then, we created two Docker
    image types. The first one was based on the uber `.jar` file, which is used to
    package and run the application, while the second one was based on native executables,
    where we could leverage the features Quarkus provides to create a native executable
    artifact.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we created the Kubernetes objects that were required to deploy the hexagonal
    system in a Kubernetes cluster. Finally, we deployed the hexagonal system in a
    local minikube cluster. More than a hexagonal system, we now have a cloud-native
    hexagonal system ready to tap into the advantages provided by cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how hexagonal architecture relates to layered
    architecture, an architectural style used by many applications. Understanding
    the differences between these two architectures helps us assess which architecture
    may be better to employ when starting or refactoring a software project.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the advantage of the native executable over the uber `.``jar` artifact?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Kubernetes object can we use to store environment variables and mount
    configuration files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Service type is used to make a Kubernetes Pod externally available?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The startup time is much faster than the traditional uber `.``jar` artifact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `ConfigMap` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `NodePort` Service type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 4: Hexagonal Architecture and Beyond'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will learn in this part what distinguishes hexagonal architecture from the
    widely used layered architecture. We will highlight the differences between both
    and allow you to make a more informed decision regarding which architecture to
    use when starting your next software project.
  prefs: []
  type: TYPE_NORMAL
- en: We will then explore how SOLID principles can be combined with hexagonal architecture
    ideas to build better, change-tolerant applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to finish the book, we'll discuss some good design practices you can
    follow to create robust hexagonal systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19777_15.xhtml#_idTextAnchor305), *Comparing Hexagonal Architecture
    with Layered Architecture*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19777_16.xhtml#_idTextAnchor324), *Using SOLID Principles with
    Hexagonal Architecture*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B19777_17.xhtml#_idTextAnchor348), *Good Design Practices for
    Your Hexagonal Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
