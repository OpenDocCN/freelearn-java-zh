- en: '*Chapter 7*: Implementing Queries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best view comes after the hardest climb.
  prefs: []
  type: TYPE_NORMAL
- en: – Anonymous
  prefs: []
  type: TYPE_NORMAL
- en: In the section *Command Query Responsibility Segregation (CQRS)* from [*Chapter
    3*](B16716_03_Final_NM_ePub.xhtml#_idTextAnchor054), *Understanding the Domain,*
    we described how DDD and CQRS complement each other and how the query side (read
    models) can be used to create one or more representations of the underlying data.
    In this chapter, we will dive deeper into how we can construct read-optimized
    representations of the data by listening to domain events. We will also look at
    persistence options for these read models.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with query models, we construct models by listening to events
    as they happen. We will examine how to deal with the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: New requirements evolving over a period of time, requiring us to build new query
    models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discover a bug in our query model that requires us to recreate the model
    from scratch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do that, the agenda of the chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing our design journey
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the query side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Historic event replays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will learn to appreciate how to build query
    models by listening to domain events. You will also learn how to purpose-build
    new query models to suit specific read requirements as opposed to being restricted
    by the data model that was chosen to service commands. You will finally look at
    how historic event replays work and how you can use them to create new query models
    to service new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the examples in this chapter, you will need access to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 1.8+ (we have used Java 17 to compile sample sources)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.4.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axon Framework 4.5.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5.7.x (included with Spring Boot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJFX Monocle (for headless UI testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Lombok (to reduce verbosity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the `Chapter07` directory of the book’s accompanying source
    code repository at [https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter07)
    for complete working examples.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing our design journey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B16716_04_Final_NM_ePub.xhtml#_idTextAnchor065), *Domain Analysis
    and Modeling*, we discussed eventstorming as a lightweight method to clarify business
    flows. As a reminder, this is the output produced from our eventstorming session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Recap of the eventstorming session'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_7.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Recap of the eventstorming session
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, we are making use of the CQRS architecture pattern
    to create the solution. For a detailed explanation on why this is a sound method
    to employ, you can revisit the *When to use CQRS* section in [*Chapter 3*](B16716_03_Final_NM_ePub.xhtml#_idTextAnchor054),
    *Understanding the Domain,* where we’ve already covered this. In the preceding
    diagram, the green stickies represent read/query models. These query models are
    required when validating a command (for example, a list of valid product identifiers
    when processing the `ValidateProduct` command) or if the information is simply
    required to be presented to the user (for example, a list of LCs created by an
    applicant). Let’s look at what it means to apply CQRS in practical terms for the
    query side.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the query side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing
    Domain Logic*, we examined how to publish events when a command is successfully
    processed. Now, let’s look at how we can construct a query model by listening
    to these domain events. Logically, this will look something like the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The CQRS application – the query side'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_7.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The CQRS application – the query side
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed explanation of how the command side is implemented, please refer
    to the *Implementing the command side* section in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level sequence on the query side is described here:'
  prefs: []
  type: TYPE_NORMAL
- en: An event listening component listens to these domain events published on the
    event bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It constructs a purpose-built query model to satisfy a specific query use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This query model is persisted in a datastore optimized for read operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This query model is then exposed in the form of an API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note how there can exist more than one query side component for handling respective
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement each of these steps to see how this works for our LC issuance
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling choices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a CQRS application, there is a separation between the command and query sides.
    At this time, this separation is logical in our application because both the command
    and query sides are running as components within the same application process.
    To illustrate the concepts, we will use conveniences provided by Axon Framework
    to implement the query side in this chapter. In [*Chapter 10*](B16716_10_Final_NM_ePub.xhtml#_idTextAnchor150),
    *Beginning the Decomposition Journey*, we will look at how it may not be necessary
    to use a specialized framework (such as Axon) to implement the query side.
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing the query side, we have two concerns to address, as depicted
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The query side dissected'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_7.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – The query side dissected
  prefs: []
  type: TYPE_NORMAL
- en: 'These concerns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Consuming domain events and persisting one or more query models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing the query model as an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start implementing these concerns, let’s identify the queries we need
    to implement for our LC issuance application.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the eventstorming session, we have the following queries to start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Identified queries'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_7.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Identified queries
  prefs: []
  type: TYPE_NORMAL
- en: 'The queries marked in green (in the output from the eventstorming session from
    *Figure 7.1*) all require us to expose a collection of LCs in various states.
    To represent this, we can create an `LCView` class, an extremely simple object
    devoid of any logic, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch7-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These query models are an absolute necessity to implement basic functionality
    dictated by business requirements. But it is possible and very likely that we
    will need additional query models as the system requirements evolve. We will enhance
    our application to support these queries as and when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the query model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As seen in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing
    Domain Logic*, when starting a new LC application, the importer sends `StartNewLCApplicationCommand`,
    which results in `LCApplicationStartedEvent` being emitted, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch7-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s write an event-processing component that will listen to this event and
    construct a query model. When working with Axon Framework, we have a convenient
    way to do this by annotating the event-listening method with the `@EventHandler`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make any method an event listener, we annotate it with the `@EventHandler`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch7-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To make any method an event listener, we annotate it with the `@EventHandler`
    annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The handler method needs to specify the event that we intend to listen to. There
    are other arguments that are supported by event handlers. Please refer to the
    Axon Framework documentation for more information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We finally save the query model in an appropriate query store. When persisting
    this data, we should consider storing it in a form that is optimized for data
    access. In other words, we want to reduce as much complexity and cognitive load
    when querying this data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@EventHandler` annotation should not be confused with the `@EventSourcingHandler`
    annotation that we looked at in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*. The `@EventSourcingHandler` annotation is used to
    replay events and restore aggregate state when loading event-sourced aggregates
    on the command side, whereas the `@EventHandler` annotation is used to listen
    to events outside the context of the aggregate. In other words, the `@EventSourcingHandler`
    annotation is used exclusively within aggregates, whereas the `@EventHandler`
    annotation can be used anywhere there is a need to consume domain events. In this
    case, we are using it to construct a query model.
  prefs: []
  type: TYPE_NORMAL
- en: Query-side persistence choices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Segregating the query side this way enables us to choose the persistence technology
    most appropriate for the problem being solved on the query side. For example,
    if extreme performance and simple filtering criteria are important, it may be
    prudent to choose an in-memory store such as Redis or Memcached. If complex search/analytics
    requirements and large datasets are to be supported, then we may want to consider
    something like Elasticsearch. Or we may even simply choose to stick with just
    a relational database. The point we would like to emphasize is that employing
    CQRS affords a level of flexibility that was previously not available to us.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing a query API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Applicants like to view the LCs they created, specifically those in the draft
    state. Let’s look at how we can implement this functionality. Let’s start by defining
    a simple object to capture the query criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch7-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s implement the query using Spring’s repository pattern to retrieve the
    results for these criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch7-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the dynamic Spring data finder method we will use to query the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@QueryHandler` annotation provided by Axon Framework routes query requests
    to the respective handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we invoke the finder method to return results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding example, we have implemented the `QueryHandler` method within
    the repository itself for brevity. `QueryHandler` can be placed elsewhere as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect this to the UI, we add a new method in `BackendService` (originally
    introduced in [*Chapter 6*](B16716_06_Final_NM_ePub.xhtml#_idTextAnchor097), *Implementing
    the User Interface - Task-Based*) to invoke the query, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch7-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Axon Framework provides the `QueryGateway` convenience that allows us to invoke
    the query. For more details on how to use `QueryGateway`, please refer to the
    Axon Framework documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We execute the query using the `MyDraftLCsQuery` object to return results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we looked at previously is an example of a very simple query implementation
    where we have a single `@QueryHandler` annotation to service the query results.
    This implementation returns results as a one-time fetch. Let’s look at more complex
    query scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced query scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our focus currently is on active LC applications. Maintaining issued LCs happens
    in a different bounded context of the system. Consider a scenario where we need
    to provide a consolidated view of currently active LC applications and issued
    LCs. In such a scenario, it is necessary to obtain this information by querying
    two distinct sources (ideally in parallel) – commonly referred to as the *scatter-gather*
    pattern. Please refer to the section on scatter-gather queries in the Axon Framework
    documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, we may want to remain up to date on dynamically changing data.
    For example, consider a real-time stock-ticker application tracking price changes.
    One way to implement this is by polling for price changes. A more efficient way
    to do this is to push price changes as and when they occur – commonly referred
    to as the *publish-subscribe* pattern. Please refer to the section on subscription
    queries in the Axon Framework documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Historic event replays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example we have looked at thus far allows us to listen to events as they
    occur. Consider a scenario where we need to build a new query from historic events
    to satisfy an unanticipated new requirement. This new requirement may necessitate
    the need to create a new query model or, in a more extreme case, a completely
    new bounded context. Another scenario might be when we may need to correct a bug
    in the way we had built an existing query model and now need to recreate it from
    scratch. Given that we have a record of all events that have transpired in the
    event store, we can use replay events to enable us to construct both new and/or
    correct existing query models with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We have used the term *event replay* in the context of reconstituting the state
    of event-sourced aggregate instances (discussed in the *Event-sourced aggregates*
    section in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing
    Domain Logic*). The event replay mentioned here, although similar in concept,
    is still very different. In the case of a domain object event replay, we work
    with a single aggregate root instance and only load events for that one instance.
    In this case, though, we will likely work with events that span more than one
    aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the different types of replays and how we can use each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Types of replays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When replaying events, there are at least two types of replays, depending on
    the requirements we need to meet. Let’s look at each type in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full event replay**: This is where we replay all the events in the event
    store. This can be used in a scenario where we need to support a completely new
    bounded context that is dependent on this subdomain. This can also be used in
    cases where we need to support a completely new query model or reconstruct an
    existing, erroneously built query model. Depending on the number of events in
    the event store, this can be a fairly long and complex process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial/ad hoc event replay**: This is where we need to replay all the events
    on a subset of aggregate instances or a subset of events on all aggregate instances,
    or a combination of both. When working with partial event replays, we will need
    to specify filtering criteria to select subsets of aggregate instances and events.
    This means that the event store needs to have the flexibility to support these
    use cases. Using specialized event store solutions (such as Axon Server and EventStoreDB,
    to name a couple) can be extremely beneficial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event replay considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to replay events and create new query models can be invaluable.
    However, like everything else, there are considerations that we need to keep in
    mind when working with replays. Let’s examine some of these in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Event store design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*, when working with event-sourced aggregates, we persist
    immutable events in the persistence store. The primary use cases that we need
    to support are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide consistent and predictable **write** performance when acting as an append-only
    store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide consistent and predictable **read** performance when querying for events
    using the aggregate identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, replays (especially partial/ad hoc) require the event store to support
    much richer querying capabilities. Consider a scenario where we found an issue
    where the amount is incorrectly reported for LCs that were approved during a certain
    time period and only for a certain currency. To fix this issue, we need to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify affected LCs from the event store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the issue in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset the query store for these affected aggregates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do a replay of a subset of events for the affected aggregates and reconstruct
    the query model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identifying affected aggregates from the event store can be tricky if we don’t
    support querying capabilities that allow us to introspect the event payload. Even
    if this kind of ad hoc querying were to be supported, these queries can adversely
    impact the command-handling performance of the event store. One of the primary
    reasons to employ CQRS was to make use of query-side stores for such complex read
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event replays seem to introduce a chicken and egg problem where the query store
    has an issue that can only be corrected by querying the event store. A few options
    to mitigate this issue are discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**General purpose store**: Choose an event store that offers predictable performance
    for both scenarios (command handling and replay querying).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in datastore replication**: Make use of read replicas for event replay
    querying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distinct datastores**: Make use of two distinct datastores to solve each
    problem on its own (for example, use a relational database/key-value store for
    command handling and a search-optimized document store for event replay querying).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Do note that the distinct datastores approach for replays is used to satisfy
    an operational problem as opposed to query-side business use cases discussed earlier
    in this chapter. Arguably, it is more complex because the technology team on the
    command side has to be equipped to maintain more than one database technology.
  prefs: []
  type: TYPE_NORMAL
- en: Event design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Event replays are required to reconstitute the state from an event stream.
    In this article on what it means to be event-driven ([https://martinfowler.com/articles/201701-event-driven.html](https://martinfowler.com/articles/201701-event-driven.html)),
    Martin Fowler talks about three different styles of events. If we employ the event-carried
    state-transfer approach (in Martin’s article) to reconstitute state, it might
    require us to only replay the latest event for a given aggregate, as opposed to
    replaying all the events for that aggregate in order of occurrence. While this
    may seem convenient, it also has its downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: All events may now require carrying a lot of additional information that may
    not be relevant to that event. Assembling all this information when publishing
    the event can add to the cognitive complexity on the command side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of data that needs to be stored and flow through the wire can increase
    drastically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the query side, it can increase cognitive complexity when understanding the
    structure of the event and processing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a lot of ways, this leads back to the CRUD-based versus task-based approach
    for APIs discussed in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*. Our general preference is to design events with as
    lean a payload as possible. However, your experiences may be different, depending
    on your specific problem or situation.
  prefs: []
  type: TYPE_NORMAL
- en: Application availability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In an event-driven system, it is common to accumulate an extremely large number
    of events over a period of time, even in a relatively simple application. Replaying
    a large number of events can be time-consuming. Let’s look at the mechanics of
    how replays typically work:'
  prefs: []
  type: TYPE_NORMAL
- en: We suspend listening to new events in preparation for a replay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the query store for impacted aggregates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start an event replay for impacted aggregates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resume listening to new events after the replay is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the preceding list, while the replay is running (*step 3*), we may
    not be able to provide reliable answers to queries that are impacted by the replay.
    This obviously has an impact on application availability. When using event replays,
    care needs to be taken to ensure that **Service Level Objectives** (**SLOs**)
    continue to be met.
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers with side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When replaying events, we re-trigger event handlers either to fix logic that
    was previously erroneous or to support new functionality. Invoking most (if not
    all) event handlers usually results in some sort of side effect (for example,
    updating a query store). This means that some event handlers may not be running
    for the first time. To prevent unwanted side effects, it is important to undo
    the effects of having invoked these event handlers previously or code event handlers
    in an idempotent manner (for example, by using an `upsert` command instead of
    a simple `insert` command or an `update` command). The effect of some event handlers
    can be hard (if not impossible) to undo (for example, invoking a command, sending
    an email, or SMS). In such cases, it might be required to mark such event handlers
    as being ineligible to run during the replay. When using Axon Framework, this
    is fairly simple to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch7-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`@DisallowReplay` (or its counterpart `@AllowReplay`) can be used to explicitly
    mark event handlers ineligible to run during the replay.'
  prefs: []
  type: TYPE_NORMAL
- en: Events as an API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In an event-sourced system where events are persisted instead of domain state,
    it is natural for the structure of events to evolve over a period of time. Consider
    an example of `BeneficiaryInformationChangedEvent`, which has evolved over a period
    of time, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Event evolution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_7.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Event evolution
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that the event store is immutable, it is conceivable that we may have
    one or more combinations of these event versions for a given LC. This can present
    a number of decisions we will need to make when performing an event replay:'
  prefs: []
  type: TYPE_NORMAL
- en: The producer can simply provide the historic event as it exists in the event
    store and allow consumers to deal with older versions of the event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The producer can upgrade older versions of events to the latest version before
    exposing them to the consumer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the consumer to specify an explicit version of the event that they are
    able to work with and upgrade it to that version before exposing it to the consumer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrate the events in the event store to the latest version as evolutions occur.
    This may not be feasible, given the immutable promise of events in the event store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which approach you choose really depends on your specific context and the maturity
    of the producer/consumer ecosystem. Axon Framework makes provisions for a process
    they call event upcasting that allows events to be upgraded just in time before
    they are consumed. Please refer to the Axon Framework documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In an event-driven system, events are your API. This means that you will need
    to apply the same rigor that you apply to APIs when making life cycle management
    decisions (for example, versioning, deprecation, and backward compatibility).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined how to implement the query side of a CQRS-based
    system. We looked at how domain events can be consumed in real time to construct
    materialized views that can be used to service query APIs. We looked at the different
    query types that can be used to efficiently access the underlying query models.
    We rounded off by looking at persistence options for the query side.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at historic event replays and how they can be used to correct
    errors or introduce new functionality in an event-driven system.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter should give you a good idea of how to build and evolve the query
    side of a CQRS-based system to meet changing business requirements while retaining
    all the business logic on the command side.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to consume events in a stateless manner (where
    no two event handlers have knowledge of each other’s existence). In the next chapter,
    we will continue to look at how to consume events, but this time in a stateful
    manner, in the form of long-running user transactions (also known as sagas).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](img/B16716_07_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
