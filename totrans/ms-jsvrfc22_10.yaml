- en: Chapter 10. JSF Custom Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSF is a component-based framework, and JSF custom components are the major
    proof that sustain JSF flexibility and extensibility. In order to write custom
    components or extend the existing ones, JSF provides a powerful API that allows
    us to develop two types of components: **custom components,** and, from JSF 2.0
    onwards, **composite components**. A custom component implementation is responsible
    for providing an **aspect** (optional for non-UI components, such as custom validators,
    converters, and renderers) and a **behavior**. Usually the decision to write custom
    components and the skills for accomplishing it belong to advanced JSF developers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you decide to write a custom component, which can be a time-consuming
    task, you have to overview the following bullets (especially the first bullet):'
  prefs: []
  type: TYPE_NORMAL
- en: Check the Internet (for example, [http://jsfcentral.com/](http://jsfcentral.com/))
    to make sure the component doesn't exist yet. Many JSF extensions, such as PrimeFaces,
    ICEfaces, OmniFaces, and RichFaces, already come with hundreds of custom components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that you need a custom component and not just a Facelet template (see
    [Chapter 12](ch12.html "Chapter 12. Facelets Templating"), *Facelets Templating*)
    or some custom logic over the existing components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to redesign the application goals to use the existing components (sometimes
    you can combine several existing components to obtain the desired aspect and behavior).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a closer look at non-JSF components, such as jQueryUI, ComponentJS, and
    AmplifyJS (as you are not forced to solely use JSF components in your JSF applications!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application has some specific goals that just cannot be solved by any
    of the preceding bullets, it is time to start coding your own components.
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of this chapter, you will see how to write noncomposite custom
    components, and in the second part you will learn about composite components.
    The noncomposite components have been available for a long time in JSF, and the
    technique of writing such components is based on writing several Java classes.
    The new concept, which came along with composite components, is available from
    JSF 2 onwards, and the idea behind it is to replace the Java classes with XHTML
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: Building noncomposite custom components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump directly to the cool stuff and say that in JSF 2.0 a custom component
    was made available to page authors by configuring it in a Facelet tag library
    (`*taglib.xml`).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, when the component is mapped in a JAR, a special entry in `web.xml`
    is needed to point to the `*taglib.xml` file. See the application named `ch10_3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of JSF 2.2, we don''t need these files anymore. A JSF 2.2 simple custom
    component contains a single class, and it may look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the hard work is accomplished by the `@FacesComponent` annotation (`javax.faces.component.FacesComponent`).
    All we need to do is set the `createTag` element to `true`, and JSF should create
    the tag for us. Further, we can easily exploit our custom components, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the default namespace of the component is `http://xmlns.jcp.org/jsf/component`.
    This is true for all components that don't have an explicit namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch10_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire list of elements supported by JSF 2.2 `@FacesComponent` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createTag`: This can be set to `true` or `false`. When it is set to `true`,
    JSF will generate the tag for us (to be more specific, JSF will create, at runtime,
    a Facelet tag handler that extends `ComponentHandler`). This element can be used
    only in JSF 2.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tagName`: This allows us to indicate the tag name. When `createTag` is set
    to `true`, JSF will use this name for the generated tag. This element can only
    be used in JSF 2.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`namespace`: This allows us to indicate the tag namespace. When `createTag`
    is set to `true`, JSF will use this namespace for the generated tag. When namespace
    is not specified, JSF will use the `http://xmlns.jcp.org/jsf/component` namespace.
    This element can be used only in JSF 2.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This element comes from JSF 2.0 and indicates the **component type**.
    The component type can be used as the argument of the `Application.createComponent(java.lang.String)`
    method for creating instances of the `Component` class. As of JSF 2.2, if the
    `value` element is missing or is `null`, JSF will obtain it by calling the `getSimpleName`
    method on the class to which `@FacesComponent` is attached and lowercasing the
    first character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the component type, we understand a small chunk of data, specific to each
    `UIComponent` subclass, that can be used in conjunction with an `Application`
    instance to programmatically obtain new instances of those subclasses. Moreover,
    each `UIComponent` subclass belongs to a component family (for example `javax.faces.Input`).
    This is important when we write a custom component and declare it under a certain
    family, because we can exploit the renderer specific to that family of components.
    Next to the component family, we can use the **renderer type** property to select
    a `Renderer` instance from a `RenderKit` collection (for example, an input field
    belongs to the `javax.faces.Input` family and to the `javax.faces.Text` renderer
    type).
  prefs: []
  type: TYPE_NORMAL
- en: Each custom component must extend `UIComponent` or one of its subtypes, such
    as `UIComponentBase`, which is actually just a default implementation of all abstract
    methods of `UIComponent`. Anyway, there is one exception represented by the `getFamily`
    method that must be overridden even when you extend `UIComponentBase`. As a common
    practice, when a custom component needs to accept end user inputs, it will extend
    `UIInput`, and when it needs to act as a command, it will extend `UICommand`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, let''s modify our application as follows to indicate a custom namespace
    and tag name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the component will be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch10_2`. Moreover, the JSF 2.0 version of
    this application (containing the `*taglib.xml` descriptor and the specific entry
    in `web.xml`) is named `ch10_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom tag handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Notice that `*taglib.xml` is still needed in some cases. For example, if you
    decide to write a custom tag handler for your component, then you still need this
    file to configure the handler class. In this rare case, you will extend the `ComponentHandler`
    class and override the desired methods. Most developers exploit the `onComponentCreated`
    and `onComponentPopulated` methods. The first one is called after the component
    has been created but before it has been populated with children, and the second
    one is called after the component has been populated with children. As of JSF
    2.2, a new method was added for developers who wish to take over the task of instantiating
    the `UIComponent`. This method is named `createComponent`. If it returns `null`,
    then this method will be required to create the component by `TagHandlerDelegate`
    instead. Since this is a pretty rare case, we do not insist on it, and we just
    provide a simple stub of `ComponentHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to indicate that our class handler should be used, we need to configure
    it in the `*taglib.xml` file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named `ch10_24_1`. Another stub that can be used as
    a starting point can be found in `ch10_24_2`. The latter one defines the minimum
    implementation for a custom `ComponentHandler`, a custom `TagHandlerDelegateFactory`,
    and a custom `TagHandlerDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting a custom component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far you can see that our component class overrides the `encodeBegin` method.
    This method belongs to a set of four methods used for rendering a component where
    each component can render itself (the `setRendererType` method gets a `null` value
    for its argument) or delegate the rendering process to a `Renderer` class (built-in
    or user defined). These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`decode`: In order to parse the input values and save them into the component,
    each request passes through the `decode` method. Usually, when this method is
    overridden, the developer extracts the needed values from the request map (or
    from the `Map` attributes using the `UIComponent.getAttributes` method) and sets
    them into the component by calling the `setSubmittedValue(`*value*`)` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encodeBegin`: This method starts the rendering process of the custom component.
    It writes to the response stream obtained through the `FacesContext.getResponseWriter`
    method. This method is overridden when we need to encode child components, but
    we want to output a response to the user before that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ResponseWriter` object (`FacesContext.getResponseWriter`) contains special
    methods for generating a markup, such as `startElement`, `writeAttribute`, `writeText`,
    and `endElement`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`encodeChildren`: This method renders the custom component children. It is
    very rarely overridden; however, if you want to alter the default recursive process
    of encoding component children, then go ahead and override it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encodeEnd`: Probably this is the most overridden method. As its name suggests,
    this method is called at the end. Here, we write the custom markup to the response
    stream. When the custom component accepts end user inputs, the `encodeEnd` is
    preferred against `encodeBegin` because in the case of `encodeBegin`, the inputs
    may not be passed yet through a potential attached converter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The four methods we just discussed are available for all custom components and
    for all renderers. In both cases, they have the same name, and the difference
    between them consists of one argument. When they are overridden in a custom component
    class, they get a single argument representing `FacesContext`. On the other hand,
    when they are overridden in a custom renderer, they get as arguments the `FacesContext`
    instance and the corresponding custom component (`UIComponent`).
  prefs: []
  type: TYPE_NORMAL
- en: So we are at a point where we can conclude that a custom component is based
    on a subclass of `UIComponent` and it can render itself or delegate this task
    to a `Renderer` class, which is capable of rendering `UIComponent` instances and
    decoding the POST requests for obtaining user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect of custom components involves managing their state. You
    should already be familiar with the concept of states from [Chapter 9](ch09.html
    "Chapter 9. JSF State Management"), *JSF State Management*. For this reason, we
    can say that JSF 2.0 comes with the `StateHelper` interface, which basically allows
    us to store, read, and remove data across multiple requests (postbacks). This
    means we can use it to preserve states of the components.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be a little tricky to understand how to use the `StateHelper` methods
    in conjunction with custom components, but a common example can be useful to clear
    things up. Let''s consider the following custom component usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the custom component class, we can easily map these attribute names and
    default values, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to preserve the value of `unitto` under the constant `ATTR_UNITTO`
    (for `temp` it is exactly the same). For this, we use the `StateHelper.put` method,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These examples use the `Object put(Serializable key, Object value)` method,
    but `StateHelper` also has a method `Object put(Serializable key, String mapKey,
    Object value)`, which can be used to store values that would otherwise be stored
    in a `Map` instance variable. Moreover, `StateHelper` has a method named `void
    add(Serializable key, Object value)` that can be used to preserve values which
    would otherwise be stored in a `List` instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can retrieve the value stored under the `ATTR_UNITTO` constant, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Object eval(Serializable key, Object defaultValue)` method will search
    for the `ATTR_UNITTO` constant. If it can't find it, then the default value (`ATTR_UNITTO_DEFAULT`)
    is returned. This is a very useful approach because it spears us to perform `null`
    value checks. Besides this method, `StateHelper` also has the `Object eval(Serializable
    key)` and `Object get(Serializable key)` methods.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove an entry from `StateHelper`, we can call `Object remove(Serializable
    key)` or `Object remove(Serializable key, Object valueOrKey)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this moment, we have plenty of information that can be translated into code,
    so let''s write a custom component to exemplify the above knowledge. Let''s name
    it the Temperature custom component. Basically, the next custom component will
    expose a public web service as a JSF component. The web service is capable of
    converting the temperature from Celsius to Fahrenheit and vice versa for which
    we need to pass the temperature value and the conversion unit as arguments. Based
    on these two arguments, we can intuit that the corresponding JSF tag will look
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start by implementing a helper class to deal with the web service underlying
    the communication tasks. The name of this class is `TempConvertClient`, and it
    can be seen in the complete application named `ch10_4`. It''s relevant part is
    the declaration of the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Custom component implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we can focus on the important part for us, the custom component implementation.
    For this we can follow the ensuing steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a class annotated with `@FacesComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `StateHelper` to preserve the component's attribute values over multiple
    requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `callTempConvertService` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first three steps can be coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For step number four there is a hint in the preceding code. If you look carefully
    at the class constructor, you can see that the rendering tasks are delegated to
    an external class (renderer). This class will render a simple styled HTML `div`
    containing the web service response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@ResourceDependency` and `@ResourceDependencies` annotations are used for
    linked external resources (for example, JavaScript, and CSS) in custom components
    and renderers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to register this class as a `Renderer` class, you need to annotate
    it with `@FacesRenderer` or configure it in `faces-config.xml`, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Another important characteristic of a `Renderer` class consists of the fact
    that it must define a public zero-argument constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `<renderer-type>` tag corresponds to the `renderedType` element
    and the `<component-family>` tag corresponds to the `componentFamily` element.
    Moreover, the value of `componentFamily` is the same as the value returned by
    the component's `getFamily` method. A `RenderKit` can provide a `Renderer` instance
    based on this information.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in this example you can implement the rendering process in the custom
    component class also, since there is no real justification for writing a separate
    class. Usually, you will want to write a separate renderer class when you need
    to support multiple client devices and you need special renderers to be registered
    through a `RenderKit` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of code that uses our custom component (the code
    is self explanatory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can provide the conversion unit and temperature as constants
    (if one, or both attributes are missing, then the default value(s) will be used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TempBean` is just a simple backing bean, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete application is in the code bundle of this chapter under the name
    `ch10_4`. In the following screenshot, you can see the result of running this
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom component implementation](img/6466EN_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, our custom component just renders a `div` block containing the result of
    the temperature conversion. Further, we want to write a custom component that,
    besides this `div`, will render the user interface for collecting data (conversion
    unit and temperature) and submit it through AJAX. In other words, the content
    of the preceding form will be a part of the custom component.
  prefs: []
  type: TYPE_NORMAL
- en: This time we need to deal with user inputs directly into the custom component,
    which means that our custom component can extend `UIInput` instead of `UIComponentBase`.
    This major change will bring us the advantages of an `UIInput` component. We can
    submit the custom component value (using the `setSubmittedValue` method during
    the decoding process) and obtain the resultant value (using the `getValue` method
    during the encoding (rendering) process).
  prefs: []
  type: TYPE_NORMAL
- en: 'The big problem is that our custom component value is made up of two values:
    the conversion unit and the temperature value. There are a few workarounds to
    solve this kind of issue. In this case, we can simply concatenate these values
    into one, such as the one shown in the following example (*conversion_unit*`/`*temperature*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write the custom component class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we don't need to specify the component family anymore and the `getFamily`
    method is inherited from the `UIInput` class. Going further, we need to write
    the renderer class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to allow the component to render itself, use `setRendererType(null)`
    and override the corresponding methods in the component class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to render four HTML tags (the drop-down list, the input field, the
    button for submit, and the result `div`). For this, we can override the `encodeEnd`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The identifier of each component was obtained from the client ID of the main
    component (using the `getClientId` method) concatenated with the char naming container
    separator and a string hinting the component type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, the `NamingContainer` interface (implemented by `UINamingContainer`)
    is queried for obtaining the separator used to separate segments of client ID,
    but its main purpose is to ensure the uniqueness of the components declared within
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the method that renders the drop-down component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of this code are important where we extract the conversion
    unit part from the component value, and select the corresponding item in the drop-down
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we render the input field, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will extract the temperature value from the component value. To accomplish
    this, we render the button labeled **Convert**, which is responsible to submit
    the user input via AJAX as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After the user inputs are submitted, we need to render the result obtained
    from the web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The backing bean, `TempBean`, is pretty simple, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step involves decoding the user input and submitting it to the component,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Now you can see both the tests, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is present in the code bundle of this chapter under
    the name `ch10_5`.
  prefs: []
  type: TYPE_NORMAL
- en: Building composite components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe the idea behind composite components originates from the fact that JSF
    page authors and JSF component authors have different perspectives regarding components.
    While JSF page authors perceive components as tags that can be used in XHTML pages,
    JSF component authors see components as a mixture of `UIComponent`, `UIComponentBase`,
    `NamingContainer`, `Renderer`, `Validator`, and `Converter` elements—these are
    elements that shape up a JSF component. Based on this, it seems that custom components
    can be written only by JSF component authors, since they have knowledge about
    these JSF elements and Java language. This fact, however, has begun to change
    as of JSF 2 and composite components, which are practically custom components
    written in XHTML pages using markup tags. This means that JSF page authors can
    start writing their components without having the same level of knowledge and
    skills as dedicated JSF component authors—at least, simple, composite components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the skeleton of a JSF 2.2 composite component looks as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The structure is pretty simple! As you can see, there are two main tags that
    belong to the `http://xmlns.jcp.org/jsf/composite` library. The first tag demarcates
    the interface section and represents the component use contract. Here, we can
    define the component's attributes that may be changed by the end user (in principle,
    anything that can be used by the page author). The second tag marks the implementation
    section, which contains the component itself. This will be rendered to the end
    user. Moreover, in this section, we define the component behavior based on the
    attributes defined in the interface section (the use contract implementation).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Composite components are basically XHTML pages stored in libraries under the
    `resources` folder (placed as a top-level folder under the web application root
    or under the `META-INF` folder in JARs). Remember that a library is just a subfolder
    of the `resources` folder. Based on this, a composite component path is of type
    `http://xmlns.jcp.org/jsf/composite/`*library_name*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s have a quick test. Remember that the first custom component developed
    in this chapter, `WelcomeComponent`, was built from a class annotated with `@FacesComponent`.
    In that class, we have overridden the `encodeBegin` method for rendering the component.
    Well, now let''s see the same component, but this time as a composite component.
    We store this page under `resources/customs/welcome.xhtml`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It is very simple to make the analogy between the custom component and the composite
    version of it. The important thing here is to notice how attributes were declared
    using the `<cc:attribute>` tag. Besides the name, an attribute can have a type,
    can be required or not, can have a default value, can target component(s), and
    so on (during this chapter, you will have the chance to explore different kinds
    of attributes). As a general rule, JSF determines if the attribute is `MethodExpression`
    (or it has a special name such as `actionListener`, `valueChangeListener`, `action`,
    and so on) or `ValueExpression`.
  prefs: []
  type: TYPE_NORMAL
- en: The first case is a little bit tricky; JSF will try to match the attribute with
    the components from the implementation based on the list of IDs defined in the
    `targets` attribute (the list of IDs are separated by space and relative to top-level
    component). If the `targets` attribute is not present, then JSF will take the
    value of the `name` attribute as the client ID (relative to the top-level component)
    and try to find the corresponding component in the implementation section. Well,
    in the simple case, the attribute is a `ValueExpression`, and JSF will just store
    the attribute in the attributes map that is accessible via `UIComponent.getAttributes`.
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation section, the attributes are used via the `#{cc}` implicit
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It may be useful to know that JSF will implicitly create a top-level component
    for all the components that form a composite component. This component is the
    parent of all components in the page and is named `UINamingContainer` (available
    through the `UIComponent.getNamingContainer` method). Now the `#{cc}` implicit
    object actually refers to this top-level component and can be used to obtain various
    information, but it is especially used for obtaining the client ID (`#{cc.clientId}`)
    and for accessing the composite component attributes (`#{cc.attrs}`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to test our composite component. This is very easy—just import
    the composite namespace, set a prefix, and start using it, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Learning the techniques for writing composite components can be achieved
    by a lot of practice. This is why, in the upcoming sections you will see several
    types of composite components that explore different kinds of implementations.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The complete application is named `ch10_6`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developing the Temperature composite component**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Starring: backing component**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remember the Temperature custom component that we implemented in the preceding
    section? Well, we are sure you do. So let''s see how to develop a composite component
    that looks and behaves the same. The composite component page can be named `temperature.xhtml`,
    and we can store it in the `temperature` folder under the `resources` folder.
    First, let''s see it in the following code; afterwards we can dissect it:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**In the interface section, we have defined the attribute named `value`, which
    is specific to an `UIInput` component. Further, we indicate that the accepted
    value is of type `String` and the default value, applicable when the attribute
    is missing, is `celsius/0`. Usually, the `type` attribute is used to link the
    element(s) to the bean''s properties (for its value, use the fully qualified name,
    as shown in the preceding code).**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The implementation section is more interesting, because here we need to define
    the subcomponents of our component: the drop-down menu, the input field, the submit
    button, and the result div (notice that JSF generates an HTML `<div>` from `<h:panelGroup
    layout="block"/>`). When your composite component contains multiple components,
    it is a good practice to place them inside a `<div>` or a `<span>` tag with the
    ID set to `#{cc.clientId}`. This ID is the client identifier of the composite
    itself and is useful when the page author needs to refer to the entire composite
    component via a simple ID.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**External resources, such as CSS and JS, don''t need any special treatment.
    You can place them under the same library with composite components or under any
    other library, and you can load them using `<h:outputScript>` and `<h:outputStylesheet>`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**After a quick look, an obvious question arises: where is the implementation
    of the `getTempConvert` method and the backing beans properties used for linking
    these components according to the `binding` attribute? Well, all these are in
    a Java class, known as **backing component** (do not confuse this with the backing
    bean!). Yes, I know that earlier I said composite components don''t need Java
    code, but sometimes they do, like in this case, where we need to write the code
    for calling the web service! In order to write a backing component, you need to
    keep in mind the following steps:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Annotate the backing component with `@FacesComponent`**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Extend `UINamingContainer` or implement `NamingContainer` and override the
    `getFamily` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Link the composite component with the backing component by adding the `componentType`
    attribute to the `<cc:interface>` tag. The value of this attribute is the component-type
    (this tells JSF to create an instance of the class indicated here):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A backing component can define getters for exposing its properties via the
    `#{cc}` implicit object (`#{cc}` has access to action methods also). On the other
    hand, the `<cc:attribute>` attributes are available in a backing component via
    the `UIComponent.getAttributes` method.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Keeping these in mind, the backing component for our composite component
    is as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**The story of our backing component is pretty clear. In the `encodeBegin`
    method, we ensure that the component value is parsed and each subcomponent (the
    dropdown and the input field) received the correct part of the value. When the
    user submits the data, we deal with it in the `encode` method, where we take the
    value of the dropdown and of the input field and build a string of type *conversion_unit*`/`*temperature*.
    This becomes the submitted value.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**This is a good time to point out how JSF chooses the top-level component.
    JSF tries to do the following:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Locate the `componentType` attribute in the `<cc:interface>` tag. If it is
    present, then the backing component is instantiated and used as a top-level component.
    This is the case with the Temperature composite component.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Locate a `UIComponent` implementation that fits the composite component page.
    This can be a Groovy script with the same name and location as the composite component
    page (of course, with the `.groovy` extension).**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Locate a Java class named *component_library_name.composite_component_page_name*
    and instantiate it as a top-level component. This approach spears us to use `@FacesComponent`.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generate a component with the component type `javax.faces.NamingContainer`.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The complete application is named `ch10_8`. Based on the knowledge introduced
    through this didactical example, you can check out another example, named Timezone,
    as shown in the following screenshot. The complete application is named `ch10_25`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![Developing the Temperature composite component](img/6466EN_10_02.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transforming a jQuery component into composite component**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Starring: JavaScript closures**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The jQuery UI is a great collection of user interface interactions, effects,
    widgets, and themes built on top of the jQuery JavaScript library. In this section,
    you will see how to expose a jQuery component as a JSF composite component. More
    precisely, we will transform the jQuery range slider ([https://jqueryui.com/slider/#range](https://jqueryui.com/slider/#range)),
    as shown in the following screenshot:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![Transforming a jQuery component into composite component](img/6466EN_10_03.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The main code behind this component is listed as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**The JSF composite component should look like the following code (the important
    part is highlighted):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**We can start by defining the composite component attributes. These will allow
    the end user to set the minimum (`min` attribute), maximum (`max` attribute) and
    the initial range (`leftside` and `rightside` attributes). These attributes will
    be declared in the interface section, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**The implementation section can be divided into three logical parts. In the
    first part we define the external resources (CSS and JS files). Notice that `<h:outputScript>`
    and `<h:outputStylesheet>` cannot load such resources for an absolute URL (`http://...`),
    so you need to have these resources on your local machine:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**In the second part, we render the divs that expose the range slider. For
    this, we follow the exact model of the original component, but we add our attributes,
    `leftside` and `rightside`, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**While the `min` and `max` attributes can be set to certain values, we are
    especially interested in the `leftside` and `rightside` attributes, which should
    be treated as the end user inputs. For this, we have added two hidden fields (one
    for `leftside` and one for `rightside`) that can easily transport this information
    to the server.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**In the third part, we need to adapt the JavaScript code, which represents
    the component engine. This code has to be correctly generated when multiple range
    sliders are added in the same page, so we need to modify it as follows to fit
    the correct IDs and attribute values:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A common issue of combining JSF and jQuery involves using the colon (`:`).
    While JSF uses it as a separator of ID segments, the jQuery selector has other
    jobs for it. In order to work in jQuery, we need to escape the colon. This can
    be easily accomplished if you use a PrimeFaces method, as shown in the following
    code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Done! Now you can test the composite component in your page. The complete
    application is named `ch10_11`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Well, if you add multiple range sliders in the page, you will see that the
    preceding JavaScript code will be generated and added each time. The size of this
    code is insignificant, and the chances that you''ll need multiple range sliders
    in the same page are pretty small, so it will not be a big issue. But, when such
    an issue arises, you need to know that there are a few workarounds for it.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**For example, we can take out JavaScript from the composite component and
    place it into the page, or as a component should be self contained it would be
    better to place the code in a separate JavaScript file and reference it in the
    composite component with `<h:outputScript>`. After that, we parameterize the JavaScript
    code with the desired attributes, and call it from the composite component. So,
    the parameterized version might look like the following code (place this in a
    file named `slider.js`):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**Further, we adapt the composite component implementation section for calling
    the following reusable JavaScript code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Probably you already know that you just saw a technique of JavaScript closures.
    The idea is to speculate the fact that JavaScript is a dynamic language that lets
    us modify the DOM at runtime. Using the JSF client identifier and this JavaScript
    capability can help us to solve the issue of repeating code for multiple components.
    Sometimes, a good practice is to place the entire composite component inside a
    `div` element whose ID is the JSF client identifier. Moreover, you can identify
    and manage each `div` content directly from JavaScript.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The complete application for this example is named `ch10_9`. If you want
    to place the JavaScript code directly into the page, check the application named
    `ch10_26`. Besides this application, another complete example of using JavaScript
    closures is named `ch10_7`. In this example, a composite component encapsulates
    an HTML5 SSE (Server-sent Events) example. For those who are not familiar with
    SSE, a good starting point is the tutorial at [http://www.html5rocks.com/en/tutorials/eventsource/basics/](http://www.html5rocks.com/en/tutorials/eventsource/basics/).**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing the HTML5 date picker as a composite component**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Starring: `<cc:clientBehavior>` and `<cc:insertChildren />`**'
  prefs: []
  type: TYPE_NORMAL
- en: '**In this section, you will see how to transform the HTML5 date picker component
    into a composite component. There are a few attributes that allow us to customize
    the native date picker component. The following is a list of three examples:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The code for the simplest case is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The code for the constrained date picker is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The code for the date picker with data list is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Our composite component should reflect these forms, so it might look like
    the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**Alternatively, use a data list, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**So, let''s focus on the interface definition. First, we have a set of attributes
    that are very easy to define, such as `value`, `list`, `step`, `required`, and
    `readonly`:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**This was easy! Now we need to take a closer look at the `min` and `max` attributes,
    which delimitate the range of selection. Practically, they are just some dates,
    but NOT instances of `java.util.Date`, because their format is specific to HTML
    5 (y-m-d), not to Java. This means that we need some Java code for accomplishing
    the conversion from Java date format to HTML5 date format. We need a backing component
    to do this (notice that we can''t use any converter here):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '**Of course, we don''t forget to indicate the backing component in the interface
    and the restriction selection attributes, which can now be declared as `java.util.Date`,
    as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '**We need to do one more thing in the interface. When the end user selects
    a date, we want it to be submitted via AJAX to a backing bean. For this, we need
    to allow him/her to attach a client behavior (we spoke about client behavior several
    times in this book, but a perfect tutorial can be found at DZone, [http://java.dzone.com/articles/jsf-2-client-behaviors](http://java.dzone.com/articles/jsf-2-client-behaviors)),
    and for this we need the `<cc:clientBehavior>` tag, as shown in the following
    code. The `name` attribute contains the name of the event that will listen (for
    example, `change` here) and the `targets` attribute indicates the component(s)
    from the implementation, which will support the declared JavaScript event via
    the `event` attribute (do not use the prefix `on` for JavaScript events).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '**So far, the interface is ready! Going further, we need an implementation.
    This is pretty simple and is based on JSF 2.2 pass-through elements, as shown
    in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**In order to have an easy way to reference `<datalist>`, we used `#{cc.id}`.
    If the component is used multiple times in a page, then you have to specify a
    unique ID for each use. Nevertheless, if you need a clean solution that avoids
    nonunique IDs in the rendered XHTML document, you might require some additional
    ID resolving to be done (with JavaScript or in a backing component for instance).**'
  prefs: []
  type: TYPE_NORMAL
- en: '**At this moment, we can use our composite component, except the data list
    (see the preceding HTML5 `<datalist>`). For this, we need to write two more composite
    components. As you can see, a data list is just a set of several options (items)
    and each option has two attributes, named `label` and `value`. So, we can easily
    encapsulate an option in a composite component, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**Now we need to nest several options in `<datalist>`, but this is inappropriate
    here, because the number of options is indeterminate. Fortunately, for these kinds
    of situations, JSF provides the `<cc:insertChildren>` tag, which is used to insert
    the child component within a parent component (the child components will be automatically
    re-parented by JSF). Knowing this, we can write the following composite component
    for `<datalist>`:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use the `<datalist>` tag only in `<cc:implementation>` and be careful to
    avoid duplicate ID errors. In order to avoid this, it is recommended that you
    use this tag only once. To find out the number of children, use `#{cc.childCount}`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Done! Now you can try to test the complete application named `ch10_12`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**For the sake of completeness, you can treat the case when the browser doesn''t
    support HTML5 by getting back to the jQuery UI version of this component. This
    can be accomplished via the Modernizr library ([http://modernizr.com/](http://modernizr.com/)),
    which is able to detect this kind of issue. From our point of view, such browsers
    will be obsolete in the future, so we don''t think the effort to add this check
    and fallback is justified.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decorating an image with actions**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Starring: `<cc:actionSource>`, Java `enum` types**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composite components are amazing because they can transform simple things
    into a real powerful component. For example, in this section we will decorate
    a simple image to become a composite component with AJAX and action capabilities
    by adding action and action listener support. Moreover, we will force the page
    author to use only a range of values for a certain attribute.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**First, we take care of the interface section, and we can start by declaring
    an attribute that represents the image location, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '**After this quick warm up, we can declare the `action` attribute. The page
    author will use this attribute to indicate an `action` method of a backing bean.
    Notice that the `action` method signature must be declared here, as shown in the
    following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**When you write a method signature, you need to indicate the return type (`void`
    in this case), the method name and the argument types. For example, an `action`
    method that returns `String` and gets two `Integer` arguments will be declared
    as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Furthermore, we add support for the `<f:actionListener>` tag. For this, we
    use the `<cc:actionSource>` tag as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**The value of the `name` attribute will be used by the page authors as the
    value for the `<f:actionListener>` `for` attribute. The `targets` attribute points
    the component(s) from the implementation section, which receives this capability.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The `<cc:actionSource>` tag specifies the implementation of `ActionSource2`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Next, we declare a client behavior using the `<cc:clientBehavior>` tag as
    follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**As the final touch, we add an attribute that will accept only a range of
    values, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**The interface section is ready, so let''s focus on the implementation section.
    For a better understanding, let''s have a look at it as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**There are a few interesting points here! Let''s dissect the code from the
    inside to the outside in the following points:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**First, the image is loaded in JSF classic style through the `<h:graphicImage>`
    tag. Nothing fancy here!**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The `<h:graphicImage>` tag is nested in a `<h:commandLink>` tag, which supports
    action and action listener capabilities. Notice that this component is targeted
    from the interface section. Moreover, we nest a hidden field here (`<h:inputHidden>`)
    that associates (holds) a value with our image. This value comes from a range
    of allowed values via the `item` attribute.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The `<h:commandLink>` tag is nested in a `<h:form>` tag and everything is
    added into a `<div>` tag. Notice that, usually, it is not a good practice to add
    `<h:form>` in a composite component, since the page author may want to use the
    composite component in his/her `<h:form>`. This will lead to nested forms, which
    leads to invalid HTML code.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In order to restrict an attribute value to a range of values, you may think
    of using Java enum types. The problem is that you cannot do that in the interface
    section, but you can add a check in the implementation section. For example, we
    choose not to render the composite component when the value of the `item` attribute
    is different from `item_1`, `item_2`, and `item_3`.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The composite component is ready for testing. A perfect example can be seen
    in the code bundle of this chapter under the name `ch10_18`. Based on the same
    principle, we have written another example under the name `ch10_13`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with composite facets**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Starring: `<cc:facet>`, `<cc:renderFacet>`, and `<cc:insertFacet>`**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A composite component contains the facets definition in the interface section.
    For this, we need to use the `<cc:facet>` tag and to specify at least the facet
    name through the `name` attribute, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Once the facets are declared in the interface section, they can be used in
    the implementation section via the `<cc:renderFacet>` tag. For this tag, we need
    to specify which facet to be rendered, by setting the value of the `name` attribute
    in agreement with the corresponding facet defined in the interface section, as
    shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '**That''s all! You can see a complete example in the code bundle of this chapter
    under the name `ch10_14`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Besides `<cc:renderFacet>`, a composite component supports the `<cc:insertFacet>`
    tag. Now things become more interesting, because a common question is, what is
    the difference between them? The best answer will come from an example. Let''s
    take a simple composite component that uses `<cc:renderFacet>`, as shown in the
    following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '**This will render correctly through the following usage:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '**However, replacing `<cc:renderFacet>` with `<cc:insertFacet>` will not work.
    Nothing will be rendered.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Now let''s take a look at the following composite component that uses `<cc:insertFacet>`:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '**The following code snippet will render the desired result:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '**But again, replacing `<cc:insertFacet>` with `<cc:renderFacet>` will not
    work. Nothing will be rendered.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**So, we can conclude that `<cc:renderFacet>` is useful for rendering facets
    as child components of the composite component. This means that `<cc:renderFacet>`
    allows us to render facets when the parent component doesn''t support facets;
    the facet name can be any accepted string. On the other hand, `<cc:insertFacet>`
    allows us to render facets only in components that support facets. Here, the facet
    name must exist in the facet map of the top-level component. The facet is inserted
    as a facet child of the component in which this element is nested.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The complete application is named `ch10_17`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validating/converting inputs inside composite components**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Starring: `<cc:editableValueHolder>`**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Let''s take a quick look at a simple composite component in the following
    code, especially at the highlighted parts:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '**Now we write a page that uses this component and attaches a custom converter
    and a custom validator to it as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '**Everything works as expected, thanks to `<cc:editableValueHolder>`. In this
    case, this tag tells JSF that any converter/validator that has the value of the
    `for` attribute equal to `playerId` should be applied to the targeted components,
    `nameId` and `surnameId`. Generally speaking, `< cc:editableValueHolder>` indicates
    the components that implement `EditableValueHolder`, so any attached objects suitable
    for implementations of `EditableValueHolder` may be attached to the composite
    component.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The complete application is named `ch10_10`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**As you know, `EditableValueHolder` is an extension of `ValueHolder`. Besides
    `<cc:editableValueHolder>`, JSF defines a tag named `<cc:valueHolder>`, which
    indicates the components that implement `ValueHolder`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking the presence of an attribute**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Sometimes you need to render a composite component only if a certain attribute
    is present in the author page. For example, the following composite component
    checks for the presence of the `mandatory` attribute:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '**Now the composite component will be rendered only if the `mandatory` attribute
    is present, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**The complete application is named `ch10_22`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composite components'' pitfalls**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**In the next part of this chapter, we will discuss a few pitfalls of composite
    components, such as: `null` values within composite component attributes, hidden
    pass-through attributes in composite components, number of children of composite
    components, and rendered top-level component in `<h:panelGrid>`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Null values within a composite component''s attributes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**As of version 2.2, JSF can determine the right type of a composite component
    attributes even when that value is `null`. This is an issue in version 2.1.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Let''s have a simple composite component, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '**Also, a simple page that uses this composite component is as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '**Now if you supply a `null` value from this component, it will work correctly
    in JSF 2.2, but will not work in JSF 2.1\. The complete example is named `ch10_19`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hiding pass-through attributes in composite components**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**A composite component can hide pass-through attributes. For example, let''s
    take a simple composite component as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '**Next, let''s use this composite component in a page by adding two pass-through
    attributes to it as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '**At this moment, if you check the list of attributes (using the `UIComponent.getAttributes`
    method) and the list of pass-through attributes (using the `UIComponent.getPassThroughAttributes`
    method), you will notice that the `placeholder` and `type` attributes are in the
    list of pass-through attributes. We can easily move them into the attributes list
    by encapsulating them into the composite component, as shown in the following
    code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '**Also, you can use the composite component in the page, as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '**Done! Now the `placeholder` and `type` attributes are not present in the
    pass-through attributes list. They were added in the attributes list returned
    by the `getAttributes` method.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The complete application is named `ch10_16`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Counting the children of a composite component**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Suppose that you have a composite component that accepts children via the
    `<cc:insertChildren/>` tag. Sometimes you may need to render a certain message
    when the list of children is empty, and for this you may think of writing a composite
    component implementation, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '**Now if the composite component is used as follows, you may think that the
    message **The list of names is empty!** will be rendered:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '**Well, you are right! But, the same message, next to the list content, will
    be rendered when the component is used as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '**In order to solve this issue, you can use the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '**Done! The complete application is named `ch10_20`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-level component''s pitfall**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Remember that we have said earlier in this chapter that each composite component
    receives `UINamingContainer` as the top-level component. Well, it is important
    to not forget this when you define a composite component, as shown in the following
    code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '**And, you try to use it, as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '**If you forgot about the top-level component, you probably expect to see something
    like the left-hand side of the following screenshot, while in reality, you will
    see something like the right-hand side of the following screenshot:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![Top-level component''s pitfall](img/6466EN_10_04.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**This is normal, since `<h:panelGrid>` perceives the composite component as
    a whole. All components that define the composite component are the children of
    the top-level component and are invisible to `<h:panelGrid>`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The complete example is named `ch10_15`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributing composite components as JARs in JSF 2.2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**As of JSF 2, we can add composite components in custom tag libraries (taglibs).
    After placing the composite component artifacts in the correct folders, we need
    to write a file of type (this filename should be suffixed with `taglib.xml`),
    as shown in the following code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '**Based on this file''s content, and more precisely on `<composite-library-name>`,
    JSF 2 detects the composite components belonging to this library. This means that
    the composite components mapped in this JAR must come from this library only.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**As of JSF 2.2, this restriction doesn''t exist anymore, and we can add, in
    the same JAR, composite components that come from different libraries.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Let''s see an example! Suppose that we want to add in the same JAR the Temperature
    component (developed in application `ch10_8`) and the Range-slider component (developed
    in application `ch10_11`). The JAR will be named `jsfcc.jar`. The steps for accomplishing
    this are as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create an empty JAR named `jsfcc.jar`.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**In `jsfcc.jar`, create the folder `META-INF/resources`.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Copy the libraries that contain the composite components in `META-INF/resources`
    (copy the `resources/temperature` folder from the application `ch10_8` and `resources/range-slider`
    from the application `ch10_11`).**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**For the Temperature composite component, copy the classes `book.beans.TempConvertClient.class`
    and `book.beans.TempConvertComponent.class` under the JAR root.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create an empty `faces-config.xml` file and place it under the `META-INF`
    folder as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Create the following `cc.taglib.xml` file and place it under the `META-INF`
    folder. Notice that we don''t need a `<composite-library-name>` tag, and we have
    configured both composite components under the same namespace, [http://jsf/cc/packt/taglib](http://jsf/cc/packt/taglib).
    Using this example, it is very easy to define more components as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In the following screenshot, you can see how the JAR structure should look:![Distributing
    composite components as JARs in JSF 2.2](img/6466EN_10_05.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Specially for testing `jsfcc.jar`, you can run the application `ch10_21`.
    Notice that even if NetBeans doesn''t recognize the tags of the composite components,
    they work like a charm.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding composite components programmatically**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**The last section in this chapter discusses adding composite components programmatically.
    Before JSF 2.2, there wasn''t any official API for instantiating composite components
    as a Java instance via user code. But, there were at least two facile options
    for unofficially accomplishing this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the `Components.includeCompositeComponent` method available in OmniFaces
    from JSF Version 1.5 onwards ([https://code.google.com/p/omnifaces/](https://code.google.com/p/omnifaces/)).**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the `Components.includeCompositeComponent` source code as an inspiration
    to write your own implementation. This kind of implementation is listed in the
    complete application named `ch10_23`. In that application, you can see how to
    programmatically add in a page the Welcome and Temperature composite components
    (you need to pass to the `addCompositeComponent` method the following data: the
    composite component parent, the library name and path, and a unique ID).**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As of JSF 2.2, we can use an explicit API for instantiating composite components
    programmatically. The core of this API is based on the new `createComponent` method
    added in the `ViewDeclarationLanguage` class. The signature of this method is
    as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '**Besides `FacesContext`, you need to pass the tag library URI, the tag name,
    and the tag''s attributes, or `null`, if there are no attributes. For example,
    the Welcome component can be added via this API as follows (we append the Welcome
    component to a `<h:panelGroup>` with the `welcomeId` ID):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '**The complete application is named `ch10_27_1`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A side-effect of this API includes the fact that it allows us to add regular
    components also. For example, you can append an `UIOutput` component to `<h:panelGroup>`
    with the `myPlayerId` ID, as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '**The complete application is named `ch10_27_2`. In [Chapter 12](ch12.html
    "Chapter 12. Facelets Templating"), *Facelets Templating*, you can see an example
    of adding `<ui:include>` using this API.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**# Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you saw at work one of the greatest facilities of JSF. The
    custom and composite components feature represents the way how JSF expresses the
    respect for its developers. Writing custom/composite components is definitely
    a mandatory test of each JSF developer, since the difference between an ordinary
    and an extraordinary component resides in his skills. I hope that, next to many
    other books and tutorials about JSF custom/composite components, you have found
    this chapter as an interesting dissertation about this wide topic.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note of this chapter, we have to apologize to all JSP fans who felt
    ignored in this chapter by the fact that we did not mention anything about writing
    custom/composite components compatible with JSP. As you know, such components
    can be made compatible with JSP via tag classes (not tag handlers), but JSP was
    deprecated as of JSF 2\. I think that this is a plausible excuse for not covering
    or even mentioning JSP.
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next chapter, where we will explore the new JSF 2.2 themes!**
  prefs: []
  type: TYPE_NORMAL
