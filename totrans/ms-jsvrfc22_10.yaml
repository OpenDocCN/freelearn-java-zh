- en: Chapter 10. JSF Custom Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 JSF自定义组件
- en: 'JSF is a component-based framework, and JSF custom components are the major
    proof that sustain JSF flexibility and extensibility. In order to write custom
    components or extend the existing ones, JSF provides a powerful API that allows
    us to develop two types of components: **custom components,** and, from JSF 2.0
    onwards, **composite components**. A custom component implementation is responsible
    for providing an **aspect** (optional for non-UI components, such as custom validators,
    converters, and renderers) and a **behavior**. Usually the decision to write custom
    components and the skills for accomplishing it belong to advanced JSF developers.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JSF是一个基于组件的框架，JSF自定义组件是支持JSF灵活性和可扩展性的主要证据。为了编写自定义组件或扩展现有的组件，JSF提供了一个强大的API，允许我们开发两种类型的组件：**自定义组件**，以及从JSF
    2.0开始，**复合组件**。自定义组件实现负责提供**方面**（对于非UI组件，如自定义验证器、转换器和渲染器，是可选的）和**行为**。通常，编写自定义组件的决定和实现它的技能属于高级JSF开发者。
- en: 'Before you decide to write a custom component, which can be a time-consuming
    task, you have to overview the following bullets (especially the first bullet):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在你决定编写自定义组件之前，这可能是一项耗时的工作，你必须概述以下要点（特别是第一个要点）：
- en: Check the Internet (for example, [http://jsfcentral.com/](http://jsfcentral.com/))
    to make sure the component doesn't exist yet. Many JSF extensions, such as PrimeFaces,
    ICEfaces, OmniFaces, and RichFaces, already come with hundreds of custom components.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查互联网（例如，[http://jsfcentral.com/](http://jsfcentral.com/)) 确保该组件尚未存在。许多JSF扩展，如PrimeFaces、ICEfaces、OmniFaces和RichFaces，已经包含数百个自定义组件。
- en: Make sure that you need a custom component and not just a Facelet template (see
    [Chapter 12](ch12.html "Chapter 12. Facelets Templating"), *Facelets Templating*)
    or some custom logic over the existing components.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你需要自定义组件，而不仅仅是Facelet模板（参见[第12章](ch12.html "第12章。Facelets模板")，*Facelets模板*)或对现有组件的一些自定义逻辑。
- en: Try to redesign the application goals to use the existing components (sometimes
    you can combine several existing components to obtain the desired aspect and behavior).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试重新设计应用程序目标以使用现有组件（有时你可以组合几个现有组件以获得所需方面和行为）。
- en: Take a closer look at non-JSF components, such as jQueryUI, ComponentJS, and
    AmplifyJS (as you are not forced to solely use JSF components in your JSF applications!).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细查看非JSF组件，例如jQueryUI、ComponentJS和AmplifyJS（因为你在JSF应用程序中并不被迫只能使用JSF组件！）。
- en: If your application has some specific goals that just cannot be solved by any
    of the preceding bullets, it is time to start coding your own components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序有一些特定的目标，这些目标无法通过前面的任何一项解决，那么是时候开始编写你自己的组件了。
- en: In the first part of this chapter, you will see how to write noncomposite custom
    components, and in the second part you will learn about composite components.
    The noncomposite components have been available for a long time in JSF, and the
    technique of writing such components is based on writing several Java classes.
    The new concept, which came along with composite components, is available from
    JSF 2 onwards, and the idea behind it is to replace the Java classes with XHTML
    pages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，你将看到如何编写非复合自定义组件，在第二部分你将了解复合组件。非复合组件在JSF中已经存在很长时间了，编写此类组件的技术基于编写几个Java类。与复合组件一起出现的新概念从JSF
    2开始提供，其背后的想法是用XHTML页面替换Java类。
- en: Building noncomposite custom components
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建非复合自定义组件
- en: Let's jump directly to the cool stuff and say that in JSF 2.0 a custom component
    was made available to page authors by configuring it in a Facelet tag library
    (`*taglib.xml`).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接跳到有趣的部分，并说在JSF 2.0中，通过在Facelet标签库（`*taglib.xml`）中进行配置，自定义组件被提供给页面作者。
- en: Moreover, when the component is mapped in a JAR, a special entry in `web.xml`
    is needed to point to the `*taglib.xml` file. See the application named `ch10_3`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当组件映射到JAR文件中时，需要在`web.xml`中添加一个特殊的条目来指向`*taglib.xml`文件。参见名为`ch10_3`的应用程序。
- en: 'As of JSF 2.2, we don''t need these files anymore. A JSF 2.2 simple custom
    component contains a single class, and it may look like the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 截至JSF 2.2，我们不再需要这些文件。一个JSF 2.2简单自定义组件包含一个类，它可能看起来像以下代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most of the hard work is accomplished by the `@FacesComponent` annotation (`javax.faces.component.FacesComponent`).
    All we need to do is set the `createTag` element to `true`, and JSF should create
    the tag for us. Further, we can easily exploit our custom components, as shown
    in the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作都是由 `@FacesComponent` 注解（`javax.faces.component.FacesComponent`）完成的。我们所需做的只是将
    `createTag` 元素设置为 `true`，JSF 应该会为我们创建标签。此外，我们可以轻松利用我们的自定义组件，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the default namespace of the component is `http://xmlns.jcp.org/jsf/component`.
    This is true for all components that don't have an explicit namespace.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，组件的默认命名空间是 `http://xmlns.jcp.org/jsf/component`。这对于所有没有显式命名空间的组件都适用。
- en: The complete application is named `ch10_1`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序命名为 `ch10_1`。
- en: 'The entire list of elements supported by JSF 2.2 `@FacesComponent` is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2 支持的 `@FacesComponent` 元素完整列表如下：
- en: '`createTag`: This can be set to `true` or `false`. When it is set to `true`,
    JSF will generate the tag for us (to be more specific, JSF will create, at runtime,
    a Facelet tag handler that extends `ComponentHandler`). This element can be used
    only in JSF 2.2.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createTag`：这可以设置为 `true` 或 `false`。当设置为 `true` 时，JSF 将为我们生成标签（更具体地说，JSF 将在运行时创建一个扩展
    `ComponentHandler` 的 Facelet 标签处理器）。此元素只能在 JSF 2.2 中使用。'
- en: '`tagName`: This allows us to indicate the tag name. When `createTag` is set
    to `true`, JSF will use this name for the generated tag. This element can only
    be used in JSF 2.2.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tagName`：这允许我们指定标签名称。当 `createTag` 设置为 `true` 时，JSF 将使用此名称生成标签。此元素只能在 JSF
    2.2 中使用。'
- en: '`namespace`: This allows us to indicate the tag namespace. When `createTag`
    is set to `true`, JSF will use this namespace for the generated tag. When namespace
    is not specified, JSF will use the `http://xmlns.jcp.org/jsf/component` namespace.
    This element can be used only in JSF 2.2.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespace`：这允许我们指定标签命名空间。当 `createTag` 设置为 `true` 时，JSF 将使用此命名空间生成标签。当未指定命名空间时，JSF
    将使用 `http://xmlns.jcp.org/jsf/component` 命名空间。此元素只能在 JSF 2.2 中使用。'
- en: '`value`: This element comes from JSF 2.0 and indicates the **component type**.
    The component type can be used as the argument of the `Application.createComponent(java.lang.String)`
    method for creating instances of the `Component` class. As of JSF 2.2, if the
    `value` element is missing or is `null`, JSF will obtain it by calling the `getSimpleName`
    method on the class to which `@FacesComponent` is attached and lowercasing the
    first character.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：此元素来自 JSF 2.0，表示 **组件类型**。组件类型可以用作 `Application.createComponent(java.lang.String)`
    方法的参数，以创建 `Component` 类的实例。截至 JSF 2.2，如果 `value` 元素缺失或为 `null`，JSF 将通过在 `@FacesComponent`
    附着的类上调用 `getSimpleName` 方法并小写第一个字符来获取它。'
- en: By the component type, we understand a small chunk of data, specific to each
    `UIComponent` subclass, that can be used in conjunction with an `Application`
    instance to programmatically obtain new instances of those subclasses. Moreover,
    each `UIComponent` subclass belongs to a component family (for example `javax.faces.Input`).
    This is important when we write a custom component and declare it under a certain
    family, because we can exploit the renderer specific to that family of components.
    Next to the component family, we can use the **renderer type** property to select
    a `Renderer` instance from a `RenderKit` collection (for example, an input field
    belongs to the `javax.faces.Input` family and to the `javax.faces.Text` renderer
    type).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组件类型，我们理解一小块数据，它针对每个 `UIComponent` 子类，可以与 `Application` 实例结合使用，以编程方式获取这些子类的实例。此外，每个
    `UIComponent` 子类属于一个组件家族（例如 `javax.faces.Input`）。当我们编写自定义组件并在某个家族下声明它时，这很重要，因为我们可以利用该家族组件特有的渲染器。在组件家族旁边，我们可以使用
    **渲染器类型** 属性从 `RenderKit` 集合中选择一个 `Renderer` 实例（例如，输入字段属于 `javax.faces.Input`
    家族和 `javax.faces.Text` 渲染器类型）。
- en: Each custom component must extend `UIComponent` or one of its subtypes, such
    as `UIComponentBase`, which is actually just a default implementation of all abstract
    methods of `UIComponent`. Anyway, there is one exception represented by the `getFamily`
    method that must be overridden even when you extend `UIComponentBase`. As a common
    practice, when a custom component needs to accept end user inputs, it will extend
    `UIInput`, and when it needs to act as a command, it will extend `UICommand`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个自定义组件必须扩展 `UIComponent` 或其子类型之一，例如 `UIComponentBase`，它实际上是 `UIComponent` 所有抽象方法的默认实现。无论如何，有一个例外是
    `getFamily` 方法，即使扩展 `UIComponentBase` 也必须重写它。作为常见做法，当自定义组件需要接受最终用户输入时，它将扩展 `UIInput`，而当它需要作为命令执行时，它将扩展
    `UICommand`。
- en: 'Further, let''s modify our application as follows to indicate a custom namespace
    and tag name:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们修改我们的应用程序如下，以指示自定义命名空间和标签名称：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, the component will be used as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，组件将被如下使用：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The complete application is named `ch10_2`. Moreover, the JSF 2.0 version of
    this application (containing the `*taglib.xml` descriptor and the specific entry
    in `web.xml`) is named `ch10_3`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch10_2`。此外，此应用程序的 JSF 2.0 版本（包含 `*taglib.xml` 描述符和 `web.xml` 中的特定条目）命名为
    `ch10_3`。
- en: Writing a custom tag handler
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义标签处理器
- en: 'Notice that `*taglib.xml` is still needed in some cases. For example, if you
    decide to write a custom tag handler for your component, then you still need this
    file to configure the handler class. In this rare case, you will extend the `ComponentHandler`
    class and override the desired methods. Most developers exploit the `onComponentCreated`
    and `onComponentPopulated` methods. The first one is called after the component
    has been created but before it has been populated with children, and the second
    one is called after the component has been populated with children. As of JSF
    2.2, a new method was added for developers who wish to take over the task of instantiating
    the `UIComponent`. This method is named `createComponent`. If it returns `null`,
    then this method will be required to create the component by `TagHandlerDelegate`
    instead. Since this is a pretty rare case, we do not insist on it, and we just
    provide a simple stub of `ComponentHandler`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某些情况下仍然需要 `*taglib.xml`。例如，如果你决定为你组件编写自定义标签处理器，那么你仍然需要此文件来配置处理器类。在这种情况下，你将扩展
    `ComponentHandler` 类并覆盖所需的方法。大多数开发者利用 `onComponentCreated` 和 `onComponentPopulated`
    方法。第一个方法在组件创建后但尚未用子组件填充之前被调用，第二个方法在组件用子组件填充之后被调用。截至 JSF 2.2，为希望接管 `UIComponent`
    实例化任务的开发者添加了一个新方法。此方法名为 `createComponent`。如果它返回 `null`，则此方法将需要通过 `TagHandlerDelegate`
    创建组件。由于这是一个相当罕见的情况，我们不坚持这一点，只是提供了一个简单的 `ComponentHandler` 模板：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to indicate that our class handler should be used, we need to configure
    it in the `*taglib.xml` file, as shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指示我们的类处理器应该被使用，我们需要在 `*taglib.xml` 文件中对其进行配置，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The complete example is named `ch10_24_1`. Another stub that can be used as
    a starting point can be found in `ch10_24_2`. The latter one defines the minimum
    implementation for a custom `ComponentHandler`, a custom `TagHandlerDelegateFactory`,
    and a custom `TagHandlerDelegate`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例命名为 `ch10_24_1`。另一个可以作为起点使用的模板可以在 `ch10_24_2` 中找到。后者定义了自定义 `ComponentHandler`、自定义
    `TagHandlerDelegateFactory` 和自定义 `TagHandlerDelegate` 的最小实现。
- en: Dissecting a custom component
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析自定义组件
- en: 'So far you can see that our component class overrides the `encodeBegin` method.
    This method belongs to a set of four methods used for rendering a component where
    each component can render itself (the `setRendererType` method gets a `null` value
    for its argument) or delegate the rendering process to a `Renderer` class (built-in
    or user defined). These methods are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以看到我们的组件类覆盖了 `encodeBegin` 方法。此方法属于一组四个用于渲染组件的方法，其中每个组件都可以自行渲染（`setRendererType`
    方法的参数为 `null`）或将渲染过程委托给 `Renderer` 类（内置或用户定义）。这些方法如下：
- en: '`decode`: In order to parse the input values and save them into the component,
    each request passes through the `decode` method. Usually, when this method is
    overridden, the developer extracts the needed values from the request map (or
    from the `Map` attributes using the `UIComponent.getAttributes` method) and sets
    them into the component by calling the `setSubmittedValue(`*value*`)` method.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decode`：为了解析输入值并将它们保存到组件中，每个请求都会通过 `decode` 方法。通常，当此方法被覆盖时，开发者会从请求映射中（或使用
    `UIComponent.getAttributes` 方法从 `Map` 属性中）提取所需值，并通过调用 `setSubmittedValue(`*value*`)`
    方法将这些值设置到组件中。'
- en: '`encodeBegin`: This method starts the rendering process of the custom component.
    It writes to the response stream obtained through the `FacesContext.getResponseWriter`
    method. This method is overridden when we need to encode child components, but
    we want to output a response to the user before that.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encodeBegin`：此方法开始自定义组件的渲染过程。它通过 `FacesContext.getResponseWriter` 方法获取的响应流写入。当我们需要编码子组件但希望在编码之前向用户输出响应时，会覆盖此方法。'
- en: Note
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ResponseWriter` object (`FacesContext.getResponseWriter`) contains special
    methods for generating a markup, such as `startElement`, `writeAttribute`, `writeText`,
    and `endElement`.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ResponseWriter` 对象（`FacesContext.getResponseWriter`）包含用于生成标记的特殊方法，例如 `startElement`、`writeAttribute`、`writeText`
    和 `endElement`。'
- en: '`encodeChildren`: This method renders the custom component children. It is
    very rarely overridden; however, if you want to alter the default recursive process
    of encoding component children, then go ahead and override it.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encodeChildren`：此方法渲染自定义组件的子组件。它很少被重写；然而，如果您想改变编码组件子组件的默认递归过程，那么请继续重写它。'
- en: '`encodeEnd`: Probably this is the most overridden method. As its name suggests,
    this method is called at the end. Here, we write the custom markup to the response
    stream. When the custom component accepts end user inputs, the `encodeEnd` is
    preferred against `encodeBegin` because in the case of `encodeBegin`, the inputs
    may not be passed yet through a potential attached converter.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encodeEnd`：这可能是被重写最多的方法。正如其名称所暗示的，此方法在结束时被调用。在这里，我们将自定义标记写入响应流。当自定义组件接受最终用户输入时，`encodeEnd`
    比 `encodeBegin` 更受欢迎，因为在 `encodeBegin` 的情况下，输入可能尚未通过潜在的附加转换器传递。'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The four methods we just discussed are available for all custom components and
    for all renderers. In both cases, they have the same name, and the difference
    between them consists of one argument. When they are overridden in a custom component
    class, they get a single argument representing `FacesContext`. On the other hand,
    when they are overridden in a custom renderer, they get as arguments the `FacesContext`
    instance and the corresponding custom component (`UIComponent`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的四个方法对所有自定义组件和所有渲染器都可用。在两种情况下，它们都有相同的名称，它们之间的区别在于一个参数。当它们在自定义组件类中被重写时，它们获得一个表示
    `FacesContext` 的单个参数。另一方面，当它们在自定义渲染器中被重写时，它们获得 `FacesContext` 实例和相应的自定义组件（`UIComponent`）作为参数。
- en: So we are at a point where we can conclude that a custom component is based
    on a subclass of `UIComponent` and it can render itself or delegate this task
    to a `Renderer` class, which is capable of rendering `UIComponent` instances and
    decoding the POST requests for obtaining user inputs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，自定义组件是基于 `UIComponent` 的子类，并且它可以自行渲染或委托给一个能够渲染 `UIComponent` 实例并解码获取用户输入的
    POST 请求的 `Renderer` 类。
- en: An important aspect of custom components involves managing their state. You
    should already be familiar with the concept of states from [Chapter 9](ch09.html
    "Chapter 9. JSF State Management"), *JSF State Management*. For this reason, we
    can say that JSF 2.0 comes with the `StateHelper` interface, which basically allows
    us to store, read, and remove data across multiple requests (postbacks). This
    means we can use it to preserve states of the components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义组件的一个重要方面是管理它们的状态。您应该已经熟悉从 [第 9 章](ch09.html "第 9 章。JSF 状态管理") *JSF 状态管理*
    中了解的状态概念。因此，我们可以说 JSF 2.0 带来了 `StateHelper` 接口，它基本上允许我们在多个请求（回发）之间存储、读取和删除数据。这意味着我们可以用它来保留组件的状态。
- en: 'It can be a little tricky to understand how to use the `StateHelper` methods
    in conjunction with custom components, but a common example can be useful to clear
    things up. Let''s consider the following custom component usage:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何结合使用 `StateHelper` 方法与自定义组件可能有点棘手，但一个常见的例子可以帮助澄清问题。让我们考虑以下自定义组件的使用示例：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the custom component class, we can easily map these attribute names and
    default values, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义组件类中，我们可以轻松地将这些属性名称和默认值进行映射，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we want to preserve the value of `unitto` under the constant `ATTR_UNITTO`
    (for `temp` it is exactly the same). For this, we use the `StateHelper.put` method,
    as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望在常量 `ATTR_UNITTO` 下保留 `unitto` 的值（对于 `temp` 来说，这完全相同）。为此，我们使用 `StateHelper.put`
    方法，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These examples use the `Object put(Serializable key, Object value)` method,
    but `StateHelper` also has a method `Object put(Serializable key, String mapKey,
    Object value)`, which can be used to store values that would otherwise be stored
    in a `Map` instance variable. Moreover, `StateHelper` has a method named `void
    add(Serializable key, Object value)` that can be used to preserve values which
    would otherwise be stored in a `List` instance variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用 `Object put(Serializable key, Object value)` 方法，但 `StateHelper` 还有一个名为
    `Object put(Serializable key, String mapKey, Object value)` 的方法，可以用来存储那些本应存储在
    `Map` 实例变量中的值。此外，`StateHelper` 还有一个名为 `void add(Serializable key, Object value)`
    的方法，可以用来保留那些本应存储在 `List` 实例变量中的值。
- en: 'Next, you can retrieve the value stored under the `ATTR_UNITTO` constant, as
    shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以检索存储在 `ATTR_UNITTO` 常量下的值，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Object eval(Serializable key, Object defaultValue)` method will search
    for the `ATTR_UNITTO` constant. If it can't find it, then the default value (`ATTR_UNITTO_DEFAULT`)
    is returned. This is a very useful approach because it spears us to perform `null`
    value checks. Besides this method, `StateHelper` also has the `Object eval(Serializable
    key)` and `Object get(Serializable key)` methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object eval(Serializable key, Object defaultValue)` 方法将搜索 `ATTR_UNITTO` 常量。如果找不到，则返回默认值（`ATTR_UNITTO_DEFAULT`）。这是一个非常有用的方法，因为它可以避免我们执行
    `null` 值检查。除了这个方法之外，`StateHelper` 还具有 `Object eval(Serializable key)` 和 `Object
    get(Serializable key)` 方法。'
- en: In order to remove an entry from `StateHelper`, we can call `Object remove(Serializable
    key)` or `Object remove(Serializable key, Object valueOrKey)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 `StateHelper` 中删除条目，我们可以调用 `Object remove(Serializable key)` 或 `Object remove(Serializable
    key, Object valueOrKey)`。
- en: 'At this moment, we have plenty of information that can be translated into code,
    so let''s write a custom component to exemplify the above knowledge. Let''s name
    it the Temperature custom component. Basically, the next custom component will
    expose a public web service as a JSF component. The web service is capable of
    converting the temperature from Celsius to Fahrenheit and vice versa for which
    we need to pass the temperature value and the conversion unit as arguments. Based
    on these two arguments, we can intuit that the corresponding JSF tag will look
    like the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们有很多信息可以转化为代码，所以让我们编写一个自定义组件来举例说明上述知识。让我们称它为温度自定义组件。基本上，下一个自定义组件将公开一个作为
    JSF 组件的公共网络服务。这个网络服务能够将摄氏度转换为华氏度，反之亦然，我们需要传递温度值和转换单位作为参数。基于这两个参数，我们可以直观地推断出相应的
    JSF 标签将类似于以下代码：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can start by implementing a helper class to deal with the web service underlying
    the communication tasks. The name of this class is `TempConvertClient`, and it
    can be seen in the complete application named `ch10_4`. It''s relevant part is
    the declaration of the following method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先实现一个辅助类来处理通信任务背后的网络服务。这个类的名字是 `TempConvertClient`，可以在名为 `ch10_4` 的完整应用程序中看到。它相关部分是以下方法的声明：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Custom component implementation
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义组件实现
- en: 'Now we can focus on the important part for us, the custom component implementation.
    For this we can follow the ensuing steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以专注于对我们来说重要的部分，即自定义组件实现。为此，我们可以遵循以下步骤：
- en: Write a class annotated with `@FacesComponent`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个带有 `@FacesComponent` 注解的类。
- en: Use `StateHelper` to preserve the component's attribute values over multiple
    requests.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `StateHelper` 在多个请求中保留组件的属性值。
- en: Call the `callTempConvertService` method.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `callTempConvertService` 方法。
- en: Render the result.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染结果。
- en: 'The first three steps can be coded as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个步骤可以编码如下：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For step number four there is a hint in the preceding code. If you look carefully
    at the class constructor, you can see that the rendering tasks are delegated to
    an external class (renderer). This class will render a simple styled HTML `div`
    containing the web service response as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，前一段代码中有一个提示。如果你仔细查看类构造函数，你会看到渲染任务被委托给一个外部类（renderer）。这个类将渲染一个包含网络服务响应的简单样式化HTML
    `div`，如下所示：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `@ResourceDependency` and `@ResourceDependencies` annotations are used for
    linked external resources (for example, JavaScript, and CSS) in custom components
    and renderers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ResourceDependency` 和 `@ResourceDependencies` 注解用于自定义组件和渲染器中的链接外部资源（例如，JavaScript
    和 CSS）。'
- en: 'In order to register this class as a `Renderer` class, you need to annotate
    it with `@FacesRenderer` or configure it in `faces-config.xml`, as shown in the
    following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此类注册为`Renderer`类，您需要使用`@FacesRenderer`注解它或在`faces-config.xml`中进行配置，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Another important characteristic of a `Renderer` class consists of the fact
    that it must define a public zero-argument constructor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Renderer`类的一个重要特性是它必须定义一个无参数的公共构造函数。'
- en: Notice that the `<renderer-type>` tag corresponds to the `renderedType` element
    and the `<component-family>` tag corresponds to the `componentFamily` element.
    Moreover, the value of `componentFamily` is the same as the value returned by
    the component's `getFamily` method. A `RenderKit` can provide a `Renderer` instance
    based on this information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`<renderer-type>`标签对应于`renderedType`元素，而`<component-family>`标签对应于`componentFamily`元素。此外，`componentFamily`的值与组件的`getFamily`方法返回的值相同。`RenderKit`可以根据这些信息提供一个`Renderer`实例。
- en: Of course, in this example you can implement the rendering process in the custom
    component class also, since there is no real justification for writing a separate
    class. Usually, you will want to write a separate renderer class when you need
    to support multiple client devices and you need special renderers to be registered
    through a `RenderKit` collection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个例子中，您也可以在自定义组件类中实现渲染过程，因为没有真正的理由要编写一个单独的类。通常，当您需要支持多个客户端设备并且需要通过`RenderKit`集合注册特殊渲染器时，您会想要编写一个单独的渲染器类。
- en: 'The following is an example of code that uses our custom component (the code
    is self explanatory):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例展示了如何使用我们的自定义组件（代码本身具有自解释性）：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, we can provide the conversion unit and temperature as constants
    (if one, or both attributes are missing, then the default value(s) will be used):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将转换单位和温度作为常量提供（如果其中一个或两个属性缺失，则将使用默认值）：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `TempBean` is just a simple backing bean, as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`TempBean`只是一个简单的后端Bean，如下面的代码所示：'
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The complete application is in the code bundle of this chapter under the name
    `ch10_4`. In the following screenshot, you can see the result of running this
    application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序位于本章的代码包中，名称为`ch10_4`。在下面的屏幕截图中，您可以看到运行此应用程序的结果：
- en: '![Custom component implementation](img/6466EN_10_01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![自定义组件实现](img/6466EN_10_01.jpg)'
- en: So, our custom component just renders a `div` block containing the result of
    the temperature conversion. Further, we want to write a custom component that,
    besides this `div`, will render the user interface for collecting data (conversion
    unit and temperature) and submit it through AJAX. In other words, the content
    of the preceding form will be a part of the custom component.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的自定义组件只是渲染一个包含温度转换结果的`div`块。进一步地，我们希望编写一个自定义组件，除了这个`div`之外，它还将渲染用于收集数据（转换单位和温度）的用户界面，并通过AJAX提交。换句话说，前面表单的内容将是自定义组件的一部分。
- en: This time we need to deal with user inputs directly into the custom component,
    which means that our custom component can extend `UIInput` instead of `UIComponentBase`.
    This major change will bring us the advantages of an `UIInput` component. We can
    submit the custom component value (using the `setSubmittedValue` method during
    the decoding process) and obtain the resultant value (using the `getValue` method
    during the encoding (rendering) process).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们需要直接在自定义组件中处理用户输入，这意味着我们的自定义组件可以扩展`UIInput`而不是`UIComponentBase`。这个主要变化将给我们带来`UIInput`组件的优势。我们可以在解码过程中使用`setSubmittedValue`方法提交自定义组件的值，并在编码（渲染）过程中使用`getValue`方法获取结果值。
- en: 'The big problem is that our custom component value is made up of two values:
    the conversion unit and the temperature value. There are a few workarounds to
    solve this kind of issue. In this case, we can simply concatenate these values
    into one, such as the one shown in the following example (*conversion_unit*`/`*temperature*):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大问题在于我们的自定义组件值由两个值组成：转换单位和温度值。有一些解决方案可以解决这个问题。在这种情况下，我们可以简单地将这些值连接成一个，例如以下示例（*conversion_unit*`/`*temperature*）：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can write the custom component class, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写自定义组件类，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we don't need to specify the component family anymore and the `getFamily`
    method is inherited from the `UIInput` class. Going further, we need to write
    the renderer class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再需要指定组件家族，`getFamily`方法是从`UIInput`类继承的。进一步来说，我们需要编写渲染器类。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to allow the component to render itself, use `setRendererType(null)`
    and override the corresponding methods in the component class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要允许组件自行渲染，使用`setRendererType(null)`并覆盖组件类中的相应方法。
- en: 'We need to render four HTML tags (the drop-down list, the input field, the
    button for submit, and the result `div`). For this, we can override the `encodeEnd`
    method, as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要渲染四个HTML标签（下拉列表、输入字段、提交按钮和结果`div`）。为此，我们可以覆盖`encodeEnd`方法，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The identifier of each component was obtained from the client ID of the main
    component (using the `getClientId` method) concatenated with the char naming container
    separator and a string hinting the component type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件的标识符是从主组件的客户端ID（使用`getClientId`方法）拼接上命名容器分隔符和一个表示组件类型的字符串获得的。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, the `NamingContainer` interface (implemented by `UINamingContainer`)
    is queried for obtaining the separator used to separate segments of client ID,
    but its main purpose is to ensure the uniqueness of the components declared within
    it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，查询`NamingContainer`接口（由`UINamingContainer`实现）以获取用于分隔客户端ID段分隔符，但其主要目的是确保其内部声明的组件的唯一性。
- en: 'Next, the method that renders the drop-down component is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，渲染下拉组件的方法如下：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first two lines of this code are important where we extract the conversion
    unit part from the component value, and select the corresponding item in the drop-down
    component.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的前两行很重要，其中我们提取了组件值中的转换单位部分，并在下拉组件中选择了相应的项。
- en: 'Next, we render the input field, as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们渲染输入字段，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we will extract the temperature value from the component value. To accomplish
    this, we render the button labeled **Convert**, which is responsible to submit
    the user input via AJAX as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从组件值中提取温度值。为了完成这个任务，我们渲染了一个标记为**转换**的按钮，该按钮负责通过AJAX提交用户输入，如下所示：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After the user inputs are submitted, we need to render the result obtained
    from the web service:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户输入提交后，我们需要渲染从网络服务获得的结果：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The backing bean, `TempBean`, is pretty simple, as shown in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 后端Bean，`TempBean`，相当简单，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final step involves decoding the user input and submitting it to the component,
    as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步涉及解码用户输入并将其提交给组件，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Done! Now you can see both the tests, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在你可以看到两个测试，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The complete application is present in the code bundle of this chapter under
    the name `ch10_5`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在本章的代码包中，名称为`ch10_5`。
- en: Building composite components
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建组合组件
- en: Maybe the idea behind composite components originates from the fact that JSF
    page authors and JSF component authors have different perspectives regarding components.
    While JSF page authors perceive components as tags that can be used in XHTML pages,
    JSF component authors see components as a mixture of `UIComponent`, `UIComponentBase`,
    `NamingContainer`, `Renderer`, `Validator`, and `Converter` elements—these are
    elements that shape up a JSF component. Based on this, it seems that custom components
    can be written only by JSF component authors, since they have knowledge about
    these JSF elements and Java language. This fact, however, has begun to change
    as of JSF 2 and composite components, which are practically custom components
    written in XHTML pages using markup tags. This means that JSF page authors can
    start writing their components without having the same level of knowledge and
    skills as dedicated JSF component authors—at least, simple, composite components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可能组合组件背后的想法源于JSF页面作者和JSF组件作者对组件的不同看法。虽然JSF页面作者将组件视为可以在XHTML页面中使用的标签，但JSF组件作者将组件视为`UIComponent`、`UIComponentBase`、`NamingContainer`、`Renderer`、`Validator`和`Converter`元素的混合体——这些元素构成了JSF组件。基于此，似乎只有JSF组件作者才能编写自定义组件，因为他们对这些JSF元素和Java语言有了解。然而，从JSF
    2开始，这一事实已经开始改变，组合组件实际上是在XHTML页面中使用标记标签编写的自定义组件。这意味着JSF页面作者可以开始编写他们的组件，而无需具备与专门的JSF组件作者相同水平的知识和技能——至少，简单的组合组件。
- en: 'For example, the skeleton of a JSF 2.2 composite component looks as shown in
    the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，JSF 2.2组合组件的结构如下所示：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The structure is pretty simple! As you can see, there are two main tags that
    belong to the `http://xmlns.jcp.org/jsf/composite` library. The first tag demarcates
    the interface section and represents the component use contract. Here, we can
    define the component's attributes that may be changed by the end user (in principle,
    anything that can be used by the page author). The second tag marks the implementation
    section, which contains the component itself. This will be rendered to the end
    user. Moreover, in this section, we define the component behavior based on the
    attributes defined in the interface section (the use contract implementation).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结构非常简单！正如你所见，有两个主要标签属于`http://xmlns.jcp.org/jsf/composite`库。第一个标签定义了接口部分，表示组件使用合同。在这里，我们可以定义可能被最终用户更改的组件属性（原则上，任何页面作者可以使用的属性）。第二个标签标记了实现部分，其中包含组件本身。这将渲染给最终用户。此外，在这个部分中，我们根据接口部分中定义的属性（使用合同实现）定义组件的行为。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Composite components are basically XHTML pages stored in libraries under the
    `resources` folder (placed as a top-level folder under the web application root
    or under the `META-INF` folder in JARs). Remember that a library is just a subfolder
    of the `resources` folder. Based on this, a composite component path is of type
    `http://xmlns.jcp.org/jsf/composite/`*library_name*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 复合组件基本上是存储在`resources`文件夹下库中的XHTML页面（放置在Web应用程序根目录下的顶级文件夹或JAR中的`META-INF`文件夹下）。记住，库只是`resources`文件夹的子文件夹。基于此，复合组件路径的类型为`http://xmlns.jcp.org/jsf/composite/`*library_name*。
- en: 'So, let''s have a quick test. Remember that the first custom component developed
    in this chapter, `WelcomeComponent`, was built from a class annotated with `@FacesComponent`.
    In that class, we have overridden the `encodeBegin` method for rendering the component.
    Well, now let''s see the same component, but this time as a composite component.
    We store this page under `resources/customs/welcome.xhtml`, as shown in the following
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来做一个快速测试。记住，在本章中首先开发的自定义组件`WelcomeComponent`是从一个带有`@FacesComponent`注解的类构建的。在这个类中，我们重写了`encodeBegin`方法以渲染组件。好的，现在让我们看看同一个组件，但这次是一个复合组件。我们将这个页面存储在`resources/customs/welcome.xhtml`下，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is very simple to make the analogy between the custom component and the composite
    version of it. The important thing here is to notice how attributes were declared
    using the `<cc:attribute>` tag. Besides the name, an attribute can have a type,
    can be required or not, can have a default value, can target component(s), and
    so on (during this chapter, you will have the chance to explore different kinds
    of attributes). As a general rule, JSF determines if the attribute is `MethodExpression`
    (or it has a special name such as `actionListener`, `valueChangeListener`, `action`,
    and so on) or `ValueExpression`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将自定义组件与其复合版本进行类比非常简单。这里重要的是要注意属性是如何使用`<cc:attribute>`标签声明的。除了名称外，属性可以有类型，可以是必需的或非必需的，可以有默认值，可以针对组件，等等（在本章中，你将有机会探索不同类型的属性）。一般来说，JSF确定属性是`MethodExpression`（或者它有如`actionListener`、`valueChangeListener`、`action`等特殊名称）还是`ValueExpression`。
- en: The first case is a little bit tricky; JSF will try to match the attribute with
    the components from the implementation based on the list of IDs defined in the
    `targets` attribute (the list of IDs are separated by space and relative to top-level
    component). If the `targets` attribute is not present, then JSF will take the
    value of the `name` attribute as the client ID (relative to the top-level component)
    and try to find the corresponding component in the implementation section. Well,
    in the simple case, the attribute is a `ValueExpression`, and JSF will just store
    the attribute in the attributes map that is accessible via `UIComponent.getAttributes`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个案例有点棘手；JSF会尝试根据`targets`属性中定义的ID列表（ID列表由空格分隔，相对于顶级组件）将属性与实现中的组件进行匹配。如果不存在`targets`属性，那么JSF将`name`属性的值作为客户端ID（相对于顶级组件）并尝试在实现部分中找到相应的组件。嗯，在简单的情况下，属性是一个`ValueExpression`，JSF将只将属性存储在可通过`UIComponent.getAttributes`访问的属性映射中。
- en: In the implementation section, the attributes are used via the `#{cc}` implicit
    object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现部分，通过`#{cc}`隐含对象使用属性。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It may be useful to know that JSF will implicitly create a top-level component
    for all the components that form a composite component. This component is the
    parent of all components in the page and is named `UINamingContainer` (available
    through the `UIComponent.getNamingContainer` method). Now the `#{cc}` implicit
    object actually refers to this top-level component and can be used to obtain various
    information, but it is especially used for obtaining the client ID (`#{cc.clientId}`)
    and for accessing the composite component attributes (`#{cc.attrs}`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要知道，JSF会隐式地为所有构成复合组件的组件创建一个顶级组件。这个组件是页面中所有组件的父组件，命名为`UINamingContainer`（通过`UIComponent.getNamingContainer`方法可用）。现在，`#{cc}`隐式对象实际上指的是这个顶级组件，可以用来获取各种信息，但它特别用于获取客户端ID（`#{cc.clientId}`）和访问复合组件属性（`#{cc.attrs}`）。
- en: 'Now it''s time to test our composite component. This is very easy—just import
    the composite namespace, set a prefix, and start using it, as shown in the following
    code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试我们的复合组件了。这非常简单——只需导入复合命名空间，设置一个前缀，然后开始使用它，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Learning the techniques for writing composite components can be achieved
    by a lot of practice. This is why, in the upcoming sections you will see several
    types of composite components that explore different kinds of implementations.**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过大量实践学习编写复合组件的技术。这就是为什么在接下来的章节中，您将看到几种不同类型的复合组件，它们探索了不同的实现方式。**'
- en: '**The complete application is named `ch10_6`.**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的应用程序命名为`ch10_6`。**'
- en: '**Developing the Temperature composite component**'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**开发温度复合组件**'
- en: '**Starring: backing component**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**主演：后端组件**'
- en: '**Remember the Temperature custom component that we implemented in the preceding
    section? Well, we are sure you do. So let''s see how to develop a composite component
    that looks and behaves the same. The composite component page can be named `temperature.xhtml`,
    and we can store it in the `temperature` folder under the `resources` folder.
    First, let''s see it in the following code; afterwards we can dissect it:**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**还记得我们在上一节中实现的温度自定义组件吗？好吧，我们确信您记得。那么，让我们看看如何开发一个看起来和表现相同的复合组件。复合组件页面可以命名为`temperature.xhtml`，我们可以将其存储在`resources`文件夹下的`temperature`文件夹中。首先，让我们在下面的代码中看看它；然后我们可以分析它：**'
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**In the interface section, we have defined the attribute named `value`, which
    is specific to an `UIInput` component. Further, we indicate that the accepted
    value is of type `String` and the default value, applicable when the attribute
    is missing, is `celsius/0`. Usually, the `type` attribute is used to link the
    element(s) to the bean''s properties (for its value, use the fully qualified name,
    as shown in the preceding code).**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**在接口部分，我们定义了一个名为`value`的属性，这是针对`UIInput`组件的。进一步地，我们指出接受值为`String`类型，当属性缺失时，默认值为`celsius/0`。通常，`type`属性用于将元素（们）链接到bean的属性（对于其值，使用完全限定名，如前述代码所示）。**'
- en: '**The implementation section is more interesting, because here we need to define
    the subcomponents of our component: the drop-down menu, the input field, the submit
    button, and the result div (notice that JSF generates an HTML `<div>` from `<h:panelGroup
    layout="block"/>`). When your composite component contains multiple components,
    it is a good practice to place them inside a `<div>` or a `<span>` tag with the
    ID set to `#{cc.clientId}`. This ID is the client identifier of the composite
    itself and is useful when the page author needs to refer to the entire composite
    component via a simple ID.**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现部分更有趣，因为在这里我们需要定义我们组件的子组件：下拉菜单、输入字段、提交按钮和结果div（注意JSF从`<h:panelGroup layout="block"/>`生成一个HTML
    `<div>`）。当您的复合组件包含多个组件时，将它们放置在ID设置为`#{cc.clientId}`的`<div>`或`<span>`标签内是一个好习惯。这个ID是复合组件本身的客户端标识符，当页面作者需要通过一个简单的ID引用整个复合组件时非常有用。**'
- en: '**External resources, such as CSS and JS, don''t need any special treatment.
    You can place them under the same library with composite components or under any
    other library, and you can load them using `<h:outputScript>` and `<h:outputStylesheet>`.**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部资源，如CSS和JS，不需要任何特殊处理。您可以将它们放置在与复合组件相同的库中，或者放置在任何其他库中，并且可以使用`<h:outputScript>`和`<h:outputStylesheet>`来加载它们。**'
- en: '**After a quick look, an obvious question arises: where is the implementation
    of the `getTempConvert` method and the backing beans properties used for linking
    these components according to the `binding` attribute? Well, all these are in
    a Java class, known as **backing component** (do not confuse this with the backing
    bean!). Yes, I know that earlier I said composite components don''t need Java
    code, but sometimes they do, like in this case, where we need to write the code
    for calling the web service! In order to write a backing component, you need to
    keep in mind the following steps:**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速查看后，一个明显的问题出现了：`getTempConvert`方法的实现和用于根据`binding`属性链接这些组件的后端bean属性在哪里？好吧，所有这些都在一个Java类中，称为**后端组件**（不要与后端bean混淆！）。是的，我知道我之前说过复合组件不需要Java代码，但有时它们确实需要，就像在这个案例中，我们需要编写调用Web服务的代码！为了编写后端组件，您需要记住以下步骤：**'
- en: '**Annotate the backing component with `@FacesComponent`**'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用`@FacesComponent`注解标注后端组件**'
- en: '**Extend `UINamingContainer` or implement `NamingContainer` and override the
    `getFamily` method as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扩展`UINamingContainer`或实现`NamingContainer`并覆盖`getFamily`方法如下：**'
- en: '[PRE32]**'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE32]**'
- en: '**Link the composite component with the backing component by adding the `componentType`
    attribute to the `<cc:interface>` tag. The value of this attribute is the component-type
    (this tells JSF to create an instance of the class indicated here):'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过向`<cc:interface>`标签添加`componentType`属性将复合组件与后端组件链接。此属性的值是组件类型（这告诉JSF创建此处指示的类的实例）**'
- en: '[PRE33]**'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE33]**'
- en: '**Note**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**A backing component can define getters for exposing its properties via the
    `#{cc}` implicit object (`#{cc}` has access to action methods also). On the other
    hand, the `<cc:attribute>` attributes are available in a backing component via
    the `UIComponent.getAttributes` method.**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**后端组件可以定义getter来通过`#{cc}`隐式对象（`#{cc}`可以访问操作方法）公开其属性。另一方面，`<cc:attribute>`属性可以通过`UIComponent.getAttributes`方法在后端组件中访问。**'
- en: '**Keeping these in mind, the backing component for our composite component
    is as follows:**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑到这些，我们的复合组件的后端组件如下：**'
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**The story of our backing component is pretty clear. In the `encodeBegin`
    method, we ensure that the component value is parsed and each subcomponent (the
    dropdown and the input field) received the correct part of the value. When the
    user submits the data, we deal with it in the `encode` method, where we take the
    value of the dropdown and of the input field and build a string of type *conversion_unit*`/`*temperature*.
    This becomes the submitted value.**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们的后端组件的故事相当清晰。在`encodeBegin`方法中，我们确保组件值被解析，并且每个子组件（下拉列表和输入字段）都收到了正确的值部分。当用户提交数据时，我们在`encode`方法中处理它，其中我们获取下拉列表和输入字段的值，并构建一个类型为`conversion_unit``/``temperature`的字符串。这成为提交的值。**'
- en: '**This is a good time to point out how JSF chooses the top-level component.
    JSF tries to do the following:**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在是指出JSF如何选择顶级组件的好时机。JSF试图做以下事情：**'
- en: '**Locate the `componentType` attribute in the `<cc:interface>` tag. If it is
    present, then the backing component is instantiated and used as a top-level component.
    This is the case with the Temperature composite component.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在`<cc:interface>`标签中定位`componentType`属性。如果存在，则后端组件将被实例化并用作顶级组件。这就是温度复合组件的情况。**'
- en: '**Locate a `UIComponent` implementation that fits the composite component page.
    This can be a Groovy script with the same name and location as the composite component
    page (of course, with the `.groovy` extension).**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定位一个与复合组件页面相同名称和位置的`UIComponent`实现。这可以是一个与复合组件页面同名同地的Groovy脚本（当然，带有`.groovy`扩展名）。**'
- en: '**Locate a Java class named *component_library_name.composite_component_page_name*
    and instantiate it as a top-level component. This approach spears us to use `@FacesComponent`.**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定位一个名为`component_library_name.composite_component_page_name`的Java类，并将其实例化为顶级组件。这种方法使我们能够使用`@FacesComponent`。**'
- en: '**Generate a component with the component type `javax.faces.NamingContainer`.**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成一个类型为`javax.faces.NamingContainer`的组件。**'
- en: '**The complete application is named `ch10_8`. Based on the knowledge introduced
    through this didactical example, you can check out another example, named Timezone,
    as shown in the following screenshot. The complete application is named `ch10_25`.**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的应用程序命名为`ch10_8`。基于通过这个教学示例引入的知识，您可以查看另一个名为时区的示例，如下截图所示。完整的应用程序命名为`ch10_25`。**'
- en: '**![Developing the Temperature composite component](img/6466EN_10_02.jpg)**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**![开发温度复合组件](img/6466EN_10_02.jpg)**'
- en: '**Transforming a jQuery component into composite component**'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**将jQuery组件转换为复合组件**'
- en: '**Starring: JavaScript closures**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**亮点：JavaScript闭包**'
- en: '**The jQuery UI is a great collection of user interface interactions, effects,
    widgets, and themes built on top of the jQuery JavaScript library. In this section,
    you will see how to expose a jQuery component as a JSF composite component. More
    precisely, we will transform the jQuery range slider ([https://jqueryui.com/slider/#range](https://jqueryui.com/slider/#range)),
    as shown in the following screenshot:**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**jQuery UI是在jQuery JavaScript库之上构建的出色的用户界面交互、效果、小部件和主题集合。在本节中，你将了解如何将jQuery组件公开为JSF复合组件。更确切地说，我们将转换jQuery范围滑块([https://jqueryui.com/slider/#range](https://jqueryui.com/slider/#range))，如下面的截图所示：**'
- en: '**![Transforming a jQuery component into composite component](img/6466EN_10_03.jpg)**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**![将jQuery组件转换为复合组件](img/6466EN_10_03.jpg)**'
- en: '**The main code behind this component is listed as follows:**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**此组件背后的主要代码如下所示：**'
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**The JSF composite component should look like the following code (the important
    part is highlighted):**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSF复合组件应如下所示（重要部分已突出显示）：**'
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**We can start by defining the composite component attributes. These will allow
    the end user to set the minimum (`min` attribute), maximum (`max` attribute) and
    the initial range (`leftside` and `rightside` attributes). These attributes will
    be declared in the interface section, as shown in the following code:**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们可以从定义复合组件属性开始。这些属性将允许最终用户设置最小值（`min`属性）、最大值（`max`属性）和初始范围（`leftside`和`rightside`属性）。这些属性将在接口部分声明，如下面的代码所示：**'
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**The implementation section can be divided into three logical parts. In the
    first part we define the external resources (CSS and JS files). Notice that `<h:outputScript>`
    and `<h:outputStylesheet>` cannot load such resources for an absolute URL (`http://...`),
    so you need to have these resources on your local machine:**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现部分可以分为三个逻辑部分。在第一部分中，我们定义外部资源（CSS和JS文件）。请注意，`<h:outputScript>`和`<h:outputStylesheet>`不能为绝对URL（`http://...`）加载此类资源，因此你需要将这些资源放在你的本地机器上：**'
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**In the second part, we render the divs that expose the range slider. For
    this, we follow the exact model of the original component, but we add our attributes,
    `leftside` and `rightside`, as shown in the following code:**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**在第二部分，我们渲染显示范围滑块的div。为此，我们遵循原始组件的精确模型，但添加了我们的属性`leftside`和`rightside`，如下面的代码所示：**'
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**While the `min` and `max` attributes can be set to certain values, we are
    especially interested in the `leftside` and `rightside` attributes, which should
    be treated as the end user inputs. For this, we have added two hidden fields (one
    for `leftside` and one for `rightside`) that can easily transport this information
    to the server.**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**虽然`min`和`max`属性可以设置为特定值，但我们特别关注`leftside`和`rightside`属性，它们应被视为最终用户的输入。为此，我们添加了两个隐藏字段（一个用于`leftside`，一个用于`rightside`），可以轻松地将此信息传输到服务器。**'
- en: '**In the third part, we need to adapt the JavaScript code, which represents
    the component engine. This code has to be correctly generated when multiple range
    sliders are added in the same page, so we need to modify it as follows to fit
    the correct IDs and attribute values:**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**在第三部分，我们需要调整代表组件引擎的JavaScript代码。当在同一页面上添加多个范围滑块时，此代码必须正确生成，因此我们需要按以下方式修改它以适应正确的ID和属性值：**'
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Note**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**A common issue of combining JSF and jQuery involves using the colon (`:`).
    While JSF uses it as a separator of ID segments, the jQuery selector has other
    jobs for it. In order to work in jQuery, we need to escape the colon. This can
    be easily accomplished if you use a PrimeFaces method, as shown in the following
    code:**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**将JSF和jQuery结合使用时，一个常见问题涉及使用冒号（`:`）。虽然JSF将其用作ID段分隔符，但jQuery选择器有其他用途。为了在jQuery中工作，我们需要转义冒号。如果你使用PrimeFaces方法，这可以很容易地完成，如下面的代码所示：**'
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Done! Now you can test the composite component in your page. The complete
    application is named `ch10_11`.**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成！现在你可以在你的页面上测试复合组件。完整的应用程序命名为`ch10_11`。**'
- en: '**Well, if you add multiple range sliders in the page, you will see that the
    preceding JavaScript code will be generated and added each time. The size of this
    code is insignificant, and the chances that you''ll need multiple range sliders
    in the same page are pretty small, so it will not be a big issue. But, when such
    an issue arises, you need to know that there are a few workarounds for it.**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**好吧，如果您在页面中添加多个范围滑块，您将看到前面的 JavaScript 代码每次都会生成并添加。这段代码的大小微不足道，您在同一页面上需要多个范围滑块的可能性很小，所以这不会是一个大问题。但是，当出现这样的问题时，您需要知道有一些解决方案。**'
- en: '**For example, we can take out JavaScript from the composite component and
    place it into the page, or as a component should be self contained it would be
    better to place the code in a separate JavaScript file and reference it in the
    composite component with `<h:outputScript>`. After that, we parameterize the JavaScript
    code with the desired attributes, and call it from the composite component. So,
    the parameterized version might look like the following code (place this in a
    file named `slider.js`):**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**例如，我们可以将 JavaScript 从复合组件中提取出来并放置到页面中，或者作为一个应该自包含的组件，最好是将代码放置到一个单独的 JavaScript
    文件中，并在复合组件中使用 `<h:outputScript>` 引用它。之后，我们使用期望的属性参数化 JavaScript 代码，并从复合组件中调用它。因此，参数化版本可能看起来像以下代码（将此代码放入名为
    `slider.js` 的文件中）：**'
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Further, we adapt the composite component implementation section for calling
    the following reusable JavaScript code:**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步，我们调整了复合组件实现部分以调用以下可重用 JavaScript 代码：**'
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Probably you already know that you just saw a technique of JavaScript closures.
    The idea is to speculate the fact that JavaScript is a dynamic language that lets
    us modify the DOM at runtime. Using the JSF client identifier and this JavaScript
    capability can help us to solve the issue of repeating code for multiple components.
    Sometimes, a good practice is to place the entire composite component inside a
    `div` element whose ID is the JSF client identifier. Moreover, you can identify
    and manage each `div` content directly from JavaScript.**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**可能您已经看到了 JavaScript 闭包的技术。这个想法是推测 JavaScript 是一种动态语言，它允许我们在运行时修改 DOM。使用 JSF
    客户端标识符和这种 JavaScript 功能可以帮助我们解决为多个组件重复代码的问题。有时，一个好的做法是将整个复合组件放在一个 ID 为 JSF 客户端标识符的
    `div` 元素中。此外，您可以直接从 JavaScript 中识别和管理每个 `div` 的内容。**'
- en: '**The complete application for this example is named `ch10_9`. If you want
    to place the JavaScript code directly into the page, check the application named
    `ch10_26`. Besides this application, another complete example of using JavaScript
    closures is named `ch10_7`. In this example, a composite component encapsulates
    an HTML5 SSE (Server-sent Events) example. For those who are not familiar with
    SSE, a good starting point is the tutorial at [http://www.html5rocks.com/en/tutorials/eventsource/basics/](http://www.html5rocks.com/en/tutorials/eventsource/basics/).**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**本例的完整应用程序命名为 `ch10_9`。如果您想直接将 JavaScript 代码放入页面中，请检查名为 `ch10_26` 的应用程序。除了这个应用程序之外，另一个使用
    JavaScript 闭包的完整示例应用程序命名为 `ch10_7`。在这个例子中，一个复合组件封装了一个 HTML5 SSE（服务器端事件）示例。对于那些不熟悉
    SSE 的人来说，一个好的起点是 [http://www.html5rocks.com/en/tutorials/eventsource/basics/](http://www.html5rocks.com/en/tutorials/eventsource/basics/)
    上的教程。**'
- en: '**Writing the HTML5 date picker as a composite component**'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**将 HTML5 日期选择器编写为复合组件**'
- en: '**Starring: `<cc:clientBehavior>` and `<cc:insertChildren />`**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**主演：`<cc:clientBehavior>` 和 `<cc:insertChildren />`**'
- en: '**In this section, you will see how to transform the HTML5 date picker component
    into a composite component. There are a few attributes that allow us to customize
    the native date picker component. The following is a list of three examples:**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本节中，您将了解如何将 HTML5 日期选择器组件转换为复合组件。有一些属性允许我们自定义原生日期选择器组件。以下是一个包含三个示例的列表：**'
- en: '**The code for the simplest case is as follows:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最简单情况的代码如下：**'
- en: '[PRE44]**'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE44]**'
- en: '**The code for the constrained date picker is as follows:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**约束日期选择器的代码如下：**'
- en: '[PRE45]**'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE45]**'
- en: '**The code for the date picker with data list is as follows:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有数据列表的日期选择器的代码如下：**'
- en: '[PRE46]**'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE46]**'
- en: '**Our composite component should reflect these forms, so it might look like
    the following code:**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们的复合组件应该反映这些形式，所以它可能看起来像以下代码：**'
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Alternatively, use a data list, as shown in the following code:**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**或者，使用数据列表，如下面的代码所示：**'
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**So, let''s focus on the interface definition. First, we have a set of attributes
    that are very easy to define, such as `value`, `list`, `step`, `required`, and
    `readonly`:**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**那么，让我们专注于接口定义。首先，我们有一组很容易定义的属性，例如`value`、`list`、`step`、`required`和`readonly`：**'
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**This was easy! Now we need to take a closer look at the `min` and `max` attributes,
    which delimitate the range of selection. Practically, they are just some dates,
    but NOT instances of `java.util.Date`, because their format is specific to HTML
    5 (y-m-d), not to Java. This means that we need some Java code for accomplishing
    the conversion from Java date format to HTML5 date format. We need a backing component
    to do this (notice that we can''t use any converter here):**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**这很简单！现在我们需要更仔细地看看`min`和`max`属性，它们定义了选择范围。实际上，它们只是一些日期，但不是`java.util.Date`的实例，因为它们的格式是HTML
    5特有的（y-m-d），而不是Java。这意味着我们需要一些Java代码来完成从Java日期格式到HTML5日期格式的转换。我们需要一个后端组件来完成这个任务（注意，我们在这里不能使用任何转换器）：**'
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Of course, we don''t forget to indicate the backing component in the interface
    and the restriction selection attributes, which can now be declared as `java.util.Date`,
    as shown in the following code:**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**当然，我们不会忘记在接口和限制选择属性中指明后端组件，现在这些属性可以声明为`java.util.Date`，如下面的代码所示：**'
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**We need to do one more thing in the interface. When the end user selects
    a date, we want it to be submitted via AJAX to a backing bean. For this, we need
    to allow him/her to attach a client behavior (we spoke about client behavior several
    times in this book, but a perfect tutorial can be found at DZone, [http://java.dzone.com/articles/jsf-2-client-behaviors](http://java.dzone.com/articles/jsf-2-client-behaviors)),
    and for this we need the `<cc:clientBehavior>` tag, as shown in the following
    code. The `name` attribute contains the name of the event that will listen (for
    example, `change` here) and the `targets` attribute indicates the component(s)
    from the implementation, which will support the declared JavaScript event via
    the `event` attribute (do not use the prefix `on` for JavaScript events).**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**在接口中我们还需要做一件事。当最终用户选择一个日期时，我们希望它通过AJAX提交给后端bean。为此，我们需要允许他/她附加客户端行为（我们在本书中多次提到了客户端行为，但一个完美的教程可以在DZone找到，[http://java.dzone.com/articles/jsf-2-client-behaviors](http://java.dzone.com/articles/jsf-2-client-behaviors))，为此我们需要使用`<cc:clientBehavior>`标签，如下面的代码所示。`name`属性包含将监听的事件名称（例如，这里的`change`）和`targets`属性指示实现中的组件（哪些组件）将通过`event`属性支持声明的JavaScript事件（JavaScript事件不要使用`on`前缀）。**'
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**So far, the interface is ready! Going further, we need an implementation.
    This is pretty simple and is based on JSF 2.2 pass-through elements, as shown
    in the following code:**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**到目前为止，接口已经准备好了！进一步来说，我们需要一个实现。这很简单，基于JSF 2.2的透传元素，如下面的代码所示：**'
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Note**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**In order to have an easy way to reference `<datalist>`, we used `#{cc.id}`.
    If the component is used multiple times in a page, then you have to specify a
    unique ID for each use. Nevertheless, if you need a clean solution that avoids
    nonunique IDs in the rendered XHTML document, you might require some additional
    ID resolving to be done (with JavaScript or in a backing component for instance).**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了方便引用`<datalist>`，我们使用了`#{cc.id}`。如果组件在页面中被多次使用，那么你必须为每次使用指定一个唯一的ID。不过，如果你需要一个干净的解决方案，避免在渲染的XHTML文档中出现非唯一ID，你可能需要做一些额外的ID解析（例如使用JavaScript或在后端组件中完成）。**'
- en: '**At this moment, we can use our composite component, except the data list
    (see the preceding HTML5 `<datalist>`). For this, we need to write two more composite
    components. As you can see, a data list is just a set of several options (items)
    and each option has two attributes, named `label` and `value`. So, we can easily
    encapsulate an option in a composite component, as shown in the following code:**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**在这个时候，我们可以使用我们的复合组件，除了数据列表（参见前面的HTML5 `<datalist>`）。为此，我们需要编写两个额外的复合组件。正如你所看到的，数据列表只是一组选项（项目），每个选项有两个属性，分别命名为`label`和`value`。因此，我们可以很容易地将一个选项封装在一个复合组件中，如下面的代码所示：**'
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Now we need to nest several options in `<datalist>`, but this is inappropriate
    here, because the number of options is indeterminate. Fortunately, for these kinds
    of situations, JSF provides the `<cc:insertChildren>` tag, which is used to insert
    the child component within a parent component (the child components will be automatically
    re-parented by JSF). Knowing this, we can write the following composite component
    for `<datalist>`:**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们需要在 `<datalist>` 中嵌套几个选项，但在这里这不合适，因为选项的数量是不确定的。幸运的是，对于这类情况，JSF 提供了 `<cc:insertChildren>`
    标签，它用于在父组件（们）内插入子组件（子组件将由 JSF 自动重新设置父组件）。了解这一点后，我们可以为 `<datalist>` 编写以下复合组件：**'
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Note**'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**Use the `<datalist>` tag only in `<cc:implementation>` and be careful to
    avoid duplicate ID errors. In order to avoid this, it is recommended that you
    use this tag only once. To find out the number of children, use `#{cc.childCount}`.**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅在 `<cc:implementation>` 中使用 `<datalist>` 标签，并小心避免重复 ID 错误。为了避免这种情况，建议您只使用此标签一次。要找出子组件的数量，请使用
    `#{cc.childCount}`。**'
- en: '**Done! Now you can try to test the complete application named `ch10_12`.**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成！现在你可以尝试测试名为 `ch10_12` 的完整应用程序了。**'
- en: '**Note**'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**For the sake of completeness, you can treat the case when the browser doesn''t
    support HTML5 by getting back to the jQuery UI version of this component. This
    can be accomplished via the Modernizr library ([http://modernizr.com/](http://modernizr.com/)),
    which is able to detect this kind of issue. From our point of view, such browsers
    will be obsolete in the future, so we don''t think the effort to add this check
    and fallback is justified.**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了完整性，你可以处理浏览器不支持 HTML5 的情况，通过回到这个组件的 jQuery UI 版本。这可以通过 Modernizr 库（[http://modernizr.com/](http://modernizr.com/)）来完成，该库能够检测这类问题。从我们的观点来看，这类浏览器在未来将会过时，所以我们认为添加这个检查和回退的工作是不必要的。**'
- en: '**Decorating an image with actions**'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**使用动作装饰图像**'
- en: '**Starring: `<cc:actionSource>`, Java `enum` types**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**主演：`<cc:actionSource>`，Java `enum` 类型**'
- en: '**Composite components are amazing because they can transform simple things
    into a real powerful component. For example, in this section we will decorate
    a simple image to become a composite component with AJAX and action capabilities
    by adding action and action listener support. Moreover, we will force the page
    author to use only a range of values for a certain attribute.**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**复合组件非常神奇，因为它们可以将简单的事物转换成真正的强大组件。例如，在本节中，我们将通过添加动作和动作监听器支持，将一个简单的图像装饰成一个具有
    AJAX 和动作能力的复合组件。此外，我们将强制页面作者只使用一定范围内的值来设置某个属性。**'
- en: '**First, we take care of the interface section, and we can start by declaring
    an attribute that represents the image location, as shown in the following code:**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**首先，我们处理接口部分，我们可以从声明一个表示图像位置的属性开始，如下面的代码所示：**'
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**After this quick warm up, we can declare the `action` attribute. The page
    author will use this attribute to indicate an `action` method of a backing bean.
    Notice that the `action` method signature must be declared here, as shown in the
    following code:**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**在这短暂的预热之后，我们可以声明 `action` 属性。页面作者将使用此属性来指示后端 Bean 的 `action` 方法。请注意，`action`
    方法签名必须在这里声明，如下面的代码所示：**'
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**When you write a method signature, you need to indicate the return type (`void`
    in this case), the method name and the argument types. For example, an `action`
    method that returns `String` and gets two `Integer` arguments will be declared
    as follows:**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你编写方法签名时，你需要指明返回类型（在这种情况下为 `void`），方法名和参数类型。例如，一个返回 `String` 并接受两个 `Integer`
    参数的 `action` 方法将被声明如下：**'
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**Furthermore, we add support for the `<f:actionListener>` tag. For this, we
    use the `<cc:actionSource>` tag as follows:**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**此外，我们添加了对 `<f:actionListener>` 标签的支持。为此，我们使用 `<cc:actionSource>` 标签如下：**'
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**The value of the `name` attribute will be used by the page authors as the
    value for the `<f:actionListener>` `for` attribute. The `targets` attribute points
    the component(s) from the implementation section, which receives this capability.**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**`name` 属性的值将被页面作者用作 `<f:actionListener>` 的 `for` 属性的值。`targets` 属性指向实现部分中的组件（们），这些组件接收这个能力。**'
- en: '**Note**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**The `<cc:actionSource>` tag specifies the implementation of `ActionSource2`.**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<cc:actionSource>` 标签指定了 `ActionSource2` 的实现。**'
- en: '**Next, we declare a client behavior using the `<cc:clientBehavior>` tag as
    follows:**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**接下来，我们使用 `<cc:clientBehavior>` 标签声明一个客户端行为，如下所示：**'
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**As the final touch, we add an attribute that will accept only a range of
    values, as shown in the following code:**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**作为最后的润色，我们添加了一个只能接受一系列值的属性，如下面的代码所示：**'
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**The interface section is ready, so let''s focus on the implementation section.
    For a better understanding, let''s have a look at it as follows:**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口部分已经准备好了，让我们专注于实现部分。为了更好地理解，让我们如下查看：**'
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**There are a few interesting points here! Let''s dissect the code from the
    inside to the outside in the following points:**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**这里有几个有趣的地方！让我们以下面的几个点从内到外剖析代码：**'
- en: '**First, the image is loaded in JSF classic style through the `<h:graphicImage>`
    tag. Nothing fancy here!**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首先，图像通过JSF经典样式中的`<h:graphicImage>`标签加载。这里没有太多花哨的东西！**'
- en: '**The `<h:graphicImage>` tag is nested in a `<h:commandLink>` tag, which supports
    action and action listener capabilities. Notice that this component is targeted
    from the interface section. Moreover, we nest a hidden field here (`<h:inputHidden>`)
    that associates (holds) a value with our image. This value comes from a range
    of allowed values via the `item` attribute.**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`<h:graphicImage>`标签嵌套在`<h:commandLink>`标签中，该标签支持动作和动作监听器功能。请注意，这个组件是从接口部分定位的。此外，我们在其中嵌套了一个隐藏字段（`<h:inputHidden>`），它与我们的图像关联（持有）一个值。这个值通过`item`属性从一系列允许的值中获取。**'
- en: '**The `<h:commandLink>` tag is nested in a `<h:form>` tag and everything is
    added into a `<div>` tag. Notice that, usually, it is not a good practice to add
    `<h:form>` in a composite component, since the page author may want to use the
    composite component in his/her `<h:form>`. This will lead to nested forms, which
    leads to invalid HTML code.**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`<h:commandLink>`标签嵌套在`<h:form>`标签中，所有内容都添加到`<div>`标签中。请注意，通常在组合组件中添加`<h:form>`不是一个好习惯，因为页面作者可能希望在他的/她的`<h:form>`中使用组合组件。这将导致嵌套表单，从而导致无效的HTML代码。**'
- en: '**In order to restrict an attribute value to a range of values, you may think
    of using Java enum types. The problem is that you cannot do that in the interface
    section, but you can add a check in the implementation section. For example, we
    choose not to render the composite component when the value of the `item` attribute
    is different from `item_1`, `item_2`, and `item_3`.**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为了将属性值限制在一系列值范围内，你可能想到使用Java枚举类型。问题是，你无法在接口部分这样做，但你可以在实现部分添加检查。例如，我们选择在`item`属性的值不是`item_1`、`item_2`和`item_3`时，不渲染组合组件。**'
- en: '**The composite component is ready for testing. A perfect example can be seen
    in the code bundle of this chapter under the name `ch10_18`. Based on the same
    principle, we have written another example under the name `ch10_13`.**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合组件已经准备好测试。一个完美的例子可以在本章的代码包中看到，名称为`ch10_18`。基于同样的原则，我们编写了另一个名为`ch10_13`的例子。**'
- en: '**Working with composite facets**'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**与组合面交互**'
- en: '**Starring: `<cc:facet>`, `<cc:renderFacet>`, and `<cc:insertFacet>`**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**主演：`<cc:facet>`、`<cc:renderFacet>`和`<cc:insertFacet>`**'
- en: '**A composite component contains the facets definition in the interface section.
    For this, we need to use the `<cc:facet>` tag and to specify at least the facet
    name through the `name` attribute, as shown in the following code:**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合组件在接口部分包含面定义。为此，我们需要使用`<cc:facet>`标签，并通过`name`属性指定至少一个面名，如下面的代码所示：**'
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Once the facets are declared in the interface section, they can be used in
    the implementation section via the `<cc:renderFacet>` tag. For this tag, we need
    to specify which facet to be rendered, by setting the value of the `name` attribute
    in agreement with the corresponding facet defined in the interface section, as
    shown in the following code:**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**一旦在接口部分声明了面，它们可以通过`<cc:renderFacet>`标签在实现部分使用。对于这个标签，我们需要指定要渲染哪个面，通过设置`name`属性的值与接口部分中定义的相应面相一致，如下面的代码所示：**'
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**That''s all! You can see a complete example in the code bundle of this chapter
    under the name `ch10_14`.**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就结束了！你可以在本章的代码包中看到完整的示例，名称为`ch10_14`。**'
- en: '**Besides `<cc:renderFacet>`, a composite component supports the `<cc:insertFacet>`
    tag. Now things become more interesting, because a common question is, what is
    the difference between them? The best answer will come from an example. Let''s
    take a simple composite component that uses `<cc:renderFacet>`, as shown in the
    following code:**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**除了`<cc:renderFacet>`之外，组合组件还支持`<cc:insertFacet>`标签。现在事情变得更有趣了，因为一个常见的问题是，它们之间有什么区别？最好的答案将来自一个例子。让我们看看以下代码中一个简单的使用`<cc:renderFacet>`的组合组件：**'
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**This will render correctly through the following usage:**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下用法可以正确渲染：**'
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**However, replacing `<cc:renderFacet>` with `<cc:insertFacet>` will not work.
    Nothing will be rendered.**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**然而，将 `<cc:renderFacet>` 替换为 `<cc:insertFacet>` 也不会起作用。将不会渲染任何内容。**'
- en: '**Now let''s take a look at the following composite component that uses `<cc:insertFacet>`:**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在让我们看看以下使用 `<cc:insertFacet>` 的复合组件：**'
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '**The following code snippet will render the desired result:**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下代码片段将渲染所需的结果：**'
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**But again, replacing `<cc:insertFacet>` with `<cc:renderFacet>` will not
    work. Nothing will be rendered.**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**但是，再次强调，将 `<cc:insertFacet>` 替换为 `<cc:renderFacet>` 不会起作用。将不会渲染任何内容。**'
- en: '**So, we can conclude that `<cc:renderFacet>` is useful for rendering facets
    as child components of the composite component. This means that `<cc:renderFacet>`
    allows us to render facets when the parent component doesn''t support facets;
    the facet name can be any accepted string. On the other hand, `<cc:insertFacet>`
    allows us to render facets only in components that support facets. Here, the facet
    name must exist in the facet map of the top-level component. The facet is inserted
    as a facet child of the component in which this element is nested.**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**因此，我们可以得出结论，`<cc:renderFacet>` 对于将方面作为复合组件的子组件进行渲染非常有用。这意味着 `<cc:renderFacet>`
    允许我们在父组件不支持方面时渲染方面；方面名称可以是任何接受的字符串。另一方面，`<cc:insertFacet>` 允许我们仅在支持方面的组件中渲染方面。在这里，方面名称必须存在于顶级组件的方面映射中。方面作为嵌套此元素的组件的方面子组件被插入。**'
- en: '**The complete application is named `ch10_17`.**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的应用程序命名为 `ch10_17`。**'
- en: '**Validating/converting inputs inside composite components**'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**在复合组件内验证/转换输入**'
- en: '**Starring: `<cc:editableValueHolder>`**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**重点：`<cc:editableValueHolder>`**'
- en: '**Let''s take a quick look at a simple composite component in the following
    code, especially at the highlighted parts:**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们快速查看以下代码中的简单复合组件，特别是突出显示的部分：**'
- en: '[PRE69]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**Now we write a page that uses this component and attaches a custom converter
    and a custom validator to it as follows:**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们编写一个使用此组件并附加自定义转换器和自定义验证器的页面，如下所示：**'
- en: '[PRE70]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '**Everything works as expected, thanks to `<cc:editableValueHolder>`. In this
    case, this tag tells JSF that any converter/validator that has the value of the
    `for` attribute equal to `playerId` should be applied to the targeted components,
    `nameId` and `surnameId`. Generally speaking, `< cc:editableValueHolder>` indicates
    the components that implement `EditableValueHolder`, so any attached objects suitable
    for implementations of `EditableValueHolder` may be attached to the composite
    component.**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**由于 `<cc:editableValueHolder>` 的存在，一切工作都如预期般进行。在这种情况下，此标签告诉 JSF，任何具有 `for`
    属性值等于 `playerId` 的转换器/验证器都应该应用于目标组件，即 `nameId` 和 `surnameId`。一般来说，`< cc:editableValueHolder>`
    指示实现 `EditableValueHolder` 的组件，因此任何适合实现 `EditableValueHolder` 的对象都可以附加到复合组件上。**'
- en: '**The complete application is named `ch10_10`.**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的应用程序命名为 `ch10_10`。**'
- en: '**As you know, `EditableValueHolder` is an extension of `ValueHolder`. Besides
    `<cc:editableValueHolder>`, JSF defines a tag named `<cc:valueHolder>`, which
    indicates the components that implement `ValueHolder`.**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**正如你所知，`EditableValueHolder` 是 `ValueHolder` 的扩展。除了 `<cc:editableValueHolder>`
    之外，JSF 定义了一个名为 `<cc:valueHolder>` 的标签，它指示实现 `ValueHolder` 的组件。**'
- en: '**Checking the presence of an attribute**'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**检查属性的存在**'
- en: '**Sometimes you need to render a composite component only if a certain attribute
    is present in the author page. For example, the following composite component
    checks for the presence of the `mandatory` attribute:**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**有时，只有当作者页面中存在某个属性时，才需要渲染复合组件。例如，以下复合组件检查 `mandatory` 属性的存在：**'
- en: '[PRE71]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '**Now the composite component will be rendered only if the `mandatory` attribute
    is present, as shown in the following code:**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在，只有当 `mandatory` 属性存在时，复合组件才会被渲染，如下面的代码所示：**'
- en: '[PRE72]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**The complete application is named `ch10_22`.**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的应用程序命名为 `ch10_22`。**'
- en: '**Composite components'' pitfalls**'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**复合组件的陷阱**'
- en: '**In the next part of this chapter, we will discuss a few pitfalls of composite
    components, such as: `null` values within composite component attributes, hidden
    pass-through attributes in composite components, number of children of composite
    components, and rendered top-level component in `<h:panelGrid>`.**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本章的下一部分，我们将讨论复合组件的一些陷阱，例如：复合组件属性中的 `null` 值、复合组件中的隐藏透传属性、复合组件的子组件数量以及 `<h:panelGrid>`
    中的渲染顶级组件。**'
- en: '**Null values within a composite component''s attributes**'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**复合组件属性中的 `null` 值**'
- en: '**As of version 2.2, JSF can determine the right type of a composite component
    attributes even when that value is `null`. This is an issue in version 2.1.**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**截至版本2.2，JSF可以在值是`null`的情况下确定组合组件属性的适当类型。这是2.1版本中的一个问题。**'
- en: '**Let''s have a simple composite component, as shown in the following code:**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们看看以下代码中的简单组合组件：**'
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '**Also, a simple page that uses this composite component is as follows:**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**此外，一个使用此组合组件的简单页面如下所示：**'
- en: '[PRE74]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**Now if you supply a `null` value from this component, it will work correctly
    in JSF 2.2, but will not work in JSF 2.1\. The complete example is named `ch10_19`.**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在，如果你从这个组件提供一个`null`值，它将在JSF 2.2中正确工作，但在JSF 2.1中则不会工作。完整的示例命名为`ch10_19`。**'
- en: '**Hiding pass-through attributes in composite components**'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**在组合组件中隐藏透传属性**'
- en: '**A composite component can hide pass-through attributes. For example, let''s
    take a simple composite component as follows:**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合组件可以隐藏透传属性。例如，让我们考虑以下简单的组合组件：**'
- en: '[PRE75]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '**Next, let''s use this composite component in a page by adding two pass-through
    attributes to it as follows:**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**接下来，让我们通过向其中添加两个透传属性，在页面中使用这个组合组件，如下所示：**'
- en: '[PRE76]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '**At this moment, if you check the list of attributes (using the `UIComponent.getAttributes`
    method) and the list of pass-through attributes (using the `UIComponent.getPassThroughAttributes`
    method), you will notice that the `placeholder` and `type` attributes are in the
    list of pass-through attributes. We can easily move them into the attributes list
    by encapsulating them into the composite component, as shown in the following
    code:**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**此刻，如果你检查属性列表（使用`UIComponent.getAttributes`方法）和透传属性列表（使用`UIComponent.getPassThroughAttributes`方法），你会注意到`placeholder`和`type`属性在透传属性列表中。我们可以通过将它们封装到组合组件中，轻松地将它们移动到属性列表中，如下面的代码所示：**'
- en: '[PRE77]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '**Also, you can use the composite component in the page, as follows:**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**此外，你可以在页面中使用组合组件，如下所示：**'
- en: '[PRE78]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '**Done! Now the `placeholder` and `type` attributes are not present in the
    pass-through attributes list. They were added in the attributes list returned
    by the `getAttributes` method.**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成！现在`placeholder`和`type`属性不再出现在透传属性列表中。它们被添加到了`getAttributes`方法返回的属性列表中。**'
- en: '**The complete application is named `ch10_16`.**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的应用程序命名为`ch10_16`。**'
- en: '**Counting the children of a composite component**'
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计算组合组件的子组件数量**'
- en: '**Suppose that you have a composite component that accepts children via the
    `<cc:insertChildren/>` tag. Sometimes you may need to render a certain message
    when the list of children is empty, and for this you may think of writing a composite
    component implementation, as shown in the following code:**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**假设你有一个通过`<cc:insertChildren/>`标签接受子组件的组合组件。有时你可能需要在子组件列表为空时渲染特定的消息，为此你可能考虑编写一个组合组件实现，如下面的代码所示：**'
- en: '[PRE79]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '**Now if the composite component is used as follows, you may think that the
    message **The list of names is empty!** will be rendered:**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在，如果组合组件按如下方式使用，你可能认为将渲染消息**“名称列表为空！”**'
- en: '[PRE80]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '**Well, you are right! But, the same message, next to the list content, will
    be rendered when the component is used as follows:**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**嗯，你说得对！但是，当组件按如下方式使用时，将渲染与列表内容并排的消息：**'
- en: '[PRE81]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '**In order to solve this issue, you can use the following code:**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了解决这个问题，你可以使用以下代码：**'
- en: '[PRE82]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '**Done! The complete application is named `ch10_20`.**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成！完整的应用程序命名为`ch10_20`。**'
- en: '**Top-level component''s pitfall**'
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**顶级组件的陷阱**'
- en: '**Remember that we have said earlier in this chapter that each composite component
    receives `UINamingContainer` as the top-level component. Well, it is important
    to not forget this when you define a composite component, as shown in the following
    code:**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**记住，我们在这章前面提到，每个组合组件都接收`UINamingContainer`作为顶级组件。当定义组合组件时，这一点很重要，如下面的代码所示：**'
- en: '[PRE83]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**And, you try to use it, as shown in the following code:**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**然后，你尝试使用它，如下面的代码所示：**'
- en: '[PRE84]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '**If you forgot about the top-level component, you probably expect to see something
    like the left-hand side of the following screenshot, while in reality, you will
    see something like the right-hand side of the following screenshot:**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你忘记了顶级组件，你可能期望看到如下截图的左侧部分，而实际上，你将看到如下截图的右侧部分：**'
- en: '**![Top-level component''s pitfall](img/6466EN_10_04.jpg)**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**![顶级组件的陷阱](img/6466EN_10_04.jpg)**'
- en: '**This is normal, since `<h:panelGrid>` perceives the composite component as
    a whole. All components that define the composite component are the children of
    the top-level component and are invisible to `<h:panelGrid>`.**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是正常的，因为 `<h:panelGrid>` 将复合组件视为一个整体。定义复合组件的所有组件都是顶级组件的子组件，并且对 `<h:panelGrid>`
    不可见。**'
- en: '**The complete example is named `ch10_15`.**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的示例命名为 `ch10_15`。**'
- en: '**Distributing composite components as JARs in JSF 2.2**'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**在 JSF 2.2 中将复合组件作为 JAR 分发**'
- en: '**As of JSF 2, we can add composite components in custom tag libraries (taglibs).
    After placing the composite component artifacts in the correct folders, we need
    to write a file of type (this filename should be suffixed with `taglib.xml`),
    as shown in the following code:**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**截至 JSF 2，我们可以在自定义标签库（taglibs）中添加复合组件。在将复合组件工件放置在正确的文件夹后，我们需要编写一个类型为（此文件名应以
    `taglib.xml` 结尾）的文件，如下面的代码所示：**'
- en: '[PRE85]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '**Based on this file''s content, and more precisely on `<composite-library-name>`,
    JSF 2 detects the composite components belonging to this library. This means that
    the composite components mapped in this JAR must come from this library only.**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**根据此文件的内容，更确切地说，根据 `<composite-library-name>`，JSF 2 检测属于此库的复合组件。这意味着在此 JAR
    中映射的复合组件必须仅来自此库。**'
- en: '**As of JSF 2.2, this restriction doesn''t exist anymore, and we can add, in
    the same JAR, composite components that come from different libraries.**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**截至 JSF 2.2，这个限制不再存在，我们可以在同一个 JAR 中添加来自不同库的复合组件。**'
- en: '**Let''s see an example! Suppose that we want to add in the same JAR the Temperature
    component (developed in application `ch10_8`) and the Range-slider component (developed
    in application `ch10_11`). The JAR will be named `jsfcc.jar`. The steps for accomplishing
    this are as follows:**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们看一个例子！假设我们想在同一个 JAR 中添加温度组件（在应用程序 `ch10_8` 中开发）和范围滑块组件（在应用程序 `ch10_11`
    中开发）。该 JAR 将命名为 `jsfcc.jar`。完成此操作的步骤如下：**'
- en: '**Create an empty JAR named `jsfcc.jar`.**'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个名为 `jsfcc.jar` 的空 JAR。**'
- en: '**In `jsfcc.jar`, create the folder `META-INF/resources`.**'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 `jsfcc.jar` 中创建文件夹 `META-INF/resources`。**'
- en: '**Copy the libraries that contain the composite components in `META-INF/resources`
    (copy the `resources/temperature` folder from the application `ch10_8` and `resources/range-slider`
    from the application `ch10_11`).**'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复制包含复合组件的库到 `META-INF/resources`（从应用程序 `ch10_8` 复制 `resources/temperature`
    文件夹，并从应用程序 `ch10_11` 复制 `resources/range-slider`）。**'
- en: '**For the Temperature composite component, copy the classes `book.beans.TempConvertClient.class`
    and `book.beans.TempConvertComponent.class` under the JAR root.**'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对于温度复合组件，将类 `book.beans.TempConvertClient.class` 和 `book.beans.TempConvertComponent.class`
    复制到 JAR 根目录下。**'
- en: '**Create an empty `faces-config.xml` file and place it under the `META-INF`
    folder as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个空的 `faces-config.xml` 文件并将其放置在 `META-INF` 文件夹下，如下所示：**'
- en: '[PRE86]**'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE86]**'
- en: '**Create the following `cc.taglib.xml` file and place it under the `META-INF`
    folder. Notice that we don''t need a `<composite-library-name>` tag, and we have
    configured both composite components under the same namespace, [http://jsf/cc/packt/taglib](http://jsf/cc/packt/taglib).
    Using this example, it is very easy to define more components as follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建以下 `cc.taglib.xml` 文件并将其放置在 `META-INF` 文件夹下。请注意，我们不需要 `<composite-library-name>`
    标签，并且我们已经将两个复合组件配置在同一个命名空间下，[http://jsf/cc/packt/taglib](http://jsf/cc/packt/taglib)。使用此示例，定义更多组件非常容易，如下所示：**'
- en: '[PRE87]**'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE87]**'
- en: '**In the following screenshot, you can see how the JAR structure should look:![Distributing
    composite components as JARs in JSF 2.2](img/6466EN_10_05.jpg)**'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在下面的屏幕截图中，你可以看到 JAR 结构应该如何看起来：![在 JSF 2.2 中将复合组件作为 JAR 分发](img/6466EN_10_05.jpg)**'
- en: '**Specially for testing `jsfcc.jar`, you can run the application `ch10_21`.
    Notice that even if NetBeans doesn''t recognize the tags of the composite components,
    they work like a charm.**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**特别为测试 `jsfcc.jar`，你可以运行应用程序 `ch10_21`。请注意，即使 NetBeans 不识别复合组件的标签，它们也能正常工作。**'
- en: '**Adding composite components programmatically**'
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**以编程方式添加复合组件**'
- en: '**The last section in this chapter discusses adding composite components programmatically.
    Before JSF 2.2, there wasn''t any official API for instantiating composite components
    as a Java instance via user code. But, there were at least two facile options
    for unofficially accomplishing this:**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章的最后部分讨论了以编程方式添加复合组件。在 JSF 2.2 之前，没有官方 API 通过用户代码将复合组件作为 Java 实例实例化。但是，至少有两种简单的方法可以非官方地完成此操作：**'
- en: '**Using the `Components.includeCompositeComponent` method available in OmniFaces
    from JSF Version 1.5 onwards ([https://code.google.com/p/omnifaces/](https://code.google.com/p/omnifaces/)).**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从JSF 1.5版本开始，可以使用OmniFaces中可用的`Components.includeCompositeComponent`方法（[https://code.google.com/p/omnifaces/](https://code.google.com/p/omnifaces/)).**'
- en: '**Using the `Components.includeCompositeComponent` source code as an inspiration
    to write your own implementation. This kind of implementation is listed in the
    complete application named `ch10_23`. In that application, you can see how to
    programmatically add in a page the Welcome and Temperature composite components
    (you need to pass to the `addCompositeComponent` method the following data: the
    composite component parent, the library name and path, and a unique ID).**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以`Components.includeCompositeComponent`源代码作为编写你自己的实现的灵感。这种实现列在完整的应用程序`ch10_23`中。在那个应用程序中，你可以看到如何通过程序化在页面中添加Welcome和Temperature组合组件（你需要传递给`addCompositeComponent`方法以下数据：组合组件父级、库名称和路径，以及一个唯一的ID）。**'
- en: '**As of JSF 2.2, we can use an explicit API for instantiating composite components
    programmatically. The core of this API is based on the new `createComponent` method
    added in the `ViewDeclarationLanguage` class. The signature of this method is
    as follows:**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**截至JSF 2.2，我们可以使用显式API来程序化实例化组合组件。这个API的核心是基于在`ViewDeclarationLanguage`类中添加的新`createComponent`方法。这个方法的签名如下：**'
- en: '[PRE88]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '**Besides `FacesContext`, you need to pass the tag library URI, the tag name,
    and the tag''s attributes, or `null`, if there are no attributes. For example,
    the Welcome component can be added via this API as follows (we append the Welcome
    component to a `<h:panelGroup>` with the `welcomeId` ID):**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**除了`FacesContext`外，您还需要传递标签库URI、标签名称和标签的属性，如果没有属性则传递`null`。例如，可以通过此API添加Welcome组件，如下所示（我们将Welcome组件添加到具有`welcomeId`
    ID的`<h:panelGroup>`中）：**'
- en: '[PRE89]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**The complete application is named `ch10_27_1`.**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的应用程序命名为`ch10_27_1`。**'
- en: '**A side-effect of this API includes the fact that it allows us to add regular
    components also. For example, you can append an `UIOutput` component to `<h:panelGroup>`
    with the `myPlayerId` ID, as follows:**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**此API的一个副作用是它还允许我们添加常规组件。例如，你可以将`UIOutput`组件添加到具有`myPlayerId` ID的`<h:panelGroup>`中，如下所示：**'
- en: '[PRE90]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**The complete application is named `ch10_27_2`. In [Chapter 12](ch12.html
    "Chapter 12. Facelets Templating"), *Facelets Templating*, you can see an example
    of adding `<ui:include>` using this API.**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的应用程序命名为`ch10_27_2`。在[第12章](ch12.html "第12章。Facelets 模板") *Facelets 模板*中，你可以看到使用此API添加`<ui:include>`的示例。**'
- en: '**# Summary'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 摘要**'
- en: In this chapter, you saw at work one of the greatest facilities of JSF. The
    custom and composite components feature represents the way how JSF expresses the
    respect for its developers. Writing custom/composite components is definitely
    a mandatory test of each JSF developer, since the difference between an ordinary
    and an extraordinary component resides in his skills. I hope that, next to many
    other books and tutorials about JSF custom/composite components, you have found
    this chapter as an interesting dissertation about this wide topic.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了JSF最伟大的功能之一。自定义和组合组件功能代表了JSF对开发者的尊重。编写自定义/组合组件无疑是每个JSF开发者必须通过的强制性测试，因为普通组件和非凡组件之间的区别在于其技能。我希望，在许多关于JSF自定义/组合组件的书籍和教程中，你也能找到本章关于这个广泛主题的有趣论文。
- en: As a final note of this chapter, we have to apologize to all JSP fans who felt
    ignored in this chapter by the fact that we did not mention anything about writing
    custom/composite components compatible with JSP. As you know, such components
    can be made compatible with JSP via tag classes (not tag handlers), but JSP was
    deprecated as of JSF 2\. I think that this is a plausible excuse for not covering
    or even mentioning JSP.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的最后一句话，我们必须向所有感到被忽视的JSP粉丝道歉。因为我们没有提到任何关于编写与JSP兼容的自定义/组合组件的内容。正如你所知，这些组件可以通过标签类（而不是标签处理器）与JSP兼容，但自JSF
    2以来，JSP已被弃用。我认为这是不涵盖甚至提及JSP的合理借口。
- en: See you in the next chapter, where we will explore the new JSF 2.2 themes!**
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎你回到下一章，我们将探索新的JSF 2.2主题！**
