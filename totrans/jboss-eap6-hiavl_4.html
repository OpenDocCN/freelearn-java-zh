<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Load Balancing with mod_jk"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Load Balancing with mod_jk</h1></div></div></div><p>In the previous chapter, we set up two EAP6 servers running in domain mode with the <code class="literal">full-ha</code> profile. In this chapter, let's set up a load balancer that could dispatch user requests to these two EAP6 servers.</p><p>The load balancer we use in this chapter is called mod_jk<a id="id181" class="indexterm"/> provided by the Apache community.<a id="id182" class="indexterm"/> It's easy to use and yet very powerful. The following diagram shows how it works:</p><div class="mediaobject"><img src="graphics/2432OS_04_01.jpg" alt="Load Balancing with mod_jk"/></div><p>The following are some notes regarding the previous diagram:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">mod_jk is a dynamic library that can be used as an Apache httpd module. In this chapter, we'll learn how to use it.</li><li class="listitem" style="list-style-type: disc">AJP13<a id="id183" class="indexterm"/> is a binary protocol used by mod_jk to proxy user requests to JBoss EAP6 servers. AJP13 stands for Apache JServ Protocol 1.3 and is widely used by Tomcat, Jetty, and other web servers.</li><li class="listitem" style="list-style-type: disc">When Apache httpd receives user requests, the mod_jk module will wrap the HTTP request into AJP13 format and pass it to JBoss EAP6, and the AJP connector in JBoss EAP6 will receive the proxy request from httpd. Then, EAP6 will process the request and send the response back to Apache httpd. Finally, Apache httpd will process the AJP response from JBoss EAP6 and transform it into the real HTTP response and send it back to a user.</li></ul></div><p>In practice, we usually bind the load balancer to the public IP address so it can listen to user requests from the Internet and put the EAP6 worker nodes in the local network. In addition, we should also bind a local IP address for the load balancer so it can communicate with EAP6 servers. Users just need to communicate with the load balancer to access the service, and they don't need to understand the architecture behind the load balancer. In addition, exposing the internal architecture of a cluster to the public is unnecessary and could introduce a potential security risk.</p><div class="section" title="Preparing a machine to install Apache httpd"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Preparing a machine to install Apache httpd</h1></div></div></div><p>As we have seen <a id="id184" class="indexterm"/>in the previous chapter, our cluster deployment structure will be as follows:</p><div class="mediaobject"><img src="graphics/2432OS_04_03.jpg" alt="Preparing a machine to install Apache httpd"/></div><p>We have configured the two EAP6 servers in the previous chapter. Now, we will install Apache httpd and mod_jk on a machine as the load balancer, and let's call it <code class="literal">lb</code>. This machine will have two IP addresses:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A public IP address that will serve user requests</li><li class="listitem" style="list-style-type: disc">A local IP address that can communicate with JBoss EAP6 servers in the local network<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>If your computer has just one local IP address, you can use it to serve both user requests and to communicate with EAP6 servers. But in practice, we usually hide the clustering architecture behind a firewall.</p></div></div></li></ul></div></div></div>
<div class="section" title="Compiling and installing Apache httpd"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Compiling and installing Apache httpd</h1></div></div></div><p>Now, let's <a id="id185" class="indexterm"/>learn how to compile and install Apache httpd. You may ask why <a id="id186" class="indexterm"/>we need to compile the Apache httpd by ourselves. There are multiple reasons. Usually, the httpd is provided by different platforms that have different versions and different configurations. For example, if you are using Ubuntu Linux and I'm using MacOS, our httpd versions will be different and our configurations of httpd will also be different.</p><p>In practice, compiling httpd, mod_jk, and mod_cluster is also common. This is because sometimes the newer versions of mod_jk and mod_cluster are released in the source code format before the binary format. So, we need to build them by ourselves.</p><div class="section" title="Downloading httpd"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Downloading httpd</h2></div></div></div><p>First, let's download<a id="id187" class="indexterm"/> the source code of Apache httpd from its website. We'll use the httpd 2.2.x in this book. This branch is currently the most stable version to work with mod_jk and mod_cluster. At the time of this writing, the newest version in 2.2.x branch is httpd 2.2.25, so let's use this to build our load balancer. Please note that the versions of httpd, mod_jk, and mod_cluster are very important, so please stick to the versions we used in this book or you may waste time on some bugs. You can download httpd 2.2.25 from <a class="ulink" href="http://archive.apache.org/dist/httpd/httpd-2.2.25.tar.gz">http://archive.apache.org/dist/httpd/httpd-2.2.25.tar.gz</a>.</p><p>After downloading it, please extract it to a directory that you have full access to. I've extracted it to <code class="literal">/packt/</code>:</p><div class="informalexample"><pre class="programlisting">$ pwd
/packt
$ tar zxvf httpd-2.2.25.tar.gz
...
$ ls
httpd-2.2.25        httpd-2.2.25.tar.gz</pre></div><p>Because we'll use the absolute path in some situations, please don't put the source in a very deep path, or you'll create unnecessary difficulties when referring to your absolute path.</p></div><div class="section" title="Compiling httpd"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Compiling httpd</h2></div></div></div><p>To <a id="id188" class="indexterm"/>compile httpd, first let's have a look at the contents of the sources shown as follows:</p><div class="mediaobject"><img src="graphics/2432OS_04_04.jpg" alt="Compiling httpd"/></div><p>In the contents, there is a file called <code class="literal">configure</code> that will detect your system settings and generate the build script <code class="literal">Makefile</code> for you. Let's run it first:</p><div class="informalexample"><pre class="programlisting">./configure --prefix=/packt/httpd \
    --with-mpm=worker \
    --enable-mods-shared=most \
    --enable-maintainer-mode \
    --with-expat=builtin \
    --enable-ssl \
    --enable-proxy \
    --enable-proxy-http \
    --enable-proxy-ajp \
    --disable-proxy-balancer</pre></div><p>As shown in the previous code snippet, we have provided several options to the <code class="literal">configure</code> script. Let's check them one by one:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">prefix=/packt/httpd</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">prefix</code> option defines the binaries install location.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">with-mpm=worker</code>
</p>
</td><td style="text-align: left" valign="top">
<p>MPM is the httpd process engine. The <code class="literal">worker</code> engine currently works stable with httpd 2.2.x, so we'll use it.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enable-mods-shared=most</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This option will compile the modules into the shared library. If we don't enable it, the modules will be compiled as a static-linked library and we cannot disable them separately with the <code class="literal">LoadModule</code> directive in <code class="literal">httpd.conf</code> later.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enable-maintainer-mode</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An option to control the <code class="literal">Automake</code> tool.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">with-expat=builtin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Expat is an XML parser library written in C.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enable-ssl</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The SSL library will be needed in the chapter that concerns the SSL support in the clustering environment.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enable-proxy</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">proxy</code> library is a dependency of mod_cluster. We'll learn about mod_cluster in the next chapter.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enable-proxy-http</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">proxy-http</code> is needed by mod_cluster.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">enable-proxy-ajp</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">proxy-ajp</code> is needed by mod_jk and mod_cluster.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">disable-proxy-balancer</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">proxy-balancer</code> conflicts with mod_cluster, so we must disable it.</p>
</td></tr></tbody></table></div><p>After<a id="id189" class="indexterm"/> understanding the meaning of these options, please run the <code class="literal">configure</code> command with the preceding options. Now let's run <code class="literal">make</code> to compile httpd:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>httpd-2.2.25$ make</strong></span>
<span class="strong"><strong>Making all in srclib</strong></span>
<span class="strong"><strong>Making all in pcre</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>Wait a few minutes and the compiling should finish.</p></div><div class="section" title="Installing httpd"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Installing httpd</h2></div></div></div><p>After <a id="id190" class="indexterm"/>compiling it, use the following command to install the compiled binaries:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>httpd-2.2.25$ make install</strong></span>
<span class="strong"><strong>Making install in srclib</strong></span>
<span class="strong"><strong>Making install in pcre</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>mkdir /packt/httpd</strong></span>
<span class="strong"><strong>mkdir /packt/httpd/modules</strong></span>
<span class="strong"><strong>...    </strong></span>
<span class="strong"><strong>Installing man pages and online manual</strong></span>
<span class="strong"><strong>mkdir /packt/httpd/man</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>As we can see, the compiled binaries are installed in the directory we've set the <code class="literal">--prefix</code> option. For me, it is <code class="literal">/packt/httpd</code>.</p></div><div class="section" title="Starting httpd"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Starting httpd</h2></div></div></div><p>Now, let's try to start httpd to <a id="id191" class="indexterm"/>see if it's installed correctly. Go to the <code class="literal">bin</code> directory of your installed httpd and run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>httpd/bin$ sudo ./httpd -k start -f /packt/httpd/conf/httpd.conf</strong></span>
</pre></div><p>We have used the <code class="literal">-k</code> option with the start command to tell httpd to start and the <code class="literal">-f</code> option with the full path of <code class="literal">httpd.conf</code> to make sure that the httpd server is using the configuration file we installed.</p><p>We are using the <code class="literal">sudo</code> command because we need the root access to bind the httpd service to port 80. If the server starts successfully, it will show some warnings:</p><div class="informalexample"><pre class="programlisting">httpd: Could not reliably determine the server's fully qualified domain name, using localhost.local for ServerName</pre></div><p>The warning is caused by the missing config of <code class="literal">ServerName</code> in <code class="literal">httpd.conf</code>. We'll configure it correctly later. Now, let's check the log output. Go to the logs directory and check <code class="literal">error_log</code>:</p><div class="informalexample"><pre class="programlisting">httpd/logs$ tail -f error_log
...
[Thu Oct 03 15:19:18 2013] [notice] Apache/2.2.25 (Unix) mod_ssl/2.2.25 OpenSSL/1.0.1c DAV/2 configured -- resuming normal operations</pre></div><p>The <code class="literal">error_log</code> file can help us to check if there are any errors when you run the httpd server. Here, we have used the tail command to check the tail contents of this log, and the <code class="literal">-f</code> option will keep updating the contents of <code class="literal">error_log</code> into the console. So, please keep the console window open; we can always check for any error when we are playing around with httpd. Now, we can use the cURL command to test the httpd service:</p><div class="informalexample"><pre class="programlisting">$ curl http://localhost
&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</pre></div><p>As we can see, the HTTP service is up. Now, let's stop the httpd server and do some basic configurations in <code class="literal">httpd.con</code>
<code class="literal">f</code>.</p></div><div class="section" title="Stopping httpd"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Stopping httpd</h2></div></div></div><p>The<a id="id192" class="indexterm"/> command to stop httpd is similar to the command that starts it; only replace <code class="literal">start</code> with <code class="literal">stop</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo httpd -k stop -f /packt/httpd/conf/httpd.conf</strong></span>
</pre></div><p>From <code class="literal">error_log</code>, we can see that the server has stopped:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Thu Oct 03 16:23:59 2013] [notice] caught SIGTERM, shutting down</strong></span>
</pre></div></div><div class="section" title="Configuring httpd"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Configuring httpd</h2></div></div></div><p>Now, let's do <a id="id193" class="indexterm"/>some basic configuration for httpd. The first step is to back up your original <code class="literal">httpd.conf</code>:</p><div class="informalexample"><pre class="programlisting">httpd/conf$ cp httpd.conf httpd.conf.orig</pre></div><p>It's a good habit to keep an original copy of your configuration; in case we mess it up, we can restore it later. The next step is to open <code class="literal">http.conf</code> with your favorite editor and find the following code line:</p><div class="informalexample"><pre class="programlisting">Listen 80</pre></div><p>We need to change it for httpd to listen to the public address:</p><div class="informalexample"><pre class="programlisting">Listen 172.16.123.1:80</pre></div><p>I've configured this IP address on the machine lb, and it will be used to listen to user requests. Note that it's a good habit to bind httpd to specific IP addresses and ports to prevent potential security risks. Besides the public IP address, the machine lb also has a local IP address, <code class="literal">10.0.1.32</code>. The former one will be used for public access from users; the latter one sits in the same LAN with the two EAP6 servers. If your machine doesn't have two IP addresses, it's okay to just use the single address for both purposes. Just keep in mind, in practice, we usually put the clustering architecture behind a firewall.</p><p>Now let's go to the next step. We need to find the following line:</p><div class="informalexample"><pre class="programlisting">#ServerName www.example.com:80</pre></div><p>Let's put our own server name under this line:</p><div class="informalexample"><pre class="programlisting">ServerName lb</pre></div><p>That's all we need to configure in <code class="literal">httpd.conf</code> for now. Let's save the configuration and quit editing. Next, we need to make sure the hostname lb is mapped to our public IP address. For a Linux-like environment, we can put the mapping in <code class="literal">/etc/hosts</code>. Open the <code class="literal">httpd.conf</code> file and add the following line at the bottom:</p><div class="informalexample"><pre class="programlisting">172.16.123.1 lb</pre></div><p>After saving the configuration file, we can use the <code class="literal">ping</code> command to test the hostname:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ping -c 3 lb</strong></span>
<span class="strong"><strong>PING lb (172.16.123.1): 56 data bytes</strong></span>
<span class="strong"><strong>64 bytes from 172.16.123.1: icmp_seq=0 ttl=64 time=0.036 ms</strong></span>
<span class="strong"><strong>64 bytes from 172.16.123.1: icmp_seq=1 ttl=64 time=0.079 ms</strong></span>
<span class="strong"><strong>64 bytes from 172.16.123.1: icmp_seq=2 ttl=64 time=0.087 ms</strong></span>
</pre></div><p>Now, let's start httpd to check our configuration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo httpd -k start -f /packt/httpd/conf/httpd.conf</strong></span>
</pre></div><p>If you still keep the tail <code class="literal">-f logs/error_log</code> console opened, you can check it immediately<a id="id194" class="indexterm"/> to see if there are any errors during startup. If everything goes fine, we can access the httpd server by the hostname now:</p><div class="informalexample"><pre class="programlisting">$ curl http://lb
&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; </pre></div><p>As shown in the previous code snippet, the hostname lb is bound to the httpd server. In addition, during the httpd server startup, note that the warning <span class="strong"><strong>httpd: Could not reliably determine the server's fully qualified domain name</strong></span> disappeared. That's because we have configured <code class="literal">ServerName</code> in <code class="literal">httpd.conf</code>.</p><p>As we have configured httpd, the next step is to learn to use mod_jk.</p></div></div>
<div class="section" title="Compiling and installing mod_jk"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Compiling and installing mod_jk</h1></div></div></div><p>The full name of mod_jk is <a id="id195" class="indexterm"/>Apache Tomcat Connector. It was originally designed to proxy HTTP requests from httpd to Tomcat, but as it is a standard AJP connector, it can be used on web containers that support the AJP protocol. Because JBoss EAP6 supports the AJP13 protocol, we can use mod_jk as its connector.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>To save some typing, in the following text I'll use JK to refer to mod_jk.</p></div></div><div class="section" title="Installing JK"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Installing JK</h2></div></div></div><p>The <a id="id196" class="indexterm"/>download page of JK is at <a class="ulink" href="http://tomcat.apache.org/download-connectors.cgi">http://tomcat.apache.org/download-connectors.cgi</a>.</p><p>At the<a id="id197" class="indexterm"/> time of this writing, the newest version is 1.2.37, and it's the version we'll use in this book. Please download the 1.2.37 source bundle from the previously mentioned website and unzip it after download. After all this is finished, let's have a look at the contents of the source package:</p><div class="informalexample"><pre class="programlisting">tomcat-connectors-1.2.37-src$ ls
HOWTO-RELEASE.txt conf              support
LICENSE           docs              tools
NOTICE            jkstatus          xdocs
README.txt        native</pre></div><p>As we can see, mod_jk contains many components, but we only need to build the codes in the native directory. Let's go into this directory and run the <code class="literal">configure</code> script inside:</p><div class="informalexample"><pre class="programlisting">$ ./configure --with-apxs=/packt/httpd/bin/apxs</pre></div><p>Please note that we have been provided with the<code class="literal">—with-apxs</code> option to configure, because during the building process, it needs the httpd binaries. The configuration process is shown as follows:</p><div class="informalexample"><pre class="programlisting">tomcat-connectors-1.2.37-src/native$ ./configure --with-apxs=/packt/httpd/bin/apxs
checking build system type... 
checking host system type... 
...
config.status: executing depfiles commands
After configure process finished, run make to compile it:
tomcat-connectors-1.2.37-src/native$ make
libtool: install: warning: remember to run `libtool --finish /packt/httpd/modules'
...
Making all in common
Making all in apache-2.0
make[1]: Nothing to be done for `all'.</pre></div><p>Now <a id="id198" class="indexterm"/>let's install it by running <code class="literal">make install</code>:</p><div class="informalexample"><pre class="programlisting">tomcat-connectors-1.2.37-src/native$ make install
Making install in apache-2.0

Installing files to Apache Modules Directory...
cp .libs/mod_jk.so /packt/httpd/modules/mod_jk.so
chmod 755 /packt/httpd/modules/mod_jk.so

Please be sure to arrange /packt/httpd/conf/httpd.conf...</pre></div><p>I have trimmed the log output and just left the important parts. From the previous log, we can see that the compiled shared binary <code class="literal">mod_jk.so</code> has been copied to <code class="literal">/packt/httpd/modules/</code>. Because we have set the httpd path using the <code class="literal">--with-apxs</code> option, during the installation process, the build script knows where to put the compiled binary.</p><p>At the end of the log, JK has reminded us to configure <code class="literal">httpd.conf</code> to enable it. In the following section, we will perform this task.</p></div><div class="section" title="Configuring JK"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Configuring JK</h2></div></div></div><p>In the JK source,<a id="id199" class="indexterm"/> there is a directory called <code class="literal">conf</code>. In this directory, JK has provided us some sample configuration files that we can refer to:</p><div class="informalexample"><pre class="programlisting">$ ls /packt/tomcat-connectors-1.2.37-src/conf 
httpd-jk.conf              workers.properties
uriworkermap.properties    workers.properties.minimal</pre></div><p>Let's copy these files into httpd. First, let us  create a new directory called <code class="literal">conf.d</code> in httpd:</p><div class="informalexample"><pre class="programlisting">/packt/httpd$ mkdir conf.d</pre></div><p>Then, let's copy the configuration file from JK source to <code class="literal">conf.d</code>:</p><div class="informalexample"><pre class="programlisting">$ cp /packt/tomcat-connectors-1.2.37-src/conf/httpd-jk.conf /packt/httpd/conf.d/</pre></div><p>We want httpd to load <code class="literal">conf.d/httpd-jk.conf</code> during startup. To achieve this goal, please open <code class="literal">conf/httpd.conf</code> and find many lines starting with <code class="literal">LoadModule</code>. At the bottom of these <code class="literal">LoadModule</code> directives, let's put a new code line:</p><div class="informalexample"><pre class="programlisting">Include conf.d/*.conf</pre></div><p>The modification<a id="id200" class="indexterm"/> is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432OS_04_08.jpg" alt="Configuring JK"/></div><p>The <code class="literal">Include</code> directive will tell httpd to load the files with suffix <code class="literal">.conf</code> in <code class="literal">conf.d</code> during startup. As we have put <code class="literal">httpd-jk.conf</code> into <code class="literal">conf.d</code>, it will be loaded during the httpd startup. Now let's move to JK configuration.</p><div class="section" title="Configuring httpd-jk.conf"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Configuring httpd-jk.conf</h3></div></div></div><p>We need to<a id="id201" class="indexterm"/> configure the JK properly. Please open the <code class="literal">httpd-jk.conf</code> in <code class="literal">conf.d</code> and let's check some important configurations:</p><div class="informalexample"><pre class="programlisting">LoadModule jk_module modules/mod_jk.so</pre></div><p>As shown in the previous code line, we can see that the <code class="literal">mod_jk.so</code> library is loaded.</p><div class="informalexample"><pre class="programlisting">JkWorkersFile conf/workers.properties</pre></div><p>By default, JK will find <code class="literal">workers.properties</code> in the <code class="literal">conf</code> directory. This property file is used to define our cluster structure. Let's copy the sample <code class="literal">config</code> file named <code class="literal">workers.properties.minimal</code> from the JK source directory to <code class="literal">conf.d</code>:</p><div class="informalexample"><pre class="programlisting">$ cp /packt/tomcat-connectors-1.2.37-src/conf/workers.properties.minimal /packt/httpd/conf/workers.properties</pre></div><p>Later, we'll<a id="id202" class="indexterm"/> go through the details in this file. Now, let's go back to check <code class="literal">httpd-jk.conf</code>:</p><div class="informalexample"><pre class="programlisting">JkLogFile logs/mod_jk.log</pre></div><p>The <code class="literal">JkLogFile</code> directive defines the logfile used by JK.</p><div class="informalexample"><pre class="programlisting">JkLogLevel info</pre></div><p>The <code class="literal">JkLogLevel</code> directive<a id="id203" class="indexterm"/> defines the log level of JK. You can change it to <code class="literal">debug</code> to see more details when JK is running.</p><div class="informalexample"><pre class="programlisting">JkShmFile logs/mod_jk.shm</pre></div><p>This is the JK shared memory file. Just keep it as it is. Now, let's see the following two JK modules:</p><div class="informalexample"><pre class="programlisting"> &lt;Location /jk-status&gt;
    JkMount jk-status
    Order deny,allow
    Deny from all
    Allow from 127.0.0.1
&lt;/Location&gt;
&lt;Location /jk-manager&gt;
    JkMount jk-manager
    Order deny,allow
    Deny from all
    Allow from 127.0.0.1
&lt;/Location&gt;</pre></div><p>The previously mentioned two locations are for JK management components. We can define them in <code class="literal">workers.properties</code>:</p><div class="informalexample"><pre class="programlisting">worker.list=jk-status
worker.jk-status.type=status
worker.jk-status.read_only=true

worker.list=jk-manager
worker.jk-manager.type=status</pre></div><p>We can see that <code class="literal">jk-status</code> and <code class="literal">jk-manager</code> are actually the same thing:</p><div class="informalexample"><pre class="programlisting">worker.jk-status.type=status</pre></div><p>Just one of them is <code class="literal">read_only</code>:</p><div class="informalexample"><pre class="programlisting">worker.jk-status.read_only=true</pre></div><p>The other one can accept the management command. In this book, we'll just configure JK using the configuration file and won't cover the topic of <code class="literal">jk-manager</code> usages. Now, let's go back to the configuration file. The access scope of <code class="literal">jk-status</code> and <code class="literal">jk-manager</code> are defined in the <code class="literal">Location</code> settings:</p><div class="informalexample"><pre class="programlisting">Allow from 127.0.0.1</pre></div><p>That means we<a id="id204" class="indexterm"/> can only access <code class="literal">/jk-status</code> and <code class="literal">/jk-manager</code> from the localhost. This is secure because we don't want these management components to be accessed remotely. To support it, we need to add a line in <code class="literal">conf/httpd.conf</code>. Under the existing <code class="literal">Listen</code> section, add another directive:</p><div class="informalexample"><pre class="programlisting">Listen 127.0.0.1:80</pre></div><p>It should look like the following:</p><div class="mediaobject"><img src="graphics/2432OS_04_09.jpg" alt="Configuring httpd-jk.conf"/></div><p>This will let httpd to accept connection from the localhost. That's all we need to do to enable management consoles. Now, let's check <code class="literal">worker</code>
<code class="literal">s.properties</code>.</p></div><div class="section" title="The workers.properties configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec14"/>The workers.properties configuration</h3></div></div></div><p>We will<a id="id205" class="indexterm"/> define<a id="id206" class="indexterm"/> our cluster structure in <code class="literal">workers.properties</code> that we've copied to the <code class="literal">conf</code> directory. The content of this file is straightforward, which is shown as follows:</p><div class="informalexample"><pre class="programlisting">worker.list=lb,jk-status

worker.node1.type=ajp13
worker.node1.host=localhost
worker.node1.port=8009

worker.lb.type=lb
worker.lb.balance_workers=node1

worker.jk-status.type=status</pre></div><p>The first line<a id="id207" class="indexterm"/> of configuration defines two workers: <code class="literal">lb</code> and <code class="literal">jk-status</code>. We know that <code class="literal">jk-status</code> is used for mounting the management component of JK, and its type is <code class="literal">status</code>.</p><p>For the worker <code class="literal">lb</code>, we see that its type is <code class="literal">lb</code>:</p><div class="informalexample"><pre class="programlisting">worker.lb.type=lb</pre></div><p>The <code class="literal">lb</code> type defines a load balancer in JK, and it can be used to dispatch user requests to worker nodes. We see that the example provided by JK has one worker node called <code class="literal">node1</code>:</p><div class="informalexample"><pre class="programlisting">worker.lb.balance_workers=node1</pre></div><p>By default, <code class="literal">node1</code> is a node that supports the AJP13 protocol:</p><div class="informalexample"><pre class="programlisting">worker.node1.type=ajp13
worker.node1.host=localhost
worker.node1.port=8009</pre></div><p>The preceding configuration needs to be modified. We have two worker nodes, which are the two EAP6 servers running on master and slave, and their IP addresses are <code class="literal">10.0.1.13</code> and <code class="literal">10.0.1.19</code> as we know.</p><p>We know the two EAP6 servers are running in the domain mode and we are using <code class="literal">other-server-group</code>, and master is running as the domain controller. So let's check <code class="literal">domain.xml</code> on master:</p><div class="informalexample"><pre class="programlisting">&lt;server-group name="other-server-group" profile="full-ha"&gt;
    &lt;socket-binding-group ref="full-ha-sockets"/&gt;
&lt;/server-group&gt;
&lt;socket-binding-group name="full-ha-sockets" default-interface="public"&gt;
    &lt;socket-binding name="ajp" port="8009"/&gt;
    ...
&lt;/socket-binding-group&gt;</pre></div><p>The <code class="literal">other-server-group</code> uses the <code class="literal">full-ha-sockets</code> binding group. And the AJP port is bound to 8009. But don't forget the <code class="literal">port-offset</code> settings in <code class="literal">host.xml</code> on master and slave. On the master system, we have the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;server name="master-server" group="other-server-group" auto-start="true"&gt;
    &lt;socket-bindings port-offset="250"/&gt;
&lt;/server&gt;</pre></div><p>On the slave system, we have the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;server name="slave-server" group="other-server-group" auto-start="true"&gt;
    &lt;socket-bindings port-offset="250"/&gt;
&lt;/server&gt;</pre></div><p>So their bound<a id="id208" class="indexterm"/> AJP ports are <span class="emphasis"><em>8009 + 250 = 8259</em></span>. According to the settings in these two worker nodes, let's modify the configuration in <code class="literal">workers.properties</code>. The following comprises the full contents:</p><div class="informalexample"><pre class="programlisting">worker.list=lb,jk-status

worker.master.type=ajp13
worker.master.host=10.0.1.13
worker.master.port=8259

worker.slave.type=ajp13
worker.slave.host=10.0.1.19
worker.slave.port=8259

worker.lb.type=lb
worker.lb.balance_workers=master,slave

worker.jk-status.type=status</pre></div><p>In the previous configuration file, we configured our two EAP6 servers as the worker nodes of <code class="literal">lb</code>. The following diagram shows their relationship:</p><div class="mediaobject"><img src="graphics/2432OS_04_10.jpg" alt="The workers.properties configuration"/></div><p>After configuring <code class="literal">workers.properties</code>, we need to go back to <code class="literal">conf.d/httpd-jk.conf</code> to add a mount point to our cluster. Under the <code class="literal">JkWorkersFile</code> directive, add the following line of code:</p><div class="informalexample"><pre class="programlisting">JkMount /* lb</pre></div><p>The configuration is shown as follows:</p><div class="mediaobject"><img src="graphics/2432OS_04_11.jpg" alt="The workers.properties configuration"/></div><p>It will tell httpd to <a id="id209" class="indexterm"/>redirect all the HTTP requests to <code class="literal">lb</code>, and <code class="literal">lb</code> will proxy the request to EAP6 servers with the AJP13 protocol. That's all for the configuration. Now let's test our cluster.</p></div></div></div>
<div class="section" title="Testing the cluster"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Testing the cluster</h1></div></div></div><p>Please <a id="id210" class="indexterm"/>shut down the httpd server and then restart it. If you have followed all the instructions in the previous sections, the server should start correctly.</p><p>Make sure that you have started two EAP6 servers in the domain mode, and the project <code class="literal">cluster-demo1</code> has been deployed to <code class="literal">other-server-group</code>. We'll use these two worker nodes for testing.</p><p>As we have bound the public IP address of the load balancer to the hostname <code class="literal">lb</code>, let's access it by the hostname. Open a web browser and enter the URL <code class="literal">http://lb</code>.</p><p>If everything goes well, we should see the EAP home page now:</p><div class="mediaobject"><img src="graphics/2432OS_04_12.jpg" alt="Testing the cluster"/></div><p>From the<a id="id211" class="indexterm"/> previous screenshot, we see that the request is forwarded to the EAP6 servers. Now let's try to access <code class="literal">cluster-demo1</code>:</p><div class="informalexample"><pre class="programlisting">$ curl http://lb/cluster-demo1/index.jsp
&lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;Hello World!&lt;/h2&gt;

    Hello! The time is now Fri Oct 04 00:31:54 CST 2013
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>We can check the server output of the two EAP6 servers to see which is actually processing this request. In my cluster, this request is handled by <code class="literal">master-server</code>:</p><div class="informalexample"><pre class="programlisting">[Server:master-server] 00:31:54,264 INFO  [stdout] (ajp-/10.0.1.13:8259-3) Hello! The time is now Fri Oct 04 00:31:54 CST 2013</pre></div><p>Let's shut down the EAP6 server that is serving this request. For my cluster, I press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> on my <code class="literal">master-server</code> to shut down:</p><div class="informalexample"><pre class="programlisting">00:36:32,078 INFO  [org.jboss.as.process] (Shutdown thread) JBAS012015: All processes finished; exiting</pre></div><p>Then, I use <code class="literal">cURL</code> to access the load balancer again. The request is forwarded to another EAP server. It is <code class="literal">slave-server</code> processing the user request this time:</p><div class="informalexample"><pre class="programlisting">[Server:slave-server] 00:36:39,966 INFO  [stdout] (ajp-/10.0.1.19:8259-4) Hello! The time is now Fri Oct 04 00:36:39 CST 2013</pre></div><p>From the users' perspective, <a id="id212" class="indexterm"/>they are not affected by one worker node shutdown in the cluster.</p><div class="section" title="The jk-status module"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>The jk-status module</h2></div></div></div><p>Finally, let's have a brief look at the <code class="literal">jk-status</code> module<a id="id213" class="indexterm"/>. Open your web browser from the machine of your load balancer. Then, access the <code class="literal">jk-status</code> by its URL: <code class="literal">http://localhost/jk-status</code>.</p><p>We will see the status of two worker nodes:</p><div class="mediaobject"><img src="graphics/2432OS_04_14.jpg" alt="The jk-status module"/></div><p>From the previous screenshot, we can check the running statuses of the two EAP6 servers and how many requests they have processed.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we have learned how to use JK as a load balancer to proxy user requests. As you can see, JK is very easy to use and yet powerful. It relies on <code class="literal">workers.properties</code> to define the structure of the cluster. When a worker node in a cluster crashes, JK will failover the user requests to other nodes in the cluster. We haven't touched all the features that JK has provided to us, for example, a fine-grained route matching and the usage of <code class="literal">jk-status</code> for management tasks. You can refer to the JK online document for these topics.</p></div></body></html>