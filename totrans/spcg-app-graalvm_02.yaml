- en: '*Chapter 1*: Evolution of Java Virtual Machine'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：Java 虚拟机演变'
- en: This chapter will walk you through the evolution of **Java Virtual Machine**
    (**JVM**), and how it optimized the interpreter and compiler. We will learn about
    C1 and C2 compilers and various types of code optimizations that the JVM performs
    to run Java programs faster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍 **Java 虚拟机**（**JVM**）的演变过程以及它是如何优化解释器和编译器的。我们将了解 C1 和 C2 编译器以及 JVM 执行的多种代码优化类型，以使
    Java 程序运行得更快。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to GraalVM
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 简介
- en: Learning how JVM works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 JVM 的工作原理
- en: Understanding the JVM architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 JVM 架构
- en: Understanding the kind of optimizations JVM performs with **Just-In-Time** (**JIT**)
    compilers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 JVM 使用 **即时编译器**（**JIT**）执行的优化类型
- en: Learning the pros and cons of the JVM approach
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 JVM 方法的优缺点
- en: By the end of this chapter, you will have a clear understanding of the JVM architecture.
    This is critical in understanding the GraalVM architecture and how GraalVM further
    optimizes and builds on top of JVM best practices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对 JVM 架构有一个清晰的理解。这对于理解 GraalVM 架构以及 GraalVM 如何进一步优化并建立在 JVM 最佳实践之上至关重要。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not require any specific software/hardware.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要任何特定的软件/硬件。
- en: Introduction to GraalVM
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraalVM 简介
- en: GraalVM is a high-performance VM that provides the runtime for modern cloud-native
    applications. Cloud-native applications are built based on the service architecture.
    The microservice architecture changes the paradigm of building micro applications,
    which challenges the fundamental way we build and run applications. The microservices
    runtimes demand a different set of requirements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 是一个高性能虚拟机，为现代云原生应用程序提供运行时。云原生应用程序是基于服务架构构建的。微服务架构改变了构建微应用程序的范式，这挑战了构建和运行应用程序的基本方式。微服务运行时需要一套不同的要求。
- en: 'Here are some of the key requirements of a cloud-native application built on
    the microservice architecture:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些基于微服务架构构建的云原生应用程序的关键要求：
- en: '**Smaller footprint**: Cloud-native applications run on the "pay for what we
    use" model. This means that the cloud-native runtimes need to have a smaller memory
    footprint and should run with the optimum CPU cycles. This will help run more
    workloads with fewer cloud resources.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的内存占用**：云原生应用程序运行在“按使用付费”的模式上。这意味着云原生运行时需要具有更小的内存占用，并且应该以最佳 CPU 循环运行。这将有助于使用更少的云资源运行更多的工作负载。'
- en: '**Quicker bootstrap**: Scalability is one of the most important aspects of
    container-based microservices architecture. The faster the application''s bootup,
    the faster it can scale the clusters. This is even more important for serverless
    architectures, where the code is initialized and run and then shut down on request.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速启动**：可扩展性是容器化微服务架构最重要的方面之一。应用程序启动越快，它就能更快地扩展集群。这对于无服务器架构来说尤为重要，在无服务器架构中，代码在请求初始化和运行后关闭。'
- en: '**Polyglot and interoperability**: Polyglot is the reality; each language has
    its strengths and will continue to. Cloud-native microservices are being built
    with different languages. It''s very important to have an architecture that embraces
    the polyglot requirements and provides interoperability across languages. As we
    move to modern architectures, it''s important to reuse as much code and logic
    as possible, that is time-tested and critical for business.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多语言和互操作性**：多语言是现实；每种语言都有其优势，并将继续如此。云原生微服务正在用不同的语言构建。拥有一个能够接纳多语言需求并提供跨语言互操作性的架构非常重要。随着我们转向现代架构，尽可能重用代码和逻辑至关重要，这些代码和逻辑是经过时间考验的，对业务至关重要。'
- en: GraalVM provides a solution to all these requirements and provides a common
    platform to embed and run polyglot cloud-native applications. It is built on JVM
    and brings in further optimizations. Before understanding how GraalVM works, it's
    important to understand the internal workings of JVM.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 为所有这些需求提供了解决方案，并为嵌入和运行多语言云原生应用程序提供了一个通用平台。它是基于 JVM 构建的，并带来了进一步的优化。在了解
    GraalVM 的工作原理之前，了解 JVM 的内部工作原理非常重要。
- en: Traditional JVM (before GraalVM) has evolved into the most mature runtime implementation.
    While it has some of the previously listed requirements, it is not built for cloud-native
    applications, and it comes with its baggage of monolith design principles. It
    is not an ideal runtime for cloud-native applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的JVM（在GraalVM之前）已经发展成为最成熟的运行时实现。虽然它具有之前列出的某些要求，但它并不是为云原生应用程序设计的，并且带有单体设计原则的包袱。它不是云原生应用程序的理想运行时。
- en: This chapter will walk you through in detail how JVM works and the key components
    of the JVM architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍JVM的工作原理以及JVM架构的关键组件。
- en: Learning how JVM works
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习JVM的工作原理
- en: Java is one of the most successful and widely used languages. Java has been
    very successful because of its *write once, run anywhere* design principle. JVM
    realizes this design principle by sitting between the application code and the
    machine code and interpreting the application code to machine code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Java是最成功和最广泛使用的语言之一。Java之所以非常成功，是因为其“一次编写，到处运行”的设计原则。JVM通过位于应用程序代码和机器码之间，将应用程序代码解释为机器码来实现这一设计原则。
- en: 'Traditionally, there two ways of running application code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，运行应用程序代码有两种方式：
- en: '**Compilers**: Application code is directly compiled to machine code (in C,
    C++). Compilers go through a build process of converting the application code
    to machine code. Compilers generate the most optimized code for a specific target
    architecture. The application code has to be compiled to target architectures.
    In general, the compiled code always runs faster than interpreted code, and issues
    with code semantics can be identified during compilation time rather than runtime.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器**：应用程序代码直接编译为机器码（C、C++等）。编译器通过构建过程将应用程序代码转换为机器码。编译器为特定的目标架构生成最优化代码。应用程序代码必须编译为目标架构。一般来说，编译的代码总是比解释的代码运行得快，并且可以在编译时而不是运行时识别代码语义问题。'
- en: '**Interpreters**: Application code is interpreted to machine code line by line
    (JavaScript and so on). Since interpreters run line by line, the code may not
    be optimized to the target architecture, and run slowly, compared to the compiled
    code. Interpreters have the flexibility of writing once and running anywhere.
    A good example is the JavaScript code that is predominantly used for web applications.
    This runs pretty much on different target browsers with minimal or no changes
    in the application code. Interpreters are generally slow and are good for running
    small applications.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释器**：应用程序代码逐行解释为机器码（JavaScript等）。由于解释器逐行运行，代码可能没有针对目标架构进行优化，并且运行速度较慢，与编译的代码相比。解释器具有“一次编写，到处运行”的灵活性。一个很好的例子是主要用于Web应用程序的JavaScript代码。它在不同的目标浏览器上几乎不需要或只需要很少的更改即可运行。解释器通常运行较慢，适用于运行小型应用程序。'
- en: 'JVM has taken the best of both interpreters and compilers. The following diagram
    illustrates how JVM runs the Java code using both the interpreter and compiler
    approaches:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JVM结合了解释器和编译器的优点。以下图表说明了JVM如何使用解释器和编译器方法运行Java代码：
- en: '![Figure 1.1 – Java compiler and interpreter'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – Java编译器和解释器'
- en: '](img/B16878_Figure_1.1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16878_Figure_1.1.jpg](img/B16878_Figure_1.1.jpg)'
- en: Figure 1.1 – Java compiler and interpreter
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Java编译器和解释器
- en: 'Let''s see how this works:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: Java Compiler (**javac**) compiles the Java application source code to **bytecode**
    (intermediate format).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java编译器（**javac**）将Java应用程序源代码编译为**字节码**（中间格式）。
- en: JVM interprets the bytecode to machine code line by line at runtime. This helps
    in translating the optimized bytecode to target machine code, helping in running
    the same application code on different target machines, without re-programming
    or re-compiling.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM在运行时逐行将字节码解释为机器码。这有助于将优化的字节码转换为目标机器码，从而帮助在不同的目标机器上运行相同的应用程序代码，而无需重新编程或重新编译。
- en: JVM also has a Just-In-Time (**JIT)** compiler to further optimize the code
    at runtime by profiling the code.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM还有一个即时编译器（**JIT**），通过分析代码在运行时进一步优化代码。
- en: In this section, we looked at how Java Compiler and JIT work together to run
    Java code on JVM at a higher level. In the next section, we will learn about the
    architecture of JVM.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Java编译器和JIT如何协同工作，在JVM上以更高的层次运行Java代码。在下一节中，我们将学习JVM的架构。
- en: Understanding the JVM architecture
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JVM架构
- en: Over the years, JVM has evolved into the most mature VM runtime. It has a very
    structured and sophisticated implementation of a runtime. This is one of the reasons
    why GraalVM is built to utilize all the best features of the JVM and provide further
    optimizations required for the cloud-native world. To better appreciate the GraalVM
    architecture and optimizations that it brings on top of the JVM, it's important
    to understand the JVM architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的发展，JVM已经发展成为最成熟的VM运行时。它具有非常结构化和复杂的运行时实现。这也是GraalVM被构建出来以利用JVM的所有最佳特性，并为云原生世界提供进一步优化所需的功能的原因之一。为了更好地欣赏GraalVM架构及其在JVM之上带来的优化，了解JVM架构是非常重要的。
- en: 'This section walks you through the JVM architecture in detail. The following
    diagram shows the high-level architecture of various subsystems in JVM:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将详细向您介绍JVM架构。以下图显示了JVM中各个子系统的整体架构：
- en: '![Figure 1.2 – High-level architecture of JVM'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – JVM的整体架构'
- en: '](img/B16878_Figure_1.2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16878_Figure_1.2.jpg)'
- en: Figure 1.2 – High-level architecture of JVM
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – JVM的整体架构
- en: The rest of this section will walk you through each of these subsystems in detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分将详细介绍这些子系统。
- en: Class loader subsystem
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类加载器子系统
- en: 'The class loader subsystem is responsible for allocating all the relevant `.class`
    files and loading these classes to the memory. The class loader subsystem is also
    responsible for linking and verifying the schematics of the `.class` file before
    the classes are initialized and loaded to memory. The class loader subsystem has
    the following three key functionalities:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器子系统负责分配所有相关的`.class`文件并将这些类加载到内存中。类加载器子系统还负责在类初始化和加载到内存之前链接和验证`.class`文件的规范。类加载器子系统具有以下三个关键功能：
- en: Loading
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载
- en: Linking
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接
- en: Initializing
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化
- en: 'The following diagram shows the various components of the class loader subsystem:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了类加载器子系统的各个组件：
- en: '![Figure 1.3 – Components of the class loader subsystem'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 类加载器子系统的组件'
- en: '](img/B16878_Figure_1.3.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16878_Figure_1.3.jpg)'
- en: Figure 1.3 – Components of the class loader subsystem
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 类加载器子系统的组件
- en: Let's now look at what each of these components does.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看每个组件的作用。
- en: Loading
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载
- en: In traditional compiler-based languages such as C/C++, the source code is compiled
    to object code, and then all the dependent object code is linked by a linker before
    the final executable is built. All this is part of the build process. Once the
    final executable is built, it is then loaded into the memory by the loader. Java
    works differently.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的基于编译器的语言（如C/C++）中，源代码被编译成目标代码，然后所有依赖的目标代码在构建最终可执行文件之前通过链接器链接。所有这些都属于构建过程的一部分。一旦构建了最终的可执行文件，它就会被加载器加载到内存中。Java的工作方式不同。
- en: Java source code (`.java`) is compiled by Java Compiler (`javac`) to bytecode
    (`.class`) files. Class loader is one of the key subsystems of the JVM, which
    is responsible for loading all the dependent classes that are required to run
    the application. This includes the classes that are written by the application
    developer, the libraries, and the **Java Software Development Kit** (**SDK**)
    classes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码（`.java`）由Java编译器（`javac`）编译成字节码（`.class`）文件。类加载器是JVM的关键子系统之一，负责加载运行应用程序所需的所有依赖类。这包括应用程序开发者编写的类、库以及**Java软件开发工具包**（**SDK**）类。
- en: 'There are three types of class loaders as part of this system:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统包括三种类型的类加载器：
- en: '`rt.jar`, which contains all the Java Standard Edition JDK classes, such as
    `java.lang`, `java.net`, `java.util`, and `java.io`. Bootstrap is responsible
    for loading all the classes that are required to run any Java application. This
    is a core part of the JVM and is implemented in the native language.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rt.jar`，其中包含所有Java标准版JDK类，如`java.lang`、`java.net`、`java.util`和`java.io`。引导加载器负责加载运行任何Java应用程序所需的所有类。这是JVM的核心部分，用本地语言实现。'
- en: '`jre`/`lib`/`ext` directory. Extension class loader classes are typically extension
    classes of the bootstrap implemented in Java. The extension class loader is implemented
    in Java (`sun.misc.Launcher$ExtClassLoader.class`).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jre`/`lib`/`ext`目录。扩展类加载器类通常是Java中实现的引导扩展类。扩展类加载器用Java实现（`sun.misc.Launcher$ExtClassLoader.class`）。'
- en: '`CLASSPATH` env variable). This is also implemented in Java (`sun.misc.Launcher$AppClassLoader.class`).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLASSPATH`环境变量）。这也用Java实现（`sun.misc.Launcher$AppClassLoader.class`）。'
- en: Bootstrap, extension, and application class loaders are responsible for loading
    all the classes that are required to run the application. In the event where the
    class loaders do not find the required classes, `ClassNotFoundException` is thrown.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 引导、扩展和应用程序类加载器负责加载运行应用程序所需的所有类。在类加载器找不到所需类的情况下，将抛出`ClassNotFoundException`。
- en: 'Class loaders implement the delegation hierarchy algorithm. The following diagram
    shows how the class loader implements the delegation hierarchy algorithm to load
    all the required classes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器实现了委托层次算法。以下图表显示了类加载器如何实现委托层次算法来加载所有必需的类：
- en: '![Figure 1.4 – Class loader delegation hierarchy algorithm implementation flowchart'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – 类加载器委托层次算法实现流程图](img/B16878_Figure_1.4.jpg)'
- en: '](img/B16878_Figure_1.4.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_1.4.jpg)'
- en: Figure 1.4 – Class loader delegation hierarchy algorithm implementation flowchart
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 类加载器委托层次算法实现流程图
- en: 'Let''s understand how this algorithm works:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这个算法是如何工作的：
- en: JVM looks for the class in the method area (this will be discussed in detail
    later in this section). If it does not find the class, it will ask the application
    class loader to load the class into memory.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM将在方法区中查找类（将在本节稍后详细讨论）。如果没有找到类，它将要求应用程序类加载器将类加载到内存中。
- en: The application class loader delegates the call to the extension class loader,
    which in turn delegates to the bootstrap class loader.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序类加载器将调用委托给扩展类加载器，扩展类加载器再委托给引导类加载器。
- en: The bootstrap class loader looks for the class in the bootstrap `CLASSPATH`.
    If it finds the class, it will load to the memory. If it does not find the class,
    control is delegated to the extension class loader.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导类加载器将在引导`CLASSPATH`中查找类。如果找到类，它将加载到内存中。如果没有找到类，控制权将委托给扩展类加载器。
- en: The extension class loader will try to find the class in the extension `CLASSPATH`.
    If it finds the class, it will load to the memory. If it does not find the class,
    control is delegated to the application class loader.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展类加载器将尝试在扩展`CLASSPATH`中查找类。如果找到类，它将加载到内存中。如果没有找到类，控制权将委托给应用程序类加载器。
- en: The application class loader will try to look for the class in `CLASSPATH`.
    If it does not find it, it will raise `ClassNotFoundException`, otherwise, the
    class is loaded into the method area, and the JVM will start using it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序类加载器将尝试在`CLASSPATH`中查找类。如果找不到，它将抛出`ClassNotFoundException`，否则，该类将被加载到方法区，JVM将开始使用它。
- en: Linking
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接
- en: 'Once the classes are loaded into the memory (into the method area, discussed
    further in the *Memory subsystem* section), the class loader subsystem will perform
    linking. The linking process consists of the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类被加载到内存中（到方法区，在*内存子系统*部分将进一步讨论），类加载器子系统将执行链接。链接过程包括以下步骤：
- en: '`java.lang.Object`. The verification phase validates and ensures that the methods
    run without any issues.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Object`。验证阶段验证并确保方法运行时没有任何问题。'
- en: '**Preparation**: Once all the classes are loaded and verified, JVM allocates
    memory for class variables (static variables). This also includes calling static
    initializations (static blocks).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：一旦所有类都加载并验证，JVM将为类变量（静态变量）分配内存。这也包括调用静态初始化（静态块）。'
- en: '**Resolution**: JVM then resolves by locating the classes, interfaces, fields,
    and methods referenced in the symbol table. The JVM might resolve the symbol during
    initial verification (static resolution) or may resolve when the class is being
    verified (lazy resolution).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析**：JVM通过定位符号表中引用的类、接口、字段和方法来进行解析。JVM可能在初始验证（静态解析）期间解析符号，也可能在类正在验证时解析（懒解析）。'
- en: 'The class loader subsystem raises various exceptions, including the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器子系统会抛出各种异常，包括以下内容：
- en: '`ClassNotFoundException`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassNotFoundException`'
- en: '`NoClassDefFoundError`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoClassDefFoundError`'
- en: '`ClassCastException`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassCastException`'
- en: '`UnsatisfiedLinkError`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnsatisfiedLinkError`'
- en: '`ClassCircularityError`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassCircularityError`'
- en: '`ClassFormatError`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassFormatError`'
- en: '`ExceptionInInitializerError`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExceptionInInitializerError`'
- en: 'You can refer to the Java specifications for more details: [https://docs.oracle.com/en/java/javase](https://docs.oracle.com/en/java/javase).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考Java规范以获取更多详细信息：[https://docs.oracle.com/en/java/javase](https://docs.oracle.com/en/java/javase)。
- en: Initializing
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化
- en: Once all the classes are loaded and symbols are resolved, the initialization
    phase starts. During this phase, the classes are initialized (new). This includes
    initializing the static variables, executing static blocks, and invocating reflective
    methods (`java.lang.reflect`). This might also result in loading those classes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有类都被加载并且符号被解析，初始化阶段就开始了。在这个阶段，类被初始化（new）。这包括初始化静态变量、执行静态块和调用反射方法（`java.lang.reflect`）。这也可能导致加载那些类。
- en: Class loaders load all the classes into the memory before the application can
    run. Most of the time, the class loader has to load the full hierarchy of classes
    and dependent classes (though there is lazy resolution) to validate the schematics.
    This is time-consuming and also takes up a lot of memory footprint. It's even
    slower if the application uses reflection and the reflected classes need to be
    loaded.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器在应用程序运行之前将所有类加载到内存中。大多数情况下，类加载器必须加载完整的类层次结构和依赖类（尽管存在延迟解析），以验证方案。这既耗时又占用大量内存。如果应用程序使用反射并且需要加载反射类，那么这个过程会更慢。
- en: After learning about the class loader subsystem, let's now understand how the
    memory subsystem works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解类加载器子系统之后，现在让我们来理解内存子系统是如何工作的。
- en: Memory subsystem
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存子系统
- en: 'The memory subsystem is one of the most critical subsystems of the JVM. The
    memory subsystem, as the name suggests, is responsible for managing the allocated
    memory of method variables, heaps, stacks, and registers. The following diagram
    shows the architecture of the memory subsystem:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 内存子系统是JVM中最关键的子系统之一。正如其名称所暗示的，内存子系统负责管理方法变量、堆栈、栈和寄存器分配的内存。以下图表显示了内存子系统的架构：
- en: '![Figure 1.5 – Memory subsystem architecture'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5 – 内存子系统架构'
- en: '](img/B16878_Figure_1.5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_1.5.jpg)'
- en: Figure 1.5 – Memory subsystem architecture
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 内存子系统架构
- en: 'The memory subsystem has two areas: JVM level and thread level. Let''s discuss
    each in detail.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 内存子系统有两个区域：JVM级别和线程级别。让我们详细讨论每个区域。
- en: JVM level
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JVM级别
- en: 'JVM-level memory, as the name suggests, is where the objects are stored at
    the JVM level. This is not thread-safe, as multiple threads might be accessing
    these objects. This explains why programmers are recommended to code thread-safe
    (synchronization) when they update the objects in this area. There are two areas
    of JVM-level memory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JVM级别的内存，正如其名称所暗示的，是对象在JVM级别存储的地方。这不是线程安全的，因为多个线程可能会访问这些对象。这也解释了为什么当程序员在这个区域更新对象时，建议他们编写线程安全的（同步）代码。JVM级别的内存有两个区域：
- en: '**Method**: The method area is where all the class-level data is stored. This
    includes the class names, hierarchy, methods, variables, and static variables.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：方法区是存储所有类级别数据的地方。这包括类名、层次结构、方法、变量和静态变量。'
- en: '**Heap**: The heap is where all the objects and the instance variables are
    stored.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆**：堆是存储所有对象和实例变量的地方。'
- en: Thread level
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程级别
- en: 'Thread-level memory is where all the thread-local objects are stored. This
    is accessible/visible to the respective threads, hence it is thread-safe. There
    are three areas of the thread-level memory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 线程级别的内存是存储所有线程局部对象的地方。这对相应的线程是可访问/可见的，因此它是线程安全的。线程级别的内存有三个区域：
- en: '**Stack**: For each method call, a stack frame is created, which stores all
    the method-level data. The stack frame consists of all the variables/objects that
    are created within the method scope, operand stack (used to perform intermediate
    operations), the frame data (which stores all the symbols corresponding to the
    method), and exception catch block information.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈**：对于每个方法调用，都会创建一个栈帧，用于存储所有方法级别的数据。栈帧包括在方法作用域内创建的所有变量/对象、操作数栈（用于执行中间操作）、帧数据（存储与方法对应的所有符号）以及异常捕获块信息。'
- en: '**Registers**: PC registers keep track of the instruction execution and point
    to the current instruction that is being executed. This is maintained for each
    thread that is executing.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器**：PC寄存器跟踪指令执行并指向正在执行的当前指令。这为每个正在执行的线程维护。'
- en: '**Native Method Stack**: The native method stack is a special type of stack
    that stores the native method information, which is useful when calling and executing
    the native methods.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地方法栈**：本地方法栈是一种特殊的栈，用于存储本地方法信息，这在调用和执行本地方法时非常有用。'
- en: Now that the classes are loaded into the memory, let's look at how the JVM execution
    engine works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类已经被加载到内存中，让我们看看JVM执行引擎是如何工作的。
- en: JVM execution engine subsystem
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM 执行引擎子系统
- en: 'The JVM execution engine is the core of the JVM, where all the execution happens.
    This is where the bytecodes are interpreted and executed. The JVM execution engine
    uses the memory subsystem to store and retrieve the objects. There are three key
    components of the JVM execution engine, as shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 执行引擎是 JVM 的核心，所有执行都在这里发生。这是字节码被解释和执行的地方。JVM 执行引擎使用内存子系统来存储和检索对象。JVM 执行引擎有三个关键组件，如下所示：
- en: '![Figure 1.6 – JVM execution engine architecture'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – JVM 执行引擎架构'
- en: '](img/B16878_Figure_1.6.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_1.6.jpg)'
- en: Figure 1.6 – JVM execution engine architecture
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – JVM 执行引擎架构
- en: We will talk about each component in detail in the following sections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细讨论每个组件。
- en: Bytecode interpreter
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字节码解释器
- en: As mentioned earlier in this chapter, bytecode (`.class`) is the input to the
    JVM. The JVM bytecode interpreter picks each instruction from the `.class` file
    and converts it to machine code and executes it. The obvious disadvantage of interpreters
    is that they are not optimized. The instructions are executed in sequence, and
    even if the same method is called several times, it goes through each instruction,
    interprets it, and then executes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，字节码（`.class`）是 JVM 的输入。JVM 字节码解释器从 `.class` 文件中选取每条指令，将其转换为机器码并执行。解释器的明显缺点是它们没有被优化。指令按顺序执行，即使同一个方法被多次调用，它也会逐条指令执行，解释后再执行。
- en: JIT compiler
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JIT 编译器
- en: The JIT compiler saves the day by profiling the code that is being executed
    by interpreters, identifies areas where the code can be optimized and compiles
    them to target machine code, so that they can be executed faster. A combination
    of bytecode and compiled code snippets provide the optimum way to execute the
    class files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 编译器通过分析由解释器执行的代码，识别出代码可以优化的区域，并将它们编译为目标机器码，以便它们可以更快地执行。字节码和编译代码片段的组合提供了执行类文件的最佳方式。
- en: 'The following diagram illustrates the detailed workings of JVM, along with
    the various types of JIT compilers that the JVM uses to optimize the code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示详细说明了 JVM 的工作原理，以及 JVM 使用的各种类型的 JIT 编译器来优化代码：
- en: '![Figure 1.7 – The detailed working of JVM with JIT compilers'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – JVM 与 JIT 编译器的详细工作原理'
- en: '](img/B16878_Figure_1.7.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_1.7.jpg)'
- en: Figure 1.7 – The detailed working of JVM with JIT compilers
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – JVM 与 JIT 编译器的详细工作原理
- en: 'Let''s understand the workings shown in the previous diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解前面图示中显示的工作原理：
- en: The JVM interpreter steps through each bytecode and interprets it with machine
    code, using the bytecode to machine code mapping.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM 解释器逐个字节码执行，并使用机器码对其进行解释，利用字节码到机器码的映射。
- en: JVM profiles the code consistently using a counter, to count the number of times
    a code is executed, and if the counter reaches a threshold, it uses the JIT compiler
    to compile that code for optimization and stores it in the code cache.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM 使用计数器持续分析代码，以统计代码执行的次数，如果计数器达到阈值，它将使用 JIT 编译器编译该代码以进行优化，并将其存储在代码缓存中。
- en: JVM then checks whether that compilation unit (block) is already compiled. If
    JVM finds a compiled code in the code cache, it will use the compiled code for
    faster execution.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM 然后检查该编译单元（块）是否已经编译。如果 JVM 在代码缓存中找到已编译的代码，它将使用这些已编译的代码以实现更快的执行。
- en: JVM uses two types of compilers, the C1 compiler and the C2 compiler, to compile
    the code.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM 使用两种类型的编译器，C1 编译器和 C2 编译器，来编译代码。
- en: As illustrated in *Figure 1.7*, the JIT compiler brings in optimizations by
    profiling the code that is running and, over a period of time, it identifies the
    code that can be compiled. The JVM runs the compiled snippets of code instead
    of interpreting the code. It is a hybrid method of running interpreted code and
    compiled code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 1.7* 所示，JIT 编译器通过分析正在运行的代码进行优化，并在一段时间内识别出可以编译的代码。JVM 运行编译后的代码片段，而不是解释代码。这是一种运行解释代码和编译代码的混合方法。
- en: 'JVM introduced two types of compilers, C1 (client) and C2 (server), and the
    recent versions of JVM use the best of both for optimizing and compiling the code
    at runtime. Let''s understand these types better:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 引入了两种类型的编译器，C1（客户端）和 C2（服务器），而 JVM 的最新版本则结合了两者在运行时优化和编译代码的最佳性能。让我们更好地理解这些类型：
- en: '**C1 compiler**: A performance counter was introduced, which counted the number
    of times a particular method/snippet of code is executed. Once a method/code snippet
    is used a particular number of times (threshold), then that particular code snippet
    is compiled, optimized, and cached by the C1 compiler. The next time that code
    snippet is called, it directly executes the compiled machine instructions from
    the cache, rather than going through the interpreter. This brought in the first
    level of optimization.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C1 编译器**：引入了一个性能计数器，用于计算特定方法/代码片段执行的次数。一旦方法/代码片段被使用特定次数（阈值），则该代码片段将由 C1 编译器编译、优化和缓存。下次调用该代码片段时，它将直接从缓存中执行编译后的机器指令，而不是通过解释器。这引入了第一级优化。'
- en: '**C2 compiler**: While the code is getting executed, the JVM will perform runtime
    code profiling and come up with code paths and hotspots. It then runs the C2 compiler
    to further optimize the hot code paths. This is also known as a hotspot.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C2 编译器**：在代码执行过程中，JVM 将执行运行时代码分析，确定代码路径和热点。然后运行 C2 编译器以进一步优化热点代码路径。这也被称为热点。'
- en: C1 is faster and good for short-running applications, while C2 is slower and
    heavy, but is ideal for long-running processes such as daemons and servers, so
    the code performs better over time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: C1 编译器更快，适合短运行时应用，而 C2 编译器较慢且重量级，但非常适合长时间运行的过程，如守护进程和服务器，因此代码在长时间运行中表现更佳。
- en: In Java 6, there is a command-line option to use either C1 or C2 methods (with
    the command-line arguments `-client` (for C1) and `-server` (for C2)). In Java
    7, there is a command-line option to use both. Since Java 8, both C1 and C2 compilers
    are used for optimization as the default behavior.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 6 中，有一个命令行选项可以用来选择使用 C1 或 C2 方法（使用命令行参数 `-client`（用于 C1）和 `-server`（用于
    C2））。在 Java 7 中，有一个命令行选项可以同时使用两者。自 Java 8 以来，C1 和 C2 编译器都用于优化，作为默认行为。
- en: 'There are five tiers/levels of compilation. Compilation logs can be generated
    to understand which Java method is compiled using which compiler tier/level. The
    following are the five tiers/levels of compilation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编译有五个层级/级别。可以通过生成编译日志来了解哪个 Java 方法使用了哪个编译器层级/级别。以下为五个编译层级/级别：
- en: Interpreted code (level 0)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释代码（级别 0）
- en: Simple C1 compiled code (level 1)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的 C1 编译代码（级别 1）
- en: Limited C1 compiled code (level 2)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限的 C1 编译代码（级别 2）
- en: Full C1 compiled code (level 3)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的 C1 编译代码（级别 3）
- en: C2 compiled code (level 4)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C2 编译代码（级别 4）
- en: Let's now look at the various types of code optimizations that the JVM applies
    during compilation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 JVM 在编译过程中应用的各类代码优化。
- en: Code optimizations
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码优化
- en: The JIT compiler generates the internal representation of the code that is being
    compiled to understand the semantics and syntax. These internal representations
    are tree data structures, on which the JIT will then run the code optimization
    (as multiple threads, which can be controlled with the `XcompilationThreads` options
    from the command line).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 编译器生成正在编译的代码的内部表示，以理解其语义和语法。这些内部表示是树形数据结构，JIT 将在这些结构上运行代码优化（作为多个线程，可以通过命令行的
    `XcompilationThreads` 选项进行控制）。
- en: 'The following are some of the optimizations that the JIT compilers perform
    on the code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 JIT 编译器对代码执行的优化：
- en: '`-XX:MaxFreqInlineSize` flag (by default, it is 325 bytes).'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MaxFreqInlineSize` 标志（默认值为 325 字节）。'
- en: '**Escape analysis**: The JVM profiles the variables to analyze the scope of
    the usage of the variables. If the variables don''t escape the local scope, it
    then performs local optimization. Lock Elision is one such optimization, where
    the JVM decided whether a synchronization lock is really required for the variable.
    Synchronization locks are very expensive to the processor. The JVM also decides
    to move the object from the heap to the stack. This has a positive impact on memory
    usage and garbage collection, as the objects are destroyed once the method is
    executed.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逃逸分析**：JVM 对变量进行配置以分析变量的使用范围。如果变量没有超出局部作用域，它将执行局部优化。锁消除就是这样一种优化，其中 JVM 决定是否真的需要为变量使用同步锁。同步锁对处理器来说非常昂贵。JVM
    还决定将对象从堆移动到栈上。这有助于提高内存使用率和垃圾收集效率，因为对象在方法执行完毕后就会被销毁。'
- en: '**DeOptimization**: DeOptimization is another critical optimization technique.
    The JVM profiles the code after optimization and may decide to deoptimize the
    code. Deoptimizations will have a momentary impact on performance. The JIT compiler
    decides to deoptimize in two cases:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消优化**：取消优化是另一种关键的优化技术。JVM 在优化后对代码进行分析，并可能决定取消优化代码。取消优化将对性能产生短暂的影响。JIT 编译器在两种情况下决定取消优化：'
- en: 'a. **Not Entrant Code**: This is very prominent in inherited classes or interface
    implementations. JIT may have optimized, assuming a particular class in the hierarchy,
    but over time when it learns otherwise, it will deoptimize and profile for further
    optimization of more specific class implementations.'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. **非进入代码**：这在继承类或接口实现中非常明显。JIT 可能已经针对层次结构中的特定类进行了优化，但随着时间的推移，当它了解到不同的情况时，它将取消优化并针对更具体的类实现进行进一步优化。
- en: 'b. **Zombie Code**: During Not Entrant code analysis, some of the objects get
    garbage collected, leading into code that may never be called. This code is marked
    as zombie code. This code is removed from the code cache.'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. **僵尸代码**：在非进入代码分析期间，一些对象被垃圾收集，导致可能永远不会被调用的代码。这种代码被标记为僵尸代码。此代码将从代码缓存中删除。
- en: Apart from this, the JIT compiler performs other optimizations, such as control
    flow optimization, which includes rearranging code paths to improve efficiency
    and native code generation to the target machine code for faster execution.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，JIT 编译器还执行其他优化，例如控制流优化，这包括重新排列代码路径以提高效率，并将本地代码生成到目标机器代码以实现更快的执行。
- en: JIT compiler optimizations are performed over a period of time, and they are
    good for long-running processes. We will be going into a detailed explanation
    on JIT compilation in [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)*,
    JIT, Hotspot, and GraalVM*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 编译器的优化是在一段时间内进行的，这对于长时间运行的过程很有好处。我们将在[*第 2 章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)*，JIT、Hotspot
    和 GraalVM*中详细解释 JIT 编译。
- en: Java ahead-of-time compilation
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Java 预编译
- en: The ahead-of-time compilation option was introduced with Java 9 with `jaotc`,
    where a Java application code can be directly compiled to generate final machine
    code. The code is compiled to a target architecture, so it is not portable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译选项是在 Java 9 中通过 `jaotc` 引入的，它可以将 Java 应用程序代码直接编译成最终机器代码。代码被编译为目标架构，因此它不是可移植的。
- en: 'Java supports running both Java bytecode and AOT compiled code together in
    an x86 architecture. The following diagram illustrates how it works. This is the
    most optimum code that Java can generate:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Java 支持在 x86 架构上同时运行 Java 字节码和 AOT 编译的代码。以下图表说明了它是如何工作的。这是 Java 可以生成的最优化代码：
- en: '![Figure 1.8 – The detailed workings of JVM JIT time compilers along with the
    ahead-of-time compiler'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8 – JVM JIT 时间编译器和预编译器的详细工作原理]'
- en: '](img/B16878_Figure_1.8.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B16878_1.8](img/B16878_Figure_1.8.jpg)'
- en: Figure 1.8 – The detailed workings of JVM JIT time compilers along with the
    ahead-of-time compiler
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – JVM JIT 时间编译器和预编译器的详细工作原理
- en: The bytecode will go through the approach that was explained previously (C1,
    C2). `jaotc` compiles the most used java code (like libraries) into machine code,
    ahead of time, and this is directly loaded into the code cache. This will reduce
    the load on JVM. The Java byte code goes through the usual interpreter, and uses
    the code from the code cache, if available. This reduces a lot of load on JVM
    to compile the code at runtime. Typically, the most frequently used libraries
    can be AOT compiled for faster responses.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码将通过之前解释的方法（C1、C2）。`jaotc` 预先编译最常用的 Java 代码（如库）成机器代码，并将其直接加载到代码缓存中。这将减少 JVM
    的负载。Java 字节码将通过常规解释器，并使用代码缓存中的代码（如果可用）。这将大大减少 JVM 在运行时编译代码的负载。通常，最常用的库可以预先编译以实现更快的响应。
- en: Garbage collector
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垃圾收集器
- en: One of the sophistication of Java is its in-built memory management. In languages
    such as C/C++, the programmer is expected to allocate and de-allocate the memory.
    In Java, JVM takes care of cleaning up the unreferenced objects and reclaims the
    memory. The garbage collector is a daemon thread that performs the cleanup either
    automatically or can also be invoked by the programmer (`System.gc()` and `Runtime.getRuntime().gc()`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的一个复杂之处在于其内置的内存管理。在 C/C++ 等语言中，程序员需要负责分配和释放内存。在 Java 中，JVM 负责清理未引用的对象并回收内存。垃圾收集器是一个守护线程，它自动执行清理工作，也可以由程序员调用（`System.gc()`
    和 `Runtime.getRuntime().gc()`）。
- en: Native subsystem
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地子系统
- en: 'Java allows programmers to access native libraries. Native libraries are typically
    those libraries that are built (using languages such as C/C++) and used for a
    specific target architecture. **Java Native Interface** (**JNI**) provides an
    abstraction layer and interface specification for implementing the bridge to access
    the native libraries. Each JVM implements JNI for the specific target system.
    Programmers can also use JNI to call the native methods. The following diagram
    illustrates the components of the native subsystem:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Java 允许程序员访问原生库。原生库通常是那些为特定目标架构构建（使用如 C/C++ 等语言）并使用的库。**Java 原生接口**（**JNI**）提供了一个抽象层和接口规范，用于实现访问原生库的桥梁。每个
    JVM 都为特定的目标系统实现了 JNI。程序员还可以使用 JNI 来调用原生方法。以下图表说明了原生子系统的组件：
- en: '![Figure 1.9 – Native subsystem architecture'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – 原生子系统架构'
- en: '](img/B16878_Figure_1.9.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_1.9.jpg)'
- en: Figure 1.9 – Native subsystem architecture
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 原生子系统架构
- en: The native subsystem provides the implementation to access and manage the native
    libraries.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 原生子系统提供了访问和管理原生库的实现。
- en: JVM has evolved and has one of the most sophisticated implementations of a language
    VM runtime.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 已经发展并拥有语言 VM 运行时最复杂的实现之一。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by learning what GraalVM is, followed by understanding
    how JVM works and its architecture, along with its various subsystems and components.
    Later on, we also learned how JVM combines the best of interpreters and the compiler
    approach to run Java code on various target architectures, along with how a code
    is compiled just-in-time with C1 and C2 compilers. Lastly, we learned about various
    types of code optimizations that the JVM performs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了 GraalVM 是什么，然后了解了 JVM 的工作原理及其架构，包括其各种子系统和组件。稍后，我们还学习了 JVM 如何结合解释器和编译器的最佳方法在多种目标架构上运行
    Java 代码，以及代码是如何通过 C1 和 C2 编译器即时编译的。最后，我们学习了 JVM 执行的各种类型的代码优化。
- en: This chapter provided a good understanding of the architecture of JVM, which
    will help us understand how the GraalVM architecture works and how it is built
    on top of JVM.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了对 JVM 架构的良好理解，这将帮助我们了解 GraalVM 架构的工作原理以及它是如何建立在 JVM 之上的。
- en: The next chapter will cover the details of how JIT compilers work and help you
    understand how Graal JIT builds on top of JVM JIT.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖 JIT 编译器的工作原理的细节，并帮助您了解 Graal JIT 是如何建立在 JVM JIT 之上的。
- en: Questions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is Java code interpreted to bytecode and later compiled at runtime?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 Java 代码会被解释成字节码，并在运行时编译？
- en: How does JVM load the appropriate class files and link them?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM 如何加载适当的类文件并将它们链接起来？
- en: What are the various types of memory areas in JVM?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM 中有哪些不同类型的内存区域？
- en: What is the difference between the C1 compiler and the C2 compiler?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C1 编译器和 C2 编译器之间的区别是什么？
- en: What is a code cache in JVM?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM 中的代码缓存是什么？
- en: What are the various types of code optimizations that are performed just in
    time?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立即执行时执行的各种代码优化类型有哪些？
- en: Further reading
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Introduction to JVM Languages*, by Vincent van der Leun, Packt Publishing
    ([https://www.packtpub.com/product/introduction-to-jvm-languages/9781787127944](https://www.packtpub.com/product/introduction-to-jvm-languages/9781787127944))'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《JVM 语言入门》，作者 Vincent van der Leun，Packt 出版公司 ([https://www.packtpub.com/product/introduction-to-jvm-languages/9781787127944](https://www.packtpub.com/product/introduction-to-jvm-languages/9781787127944))
- en: '*Java Documentation and Specification*, by Oracle ([https://docs.oracle.com/en/java/](https://docs.oracle.com/en/java/))'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Java 文档和规范》，作者 Oracle ([https://docs.oracle.com/en/java/](https://docs.oracle.com/en/java/))
