- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documenting Your API Effectively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comprehensive **documentation** is essential for ensuring clients understand
    how to use your API effectively. In this chapter, we will explore the process
    of documenting a REST API using **Swagger** annotations and best practices. We’ll
    delve into several key topics to provide you with a comprehensive understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we’ll discuss the importance of API specifications by examining the
    **OpenAPI Specification** and **JSON Schema** , essential standards that define
    the structure and format of API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also explore the debate between **code-first** and **specification-first**
    approaches in API development, discussing their respective advantages and considerations.
    Following this, we’ll document the Product API, illustrating how to use Swagger
    annotations effectively to describe endpoints, parameters, responses, and other
    critical details.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll demonstrate the practical utility of the Swagger **user interface**
    ( **UI)** , a powerful tool for visualizing and interacting with API documentation,
    enhancing developer experience and facilitating seamless API consumption. Through
    these discussions and examples, you will gain insights into creating well-documented,
    standardized REST APIs that promote interoperability and ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importance of API specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing OpenAPI and JSON Schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between specification-first and code-first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting the Product API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Swagger UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will implement the documentation for our Product API. To
    be able to follow along and use the code examples as they are printed in this
    book, you should have the Product API code that was created in the previous chapter.
    You can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter3](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter3)
    . The code added in this chapter will not change the actual functionality of the
    API; it will only provide metadata to generate the documentation for the API.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of API specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us begin by discussing what API specifications are and why they are important.
  prefs: []
  type: TYPE_NORMAL
- en: From Java, we know the principles of object-oriented programming. One of those
    principles is **encapsulation** , which involves making as many members of a class
    private as possible. Only those members (typically methods) that are explicitly
    intended for external access should be made public. The collection of these public
    members forms the class’s API. It is good practice to accompany the public members
    by Javadoc so that their usage is clear without seeing the code implementing the
    class. By limiting the size of the public API, we retain the liberty to change
    or remove the internal (private) members without breaking code outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: We should also be cautious when defining the signatures of public methods. Passing
    unnecessary data via arguments or return values can cause unnecessary coupling,
    increase the complexity of the code processing the data (e.g., validations or
    ensuring immutability), and limit the possibilities of performance optimization.
  prefs: []
  type: TYPE_NORMAL
- en: A poorly designed API, whose structure is driven more by the ease of technical
    implementation rather than business requirements, can expose elements that should
    be hidden. Once such an API is in use, it becomes difficult to change because
    there may be clients outside our control who depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: If this is true for APIs within a single Java program, it is even more crucial
    for REST APIs that cross the boundaries of individual programs to have clearly
    separated interfaces and thorough documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Although it may be necessary to provide API users with some additional information
    using prose, we can greatly benefit from describing as much as possible of our
    API using a formal and machine-readable specification language. For REST APIs,
    the most widely used and advanced standard is **OpenAPI** .
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OpenAPI and JSON Schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **OpenAPI Specification** , backed by the OpenAPI Initiative ( [https://www.openapis.org/](https://www.openapis.org/)
    ), defines a formal language that both humans and computers can read to learn
    about the capabilities of a service without the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to the service implementation code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate documentation in another format (language)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the network traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenAPI Specification was originally based on the Swagger Specification.
    OpenAPI can describe any API using the HTTP protocol, including RESTful APIs at
    any maturity level.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI Specification documents can be written in JSON and YAML formats. The
    YAML syntax ( [https://yaml.org/](https://yaml.org/) ) replaces a lot of the JSON
    punctuation with indentation; therefore, YAML tends to be more concise and easier
    to read for many humans. In this book, we will use the YAML format for all OpenAPI
    Specifications written manually (not generated by tools).
  prefs: []
  type: TYPE_NORMAL
- en: 'The two most important (and usually longest) parts of a typical OpenAPI Specification
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Paths** : These describe the actions that the API supports, specified by
    resources, HTTP methods, URI parameters, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schemas** : These describe the complex data structures of the request and
    response bodies (payloads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our Product API uses two paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/products/{productId}` : This supports the `GET` , `PUT` , `DELETE` ,
    and `PATCH` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/products` : This supports the `GET` method only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following schemas are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductInput` : This is used for full product data in requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductDescriptionInput` : This is used to update the product description
    only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductOutput` : This is used for product data in responses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProblemDetail` : This is used for error responses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format we use to transfer complex data through our API is JSON, which is
    why the schemas part of the OpenAPI Specification uses a dialect of a specification
    language called JSON Schema.
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON Schema** is a separate standard that can be used to validate JSON documents
    outside the scope of OpenAPI Specifications. The schema part of every version
    of the OpenAPI Specification is based on a version of the JSON Schema standard,
    plus some OpenAPI-specific modifications. This is why it is called a **dialect**
    of the JSON Schema. It is important to use the features of the schemas section
    supported by the version of the OpenAPI Specification that we want to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what the OpenAPI Specification of our Product API would look like.
    We will use YAML syntax. In the following subsections, some attributes of the
    API specification are omitted for brevity. You can see the full specification
    in the accompanying GitHub repository at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter3/product-api/src/main/resources/Product_Catalogue_API.yml](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter3/product-api/src/main/resources/Product_Catalogue_API.yml)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Common API metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the two main parts of the specification mentioned earlier, there are
    header sections providing metadata about the API and its specification. They define
    the version of the OpenAPI standard, the version of our API, the base URL for
    the API, and some human-readable names and descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Product API paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following parts of the Product API specification are the paths, starting
    with the `GET` method for `/api/products/{productId}` . The `$ref` notation is
    used to refer to the schemas. There are separate response specifications for the
    `200` , `400` , and `404` HTTP response codes. We can also see the specification
    of the required `productId` URI parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The same path continues with the specification of the `PUT` method that needs
    a request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: (The response bodies for the other status codes are omitted.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at one more operation: the one returning the list of products (represented
    by a JSON array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Product API schemas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Putting the named schemas in a separate part of the specification lets us reuse
    them for multiple operations, for example, the `ProductOutput` schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `example` attribute, we can provide additional information about
    the data elements that can be used by both humans and automated tools (test client
    or mock server generators). Without the `example` attribute, anyone who wants
    to test our API would have to guess meaningful values solely based on their types.
    Generating random strings would lead to unrealistic examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `ProblemDetail` schema used for error responses is so generic that it is
    likely that we will want to reuse it across multiple APIs (microservices). OpenAPI
    Specifications can be divided into multiple files. We can also host the reusable
    schemas on a web server and refer to them using HTTP URLs.
  prefs: []
  type: TYPE_NORMAL
- en: However, we should bear in mind that it brings coupling among the different
    APIs, so this kind of reuse should only be used with schemas that rarely change
    (the `ProblemDetail` schema fulfills this criterion).
  prefs: []
  type: TYPE_NORMAL
- en: We have introduced the basic structure and the most important attributes of
    OpenAPI Specifications. We will get to more advanced OpenAPI features in the following
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following section, you will learn about an important decision you have
    to make: This is whether you want to start with an explicit abstract specification
    document, such as the one shown earlier, or derive it from Java code.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between specification-first and code-first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We made it clear that for the success of our API, we need both a concrete implementation
    and an abstract specification of the interface it implements. There are two basic
    approaches when creating APIs: **specification-first** (also known as *design-first*
    or *API-first* ) and **code-first** .'
  prefs: []
  type: TYPE_NORMAL
- en: Specification-first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with the specification forces the API developers to decide upfront
    what needs to be in the public part of the API. Intentional hiding of the details
    the consumers do not need to know makes the API as small as possible and hence
    easier to maintain and evolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the pros of specification-first:'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone specifications tend to be smaller as they only define the elements
    of the API needed to satisfy the business requirements; the APIs defined by separate
    specification documents are easier to maintain, and the specification changes
    are more controllable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specification-first ensures the API specification is not biased to any implementation
    language, supporting API providers and consumers written in multiple languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get the ability to develop the API provider and consumers in parallel. The
    interface between the connected parties can be negotiated without going into the
    details of the implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests can be created before the API is implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifications written manually (not generated) are easier for humans to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of specification-first:'
  prefs: []
  type: TYPE_NORMAL
- en: The development team needs to master the API specification language in addition
    to the implementation programming language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To maintain consistency between the specification and the code, we need tools
    to generate code stubs from the specification. The code generators available may
    not support all the features of both the specification and the implementation
    language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code-first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Code-first** prioritizes the short-term speed of implementation over clean
    interface design. The API specification is actually reverse-engineered from the
    implementation code. Annotations on code elements and additional metadata are
    added manually to aid the tool used to generate the specification.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the pros of code-first:'
  prefs: []
  type: TYPE_NORMAL
- en: Skipping the specification step leads to a working API faster; this makes sense
    for rapid prototyping or low-impact APIs whose clients are under our control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the implementation and the interface are written in one language (usually
    with the help of some annotations or metadata)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having the implementation code available may help to include performance or
    other non-functional considerations in the API specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of code-first:'
  prefs: []
  type: TYPE_NORMAL
- en: Need to explicitly prevent unwanted implementation details from leaking in the
    generated specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to master the specification generation tools with their annotations specific
    to each implementation language instead of using a standard implementation-agnostic
    specification language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard to generate polished and nice-to-read specifications, especially for more
    complex APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure of the APIs developed without the conscious API design step is
    likely to reflect the (first) technical implementation rather than the business
    domain. This is why they tend to be hard to maintain and evolve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will demonstrate the code-first approach for the Product
    API because we already have its implementation code from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The specification-first approach will be shown in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the Product API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To document our API, we will need to add some dependencies from Swagger. In
    the case of the Spring framework, we have the `springdoc-openapi-starter-webmvc-ui`
    dependency, which covers all we need to document the API of the Spring application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Adding this dependency in `pom.xml` allows us to use the Swagger annotations
    and the Swagger UI. After accessing `http://localhost:8080/swagger-ui/index.html`
    , we can see the Swagger UI, represented in *Figure 3.1* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Swagger UI](img/B21843_03_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: The Swagger UI is generated based on `RestController` and our endpoints. To
    make our API more user-friendly and comprehensible for clients, we should enhance
    it using Swagger annotations. These annotations are available in the `io.swagger.v3.oas.annotations`
    package. Let us explore some of them and see how they can be applied to improve
    our API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Swagger annotations** are a set of annotations provided by the Swagger library
    used to generate interactive API documentation for RESTful web services. These
    annotations, when added to your code, help define and describe the structure and
    behavior of your API endpoints, request and response models, and overall API metadata.'
  prefs: []
  type: TYPE_NORMAL
- en: '@Tag'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@Tag` annotation is used to group a set of operations; we can use it in
    our API class to inform that every method in this class should belong to this
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '@Operation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@Operation` annotation is used in method declarations to name API endpoints.
    This annotation can be combined with other annotations to provide a comprehensive
    description of the endpoint, including possible outputs and HTTP status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are using the `@Operation` annotation to define the
    description for our `delete` endpoint. The `@ApiResponse` annotation is used to
    add the possible response status, in this case, `204` , which represents that
    the product was removed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '@Parameter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our previous example, we used the `@Parameter` annotation. This annotation
    is specifically designed to be applied to method parameters, allowing for the
    definition of clear descriptions, examples, and additional information about each
    parameter. Such details are very useful for API consumers, as they provide clear
    examples and essential information, enhancing the usability of the API.
  prefs: []
  type: TYPE_NORMAL
- en: '@ApiResponse'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our previous example, we applied the `@ApiResponse` annotation. This annotation
    serves to specify the potential responses from our API endpoint, detailing the
    HTTP status and response type, and providing examples where applicable. In our
    previous case, there was no return body, as it is `204` ; let’s see an example
    for a `GET` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we have two instances of `@ApiResponse` , the first for successful
    responses with a status code of `200` . In this scenario, we use the `@Schema`
    annotation to reference the implementation class, specifically `ProductOutput.class`
    .
  prefs: []
  type: TYPE_NORMAL
- en: The second instance pertains to a `404` error, utilizing a schema outside our
    domain, namely `ProblemDetail.class` from Spring. In this case, we use another
    annotation from Swagger, the `@ExampleObject` annotation, to create a structured
    JSON representation of the expected error response, using Java’s text block feature
    to enhance readability.
  prefs: []
  type: TYPE_NORMAL
- en: '@Schema'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our previous example, we used the `@Schema` annotation to identify the content
    for the API response. This annotation is also used to describe the fields of the
    request and response models. Let’s look at an example using `ProductInput` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using `@Schema` to define the name of each field, indicate
    whether the field is required, and provide an example value. The example value
    is especially useful for new API users, as it offers clear information about the
    expected input and output.
  prefs: []
  type: TYPE_NORMAL
- en: 'By incorporating bean validation, we enhance our API with additional information
    about the fields. The generated code for `ProductInput` will look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By applying these annotations throughout our entire API, we achieve clear and
    well-defined documentation. Now, we can revisit the Swagger UI to review and explore
    the updated documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Many mock servers use the Swagger implementation to generate mocks; having a
    clear definition and examples for the input and output is essential to generate
    better mocks.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Swagger UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Swagger UI** is a web-based interface that provides interactive documentation
    for APIs. It allows developers to visualize and execute API endpoints, making
    it easier to understand and experiment with the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before accessing the Swagger UI, let’s add one more annotation from Swagger:
    the `OpenAPI` annotation. This contains some metadata from our API. We can do
    that in Spring by defining the `OpenAPI` bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we use the `OpenAPI` bean from Swagger to define metadata information.
    Specifically, we set the title, description, and version of the API. The version
    information is retrieved from the application properties, allowing us to synchronize
    it with the version specified in `pom.xml` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This annotation supports the following metadata items:'
  prefs: []
  type: TYPE_NORMAL
- en: '`openapi` : The version of the OpenAPI specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` : This provides metadata about the API:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title` : The title of the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version` : The version of the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description` : A brief description of the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`termsOfService` : A URL to the terms of service for the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contact` : Contact information for the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`license` : License information for the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servers` : This specifies the servers where the API can be accessed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url` : The URL of the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description` : A description of the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paths` : The available endpoints for the API; this is usually generated from
    the annotations shown previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`components` : Components are reusable schemas or other objects that can be
    referenced from multiple places in the API specification. This is also generated
    based on the annotations shown previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security` : This defines the security mechanisms for the API. It is also generated
    from the `@SecurityRequirement` annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags` : This provides a list of tags used by the specification with additional
    metadata. It is also generated from the `@Tag` annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`externalDocs` : This provides external documentation about the API:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description` : A short description of the external documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url` : The URL for the external documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the preceding annotations and configuration parameters can be used to enrich
    the API documentation. Now that our API is documented in the Java code, we can
    view the results by accessing the Swagger UI at `http://localhost:8080/swagger-ui/index.html`
    , as shown in *Figure 3.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Swagger UI](img/B21843_03_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding figure, our API has more detail. It has the description
    of each endpoint and all the metadata provided in the `OpenAPI` bean.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we have schemas that provide detailed information about our data
    models. These schemas include details about each field, indicating whether the
    field is required, along with example values, as we can see in *Figure 3.3* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Swagger schemas](img/B21843_03_3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Swagger schemas
  prefs: []
  type: TYPE_NORMAL
- en: With this information, API consumers can gain a good understanding of the API,
    simplifying the process of creating a client. In [*Chapter 4*](B21843_04.xhtml#_idTextAnchor096)
    , we will explore how to use the generated documentation to help in generating
    the HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating the documentation file is straightforward. In Swagger UI, there
    is a link that opens the OpenAPI Specification in JSON format, as shown in *Figure
    3.4* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Link to the documentation file](img/B21843_03_4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Link to the documentation file
  prefs: []
  type: TYPE_NORMAL
- en: This specification file can be used by anyone who wants to integrate with our
    API. Many tools, such as Postman, IntelliJ IDEA, and others, seamlessly integrate
    with the OpenAPI standard, offering numerous benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wide range of uses of the OpenAPI Specification is the reason why we should
    prefer to share a good OpenAPI Specification rather than ready-made Java clients
    in the form of libraries (JAR files). Even if we would like to limit ourselves
    to only Java-implemented clients, ready-made libraries can cause problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Incompatibility of used third-party libraries or their versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code style not fitting with the rest of the client application (e.g., reactive
    versus imperative programming)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing or incompatible annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Swagger UI also offers a convenient way to interact with the API and view
    the results. This feature proves especially useful, as demonstrated in *Figure
    3.5* , by allowing developers to easily test endpoints and observe responses directly
    within the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Try it out – Swagger UI](img/B21843_03_5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Try it out – Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see a **Try it out** button, which allows users
    to interact with the API directly from the documentation. This feature enables
    developers to send real requests and view the responses in real time, as illustrated
    in *Figure 3.6* . It’s a straightforward way to validate API behavior without
    needing to write external scripts or tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Execute the Swagger UI](img/B21843_03_6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Execute the Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: These features offered by the Swagger UI greatly enhance the developer experience
    by making it easier to test, understand, and integrate with the API. The interactive
    documentation allows developers to explore the API’s functionality, ensuring they
    can quickly grasp how it works and incorporate it effectively into their own applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the OpenAPI Specification and how to utilize
    Swagger annotations to generate documentation. In the upcoming chapter, we will
    explore using this documentation to develop a client for it and delve deeper into
    the specification-first approach.
  prefs: []
  type: TYPE_NORMAL
