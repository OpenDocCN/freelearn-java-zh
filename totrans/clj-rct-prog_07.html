<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;The UI as a Function"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. The UI as a Function</h1></div></div></div><p class="calibre7">So far we have taken a journey through managing complexity by efficiently handling and modeling asynchronous workflows in terms of streams of data. In particular, <a class="calibre1" title="Chapter 4. Introduction to core.async" href="part0033_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre8">Introduction to core.async</em></span> and <a class="calibre1" title="Chapter 5. Creating Your Own CES Framework with core.async" href="part0040_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre8">Creating Your Own CES Framework with core.async</em></span> explored what's involved in libraries that provide primitives and combinators for <span class="strong"><strong class="calibre2">Compositional Event Systems</strong></span>. We also built a simple ClojureScript application that made use of our framework.</p><p class="calibre7">One thing you might have noticed is that none of the examples so far have dealt with what happens to the data once we are ready to present it to our users. It's still an open question that we, as application developers, need to answer.</p><p class="calibre7">In this chapter, we will look at one way to handle Reactive User Interfaces in web applications <a id="id286" class="calibre1"/>using React (see <a class="calibre1" href="http://facebook.github.io/react/">http://facebook.github.io/react/</a>), a modern JavaScript framework developed by Facebook, as well as:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Learn how React renders user interfaces efficiently</li><li class="listitem">Be introduced to Om, a ClojureScript interface to React</li><li class="listitem">Learn how Om leverages persistent data structures for performance</li><li class="listitem">Develop two fully working ClojureScript applications with Om, including the use of <code class="email">core.async</code> for intercomponent communication</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;The UI as a Function">
<div class="book" title="The problem with complex web UIs"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec41" class="calibre1"/>The problem with complex web UIs</h1></div></div></div><p class="calibre7">With the rise of single-page web applications, it became a must to be able to manage the growth and <a id="id287" class="calibre1"/>complexity of a JavaScript codebase. The same applies to ClojureScript.</p><p class="calibre7">In an effort to manage this complexity, a plethora of JavaScript MVC frameworks have emerged such as AngularJS, Backbone.js, Ember.js, and KnockoutJS to name a few.</p><p class="calibre7">They are very <a id="id288" class="calibre1"/>different, but share a few common features:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Give single-page applications more structure by providing models, views, controllers, templates, and so on</li><li class="listitem">Provide client-side routing</li><li class="listitem">Two-way data binding</li></ul></div><p class="calibre7">In this <a id="id289" class="calibre1"/>chapter, we'll be focusing on the last goal.</p><p class="calibre7">Two-way data binding is absolutely crucial if we are to develop even a moderately complex single-page web application. Here's how it works.</p><p class="calibre7">Suppose we're <a id="id290" class="calibre1"/>developing a phone book application. More than likely, we will have a model—or entity, map, what have you—that represents a contact. The contact model might have attributes such as name, phone number, and e-mail address.</p><p class="calibre7">Of course, this application would not be all that useful if users couldn't update contact information, so we will need a form which displays the current details for a contact and lets you update the contact's information.</p><p class="calibre7">The contact model might have been loaded via an AJAX request and then might have used explicit DOM manipulation code to display the form. This would look something like the following pseudo-code:</p><div class="informalexample"><pre class="programlisting">function editContact(contactId) {
  contactService.get(contactId, function(data) {
    contactForm.setName(data.name);
    contactForm.setPhone(data.phone);
    contactForm.setEmail(data.email);
  })
}</pre></div><p class="calibre7">But what happens when the user updates someone's information? We need to store it somehow. On clicking on save, a function such as the following would do the trick, assuming you're using jQuery:</p><div class="informalexample"><pre class="programlisting">$("save-button").click(function(){
  contactService.update(contactForm.serialize(), function(){
    flashMessage.set("Contact Updated.")
  })</pre></div><p class="calibre7">This seemingly harmless code poses a big problem. The contact model for this particular person is now out of date. If we were still developing web applications the old way, where we reload the page at every update, this wouldn't be a problem. However, the whole point of single-page web applications is to be responsive, so it keeps a lot of state on the client, and it is important to keep our models synced with our views.</p><p class="calibre7">This is where two-way data binding comes in. An example from AngularJS would look like the following:</p><div class="informalexample"><pre class="programlisting">// JS
// in the Controller
$scope.contact = {
  name: 'Leonardo Borges',
  phone '+61 xxx xxx xxx',
  email: 'leonardoborges.rj@gmail.com'
}


&lt;!-- HTML --&gt;
&lt;!-- in the View --&gt;
&lt;form&gt;
  &lt;input type="text" name="contactName"  ng-model="contact.name"/&gt;
  &lt;input type="text" name="contactPhone" ng-model="contact.phone"/&gt;
  &lt;input type="text" name="contactEmail" ng-model="contact.email"/&gt;
&lt;/form&gt;</pre></div><p class="calibre7">Angular isn't the target of this chapter, so I won't dig into the details. All we need to know<a id="id291" class="calibre1"/> from this example is that <code class="email">$scope</code> is how we tell Angular to make our contact model available to our views. In the view, the custom attribute <code class="email">ng-model</code> tells Angular to look up that property in the scope. This establishes a two-way relationship in such a way that when your model data changes in the scope, Angular refreshes the UI. Similarly, if the user edits the form, Angular updates the model, keeping everything in sync.</p><p class="calibre7">There are, however, two main problems with this approach:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It can be slow. The way Angular and friends implement two-way data binding is, roughly speaking, by attaching event handlers and watchers to view both custom- attributes and model attributes. For complex enough user interfaces, you will start noticing that the UI becomes slower to render, diminishing the user experience.</li><li class="listitem">It relies heavily on mutation. As functional programmers, we strive to limit side effects to a minimum.</li></ul></div><p class="calibre7">The slowness that comes with this and similar approaches is two-fold: firstly, AngularJS and friends have to "watch" all properties of every model in the scope in order to track updates. Once the framework determines that data has changed in the model, it then looks up parts of the UI, which depend on that information—such as the fragments using <code class="email">ng-model</code> above—and then it re-renders them.</p><p class="calibre7">Secondly, the DOM is the slowest part of most single-page web applications. If we think about it for a moment, these frameworks are triggering dozens or perhaps hundreds of DOM event handlers in order to keep the data in sync, each of which ends up updating a node—or several—in the DOM.</p><p class="calibre7">Don't take <a id="id292" class="calibre1"/>my word for it though. I ran a simple benchmark to compare a pure calculation versus locating a DOM element and updating its value to the result of the said calculation. Here are the results—I've used JSPerf to run the <a id="id293" class="calibre1"/>benchmark, and these results are for Chrome 37.0.2062.94 on Mac OS X Mavericks (see <a class="calibre1" href="http://jsperf.com/purefunctions-vs-dom">http://jsperf.com/purefunctions-vs-dom</a>):</p><div class="informalexample"><pre class="programlisting">document.getElementsByName("sum")[0].value = 1 + 2  
// Operations per second: 2,090,202

1 + 2  
// Operations per second: 780,538,120</pre></div><p class="calibre7">Updating the DOM is orders of magnitude slower than performing a simple calculation. It seems logical that we would want to do this in the most efficient manner possible.</p><p class="calibre7">However, if we don't keep our data in sync, we're back at square one. There should be a way by which we can drastically reduce the amount of rendering being done, while retaining the convenience of two-way data binding. Can we have our cake and eat it too?</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Enter React.js"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec42" class="calibre1"/>Enter React.js</h1></div></div></div><p class="calibre7">As we'll see in this chapter, the answer to the question posed in the previous section is a resounding yes<a id="id294" class="calibre1"/> and, as you might have guessed, it involves React.js.</p><p class="calibre7">But what makes it special?</p><p class="calibre7">It's wise to start with what React is not. It is not an MVC framework and as such it is not a replacement for the likes of AngularJS, Backbone.js, and so on. React focuses solely on the V in MVC, and presents a refreshingly different way to think about user interfaces. We must take a slight detour in order to explore how it does that.</p></div>

<div class="book" title="Enter React.js">
<div class="book" title="Lessons from functional programming"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec48" class="calibre1"/>Lessons from functional programming</h2></div></div></div><p class="calibre7">As <a id="id295" class="calibre1"/>functional programmers, we don't need to be convinced <a id="id296" class="calibre1"/>of the benefits of immutability. We bought into the premise long ago. However, should we not be able to use immutability efficiently, it would not have become commonplace in functional programming languages.</p><p class="calibre7">We owe it to the huge amount of research that went into <span class="strong"><strong class="calibre2">Purely Functional Data Structures</strong></span>—first<a id="id297" class="calibre1"/> by Okasaki in his book of the same title (see <a class="calibre1" href="http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&amp;qid=1409550695&amp;sr=8-1&amp;keywords=purely+functional+data+structures">http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&amp;qid=1409550695&amp;sr=8-1&amp;keywords=purely+functional+data+structures</a>) and then improved by others.</p><p class="calibre7">Without it, our<a id="id298" class="calibre1"/> programs would be ballooning, both in space and runtime complexity.</p><p class="calibre7">The<a id="id299" class="calibre1"/> general idea is that given a data structure, the only <a id="id300" class="calibre1"/>way to update it is by creating a copy of it with the desired delta applied:</p><div class="informalexample"><pre class="programlisting">(conj [1 2 3] 4) ;; [1 2 3 4]</pre></div><div class="mediaobject"><img src="../images/00022.jpeg" alt="Lessons from functional programming" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In the preceding image, we have a simplistic view of how <code class="email">conj</code> operates. On the left, you have the underlying data structure representing the vector we wish to update. On the right, we have the newly created vector, which, as we can see, shares some structure with the previous vector, as well as containing our new item.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip24" class="calibre1"/>Tip</h3><p class="calibre7">In reality, the underlying data structure is a tree and the representation was simplified for the purposes of this book. I highly recommend referring to Okasaki's book should the reader want more details on how purely functional data structures work.</p></div><p class="calibre7">Additionally, these functions are considered pure. That is, it relates every input to a single output and does nothing else. This is, in fact, remarkably similar to how React handles user interfaces.</p><p class="calibre7">If we think of a UI as a visual representation of a data structure, which reflects the current state of our application, we can, without too much effort, think of UI updates as a simple function whose input is the application state and the output is a DOM representation.</p><p class="calibre7">You'll have noticed I didn't say the output is rendering to the DOM—that would make the function impure as rendering is clearly a side effect. It would also make it just as slow as the alternatives.</p><p class="calibre7">This DOM representation is essentially a tree of DOM nodes that model how your UI should look, and nothing else.</p><p class="calibre7">React <a id="id301" class="calibre1"/>calls this representation a <span class="strong"><strong class="calibre2">Virtual DOM</strong></span>
<span class="strong"><em class="calibre8">,</em></span> and<a id="id302" class="calibre1"/> roughly speaking, instead of watching<a id="id303" class="calibre1"/> individual bits and pieces of application state that trigger a DOM re-render upon change, React turns your UI into a function to which you give the whole application state.</p><p class="calibre7">When you give this function the new updated state, React renders that state to the Virtual DOM. Remember the Virtual DOM is simply a data structure, so the rendering is extremely fast. Once it's done, React does one of two things:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It commits the Virtual DOM to the actual DOM if this is the first render.</li><li class="listitem">Otherwise, it compares the new Virtual DOM with the current Virtual DOM, cached from the previous render of the application. It then uses an efficient diff algorithm to compute the minimum set of changes required to update the real DOM. Finally, it commits this delta to the DOM.</li></ul></div><p class="calibre7">Without digging into the nuts and bolts of React, this is essentially how it is implemented and the reason it is faster than the alternatives. Conceptually, React hits the "refresh" button whenever your application state changes.</p><p class="calibre7">Another great benefit is that by thinking of your UI as a function from application state to a Virtual DOM, we recover some of the reasoning we're able to do when working with immutable data structures in functional languages.</p><p class="calibre7">In the upcoming sections, we will understand why this is a big win for us Clojure developers.</p></div></div>
<div class="book" title="ClojureScript and Om"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec43" class="calibre1"/>ClojureScript and Om</h1></div></div></div><p class="calibre7">Why have I <a id="id304" class="calibre1"/>spent six pages talking about JavaScript and React in a <a id="id305" class="calibre1"/>Clojure book? I promise I'm not trying to waste your precious time; we simply needed some context to understand what's to come.</p><p class="calibre7">Om is a ClojureScript interface to React.js developed by the prolific and amazing individual David Nolen, from Cognitect. Yes, he has also developed <code class="email">core.logic</code>, <code class="email">core.match</code>, and the ClojureScript compiler. That's how prolific. But I digress.</p><p class="calibre7">When Facebook released React, David immediately saw the potential and, more importantly, how to take advantage of the assumptions we are able to make when programming<a id="id306" class="calibre1"/> in Clojure, the most important of which is that data structures <a id="id307" class="calibre1"/>don't change.</p><p class="calibre7">React provides several component life-cycle functions that allow developers to control various properties and behaviors. One in particular, <code class="email">shouldComponentUpdate</code>, is used to decide whether a component needs to be re-rendered.</p><p class="calibre7">React has a big challenge here. JavaScript is inherently mutable, so it is extremely hard, when comparing Virtual DOM Trees, to identify which nodes have changed in an efficient way. React employs a few heuristics in order to avoid <span class="strong"><em class="calibre8">O(n</em></span>
<span class="strong"><em class="calibre8">3</em></span>
<span class="strong"><em class="calibre8">)</em></span> worst-case performance and is able to do it in <span class="strong"><em class="calibre8">O(n)</em></span> most of the time. Since heuristics aren't perfect, we can choose to provide our own implementation of <code class="email">shouldComponentUpdate</code> and take advantage of the knowledge we possess when rendering a component.</p><p class="calibre7">ClojureScript, on the other hand, uses immutable data structures. As such, Om provides the simplest and most efficient implementation possible for <code class="email">shouldComponentUpdate</code>: a simple reference equality check.</p><p class="calibre7">Because we're always dealing with immutable data structures, in order to know whether two trees are the same, all we need to do is compare whether their roots are the same. If they are, we're done. Otherwise, descend and repeat the process. This is guaranteed to yield <span class="strong"><em class="calibre8">O(log n)</em></span> runtime complexity and allows Om to always render the UI from the root efficiently.</p><p class="calibre7">Of course, performance isn't the only thing that's good about Om—we will now explore what makes an Om application.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Building a simple Contacts application with Om"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec44" class="calibre1"/>Building a simple Contacts application with Om</h1></div></div></div><p class="calibre7">This chapter has been very text heavy so far. It's time we get our hands dirty and build a simple Om application. Since we talked about contacts before, that's what we will start with.</p><p class="calibre7">The<a id="id308" class="calibre1"/> main driver behind React and Om is the ability to<a id="id309" class="calibre1"/> build highly reusable, self-contained components and, as such, even in a simple <span class="strong"><em class="calibre8">Contacts</em></span> application, we will have multiple components working in concert to achieve a common goal.</p><p class="calibre7">This is what our users should be able to do in the application:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Display a list of contacts currently in storage</li><li class="listitem">Display the details of a given contact</li><li class="listitem">Edit the <a id="id310" class="calibre1"/>details of a specific contact</li></ul></div><p class="calibre7">And <a id="id311" class="calibre1"/>once we're done, it will look like the following:</p><div class="mediaobject"><img src="../images/00023.jpeg" alt="Building a simple Contacts application with Om" class="calibre10"/></div><p class="calibre11"> </p></div>

<div class="book" title="Building a simple Contacts application with Om">
<div class="book" title="The Contacts application state"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec49" class="calibre1"/>The Contacts application state</h2></div></div></div><p class="calibre7">As mentioned <a id="id312" class="calibre1"/>previously, Om/React will eventually render the DOM based on our application state. We'll be using data that's in memory to keep the example simple. Here's what our application state will look like:</p><div class="informalexample"><pre class="programlisting">(def app-state
  (atom {:contacts {1 {:id    1
                       :name  "James Hetfield"
                       :email "james@metallica.com"
                       :phone "+1 XXX XXX XXX"}
                    2 {:id    2
                       :name  "Adam Darski"
                       :email "the.nergal@behemoth.pl"
                       :phone "+48 XXX XXX XXX"}}
         :selected-contact-id []
         :editing [false]}))</pre></div><p class="calibre7">The reason we keep the state in an atom is that Om uses that to re-render the application if we <code class="email">swap!</code> or <code class="email">reset!</code> it, for instance, if we load some data from the server after the application has been rendered for the first time.</p><p class="calibre7">The data in the state itself should be mostly self-explanatory. We have a map containing all contacts, a key representing whether there is currently a contact selected, and a flag that indicates whether we are currently editing the selected contact. What might look odd is that both<code class="email">:selected-contact-id</code> and <code class="email">:editing keys</code> point to a vector. Just bear with me for a moment; the reason for this will become clear shortly.</p><p class="calibre7">Now that we have a draft of our application state, it's time we think about how the state will flow through the different components in our app. A picture is worth a thousand words, so the following diagram shows the high-level architecture through which our data will flow:</p><div class="mediaobject"><img src="../images/00024.jpeg" alt="The Contacts application state" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In the<a id="id313" class="calibre1"/> preceding image, each function corresponds to an Om component. At the very least, they take some piece of data as their initial state. What is interesting in this image is that as we descend into our more specialized components, they request less state than the main component, <code class="email">contacts-app</code>. For instance, the <code class="email">contacts-view</code> component needs all contacts as well as the ID of the selected contact. The <code class="email">details-panel-view</code> component, on the other hand, only needs the currently selected contact, and whether it's being edited or not. This is a common pattern in Om and we usually want to avoid over-sharing the application state.</p><p class="calibre7">With a rough understanding of our high-level architecture, we are ready to start building our Contacts application.</p></div></div>

<div class="book" title="Building a simple Contacts application with Om">
<div class="book" title="Setting up the Contacts project"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec50" class="calibre1"/>Setting up the Contacts project</h2></div></div></div><p class="calibre7">Once<a id="id314" class="calibre1"/> again, we will use a leiningen template to help us get <a id="id315" class="calibre1"/>started. This time we'll be using <code class="email">om-start</code> (see <a class="calibre1" href="https://github.com/magomimmo/om-start-template">https://github.com/magomimmo/om-start-template</a>), also by Mimmo Cosenza (see <a class="calibre1" href="https://github.com/magomimmo">https://github.com/magomimmo</a>). Type this in the terminal to create a base project<a id="id316" class="calibre1"/> using this template:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein new om-start contacts</strong></span>
<span class="strong"><strong class="calibre2">cd contacts</strong></span>
</pre></div><p class="calibre7">Next, let's<a id="id317" class="calibre1"/> open the <code class="email">project.clj</code> file and make sure we have the same versions for the various different dependencies the template pulls in. This is just so that we don't have any surprises with incompatible versions:</p><div class="informalexample"><pre class="programlisting">...
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.clojure/clojurescript "0.0-2277"]
                 [org.clojure/core.async "0.1.338.0-5c5012-alpha"]
                 [om "0.7.1"]
                 [com.facebook/react "0.11.1"]]
...</pre></div><p class="calibre7">To validate the new project skeleton, still in the terminal, type the following to auto-compile your ClojureScript source files:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein cljsbuild auto</strong></span>
<span class="strong"><strong class="calibre2">Compiling ClojureScript.</strong></span>
<span class="strong"><strong class="calibre2">Compiling "dev-resources/public/js/contacts.js" from ("src/cljs" "dev-resources/tools/repl")...</strong></span>
<span class="strong"><strong class="calibre2">Successfully compiled "dev-resources/public/js/contacts.js" in 9.563 seconds.</strong></span>
</pre></div><p class="calibre7">Now, we should see the template default "Hello World" page if we open the <code class="email">dev-resources/public/index.html</code> file in the browser.</p></div></div>

<div class="book" title="Building a simple Contacts application with Om">
<div class="book" title="Application components"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec51" class="calibre1"/>Application components</h2></div></div></div><p class="calibre7">The next thing we'll do is open the <code class="email">src/cljs/contacts/core.cljs</code> file, which is where our<a id="id318" class="calibre1"/> application code will go, and make sure it looks like the following so that we have a clean slate with the appropriate namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns contacts.core
  (:require [om.core :as om :include-macros true]
            [om.dom :as dom :include-macros true]))

(enable-console-print!)

(def app-state
  (atom {:contacts {1 {:id    1
                       :name  "James Hetfield"
                       :email "james@metallica.com"
                       :phone "+1 XXX XXX XXX"}
                    2 {:id    2
                       :name  "Adam Darski"
                       :email "the.nergal@behemoth.pl"
                       :phone "+48 XXX XXX XXX"}}
         :selected-contact-id []
         :editing [false]}))

(om/root
  contacts-app
  app-state
  {:target (. js/document (getElementById "app"))})</pre></div><p class="calibre7">Every Om application starts with a root component created by the <code class="email">om/root</code> function. It takes<a id="id319" class="calibre1"/> as arguments a function representing a component—<code class="email">contacts-app</code>—the initial state of the application—<code class="email">app-state</code>—and a map of options of which the only one we care about is <code class="email">:target</code>, which tells Om where to mount our root component on the DOM.</p><p class="calibre7">In this instance, it will mount on a DOM element whose ID is <code class="email">app</code>. This element was given to us by the <code class="email">om-start</code> template and is located in the <code class="email">dev-resources/public/index.html</code> file.</p><p class="calibre7">Of course, this code won't compile yet, as we don't have the <code class="email">contacts-app</code> template. Let's solve that and create it above the preceding declaration—we're implementing the components bottom-up:</p><div class="informalexample"><pre class="programlisting">(defn contacts-app [data owner]
  (reify
    om/IRender
    (render [this]
      (let [[selected-id :as selected-id-cursor] 
            (:selected-contact-id data)]
        (dom/div nil
                 (om/build contacts-view
                           {:contacts            (:contacts data)
                            :selected-id-cursor selected-id-cursor})
                 (om/build details-panel-view
                           {:contact        (get-in data [:contacts selected-id])
                            :editing-cursor (:editing data)}))))))</pre></div><p class="calibre7">This snippet introduces a number of new features and terminology, so it deserves a few paragraphs.</p><p class="calibre7">When describing <code class="email">om/root</code>, we saw that its first argument must be an Om component. The <code class="email">contact-app</code> function creates one by reifying the <code class="email">om/IRender</code> protocol. This protocol contains a single function—<code class="email">render</code>—which gets called when the application state <a id="id320" class="calibre1"/>changes.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip25" class="calibre1"/>Tip</h3><p class="calibre7">Clojure uses reify to implement protocols or Java interfaces on the fly, without the need to create a new type. You can read more about this on the data types page of the <a id="id321" class="calibre1"/>Clojure documentation at <a class="calibre1" href="http://clojure.org/datatypes">http://clojure.org/datatypes</a>.</p></div><p class="calibre7">The <code class="email">render</code> function must return an <code class="email">Om/React</code> component or something React knows how to render—such as a DOM representation of the component. The arguments to <code class="email">contacts-app</code> are straightforward: <code class="email">data</code> is the component state and <code class="email">owner</code> is the backing React component.</p><p class="calibre7">Moving down the source file, in the implementation of <code class="email">render</code>, we have the following:</p><div class="informalexample"><pre class="programlisting">(let [[selected-id :as selected-id-cursor] 
      (:selected-contact-id data)]
  ...)</pre></div><p class="calibre7">If we recall from our application state, the value of <code class="email">:selected-contact-id</code> is, at this stage, an empty vector. Here, then, we are destructuring this vector and giving it a name. What you might be wondering now is why we bound the vector to a variable named <code class="email">selected-id-cursor</code>. This is to reflect the fact that at this point in the life cycle of a component, <code class="email">selected-id-cursor</code> isn't a vector any longer but rather it is a cursor.</p></div></div>

<div class="book" title="Building a simple Contacts application with Om">
<div class="book" title="Om cursors"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec52" class="calibre1"/>Om cursors</h2></div></div></div><p class="calibre7">Once <code class="email">om/root</code> creates our root component, sub-components don't have direct access to the state atom <a id="id322" class="calibre1"/>any longer. Instead, components receive a cursor created from the application state.</p><p class="calibre7">Cursors are data structures that represent a place in the original state atom. You can use cursors<a id="id323" class="calibre1"/> to read, delete, update, or create a value with no knowledge of the original data structure. Let's take the <code class="email">selected-id-cursor</code> cursor as an example:</p><div class="mediaobject"><img src="../images/00025.jpeg" alt="Om cursors" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">At the<a id="id324" class="calibre1"/> top, we have our original application state, which Om turns into a cursor. When we request the <code class="email">:selected-contact-id</code> key from it, Om gives us another cursor representing that particular place in the data structure. It just so happens that its value is the empty vector.</p><p class="calibre7">What is interesting about this cursor is that if we update its value using one of Om's state transition functions such as <code class="email">om/transact!</code> and <code class="email">om/update!</code>—we will explain these shortly—it knows how to propagate the change up the tree and all the way back to the application state atom.</p><p class="calibre7">This is important because as we have briefly stated before, it is common practice to have our more specialized components depend on specific parts of the application state required for its correct operation.</p><p class="calibre7">By using cursors, we can easily propagate changes without knowing what the application state looks like, thus avoiding the need to access the global state.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip26" class="calibre1"/>Tip</h3><p class="calibre7">You can think of cursors as zippers. Conceptually, they serve a similar purpose but have different APIs.</p></div></div></div>

<div class="book" title="Building a simple Contacts application with Om">
<div class="book" title="Filling in the blanks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec53" class="calibre1"/>Filling in the blanks</h2></div></div></div><p class="calibre7">Moving <a id="id325" class="calibre1"/>down the <code class="email">contacts-app</code> component, we now have the following:</p><div class="informalexample"><pre class="programlisting">(dom/div nil
                 (om/build contacts-view
                           {:contacts            (:contacts data)
                            :selected-id-cursor selected-id-cursor})
                 (om/build details-panel-view
                           {:contact        (get-in data [:contacts selected-id])
                            :editing-cursor (:editing data)}))</pre></div><p class="calibre7">The <code class="email">dom</code> namespace contains thin wrappers around React's DOM classes. It's essentially the data structure representing what the application will look like. Next, we see two examples of how we can create Om components inside another Om component. We use the <code class="email">om/build</code> function for that and create the <code class="email">contacts-view</code> and <code class="email">details-panel-view</code> components. The <code class="email">om/build</code> function takes as arguments the component function, the component state, and, optionally, a map of options which aren't important for this example.</p><p class="calibre7">At this point, we have already started to limit the state we will pass into the sub-components by creating sub-cursors.</p><p class="calibre7">According<a id="id326" class="calibre1"/> to the source code, the next component we should look at is <code class="email">contacts-view</code>. Here it is in full:</p><div class="informalexample"><pre class="programlisting">(defn contacts-view [{:keys [contacts selected-id-cursor]} owner]
  (reify
    om/IRender
    (render [_]
      (dom/div #js {:style #js {:float "left"
                                            :width "50%"}}
               (apply dom/ul nil
                      (om/build-all contact-summary-view (vals contacts)
                                    {:shared {:selected-id-cursor selected-id-cursor}}))))))</pre></div><p class="calibre7">Hopefully, the source of this component looks a little more familiar now. As before, we reify <code class="email">om/IRender</code> to provide a DOM representation of our component. It comprises a single <code class="email">div</code> element. This time we give as the second argument to <code class="email">dom/div</code> a hash-map representing HTML attributes. We are using some inline styles, but ideally we would use an external style sheet.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip27" class="calibre1"/>Tip</h3><p class="calibre7">If you are not familiar with the <code class="email">#js {…}</code> syntax, it's simply a reader macro that expands to (<code class="email">clj-&gt;js {…}</code>) in order to convert a ClojureScript hash-map into a JavaScript object. The only thing to watch for is that it is not recursive, as evidenced by the nested use of <code class="email">#js</code>.</p></div><p class="calibre7">The third argument to <code class="email">dom/div</code> is slightly more complex than what we have seen so far:</p><div class="informalexample"><pre class="programlisting">(apply dom/ul nil
                      (om/build-all contact-summary-view (vals contacts)
                                    {:shared {:selected-id-cursor selected-id-cursor}}))</pre></div><p class="calibre7">Each contact will be represented by a <code class="email">li</code> (list item) HTML node, so we start by wrapping the result into a <code class="email">dom/ul</code> element. Then, we use <code class="email">om/build-all</code> to build a list of contact-<code class="email">summary-view</code> components. Om will, in turn, call <code class="email">om/build</code> for each contact in <code class="email">vals contacts</code>.</p><p class="calibre7">Lastly, we use the third argument to <code class="email">om/build-all</code>—the options map—to demonstrate how we can share state between components without the use of global state. We'll see how that's <a id="id327" class="calibre1"/>used in the next component, <code class="email">contact-summary-view</code>:</p><div class="informalexample"><pre class="programlisting">  (defn contact-summary-view [{:keys [name phone] :as contact} owner]
  (reify
    om/IRender
    (render [_]
      (dom/li #js {:onClick #(select-contact! @contact
                                              (om/get-shared owner :selected-id-cursor))}
              (dom/span nil name)
              (dom/span nil phone)))))</pre></div><p class="calibre7">If we think of our application as a tree of components, we have now reached one of its leaves. This component simply returns a <code class="email">dom/li</code> node with the contact's name and phone in it, wrapped in <code class="email">dom/span</code> nodes.</p><p class="calibre7">It also installs a handler to the <code class="email">dom/li onClick</code> event, which we can use to update the state cursor.</p><p class="calibre7">We use <code class="email">om/get-shared</code> to access the shared state we installed earlier and pass the resulting cursor into <code class="email">select-contact!</code> We also pass the current contact, but, if you look closely, we have to <code class="email">deref</code> it first:</p><div class="informalexample"><pre class="programlisting">@contact</pre></div><p class="calibre7">The reason for this is that Om doesn't allow us to manipulate cursors outside of the render phase. By derefing the cursor, we have its most recent underlying value. Now <code class="email">select-contact</code>! has all it needs to perform the update:</p><div class="informalexample"><pre class="programlisting">(defn select-contact! [contact selected-id-cursor]
  (om/update! selected-id-cursor 0 (:id contact)))</pre></div><p class="calibre7">We simply use <code class="email">om/update!</code> to set the value of the <code class="email">selected-id-cursor</code> cursor at index <code class="email">0</code> to the <code class="email">id</code> of the contact. As mentioned previously, the cursor takes care of propagating the change.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip28" class="calibre1"/>Tip</h3><p class="calibre7">You can think of <code class="email">om/update!</code> as the cursors version of <code class="email">clojure.core/reset!</code> used in atoms. Conversely, the same applies to <code class="email">om/transact!</code> and <code class="email">clojure.core/swap!</code>, respectively.</p></div><p class="calibre7">We<a id="id328" class="calibre1"/> are moving at a good pace. It's time we look at the next component, <code class="email">details-panel-view</code>:</p><div class="informalexample"><pre class="programlisting">(defn details-panel-view [data owner]
  (reify
    om/IRender
    (render [_]
      (dom/div #js {:style #js {:float "right"
                                :width "50%"}}
               (om/build contact-details-view data)
               (om/build contact-details-form-view data)))))</pre></div><p class="calibre7">This<a id="id329" class="calibre1"/> component <a id="id330" class="calibre1"/>should now look fairly familiar. All it does is build two other components, <code class="email">contact-details-view</code> and <code class="email">contact-details-form-view</code>:</p><div class="informalexample"><pre class="programlisting">(defn contact-details-view [{{:keys [name phone email id] :as contact} :contact
                             editing :editing-cursor}
                            owner]
  (reify
    om/IRender
    (render [_]
      (dom/div #js {:style #js {:display (if (get editing 0) "none" "")}}
             (dom/h2 nil "Contact details")
             (if contact
               (dom/div nil
                        (dom/h3 #js {:style #js {:margin-bottom "0px"}} (:name contact))
                        (dom/span nil (:phone contact)) (dom/br nil)
                        (dom/span nil (:email contact)) (dom/br nil)
                        (dom/button #js {:onClick #(om/update! editing 0 true)}
                                    "Edit"))
               (dom/span nil "No contact selected"))))))</pre></div><p class="calibre7">The <code class="email">contact-details-view</code> component receives two pieces of state: the contact and the<a id="id331" class="calibre1"/> editing flag. If we have a contact, we simply render the component. However, we use the editing flag to hide it, if we are editing it. This is so that we can show the edit form in the next component. We also install an <code class="email">onClick</code> handler to the Edit button so that we can update the editing cursor.</p><p class="calibre7">The <code class="email">contact-details-form-view</code> component receives the same arguments but renders the <a id="id332" class="calibre1"/>following form instead:</p><div class="informalexample"><pre class="programlisting">(defn contact-details-form-view [{{:keys [name phone email id] :as contact} :contact
                                  editing :editing-cursor}
                                 owner]
  (reify
    om/IRender
    (render [_]
      (dom/div #js {:style #js {:display (if (get editing 0) "" "none")}}
               (dom/h2 nil "Contact details")
               (if contact
                 (dom/div nil
                          (dom/input #js {:type "text"
                                                   :value name
                                                   :onChange #(update-contact! % contact :name)})
                          (dom/input #js {:type "text"
                                                   :value phone
                                                   :onChange #(update-contact! % contact :phone)})
                          (dom/input #js {:type "text"
                                                   :value email
                                                   :onChange #(update-contact! % contact :email)})
                          (dom/button #js {:onClick #(om/update! editing 0 false)}
                                                    "Save"))
               (dom/div nil "No contact selected"))))))</pre></div><p class="calibre7">This is the component responsible for actually updating the contact information based on the form. It does so by calling <code class="email">update-contact!</code> with the JavaScript event, the contact cursor, and <a id="id333" class="calibre1"/>the key representing the attribute to be updated:</p><div class="informalexample"><pre class="programlisting">(defn update-contact! [e contact key]
  (om/update! contact key (.. e -target -value)))</pre></div><p class="calibre7">As before, we simply use <code class="email">om/update!</code> instead of <code class="email">om/transact!</code> as we are simply replacing the value of the cursor attribute with the current value of the form field which triggered the event <code class="email">e</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre7">If you're not familiar with the <code class="email">..</code> syntax, it's simply a convenience macro for Java and JavaScript interoperability. The previous example expands to:</p><div class="informalexample"><pre class="programlisting">(. (. e -target) -value)</pre></div><p class="calibre7">This and<a id="id334" class="calibre1"/> other interoperability operators are described in the Java Interop page of the Clojure website (see <a class="calibre1" href="http://clojure.org/java_interop">http://clojure.org/java_interop</a>).</p></div><p class="calibre7">This is it. Make sure your code is still compiling—or if you haven't yet, start the auto-compilation by typing the following in the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein cljsbuild auto</strong></span>
</pre></div><p class="calibre7">Then, open up <code class="email">dev-resources/public/index.html</code> again in your browser and take our Contacts app for a spin! Note in particular how the application state is always in sync while you edit the contact attributes.</p><p class="calibre7">If there are any issues at this stage, make sure the <code class="email">src/cljs/contacts/core.cljs</code> file matches the companion code for this book.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Intercomponent communication"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec45" class="calibre1"/>Intercomponent communication</h1></div></div></div><p class="calibre7">In our <a id="id335" class="calibre1"/>previous example, the components we built communicated with each other exclusively through the application state, both for reading and transacting data. While this approach works, it is not always the best except for very simple use cases. In this section, we will learn an alternate way of performing this communication <a id="id336" class="calibre1"/>using <code class="email">core.async</code> channels.</p><p class="calibre7">The application we will build is a super simple virtual agile board. If you've heard of it, it's similar to <a id="id337" class="calibre1"/>Trello (see <a class="calibre1" href="https://trello.com/">https://trello.com/</a>). If you haven't, fear not, it's essentially a task management web application in which you have cards that represent tasks and you move them between columns such as <span class="strong"><strong class="calibre2">Backlog</strong></span>, <span class="strong"><strong class="calibre2">In Progress</strong></span>, and <span class="strong"><strong class="calibre2">Done</strong></span>.</p><p class="calibre7">By the <a id="id338" class="calibre1"/>end of this section, the application will look like the following:</p><div class="mediaobject"><img src="../images/00026.jpeg" alt="Intercomponent communication" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">We'll limit ourselves to a single feature: moving cards between columns by dragging and dropping them. Let's get started.</p></div>

<div class="book" title="Intercomponent communication">
<div class="book" title="Creating an agile board with Om"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec54" class="calibre1"/>Creating an agile board with Om</h2></div></div></div><p class="calibre7">We're <a id="id339" class="calibre1"/>already familiar with the <code class="email">om-start</code> (see <a class="calibre1" href="https://github.com/magomimmo/om-start-template">https://github.com/magomimmo/om-start-template</a>) leiningen template, and <a id="id340" class="calibre1"/>since there is no reason to change it, that's what<a id="id341" class="calibre1"/> we will use to create our project—which I called <code class="email">om-pm</code> for <a id="id342" class="calibre1"/>
<span class="strong"><strong class="calibre2">Om Project Management</strong></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein new om-start om-pm</strong></span>
<span class="strong"><strong class="calibre2">cd om-pm</strong></span>
</pre></div><p class="calibre7">As before, we should ensure we have the right dependencies in our <code class="email">project.clj</code> file:</p><div class="informalexample"><pre class="programlisting">  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.clojure/clojurescript "0.0-2511"]
                 [org.om/om "0.8.1"]
                 [org.clojure/core.async "0.1.346.0-17112a-alpha"]
                 [com.facebook/react "0.12.2"]]</pre></div><p class="calibre7">Now validate that we are in good shape by making sure the project compiles properly:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein cljsbuild auto</strong></span>
<span class="strong"><strong class="calibre2">Compiling ClojureScript.</strong></span>
<span class="strong"><strong class="calibre2">Compiling "dev-resources/public/js/om_pm.js" from ("src/cljs" "dev-resources/tools/repl")...</strong></span>
<span class="strong"><strong class="calibre2">Successfully compiled "dev-resources/public/js/om_pm.js" in 13.101 seconds.</strong></span>
</pre></div><p class="calibre7">Next, open the <code class="email">src/cljs/om_pm/core.cljs</code> file and add the namespaces that we will be<a id="id343" class="calibre1"/> using to build the application:</p><div class="informalexample"><pre class="programlisting">(ns om-pm.core
  (:require [om.core :as om :include-macros true]
            [om.dom :as dom :include-macros true]
            [cljs.core.async :refer [put! chan &lt;!]]
            [om-pm.util :refer [set-transfer-data! get-transfer-data! move-card!]])
  (:require-macros [cljs.core.async.macros :refer [go go-loop]]))</pre></div><p class="calibre7">The <a id="id344" class="calibre1"/>main difference this time is that we are requiring <code class="email">core.async</code> functions and macros. We don't yet have an <code class="email">om-pm.util</code> namespace, but <a id="id345" class="calibre1"/>we'll get to that at the end.</p></div></div>

<div class="book" title="Intercomponent communication">
<div class="book" title="The board state"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec55" class="calibre1"/>The board state</h2></div></div></div><p class="calibre7">It's time <a id="id346" class="calibre1"/>we think what our application state will look like. Our main entity in this application is the <span class="strong"><strong class="calibre2">card</strong></span>, which represents a task and has the attributes <code class="email">id</code>, <code class="email">title</code>, and <code class="email">description</code>. We will start by defining a couple of cards:</p><div class="informalexample"><pre class="programlisting">(def cards [{:id 1
             :title "Groceries shopping"
             :description "Almond milk, mixed nuts, eggs..."}
            {:id 2
             :title "Expenses"
             :description "Submit last client's expense report"}])</pre></div><p class="calibre7">This isn't our application state yet, but rather a part of it. Another important piece of state is a way to track which cards are on which columns. To keep things simple, we will work with only three columns: <span class="strong"><strong class="calibre2">Backlog</strong></span>, <span class="strong"><strong class="calibre2">In Progress</strong></span>, and <span class="strong"><strong class="calibre2">Done</strong></span>. By default, all cards start out in the backlog:</p><div class="informalexample"><pre class="programlisting">(def app-state
  (atom {:cards cards
         :columns [{:title "Backlog"
                    :cards (mapv :id cards)}
                   {:title "In Progress"
                    :cards []}
                   {:title "Done"
                    :cards []}]}))</pre></div><p class="calibre7">This is all the state we need. Columns have a <code class="email">:title</code> and a <code class="email">:cards</code> attribute, which contains the IDs of all cards in that column.</p><p class="calibre7">Additionally, we <a id="id347" class="calibre1"/>will have a helper function to make finding cards more convenient:</p><div class="informalexample"><pre class="programlisting">(defn card-by-id [id]
  (first (filterv #(= id (:id %)) cards)))</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip29" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre2">Beware of lazy sequences</strong></span>
</p><p class="calibre7">You might have noticed the use of <code class="email">mapv</code> instead of <code class="email">map</code> for retrieving the cards IDs. This is a subtle but important difference: <code class="email">map</code> is lazy by default, but Om can only create cursors for maps and vectors. Using <code class="email">mapv</code> gives us a vector back, avoiding laziness altogether.</p><p class="calibre7">Had we not done that, Om would consider the list of IDs as a normal value and we would not be able to transact it.</p></div></div></div>

<div class="book" title="Intercomponent communication">
<div class="book" title="Components overview"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec56" class="calibre1"/>Components overview</h2></div></div></div><p class="calibre7">There are many ways to slice up an Om application into components, and in this section, we will present <a id="id348" class="calibre1"/>one way as we walk through each component's implementation.</p><p class="calibre7">The approach we will follow is similar to our previous application in that from this point on, we present the components bottom-up.</p><p class="calibre7">Before we see our first component, however, we should start with Om's own <code class="email">root</code> component:</p><div class="informalexample"><pre class="programlisting">(om/root project-view app-state
         {:target (. js/document (getElementById "app"))})</pre></div><p class="calibre7">This gives us a hint as to what our next component will be, <code class="email">project-view</code>:</p><div class="informalexample"><pre class="programlisting">(defn project-view [app owner]
  (reify
    om/IInitState
    (init-state [_]
      {:transfer-chan (chan)})

    om/IWillMount
    (will-mount [_]
      (let [transfer-chan (om/get-state owner :transfer-chan)]
        (go-loop []
          (let [transfer-data (&lt;! transfer-chan)]
            (om/transact! app :columns 
                          #(move-card! % transfer-data))
            (recur)))))

    om/IRenderState
    (render-state [this state]
      (dom/div nil
               (apply dom/ul nil
                      (om/build-all column-view (:columns app)
                                    {:shared     {:cards (:cards app)}
                                     :init-state state}))))))</pre></div></div></div>

<div class="book" title="Intercomponent communication">
<div class="book" title="Lifecycle and component local state"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec57" class="calibre1"/>Lifecycle and component local state</h2></div></div></div><p class="calibre7">The previous component is fairly different from the ones we have seen so far. More specifically, it implements two new protocols: <code class="email">om/IInitState</code> and <code class="email">om/IWillMount</code>. Additionally, we dropped <code class="email">om/IRender</code> altogether in favor of <code class="email">om/IRenderState</code>. Before we explain <a id="id349" class="calibre1"/>what these new protocols are good for, we need to discuss<a id="id350" class="calibre1"/> our high-level design.</p><p class="calibre7">The <code class="email">project-view</code> component is our application's main entry point and receives the whole application state as its first argument. As in our earlier <span class="strong"><em class="calibre8">Contacts</em></span> application, it then instantiates the remaining components with the data they need.</p><p class="calibre7">Different from the <span class="strong"><em class="calibre8">Contacts</em></span> example, however, it creates a <code class="email">core.async</code> channel—<code class="email">transfer-chan</code>—which works as a message bus. The idea is that when we drag a card from one column and drop it on another, one of our components will put a transfer event in this channel and let someone else—most likely a <code class="email">go</code> block—perform the actual move operation.</p><p class="calibre7">This is done in the following snippet taken from the component shown earlier:</p><div class="informalexample"><pre class="programlisting">    om/IInitState
    (init-state [_]
      {:transfer-chan (chan)})</pre></div><p class="calibre7">This creates what Om calls the component local state. It uses a different lifecycle protocol, <code class="email">om/IInitState</code>, which is guaranteed to be called only once. After all, we need a single channel for this component. <code class="email">init-state</code> should return a map representing the local state.</p><p class="calibre7">Now that<a id="id351" class="calibre1"/> we have the channel, we need to install a <code class="email">go-loop</code> to<a id="id352" class="calibre1"/> handle messages sent to it. For this purpose, we use a different protocol:</p><div class="informalexample"><pre class="programlisting">    om/IWillMount
    (will-mount [_]
      (let [transfer-chan (om/get-state owner :transfer-chan)]
        (go-loop []
          (let [transfer-data (&lt;! transfer-chan)]
            (om/transact! app :columns #(move-card! % transfer-data))
            (recur)))))</pre></div><p class="calibre7">Like the previous protocol, <code class="email">om/IWillMount</code> is also guaranteed to be called once in the component life cycle. It is called when it is about to be mounted into the DOM and is the perfect place to install the <code class="email">go-loop</code> into our channel.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip30" class="calibre1"/>Tip</h3><p class="calibre7">When creating <code class="email">core.async</code> channels in Om applications, it is important to avoid creating them inside life-cycle functions that are called multiple times. Besides non-deterministic behavior, this is a source of memory leaks.</p></div><p class="calibre7">We get hold of it from the component local state using the <code class="email">om/get-state</code> function. Once we get a message, we transact the state. We will see what <code class="email">transfer-data</code> looks like very shortly.</p><p class="calibre7">We complete the component by implementing its render function:</p><div class="informalexample"><pre class="programlisting">...
om/IRenderState
    (render-state [this state]
      (dom/div nil
               (apply dom/ul nil
                      (om/build-all column-view (:columns app)
                                    {:shared     {:cards (:cards app)}
                                     :init-state state}))))
...</pre></div><p class="calibre7">The <code class="email">om/IRenderState</code> function serves the same purpose of <code class="email">om/IRender</code>, that is, it should return the DOM representation of what the component should look like. However, it defines a<a id="id353" class="calibre1"/> different function, <code class="email">render-state</code>, which receives<a id="id354" class="calibre1"/> the component local state as its second argument. This state contains the map we created during the <code class="email">init-state</code> phase.</p></div></div>

<div class="book" title="Intercomponent communication">
<div class="book" title="Remaining components"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec58" class="calibre1"/>Remaining components</h2></div></div></div><p class="calibre7">Next, we will build multiple <code class="email">column-view</code> components, one per column. Each of them receives <a id="id355" class="calibre1"/>the list of cards from the application state as their shared state. We will use that to retrieve the card details from the IDs we store in each column.</p><p class="calibre7">We also use the <code class="email">:init-state</code> key to initialize the local state of each column view with our channel, since all columns need a reference to it. Here's what the component looks like:</p><div class="informalexample"><pre class="programlisting">(defn column-view [{:keys [title cards]} owner]
  (reify
    om/IRenderState
    (render-state [this {:keys [transfer-chan]}]
      (dom/div #js {:style      #js {:border  "1px solid black"
                                     :float   "left"
                                     :height  "100%"
                                     :width   "320px"
                                     :padding "10px"}
                    :onDragOver #(.preventDefault %)
                    :onDrop     #(handle-drop % transfer-chan title)}
               (dom/h2 nil title)
               (apply dom/ul #js {:style #js {:list-style-type "none"
                                              :padding         "0px"}}
                      (om/build-all (partial card-view title)
                                    (mapv card-by-id cards)))))))</pre></div><p class="calibre7">The code should look fairly familiar at this point. We used inline CSS in the example to keep it simple, but in a real application, we would probably have used an external style sheet.</p><p class="calibre7">We implement <code class="email">render-state</code> once more to retrieve the transfer channel, which will be used when handling the <code class="email">onDrop</code> JavaScript event. This event is fired by the browser when a user drops a draggable DOM element onto this component. <code class="email">handle-drop</code> takes care of that like so:</p><div class="informalexample"><pre class="programlisting">(defn handle-drop [e transfer-chan column-title]
  (.preventDefault e)
  (let [data {:card-id            
              (js/parseInt (get-transfer-data! e "cardId"))
              :source-column      
              (get-transfer-data! e "sourceColumn")
              :destination-column 
              column-title}]
    (put! transfer-chan data)))</pre></div><p class="calibre7">This function creates the transfer data—a map with the keys <code class="email">:card-id</code>, <code class="email">:source-column</code>, and <code class="email">:destination-column</code>—which is everything we need to move the cards between <a id="id356" class="calibre1"/>columns. Finally, we <code class="email">put!</code> it into the transfer channel.</p><p class="calibre7">Next, we build a number or <code class="email">card-view</code> components. As mentioned previously, Om can't create cursors from lazy sequences, so we use <code class="email">filterv</code> to give each <code class="email">card-view</code> a vector containing their respective cards. Let's see its source:</p><div class="informalexample"><pre class="programlisting">(defn card-view [column {:keys [id title description] :as card} owner]
  (reify
    om/IRender
    (render [this]
      (dom/li #js {:style #js {:border "1px solid black"}
                   :draggable true
                   :onDragStart (fn [e]
                                  (set-transfer-data! e "cardId" id)
                                  (set-transfer-data! e "sourceColumn" column))}
              (dom/span nil title)
              (dom/p nil description)))))</pre></div><p class="calibre7">As this component doesn't need any local state, we go back to using the <code class="email">IRender</code> protocol. Additionally, we make it draggable and install an event handler on the <code class="email">onDragStart</code> event, which will be triggered when the user starts dragging the card.</p><p class="calibre7">This event handler sets the transfer data, which we use from <code class="email">handle-drop</code>.</p><p class="calibre7">We have glossed over the fact that these components use a few utility functions. That's OK, as we will now define them in a new namespace.</p></div></div>

<div class="book" title="Intercomponent communication">
<div class="book" title="Utility functions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch07lvl2sec59" class="calibre1"/>Utility functions</h2></div></div></div><p class="calibre7">Go <a id="id357" class="calibre1"/>ahead and create a new file under <code class="email">src/cljs/om_pm/</code> called <code class="email">util.cljs</code> and add the following namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns om-pm.util)</pre></div><p class="calibre7">For <a id="id358" class="calibre1"/>consistency, we will look at the functions bottom-up, starting with <code class="email">move-card!</code>:</p><div class="informalexample"><pre class="programlisting">(defn column-idx [title columns]
  (first (keep-indexed (fn [idx column]
                         (when  (= title (:title column))
                           idx))
                       columns)))

(defn move-card! [columns {:keys [card-id source-column destination-column]}]
  (let [from (column-idx source-column      columns)
        to   (column-idx destination-column columns)]
    (-&gt; columns
        (update-in [from :cards] (fn [cards]
                                   (remove #{card-id} cards)))
        (update-in [to   :cards] (fn [cards]
                                   (conj cards card-id))))))</pre></div><p class="calibre7">The <code class="email">move-card!</code> function receives a cursor for the columns in our application state and simply moves <code class="email">card-id</code> between the source and destination. You will notice we didn't need any access to <code class="email">core.async</code> or Om specific functions, which means this function is pure and therefore easy to test.</p><p class="calibre7">Next, we have the functions that handle transfer data:</p><div class="informalexample"><pre class="programlisting">(defn set-transfer-data! [e key value]
  (.setData (-&gt; e .-nativeEvent .-dataTransfer)
            key value))

(defn get-transfer-data! [e key]
  (-&gt; (-&gt; e .-nativeEvent .-dataTransfer)
      (.getData key)))</pre></div><p class="calibre7">These functions use JavaScript interoperability to interact with HTML's <code class="email">DataTransfer</code> (see <a class="calibre1" href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer">https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer</a>) object. This<a id="id359" class="calibre1"/> is how browsers share data related to drag and drop events.</p><p class="calibre7">Now, let's simply save the file and make sure the code compiles properly. We can finally open <code class="email">dev-resources/public/index.html</code> in the browser and play around with the product of our work!</p></div></div>
<div class="book" title="Exercises"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec46" class="calibre1"/>Exercises</h1></div></div></div><p class="calibre7">In this exercise, we will modify the <code class="email">om-pm</code> project we created in the previous section. The objective is to add keyboard shortcuts so that power users can operate the agile board more efficiently.</p><p class="calibre7">The shortcuts to be supported are:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">up</code>, <code class="email">down</code>, <code class="email">left</code>, and <code class="email">right</code> arrow keys: These allow the user to navigate through the cards, highlighting the current one</li><li class="listitem">The <code class="email">n</code> and <code class="email">p</code> keys: These are used to move the current card to the next (right) or previous (left) column, respectively</li></ul></div><p class="calibre7">The key insight here is to create a new <code class="email">core.async</code> channel, which will contain key press events. These events will then trigger the actions outlined previously. We can use the Google closure library to listen for events. Just add the following <code class="email">require</code> to the application namespace:</p><div class="informalexample"><pre class="programlisting">(:require [goog.events :as events])</pre></div><p class="calibre7">Then, use this function to create a channel from DOM events:</p><div class="informalexample"><pre class="programlisting"> (defn listen [el type]
  (let [c (chan)]
    (events/listen el type #(put! c %))
    c))</pre></div><p class="calibre7">The actual logic of moving the cards around based on keyboard shortcuts can be implemented in a number of ways, so don't forget to compare your solution with the answers provided in this book's companion code.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec47" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we saw a different approach on how to handle reactive web interfaces by Om and React. In turn, these frameworks make this possible and painless by applying functional programming principles such as immutability and persistent data structures for efficient rendering.</p><p class="calibre7">We also learned to think the Om way by structuring our applications as a series of functions, which receive state and output a DOM representation of state changes.</p><p class="calibre7">Additionally, we saw that by structuring application state transitions through <code class="email">core.async</code> channels, we separate the presentation logic from the code, which will actually perform the work, making our components even easier to reason about.</p><p class="calibre7">In the next chapter, we will turn to an often overlooked yet useful tool for creating reactive applications: <span class="strong"><strong class="calibre2">Futures</strong></span>.</p></div></body></html>