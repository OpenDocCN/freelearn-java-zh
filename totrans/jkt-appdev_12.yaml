- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Jakarta Enterprise Beans
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta企业Bean
- en: '**Jakarta Enterprise Beans** are server-side components that encapsulate the
    business logic of an application. Enterprise beans simplify application development
    by automatically taking care of transaction management and security. There are
    two types of enterprise beans: **session beans**, which perform business logic,
    and **message-driven beans**, which act as a message listener.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jakarta企业Bean**是封装应用业务逻辑的服务端组件。企业Bean通过自动处理事务管理和安全性来简化应用开发。有两种类型的企业Bean：**会话Bean**，执行业务逻辑，和**消息驱动Bean**，作为消息监听器。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Session beans
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话Bean
- en: Message-driven beans
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息驱动Bean
- en: Transactions in enterprise beans
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业Bean中的事务
- en: Enterprise bean life cycles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业Bean生命周期
- en: Enterprise bean timer service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业Bean定时器服务
- en: Enterprise bean security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业Bean安全性
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch12_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch12_src).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch12_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch12_src)。
- en: Session beans
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话Bean
- en: As we previously mentioned, session beans typically encapsulate business logic.
    One or two artifacts need to be created in order to create a session bean, including
    the bean itself, and an optional business interface. These artifacts need to be
    annotated adequately to let the Jakarta EE runtime know they are session beans.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，会话Bean通常封装业务逻辑。为了创建一个会话Bean，需要创建一个或两个工件，包括Bean本身和一个可选的业务接口。这些工件需要适当地注解，以便让Jakarta
    EE运行时知道它们是会话Bean。
- en: A simple session bean
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的会话Bean
- en: 'The following example illustrates a very simple session bean:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了一个非常简单的会话Bean：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `@Stateless` annotation lets the Jakarta EE runtime know that this class
    is a **stateless session bean**. There are three types of session beans: stateless,
    stateful, and singleton. Before we explain the difference between these types
    of session beans, we need to clarify how an instance of an enterprise bean is
    provided to a client application.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Stateless`注解让Jakarta EE运行时知道这个类是一个**无状态会话Bean**。有三种类型的会话Bean：无状态、有状态和单例。在我们解释这些类型会话Bean之间的区别之前，我们需要明确一个企业Bean的实例是如何提供给客户端应用的。'
- en: When a stateless or stateful session bean is deployed, the Jakarta EE container
    creates a series of instances of each session bean. This is what is typically
    referred to as the **enterprise bean pool**. When a client application obtains
    an instance of an enterprise bean, one of the instances in the pool is provided
    to this client application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当无状态或有状态会话Bean部署时，Jakarta EE容器为每个会话Bean创建一系列实例。这通常被称为**企业Bean池**。当客户端应用获取一个企业Bean的实例时，池中的一个实例会被提供给这个客户端应用。
- en: The difference between stateful and stateless session beans is that stateful
    session beans maintain a **conversational state** with the client, whereas stateless
    session beans do not. In simple terms, what this means is that when a client application
    obtains an instance of a stateful session bean, we are guaranteed that the value
    of any instance variables in the bean will be consistent across method calls.
    Therefore, it is safe to modify any instance variables on a stateful session bean,
    since they will retain their value for the next method call. The Jakarta EE runtime
    saves conversational state by passivating stateful session beans, and retrieves
    said state when the bean is activated. The conversational state is the reason
    why the life cycle of stateful session beans is a bit more complex than the life
    cycle of stateless session beans or message-driven beans (the enterprise bean
    life cycle is discussed later in this chapter).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态会话Bean和无状态会话Bean之间的区别在于，有状态会话Bean与客户端保持**对话状态**，而无状态会话Bean则不保持。简单来说，这意味着当客户端应用获取一个有状态会话Bean的实例时，我们可以保证Bean中任何实例变量的值在方法调用之间是一致的。因此，在修改有状态会话Bean上的任何实例变量时是安全的，因为它们将在下一次方法调用中保留其值。Jakarta
    EE运行时通过钝化有状态会话Bean来保存对话状态，并在Bean激活时检索该状态。对话状态是有状态会话Bean生命周期比无状态会话Bean或消息驱动Bean生命周期更复杂的原因（企业Bean的生命周期将在本章后面讨论）。
- en: The Jakarta EE runtime may provide any instance of an enterprise bean in the
    pool when a client application requests an instance of a stateless session bean.
    Since we are not guaranteed the same instance for every method call, values set
    to any instance variables in a stateless session bean may be “lost” (they are
    not really lost; the modification is in another instance of the enterprise bean
    in the pool).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端应用程序请求一个无状态会话Bean的实例时，Jakarta EE运行时可能会在池中提供任何企业Bean的实例。由于我们无法保证每次方法调用都使用相同的实例，因此在无状态会话Bean中设置的任何实例变量可能会“丢失”（它们实际上并没有丢失；修改是在池中企业Bean的另一个实例中）。
- en: 'Other than being decorated with the `@Stateless` annotation, there is nothing
    special about our example class. Notice that it implements an interface called
    `SimpleSession`. This interface is the bean’s business interface. The `SimpleSession`
    interface is shown next:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用`@Stateless`注解装饰外，我们的示例类没有特别之处。请注意，它实现了一个名为`SimpleSession`的接口。这个接口是Bean的企业接口。`SimpleSession`接口如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only peculiar thing about this interface is that it is decorated with the
    `@Remote` annotation. This annotation indicates that this is a **remote business
    interface**. What this means is that the interface may be in a different JVM than
    the client application invoking it. Remote business interfaces may even be invoked
    across the network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口唯一特别的地方是它被`@Remote`注解装饰。这个注解表示这是一个**远程业务接口**。这意味着接口可能位于调用它的客户端应用程序不同的JVM中。远程业务接口甚至可以在网络上被调用。
- en: Business interfaces may also be decorated with the `@Local` interface. This
    annotation indicates that the business interface is a **local business interface**.
    Local business interface implementations must be in the same JVM as the client
    application invoking its methods.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 企业接口也可以用`@Local`接口装饰。这个注解表示业务接口是一个**本地业务接口**。本地业务接口的实现必须在与调用其方法的客户端应用程序相同的JVM中。
- en: Once we have compiled the session bean and its corresponding business interface,
    we need to place them in a JAR file and deploy them. How to deploy an enterprise
    bean JAR file depends on what application server we are using. Most modern application
    servers have an `autodeploy` directory. We can simply copy our JAR file to this
    directory in most cases. Consult your application server documentation to find
    the exact location of its `autodeploy` directory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编译了会话Bean及其对应的企业接口，我们需要将它们放入一个JAR文件中并部署它们。如何部署企业Bean JAR文件取决于我们使用的是哪种应用服务器。大多数现代应用服务器都有一个`autodeploy`目录。在大多数情况下，我们可以简单地复制我们的JAR文件到这个目录。请查阅您的应用服务器文档以找到其`autodeploy`目录的确切位置。
- en: 'Now that we have seen the session bean and its corresponding business interface,
    let’s take a look at a client sample application:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了会话Bean及其对应的企业接口，让我们看看一个客户端示例应用程序：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code simply declares an instance variable of the `com.ensode.jakartaeebook.SimpleSession`
    type, which is the business interface for our session bean. The instance variable
    is annotated with `@EJB`. This annotation lets the Jakarta EE runtime know that
    this variable is a business interface for a session bean. The Jakarta EE runtime
    then injects an implementation of the business interface for the client code to
    use.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码简单地声明了一个`com.ensode.jakartaeebook.SimpleSession`类型的实例变量，这是我们的会话Bean的企业接口。这个实例变量被注解为`@EJB`。这个注解让Jakarta
    EE运行时知道这个变量是一个会话Bean的企业接口。然后Jakarta EE运行时注入一个业务接口的实现，以便客户端代码可以使用。
- en: 'Since our client is a standalone application (as opposed to a Jakarta EE artifact
    such as a WAR file or a deployable JAR file), we don’t need to deploy to the Jakarta
    EE runtime. In order for it to be able to access code deployed to the server,
    it must have access to the application server’s client libraries. The procedure
    on how to accomplish this varies from application server to application server.
    When using GlassFish, our client code must be placed in a `JAR` file and executed
    through the `[glassfish installation directory]/glassfish/bin/`. Assuming this
    directory is in the `PATH` environment variable, and assuming we placed our client
    code in a JAR file called `simplesessionbeanclient.jar`, we would execute the
    preceding client code by typing the following command in the command line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的客户端是一个独立的应用程序（而不是Jakarta EE工件，如WAR文件或可部署的JAR文件），我们不需要部署到Jakarta EE运行时。为了让它能够访问服务器上部署的代码，它必须能够访问应用服务器的客户端库。如何实现这一点的步骤因应用服务器而异。当使用GlassFish时，我们的客户端代码必须放置在一个`JAR`文件中，并通过`[glassfish安装目录]/glassfish/bin/`执行。假设这个目录在`PATH`环境变量中，并且假设我们将我们的客户端代码放置在一个名为`simplesessionbeanclient.jar`的JAR文件中，我们将在命令行中键入以下命令来执行前面的客户端代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Executing this command results in the following console output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令会产生以下控制台输出：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the expected output upon executing the `SessionBeanClient` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行`SessionBeanClient`类后的预期输出。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are using Maven to build our code. For this example, we have used the Maven
    Assembly Plugin ([http://maven.apache.org/plugins/maven-assembly-plugin/](http://maven.apache.org/plugins/maven-assembly-plugin/))
    to build a client JAR file that includes all dependencies. This frees us from
    having to specify all the dependent JAR files in the `-classpath` command-line
    option of `appclient`. To build this JAR file, simply invoke `mvn assembly:assembly`
    from the command line.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Maven来构建我们的代码。在这个例子中，我们使用了Maven Assembly Plugin ([http://maven.apache.org/plugins/maven-assembly-plugin/](http://maven.apache.org/plugins/maven-assembly-plugin/))
    来构建一个包含所有依赖项的客户端JAR文件。这使我们免去了在`appclient`的`-classpath`命令行选项中指定所有依赖JAR文件的需要。要构建这个JAR文件，只需在命令行中执行`mvn
    assembly:assembly`。
- en: The first line of output is simply the return value of the `getMessage()` method
    we implemented in the session bean. The second line of output displays the fully
    qualified class name of the class implementing the business interface. Notice
    that the class name is not the fully qualified name of the session bean we wrote;
    instead, what is actually provided is an implementation of the business interface
    created behind the scenes by the Jakarta EE runtime.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行仅仅是我们在会话Bean中实现的`getMessage()`方法的返回值。第二行输出显示实现业务接口的类的完全限定名称。请注意，类名不是我们编写的会话Bean的完全限定名称；实际上，提供的是Jakarta
    EE运行时在幕后创建的业务接口的实现。
- en: A more realistic example
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更现实的例子
- en: In the previous section, we saw a very simple “Hello World” type of example.
    In this section, we will show a more realistic example. Session beans are frequently
    used as **Data Access Objects** (**DAOs**). Sometimes they are used as a wrapper
    for JDBC calls; other times they are used to wrap calls to obtain or modify Jakarta
    Persistence entities. In this section, we will take the latter approach.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了一个非常简单的“Hello World”类型的例子。在本节中，我们将展示一个更现实的例子。会话Bean通常用作**数据访问对象**（**DAO**）。有时它们用作JDBC调用的包装器；有时它们用于包装获取或修改Jakarta
    Persistence实体的调用。在本节中，我们将采用后一种方法。
- en: The following example illustrates how to implement the DAO design pattern in
    a session bean.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何在会话Bean中实现DAO设计模式。
- en: 'Let’s now take a look at the session bean implementing our example business
    interface. As we are about to see, there are some differences between the way
    Jakarta Persistence code is implemented in a session bean versus in a plain old
    Java object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看实现我们示例业务接口的会话Bean。正如我们即将看到的，在会话Bean中实现Jakarta Persistence代码的方式与在普通的Java对象中实现的方式有一些不同：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is worth pointing out that since we don’t intend for our session bean to
    be invoked remotely, there is no need for a remote business interface in this
    case. Our client applications can simply inject an instance of the session bean
    via the `@``EJB` annotation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，由于我们并不打算让我们的会话Bean远程调用，因此在这种情况下不需要远程业务接口。我们的客户端应用程序可以通过`@EJB`注解简单地注入会话Bean的一个实例。
- en: As we can see, our session bean implements three methods. The `saveCustomer()`
    method saves customer data to the database, the `getCustomer()` method obtains
    data for a customer from the database, and the `deleteCustomer()` method deletes
    customer data from the database. All of these methods take an instance of a Jakarta
    Persistence entity bean or type `Customer`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的会话Bean实现了三个方法。`saveCustomer()`方法将客户数据保存到数据库，`getCustomer()`方法从数据库获取客户的资料，`deleteCustomer()`方法从数据库删除客户数据。所有这些方法都接受一个Jakarta
    Persistence实体Bean的实例或类型`Customer`。
- en: Normally, when making Jakarta Persistence calls, we need to start and commit
    transactions via `UserTransaction.begin()` and `UserTransaction.commit()`. The
    reason we need to do this is that Jakarta Persistence calls are required to be
    wrapped in a transaction. If they are not in a transaction, most Jakarta Persistence
    calls will throw `TransactionRequiredException`. Session bean methods are implicitly
    transactional. There is nothing we need to do to make them that way. For this
    reason, we don’t need to manually start and commit transactions when invoking
    Jakarta Persistence calls from a session bean. This default behavior is what is
    known as **container-managed transactions**. Container-managed transactions are
    discussed in detail later in this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们进行Jakarta Persistence调用时，我们需要通过`UserTransaction.begin()`和`UserTransaction.commit()`启动和提交事务。我们需要这样做的原因是Jakarta
    Persistence调用需要被事务包装。如果没有在事务中，大多数Jakarta Persistence调用将抛出`TransactionRequiredException`。会话Bean方法隐式地是事务性的。我们不需要做任何事情来使它们成为那样。因此，当我们从会话Bean中调用Jakarta
    Persistence调用时，我们不需要手动启动和提交事务。这种默认行为被称为**容器管理事务**。容器管理事务将在本章后面详细讨论。
- en: Invoking session beans from web applications
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Web应用程序调用会话Bean
- en: Frequently, Jakarta EE applications consist of web applications acting as clients
    for enterprise beans. In this section, we will develop a Jakarta Faces web application
    with a CDI named bean acting as a client for the DAO session bean we just discussed
    in the previous section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Jakarta EE应用程序由充当企业Bean客户端的Web应用程序组成。在本节中，我们将开发一个Jakarta Faces Web应用程序，其中有一个CDI命名Bean作为我们在上一节中讨论的DAO会话Bean的客户端。
- en: 'In order to make this application act as an enterprise bean client, we will
    develop a `CustomerController` named bean so that it delegates the logic to save
    a new customer to the database to the `CustomerDaoBean` session bean we developed
    in the previous section, as shown in the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此应用程序充当企业Bean客户端，我们将开发一个名为`CustomerController`的Bean，以便将保存新客户到数据库的逻辑委托给我们在上一节中开发的单例会话Bean
    `CustomerDaoBean`，如下例所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, all we had to do was to obtain an instance of the `CustomerDaoBean`
    session bean and annotate it with the `@EJB` annotation, then invoke the bean’s
    `saveCustomer()` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只需获取`CustomerDaoBean`会话Bean的一个实例，并用`@EJB`注解标注它，然后调用Bean的`saveCustomer()`方法。
- en: Notice that we injected an instance of the session bean directly into our client
    code. Since the client code is running on the same JVM as the enterprise bean,
    there is no need for remote interfaces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们直接将单例Bean的实例注入到我们的客户端代码中。由于客户端代码与企业Bean运行在同一个JVM上，因此不需要远程接口。
- en: Now that we have developed our web application client for our session bean,
    we need to package it in a WAR (web archive) file and deploy it in order to use
    it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的会话Bean开发出了我们的Web应用程序客户端，我们需要将其打包成WAR（Web存档）文件并部署，以便使用它。
- en: Singleton session beans
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例会话Bean
- en: Another type of session bean is the **singleton session bean**. A single instance
    of each singleton session bean exists in the Jakarta EE runtime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的会话Bean是**单例会话Bean**。在Jakarta EE运行时中，每个单例会话Bean只有一个实例存在。
- en: 'Singleton session beans are useful to cache database data. Caching frequently
    used data in a singleton session bean increases performance since it greatly minimizes
    trips to the database. The common pattern is to have a method in our bean decorated
    with the `@PostConstruct` annotation. In this method, we retrieve the data we
    want to cache. Then, we provide a setter method for the bean’s clients to call.
    The following example illustrates this technique:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单例会话Bean对于缓存数据库数据很有用。在单例会话Bean中缓存常用数据可以提高性能，因为它大大减少了访问数据库的次数。常见的模式是在我们的Bean中有一个用`@PostConstruct`注解装饰的方法。在这个方法中，我们检索我们想要缓存的数据。然后，我们提供一个setter方法供Bean的客户端调用。以下示例说明了这种技术：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `@Singleton` annotation denotes our class as a singleton session bean. Since
    our bean is a singleton, all of its clients would access the same instance, avoiding
    having duplicate data in memory. Additionally, since it is a singleton, it is
    safe to have an instance variable, since all clients access the same instance
    of the bean.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Singleton` 注解表示我们的类是一个单例会话 bean。由于我们的 bean 是单例的，所以所有客户端都会访问同一个实例，从而避免在内存中有重复数据。此外，由于它是单例的，所以可以安全地有一个实例变量，因为所有客户端都访问同一个
    bean 的实例。'
- en: Asynchronous method calls
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步方法调用
- en: Sometimes it is useful to have some processing done asynchronously, that is,
    invoke a method call and return control immediately to the client, without having
    the client wait for the method to finish.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时异步处理一些操作是有用的，即调用一个方法调用并立即将控制权返回给客户端，而无需客户端等待方法完成。
- en: The `@Asynchronous` annotation can be used to mark a method in a session bean
    as asynchronous. When an enterprise bean client invokes an asynchronous method,
    control immediately goes back to the client, without waiting for the method to
    finish.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Asynchronous` 注解可以用来标记会话 bean 中的方法为异步。当企业 bean 客户端调用异步方法时，控制权立即返回给客户端，无需等待方法完成。'
- en: 'Asynchronous methods can only return `void` or an implementation of the `java.util.concurrent.Future`
    interface. The following example illustrates both scenarios:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法只能返回 `void` 或 `java.util.concurrent.Future` 接口的实现。以下示例说明了这两种情况：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When our asynchronous method returns `void`, the only thing we need to do is
    decorate the method with the `@Asynchronous` annotation, and then call it as usual
    from the client code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的异步方法返回 `void` 时，我们只需要用 `@Asynchronous` 注解装饰方法，然后像往常一样从客户端代码中调用它。
- en: If we need a return value, this value needs to be wrapped in an implementation
    of the `jav.util.concurrent.Future` interface. Jakarta EE provides a convenient
    implementation in the form of the `jakarta.ejb.AsyncResult` class. Both the `Future`
    interface and the `AsyncResult` class use generics. We need to specify our return
    type as the type parameter of these artifacts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要返回值，这个值需要被包装在 `jav.util.concurrent.Future` 接口的实现中。Jakarta EE 以 `jakarta.ejb.AsyncResult`
    类的形式提供了一个方便的实现。`Future` 接口和 `AsyncResult` 类都使用泛型。我们需要将这些工具的返回类型指定为类型参数。
- en: 'The `Future` interface has several methods we can use to cancel the execution
    of an asynchronous method, check to see whether the method has been carried out,
    get the return value of the method, or check to see whether the method has been
    canceled. *Table 12.1* lists these methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 接口有几种方法我们可以用来取消异步方法的执行，检查方法是否已执行，获取方法的返回值，或检查方法是否已被取消。*表 12.1* 列出了这些方法：'
- en: '| **Method** | **Description** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cancel(boolean mayInterruptIfRunning)` | Cancels method execution. If the
    Boolean parameter is `true`, then this method will attempt to cancel the method
    execution even if it is already running. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `cancel(boolean mayInterruptIfRunning)` | 取消方法执行。如果布尔参数为 `true`，则此方法将尝试取消方法执行，即使它已经在运行。
    |'
- en: '| `get()` | Will return the “unwrapped” return value of the method. The return
    value will be of the type parameter of the `Future` interface implementation returned
    by the method. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `get()` | 将返回方法的“未包装”返回值。返回值将是方法返回的 `Future` 接口实现类型参数的类型。 |'
- en: '| `get(long timeout,` `TimeUnit unit)` | Will attempt the “unwrapped” return
    value of the method. The return value will be of the type parameter of the `Future`
    interface implementation returned by the method. This method will block for the
    amount of time specified by the first parameter. The unit of time to wait is determined
    by the second parameter. The `TimeUnit` enum has constants for NANOSECONDS, MILLISECONDS,
    SECONDS, MINUTES, and so on. Refer to its Javadoc documentation for the complete
    list. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `get(long timeout, TimeUnit unit)` | 将尝试方法的“未包装”返回值。返回值将是方法返回的 `Future` 接口实现类型参数的类型。此方法将阻塞指定的时间。等待时间的单位由第二个参数确定。`TimeUnit`
    枚举有 NANOSECONDS、MILLISECONDS、SECONDS、MINUTES 等常量。请参阅其 Javadoc 文档以获取完整列表。 |'
- en: '| `isCancelled()` | Returns `true` if the method has been canceled, and `false`
    otherwise. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `isCancelled()` | 如果方法已被取消，则返回 `true`，否则返回 `false`。 |'
- en: '| `isDone()` | Returns `true` if the method has finished executing, and `false`
    otherwise. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `isDone()` | 如果方法已执行完成，则返回 `true`，否则返回 `false`。 |'
- en: Table 12.1 – Canceling asynchronous method execution
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1 – 取消异步方法执行
- en: As we can see, the `@Asynchronous` annotation makes it very easy to make asynchronous
    calls without having the overhead of having to set up message queues or topics.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`@Asynchronous` 注解使得在不设置消息队列或主题的开销下进行异步调用变得非常简单。
- en: 'The following example illustrates how to invoke asynchronous Jakarta Enterprise
    Bean methods:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何调用异步 Jakara 企业 Bean 方法：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, invoking the asynchronous Jakarta Enterprise Beans method returning
    `void` is no different from invoking a regular method. Things get a bit more interesting
    when invoking a method that returns a value. The asynchronous invocation returns
    an instance of `Future`. We can then check to see whether the invocation is done
    by invoking `isDone()` on the future instance, cancel it if it’s taking too long
    by invoking `cancel()`, or obtain the value from the asynchronous method by invoking
    `get()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，调用返回 `void` 的异步 Jakara 企业 Bean 方法与调用常规方法没有区别。当调用返回值的函数时，事情会变得更有趣。异步调用返回一个
    `Future` 实例。然后我们可以通过在 future 实例上调用 `isDone()` 来检查调用是否完成，如果它花费时间过长，可以通过调用 `cancel()`
    来取消它，或者通过调用 `get()` 来从异步方法中获取值。
- en: Now that we’ve discussed session beans at length, we’ll focus our attention
    on the other type of enterprise bean, message-driven beans.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经详细讨论了会话 Bean，我们将把注意力转向另一种企业 Bean，即消息驱动 Bean。
- en: Message-driven beans
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动 Bean
- en: 'The purpose of a message-driven bean is to consume messages from a Jakarta
    messaging queue or a Jakarta messaging topic, depending on the messaging domain
    used (refer to [*Chapter 13*](B21231_13.xhtml#_idTextAnchor184)). A message-driven
    bean must be annotated with the `@MessageDriven` annotation. The `mappedName`
    attribute of this annotation must contain the **Java Naming and Directory Interface**
    (**JNDI**) name of the message queue or message topic that the bean will be consuming
    messages from. The following example illustrates a simple message-driven bean:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动 Bean 的目的是根据所使用的消息域从 Jakara 消息队列或 Jakara 消息主题中消费消息（参考[*第 13 章*](B21231_13.xhtml#_idTextAnchor184)）。消息驱动
    Bean 必须使用 `@MessageDriven` 注解进行标注。此注解的 `mappedName` 属性必须包含 Bean 将从中消费消息的消息队列或消息主题的
    **Java 命名和目录接口**（**JNDI**）名称。以下示例演示了一个简单的消息驱动 Bean：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `@JMSDestinationDefinition` annotation defines a Jakarta messaging destination
    that the message-driven bean will use to consume messages from. The destination
    can either be a queue or a topic; in our case, we are using a queue, therefore
    `jakarta.jms.Queue` is the value of the annotation’s `interfaceName` attribute.
    The annotation’s name attribute defines a JNDI name that the message-driven bean
    can use to refer to the queue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`@JMSDestinationDefinition` 注解定义了一个 Jakara 消息队列，消息驱动 Bean 将使用它来消费消息。该队列可以是队列或主题；在我们的例子中，我们使用的是队列，因此
    `jakarta.jms.Queue` 是注解的 `interfaceName` 属性的值。注解的 `name` 属性定义了一个 JNDI 名称，消息驱动
    Bean 可以使用该名称来引用队列。'
- en: Message-driven beans must be decorated with the `@MessageDriven` annotation;
    they listen for messages on the queue or topic defined in the `destinationLookup`
    property as defined by an `@ActivationConfigProperty` annotation. Notice that
    in our example, the value of the `destinationLookup` property matches the value
    of the `name` attribute in the corresponding `@JMSDestinationDefinition` annotation.
    The type of Jakarta messaging destination (`jakarta.jmsQueue` or `jakarta.jms.Topic`)
    must be specified in the `destinationType` property of `@MessageDriven`, as illustrated
    in our example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动 Bean 必须使用 `@MessageDriven` 注解进行装饰；它们在由 `@ActivationConfigProperty` 注解定义的
    `destinationLookup` 属性中定义的队列或主题上监听消息。请注意，在我们的示例中，`destinationLookup` 属性的值与相应的
    `@JMSDestinationDefinition` 注解中的 `name` 属性的值相匹配。在 `@MessageDriven` 的 `destinationType`
    属性中必须指定 Jakara 消息队列的类型（`jakarta.jmsQueue` 或 `jakarta.jms.Topic`），如我们的示例所示。
- en: It is recommended, but not required, for message-driven beans to implement the
    `jakarta.jms.MessageListener` interface. However, message-driven beans must have
    a method called `onMessage()` whose signature is identical to the preceding example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 建议但不是必须要求消息驱动 Bean 实现 `jakarta.jms.MessageListener` 接口。然而，消息驱动 Bean 必须有一个名为
    `onMessage()` 的方法，其签名与前面的示例相同。
- en: Client applications never invoke a message-driven bean’s methods directly. Instead,
    they put messages in the message queue or topic, and then the bean consumes those
    messages and acts as appropriate. Our example simply prints the message to the
    Jakarta EE runtime log.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序永远不会直接调用消息驱动Bean的方法。相反，它们将消息放入消息队列或主题，然后Bean消费这些消息并采取适当的行动。我们的示例只是将消息打印到Jakarta
    EE运行时日志中。
- en: Both session and message-driven beans support transaction management, this is
    discussed in the following sections.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 会话Bean和消息驱动Bean都支持事务管理，这将在以下章节中讨论。
- en: Transactions in enterprise beans
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业Bean事务处理
- en: As we mentioned earlier in this chapter, by default, all enterprise bean methods
    are automatically wrapped in a transaction. This default behavior is known as
    **container-managed transactions**, since transactions are managed by the Jakarta
    EE runtime. Application developers may also choose to manage transactions themselves.
    This can be accomplished by using **bean-managed transactions**. Both of these
    approaches are discussed in the following sections.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们本章前面提到的，默认情况下，所有企业Bean方法都会自动包装在事务中。这种默认行为被称为**容器管理事务**，因为事务是由Jakarta EE运行时管理的。应用程序开发者也可以选择自己管理事务。这可以通过使用**Bean管理事务**来实现。这两种方法将在以下章节中讨论。
- en: Container-managed transactions
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器管理事务
- en: Because enterprise bean methods are transactional by default, we run into an
    interesting dilemma when an enterprise bean method is invoked from client code
    that is already in a transaction. How should the Jakarta EE runtime behave? Should
    it suspend the client transaction, execute its method in a new transaction, and
    then resume the client transaction? Should it not create a new transaction and
    execute its method as part of the client transaction? Should it throw an exception?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于企业Bean方法默认是事务性的，当企业Bean方法从已经在事务中的客户端代码调用时，我们会遇到一个有趣的困境。Jakarta EE运行时应该如何处理？它应该挂起客户端事务，在一个新的事务中执行其方法，然后恢复客户端事务？它应该不创建新事务，并将方法作为客户端事务的一部分执行？或者它应该抛出异常？
- en: 'By default, if an enterprise bean method is invoked by client code that is
    already in a transaction, the Jakarta EE runtime will simply execute the enterprise
    bean method as part of the client transaction. If this is not the behavior we
    need, we can change it by annotating the method with the `@TransactionAttribute`
    annotation. This annotation has a `value` attribute that determines how the Jakarta
    EE runtime will behave when the session bean method is invoked within an existing
    transaction and when it is invoked outside any transactions. The value of the
    `value` attribute is typically a constant defined in the `jakarta.ejb.TransactionAttributeType`
    enum. *Table 12.2* lists the possible values for the `@``TransactionAttribute`
    annotation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果企业Bean方法被已经在事务中的客户端代码调用，Jakarta EE运行时会简单地执行企业Bean方法作为客户端事务的一部分。如果这不是我们需要的操作，我们可以通过使用`@TransactionAttribute`注解来更改它。这个注解有一个`value`属性，它决定了当会话Bean方法在现有事务中调用或在外部调用时，Jakarta
    EE运行时的行为。`value`属性的值通常是`jakarta.ejb.TransactionAttributeType`枚举中定义的常量。*表12.2*列出了`@TransactionAttribute`注解的可能值：
- en: '| **@****TransactionAttribute Value** | **Description** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **@TransactionAttribute 值** | **描述** |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `TransactionAttributeType.MANDATORY` | Forces the method to be invoked as
    part of a client transaction. If the method is called outside any transactions,
    it will throw `TransactionRequiredException`. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.MANDATORY` | 强制方法作为客户端事务的一部分被调用。如果方法在没有任何事务的情况下被调用，它将抛出`TransactionRequiredException`异常。|'
- en: '| `TransactionAttributeType.NEVER` | The method is never executed in a transaction.
    If the method is invoked as part of a client transaction, it will throw `RemoteException`.
    No transaction is created if the method is not invoked inside a client transaction.
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.NEVER` | 方法永远不会在事务中执行。如果方法作为客户端事务的一部分被调用，它将抛出`RemoteException`异常。如果方法不在客户端事务内部调用，则不会创建任何事务。|'
- en: '| `TransactionAttributeType.NOT_SUPPORTED` | If the method is invoked as part
    of a client transaction, the client transaction is suspended. The method is executed
    outside any transaction. After the method completes, the client transaction is
    resumed. No transaction is created if the method is not invoked inside a client
    transaction. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.NOT_SUPPORTED` | 如果方法作为客户端事务的一部分被调用，客户端事务将被挂起。该方法将在任何事务之外执行。方法完成后，客户端事务将恢复。如果方法不是在客户端事务内部被调用，则不会创建任何事务。|'
- en: '| `TransactionAttributeType.REQUIRED` | If the method is invoked as part of
    a client transaction, the method is executed as part of said transaction. If the
    method is invoked outside any transaction, a new transaction is created for the
    method. This is the default behavior. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.REQUIRED` | 如果方法作为客户端事务的一部分被调用，该方法将作为该事务的一部分执行。如果方法在任何事务之外被调用，将为该方法创建一个新的事务。这是默认行为。|'
- en: '| `TransactionAttributeType.REQUIRES_NEW` | If the method is invoked as part
    of a client transaction, said transaction is suspended, and a new transaction
    is created for the method. Once the method completes, the client transaction is
    resumed. If the method is called outside any transactions, a new transaction is
    created for the method. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.REQUIRES_NEW` | 如果方法作为客户端事务的一部分被调用，该事务将被挂起，并为该方法创建一个新的事务。一旦方法完成，客户端事务将恢复。如果方法在任何事务之外被调用，将为该方法创建一个新的事务。|'
- en: '| `TransactionAttributeType.SUPPORTS` | If the method is invoked as part of
    a client transaction, it is executed as part of said transaction. If the method
    is invoked outside a transaction, no new transaction is created for the method.
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.SUPPORTS` | 如果方法作为客户端事务的一部分被调用，它将作为该事务的一部分执行。如果方法在事务之外被调用，不会为该方法创建新的事务。|'
- en: Table 12.2 – Container-managed transactions transaction attributes
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2 – 容器管理的事务事务属性
- en: 'Although the default transaction attribute is reasonable in most cases, it
    is good to be able to override this default if necessary. For example, transactions
    have a performance impact, therefore being able to turn off transactions for a
    method that does not need them is beneficial. For a case like this, we would annotate
    our method as illustrated in the following code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数情况下默认事务属性是合理的，但能够在必要时覆盖此默认值是很好的。例如，事务有性能影响，因此能够关闭不需要事务的方法的事务是有益的。对于这种情况，我们可以在以下代码片段中注解我们的方法：|
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Other transaction attribute types can be declared by annotating the methods
    with the corresponding constant in the `TransactionAttributeType` enum.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他事务属性类型可以通过在`TransactionAttributeType`枚举中用相应的常量注解方法来声明。
- en: If we wish to override the default transaction attribute consistently across
    all methods in a session bean, we can decorate the session bean class with the
    `@TransactionAttribute` annotation. The value of its `value` attribute will be
    applied to every method in the session bean.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在会话Bean中的所有方法上始终一致地覆盖默认事务属性，我们可以用`@TransactionAttribute`注解装饰会话Bean类。其`value`属性的值将应用于会话Bean中的每个方法。
- en: 'Container-managed transactions are automatically rolled back whenever an exception
    is thrown inside an enterprise bean method. Additionally, we can programmatically
    roll back a container-managed transaction by invoking the `setRollbackOnly()`
    method on an instance of `jakarta.ejb.EJBContext` corresponding to the session
    bean in question. The following example is a new version of the session bean we
    saw earlier in this chapter, modified to roll back transactions if necessary:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 容器管理的事务在企业Bean方法内部抛出异常时自动回滚。此外，我们可以通过在对应于会话Bean的`jakarta.ejb.EJBContext`实例上调用`setRollbackOnly()`方法来程序化地回滚容器管理的事务。以下示例是本章前面看到的会话Bean的新版本，修改为在必要时回滚事务：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this version of the DAO session bean, we made the `saveNewCustomer()` `updateCustomer()`
    method public. This method now checks to see whether the `customerId` field is
    null. If it is not null, this implies we are working with a customer that already
    exists in the database. Our method also checks to make sure the object to be persisted
    is not null. If any of the checks result in invalid data, the method simply rolls
    back the transaction by invoking the `setRollBackOnly()` method on the injected
    instance of `EJBContext` and does not update the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的DAO会话Bean中，我们将 `saveNewCustomer()` 和 `updateCustomer()` 方法设置为公共的。现在，这个方法会检查
    `customerId` 字段是否为空。如果不为空，这意味着我们正在处理数据库中已经存在的客户。我们的方法还会检查要持久化的对象是否不为空。如果任何检查导致无效数据，该方法将简单地通过在注入的
    `EJBContext` 实例上调用 `setRollBackOnly()` 方法来回滚事务，并且不更新数据库。
- en: Bean-managed transactions
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向Bean管理的交易
- en: 'As we have seen, container-managed transactions make it ridiculously easy to
    write code that is wrapped in a transaction; after all, there is nothing special
    that we need to do to make them that way. As a matter of fact, some developers
    are sometimes not even aware that they are writing code that will be transactional
    in nature when they develop session beans. Container-managed transactions cover
    most of the typical cases that we will encounter. However, they do have a limitation.
    Each method can be wrapped in a single transaction or with no transaction. With
    container-managed transactions, it is not possible to implement a method that
    generates more than one transaction, but this can be accomplished by using **bean-managed
    transactions**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，容器管理的交易使得编写被事务包裹的代码变得极其简单；毕竟，我们不需要做任何特别的事情来使它们成为这样。事实上，一些开发者在开发会话Bean时甚至可能没有意识到他们正在编写具有事务性的代码。容器管理的交易涵盖了我们将遇到的典型情况的大部分。然而，它们确实有一个限制。每个方法只能被单个事务包裹，或者不包裹任何事务。在容器管理的交易中，无法实现生成多个事务的方法，但可以通过使用**Bean管理的交易**来完成：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we implemented a method named `saveMultipleNewCustomers()`.
    This method takes a `List` of customers as its sole parameter. The intention of
    this method is to save as many elements in the `ArrayList` as possible. An exception
    saving one of the entities should not stop the method from attempting to save
    the remaining elements. This behavior is not possible using container-managed
    transactions, since an exception thrown when saving one of the entities would
    roll back the whole transaction. The only way to achieve this behavior is through
    bean-managed transactions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实现了一个名为 `saveMultipleNewCustomers()` 的方法。这个方法接受一个 `List` 客户列表作为其唯一参数。这个方法的目的尽可能多地保存
    `ArrayList` 中的元素。如果保存其中一个实体时抛出异常，不应该阻止方法尝试保存剩余的元素。使用容器管理的交易无法实现这种行为，因为保存其中一个实体时抛出的异常会导致整个事务回滚。实现这种行为的唯一方法是通过Bean管理的交易。
- en: As can be seen in the example, we declare that the session bean uses bean-managed
    transactions by decorating the class with the `@TransactionManagement` annotation
    and using `TransactionManagementType.BEAN` as the value for its `value` attribute
    (the only other valid value for this attribute is `TransactionManagementType.CONTAINER`,
    but since this is the default value, it is not necessary to specify it).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们通过使用 `@TransactionManagement` 注解并使用 `TransactionManagementType.BEAN`
    作为其 `value` 属性的值（此属性的另一个有效值是 `TransactionManagementType.CONTAINER`，但由于这是默认值，因此没有必要指定它）来声明会话Bean使用Bean管理的交易。
- en: To be able to programmatically control transactions, we inject an instance of
    `jakarta.transaction.UserTransaction`, which is then used in the `for` loop inside
    the `saveMultipleNewCustomers()` method to begin and commit transactions in each
    iteration of the loop.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够以编程方式控制事务，我们注入了一个 `jakarta.transaction.UserTransaction` 实例，然后在 `saveMultipleNewCustomers()`
    方法内的 `for` 循环中使用它来开始和提交每个循环迭代的事务。
- en: If we need to roll back a bean-managed transaction, we can do it by simply calling
    the `rollback()` method on the appropriate instance of `jakarta.transaction.UserTransaction`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要回滚一个Bean管理的交易，我们可以通过在适当的 `jakarta.transaction.UserTransaction` 实例上调用 `rollback()`
    方法来实现。
- en: Before moving on, it is worth noting that even though all the examples in this
    section were session beans, the concepts explained apply to message-driven beans
    as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，值得注意的是，尽管本节中的所有示例都是会话Bean，但所解释的概念也适用于消息驱动的Bean。
- en: We will now focus our attention on enterprise bean life cycles.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将关注企业bean的生命周期。
- en: Enterprise bean life cycles
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业bean生命周期
- en: Enterprise beans go through different states throughout their life cycle. Each
    type of enterprise bean has different states. States specific to each type of
    enterprise bean are discussed in the following sections.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 企业bean在其生命周期中会经历不同的状态。每种类型的企业bean都有不同的状态。以下各节将讨论每种类型企业bean特有的状态。
- en: Stateful session bean life cycle
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有状态会话bean生命周期
- en: We can annotate methods in session beans so that they are automatically invoked
    by the Jakarta EE runtime at certain points in the bean’s life cycle. For example,
    we could have a method invoked right after the bean is created or right before
    it is destroyed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在会话bean中注解方法，以便Jakarta EE运行时在bean生命周期的特定点自动调用这些方法。例如，我们可以在bean创建后立即调用一个方法，或者在其销毁前调用。
- en: Before explaining the annotations available to implement life cycle methods,
    a brief explanation of the session bean life cycle is in order. The life cycle
    of a stateful session bean is different from the life cycle of a stateless or
    singleton session bean.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释可用于实现生命周期方法的注解之前，有必要简要说明会话bean的生命周期。有状态会话bean的生命周期与无状态或单例会话bean的生命周期不同。
- en: 'A stateful session bean life cycle contains three states: **Does Not Exist**,
    **Ready**, and **Passive**, as illustrated in *Figure 12**.1*.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态会话bean生命周期包含三个状态：**不存在**、**就绪**和**钝化**，如图*12.1*所示。
- en: '![Figure 12.1 – Stateful session bean life cycle](img/B21231_12_01.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 有状态会话bean生命周期](img/B21231_12_01.jpg)'
- en: Figure 12.1 – Stateful session bean life cycle
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 有状态会话bean生命周期
- en: Before a stateful session bean is deployed, it is in the **Does Not Exist**
    state. Upon successful deployment, the Jakarta EE runtime does any required dependency
    injection on the bean and it goes into the **Ready** state. At this point, the
    bean is ready to have its methods called by a client application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在有状态会话bean部署之前，它处于**不存在**状态。部署成功后，Jakarta EE运行时会对bean进行任何必要的依赖注入，并将其进入**就绪**状态。此时，bean准备好被客户端应用程序调用其方法。
- en: When a stateful session bean is in the **Ready** state, the Jakarta EE runtime
    may decide to passivate it, that is, to move it from main memory to secondary
    storage. When this happens, the bean goes into the **Passive** state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当有状态会话bean处于**就绪**状态时，Jakarta EE运行时可能会决定将其钝化，即将其从主内存移动到二级存储。当这种情况发生时，bean进入**钝化**状态。
- en: If an instance of a stateful session bean hasn’t been accessed for a period
    of time, the Jakarta EE runtime will set the bean to the **Does Not Exist** state.
    How long a bean will stay in memory before being destroyed varies from application
    server to application server and is usually configurable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个有状态会话bean在一段时间内未被访问，Jakarta EE运行时会将该bean设置为**不存在**状态。bean在被销毁前在内存中停留的时间因应用服务器而异，通常是可以配置的。
- en: Any methods in a stateful session bean annotated with `@PostActivate` will be
    invoked just after the stateful session bean has been activated. Similarly, any
    method annotated with `@PrePassivate` will be invoked just before the stateful
    session bean is passivated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在有状态会话bean中注解了`@PostActivate`的方法将在有状态会话bean激活后立即被调用。同样，注解了`@PrePassivate`的方法将在有状态会话bean钝化前被调用。
- en: When a stateful session bean that is in the `@PreDestroy` annotation is executed.
    If the session bean is in the `@PreDestroy` annotation are not executed. Additionally,
    if a client of the stateful session bean executes any method decorated with the
    `@Remove` annotation, any methods decorated with the `@PreDestroy` annotation
    are executed and the bean is marked for garbage collection.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个处于`@PreDestroy`注解状态的有状态会话bean被执行时。如果会话bean处于`@PreDestroy`注解状态而没有被执行。此外，如果有状态会话bean的客户端执行了任何带有`@Remove`注解的方法，任何带有`@PreDestroy`注解的方法将被执行，并且bean将被标记为垃圾回收。
- en: The `@PostActivate`, `@PrePassivate`, and `@Remove` annotations are valid only
    for stateful session beans. The `@PreDestroy` and `@PostConstruct` annotations
    are valid for stateful session beans, stateless session beans, and message-driven
    beans.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostActivate`、`@PrePassivate`和`@Remove`注解仅适用于有状态会话bean。`@PreDestroy`和`@PostConstruct`注解适用于有状态会话bean、无状态会话bean和消息驱动bean。'
- en: Stateless and singleton session bean life cycle
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态和单例会话bean生命周期
- en: A stateless or singleton session bean life cycle contains only the **Does Not
    Exist** and **Ready** states, as illustrated in *Figure 12**.2*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态或单例会话bean的生命周期只包含**不存在**和**就绪**状态，如图*图12.2*所示。
- en: '![Figure 12.2 – Stateless and singleton session beans life cycle](img/B21231_12_02.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 无状态和单例会话bean的生命周期](img/B21231_12_02.jpg)'
- en: Figure 12.2 – Stateless and singleton session beans life cycle
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 无状态和单例会话bean的生命周期
- en: Stateless and singleton session beans are never passivated. A stateless or singleton
    session bean’s methods can be decorated with the `@PostConstruct` and `@PreDestroy`
    annotations. Just like in stateful session beans, any methods decorated with the
    `@PostConstruct` annotation will be executed when the session bean goes from the
    `@PreDestroy` annotation will be executed when a stateless session bean goes from
    the `@PrePassivate` and `@PostActivate` annotations in a stateless session bean
    are simply ignored by the Jakarta EE runtime.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态和单例会话bean永远不会钝化。无状态或单例会话bean的方法可以被`@PostConstruct`和`@PreDestroy`注解装饰。就像在有状态会话bean中一样，任何被`@PostConstruct`注解装饰的方法将在会话bean从`@PreDestroy`注解转换时执行，而在无状态会话bean中，从`@PrePassivate`和`@PostActivate`注解转换时，这些方法将被Jakarta
    EE运行时简单地忽略。
- en: Most Jakarta EE runtimes allow us to configure how long to wait before an idle
    stateless or singleton session bean is destroyed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Jakarta EE运行时允许我们配置在销毁空闲的无状态或单例会话bean之前需要等待多长时间。
- en: Message-driven bean life cycle
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息驱动bean的生命周期
- en: Just like stateless session beans, message-driven beans contain only the **Does
    Not Exist** and **Ready** states, as illustrated in *Figure 12**.3*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像无状态会话bean一样，消息驱动bean只包含**不存在**和**就绪**状态，如图*图12.3*所示。
- en: '![Figure 12.3 – Message-driven bean life cycle](img/B21231_12_03.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 消息驱动bean的生命周期](img/B21231_12_03.jpg)'
- en: Figure 12.3 – Message-driven bean life cycle
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 消息驱动bean的生命周期
- en: A message-driven bean can have methods decorated with the `@PostConstruct` and
    `@PreDestroy` methods. Methods decorated with `@PostConstruct` are executed just
    before the bean goes to the `@PreDestroy` annotation are executed just before
    the bean goes to the **Does Not** **Exist** state.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动bean可以有被`@PostConstruct`和`@PreDestroy`方法装饰的方法。被`@PostConstruct`装饰的方法将在bean执行到`@PreDestroy`注解之前执行，而被`@PreDestroy`注解的方法将在bean进入**不存在**状态之前执行。
- en: Now that we’ve covered enterprise bean life cycles, we’ll focus our attention
    on another enterprise bean feature, namely the enterprise bean timer service.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了企业bean的生命周期，我们将把注意力转向另一个企业bean特性，即企业bean计时器服务。
- en: Enterprise bean timer service
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业bean计时器服务
- en: 'Stateless session beans and message-driven beans can have a method that is
    executed periodically at regular intervals of time. This can be accomplished by
    using the **enterprise bean timer service**. The following example illustrates
    how to take advantage of this feature:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态会话bean和消息驱动bean可以有一个在固定时间间隔定期执行的方法。这可以通过使用**企业bean计时器服务**来实现。以下示例说明了如何利用这个特性：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we inject an implementation of the `jakarta.ejb.TimerService`
    interface by annotating an instance variable of this type with the `@Resource`
    annotation. We can then create a timer by invoking the `createTimer()` method
    of this `TimerService` instance.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过使用`@Resource`注解来注解这个类型的实例变量，从而注入`jakarta.ejb.TimerService`接口的实现。然后我们可以通过调用这个`TimerService`实例的`createTimer()`方法来创建一个计时器。
- en: There are several overloaded versions of the `createTimer()` method. The one
    we chose to use takes an instance of `java.util.Date` as its first parameter.
    This parameter is used to indicate the first time the timer should expire (“go
    off”). In the example, we chose to use a brand-new instance of the `Date` class,
    which in effect makes the timer expire immediately. The second parameter of the
    `createTimer()` method is the amount of time to wait, in milliseconds, before
    the timer expires again. In our example, the timer will expire every five seconds.
    The third parameter of the `createTimer()` method can be an instance of any class
    implementing the `java.io.Serializable` interface. Since a single enterprise bean
    can have several timers executing concurrently, this third parameter is used to
    uniquely identify each of the timers. If we don’t need to identify the timers,
    null can be passed as a value for this parameter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTimer()`方法有几个重载版本。我们选择使用的方法接受一个`java.util.Date`实例作为其第一个参数。此参数用于指示计时器应该首次到期的第一个时间（“触发”）。在示例中，我们选择使用一个新的`Date`类实例，这实际上使得计时器立即到期。`createTimer()`方法的第二个参数是在计时器再次到期之前要等待的时间，以毫秒为单位。在我们的示例中，计时器每五秒到期一次。`createTimer()`方法的第三个参数可以是实现`java.io.Serializable`接口的任何类的实例。由于单个企业Bean可以同时执行多个计时器，因此此第三个参数用于唯一标识每个计时器。如果我们不需要标识计时器，则可以将null作为此参数的值。'
- en: We can stop a timer by invoking its `cancel()` method. There is no way to directly
    obtain a single timer associated with an enterprise bean. What we need to do is
    invoke the `getTimers()` method on the instance of `TimerService` that is linked
    to the enterprise bean. This method will return a collection containing all the
    timers associated with the enterprise bean. We can then obtain a stream from the
    collection, filter it so that it only contains elements with the desired value
    for `getInfo()`, and then invoke `cancel()` on the matching timers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用其`cancel()`方法来停止计时器。没有直接获取与企业Bean相关联的单个计时器的方法。我们需要做的是在`TimerService`实例上调用`getTimers()`方法，该实例与企业Bean相关联。此方法将返回一个包含与企业Bean相关联的所有计时器的集合。然后我们可以从集合中获取一个流，过滤它，使其只包含具有所需`getInfo()`值的元素，然后对匹配的计时器调用`cancel()`。
- en: Finally, any enterprise bean method decorated with the `@Timeout` annotation
    will be executed when a timer expires. Methods decorated with this annotation
    must return `void` and take a single parameter of type `jakarta.ejb.Timer`. In
    our example, the method simply writes a message to the server log.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任何带有`@Timeout`注解的企业Bean方法将在计时器到期时执行。带有此注解的方法必须返回`void`并接受一个类型为`jakarta.ejb.Timer`的单个参数。在我们的示例中，该方法只是将一条消息写入服务器日志。
- en: 'The following class is a standalone client for our example enterprise bean:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类是我们示例企业Bean的独立客户端：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The example simply starts a timer, waits for a couple of seconds, and then
    starts a second timer. It then sleeps for 30 seconds and then stops both timers.
    After deploying the enterprise bean and executing the client, we should see some
    entries like this in the server log:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 示例只是启动一个计时器，等待几秒钟，然后启动第二个计时器。然后它睡眠30秒，然后停止两个计时器。在部署企业Bean并执行客户端后，我们应该在服务器日志中看到一些类似条目的条目：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These entries are created each time one of the timers expires.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条目在计时器每次到期时创建。
- en: In addition to starting a timer programmatically, as seen in the example in
    this section, we can schedule our timers via the `@Schedule` annotation, which
    uses calendar-based expressions for scheduling enterprise bean timers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在本节示例中看到的使用编程方式启动计时器之外，我们还可以通过`@Schedule`注解来安排我们的计时器，该注解使用基于日历的表达式来安排企业Bean计时器。
- en: Calendar-based enterprise bean timer expressions
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于日历的企业Bean计时器表达式
- en: 'The example in the previous section has one disadvantage: the `startTimer()`
    method in the session bean must be invoked from a client in order to start the
    timer. This restriction makes it difficult to have the timer start as soon as
    the bean is deployed.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的示例有一个缺点：会话Bean中的`startTimer()`方法必须从客户端调用才能启动计时器。这种限制使得计时器在Bean部署后立即启动变得困难。
- en: 'Java EE 6 introduced calendar-based enterprise bean timer expressions. Calendar-based
    expressions allow one or more methods in our session beans to be executed at a
    certain date and time. For example, we could configure one of our methods to be
    executed every night at 8:10 p.m., which is exactly what our next example does:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 6引入了基于日历的企业bean定时器表达式。基于日历的表达式允许我们的会话bean中的一个或多个方法在特定的日期和时间执行。例如，我们可以配置我们的一个方法在每晚8:10
    p.m.执行，这正是我们下一个示例所做的事情：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see in this example, we set up the time when the method will be executed
    via the `jakarta.ejb.Schedule` annotation. In this particular example, we set
    up our method to be executed at 8:10 p.m. by setting the `hour` attribute of the
    `@Schedule` annotation to `"20"`, and its minute attribute to `"10"` (the value
    of the hour attribute is 24-hour based; hour 20 is equivalent to 8:00 p.m.).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个示例所示，我们通过`jakarta.ejb.Schedule`注释设置方法执行的时间。在这个特定的例子中，我们通过将`@Schedule`注释的`hour`属性设置为`"20"`，并将其分钟属性设置为`"10"`（小时属性的值是基于24小时制的；小时20相当于下午8:00）来设置方法在晚上8:10
    p.m.执行。
- en: The `@Schedule` annotation has several other attributes, which allows a lot
    of flexibility in specifying when the method should be executed. We could, for
    instance, have a method executed on the third Friday of every month, on the last
    day of the month, and so on and so forth.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Schedule`注释有几个其他属性，这允许我们在指定方法何时执行时具有很大的灵活性。例如，我们可以让一个方法在每月的第三个周五、月底等执行。'
- en: 'The following table lists all the attributes in the `@Schedule` annotation
    that allow us to control when the annotated method will be executed:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了`@Schedule`注释中所有允许我们控制被注释方法执行时间的属性：
- en: '| **Attribute** | **Description** | **Example Values** | **Default Value**
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** | **示例值** | **默认值** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `dayOfMonth` | The day of the month | “3”: The third day of the month“Last”:
    The last day of the month“-2”: Two days before the end of the month“1st Tue”:
    The first Tuesday of the month | “*” |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `dayOfMonth` | 月份中的某一天 | “3”：月份的第三天“Last”：月底“-2”：月底前两天“1st Tue”：月份的第一个周二
    | “*” |'
- en: '| `dayOfWeek` | The day of the week | “3”: Every Wednesday“Thu”: Every Thursday
    | “*” |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `dayOfWeek` | 一周中的某一天 | “3”：每周三“Thu”：每周四 | “*” |'
- en: '| `hour` | Hour of the day (24-hour based) | “14”: 2:00 p.m. | “0” |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `hour` | 一天中的小时（基于24小时制） | “14”：下午2:00 | “0” |'
- en: '| `minute` | Minute of the hour | “10”: 10 minutes after the hour | “0” |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `minute` | 小时中的分钟 | “10”：小时后的10分钟 | “0” |'
- en: '| `month` | Month of the year | “2”: February“March”: March | “*” |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `month` | 年中的月份 | “2”：二月“March”：三月 | “*” |'
- en: '| `second` | Second of the minute | “5”: Five seconds after the minute | “0”
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `second` | 分钟中的秒 | “5”：分钟后的5秒 | “0” |'
- en: '| `timezone` | Time zone ID | “America/New York” | “” |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `timezone` | 时区ID | “America/New York” | “” |'
- en: '| `year` | Four-digit year | “2010” | “*” |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `year` | 四位年份 | “2010” | “*” |'
- en: Table 12.3 – @Schedule annotation attributes
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.3 – @Schedule注释属性
- en: In addition to single values, most attributes accept the asterisk (“*”) as a
    wildcard, meaning that the annotated method will be executed every unit of time
    (every day, hour, etc.).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单个值之外，大多数属性接受星号（“*”）作为通配符，这意味着被注释的方法将在每个时间单位（每天、每小时等）执行。
- en: Additionally, we can specify more than one value by separating the values with
    commas. For example, if we needed a method to be executed every Tuesday and Thursday,
    we could annotate the method as `@``Schedule(dayOfWeek="Tue, Thu")`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过逗号分隔值来指定多个值。例如，如果我们需要一个方法在每周二和周四执行，我们可以将方法注释为`@Schedule(dayOfWeek="Tue,
    Thu")`。
- en: We can also specify a range of values. The first value and last value are separated
    by a dash (-). To execute a method from Monday through Friday, we could use `@Schedule(dayOfWeek="Mon-Fri")`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定一个值的范围。第一个值和最后一个值由破折号（-）分隔。要执行从周一到周五的方法，我们可以使用`@Schedule(dayOfWeek="Mon-Fri")`。
- en: Additionally, we could specify that we need the method to be executed every
    *n* units of time (for example, every day, every 2 hours, or every 10 minutes).
    To do something like this, we could use `@Schedule(hour="*/12")`, which would
    execute the method every 12 hours.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以指定方法需要每*n*个时间单位（例如，每天、每2小时或每10分钟）执行。要执行类似的操作，我们可以使用`@Schedule(hour="*/12")`，这将使方法每12小时执行一次。
- en: As we can see, the `@Schedule` annotation provides a lot of flexibility regarding
    how to specify when we need our methods executed. Plus it provides the advantage
    of not needing a client call to activate the scheduling. Additionally, it also
    has the advantage of using cron-like syntax, therefore developers familiar with
    that Unix tool will feel right at home using this annotation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`@Schedule` 注解在指定何时需要执行我们的方法方面提供了很多灵活性。此外，它还提供了不需要客户端调用即可激活调度的优势。此外，它还具有使用类似于cron的语法的优势，因此熟悉该Unix工具的开发者将感到使用此注解非常得心应手。
- en: The final topic we will cover in this chapter is enterprise bean security.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要涵盖的最后一个主题是企业Bean安全。
- en: Enterprise bean security
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业Bean安全
- en: Enterprise beans allow us to declaratively decide which users can access their
    methods. For example, some methods might only be available to users in certain
    roles. A typical scenario is that only users with the role of administrator can
    add, delete, or modify other users in the system.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 企业Bean允许我们声明性地决定哪些用户可以访问其方法。例如，某些方法可能仅供具有特定角色的用户使用。一个典型的场景是，只有具有管理员角色的用户可以添加、删除或修改系统中的其他用户。
- en: 'The following example is a slightly modified version of the DAO session bean
    we saw earlier in this chapter. In this version, some methods that were previously
    private have been made public. Additionally, the session bean has been modified
    to allow only users in certain roles to access its methods:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是本章前面看到的DAO会话Bean的略微修改版本。在这个版本中，一些之前是私有的方法已被改为公共。此外，会话Bean已被修改，以允许只有具有特定角色的用户访问其方法：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see, we declare what roles have access to the methods by using the
    `@RolesAllowed` annotation. This annotation can take either a single `String`
    or an array of `String` as a parameter. When a single String is used as a parameter
    for this annotation, only users with the role specified by the parameter can access
    the method. If an array of `String` is used as a parameter, users with any of
    the roles specified by the array’s elements can access the method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们通过使用 `@RolesAllowed` 注解来声明哪些角色可以访问方法。此注解可以接受单个 `String` 或 `String` 数组作为参数。当使用单个String作为此注解的参数时，只有参数指定的角色的用户可以访问方法。如果使用
    `String` 数组作为参数，则具有数组元素中指定的任何角色的用户都可以访问方法。
- en: The `@RolesAllowed` annotation can be used at the class level, in which case
    its values apply to all the methods in the enterprise bean. It can also be used
    at the method level, in which case its values apply only to the method the annotation
    is decorating. If, like in our example, both the class and one or more of its
    methods are decorated with the `@RolesAllowed` annotation, the method-level annotation
    takes precedence.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RolesAllowed` 注解可以在类级别使用，在这种情况下，其值适用于企业Bean中的所有方法。它也可以在方法级别使用，在这种情况下，其值仅适用于被注解装饰的方法。如果，像我们的例子一样，类及其一个或多个方法都被
    `@RolesAllowed` 注解装饰，则方法级别的注解具有优先级。'
- en: In our example, only users with the role of “admin” can save or update customer
    data, both admins and users can retrieve customer data.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，只有具有“admin”角色的用户可以保存或更新客户数据，管理员和用户都可以检索客户数据。
- en: Clients invoking secured enterprise beans must be authenticated (refer to [*Chapter
    10*](B21231_10.xhtml#_idTextAnchor135)) and must have the appropriate role.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 调用受保护的企业Bean的客户端必须经过身份验证（请参阅[*第10章*](B21231_10.xhtml#_idTextAnchor135)）并且必须具有适当的角色。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to implement business logic via stateless and
    stateful session beans. Additionally, we covered how to implement message-driven
    beans to consume Jakarta messaging messages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何通过无状态和有状态会话Bean实现业务逻辑。此外，还介绍了如何实现消息驱动Bean以消费Jakarta消息消息。
- en: 'The following topics were covered in this chapter:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: How to take advantage of the transactional nature of enterprise beans to simplify
    implementing the DAO pattern
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用企业Bean的事务性来简化实现DAO模式
- en: Container-managed transactions and how to control transactions by using the
    appropriate annotations
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器管理的交易以及如何使用适当的注解控制交易
- en: Bean-managed transactions, for cases in which container-managed transactions
    are not enough to satisfy our requirements
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于容器管理的交易不足以满足我们要求的情况，使用Bean管理的交易
- en: Life cycles for the different types of Enterprise Java beans, including an explanation
    of how to have enterprise bean methods automatically invoked by the Jakarta EE
    runtime at certain points in the life cycle
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的企业Java Bean的生命周期，包括解释如何使企业Bean方法在生命周期中的特定点自动由Jakarta EE运行时调用
- en: How to have enterprise bean methods invoked periodically by the runtime by taking
    advantage of the timer service
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用定时器服务使企业Bean方法定期被运行时调用
- en: How to make sure enterprise bean methods are only invoked by authorized users
    by annotating enterprise bean classes and/or methods with the appropriate security
    annotations
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过在企业Bean类和/或方法上使用适当的安全注解来确保企业Bean方法仅被授权用户调用
- en: As we have seen in this chapter, Jakarta Enterprise Beans take care of some
    enterprise requirements such as transactions and security, freeing us as application
    developers from having to implement them, and allowing us to focus on implementing
    business logic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，Jakarta Enterprise Beans负责一些企业需求，例如事务和安全，这使我们作为应用程序开发者免于实现它们，并允许我们专注于实现业务逻辑。
