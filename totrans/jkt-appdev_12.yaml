- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta Enterprise Beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jakarta Enterprise Beans** are server-side components that encapsulate the
    business logic of an application. Enterprise beans simplify application development
    by automatically taking care of transaction management and security. There are
    two types of enterprise beans: **session beans**, which perform business logic,
    and **message-driven beans**, which act as a message listener.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Session beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message-driven beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions in enterprise beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise bean life cycles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise bean timer service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise bean security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch12_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch12_src).
  prefs: []
  type: TYPE_NORMAL
- en: Session beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we previously mentioned, session beans typically encapsulate business logic.
    One or two artifacts need to be created in order to create a session bean, including
    the bean itself, and an optional business interface. These artifacts need to be
    annotated adequately to let the Jakarta EE runtime know they are session beans.
  prefs: []
  type: TYPE_NORMAL
- en: A simple session bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example illustrates a very simple session bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Stateless` annotation lets the Jakarta EE runtime know that this class
    is a **stateless session bean**. There are three types of session beans: stateless,
    stateful, and singleton. Before we explain the difference between these types
    of session beans, we need to clarify how an instance of an enterprise bean is
    provided to a client application.'
  prefs: []
  type: TYPE_NORMAL
- en: When a stateless or stateful session bean is deployed, the Jakarta EE container
    creates a series of instances of each session bean. This is what is typically
    referred to as the **enterprise bean pool**. When a client application obtains
    an instance of an enterprise bean, one of the instances in the pool is provided
    to this client application.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between stateful and stateless session beans is that stateful
    session beans maintain a **conversational state** with the client, whereas stateless
    session beans do not. In simple terms, what this means is that when a client application
    obtains an instance of a stateful session bean, we are guaranteed that the value
    of any instance variables in the bean will be consistent across method calls.
    Therefore, it is safe to modify any instance variables on a stateful session bean,
    since they will retain their value for the next method call. The Jakarta EE runtime
    saves conversational state by passivating stateful session beans, and retrieves
    said state when the bean is activated. The conversational state is the reason
    why the life cycle of stateful session beans is a bit more complex than the life
    cycle of stateless session beans or message-driven beans (the enterprise bean
    life cycle is discussed later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The Jakarta EE runtime may provide any instance of an enterprise bean in the
    pool when a client application requests an instance of a stateless session bean.
    Since we are not guaranteed the same instance for every method call, values set
    to any instance variables in a stateless session bean may be “lost” (they are
    not really lost; the modification is in another instance of the enterprise bean
    in the pool).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than being decorated with the `@Stateless` annotation, there is nothing
    special about our example class. Notice that it implements an interface called
    `SimpleSession`. This interface is the bean’s business interface. The `SimpleSession`
    interface is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The only peculiar thing about this interface is that it is decorated with the
    `@Remote` annotation. This annotation indicates that this is a **remote business
    interface**. What this means is that the interface may be in a different JVM than
    the client application invoking it. Remote business interfaces may even be invoked
    across the network.
  prefs: []
  type: TYPE_NORMAL
- en: Business interfaces may also be decorated with the `@Local` interface. This
    annotation indicates that the business interface is a **local business interface**.
    Local business interface implementations must be in the same JVM as the client
    application invoking its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have compiled the session bean and its corresponding business interface,
    we need to place them in a JAR file and deploy them. How to deploy an enterprise
    bean JAR file depends on what application server we are using. Most modern application
    servers have an `autodeploy` directory. We can simply copy our JAR file to this
    directory in most cases. Consult your application server documentation to find
    the exact location of its `autodeploy` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the session bean and its corresponding business interface,
    let’s take a look at a client sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply declares an instance variable of the `com.ensode.jakartaeebook.SimpleSession`
    type, which is the business interface for our session bean. The instance variable
    is annotated with `@EJB`. This annotation lets the Jakarta EE runtime know that
    this variable is a business interface for a session bean. The Jakarta EE runtime
    then injects an implementation of the business interface for the client code to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our client is a standalone application (as opposed to a Jakarta EE artifact
    such as a WAR file or a deployable JAR file), we don’t need to deploy to the Jakarta
    EE runtime. In order for it to be able to access code deployed to the server,
    it must have access to the application server’s client libraries. The procedure
    on how to accomplish this varies from application server to application server.
    When using GlassFish, our client code must be placed in a `JAR` file and executed
    through the `[glassfish installation directory]/glassfish/bin/`. Assuming this
    directory is in the `PATH` environment variable, and assuming we placed our client
    code in a JAR file called `simplesessionbeanclient.jar`, we would execute the
    preceding client code by typing the following command in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this command results in the following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the expected output upon executing the `SessionBeanClient` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are using Maven to build our code. For this example, we have used the Maven
    Assembly Plugin ([http://maven.apache.org/plugins/maven-assembly-plugin/](http://maven.apache.org/plugins/maven-assembly-plugin/))
    to build a client JAR file that includes all dependencies. This frees us from
    having to specify all the dependent JAR files in the `-classpath` command-line
    option of `appclient`. To build this JAR file, simply invoke `mvn assembly:assembly`
    from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of output is simply the return value of the `getMessage()` method
    we implemented in the session bean. The second line of output displays the fully
    qualified class name of the class implementing the business interface. Notice
    that the class name is not the fully qualified name of the session bean we wrote;
    instead, what is actually provided is an implementation of the business interface
    created behind the scenes by the Jakarta EE runtime.
  prefs: []
  type: TYPE_NORMAL
- en: A more realistic example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw a very simple “Hello World” type of example.
    In this section, we will show a more realistic example. Session beans are frequently
    used as **Data Access Objects** (**DAOs**). Sometimes they are used as a wrapper
    for JDBC calls; other times they are used to wrap calls to obtain or modify Jakarta
    Persistence entities. In this section, we will take the latter approach.
  prefs: []
  type: TYPE_NORMAL
- en: The following example illustrates how to implement the DAO design pattern in
    a session bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at the session bean implementing our example business
    interface. As we are about to see, there are some differences between the way
    Jakarta Persistence code is implemented in a session bean versus in a plain old
    Java object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that since we don’t intend for our session bean to
    be invoked remotely, there is no need for a remote business interface in this
    case. Our client applications can simply inject an instance of the session bean
    via the `@``EJB` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, our session bean implements three methods. The `saveCustomer()`
    method saves customer data to the database, the `getCustomer()` method obtains
    data for a customer from the database, and the `deleteCustomer()` method deletes
    customer data from the database. All of these methods take an instance of a Jakarta
    Persistence entity bean or type `Customer`.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, when making Jakarta Persistence calls, we need to start and commit
    transactions via `UserTransaction.begin()` and `UserTransaction.commit()`. The
    reason we need to do this is that Jakarta Persistence calls are required to be
    wrapped in a transaction. If they are not in a transaction, most Jakarta Persistence
    calls will throw `TransactionRequiredException`. Session bean methods are implicitly
    transactional. There is nothing we need to do to make them that way. For this
    reason, we don’t need to manually start and commit transactions when invoking
    Jakarta Persistence calls from a session bean. This default behavior is what is
    known as **container-managed transactions**. Container-managed transactions are
    discussed in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking session beans from web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frequently, Jakarta EE applications consist of web applications acting as clients
    for enterprise beans. In this section, we will develop a Jakarta Faces web application
    with a CDI named bean acting as a client for the DAO session bean we just discussed
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make this application act as an enterprise bean client, we will
    develop a `CustomerController` named bean so that it delegates the logic to save
    a new customer to the database to the `CustomerDaoBean` session bean we developed
    in the previous section, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, all we had to do was to obtain an instance of the `CustomerDaoBean`
    session bean and annotate it with the `@EJB` annotation, then invoke the bean’s
    `saveCustomer()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we injected an instance of the session bean directly into our client
    code. Since the client code is running on the same JVM as the enterprise bean,
    there is no need for remote interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have developed our web application client for our session bean,
    we need to package it in a WAR (web archive) file and deploy it in order to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton session beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another type of session bean is the **singleton session bean**. A single instance
    of each singleton session bean exists in the Jakarta EE runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Singleton session beans are useful to cache database data. Caching frequently
    used data in a singleton session bean increases performance since it greatly minimizes
    trips to the database. The common pattern is to have a method in our bean decorated
    with the `@PostConstruct` annotation. In this method, we retrieve the data we
    want to cache. Then, we provide a setter method for the bean’s clients to call.
    The following example illustrates this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `@Singleton` annotation denotes our class as a singleton session bean. Since
    our bean is a singleton, all of its clients would access the same instance, avoiding
    having duplicate data in memory. Additionally, since it is a singleton, it is
    safe to have an instance variable, since all clients access the same instance
    of the bean.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous method calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it is useful to have some processing done asynchronously, that is,
    invoke a method call and return control immediately to the client, without having
    the client wait for the method to finish.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Asynchronous` annotation can be used to mark a method in a session bean
    as asynchronous. When an enterprise bean client invokes an asynchronous method,
    control immediately goes back to the client, without waiting for the method to
    finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous methods can only return `void` or an implementation of the `java.util.concurrent.Future`
    interface. The following example illustrates both scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When our asynchronous method returns `void`, the only thing we need to do is
    decorate the method with the `@Asynchronous` annotation, and then call it as usual
    from the client code.
  prefs: []
  type: TYPE_NORMAL
- en: If we need a return value, this value needs to be wrapped in an implementation
    of the `jav.util.concurrent.Future` interface. Jakarta EE provides a convenient
    implementation in the form of the `jakarta.ejb.AsyncResult` class. Both the `Future`
    interface and the `AsyncResult` class use generics. We need to specify our return
    type as the type parameter of these artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Future` interface has several methods we can use to cancel the execution
    of an asynchronous method, check to see whether the method has been carried out,
    get the return value of the method, or check to see whether the method has been
    canceled. *Table 12.1* lists these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cancel(boolean mayInterruptIfRunning)` | Cancels method execution. If the
    Boolean parameter is `true`, then this method will attempt to cancel the method
    execution even if it is already running. |'
  prefs: []
  type: TYPE_TB
- en: '| `get()` | Will return the “unwrapped” return value of the method. The return
    value will be of the type parameter of the `Future` interface implementation returned
    by the method. |'
  prefs: []
  type: TYPE_TB
- en: '| `get(long timeout,` `TimeUnit unit)` | Will attempt the “unwrapped” return
    value of the method. The return value will be of the type parameter of the `Future`
    interface implementation returned by the method. This method will block for the
    amount of time specified by the first parameter. The unit of time to wait is determined
    by the second parameter. The `TimeUnit` enum has constants for NANOSECONDS, MILLISECONDS,
    SECONDS, MINUTES, and so on. Refer to its Javadoc documentation for the complete
    list. |'
  prefs: []
  type: TYPE_TB
- en: '| `isCancelled()` | Returns `true` if the method has been canceled, and `false`
    otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `isDone()` | Returns `true` if the method has finished executing, and `false`
    otherwise. |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Canceling asynchronous method execution
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `@Asynchronous` annotation makes it very easy to make asynchronous
    calls without having the overhead of having to set up message queues or topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to invoke asynchronous Jakarta Enterprise
    Bean methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, invoking the asynchronous Jakarta Enterprise Beans method returning
    `void` is no different from invoking a regular method. Things get a bit more interesting
    when invoking a method that returns a value. The asynchronous invocation returns
    an instance of `Future`. We can then check to see whether the invocation is done
    by invoking `isDone()` on the future instance, cancel it if it’s taking too long
    by invoking `cancel()`, or obtain the value from the asynchronous method by invoking
    `get()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed session beans at length, we’ll focus our attention
    on the other type of enterprise bean, message-driven beans.
  prefs: []
  type: TYPE_NORMAL
- en: Message-driven beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of a message-driven bean is to consume messages from a Jakarta
    messaging queue or a Jakarta messaging topic, depending on the messaging domain
    used (refer to [*Chapter 13*](B21231_13.xhtml#_idTextAnchor184)). A message-driven
    bean must be annotated with the `@MessageDriven` annotation. The `mappedName`
    attribute of this annotation must contain the **Java Naming and Directory Interface**
    (**JNDI**) name of the message queue or message topic that the bean will be consuming
    messages from. The following example illustrates a simple message-driven bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `@JMSDestinationDefinition` annotation defines a Jakarta messaging destination
    that the message-driven bean will use to consume messages from. The destination
    can either be a queue or a topic; in our case, we are using a queue, therefore
    `jakarta.jms.Queue` is the value of the annotation’s `interfaceName` attribute.
    The annotation’s name attribute defines a JNDI name that the message-driven bean
    can use to refer to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Message-driven beans must be decorated with the `@MessageDriven` annotation;
    they listen for messages on the queue or topic defined in the `destinationLookup`
    property as defined by an `@ActivationConfigProperty` annotation. Notice that
    in our example, the value of the `destinationLookup` property matches the value
    of the `name` attribute in the corresponding `@JMSDestinationDefinition` annotation.
    The type of Jakarta messaging destination (`jakarta.jmsQueue` or `jakarta.jms.Topic`)
    must be specified in the `destinationType` property of `@MessageDriven`, as illustrated
    in our example.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended, but not required, for message-driven beans to implement the
    `jakarta.jms.MessageListener` interface. However, message-driven beans must have
    a method called `onMessage()` whose signature is identical to the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Client applications never invoke a message-driven bean’s methods directly. Instead,
    they put messages in the message queue or topic, and then the bean consumes those
    messages and acts as appropriate. Our example simply prints the message to the
    Jakarta EE runtime log.
  prefs: []
  type: TYPE_NORMAL
- en: Both session and message-driven beans support transaction management, this is
    discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in enterprise beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier in this chapter, by default, all enterprise bean methods
    are automatically wrapped in a transaction. This default behavior is known as
    **container-managed transactions**, since transactions are managed by the Jakarta
    EE runtime. Application developers may also choose to manage transactions themselves.
    This can be accomplished by using **bean-managed transactions**. Both of these
    approaches are discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Container-managed transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because enterprise bean methods are transactional by default, we run into an
    interesting dilemma when an enterprise bean method is invoked from client code
    that is already in a transaction. How should the Jakarta EE runtime behave? Should
    it suspend the client transaction, execute its method in a new transaction, and
    then resume the client transaction? Should it not create a new transaction and
    execute its method as part of the client transaction? Should it throw an exception?
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, if an enterprise bean method is invoked by client code that is
    already in a transaction, the Jakarta EE runtime will simply execute the enterprise
    bean method as part of the client transaction. If this is not the behavior we
    need, we can change it by annotating the method with the `@TransactionAttribute`
    annotation. This annotation has a `value` attribute that determines how the Jakarta
    EE runtime will behave when the session bean method is invoked within an existing
    transaction and when it is invoked outside any transactions. The value of the
    `value` attribute is typically a constant defined in the `jakarta.ejb.TransactionAttributeType`
    enum. *Table 12.2* lists the possible values for the `@``TransactionAttribute`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **@****TransactionAttribute Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.MANDATORY` | Forces the method to be invoked as
    part of a client transaction. If the method is called outside any transactions,
    it will throw `TransactionRequiredException`. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.NEVER` | The method is never executed in a transaction.
    If the method is invoked as part of a client transaction, it will throw `RemoteException`.
    No transaction is created if the method is not invoked inside a client transaction.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.NOT_SUPPORTED` | If the method is invoked as part
    of a client transaction, the client transaction is suspended. The method is executed
    outside any transaction. After the method completes, the client transaction is
    resumed. No transaction is created if the method is not invoked inside a client
    transaction. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.REQUIRED` | If the method is invoked as part of
    a client transaction, the method is executed as part of said transaction. If the
    method is invoked outside any transaction, a new transaction is created for the
    method. This is the default behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.REQUIRES_NEW` | If the method is invoked as part
    of a client transaction, said transaction is suspended, and a new transaction
    is created for the method. Once the method completes, the client transaction is
    resumed. If the method is called outside any transactions, a new transaction is
    created for the method. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransactionAttributeType.SUPPORTS` | If the method is invoked as part of
    a client transaction, it is executed as part of said transaction. If the method
    is invoked outside a transaction, no new transaction is created for the method.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 12.2 – Container-managed transactions transaction attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the default transaction attribute is reasonable in most cases, it
    is good to be able to override this default if necessary. For example, transactions
    have a performance impact, therefore being able to turn off transactions for a
    method that does not need them is beneficial. For a case like this, we would annotate
    our method as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Other transaction attribute types can be declared by annotating the methods
    with the corresponding constant in the `TransactionAttributeType` enum.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to override the default transaction attribute consistently across
    all methods in a session bean, we can decorate the session bean class with the
    `@TransactionAttribute` annotation. The value of its `value` attribute will be
    applied to every method in the session bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Container-managed transactions are automatically rolled back whenever an exception
    is thrown inside an enterprise bean method. Additionally, we can programmatically
    roll back a container-managed transaction by invoking the `setRollbackOnly()`
    method on an instance of `jakarta.ejb.EJBContext` corresponding to the session
    bean in question. The following example is a new version of the session bean we
    saw earlier in this chapter, modified to roll back transactions if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the DAO session bean, we made the `saveNewCustomer()` `updateCustomer()`
    method public. This method now checks to see whether the `customerId` field is
    null. If it is not null, this implies we are working with a customer that already
    exists in the database. Our method also checks to make sure the object to be persisted
    is not null. If any of the checks result in invalid data, the method simply rolls
    back the transaction by invoking the `setRollBackOnly()` method on the injected
    instance of `EJBContext` and does not update the database.
  prefs: []
  type: TYPE_NORMAL
- en: Bean-managed transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen, container-managed transactions make it ridiculously easy to
    write code that is wrapped in a transaction; after all, there is nothing special
    that we need to do to make them that way. As a matter of fact, some developers
    are sometimes not even aware that they are writing code that will be transactional
    in nature when they develop session beans. Container-managed transactions cover
    most of the typical cases that we will encounter. However, they do have a limitation.
    Each method can be wrapped in a single transaction or with no transaction. With
    container-managed transactions, it is not possible to implement a method that
    generates more than one transaction, but this can be accomplished by using **bean-managed
    transactions**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we implemented a method named `saveMultipleNewCustomers()`.
    This method takes a `List` of customers as its sole parameter. The intention of
    this method is to save as many elements in the `ArrayList` as possible. An exception
    saving one of the entities should not stop the method from attempting to save
    the remaining elements. This behavior is not possible using container-managed
    transactions, since an exception thrown when saving one of the entities would
    roll back the whole transaction. The only way to achieve this behavior is through
    bean-managed transactions.
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the example, we declare that the session bean uses bean-managed
    transactions by decorating the class with the `@TransactionManagement` annotation
    and using `TransactionManagementType.BEAN` as the value for its `value` attribute
    (the only other valid value for this attribute is `TransactionManagementType.CONTAINER`,
    but since this is the default value, it is not necessary to specify it).
  prefs: []
  type: TYPE_NORMAL
- en: To be able to programmatically control transactions, we inject an instance of
    `jakarta.transaction.UserTransaction`, which is then used in the `for` loop inside
    the `saveMultipleNewCustomers()` method to begin and commit transactions in each
    iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to roll back a bean-managed transaction, we can do it by simply calling
    the `rollback()` method on the appropriate instance of `jakarta.transaction.UserTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, it is worth noting that even though all the examples in this
    section were session beans, the concepts explained apply to message-driven beans
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: We will now focus our attention on enterprise bean life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise bean life cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise beans go through different states throughout their life cycle. Each
    type of enterprise bean has different states. States specific to each type of
    enterprise bean are discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful session bean life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can annotate methods in session beans so that they are automatically invoked
    by the Jakarta EE runtime at certain points in the bean’s life cycle. For example,
    we could have a method invoked right after the bean is created or right before
    it is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Before explaining the annotations available to implement life cycle methods,
    a brief explanation of the session bean life cycle is in order. The life cycle
    of a stateful session bean is different from the life cycle of a stateless or
    singleton session bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stateful session bean life cycle contains three states: **Does Not Exist**,
    **Ready**, and **Passive**, as illustrated in *Figure 12**.1*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Stateful session bean life cycle](img/B21231_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Stateful session bean life cycle
  prefs: []
  type: TYPE_NORMAL
- en: Before a stateful session bean is deployed, it is in the **Does Not Exist**
    state. Upon successful deployment, the Jakarta EE runtime does any required dependency
    injection on the bean and it goes into the **Ready** state. At this point, the
    bean is ready to have its methods called by a client application.
  prefs: []
  type: TYPE_NORMAL
- en: When a stateful session bean is in the **Ready** state, the Jakarta EE runtime
    may decide to passivate it, that is, to move it from main memory to secondary
    storage. When this happens, the bean goes into the **Passive** state.
  prefs: []
  type: TYPE_NORMAL
- en: If an instance of a stateful session bean hasn’t been accessed for a period
    of time, the Jakarta EE runtime will set the bean to the **Does Not Exist** state.
    How long a bean will stay in memory before being destroyed varies from application
    server to application server and is usually configurable.
  prefs: []
  type: TYPE_NORMAL
- en: Any methods in a stateful session bean annotated with `@PostActivate` will be
    invoked just after the stateful session bean has been activated. Similarly, any
    method annotated with `@PrePassivate` will be invoked just before the stateful
    session bean is passivated.
  prefs: []
  type: TYPE_NORMAL
- en: When a stateful session bean that is in the `@PreDestroy` annotation is executed.
    If the session bean is in the `@PreDestroy` annotation are not executed. Additionally,
    if a client of the stateful session bean executes any method decorated with the
    `@Remove` annotation, any methods decorated with the `@PreDestroy` annotation
    are executed and the bean is marked for garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: The `@PostActivate`, `@PrePassivate`, and `@Remove` annotations are valid only
    for stateful session beans. The `@PreDestroy` and `@PostConstruct` annotations
    are valid for stateful session beans, stateless session beans, and message-driven
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless and singleton session bean life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stateless or singleton session bean life cycle contains only the **Does Not
    Exist** and **Ready** states, as illustrated in *Figure 12**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Stateless and singleton session beans life cycle](img/B21231_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Stateless and singleton session beans life cycle
  prefs: []
  type: TYPE_NORMAL
- en: Stateless and singleton session beans are never passivated. A stateless or singleton
    session bean’s methods can be decorated with the `@PostConstruct` and `@PreDestroy`
    annotations. Just like in stateful session beans, any methods decorated with the
    `@PostConstruct` annotation will be executed when the session bean goes from the
    `@PreDestroy` annotation will be executed when a stateless session bean goes from
    the `@PrePassivate` and `@PostActivate` annotations in a stateless session bean
    are simply ignored by the Jakarta EE runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Most Jakarta EE runtimes allow us to configure how long to wait before an idle
    stateless or singleton session bean is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Message-driven bean life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like stateless session beans, message-driven beans contain only the **Does
    Not Exist** and **Ready** states, as illustrated in *Figure 12**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Message-driven bean life cycle](img/B21231_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Message-driven bean life cycle
  prefs: []
  type: TYPE_NORMAL
- en: A message-driven bean can have methods decorated with the `@PostConstruct` and
    `@PreDestroy` methods. Methods decorated with `@PostConstruct` are executed just
    before the bean goes to the `@PreDestroy` annotation are executed just before
    the bean goes to the **Does Not** **Exist** state.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered enterprise bean life cycles, we’ll focus our attention
    on another enterprise bean feature, namely the enterprise bean timer service.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise bean timer service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stateless session beans and message-driven beans can have a method that is
    executed periodically at regular intervals of time. This can be accomplished by
    using the **enterprise bean timer service**. The following example illustrates
    how to take advantage of this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we inject an implementation of the `jakarta.ejb.TimerService`
    interface by annotating an instance variable of this type with the `@Resource`
    annotation. We can then create a timer by invoking the `createTimer()` method
    of this `TimerService` instance.
  prefs: []
  type: TYPE_NORMAL
- en: There are several overloaded versions of the `createTimer()` method. The one
    we chose to use takes an instance of `java.util.Date` as its first parameter.
    This parameter is used to indicate the first time the timer should expire (“go
    off”). In the example, we chose to use a brand-new instance of the `Date` class,
    which in effect makes the timer expire immediately. The second parameter of the
    `createTimer()` method is the amount of time to wait, in milliseconds, before
    the timer expires again. In our example, the timer will expire every five seconds.
    The third parameter of the `createTimer()` method can be an instance of any class
    implementing the `java.io.Serializable` interface. Since a single enterprise bean
    can have several timers executing concurrently, this third parameter is used to
    uniquely identify each of the timers. If we don’t need to identify the timers,
    null can be passed as a value for this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We can stop a timer by invoking its `cancel()` method. There is no way to directly
    obtain a single timer associated with an enterprise bean. What we need to do is
    invoke the `getTimers()` method on the instance of `TimerService` that is linked
    to the enterprise bean. This method will return a collection containing all the
    timers associated with the enterprise bean. We can then obtain a stream from the
    collection, filter it so that it only contains elements with the desired value
    for `getInfo()`, and then invoke `cancel()` on the matching timers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, any enterprise bean method decorated with the `@Timeout` annotation
    will be executed when a timer expires. Methods decorated with this annotation
    must return `void` and take a single parameter of type `jakarta.ejb.Timer`. In
    our example, the method simply writes a message to the server log.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class is a standalone client for our example enterprise bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The example simply starts a timer, waits for a couple of seconds, and then
    starts a second timer. It then sleeps for 30 seconds and then stops both timers.
    After deploying the enterprise bean and executing the client, we should see some
    entries like this in the server log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These entries are created each time one of the timers expires.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to starting a timer programmatically, as seen in the example in
    this section, we can schedule our timers via the `@Schedule` annotation, which
    uses calendar-based expressions for scheduling enterprise bean timers.
  prefs: []
  type: TYPE_NORMAL
- en: Calendar-based enterprise bean timer expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example in the previous section has one disadvantage: the `startTimer()`
    method in the session bean must be invoked from a client in order to start the
    timer. This restriction makes it difficult to have the timer start as soon as
    the bean is deployed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java EE 6 introduced calendar-based enterprise bean timer expressions. Calendar-based
    expressions allow one or more methods in our session beans to be executed at a
    certain date and time. For example, we could configure one of our methods to be
    executed every night at 8:10 p.m., which is exactly what our next example does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in this example, we set up the time when the method will be executed
    via the `jakarta.ejb.Schedule` annotation. In this particular example, we set
    up our method to be executed at 8:10 p.m. by setting the `hour` attribute of the
    `@Schedule` annotation to `"20"`, and its minute attribute to `"10"` (the value
    of the hour attribute is 24-hour based; hour 20 is equivalent to 8:00 p.m.).
  prefs: []
  type: TYPE_NORMAL
- en: The `@Schedule` annotation has several other attributes, which allows a lot
    of flexibility in specifying when the method should be executed. We could, for
    instance, have a method executed on the third Friday of every month, on the last
    day of the month, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists all the attributes in the `@Schedule` annotation
    that allow us to control when the annotated method will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** | **Example Values** | **Default Value**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dayOfMonth` | The day of the month | “3”: The third day of the month“Last”:
    The last day of the month“-2”: Two days before the end of the month“1st Tue”:
    The first Tuesday of the month | “*” |'
  prefs: []
  type: TYPE_TB
- en: '| `dayOfWeek` | The day of the week | “3”: Every Wednesday“Thu”: Every Thursday
    | “*” |'
  prefs: []
  type: TYPE_TB
- en: '| `hour` | Hour of the day (24-hour based) | “14”: 2:00 p.m. | “0” |'
  prefs: []
  type: TYPE_TB
- en: '| `minute` | Minute of the hour | “10”: 10 minutes after the hour | “0” |'
  prefs: []
  type: TYPE_TB
- en: '| `month` | Month of the year | “2”: February“March”: March | “*” |'
  prefs: []
  type: TYPE_TB
- en: '| `second` | Second of the minute | “5”: Five seconds after the minute | “0”
    |'
  prefs: []
  type: TYPE_TB
- en: '| `timezone` | Time zone ID | “America/New York” | “” |'
  prefs: []
  type: TYPE_TB
- en: '| `year` | Four-digit year | “2010” | “*” |'
  prefs: []
  type: TYPE_TB
- en: Table 12.3 – @Schedule annotation attributes
  prefs: []
  type: TYPE_NORMAL
- en: In addition to single values, most attributes accept the asterisk (“*”) as a
    wildcard, meaning that the annotated method will be executed every unit of time
    (every day, hour, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can specify more than one value by separating the values with
    commas. For example, if we needed a method to be executed every Tuesday and Thursday,
    we could annotate the method as `@``Schedule(dayOfWeek="Tue, Thu")`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify a range of values. The first value and last value are separated
    by a dash (-). To execute a method from Monday through Friday, we could use `@Schedule(dayOfWeek="Mon-Fri")`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we could specify that we need the method to be executed every
    *n* units of time (for example, every day, every 2 hours, or every 10 minutes).
    To do something like this, we could use `@Schedule(hour="*/12")`, which would
    execute the method every 12 hours.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `@Schedule` annotation provides a lot of flexibility regarding
    how to specify when we need our methods executed. Plus it provides the advantage
    of not needing a client call to activate the scheduling. Additionally, it also
    has the advantage of using cron-like syntax, therefore developers familiar with
    that Unix tool will feel right at home using this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The final topic we will cover in this chapter is enterprise bean security.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise bean security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise beans allow us to declaratively decide which users can access their
    methods. For example, some methods might only be available to users in certain
    roles. A typical scenario is that only users with the role of administrator can
    add, delete, or modify other users in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a slightly modified version of the DAO session bean
    we saw earlier in this chapter. In this version, some methods that were previously
    private have been made public. Additionally, the session bean has been modified
    to allow only users in certain roles to access its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we declare what roles have access to the methods by using the
    `@RolesAllowed` annotation. This annotation can take either a single `String`
    or an array of `String` as a parameter. When a single String is used as a parameter
    for this annotation, only users with the role specified by the parameter can access
    the method. If an array of `String` is used as a parameter, users with any of
    the roles specified by the array’s elements can access the method.
  prefs: []
  type: TYPE_NORMAL
- en: The `@RolesAllowed` annotation can be used at the class level, in which case
    its values apply to all the methods in the enterprise bean. It can also be used
    at the method level, in which case its values apply only to the method the annotation
    is decorating. If, like in our example, both the class and one or more of its
    methods are decorated with the `@RolesAllowed` annotation, the method-level annotation
    takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, only users with the role of “admin” can save or update customer
    data, both admins and users can retrieve customer data.
  prefs: []
  type: TYPE_NORMAL
- en: Clients invoking secured enterprise beans must be authenticated (refer to [*Chapter
    10*](B21231_10.xhtml#_idTextAnchor135)) and must have the appropriate role.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to implement business logic via stateless and
    stateful session beans. Additionally, we covered how to implement message-driven
    beans to consume Jakarta messaging messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics were covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to take advantage of the transactional nature of enterprise beans to simplify
    implementing the DAO pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container-managed transactions and how to control transactions by using the
    appropriate annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean-managed transactions, for cases in which container-managed transactions
    are not enough to satisfy our requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Life cycles for the different types of Enterprise Java beans, including an explanation
    of how to have enterprise bean methods automatically invoked by the Jakarta EE
    runtime at certain points in the life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to have enterprise bean methods invoked periodically by the runtime by taking
    advantage of the timer service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make sure enterprise bean methods are only invoked by authorized users
    by annotating enterprise bean classes and/or methods with the appropriate security
    annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have seen in this chapter, Jakarta Enterprise Beans take care of some
    enterprise requirements such as transactions and security, freeing us as application
    developers from having to implement them, and allowing us to focus on implementing
    business logic.
  prefs: []
  type: TYPE_NORMAL
