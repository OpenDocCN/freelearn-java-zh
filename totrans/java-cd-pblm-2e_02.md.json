["```java\nint decimalA = \"A\".charAt(0); // 65\nString binaryA = Integer.toBinaryString(decimalA); // 1000001 \n```", "```java\nchar[] chars = \"Hello World\".toCharArray();\nfor(char ch : chars) {\n  System.out.print(\"0\" + Integer.toBinaryString(ch) + \" \");\n} \n```", "```java\nint e = \"ê\".charAt(0);                // 234\nString hexe = Integer.toHexString(e); // ea \n```", "```java\nString binarye = Integer.toBinaryString(e); // 11101010 = 234 \n```", "```java\nint cp1 = \"A\".charAt(0);                   // 65\nString hcp1 = Integer.toHexString(cp1);    // 41\nString bcp1 = Integer.toBinaryString(cp1); // 1000001\nint cp2 = \"![](img/B19665_02_010.png)\".charAt(0);                  // 26263\nString hcp2 = Integer.toHexString(cp2);    // 6697\nString bcp2 = Integer.toBinaryString(cp2); // 1101100000111101 \n```", "```java\npublic static String strToBinary(String str) {\n   String binary = str.chars()\n     .mapToObj(Integer::toBinaryString)\n     .map(t -> \"0\" +  t)\n     .collect(Collectors.joining(\" \"));\n   return binary;\n} \n```", "```java\nString uc = Integer.toBinaryString(c2); // 11111011000001101 \n```", "```java\npublic static String codePointToBinary(String str) {\n   String binary = str.codePoints()\n      .mapToObj(Integer::toBinaryString)\n      .collect(Collectors.joining(\" \"));\n   return binary;\n} \n```", "```java\nString str1 = String.valueOf(Character.toChars(65)); // A\nString str2 = String.valueOf(Character.toChars(128525)); \n```", "```java\npublic static String stringToBinaryEncoding(\n      String str, String encoding) {\n   final Charset charset = Charset.forName(encoding);\n   final byte[] strBytes = str.getBytes(charset);\n   final StringBuilder strBinary = new StringBuilder();\n   for (byte strByte : strBytes) {\n      for (int i = 0; i < 8; i++) {\n        strBinary.append((strByte & 128) == 0 ? 0 : 1);\n        strByte <<= 1;\n      }\n      strBinary.append(\" \");\n   }\n   return strBinary.toString().trim();\n} \n```", "```java\n// 00000000 00000000 00000000 01000001\nString r = Charsets.stringToBinaryEncoding(\"A\", \"UTF-32\");\n// 10010111 01100110\nString r = Charsets.stringToBinaryEncoding(\"![](img/B19665_02_010.png)\", \n              StandardCharsets.UTF_16LE.name()); \n```", "```java\n// the default charset is computed from native.encoding\njava -Dfile-encoding = COMPAT \n// the default charset is windows-1252\njava -Dfile-encoding = windows-1252 \n```", "```java\ntry ( BufferedReader br = new BufferedReader(new FileReader(\n   chineseUtf8File.toFile(), StandardCharsets.UTF_8))) {\n   ...\n} \n```", "```java\ntry ( BufferedReader br = new BufferedReader(\n   new FileReader(chineseUtf8File.toFile()))) {\n   ...\n} \n```", "```java\n-Dstderr.encoding=utf8 -Dstdout.encoding=utf8 \n```", "```java\n_JAVA_OPTIONS=\"-Dstdout.encoding=utf8 -Dstderr.encoding=utf8\" \n```", "```java\npublic static boolean isPressureSupported(\n      int avgPressure, int unitsOfPressure, int maxPressure) {\n  if(avgPresure < 0 || unitsOfPressure < 0 || maxPressure < 0\n    || (avgPresure + unitsOfPressure) > maxPressure) {\n    throw new IndexOutOfBoundsException(\n           \"One or more parameters are out of bounds\");\n  }\n  // the secret algorithm\n  return (avgPressure + unitsOfPressure) <\n    (maxPressure - maxPressure/4);\n} \n```", "```java\npublic static boolean isPressureSupported(\n      int avgPressure, int unitsOfPressure, int maxPressure) {\n  Objects.checkFromIndexSize(\n    avgPressure, unitsOfPressure, maxPressure);\n  // the secret algorithm\n  return (avgPressure + unitsOfPressure) <\n   (maxPressure - maxPressure/4);\n} \n```", "```java\nobject.getClass().getName() + \"@\" \n  + Integer.toHexString(System.identityHashCode(object)) \n```", "```java\npublic class MyPoint {\n  private final int x;\n  private final int y;\n  private final int z;\n  ...\n  @Override\n  public String toString() {\n    return \"MyPoint{\" + \"x=\" + x + \", y=\" + y \n                      + \", z=\" + z + '}';\n  }  \n} \n```", "```java\nMyPoint p = new MyPoint(1, 2, 3);\n// modern.challenge.MyPoint@76ed5528\nObjects.toIdentityString(p); \n```", "```java\n@Override\npublic int hashCode() {\n  int hash = 7;\n  hash = 23 * hash + this.x;\n  hash = 23 * hash + this.y;\n  hash = 23 * hash + this.z;\n  return hash;\n} \n```", "```java\npublic class HelloWorld { \n  public static void main(String[] args) { \n    System.out.println(\"Hello World!\");\n  }\n} \n```", "```java\npublic class HelloWorld { \n  void main() { \n    System.out.println(\"Hello World!\");\n  }\n} \n```", "```java\nvoid main() { \n  System.out.println(\"Hello World!\");\n} \n```", "```java\n/**\n * A telemeter with laser ranging from 0 to 60 ft including   \n * calculation of surfaces and volumes with high-precision\n *\n * <pre>{@code\n *     Telemeter.Calibrate.at(0.00001);\n *     Telemeter telemeter = new Telemeter(0.15, 2, \"IP54\");\n * }</pre>\n */\npublic class Telemeter {\n   ... \n```", "```java\n@snippet can be discovered and validated by third-party tools (not by the javadoc tool itself). \n@snippet as follows:\n```", "```java\n/**\n * A telemeter with laser ranging from 0 to 60 ft including   \n * calculation of surfaces and volumes with high-precision\n *\n * {@snippet :\n *     Telemeter.Calibrate.at(0.00001);\n *     Telemeter telemeter = new Telemeter(0.15, 2, \"IP54\");\n * }\n */\npublic class Telemeter {\n   ... \n```", "```java\nname=value pairs. For instance, we can provide a tip about the programming language of our snippet via the lang attribute. The value of the attribute is available to external tools and is present in the generated HTML. Here are two examples:\n```", "```java\n * {@snippet lang=\"java\" :\n *     Telemeter.Calibrate.at(0.00001);\n *     Telemeter telemeter = new Telemeter(0.15, 2, \"IP54\");\n * } \n```", "```java\n<code class=\"language-java\"> … </code> \n```", "```java\n * {@snippet lang=\"properties\" :\n *   telemeter.precision.default=42\n *   telemeter.clazz.default=2\n * } \n```", "```java\n<code class=\"language-properties\"></code> \n```", "```java\nmarkup comments. A markup comment occurs at the end of the line and it contains one or more *markup tags* of the form @name args, where args are commonly *name=value* pairs. Common markup comments include highlighting, linking, and content (text) modifications.\n```", "```java\nCalibrate that navigates in documentation to the description of the Calibrate.at() method:\n```", "```java\nsnippet-files and it can contain external snippets as Java sources, plain text files, or properties files. In the following figure, we have a single external file named MainSnippet.txt:\n```", "```java\n not a Java file, then it can be loaded via {@snippet file …} as follows:\n```", "```java\n{@snippet file = MainSnippet.txt}\n{@snippet file = \"MainSnippet.txt\"}\n{@snippet file = 'MainSnippet.txt'} \n```", "```java\njavadoc. Of course, you can pass it via the command line, via your IDE, or via maven-javadoc-plugin, as follows:\n```", "```java\n<additionalJOption>\n  --snippet-path C:\\...\\src\\snippet-src\n</additionalJOption> \n```", "```java\n{@snippet class = DistanceSnippet}\n{@snippet class = \"DistanceSnippet\"}\n{@snippet class = 'DistanceSnippet'} \n```", "```java\n{@snippet class = DistanceSnippet.java} \n```", "```java\nIllegal package name: “foo.buzz.snippet-files”. If you find yourself in this scenario, then simply use another folder name and location for the documentation external snippets written in Java sources.\n```", "```java\n// This is an example used in the documentation\n// @start region=only-code \n   Telemeter.Calibrate.at(0.00001, \"HIGH\");  \n// @end region=only-code \n```", "```java\n{@snippet file = AtSnippet.txt region=only-code} \n```", "```java\n# @start region=dist\nsc=[0,0]\nec=[0,0]\ninterpolation=false\n# @end region=dist\n# @start region=at\neps=0.1\ntype=null\n# @end region=at \n```", "```java\n// invoke Printable.print(String)\nPrintable pproxy = (Printable) Proxy.newProxyInstance(\n  Printable.class.getClassLoader(),\n  new Class<?>[]{Printable.class}, (o, m, p) -> {\n    if (m.isDefault()) {\n      Constructor<Lookup> cntr = Lookup.class\n        .getDeclaredConstructor(Class.class);\n      cntr.setAccessible(true);\n      return cntr.newInstance(Printable.class)\n                 .in(Printable.class)\n                 .unreflectSpecial(m, Printable.class)\n                 .bindTo(o)\n                 .invokeWithArguments(p);\n      }\n      return null;\n  });\n// invoke Printable.print()\npproxy.print(\"Chapter 2\"); \n```", "```java\n// invoke Draft.write(String) and Writable.write(String)\nWritable dpproxy = (Writable) Proxy.newProxyInstance(\n Writable.class.getClassLoader(),\n  new Class<?>[]{Writable.class, Draft.class}, (o, m, p) -> {\n   if (m.isDefault() && m.getName().equals(\"write\")) {\n    Constructor<Lookup> cntr = Lookup.class\n     .getDeclaredConstructor(Class.class);\n    cntr.setAccessible(true); \n    cntr.newInstance(Draft.class)\n        .in(Draft.class)\n        .findSpecial(Draft.class, \"write\",\n           MethodType.methodType(void.class, String.class), \n           Draft.class)\n        .bindTo(o)\n        .invokeWithArguments(p);\n    return cntr.newInstance(Writable.class)\n        .in(Writable.class)\n        .findSpecial(Writable.class, \"write\",\n           MethodType.methodType(void.class, String.class), \n           Writable.class)\n        .bindTo(o)\n        .invokeWithArguments(p);\n    }\n    return null;\n  });\n// invoke Writable.write(String)\ndpproxy.write(\"Chapter 1\"); \n```", "```java\n// invoke Printable.print(String doc)\nPrintable pproxy = (Printable) Proxy.newProxyInstance(\n    Printable.class.getClassLoader(),\n    new Class<?>[]{Printable.class}, (o, m, p) -> {\n      if (m.isDefault()) {\n       return MethodHandles.lookup()\n         .findSpecial(Printable.class, \"print\",  \n           MethodType.methodType(void.class, String.class), \n           Printable.class)\n         .bindTo(o)\n         .invokeWithArguments(p);\n      }\n      return null;\n  });\n// invoke Printable.print()\npproxy.print(\"Chapter 2\"); \n```", "```java\n// invoke Printable.print(String doc)\nPrintable pproxy = (Printable) Proxy.newProxyInstance(\n  Printable.class.getClassLoader(),\n    new Class<?>[]{Printable.class}, (o, m, p) -> {\n      if (m.isDefault()) {\n        return InvocationHandler.invokeDefault(o, m, p);\n      }\n      return null;\n  });\n// invoke Printable.print()\npproxy.print(\"Chapter 2\"); \n```", "```java\n// invoke Draft.write(String) and Writable.write(String)\nWritable dpproxy = (Writable) Proxy.newProxyInstance(\n Writable.class.getClassLoader(),\n  new Class<?>[]{Writable.class, Draft.class}, (o, m, p) -> {\n   if (m.isDefault() && m.getName().equals(\"write\")) {\n    Method writeInDraft = Draft.class.getMethod(\n     m.getName(), m.getParameterTypes());\n    InvocationHandler.invokeDefault(o, writeInDraft, p);\n    return InvocationHandler.invokeDefault(o, m, p);\n   }\n   return null;\n });\n// invoke Writable.write(String)\ndpproxy.write(\"Chapter 1\"); \n```", "```java\npublic static String byteToHexString(byte v) {\n  int higher = (v >> 4) & 0xF;\n  int lower = v & 0xF;\n  String result = String.valueOf(\n    new char[]{\n      Character.forDigit(higher, 16),\n      Character.forDigit(lower, 16)}\n    );\n  return result;\n} \n```", "```java\npublic static String byteToHexString(byte v) {\n  return Integer.toHexString(v & 0xFF);\n} \n```", "```java\npublic static byte hexToByte(String s) {\n  int d1 = Character.digit(s.charAt(0), 16);\n  int d2 = Character.digit(s.charAt(1), 16);\n  return (byte) ((d1 << 4) + d2);\n} \n```", "```java\npublic static String byteToHexString(byte v) {\n  HexFormat hex = HexFormat.of();\n  return hex.toHexDigits(v);\n} \n```", "```java\npublic static byte hexToByte(String s) {\n  HexFormat hex = HexFormat.of();\n  return hex.parseHex(s)[0];\n} \n```", "```java\npublic class A {\n  {\n    System.out.println(\"Non-static initializer ...\");\n  }\n  static {\n    System.out.println(\"Static initializer ...\");\n  }\n} \n```", "```java\nA a1 = new A();\nA a2 = new A();\nA a3 = new A(); \n```", "```java\nStatic initializer ...\nNon-static initializer ...\nNon-static initializer ...\nNon-static initializer ... \n```", "```java\npublic class A {\n    private static class B { ... }\n} \n```", "```java\npublic class Connection { // singleton\n  private Connection() {\n  }\n  private static class LazyConnection { // holder\n    static final Connection INSTANCE = new Connection();\n    static {\n      System.out.println(\"Initializing connection ...\" \n        + INSTANCE);\n    }\n  }\n  public static Connection get() {\n    return LazyConnection.INSTANCE;\n  }\n} \n```", "```java\npublic class A {\n  public class B {\n    {\n      System.out.println(\"Non-static initializer ...\");\n    }\n    static {\n      System.out.println(\"Static initializer ...\");\n    }\n  }\n} \n```", "```java\npublic class Connection { // singleton\n  private Connection() {\n  }\n  public static Connection get() {\n    class LazyConnection { // holder\n      static final Connection INSTANCE = new Connection();\n      static {\n        System.out.println(\"Initializing connection ...\" \n          + INSTANCE);\n      }\n    }\n    return LazyConnection.INSTANCE;\n  }\n} \n```", "```java\nbutton.addActionListener(new ActionListener() {\n  public void actionPerformed(ActionEvent e) {\n    ...\n  }\n} \n```", "```java\npublic interface Printer {\n    public void print(String quality);\n} \n```", "```java\npublic static void printerTest() {\n  Printer printer = new Printer() {\n  @Override\n  public void print(String quality) {\n    if (\"best\".equals(quality)) {\n      Tools tools = new Tools();\n      tools.enableLaserGuidance();\n      tools.setHighResolution();\n    }\n    System.out.println(\"Printing photo-test ...\");\n  }\nclass Tools {\n    private void enableLaserGuidance() {\n      System.out.println(\"Adding laser guidance ...\");\n    }\n    private void setHighResolution() {\n      System.out.println(\"Set high resolution ...\");\n    }\n  }\n}; \n```", "```java\nPrinter printer = new Printer() {\n  @Override\n  public void print(String quality) {\n    class Tools {\n      private void enableLaserGuidance() {\n        System.out.println(\"Adding laser guidance ...\");\n      }\n      private void setHighResolution() {\n        System.out.println(\"Set high resolution ...\");\n      }\n    }\n    if (\"best\".equals(quality)) {\n      Tools tools = new Tools();\n      tools.enableLaserGuidance();\n      tools.setHighResolution();\n    }\n    System.out.println(\"Printing photo-test ...\");\n  }\n}; \n```", "```java\nPrinter printer = new Printer() {\n  @Override\n  public void print(String quality) {\n    if (\"best\".equals(quality)) {\n      enableLaserGuidance();\n      setHighResolution();\n    }\n    System.out.println(\"Printing your photos ...\");\n  }\n  private static void enableLaserGuidance() {\n    System.out.println(\"Adding laser guidance ...\");\n  }\n  private static void setHighResolution() {\n    System.out.println(\"Set high resolution ...\");\n  }\n}; \n```", "```java\nPrinter printer = new Printer() {\n  @Override\n  public void print(String quality) {\n    if (\"best\".equals(quality)) {\n      Tools.enableLaserGuidance();\n      Tools.setHighResolution();\n    }\n    System.out.println(\"Printing photo-test ...\");\n  }\n  private final static class Tools {\n    private static void enableLaserGuidance() {\n      System.out.println(\"Adding laser guidance ...\");\n    }\n    private static void setHighResolution() {\n      System.out.println(\"Set high resolution ...\");\n    }\n  }\n}; \n```", "```java\npublic class ImmutableStack<E> implements Stack<E> {\n  private final E head;\n  private final Stack<E> tail;\n  ... \n```", "```java\npublic class ImmutableStack<Object> implements Stack<Object> {\n  private final Object head;\n  private final Stack<Object> tail;\n  ... \n```", "```java\npublic static <T, R extends T> List<T> listOf(T t, R r) {\n  List<T> list = new ArrayList<>();\n  list.add(t);\n  list.add(r);\n  return list;\n}\n// use this method\nList<Object> list = listOf(1, \"one\"); \n```", "```java\npublic class Puzzle<E> {\n  public E piece;\n  public Puzzle(E piece) {\n    this.piece = piece;\n  }\n  public void setPiece(E piece) { \n    this.piece = piece;\n  }\n} \n```", "```java\npublic class FunPuzzle extends Puzzle<String> {\n  public FunPuzzle(String piece) {\n    super(piece);\n  }\n  @Override\n  public void setPiece(String piece) { \n    super.setPiece(piece);\n  }\n} \n```", "```java\n/* Decompiler 8ms, total 3470ms, lines 18 */\npackage modern.challenge;\npublic class FunPuzzle extends Puzzle<String> {\n   public FunPuzzle(String piece) {\n      super(piece);\n   }\n   public void setPiece(String piece) {\n      super.setPiece(piece);\n   }\n**// $FF: synthetic method**\n**// $FF: bridge method**\n**public****void****setPiece****(Object var1)** **{**\n**this****.setPiece((String)var1);**\n **}**\n} \n```", "```java\npublic static <T> void listOf(List<T> list, T... ts) {\n  list.addAll(Arrays.asList(ts));    \n} \n```", "```java\n@SafeVarargs\npublic static <T> void listOf(List<T> list, T... ts) {...} \n```", "```java\npublic static void main(String[] args) {\n  List<Integer> ints = new ArrayList<>();\n  Main.listOf(ints, 1, 2, 3);\n  Main.listsOfYeak(ints);\n}\npublic static void listsOfYeak(List<Integer>... lists) {\n  Object[] listsAsArray = lists;     \n  listsAsArray[0] = Arrays.asList(4, 5, 6); \n  Integer someInt = lists[0].get(0);   \n  listsAsArray[0] = Arrays.asList(\"a\", \"b\", \"c\"); \n  Integer someIntYeak = lists[0].get(0); // ClassCastException\n} \n```", "```java\n// unchecked generic array creation for varargs parameter \n// of type java.util.List<java.lang.Integer>[]\nMain.listsOfYeak(ints);\n// Possible heap pollution from parameterized vararg\n// type java.util.List<java.lang.Integer>\npublic static void listsOfYeak(List<Integer>... lists) { ... } \n```", "```java\nstatic void kaboom(byte b) { wordie += \"a\";}   \nstatic void kaboom(short s) { wordie += \"b\";}   \nkaboom(1); \n```", "```java\nstatic void kaboom(byte b) { wordie += \"a\";}   \nstatic void kaboom(short s) { wordie += \"b\";}  \nstatic void kaboom(long l) { wordie += \"d\";}   \nstatic void kaboom(Integer i) { wordie += \"i\";}   \nkaboom(1); \n```", "```java\nstatic void kaboom(Integer i) { wordie += \"i\";} \nstatic void kaboom(Long l) { wordie += \"j\";} \nkaboom(1); \n```", "```java\nstatic void kaboom(Object... ov) { wordie += \"o\";}   \nstatic void kaboom(Number n) { wordie += \"p\";}   \nstatic void kaboom(Number... nv) { wordie += \"q\";}  \nkaboom(1); \n```", "```java\nstatic void kaboom(Object... ov) { wordie += \"o\";}   \nstatic void kaboom(File... fv) { wordie += \"s\";}   \nkaboom(1); \n```", "```java\nstatic void kaboom(Number... nv) { wordie += \"q\";}   \nstatic void kaboom(File... fv) { wordie += \"s\";}   \nkaboom(); \n```", "```java\nvoid print(List<A> listOfA) {\n  System.out.println(\"Printing A: \" + listOfA);\n}\nvoid print(List<B> listofB) {\n  System.out.println(\"Printing B: \" + listofB);\n} \n```", "```java\nvoid print(List<A> listOfA, Void... v) {\n  System.out.println(\"Printing A: \" + listOfA);\n} \n```", "```java\nnew Main().print(List.of(new A(), new A()));\nnew Main().print(List.of(new B(), new B())); \n```", "```java\npublic class House {\n  private String location;\n  private float price;\n  ...\n} \n```", "```java\nmodule P48_XlintDefaultConstructor {\n  exports modern.challenge;\n} \n```", "```java\npublic class Truck {\n  public void revision1(Truck this) {\n    Truck thisTruck = this;\n    System.out.println(\"Truck: \" + thisTruck);\n  }\n  public void revision2() {\n    Truck thisTruck = this;\n    System.out.println(\"Truck: \" + thisTruck);\n  }\n} \n```", "```java\npublic class PaymentService {\n  class InvoiceCalculation {\n    final PaymentService paymentService;\n    InvoiceCalculation(PaymentService PaymentService.this) {\n      paymentService = PaymentService.this;\n    }\n  }\n} \n```", "```java\n@Target(ElementType.TYPE_USE)\npublic @interface ValidAddress {}\npublic String getAddress(@ValidAddress Person this) { ... } \n```", "```java\npublic class Parcel {\n  public void order(@New Parcel this) {...}\n  public void shipping(@Ordered Parcel this) {...}\n  public void deliver(@Shipped Parcel this) {...}\n  public void cashit(@Delivered Parcel this) {...}\n  public void done(@Cashed Parcel this) {...}\n} \n```", "```java\npublic interface Stack<T> extends Iterable<T> {\n  boolean isEmpty();\n  Stack<T> push(T value);\n  Stack<T> pop();\n  T peek();    \n} \n```", "```java\nprivate static class EmptyStack<U> implements Stack<U> {\n  @Override\n    public Stack<U> push(U u) {\n      return new ImmutableStack<>(u, this);\n    }\n    @Override\n    public Stack<U> pop() {\n      throw new UnsupportedOperationException(\n        \"Unsupported operation on an empty stack\");\n    } \n    @Override\n    public U peek() {\n      throw new UnsupportedOperationException (\n        \"Unsupported operation on an empty stack\");\n    }\n    @Override\n    public boolean isEmpty() {\n      return true;\n    }\n    @Override\n    public Iterator<U> iterator() {\n      return new StackIterator<>(this);\n  }\n} \n```", "```java\nprivate static class StackIterator<U> implements Iterator<U> {\n  private Stack<U> stack;\n  public StackIterator(final Stack<U> stack) {\n    this.stack = stack;\n  }\n  @Override\n  public boolean hasNext() {\n    return !this.stack.isEmpty();\n  }\n  @Override\n  public U next() {\n    U e = this.stack.peek();\n    this.stack = this.stack.pop();\n    return e;\n  }\n  @Override\n  public void remove() {\n  }\n} \n```", "```java\npublic class ImmutableStack<E> implements Stack<E> {\n  private final E head;\n  private final Stack<E> tail;\n  private ImmutableStack(final E head, final Stack<E> tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  public static <U> Stack<U> empty(final Class<U> type) {\n    return new EmptyStack<>();\n  }\n  @Override\n  public Stack<E> push(E e) {\n    return new ImmutableStack<>(e, this);\n  }\n  @Override\n  public Stack<E> pop() {\n    return this.tail;\n  }    \n  @Override\n  public E peek() {\n    return this.head;\n  }\n  @Override\n  public boolean isEmpty() {\n    return false;\n  }\n  @Override\n  public Iterator<E> iterator() {\n    return new StackIterator<>(this);\n  }\n  // iterator code\n  // empty stack singleton code\n} \n```", "```java\nStack<String> s = ImmutableStack.empty(String.class); \n```", "```java\nString str = \"start\";\nstr = stopIt(str);\npublic static String stopIt(String str) {\n  str.replace(str, \"stop\");\n  return str;\n} \n```", "```java\npublic static String stopIt(String str) {\n  str =  str.replace(str, \"stop\");\n  return str;\n} \n```", "```java\npublic static String stopIt(String str) {\n  return str.replace(str, \"stop\");\n} \n```", "```java\npublic final class ChainSaw {\n  private static final List<String> MODELS\n    = List.of(\"T300\", \"T450\", \"T700\", \"T800\", \"T900\");\n  private final String model;\n  private final String power;\n  private final int speed;\n  public boolean started;\n  private ChainSaw(String model, String power, int speed) {\n    this.model = model;\n    this.power = power;\n    this.speed = speed;\n  }\n  public static ChainSaw initChainSaw(String model) {\n    for (String m : MODELS) {\n      if (model.endsWith(m)) {**WARNING** **3****!** \n        return new ChainSaw(model, null, **WARNING** **5****!**\n          (int) (Math.random() * 100));\n      }\n    }\n    return null; **WARNING** **1****,****2****!**\n  }\n  public int performance(ChainSaw[] css) {\n    int score = 0;\n    for (ChainSaw cs : css) { **WARNING** **3****!**\n      score += Integer.compare(\n        this.speed,cs.speed); **WARNING** **4****!**\n    }\n    return score;\n  }\n  public void start() {\n    if (!started) {\n      System.out.println(\"Started ...\");\n      started = true;\n    }\n  }\n  public void stop() {\n    if (started) {\n      System.out.println(\"Stopped ...\");\n      started = false;\n    }\n  } \n  public String getPower() {\n    return power; **WARNING** **5****!**\n  }\n  @Override\n  public String toString() {\n    return \"ChainSaw{\" + \"model=\" + model \n      + \", speed=\" + speed + \", started=\" + started + '}';\n  } \n} \n```", "```java\nException in thread \"main\" java.lang.NullPointerException\n    at modern.challenge.Main.main(Main.java:21) \n```", "```java\nException in thread \"main\" java.lang.NullPointerException: Cannot invoke \"modern.challenge.Strings.reverse()\" because \"str\" is null\n    at modern.challenge.Main.main(Main.java:21) \n```", "```java\nChainSaw cs = ChainSaw.initChainSaw(\"QW-T650\");\ncs.start(); // 'cs' is null \n```", "```java\nException in thread \"main\" java.lang.NullPointerException: Cannot invoke \"modern.challenge.ChainSaw.start()\" because \"cs\" is null\n    at modern.challenge.Main.main(Main.java:9) \n```", "```java\nChainSaw cs = ChainSaw.initChainSaw(\"QW-T650\");\nboolean isStarted = cs.started; // 'cs' is null \n```", "```java\nChainSaw cs = ChainSaw.initChainSaw(null); \n```", "```java\nException in thread \"main\" java.lang.NullPointerException: Cannot invoke \"String.endsWith(String)\" because \"model\" is null\n   at modern.challenge.ChainSaw.initChainSaw(ChainSaw.java:25)\n   at modern.challenge.Main.main(Main.java:16) \n```", "```java\nChainSaw myChainSaw = ChainSaw.initChainSaw(\"QWE-T800\");\nChainSaw[] friendsChainSaw = new ChainSaw[]{\n  ChainSaw.initChainSaw(\"Q22-T450\"),\n  ChainSaw.initChainSaw(\"QRT-T300\"),\n  ChainSaw.initChainSaw(\"Q-T900\"),\n  null, // ops!\n  ChainSaw.initChainSaw(\"QMM-T850\"), // model is not supported\n  ChainSaw.initChainSaw(\"ASR-T900\")\n};\nint score = myChainSaw.performance(friendsChainSaw); \n```", "```java\nException in thread \"main\" java.lang.NullPointerException: Cannot read field \"speed\" because \"cs\" is null\n    at modern.challenge.ChainSaw.performance(ChainSaw.java:37)\n    at modern.challenge.Main.main(Main.java:31) \n```", "```java\nChainSaw cs = ChainSaw.initChainSaw(\"T5A-T800\");\nString power = cs.getPower();\nSystem.out.println(power.concat(\" Watts\")); \n```", "```java\nException in thread \"main\" java.lang.NullPointerException: Cannot invoke \"String.concat(String)\" because \"power\" is null\n    at modern.challenge.Main.main(Main.java:37) \n```", "```java\npublic final class ChainSaw {\n  private static final String UNKNOWN_POWER = \"UNKNOWN\";\n  private static final List<String> MODELS\n    = List.of(\"T300\", \"T450\", \"T700\", \"T800\", \"T900\");\n  private final String model;\n  private final String power;\n  private final int speed;\n  public boolean started;\n  private ChainSaw(String model, String power, int speed) {\n    this.model = model;\n    this.power = power;\n    this.speed = speed;\n  }\n  public static ChainSaw initChainSaw(String model) {\n    if (model == null || model.isBlank()) {\n     throw new IllegalArgumentException(\"The given model \n               cannot be null/empty\");\n    }\n    for (String m : MODELS) {\n      if (model.endsWith(m)) { \n        // TO DO (JIRA ####): replace UNKNOWN_POWER with code\n        return new ChainSaw(model, **UNKNOWN_POWER**, \n         (int) (Math.random() * 100));\n        }\n    }\n    throw new UnsupportedOperationException(\n      \"Model \" + model + \" is not supported\");\n  }\n  public int performance(ChainSaw[] css) {\n    if (css == null) {\n      throw new IllegalArgumentException(\n        \"The given models cannot be null\");\n    }\n    int score = 0;\n    for (ChainSaw cs : css) {\n      if (cs != null) {\n        score += Integer.compare(this.speed, cs.speed);\n      }\n    }\n    return score;\n  }\n  public void start() {\n    if (!started) {\n      System.out.println(\"Started ...\");\n      started = true;\n    }\n  }\n  public void stop() {\n    if (started) {\n      System.out.println(\"Stopped ...\");\n      started = false;\n    }\n  }\n  public String getPower() {\n    return power;\n  }\n  @Override\n  public String toString() {\n    return \"ChainSaw{\" + \"model=\" + model\n      + \", speed=\" + speed + \", started=\" + started + '}';\n  }\n} \n```", "```java\nreturn switch (playerType) {\n  case TENNIS ->\n    new TennisPlayer();\n  case FOOTBALL ->\n    new FootballPlayer();\n  ...\n}; \n```", "```java\nreturn switch (playerType) {\n  case TENNIS -> {\n    System.out.println(\"Creating a TennisPlayer ...\");\n    break new TennisPlayer();\n  }\n  case FOOTBALL -> {\n    System.out.println(\"Creating a FootballPlayer ...\");\n    break new FootballPlayer();\n  }\n  ...\n}; \n```", "```java\nreturn switch (playerType) {\n  case TENNIS:\n    yield new TennisPlayer();\n  case FOOTBALL:\n    yield new FootballPlayer();\n  ...\n};\nreturn switch (playerType) {\n  case TENNIS -> {\n    System.out.println(\"Creating a TennisPlayer ...\");\n    yield new TennisPlayer();\n  }\n  case FOOTBALL -> {\n    System.out.println(\"Creating a FootballPlayer ...\");\n    yield new FootballPlayer();\n  }\n  ...\n}; \n```", "```java\nprivate static Player createPlayer(PlayerTypes playerType) {\n  // handling null values in a condition outside switch\n  if (playerType == null) {\n    throw new IllegalArgumentException(\n     \"Player type cannot be null\");\n  }\n  return switch (playerType) {\n    case TENNIS -> new TennisPlayer();\n    case FOOTBALL -> new FootballPlayer();\n    ...\n  };\n} \n```", "```java\nprivate static Player createPlayer(PlayerTypes playerType) {\n  return switch (playerType) {\n    case TENNIS -> new TennisPlayer();\n    case FOOTBALL -> new FootballPlayer();\n    case SNOOKER -> new SnookerPlayer();\n    case null -> throw new NullPointerException(\n                   \"Player type cannot be null\");\n    case UNKNOWN -> throw new UnknownPlayerException(\n                      \"Player type is unknown\");\n    // default is not mandatory\n    default -> throw new IllegalArgumentException(\n                 \"Invalid player type: \" + playerType);\n  };\n} \n```", "```java\nprivate static Player createPlayer(PlayerTypes playerType) {\n  return switch (playerType) {\n    case TENNIS -> new TennisPlayer();\n    case FOOTBALL -> new FootballPlayer();\n    ...\n    case null, default ->\n      throw new IllegalArgumentException(\n       \"Invalid player type: \" + playerType);\n  };\n} \n```", "```java\n...    \ncase TENNIS: yield new TennisPlayer();\ncase FOOTBALL: yield new FootballPlayer();\n...\ncase null, default:\n  throw new IllegalArgumentException(\n    \"Invalid player type: \" + playerType);\n... \n```", "```java\nInteger x1 = 14; Integer y1 = 14;\nInteger x2 = 129; Integer y2 = 129;\nList<Integer> listOfInt1 = new ArrayList<>(\n Arrays.asList(x1, y1, x2, y2));\nlistOfInt1.removeIf(t -> t == x1 || t == x2);\nList<Integer> listOfInt2 = new ArrayList<>(\n Arrays.asList(x1, y1, x2, y2));\nlistOfInt2.removeIf(t -> t.equals(x1) || t.equals(x2)); \n```", "```java\ninterface Furniture {};\nclass Plywood {};\nclass Wardrobe extends Plywood implements Furniture {}; \n```", "```java\nWardrobe wardrobe = new Wardrobe();\nif(wardrobe instanceof Wardrobe) { } // true\nPlywood plywood = new Plywood();\nif(plywood instanceof Plywood) { } // true \n```", "```java\nWardrobe wardrobe = new Wardrobe();\nif(wardrobe instanceof Plywood) {} // true \n```", "```java\nWardrobe wardrobe = new Wardrobe();\nif(wardrobe instanceof Furniture) {} // true \n```", "```java\ncode (this is a simple code used to save different kinds of artifacts on a USB device)?\n```", "```java\npublic static String save(Object o) throws IOException {\n  if (o instanceof File) {\n    File file = (File) o;\n    return \"Saving a file of size: \" \n      + String.format(\"%,d bytes\", file.length());\n  } \n  if (o instanceof Path) {\n    Path path = (Path) o;\n    return \"Saving a file of size: \" \n      + String.format(\"%,d bytes\", Files.size(path));\n  }\n  if (o instanceof String) {\n    String str = (String) o;\n    return \"Saving a string of size: \" \n      + String.format(\"%,d bytes\", str.length());\n  }\n  return \"I cannot save the given object\";\n} \n```", "```java\npublic static String save(Object o) throws IOException {\n  if (o instanceof File file) {\n    return \"Saving a file of size: \" \n      + String.format(\"%,d bytes\", file.length());\n  }\n  if (o instanceof String str) {\n    return \"Saving a string of size: \" \n      + String.format(\"%,d bytes\", str.length());\n  }\n  if (o instanceof Path path) {\n    return \"Saving a file of size: \" \n      + String.format(\"%,d bytes\", Files.size(path));\n  }\n  return \"I cannot save the given object\";\n} \n```", "```java\nif (\"foo\" instanceof String str) {}\nif (\"foo\" instanceof CharSequence sequence) {} \n```", "```java\nif (\"foo\" instanceof String) {}\nif (\"foo\" instanceof CharSequence) {} \n```", "```java\nif (o instanceof File **file**) {\n  return \"Saving a file of size: \" \n    + String.format(\"%,d bytes\", **file.length()**);\n}\n// 'file' is out of scope here \nfile binding variable is visible in the if-then block. Once the block is closed, the file binding variable is out of scope. But, thanks to flow scoping, a binding variable can be used in the if statement that has introduced it to define a so-called *guarded pattern*. Here it is:\n```", "```java\n// 'file' is created ONLY if 'instanceof' returns true\nif (o instanceof File file\n    // this is evaluated ONLY if 'file' was created\n    && file.length() > 0 && file.length() < 1000) {\n  return \"Saving a file of size: \" \n    + String.format(\"%,d bytes\", file.length());\n}\n// another example\nif (o instanceof Path path\n     && Files.size(path) > 0 && Files.size(path) < 1000) {\n  return \"Saving a file of size: \" \n    + String.format(\"%,d bytes\", Files.size(path));\n} \n```", "```java\n// this will not compile\nif (o instanceof Path path\n  || Files.size(path) > 0 && Files.size(path) < 1000) {...} \n```", "```java\nif (o instanceof Path path\n  && (Files.size(path) > 0 || Files.size(path) < 1000)) {...} \n```", "```java\nif (!(o instanceof String str)) {\n  // str is not available here\n  return \"I cannot save the given object\";\n} else {\n  return \"Saving a string of size: \" \n    + String.format(\"%,d bytes\", str.length());\n} \n```", "```java\npublic int getStringLength(Object o) { \n  if (!(o instanceof String str)) {\n    return 0;\n  }\n  return str.length();\n} \n```", "```java\nprivate String strNumber(Object o) {\n if (o instanceof Integer **nr**) {\n   return String.valueOf(nr.intValue());\n } else if (o instanceof Long **nr**) {\n   return String.valueOf(nr.longValue());\n } else {\n   // nr is out of scope here\n   return \"Probably a float number\";\n }\n} \n```", "```java\nprivate final String **str**\n  = \"   I am a string with leading and trailing spaces     \";\npublic String convert(Object o) {\n  // local variable (binding variable) hides a field\n  if (o instanceof String **str**) { \n    return str.strip(); // refers to binding variable, str\n  } else {\n    return str.strip(); // refers to field, str\n  } \n} \n```", "```java\nString dummy = \"\";\nprivate int getLength(Object o) { \n  if(o instanceof String str) {\n      str = dummy; // reassigning binding variable\n      // returns the length of 'dummy' not the passed 'str'\n      return str.length(); \n  }\n  return 0;\n} \n```", "```java\npublic class MyPoint {\n  private final int x;\n  private final int y;\n  private final int z;\n  public MyPoint(int x, int y, int z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (!(obj instanceof MyPoint)) {\n      return false;\n    }\n    final MyPoint other = (MyPoint) obj;\n    return (this.x == other.x && this.y == other.y\n      && this.z == other.z); \n  }       \n} \n```", "```java\n@Override\npublic boolean equals(Object obj) {\n  if (this == obj) {\n    return true;\n  }\n  return obj instanceof MyPoint other\n    && this.x == other.x && this.y == other.y\n    && this.z == other.z; \n} \n```", "```java\nreturn obj instanceof MyPoint<?> other\n  && this.x == other.x && this.y == other.y\n  && this.z == other.z; \n```", "```java\ninstanceof in the old-school fashion:\n```", "```java\npublic static <K, V> void process(Map<K, ? extends V> map) {\n  if (map instanceof EnumMap<?, ? extends V>) {\n    EnumMap<?, ? extends V> books \n     = (EnumMap<?, ? extends V>) map;\n    if (books.get(Status.DRAFT) instanceof Book) {\n      Book book = (Book) books.get(Status.DRAFT);\n      book.review();\n    }\n  }\n}\n// use case\nEnumMap<Status, Book> books = new EnumMap<>(Status.class);\nbooks.put(Status.DRAFT, new Book());\nbooks.put(Status.READY, new Book());\nprocess(books); \n```", "```java\npublic static <K, V> void process(Map<K, ? extends V> map) {\n  if (map instanceof EnumMap<?, ? extends V> books\n    && books.get(Status.DRAFT) instanceof Book book) {\n      book.review();\n  }\n} \n```", "```java\npublic static List<Engine> filterRegularEngines(\n              List<Engine> engines, int testSpeed) {\n  for (Iterator<Engine> i = engines.iterator(); i.hasNext();){\n    final Engine e = i.next();\n    if (e instanceof RegularEngine) {\n      final RegularEngine popularEngine = (RegularEngine) e;\n      if (popularEngine.isElectric()) {\n        if (!hasEnoughAutonomy(popularEngine, testSpeed)) {\n          i.remove();\n        }\n      }\n    }\n  }\n  return engines;\n} \n```", "```java\npublic static List<Engine> filterRegularEngines(\n              List<Engine> engines, int testSpeed) {\n  engines.removeIf(e -> e instanceof RegularEngine engine \n    && engine.isElectric()\n    && !hasEnoughAutonomy(engine, testSpeed));\n  return engines;\n} \n```", "```java\nProblem 58 via a type pattern for switch:\n```", "```java\npublic static String save(Object o) throws IOException {\n  return switch(o) {\n    case File file -> \"Saving a file of size: \" \n              + String.format(\"%,d bytes\", file.length());\n    case Path path -> \"Saving a file of size: \" \n              + String.format(\"%,d bytes\", Files.size(path));\n    case String str -> \"Saving a string of size: \" \n              + String.format(\"%,d bytes\", str.length());\n    case null -> \"Why are you doing this?\";\n    default -> \"I cannot save the given object\";\n  }; \n} \n```", "```java\nprivate static String turnOnTheHeat(Heater heater) {\n  return switch (heater) {\n    case Stove stove -> \"Make a fire in the stove\";\n    case Chimney chimney -> \"Make a fire in the chimney\";\n    default -> \"No heater available!\";\n  };\n} \n```", "```java\nreturn switch (heater) {\n  case Stove stove -> \"Make a fire in the stove\";\n**case** **Chimney chimney**\n **&& chimney.isElectric() ->** **\"Plug in the chimney\"****;**\n  case Chimney chimney -> \"Make a fire in the chimney\";\n  default -> \"No heater available!\";\n}; \n```", "```java\nenum FuelType { GASOLINE, HYDROGEN, KEROSENE }\nclass Vehicle {\n  private final int gallon;\n  private final FuelType fuel;\n  ...\n} \n```", "```java\nprivate static String theVehicle(Vehicle vehicle) {\n  return switch (vehicle) {\n    case Vehicle v && v.getFuel().equals(GASOLINE)\n      && v.getGallon() < 120 -> \"probably a car/van\"; \n    case Vehicle v && v.getFuel().equals(GASOLINE)\n      && v.getGallon() > 120 -> \"probably a big rig\"; \n    case Vehicle v && v.getFuel().equals(HYDROGEN) \n      && v.getGallon() < 300_000 -> \"probably an aircraft\";\n    case Vehicle v && v.getFuel().equals(HYDROGEN) \n      && v.getGallon() > 300_000 -> \"probably a rocket\";\n    case Vehicle v && v.getFuel().equals(KEROSENE) \n      && v.getGallon() > 2_000 && v.getGallon() < 6_000 \n         -> \"probably a narrow-body aircraft\";\n    case Vehicle v && v.getFuel().equals(KEROSENE) \n      && v.getGallon() > 6_000 && v.getGallon() < 55_000\n         -> \"probably a large (B747-400) aircraft\";\n    default -> \"no clue\";\n  };\n} \n```", "```java\nreturn switch (vehicle) {\n  case Vehicle v when (v.getFuel().equals(GASOLINE)\n    && v.getGallon() < 120) -> \"probably a car/van\"; \n  case Vehicle v when (v.getFuel().equals(GASOLINE)\n    && v.getGallon() > 120) -> \"probably a big rig\"; \n  ...\n  case Vehicle v when (v.getFuel().equals(KEROSENE) \n    && v.getGallon() > 6_000 && v.getGallon() < 55_000)\n      -> \"probably a large (B747-400) aircraft\";\n  default -> \"no clue\";\n}; \n```", "```java\nabstract class Pill {}\nclass Nurofen extends Pill {}\nclass Ibuprofen extends Pill {}\nclass Piafen extends Pill {} \n```", "```java\nprivate static String headache(Pill o) {\n  return switch(o) {\n    case Nurofen nurofen -> \"Get Nurofen ...\";\n    case Ibuprofen ibuprofen -> \"Get Ibuprofen ...\";\n    case Piafen piafen -> \"Get Piafen ...\";\n    default -> \"Sorry, we cannot solve your headache!\";\n  };\n} \n```", "```java\nreturn switch(o) { \n  // case Nurofen nurofen -> \"Get Nurofen ...\";\n  case Ibuprofen ibuprofen -> \"Get Ibuprofen ...\";\n  case Piafen piafen -> \"Get Piafen ...\";\n  default -> \"Sorry, we cannot solve your headache!\";\n}; \n```", "```java\nreturn switch(o) { \n  case Pill pill -> \"Get a headache pill ...\";\n  case Nurofen nurofen -> \"Get Nurofen ...\";\n  case Ibuprofen ibuprofen -> \"Get Ibuprofen ...\";\n  case Piafen piafen -> \"Get Piafen ...\";\n}; \n```", "```java\nreturn switch(o) { \n  case Nurofen nurofen -> \"Get Nurofen ...\";\n  case Ibuprofen ibuprofen -> \"Get Ibuprofen ...\";\n  case Piafenpiafen -> \"Get Piafen ...\";\n  case Pill pill -> \"Get a headache pill ...\";\n}; \n```", "```java\nabstract class Drink {}\nclass Small extends Drink {}\nclass Medium extends Small {}\nclass Large extends Medium {}\nclass Extra extends Medium {}\nclass Huge extends Large {}\nclass Jumbo extends Extra {} \n```", "```java\nprivate static String buyDrink(Drink o) {\n  return switch(o) { \n    case Jumbo j: yield \"We can give a Jumbo ...\";\n    case Huge h: yield \"We can give a Huge ...\"; \n    case Extra e: yield \"We can give a Extra ...\";\n    case Large l: yield \"We can give a Large ...\";\n    case Medium m: yield \"We can give a Medium ...\";\n    case Small s: yield \"We can give a Small ...\";\n    default: yield \"Sorry, we don't have this drink!\";\n  };\n} \n```", "```java\nreturn switch(o) { \n  case Huge h: yield \"We can give a Huge ...\";\n  case Large l: yield \"We can give a Large ...\";\n  case Medium m: yield \"We can give a Medium ...\";\n  case Small s: yield \"We can give a Small ...\";\n  default: yield \"Sorry, we don't have this drink!\";\n}; \n```", "```java\nreturn switch(o) {\n  case Huge h: yield \"We can give a Huge ...\";\n  case Large l: yield \"We can give a Large ...\";\n  case Small s: yield \"We can give a Small ...\";\n  default: yield \"Sorry, we don't have this drink!\";\n}; \n```", "```java\nprivate static int oneHundredDividedBy(Integer value) {\n  return switch(value) { \n    case Integer i -> 100/i;\n    case 0 -> 0;\n  };\n} \n```", "```java\n return switch(value) { \n    case 0 -> 0;\n    case Integer i -> 100/i;\n  }; \n```", "```java\nenum Hero { CAPTAIN_AMERICA, IRON_MAN, HULK }\nprivate static String callMyMarvelHero(Hero hero) {\n  return switch(hero) {\n    case Hero h -> \"Calling \" + h;\n    case HULK -> \"Sorry, we cannot call this guy!\";\n  };\n} \n```", "```java\nreturn switch(hero) { \n    case HULK -> \"Sorry, we cannot call this guy!\";\n    case Hero h -> \"Calling \" + h;\n  }; \n```", "```java\nprivate static int oneHundredDividedByPositive(Integer value){\n  return switch(value) { \n    case Integer i when i > 0 -> 100/i;\n    case 0 -> 0;\n    case Integer i -> (-1) * 100/i;\n  };\n} \n```", "```java\nreturn switch(value) { \n  case 0 -> 0;\n  case Integer i when i > 0 -> 100/i;\n  case Integer i -> (-1) * 100/i;\n}; \n```", "```java\nclass Vehicle {}\nclass Car extends Vehicle {}\nclass Van extends Vehicle {}\nprivate static String whatAmI(Vehicle vehicle) {\n  return switch(vehicle) {\n    case Car car -> \"You're a car\";\n    case Van van -> \"You're a van\";\n  };\n} \nThe switch expression does not cover all possible input values. The compiler complains because we don’t have a case pattern label for Vehicle. This base class can be legitimately used without being a Car or a Van, so it is a valid candidate for our switch. We can add a case Vehicle or a default label. If you know that Vehicle will remain an empty base class, then you’ll probably go for a default label:\n```", "```java\nreturn switch(vehicle) {\n    case Car car -> \"You're a car\";\n    case Van van -> \"You're a van\";\n    **default** **->** **\"I have no idea ... what are you?\"****;**\n  }; \n```", "```java\nreturn switch(vehicle) {\n    case Car car -> \"You're a car\";\n    case Van van -> \"You're a van\";\n    **case** **Vehicle v ->** **\"You're a vehicle\"****;** **// total pattern**\n}; \n```", "```java\nprivate static String whatAmI(Object o) {\n  return switch(o) {\n    case Car car -> \"You're a car\";\n    case Van van -> \"You're a van\";\n**case** **Vehicle v ->** **\"You're a vehicle\"****;** **// optional**\n**default** **->** **\"I have no idea ... what are you?\"****;**\n  };\n} \n```", "```java\nreturn switch(o) {\n  case Car car -> \"You're a car\";\n  case Van van -> \"You're a van\";\n**case** **Vehicle v ->** **\"You're a vehicle\"****;** **// optional**\n**case** **Object obj ->** **\"You're an object\"****;** **// total pattern**\n}; \n```", "```java\npublic static String whatAmI(CharSequence cs) {\n  return switch(cs) { \n    case String str -> \"You're a string\";\n    case Segment segment -> \"You're a Segment\";\n    case CharBuffer charbuffer -> \"You're a CharBuffer\";\n    case StringBuffer strbuffer -> \"You're a StringBuffer\";\n    case StringBuilder strbuilder -> \"You're a StringBuilder\";\n  };\n} \nThe switch expression does not cover all possible input values. But, if we check the documentation of CharSequence, we see that it is implemented by five classes: CharBuffer, Segment, String, StringBuffer, and StringBuilder. In our code, each of these classes is covered by a pattern label, so we have covered all possible values, right? Well, yes and no… “Yes” because we cover all possible values for the moment, and “no” because anyone can implement the CharSequence interface, which will break the exhaustive coverage of our switch. We can do this:\n```", "```java\npublic class CoolChar implements CharSequence { ... } \n```", "```java\nreturn switch(cs) { \n  case String str -> \"You're a string\";\n  ...\n  case StringBuilder strbuilder -> \"You're a StringBuilder\";\n **// we have created this**\n**case** **CoolChar cool ->** **\"Welcome ... you're a CoolChar\"****;**\n**// this is a total pattern**\n**case** **CharSequence charseq ->** **\"You're a CharSequence\"****;**\n  // can be used instead of the total pattern\n  // default -> \"I have no idea ... what are you?\";\n}; \n```", "```java\nprivate static String whatAmI(ConstantDesc constantDesc) {\n  return switch(constantDesc) { \n    case Integer i -> \"You're an Integer\";\n    case Long l -> \"You're a Long\";\n    case Float f -> \" You're a Float\";\n    case Double d -> \"You're a Double\";\n    case String s -> \"You're a String\";\n    case ClassDesc cd -> \"You're a ClassDesc\";\n    case DynamicConstantDesc dcd -> \"You're a DCD\";\n    case MethodHandleDesc mhd -> \"You're a MethodHandleDesc\";\n    case MethodTypeDesc mtd -> \"You're a MethodTypeDesc\";\n  };\n} \n```", "```java\npublic **sealed** interface ClassDesc\n  extends ConstantDesc, TypeDescriptor.OfField<ClassDesc> \n```", "```java\nsealed interface Player {}\nfinal class Tennis implements Player {}\nfinal class Football implements Player {}\nfinal class Snooker implements Player {} \n```", "```java\nprivate static String trainPlayer(Player p) { \n  return switch (p) {\n    case Tennis t -> \"Training the tennis player ...\" + t;\n    case Football f -> \"Training the football player ...\" + f;\n    case Snooker s -> \"Training the snooker player ...\" + s;\n  };\n} \n```", "```java\nfinal class Golf implements Player {} \n```", "```java\nprivate enum PlayerTypes { TENNIS, FOOTBALL, SNOOKER } \n```", "```java\nprivate static String createPlayer(PlayerTypes p) { \n  return switch (p) {\n    case TENNIS -> \"Creating a tennis player ...\";\n    case FOOTBALL -> \"Creating a football player ...\";\n    case SNOOKER -> \"Creating a snooker player ...\";\n  };\n} \n```", "```java\nfinal static class PlayerClub implements Sport {};\nprivate enum PlayerTypes implements Sport\n  { TENNIS, FOOTBALL, SNOOKER }\nsealed interface Sport permits PlayerTypes, PlayerClub {}; \n```", "```java\nprivate static String createPlayerOrClub(Sport s) { \n  return switch (s) {\n    case PlayerTypes p when p == PlayerTypes.TENNIS\n      -> \"Creating a tennis player ...\";\n    case PlayerTypes p when p == PlayerTypes.FOOTBALL\n      -> \"Creating a football player ...\";\n    case PlayerTypes p -> \"Creating a snooker player ...\";\n    case PlayerClub p -> \"Creating a sport club ...\";\n  };\n} \n```", "```java\nprivate static String createPlayerOrClub(Sport s) {\n  return switch (s) {\n    case PlayerTypes.TENNIS\n      -> \"Creating a tennis player ...\";\n    case PlayerTypes.FOOTBALL\n      -> \"Creating a football player ...\";\n    case PlayerTypes.SNOOKER\n      -> \"Creating a snooker player ...\";\n    case PlayerClub p \n      -> \"Creating a sport club ...\";\n  };\n} \n```", "```java\nprivate static String drive(Vehicle v) {\n  return switch (v) {\n    case Truck truck -> \"truck: \" + truck;\n    case Van van -> \"van: \" + van;\n    case Vehicle vehicle -> \"vehicle: \" + vehicle.start();\n  };\n}\ndrive(null); \n```", "```java\nException in thread \"main\" java.lang.NullPointerException: Cannot invoke \"modern.challenge.Vehicle.start()\" because \"vehicle\" is null \n```", "```java\nreturn switch (v) {\n    case Truck truck -> \"truck: \" + truck;\n    case Van van -> \"van: \" + van;\n    **case****null** **->** **\"so, you don't have a vehicle?\"****;**\n    case Vehicle vehicle -> \"vehicle: \" + vehicle.start();\n  }; \n```", "```java\nreturn switch (v) {\n  case Truck truck -> \"truck: \" + truck;\n  case Van van -> \"van: \" + van;\n  // we can still use a null check\n  // case null -> \"so, you don't have a vehicle?\";\n  // total/unconditional pattern throw NPE immediately\n  case Vehicle vehicle -> \"vehicle: \" + vehicle.start();\n}; \n```", "```java\nException in thread \"main\" java.lang.NullPointerExceptionatjava.base/java.util.Objects.requireNonNull(Objects.java:233) \n```"]