- en: Chapter 8. Validators and Interceptors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 验证器和拦截器
- en: 'In this chapter, we will see data validation with constraints. This will give
    us the opportunity to put a small part of **AOP** (**Aspect Oriented Programming**)
    in action and discover the novelties in the validation and interception APIs.
    The specifications concerned are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到使用约束进行数据验证。这将给我们机会将一小部分**AOP**（**面向方面编程**）付诸实践，并发现验证和拦截API中的新特性。相关的规范包括：
- en: Bean Validation 1.1
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean Validation 1.1
- en: Interceptors 1.2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Interceptors 1.2
- en: Bean Validation
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean Validation
- en: The Bean Validation 1.1 Specification was developed under JSR 349\. This section
    just gives you an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 1.1规范是在JSR 349下开发的。本节仅为您概述API的改进。完整的规范文档（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html)下载。
- en: We are almost at the end of the realization of our online preregistration application.
    In the previous chapters, we developed the different layers of our application
    and now we need to validate the data that will be handled by this application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了我们的在线预注册应用程序的实现。在前几章中，我们开发了应用程序的不同层，现在我们需要验证将由该应用程序处理的数据。
- en: Validating your data
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证您的数据
- en: The Java language provides for Java SE and Java EE developers the Bean Validation
    Specification, which allows us to express constraints on objects. By default,
    it offers a small number of constraints (compared to the needs that you may have)
    called built-in constraints (see the following table). But, it gives you the opportunity
    to combine these constraints in order to make much more complex constraints (custom
    constraints) that suit your needs. This is what makes its power. This specification
    can be used in conjunction with many other specifications such as CDI, JSF, JPA,
    and JAX-RS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言为Java SE和Java EE开发者提供了Bean Validation规范，该规范允许我们表达对对象的约束。默认情况下，它提供了一小部分约束（与您可能的需求相比），称为内置约束（见下表）。但是，它为您提供了将这些约束组合起来的机会，以创建更复杂的约束（自定义约束），以满足您的需求。这正是其强大的原因。该规范可以与许多其他规范（如CDI、JSF、JPA和JAX-RS）一起使用。
- en: 'The list of the built-in constraints in Bean Validation 1.1 is shown in the
    following table:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了Bean Validation 1.1中的内置约束列表：
- en: '| Constraint | Supported type | Description |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 约束 | 支持的类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@Null` | `Object` | This ensures that the value of the object is null |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `@Null` | `Object` | 这确保了对象值为null |'
- en: '| `@NotNull` | `Object` | This ensures that the value of the object is not
    null |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `@NotNull` | `Object` | 这确保了对象值不为null |'
- en: '| `@AssertTrue` | `boolean`, Boolean | This ensures that the value of the object
    is true |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `@AssertTrue` | `boolean`, Boolean | 这确保了对象值为true |'
- en: '| `@AssertFalse` | `boolean`, Boolean | This ensures that the value of the
    object is false |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `@AssertFalse` | `boolean`, Boolean | 这确保了对象值为false |'
- en: '| `@Min` | `BigDecimal`, `BigInteger` `byte`, `short`, `int`, `long`, and the
    respective wrappers (such as `Byte` and `Short`) | This ensures that the value
    of the object is greater than or equal to the value specified in the annotation
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `@Min` | `BigDecimal`, `BigInteger` `byte`, `short`, `int`, `long`以及相应的包装器（如`Byte`和`Short`）
    | 这确保了对象值大于或等于注解中指定的值 |'
- en: '| `@Max` | `BigDecimal`, `BigInteger` `byte`, `short`, `int`, `long`, and the
    respective wrappers (such as `Byte` and `Short`) | This ensures that the value
    of the object is less than or equal to the value specified in the annotation |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `@Max` | `BigDecimal`, `BigInteger` `byte`, `short`, `int`, `long`以及相应的包装器（如`Byte`和`Short`）
    | 这确保了对象值小于或等于注解中指定的值 |'
- en: '| `@DecimalMin` | `BigDecimal`, `BigInteger`, `CharSequence``byte`, `short`,
    `int`, `long`, and the respective wrappers (such as `Byte` and `Short`) | This
    ensures that the value of the object is greater than or equal to the value specified
    in the annotation |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `@DecimalMin` | `BigDecimal`, `BigInteger`, `CharSequence` `byte`, `short`,
    `int`, `long`以及相应的包装器（如`Byte`和`Short`） | 这确保了对象值大于或等于注解中指定的值 |'
- en: '| `@DecimalMax` | `BigDecimal`, `BigInteger`, `CharSequence``byte`, `short`,
    `int`, `long`, and the respective wrappers (such as `Byte` and `Short`) | This
    ensures that the value of the object is less than or equal to the value specified
    in the annotation |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `@DecimalMax` | `BigDecimal`, `BigInteger`, `CharSequence`, `byte`, `short`,
    `int`, `long` 以及相应的包装器（如 `Byte` 和 `Short`） | 这确保了对象的值小于或等于注解中指定的值 |'
- en: '| `@Size` | `CharSequence`, `Collection`, `Array`, and `Map` | This ensures
    that the size of the object is in the defined range |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `@Size` | `CharSequence`, `Collection`, `Array`, 和 `Map` | 这确保了对象的尺寸在定义的范围内
    |'
- en: '| `@Digits` | `BigDecimal`, `BigInteger`, `CharSequence``byte`, `short`, `int`,
    `long`, and the respective wrappers (such `asByte` and `Short`) | This ensures
    that the value of the object is in the defined range |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `@Digits` | `BigDecimal`, `BigInteger`, `CharSequence`, `byte`, `short`,
    `int`, `long` 以及相应的包装器（如 `asByte` 和 `Short`） | 这确保了对象的值在定义的范围内 |'
- en: '| `@Past` | `java.util.Date` and `java.util.Calendar` | This ensures that the
    date contained in the object is prior to the date of treatment |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `@Past` | `java.util.Date` 和 `java.util.Calendar` | 这确保了对象中包含的日期早于处理日期 |'
- en: '| `@Future` | `java.util.Date` and `java.util.Calendar` | This ensures that
    the date contained in the object is later than the date of treatment |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `@Future` | `java.util.Date` 和 `java.util.Calendar` | 这确保了对象中包含的日期晚于处理日期
    |'
- en: '| `@Pattern` | `CharSequence` | This ensures that value of the item meets the
    regular expression defined in the annotation |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `@Pattern` | `CharSequence` | 这确保了项目的值符合注解中定义的正则表达式 |'
- en: 'One advantage of this specification is the ability to define the different
    constraints it offers via annotations, which facilitates its use. According to
    the characteristics of the annotation (explained in detail in [Chapter 7](ch07.html
    "Chapter 7. Annotations and CDI"), *Annotations and CDI*), you can express constraints
    for a class, field, or property. The following example shows a `Student` entity
    whose fields are decorated with the built-in constraints. You can see the constraints
    to avoid the null value or to define the size and format of attributes in the
    following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此规范的一个优点是能够通过注解定义它提供的不同约束，这有助于其使用。根据注解的特性（在[第 7 章](ch07.html "第 7 章。注解和 CDI")中详细解释，*注解和
    CDI*），你可以为类、字段或属性表达约束。以下示例显示了一个带有内置约束的 `Student` 实体。你可以在以下代码中看到约束以避免空值或定义属性的尺寸和格式：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the constraints are defined, the Bean Validation Specification allows
    you to validate the data under constraints manually or automatically through other
    specifications. We begin by presenting manual validation. The following example
    demonstrates how to validate the constraints of a class manually. We must say
    that the `Validator` API also provides methods to validate a single attribute
    or a specific value as shown in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了约束，Bean Validation 规范允许你通过其他规范手动或自动地验证受约束的数据。我们首先介绍手动验证。以下示例演示了如何手动验证类的约束。我们必须说，`Validator`
    API 还提供了方法来验证单个属性或特定值，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we mentioned, the Bean Validation Specification can be combined with other
    specifications. In the example that follows, we present the coupling between Bean
    Validation and JSF. We take this opportunity to highlight automatic validation.
    The example that follows demonstrates how to validate the input of a student in
    our online preregistration website:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，Bean Validation 规范可以与其他规范结合使用。在下面的示例中，我们展示了 Bean Validation 与 JSF 之间的耦合。我们借此机会强调自动验证。下面的示例演示了如何在我们的在线预注册网站上验证学生的输入：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following code shows an example of the content of the web page allowing
    candidates to enter their personal identification. As you can see, we used the
    pass through attribute explained in [Chapter 3](ch03.html "Chapter 3. The Presentation
    Layer"), *The Presentation Layer*, to use the calendar of HTML5 and we put the
    tag `<h:message/>` next to each field with the ID of the concerned field in order
    to display error messages in case of violation of the constraint. This allows
    us to have the screen capture shown in the following screenshot.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个网页内容的示例，允许候选人输入他们的个人身份信息。正如你所见，我们使用了在[第 3 章](ch03.html "第 3 章。表示层")中解释的通过属性，*表示层*，来使用
    HTML5 的日历，并将 `<h:message/>` 标签放在具有相关字段 ID 的每个字段旁边，以便在违反约束的情况下显示错误信息。这使我们能够拥有以下截图所示的屏幕截图。
- en: 'The following code is an example of the contents of the `identificationInformationPage.xml`
    JSF page:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`identificationInformationPage.xml` JSF页面的内容示例：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As shown in the following screenshot, when submitting the entry, the contents
    of the form will automatically be validated and error messages will be returned
    to the form. Thus, this association (JSF and Bean validation) allows you to define
    the constraints on a single bean and use it for multiple forms.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，在提交条目时，表单的内容将自动进行验证，并将错误信息返回到表单中。因此，这种关联（JSF和Bean验证）允许您在单个bean上定义约束，并用于多个表单。
- en: 'The result of the validation is shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的结果如下截图所示：
- en: '![Validating your data](img/923-5_08_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![验证您的数据](img/923-5_08_01.jpg)'
- en: Building a custom constraint
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义约束
- en: In the previous example, we wanted to have a constraint that allows us to ensure
    that the value of the `Gender` field was entered in uppercase, but this constraint
    does not exist explicitly. To do this, we must have some knowledge of regular
    expressions and use the `@Pattern` annotation. This requires some background.
    Fortunately, we have the ability to create custom constraints. We will set up
    a constraint that allows us to perform this task.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们想要有一个约束，可以确保`Gender`字段的值是大写的，但这个约束并不存在。为此，我们必须对正则表达式有一些了解，并使用`@Pattern`注解。这需要一些背景知识。幸运的是，我们有创建自定义约束的能力。我们将设置一个约束，允许我们执行这项任务。
- en: 'The creation of a new constraint substantially follows the same rules as the
    creation of a simple annotation (as explained [Chapter 7](ch07.html "Chapter 7. Annotations
    and CDI"), *Annotations and CDI*). The fundamental difference lies in the fact
    that instead of implementing a processor, we will implement a validator in the
    case of constraints. That said, the creation of a custom constraint includes the
    following steps: creating a constraint annotation and implementing a validator.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新约束的过程基本上遵循创建简单注解的相同规则（如第7章[Annotations and CDI](ch07.html "Chapter 7. Annotations
    and CDI")中所述）。基本区别在于，在约束的情况下，我们不会实现处理器，而是实现验证器。也就是说，创建自定义约束包括以下步骤：创建约束注解和实现验证器。
- en: Creating a constraint annotation
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建约束注解
- en: Although the goal is to create a constraint that ensures that a string character
    is capitalized, we will create a generic annotation. This annotation will take
    as parameter the type of the expected case. Thus, it may, in the future, allow
    us to test if the characters are uppercase or lowercase .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然目标是创建一个确保字符串字符首字母大写的约束，但我们将创建一个通用注解。这个注解将接受预期大小写的类型作为参数。因此，它可能在未来允许我们测试字符是大写还是小写。
- en: 'We will create the enumeration `CaseType`, which contains different types of
    case, as shown in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建枚举`CaseType`，它包含不同的大小写类型，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we have defined the possible types of cases, we will create our annotation
    and define its characteristics directly. Already, it should be noted that in addition
    to the basic features we''ve seen in the creation of annotations, you''ll have
    to add the `@Constraint` annotation that defines the validator of this constraint.
    For other features, please refer to [Chapter 7](ch07.html "Chapter 7. Annotations
    and CDI"), *Annotations and CDI*. The following code is the code of our annotation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了可能的大小写类型，我们将创建我们的注解并直接定义其特征。应该注意的是，除了我们在创建注解时看到的基线功能外，您还需要添加定义此约束验证器的`@Constraint`注解。对于其他功能，请参阅第7章[Annotations
    and CDI](ch07.html "Chapter 7. Annotations and CDI")。以下是我们注解的代码：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implementing a validator
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现验证器
- en: 'Instead of a processor that is required for simple annotations, constraints
    need to implement the `javax.validation.ConstraintValidator <A extends Annotation,
    T extends Object>` interface, which provides two methods that are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与需要用于简单注释的处理器不同，约束需要实现`javax.validation.ConstraintValidator <A extends Annotation,
    T extends Object>`接口，该接口提供了以下两个方法：
- en: '`void initialize(A constraintAnnotation)`: This method is always called before
    processing a constraint. It allows you to initialize the parameters that will
    be useful during the execution of the `isValid()` method.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void initialize(A constraintAnnotation)`: 这个方法总是在处理约束之前被调用。它允许您初始化在`isValid()`方法执行期间将有用的参数。'
- en: '`boolean isValid(T value, ConstraintValidatorContext context)`: This method
    contains the validation logic.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isValid(T value, ConstraintValidatorContext context)`: 此方法包含验证逻辑。'
- en: 'The following code shows the validator of our constraint:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们的约束验证器：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After you create your validator, you must register the service (see [Chapter
    7](ch07.html "Chapter 7. Annotations and CDI"), *Annotations and CDI*). Then,
    import the package containing your annotation. The following screenshot shows
    the structure of the project in which we have defined our annotation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建您的验证器之后，您必须注册该服务（参见[第7章](ch07.html "第7章。注解和CDI")，*注解和CDI*）。然后，导入包含您的注解的包。以下截图显示了我们在其中定义注解的项目结构：
- en: '![Implementing a validator](img/923-5_08_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![实现验证器](img/923-5_08_02.jpg)'
- en: 'Now, we just need to add `@Case (type = CaseType.UPPER)` on an attribute of
    type `String` to ensure that the value will always be in capital letters. The
    following code shows the change in the `InscriptionBean` Bean code that was presented
    earlier:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在`String`类型的属性上添加`@Case (type = CaseType.UPPER)`，以确保值始终为大写字母。以下代码显示了之前展示的`InscriptionBean`
    Bean代码中的更改：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the result is simply beautiful, as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果简单而美丽，如下截图所示：
- en: '![Implementing a validator](img/923-5_08_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![实现验证器](img/923-5_08_03.jpg)'
- en: Latest improvements in action
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最新改进的实际应用
- en: 'Chapter 2 of the *Bean* *Validation 1.1 Specification Document* presents the
    major changes of this version. These are: openness, support for dependency injection,
    better integration with CDI, support for method and constructor validation, support
    for group conversion, and finally support for message interpolation using expression
    language.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bean* *Validation 1.1 规范文档*的第二章介绍了本版本的重大变更。这些变更包括：开放性、支持依赖注入、更好地与CDI集成、支持方法和构造函数验证、支持分组转换，以及最终支持使用表达式语言进行消息插值。'
- en: Openness
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开放性
- en: The implementation of the Bean Validation 1.1 Specification has been managed
    as an open source project. Thus, the source code, reference implementation and
    test compatibility kit of the API are accessible to the community. For more information,
    please access the site [http://beanvalidation.org](http://beanvalidation.org).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 1.1 规范的实现被管理为一个开源项目。因此，API的源代码、参考实现和测试兼容性套件对社区是可访问的。更多信息，请访问网站
    [http://beanvalidation.org](http://beanvalidation.org)。
- en: Support for dependency injection and CDI integration
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持依赖注入和CDI集成
- en: 'The Bean Validation 1.1 Specification has standardized the management of objects
    used to implement validators inside a container and reviewed all the services
    that were offered to these objects. That helped support dependency injection in
    Bean Validation components and improve integration with CDI. Henceforth, we can
    use the `@Resource` and `@Inject` annotations to inject objects of type `ValidatorFactory`
    and `Validator`. The following example demonstrates the use of the `@Inject` annotation
    to validate an object using Bean Validation components:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 1.1 规范已经标准化了在容器内部实现验证器所使用的对象的管理，并审查了提供给这些对象的所有服务。这有助于支持Bean
    Validation组件中的依赖注入并改善与CDI的集成。从现在起，我们可以使用`@Resource`和`@Inject`注解注入`ValidatorFactory`和`Validator`类型的对象。以下示例演示了如何使用`@Inject`注解通过Bean
    Validation组件验证一个对象：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Support for method and constructor validation
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持方法和构造函数验证
- en: 'The Bean Validation Specification 1.1 has added the ability to define constraints
    on the parameters of a method or constructor. It also allows the definition of
    the constraints on the return value of a method. The following code demonstrates
    how to declare and validate constraints on the parameters of a method and its
    return value:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 1.1 规范增加了在方法或构造函数的参数上定义约束的能力。它还允许定义方法返回值的约束。以下代码演示了如何声明和验证方法参数及其返回值的约束：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Support for group conversion
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持分组转换
- en: 'While cascading a data validation, it may happen that the data to validate
    belongs to groups that are different from the requested group. For a concrete
    example, consider the following two classes `Student` and `Address`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在级联数据验证时，可能会出现要验证的数据属于与请求组不同的组的情况。具体示例，考虑以下两个类`Student`和`Address`：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To enable the validation of an object step-by-step, the Bean Validation Specification
    proposes the notion of groups. This gives you the ability to define a subset of
    constraints that can be validated separately. By default, validation constraints
    belongs to the `Default` group. And if a validation group is not specified when
    validating data, only the constraints of the `Default` group will be checked.
    This justifies the fact that the code of the `testDefaultGroup()` method will
    run entirely without errors. Although the phone and the e-mail attributes of the
    `Address` class are not conformed to the constraints, they will not be validated
    for the simple reason that the constraints that decorate them are not a part of
    the `Default` group. This can be seen in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐步验证对象，Bean Validation 规范提出了组的概念。这让你能够定义一个可以单独验证的约束子集。默认情况下，验证约束属于 `Default`
    组。如果在验证数据时没有指定验证组，则只检查 `Default` 组的约束。这解释了为什么 `testDefaultGroup()` 方法的代码将完全无误地运行。尽管
    `Address` 类的电话和电子邮件属性不符合约束，但它们将不会被验证，仅仅是因为装饰它们的约束不是 `Default` 组的一部分。这可以从以下代码中看出：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, to validate the attributes of the `Address` object at the same time as
    the validation of the `Student` object, you have two options. The first is to
    list all the groups in the `validate()` method as is the case in the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了在验证 `Student` 对象的同时验证 `Address` 对象的属性，你有两种选择。第一种是将所有组在 `validate()` 方法中列出，如下代码所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The second method is to use the concept of group conversion via the `@ConvertGroup`
    or `@ConvertGroup.List` for several conversions. As its name implies, this feature
    gives you the ability to perform conversions from one group to another to validate
    attributes whose constraints belong to a group different from the requested group.
    The following code shows the changes that should be added on the `Address` attribute
    of the `Student` class in order to take advantage of the group conversion feature:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用 `@ConvertGroup` 或 `@ConvertGroup.List` 的组转换概念进行多个转换。正如其名所示，这个特性让你能够从一个组转换到另一个组以验证约束属于不同于请求组的属性。以下代码展示了为了利用组转换功能，需要在
    `Student` 类的 `Address` 属性上添加的更改：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following code shows the joint validation attributes of the `Student` object
    and attributes of the `Address` object after using the `@ConvertGroup` annotation.
    As you can see in the following code, we did not have to list all the groups of
    constraints.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用 `@ConvertGroup` 注解后 `Student` 对象的联合验证属性和 `Address` 对象的属性。正如以下代码所示，我们不必列出所有约束组。
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following code shows how to use the `@ConvertGroup.List` annotation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用 `@ConvertGroup.List` 注解：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Support message interpolation using expression language
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持使用表达式语言进行消息插值
- en: 'With this version of the specification, it is possible to use expression language
    when defining the error message. It helps in better formatting of the message
    and the use of conditions in the description of the message. The following code
    shows a possible use of expression language in the definition of an error message:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个规范版本中，当定义错误消息时可以使用表达式语言。这有助于更好地格式化消息并在消息描述中使用条件。以下代码展示了在定义错误消息时可能使用表达式语言的示例：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Interceptors
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截器
- en: The Interceptors 1.2 Specification was developed under JSR 318\. This section
    just gives you an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr318/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr318/index.html).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Interceptors 1.2 规范是在 JSR 318 下开发的。本节仅为您概述了 API 的改进。完整的文档规范（更多信息）可以从 [http://jcp.org/aboutJava/communityprocess/final/jsr318/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr318/index.html)
    下载。
- en: Intercepting some processes
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拦截某些进程
- en: Interceptors are a Java mechanism that allows us to implement some concepts
    of AOP, in the sense that they give us the ability to separate the code from the
    crosscutting concerns such as logging, auditing, and security. Thus, due to this
    specification, we can intercept invocations of methods, lifecycle callback events,
    and timeout events.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器是 Java 机制，允许我们实现一些 AOP 的概念，从某种意义上说，它让我们能够将代码与诸如日志记录、审计和安全等横切关注点分离。因此，由于这个规范，我们可以拦截方法调用、生命周期回调事件和超时事件。
- en: Interceptors allow you to intercept method calls as well as the outbreak of
    some events. During the interception, you can access the method name, method parameters,
    and a lot of other information. That said, the interceptors can be used to manage
    cross cutting concerns such as logging, auditing, security (to ensure that a user
    has the right to execute a method), and modification of the method parameters.
    You can define them in a dedicated class or within the target class directly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器允许你拦截方法调用以及某些事件的爆发。在拦截过程中，你可以访问方法名、方法参数以及大量其他信息。也就是说，拦截器可以用来管理横切关注点，如日志记录、审计、安全（确保用户有执行方法的权限）以及修改方法参数。你可以在专用类或目标类中直接定义它们。
- en: 'The signature of an interceptor is as follows: `Object <method_name>(InvocationContext
    ctx) throws Exception { ... }"` and to `void <method_name>(InvocationContext ctx)
    { ... }`. It can throw an exception of type `Exception` and should be decorated
    with an annotation that defines the type of elements it must intercept. For example,
    `@AroundInvoke` to intercept methods and `@AroundTimeout` to intercept services''
    timers. Failing to use these annotations, you can always make use of XML configuration.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器的签名如下：`Object <method_name>(InvocationContext ctx) throws Exception { ...
    }` 和 `void <method_name>(InvocationContext ctx) { ... }`。它可以抛出`Exception`类型的异常，并且应该用定义它必须拦截的元素类型的注解来装饰。例如，使用`@AroundInvoke`来拦截方法，使用`@AroundTimeout`来拦截服务的定时器。如果没有使用这些注解，你总是可以利用XML配置。
- en: Defining interceptors in the target class
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在目标类中定义拦截器
- en: The following code shows a session bean with method and timer service interceptors.
    The service timer interceptor (`targetClassTimerInterceptor`) only does the logging,
    while the method interceptor (`targetClassMethodInterceptor`), in addition to
    a little logging, demonstrates how to access and modify the parameters of an intercepted
    method. In this case, we check that the names of candidates start with `Sir`,
    if this is not the case, it is added.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一个包含方法和定时服务拦截器的会话bean。服务定时拦截器（`targetClassTimerInterceptor`）只进行日志记录，而方法拦截器（`targetClassMethodInterceptor`），除了进行一些日志记录外，还演示了如何访问和修改被拦截方法的参数。在这种情况下，我们检查候选人的名字是否以`Sir`开头，如果不是，则添加。
- en: 'The following code is an example of a session bean containing interceptors:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个包含拦截器的会话bean的示例：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Defining interceptors in an interceptor class
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在拦截器类中定义拦截器
- en: The following code shows a class that can be used as an interceptor. To complete
    this class, we extract the interceptor methods contained in the `StudentSessionBean`
    class. As you can see, this class has no special annotation. But to be explicit,
    you can decorate it with `javax.interceptor.Interceptor` annotation (in our case,
    we have not done it to show you that this is optional).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一个可以作为拦截器使用的类。为了完成这个类，我们从`StudentSessionBean`类中提取了拦截器方法。正如你所见，这个类没有特殊的注解。但为了明确起见，你可以用`javax.interceptor.Interceptor`注解来装饰它（在我们的例子中，我们没有这样做，以展示这是可选的）。
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The following code shows how to declare an interceptor class in order to intercept
    some processes of a given class. The result is the same as what you get in the
    case of the `StudentSessionBean` class presented in the preceding code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何声明一个拦截器类以拦截给定类的某些过程。结果与前面代码中展示的`StudentSessionBean`类的情况相同。
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Latest improvements in action
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最新改进在行动中
- en: 'For all the new features added to the Interceptors 1.2 Specification, the most
    important are certainly: adding of a lifecycle callback interceptor for constructors,
    adding of standard annotation for managing the execution order of interceptors,
    and finally, the transfer of interceptor binding from the CDI Specification to
    Interceptors Specification 1.2.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于添加到拦截器1.2规范的所有新功能，最重要的是：为构造函数添加生命周期回调拦截器、添加用于管理拦截器执行顺序的标准注解，以及最后，将拦截器绑定从CDI规范转移到拦截器规范1.2。
- en: Intercept constructor invocation
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拦截构造函数调用
- en: Due to the `@AroundConstruct` annotation, you can define an interceptor that
    will run just before the creation of the target instance to intercept the execution
    of the target instance constructor. Interceptor methods decorated with this annotation
    should not be defined in the target class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`@AroundConstruct`注解，你可以定义一个在目标实例创建之前运行的拦截器，以拦截目标实例构造函数的执行。带有此注解的拦截器方法不应定义在目标类中。
- en: The following code demonstrates how to use the `@AroundConstruct`. The example
    is to record the time at which the different methods have been called to be sure
    that the method `@AroundConstruct` is indeed run before the constructor. It also
    shows you how to access the name of the constructor and its parameters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何使用`@AroundConstruct`。示例是记录不同方法被调用的时刻，以确保`@AroundConstruct`方法确实在构造函数之前运行。它还展示了如何访问构造函数的名称及其参数。
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Associating an interceptor with a class using interceptor binding
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用拦截器绑定将拦截器与类关联
- en: '*Associating Interceptors using Interceptor Bindings*, Chapter 3 of the *Interceptors
    1.2 Specification Document*, was extracted from Chapter 9 of the *CDI Specification
    Document*. It discusses the possibility of using annotations to associate interceptors
    with another component that is not an interceptor. To make this possible you must:
    create an interceptor binding type, declare the interceptor bindings, and bind
    this interceptor to the desired component.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用拦截器绑定关联拦截器*，来自*拦截器1.2规范文档*的第3章，是从*CDI规范文档*的第9章中提取出来的。它讨论了使用注解将拦截器与另一个非拦截器的组件关联的可能性。为了实现这一点，你必须：创建拦截器绑定类型，声明拦截器绑定，并将此拦截器绑定到所需的组件上。'
- en: Creation of interceptor binding types
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建拦截器绑定类型
- en: 'The interceptor binding type is created exactly like a simple annotation, except
    that it adds at least the `@InterceptorBinding` among the annotations used to
    define the characteristic of the interceptor binding. The following code shows
    the declaration of an interceptor binding type to log some information:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器绑定类型的创建方式与简单的注解完全相同，只是在定义拦截器绑定特性的注解中添加了至少一个`@InterceptorBinding`。以下代码展示了如何声明一个用于记录一些信息的拦截器绑定类型：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Declaring interceptor binding
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 声明拦截器绑定
- en: 'We can declare interceptor binding by annotating an interceptor with the interceptor
    binding type and the `@javax.interceptor.Interceptor` annotation. The following
    code demonstrates how to declare an interceptor binding:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用拦截器绑定类型和`@javax.interceptor.Interceptor`注解来声明拦截器绑定。以下代码演示了如何声明拦截器绑定：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Binding an interceptor by using interceptor binding type
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用拦截器绑定类型绑定拦截器
- en: 'After all these operations, it is up to you to decorate a non interceptor component
    with the interceptor binding types to bind the interceptor to a component. The
    following code demonstrates how to bind the `LoggerInterceptor` interceptor to
    our EJB:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些操作后，你需要使用拦截器绑定类型来装饰一个非拦截器组件，以便将拦截器绑定到组件上。以下代码演示了如何将`LoggerInterceptor`拦截器绑定到我们的EJB上：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By default, the interceptor is not enabled. To do this, you must declare the
    interceptor in the `bean.xml` file as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，拦截器是禁用的。为了做到这一点，你必须像以下这样在`bean.xml`文件中声明拦截器：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Defining the execution order of interceptors
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义拦截器的执行顺序
- en: When we talked about the CDI Specification in the [Chapter 7](ch07.html "Chapter 7. Annotations
    and CDI"), *Annotations and CDI*, we discussed adding the `@Priority` annotation.
    This annotation was adopted by the Interceptors 1.2 Specification and permits
    us to define an execution order for interceptors that were declared with interceptor
    bindings. When using this annotation, the interceptor with the smallest priority
    is called first. The following code demonstrates how to use this annotation. In
    our case, the `LoggerInterceptor` interceptor will be called before the `LoggerInterceptor1`
    interceptor.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第7章](ch07.html "第7章。注解和CDI")中讨论CDI规范时，*注解和CDI*，我们讨论了添加`@Priority`注解。这个注解被拦截器1.2规范所采用，并允许我们为使用拦截器绑定声明的拦截器定义执行顺序。当使用这个注解时，具有最小优先级的拦截器首先被调用。以下代码演示了如何使用这个注解。在我们的例子中，`LoggerInterceptor`拦截器将在`LoggerInterceptor1`拦截器之前被调用。
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In parallel to this the annotation permits us to enable the interceptors. In
    other words, it saves you from using the `<interceptors>` element in the `bean.xml`
    file as we did in the preceding case.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，该注解允许我们启用拦截器。换句话说，它让你免于在`bean.xml`文件中使用`<interceptors>`元素，就像我们在前面的例子中所做的那样。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: At the end of this chapter, we are now able to validate inputs on JSF forms
    and the data that will be manipulated by an application through the Bean Validation
    Specification. We also learned how to intercept different types of processes such
    as the creation of an object, invocation of a method, or service timer execution
    in order to audit or modify a method's parameters. In the next chapter, we will
    end our journey into the Java EE 7 world by addressing the security aspect of
    our online preregistration application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们现在能够通过Bean Validation规范验证JSF表单的输入以及应用程序将要操作的数据。我们还学习了如何拦截不同类型的流程，例如对象的创建、方法的调用或服务定时器的执行，以便审计或修改方法的参数。在下一章中，我们将通过解决我们在线预注册应用程序的安全方面，结束我们对Java
    EE 7世界的探索之旅。
