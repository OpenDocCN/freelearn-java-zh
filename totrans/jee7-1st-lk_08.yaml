- en: Chapter 8. Validators and Interceptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will see data validation with constraints. This will give
    us the opportunity to put a small part of **AOP** (**Aspect Oriented Programming**)
    in action and discover the novelties in the validation and interception APIs.
    The specifications concerned are:'
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation 1.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interceptors 1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bean Validation 1.1 Specification was developed under JSR 349\. This section
    just gives you an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: We are almost at the end of the realization of our online preregistration application.
    In the previous chapters, we developed the different layers of our application
    and now we need to validate the data that will be handled by this application.
  prefs: []
  type: TYPE_NORMAL
- en: Validating your data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java language provides for Java SE and Java EE developers the Bean Validation
    Specification, which allows us to express constraints on objects. By default,
    it offers a small number of constraints (compared to the needs that you may have)
    called built-in constraints (see the following table). But, it gives you the opportunity
    to combine these constraints in order to make much more complex constraints (custom
    constraints) that suit your needs. This is what makes its power. This specification
    can be used in conjunction with many other specifications such as CDI, JSF, JPA,
    and JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of the built-in constraints in Bean Validation 1.1 is shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constraint | Supported type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@Null` | `Object` | This ensures that the value of the object is null |'
  prefs: []
  type: TYPE_TB
- en: '| `@NotNull` | `Object` | This ensures that the value of the object is not
    null |'
  prefs: []
  type: TYPE_TB
- en: '| `@AssertTrue` | `boolean`, Boolean | This ensures that the value of the object
    is true |'
  prefs: []
  type: TYPE_TB
- en: '| `@AssertFalse` | `boolean`, Boolean | This ensures that the value of the
    object is false |'
  prefs: []
  type: TYPE_TB
- en: '| `@Min` | `BigDecimal`, `BigInteger` `byte`, `short`, `int`, `long`, and the
    respective wrappers (such as `Byte` and `Short`) | This ensures that the value
    of the object is greater than or equal to the value specified in the annotation
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@Max` | `BigDecimal`, `BigInteger` `byte`, `short`, `int`, `long`, and the
    respective wrappers (such as `Byte` and `Short`) | This ensures that the value
    of the object is less than or equal to the value specified in the annotation |'
  prefs: []
  type: TYPE_TB
- en: '| `@DecimalMin` | `BigDecimal`, `BigInteger`, `CharSequence``byte`, `short`,
    `int`, `long`, and the respective wrappers (such as `Byte` and `Short`) | This
    ensures that the value of the object is greater than or equal to the value specified
    in the annotation |'
  prefs: []
  type: TYPE_TB
- en: '| `@DecimalMax` | `BigDecimal`, `BigInteger`, `CharSequence``byte`, `short`,
    `int`, `long`, and the respective wrappers (such as `Byte` and `Short`) | This
    ensures that the value of the object is less than or equal to the value specified
    in the annotation |'
  prefs: []
  type: TYPE_TB
- en: '| `@Size` | `CharSequence`, `Collection`, `Array`, and `Map` | This ensures
    that the size of the object is in the defined range |'
  prefs: []
  type: TYPE_TB
- en: '| `@Digits` | `BigDecimal`, `BigInteger`, `CharSequence``byte`, `short`, `int`,
    `long`, and the respective wrappers (such `asByte` and `Short`) | This ensures
    that the value of the object is in the defined range |'
  prefs: []
  type: TYPE_TB
- en: '| `@Past` | `java.util.Date` and `java.util.Calendar` | This ensures that the
    date contained in the object is prior to the date of treatment |'
  prefs: []
  type: TYPE_TB
- en: '| `@Future` | `java.util.Date` and `java.util.Calendar` | This ensures that
    the date contained in the object is later than the date of treatment |'
  prefs: []
  type: TYPE_TB
- en: '| `@Pattern` | `CharSequence` | This ensures that value of the item meets the
    regular expression defined in the annotation |'
  prefs: []
  type: TYPE_TB
- en: 'One advantage of this specification is the ability to define the different
    constraints it offers via annotations, which facilitates its use. According to
    the characteristics of the annotation (explained in detail in [Chapter 7](ch07.html
    "Chapter 7. Annotations and CDI"), *Annotations and CDI*), you can express constraints
    for a class, field, or property. The following example shows a `Student` entity
    whose fields are decorated with the built-in constraints. You can see the constraints
    to avoid the null value or to define the size and format of attributes in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the constraints are defined, the Bean Validation Specification allows
    you to validate the data under constraints manually or automatically through other
    specifications. We begin by presenting manual validation. The following example
    demonstrates how to validate the constraints of a class manually. We must say
    that the `Validator` API also provides methods to validate a single attribute
    or a specific value as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned, the Bean Validation Specification can be combined with other
    specifications. In the example that follows, we present the coupling between Bean
    Validation and JSF. We take this opportunity to highlight automatic validation.
    The example that follows demonstrates how to validate the input of a student in
    our online preregistration website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following code shows an example of the content of the web page allowing
    candidates to enter their personal identification. As you can see, we used the
    pass through attribute explained in [Chapter 3](ch03.html "Chapter 3. The Presentation
    Layer"), *The Presentation Layer*, to use the calendar of HTML5 and we put the
    tag `<h:message/>` next to each field with the ID of the concerned field in order
    to display error messages in case of violation of the constraint. This allows
    us to have the screen capture shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of the contents of the `identificationInformationPage.xml`
    JSF page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the following screenshot, when submitting the entry, the contents
    of the form will automatically be validated and error messages will be returned
    to the form. Thus, this association (JSF and Bean validation) allows you to define
    the constraints on a single bean and use it for multiple forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the validation is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating your data](img/923-5_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building a custom constraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we wanted to have a constraint that allows us to ensure
    that the value of the `Gender` field was entered in uppercase, but this constraint
    does not exist explicitly. To do this, we must have some knowledge of regular
    expressions and use the `@Pattern` annotation. This requires some background.
    Fortunately, we have the ability to create custom constraints. We will set up
    a constraint that allows us to perform this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of a new constraint substantially follows the same rules as the
    creation of a simple annotation (as explained [Chapter 7](ch07.html "Chapter 7. Annotations
    and CDI"), *Annotations and CDI*). The fundamental difference lies in the fact
    that instead of implementing a processor, we will implement a validator in the
    case of constraints. That said, the creation of a custom constraint includes the
    following steps: creating a constraint annotation and implementing a validator.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a constraint annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the goal is to create a constraint that ensures that a string character
    is capitalized, we will create a generic annotation. This annotation will take
    as parameter the type of the expected case. Thus, it may, in the future, allow
    us to test if the characters are uppercase or lowercase .
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the enumeration `CaseType`, which contains different types of
    case, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have defined the possible types of cases, we will create our annotation
    and define its characteristics directly. Already, it should be noted that in addition
    to the basic features we''ve seen in the creation of annotations, you''ll have
    to add the `@Constraint` annotation that defines the validator of this constraint.
    For other features, please refer to [Chapter 7](ch07.html "Chapter 7. Annotations
    and CDI"), *Annotations and CDI*. The following code is the code of our annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a validator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of a processor that is required for simple annotations, constraints
    need to implement the `javax.validation.ConstraintValidator <A extends Annotation,
    T extends Object>` interface, which provides two methods that are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void initialize(A constraintAnnotation)`: This method is always called before
    processing a constraint. It allows you to initialize the parameters that will
    be useful during the execution of the `isValid()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isValid(T value, ConstraintValidatorContext context)`: This method
    contains the validation logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the validator of our constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After you create your validator, you must register the service (see [Chapter
    7](ch07.html "Chapter 7. Annotations and CDI"), *Annotations and CDI*). Then,
    import the package containing your annotation. The following screenshot shows
    the structure of the project in which we have defined our annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a validator](img/923-5_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we just need to add `@Case (type = CaseType.UPPER)` on an attribute of
    type `String` to ensure that the value will always be in capital letters. The
    following code shows the change in the `InscriptionBean` Bean code that was presented
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And the result is simply beautiful, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a validator](img/923-5_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Latest improvements in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chapter 2 of the *Bean* *Validation 1.1 Specification Document* presents the
    major changes of this version. These are: openness, support for dependency injection,
    better integration with CDI, support for method and constructor validation, support
    for group conversion, and finally support for message interpolation using expression
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: Openness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of the Bean Validation 1.1 Specification has been managed
    as an open source project. Thus, the source code, reference implementation and
    test compatibility kit of the API are accessible to the community. For more information,
    please access the site [http://beanvalidation.org](http://beanvalidation.org).
  prefs: []
  type: TYPE_NORMAL
- en: Support for dependency injection and CDI integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Bean Validation 1.1 Specification has standardized the management of objects
    used to implement validators inside a container and reviewed all the services
    that were offered to these objects. That helped support dependency injection in
    Bean Validation components and improve integration with CDI. Henceforth, we can
    use the `@Resource` and `@Inject` annotations to inject objects of type `ValidatorFactory`
    and `Validator`. The following example demonstrates the use of the `@Inject` annotation
    to validate an object using Bean Validation components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Support for method and constructor validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Bean Validation Specification 1.1 has added the ability to define constraints
    on the parameters of a method or constructor. It also allows the definition of
    the constraints on the return value of a method. The following code demonstrates
    how to declare and validate constraints on the parameters of a method and its
    return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Support for group conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While cascading a data validation, it may happen that the data to validate
    belongs to groups that are different from the requested group. For a concrete
    example, consider the following two classes `Student` and `Address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the validation of an object step-by-step, the Bean Validation Specification
    proposes the notion of groups. This gives you the ability to define a subset of
    constraints that can be validated separately. By default, validation constraints
    belongs to the `Default` group. And if a validation group is not specified when
    validating data, only the constraints of the `Default` group will be checked.
    This justifies the fact that the code of the `testDefaultGroup()` method will
    run entirely without errors. Although the phone and the e-mail attributes of the
    `Address` class are not conformed to the constraints, they will not be validated
    for the simple reason that the constraints that decorate them are not a part of
    the `Default` group. This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to validate the attributes of the `Address` object at the same time as
    the validation of the `Student` object, you have two options. The first is to
    list all the groups in the `validate()` method as is the case in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The second method is to use the concept of group conversion via the `@ConvertGroup`
    or `@ConvertGroup.List` for several conversions. As its name implies, this feature
    gives you the ability to perform conversions from one group to another to validate
    attributes whose constraints belong to a group different from the requested group.
    The following code shows the changes that should be added on the `Address` attribute
    of the `Student` class in order to take advantage of the group conversion feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following code shows the joint validation attributes of the `Student` object
    and attributes of the `Address` object after using the `@ConvertGroup` annotation.
    As you can see in the following code, we did not have to list all the groups of
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how to use the `@ConvertGroup.List` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Support message interpolation using expression language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With this version of the specification, it is possible to use expression language
    when defining the error message. It helps in better formatting of the message
    and the use of conditions in the description of the message. The following code
    shows a possible use of expression language in the definition of an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Interceptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Interceptors 1.2 Specification was developed under JSR 318\. This section
    just gives you an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr318/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr318/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting some processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interceptors are a Java mechanism that allows us to implement some concepts
    of AOP, in the sense that they give us the ability to separate the code from the
    crosscutting concerns such as logging, auditing, and security. Thus, due to this
    specification, we can intercept invocations of methods, lifecycle callback events,
    and timeout events.
  prefs: []
  type: TYPE_NORMAL
- en: Interceptors allow you to intercept method calls as well as the outbreak of
    some events. During the interception, you can access the method name, method parameters,
    and a lot of other information. That said, the interceptors can be used to manage
    cross cutting concerns such as logging, auditing, security (to ensure that a user
    has the right to execute a method), and modification of the method parameters.
    You can define them in a dedicated class or within the target class directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of an interceptor is as follows: `Object <method_name>(InvocationContext
    ctx) throws Exception { ... }"` and to `void <method_name>(InvocationContext ctx)
    { ... }`. It can throw an exception of type `Exception` and should be decorated
    with an annotation that defines the type of elements it must intercept. For example,
    `@AroundInvoke` to intercept methods and `@AroundTimeout` to intercept services''
    timers. Failing to use these annotations, you can always make use of XML configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining interceptors in the target class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code shows a session bean with method and timer service interceptors.
    The service timer interceptor (`targetClassTimerInterceptor`) only does the logging,
    while the method interceptor (`targetClassMethodInterceptor`), in addition to
    a little logging, demonstrates how to access and modify the parameters of an intercepted
    method. In this case, we check that the names of candidates start with `Sir`,
    if this is not the case, it is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a session bean containing interceptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Defining interceptors in an interceptor class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code shows a class that can be used as an interceptor. To complete
    this class, we extract the interceptor methods contained in the `StudentSessionBean`
    class. As you can see, this class has no special annotation. But to be explicit,
    you can decorate it with `javax.interceptor.Interceptor` annotation (in our case,
    we have not done it to show you that this is optional).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The following code shows how to declare an interceptor class in order to intercept
    some processes of a given class. The result is the same as what you get in the
    case of the `StudentSessionBean` class presented in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Latest improvements in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For all the new features added to the Interceptors 1.2 Specification, the most
    important are certainly: adding of a lifecycle callback interceptor for constructors,
    adding of standard annotation for managing the execution order of interceptors,
    and finally, the transfer of interceptor binding from the CDI Specification to
    Interceptors Specification 1.2.'
  prefs: []
  type: TYPE_NORMAL
- en: Intercept constructor invocation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the `@AroundConstruct` annotation, you can define an interceptor that
    will run just before the creation of the target instance to intercept the execution
    of the target instance constructor. Interceptor methods decorated with this annotation
    should not be defined in the target class.
  prefs: []
  type: TYPE_NORMAL
- en: The following code demonstrates how to use the `@AroundConstruct`. The example
    is to record the time at which the different methods have been called to be sure
    that the method `@AroundConstruct` is indeed run before the constructor. It also
    shows you how to access the name of the constructor and its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Associating an interceptor with a class using interceptor binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Associating Interceptors using Interceptor Bindings*, Chapter 3 of the *Interceptors
    1.2 Specification Document*, was extracted from Chapter 9 of the *CDI Specification
    Document*. It discusses the possibility of using annotations to associate interceptors
    with another component that is not an interceptor. To make this possible you must:
    create an interceptor binding type, declare the interceptor bindings, and bind
    this interceptor to the desired component.'
  prefs: []
  type: TYPE_NORMAL
- en: Creation of interceptor binding types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The interceptor binding type is created exactly like a simple annotation, except
    that it adds at least the `@InterceptorBinding` among the annotations used to
    define the characteristic of the interceptor binding. The following code shows
    the declaration of an interceptor binding type to log some information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Declaring interceptor binding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can declare interceptor binding by annotating an interceptor with the interceptor
    binding type and the `@javax.interceptor.Interceptor` annotation. The following
    code demonstrates how to declare an interceptor binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Binding an interceptor by using interceptor binding type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After all these operations, it is up to you to decorate a non interceptor component
    with the interceptor binding types to bind the interceptor to a component. The
    following code demonstrates how to bind the `LoggerInterceptor` interceptor to
    our EJB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the interceptor is not enabled. To do this, you must declare the
    interceptor in the `bean.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Defining the execution order of interceptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we talked about the CDI Specification in the [Chapter 7](ch07.html "Chapter 7. Annotations
    and CDI"), *Annotations and CDI*, we discussed adding the `@Priority` annotation.
    This annotation was adopted by the Interceptors 1.2 Specification and permits
    us to define an execution order for interceptors that were declared with interceptor
    bindings. When using this annotation, the interceptor with the smallest priority
    is called first. The following code demonstrates how to use this annotation. In
    our case, the `LoggerInterceptor` interceptor will be called before the `LoggerInterceptor1`
    interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In parallel to this the annotation permits us to enable the interceptors. In
    other words, it saves you from using the `<interceptors>` element in the `bean.xml`
    file as we did in the preceding case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of this chapter, we are now able to validate inputs on JSF forms
    and the data that will be manipulated by an application through the Bean Validation
    Specification. We also learned how to intercept different types of processes such
    as the creation of an object, invocation of a method, or service timer execution
    in order to audit or modify a method's parameters. In the next chapter, we will
    end our journey into the Java EE 7 world by addressing the security aspect of
    our online preregistration application.
  prefs: []
  type: TYPE_NORMAL
