- en: Chapter 2. Building Java Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw a very basic build script, which just printed
    the customary `Hello World` on the console. Now that we are comfortable with the
    Gradle command line interface, it's a perfect time for us to jump-start our journey
    with a simple Java project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to build and test simple Java projects with
    Gradle, how external dependencies are added to the classpath, and how building
    distributable binaries work.
  prefs: []
  type: TYPE_NORMAL
- en: We will try to keep the Java code as minimal as possible so that we can focus
    more on the build of the project. Along the way, we will learn some best practices
    that a Gradle-based project should follow. It's okay if we are not able to comprehend
    all the build script syntax in this chapter because we are going to see that in
    detail in [Chapter 4](part0028_split_000.html#QMFO2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 4. Demystifying Build Scripts"), *Demystifying Build Scripts*.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple Java project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the Java project's build with Gradle, let's create a very simple
    Java application that will greet a user. Just a tad bit more than a `hello world`
    in terms of application logic.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, create a directory called `hello-java`. This is our project directory.
    For the following steps, feel free to choose an IDE/text editor of your choice
    for editing the files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a build file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the root of the project directory, let''s create the `build.gradle` file
    and add the following code line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Yes, that's all that goes into the build file for now, a single line. We will
    soon see what it means.
  prefs: []
  type: TYPE_NORMAL
- en: Adding source files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, like Maven, the Java source files are read from the `src/main/java`
    directory of the project. We can configure this, of course, but let's save that
    for later. Let's create this directory structure in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create a Java class that would generate the greeting message.
    Also, we would create a `Main` class with a `main` method so that an app can be
    run from a command line. The Java files should be kept in a source root directory
    under a proper package structure. We will use the `com.packtpub.ge.hello` package
    for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding structure, we have created the package structure
    under the `src/main/java` source root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `GreetingService.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This class exposes just one method called `greet`, which we can use to generate
    a greeting message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how our `Main.java` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This class has a `main` method, which will be invoked when a program is run.
    It instantiates the `GreetingService` and prints the output of the `greet` method
    on a console.
  prefs: []
  type: TYPE_NORMAL
- en: Building the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After adding the Java files, we now want to compile the project and produce
    the class files. It can be simply done by calling the following task from a command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiled classes go into `build/classes/main` relative to the project root.
    You can confirm by checking the project tree again. We will ignore other files
    and directories for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can directly run the class, but let''s ask for more and generate
    the `.jar` file for our application. Let''s run the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces a Jar for our project in the `build/libs` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test if the Jar works as expected. To run the Jar, issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are passing the `Reader` as an argument to our java `Main` class ''s `main`
    method. This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we run the `build` task, Gradle also invokes the `compileJava` and other
    dependent tasks before actually executing the build task. So, we don't need to
    explicitly call `compileJava` here to compile classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the `.jar` file is the same as that of the project. This can be
    configured by setting the `archivesBaseName` property in the `build.gradle` file.
    For example, to generate the Jar named `my-app.jar`, add the following code line
    to the build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s fire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Also, check the directory tree again. No surprise, it's cleaned keeping the
    source files intact.
  prefs: []
  type: TYPE_NORMAL
- en: We know from our experiences with Ant that, even for the project of this size,
    we would have to define at least a handful of targets and this would be quite
    a few lines of XML. While Maven would have worked by convention, still the Maven's
    `pom.xml` needs some ceremony before it's even a valid `pom.xml` file. So, a minimal
    `pom.xml` file would still look like five to six lines of XML.
  prefs: []
  type: TYPE_NORMAL
- en: Compare that with the simplicity and carefully chosen sensible defaults by Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good point where we should see what all tasks were brought into our
    build by the `java` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is interesting to see so many useful tasks available on our build by merely
    applying the `java` plugin. Clearly, Gradle employs a very powerful plugin mechanism
    that can be leveraged to apply the **don't repeat yourself** (**DRY**) principle
    on build logic.
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gradle by itself is nothing more than a task runner. It does not know how to
    compile a Java file or where to read the source files. It means that these tasks
    are not there by default. As we saw in the last chapter, a Gradle build file,
    without any plugin applied, contained very few tasks.
  prefs: []
  type: TYPE_NORMAL
- en: A plugin adds relevant tasks and conventions to a Gradle build. In our current
    example, all the tasks such as `compileJava`, `build`, `clean`, and many more
    are essentially brought in by the `java` plugin that we applied to our build.
  prefs: []
  type: TYPE_NORMAL
- en: This means, Gradle does not force us to use a particular way to compile a Java
    project. It's completely up to us to choose the `java` plugin for our build. We
    can configure it to suite our needs. If we still don't like the way it works,
    we are free to add our own tasks directly to the build or through a custom plugin
    that will work the way we want.
  prefs: []
  type: TYPE_NORMAL
- en: There are number of plugins that come out of the box with Gradle. The `java`
    plugin is one such plugin. Throughout the course of this book, we will see many
    such plugins, which will bring in a lot of interesting functionality to our build.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is an indispensable aspect of software development. Testing gives
    us confidence that our code works fine and provides us a safety net when refactoring.
    Fortunately, Gradle's Java plugin makes it simple and easy to unit test your code.
  prefs: []
  type: TYPE_NORMAL
- en: We will write a simple test for the same example app we created above. We will
    create our first unit test now using JUnit (v4.12) library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about JUnit can be found at [http://junit.org](http://junit.org).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a unit test source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, like Maven, Java test sources are kept in the `src/test/java` directory
    relative to the project root. We will create this directory and, as a good practice,
    the test package structure will reflect the same hierarchy as the source packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add test for the `GreetingService`. By convention, the name of test
    will be `GreetingServiceTest.java`. The following is the code of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The test sets up an instance of **System Under Test** (**SUT**), which is `GreetingService`,
    and the `testGreet` method checks the equality of the SUT's `greet` methods output
    to get the expected message.
  prefs: []
  type: TYPE_NORMAL
- en: Now, take a moment and try to compile tests by using the `compileTestJava` task,
    which is exactly the same as `compileJava`, but compiles the test source files.
    Did it compile just fine? If not, can we take a guess as to what could have gone
    wrong?
  prefs: []
  type: TYPE_NORMAL
- en: The task should have failed with a bunch of compilation errors because JUnit,
    which is an external library, was not on the classpath to compile the files.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the JUnit to the classpath
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compile and run this test case, we need JUnit library on the classpath.
    It is important to remember that this dependency is only required while compiling
    and running the tests. Our application does not depend on JUnit for its compilation
    or on runtime. We also need to tell where to search for this artifact so that
    Gradle can download it if there is a need. To do this, we need to update the `build.gradle`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are two additions to this build file, from what we already know.
  prefs: []
  type: TYPE_NORMAL
- en: In the `dependencies` section, we list down all the dependencies of the project
    along with their scope. We declared JUnit to be made available in the `testCompile`
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: In the `repositories` section, we configure the type and location of the repository
    where external dependencies will be found. In this example, we tell Gradle to
    get the dependencies from the Maven central repository. Since Maven central is
    a very commonly used repo, Gradle provides a shortcut to configure it thorough
    the `mavenCentral()` method call.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover both the sections in greater depth in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are interested in running the tests to check whether everything is working
    as expected. Let''s run the `test` task, which will also sequentially run all
    the tasks that the `test` task depends on. We can also verify this by looking
    at the output that lists all the tasks that have been run as part of this build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like the tests passed. To see how Gradle tells us when a test fails,
    let''s intentionally change the expected value in assertion to `Test Hello` so
    that the assertion fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the command again to see the result when the test fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Yes, so the test failed and the output tells you about the file and the line
    number as well. Also, it points you to the report file, which includes more details
    of the test failure.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing test reports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether the test passes or not, a nice HTML report is created with details of
    all the tests that are run. By default, this report is located at `build/reports/tests/index.html`
    relative to the project root. You can open this file in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the above failure, the report looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing test reports](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on the failed test, we get to see the details of the failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing test reports](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see `org.junit.ComparisonFailure: expected:<[Test Hello]> but was:<[Hello
    Test]>` in the first line of the stack trace.'
  prefs: []
  type: TYPE_NORMAL
- en: Fitting tests in the workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have tests in place, it makes sense to build our project binaries
    (`.jar`) only if the tests pass. For that, we need to define some kind of flow
    between the tasks such that, if a task fails, the pipeline is broken there and
    the subsequent tasks are not executed. So, in our examples, the build's execution
    should depend on the test's success.
  prefs: []
  type: TYPE_NORMAL
- en: Guess what, it has already been taken care by the `java` plugin for us. We just
    need to call the last task in the flow, and all the tasks that the called tasks
    depend on will be called sequentially and the build will not succeed if any of
    the tasks fails.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Also, we don't need to call all the tasks that the build depends on explicitly
    because they will be called anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s fix the test and see the Jar getting created again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Yay! So the tests have passed and we can build binaries of our app again.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how intelligently Gradle figures out that, if only tests were changed,
    it compiled only the tests. In the preceding output, `compileJava` shows `UP-TO-DATE`,
    means nothing was changed and, hence, Gradle didn't unnecessarily compile the
    source files again.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we need to force run task actions even if nothing has changed between the
    two runs, we can pass the `--rerun-tasks` flag on the command line so that all
    task actions can run.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we see the test reports again, they will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting tests in the workflow](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the **Test Summary** will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting tests in the workflow](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bundling an application distributable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first example, we ran our application by using the `java` command directly
    from the command line. Usually, such command-line applications are shipped with
    scripts to run the application so that the end user need not always write the
    whole command by hand. Also, while developing, we repeatedly need to run the app.
    It would be nicer if we could write a task in our build file such that an app
    can be run in one Gradle invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that there already exists such a plugin called `application`,
    shipped with Gradle, which can do both for us. For this example, we will copy
    over the `hello-test` project as `hello-app`. Let''s make simple modifications
    to our `build.gradle` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The second line applies the `application` plugin to our build. To make this
    plugin work, we need to configure Gradle to use our `Main` entry point class,
    which has the static `main` method that needs to run when our application is run.
    We specified that on line `#4` by setting the `mainClassName` property that is
    added to the build by the `application` plugin. Finally, when we want to run the
    app using Gradle (that is, while developing), we need to provide some command-line
    arguments to our app. The `application` plugin adds the `run` task to our build.
    As we said earlier, tasks are objects and they have properties and methods just
    like any regular object. On line `#5`, we set the `args` property of the `run`
    task to a list with one element `Reader`, so whenever we execute the run task,
    `Reader` will be passed as a command-line argument to our main method. Those who
    have used IDEs to set **Run Configuration** can easily relate to this. The rest
    of the file is the same as the last example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding example, as we are applying the `application` plugin, it is
    not necessary to explicitly apply the `java` plugin as an `application` plugin
    implicitly applies the `java` plugin to our build.
  prefs: []
  type: TYPE_NORMAL
- en: It also implicitly applies the `distribution` plugin so that we get the tasks
    to package the application as a ZIP or TAR archive and also gets the task to install
    the application distribution locally.
  prefs: []
  type: TYPE_NORMAL
- en: More information on the `application` plugin can be found at [https://docs.gradle.org/current/userguide/distribution_plugin.html](https://docs.gradle.org/current/userguide/distribution_plugin.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we check the tasks that are available in our build, we see a few additions
    under the `Application tasks` and `Distribution tasks` groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Running the application with Gradle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first look at the `run` task. We will call this task with the `–q` flag
    to suppress other messages by Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we see the output on a console. This task really shines when we
    make changes and can run our app in one command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We changed our `GreetingService` for a moment to return "`Hola`" instead of
    "`Hello`" and see if run reflects the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it did.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One might wonder how to pass command-line arguments to run a task from the
    command line itself, instead of the build file, which is something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it doesn''t work this way. As Gradle can accept multiple task names
    from a command line, there is no way for Gradle to know whether `Reader` was an
    argument that needs to be passed to run a task, or it''s a task name itself. For
    example, the following command calls two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are, of course, some workarounds if you really need to pass the command
    line to the program at every invocation of a run task. One such way is to use
    the `–Pproperty=value` command-line option and then extract the property's value
    in the `run` task to send it as `args` to the program. The `–P` adds properties
    to the Gradle `Project`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, update the `run.args` in `build.gradle` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, then from command line provide the property value by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we provided the value of a property at the time of
    calling the `gradle` command.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could create a `gradle.properties` in project’s root parallel
    to the `build.gradle` file. In that case, for this example it would contain just
    `runArgs=world`. But it can declare more properties, which would be available
    in the build as properties on project object.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to declare properties as well, which can be found at [https://docs.gradle.org/current/userguide/build_environment.html](https://docs.gradle.org/current/userguide/build_environment.html).
  prefs: []
  type: TYPE_NORMAL
- en: Building the distribution archive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting task is `distZip`, which packages the application along
    with OS-specific start scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It would have generated the application distribution in ZIP format in the `build/distributions`
    relative to the project root. The name of the ZIP defaults to the project name.
    In this case, it would be `hello-app.zip`. This can be changed, if required, using
    the following property in `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s unzip the archive to see its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We see a pretty standard directory structure inside the ZIP. It contains a shell
    script and windows BAT script to run our app. Also, it contains the JAR file of
    our application. The `lib` directory also contains the application's runtime dependencies.
    We can configure the `distribution` plugin to add more files in our distributions
    such as Javadoc, README, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the script to verify that it works. Using command prompt, we can
    execute this command in Windows. For that use the `cd` command, and change the
    directory to the `bin` directory of the extracted ZIP file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On Mac OS X/Linux, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Generating IDE project files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDEs are an integral part of a Java developer's tool chain and workflow. However,
    manually setting up an IDE to correctly identify the project structure and dependencies
    for any moderately sized project is not an easy task.
  prefs: []
  type: TYPE_NORMAL
- en: Checking-in IDE-specific files or directories such as `.classpath`, `.project`,
    `.ipr`, `.iws`, `.nbproject`, `.idea`, `.settings`, `.iml`, is not a good idea.
    We know that some still do it because it's hard to generate the IDE file manually
    every time someone checks the project out of the version control system. However,
    checking in such files creates problems as they eventually go out of sync from
    the main build file. Also, this forces the whole team to use the same IDE and
    manually update the IDE files whenever there is a change in the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'How nice would it be if we could just check-in only those files that are necessary
    for a project to be built independent of IDE and let our build system generate
    a file specific to our favorite IDE? Our wish is granted. Also, here is the best
    part. The number of lines that you need to modify in your Gradle build file is
    only one. Gradle sports very nice plugins that can generate IDE-specific project
    files. Both IntelliJ IDEA and Eclipse are covered by their respective plugins.
    Depending on which IDE you want to support, you will either include `apply plugin:
    ''idea''` or `apply plugin: ''eclipse''`.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there is no harm in including both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from the command line, execute the following for Eclipse and IntelliJ
    IDEA, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It should generate IDE-specific files for you and now you can directly open
    a project in either of the IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure you ignore IDE-specific files in version control. For example, if
    you are using Git, consider adding the following entries in your `.gitignore`
    file to prevent someone from accidentally committing the IDE-specific files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started off this chapter by building a very simple Java project. We saw how
    the intelligent conventions of the `java` plugin helped us keep the build file
    concise. Then, we added unit tests to this project and included the JUnit library
    from the Maven central repository. We made the tests fail and checked the reports
    to see the explanation. Then, we saw how the application's distribution can be
    created using the `application` plugin. Finally, we saw the `idea` and `eclipse`
    plugins that help us generate the IDE-specific files for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we realized how powerful the plugin system in Gradle is. Gradle, out-of-the-box,
    ships with many interesting plugins, but we are not forced to use any of them.
    We will build a web application in the next chapter and also learn how configurations
    and dependency management works..
  prefs: []
  type: TYPE_NORMAL
