<html><head></head><body>
<div id="_idContainer096">
<h1 class="hapter-number" id="_idParaDest-112"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.2.1">Managing Multiple Bounded Contexts</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Many applications consist of more than one domain, or, to stick with </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.4.1">Domain-Driven Design language, more than one bounded context. </span><span class="koboSpan" id="kobo.4.2">The term “</span><strong class="bold"><span class="koboSpan" id="kobo.5.1">bounded context</span></strong><span class="koboSpan" id="kobo.6.1">” tells</span><a id="_idIndexMarker269"/><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.7.1"> us that there should be boundaries between the different domains. </span><span class="koboSpan" id="kobo.7.2">If we don’t have boundaries between different domains, there are no restrictions on dependencies between classes in these domains. </span><span class="koboSpan" id="kobo.7.3">Eventually, dependencies will grow between the domains, coupling them together. </span><span class="koboSpan" id="kobo.7.4">This coupling means that the domains can no longer evolve in isolation, but can only evolve together. </span><span class="koboSpan" id="kobo.7.5">We could just as well not have separated our code into different domains in the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">first place!</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">The whole reason to separate code into different domains is so that these domains can evolve in isolation. </span><span class="koboSpan" id="kobo.9.2">This is an application of the Single Responsibility Principle, discussed in </span><a href="B19916_03.xhtml#_idTextAnchor029"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.10.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.11.1">, </span><em class="itali"><span class="koboSpan" id="kobo.12.1">Inverting Dependencies</span></em><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">Only, this time, we’re not talking about the responsibilities of a single class, but about the responsibilities of a whole group of classes that make up a bounded context. </span><span class="koboSpan" id="kobo.13.3">If the responsibilities of one bounded context change, we don’t want to change the code for other </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">bounded contexts!</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Managing bounded contexts, that is, keeping the boundaries between them clear, is one of the main challenges of software engineering. </span><span class="koboSpan" id="kobo.15.2">Many of the pains developers associate with so-called “legacy software” stem from unclear boundaries. </span><span class="koboSpan" id="kobo.15.3">And it turns out that software doesn’t need long to </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">become “legacy.”</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">So, unsurprisingly (at least in retrospect), many readers of the first edition of this book asked me how to manage multiple bounded contexts with Hexagonal Architecture. </span><span class="koboSpan" id="kobo.17.2">Unfortunately, the answer is not simple. </span><span class="koboSpan" id="kobo.17.3">As is so often the case, there are multiple ways to go about it and none of them are right or wrong per se. </span><span class="koboSpan" id="kobo.17.4">Let’s discuss some ways of separating </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">bounded contexts.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.19.1">One hexagon per bounded context?</span></h1>
<p><span class="koboSpan" id="kobo.20.1">When working</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.21.1"> with Hexagonal Architecture and multiple bounded contexts, our reflex is to create a separate “hexagon” for each bounded context. </span><span class="koboSpan" id="kobo.21.2">The result would look something like </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.22.1">Figure 13</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.23.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.25.1"><img alt="Figure 13.1 – If each bounded context is implemented as its own hexagon, we need an outgoing port, an adapter, and an incoming port for each line of communication between bounded contexts" src="image/Figure_13.1._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.26.1">Figure 13.1 – If each bounded context is implemented as its own hexagon, we need an outgoing port, an adapter, and an incoming port for each line of communication between bounded contexts</span></p>
<p><span class="koboSpan" id="kobo.27.1">Each</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.28.1"> bounded context lives in its own hexagon, providing input ports to interact with it and using output ports to interact with the </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">outside world.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Ideally, the bounded contexts don’t need to talk to each other at all, so we don’t have any dependencies between the two. </span><span class="koboSpan" id="kobo.30.2">In the real world, however, this is rarely the case. </span><span class="koboSpan" id="kobo.30.3">Let’s assume that the bounded context on the left needs to call some functionality of the bounded context on </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">the right.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">If we use the architecture elements that Hexagonal Architecture provides us with, we add an output port to the first bounded context and an input port to the second bounded context. </span><span class="koboSpan" id="kobo.32.2">Then, we create an adapter that implements the output port, does any necessary mapping, and calls the input port of the second </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">bounded context.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Problem </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">solved, right?</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Indeed, on paper this looks like a very clean solution. </span><span class="koboSpan" id="kobo.36.2">The </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.37.1">bounded contexts are optimally separated from each other. </span><span class="koboSpan" id="kobo.37.2">The dependencies between them are clearly structured in the form of ports and adapters. </span><span class="koboSpan" id="kobo.37.3">New dependencies between bounded contexts require us to explicitly add them to the existing ports or to add a new port. </span><span class="koboSpan" id="kobo.37.4">It’s unlikely that dependencies creep in “by accident” because there is a lot of ritual involved in creating such </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">a dependency.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">If we think further than just two bounded contexts, however, it becomes apparent that this architecture doesn’t scale very well. </span><span class="koboSpan" id="kobo.39.2">For two bounded contexts with one dependency, we need to implement one adapter (the box </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.40.1">named </span><em class="itali"><span class="koboSpan" id="kobo.41.1">Domain Adapter</span></em><span class="koboSpan" id="kobo.42.1"> in the preceding figure). </span><span class="koboSpan" id="kobo.42.2">If we exclude circular dependencies, we might have to implement three adapters for three bounded contexts, six adapters for </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.43.1">four bounded contexts, and so on, as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.44.1">Figure 13</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.45.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">.</span></span><span class="No-Break"><span id="footnote-043-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-043"><span class="koboSpan" id="kobo.47.1">1</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-043">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-043-backlink"><span class="koboSpan" id="kobo.48.1">1</span></a><span class="koboSpan" id="kobo.49.1">	The formula I used to calculate the potential dependencies between </span><em class="itali"><span class="koboSpan" id="kobo.50.1">n</span></em><span class="koboSpan" id="kobo.51.1"> bounded contexts is </span><em class="itali"><span class="koboSpan" id="kobo.52.1">n-1 + n-2 + ... </span><span class="koboSpan" id="kobo.52.2">+ 1</span></em><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">The first bounded context has </span><em class="itali"><span class="koboSpan" id="kobo.54.1">n-1</span></em><span class="koboSpan" id="kobo.55.1"> potential, non-circular dependencies, the second </span><em class="itali"><span class="koboSpan" id="kobo.56.1">n-2</span></em><span class="koboSpan" id="kobo.57.1">, and so on. </span><span class="koboSpan" id="kobo.57.2">The last bounded context cannot have any dependency on another bounded context because every dependency it can have would be a circular dependency, and we don’t want to allow </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">circular dependencies</span></span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.60.1"><img alt="Figure 13.2 – The number of potential dependencies between bounded contexts grows disproportionately to the number of bounded contexts, even if we exclude circular dependencies" src="image/Figure_13.2._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 13.2 – The number of potential dependencies between bounded contexts grows disproportionately to the number of bounded contexts, even if we exclude circular dependencies</span></p>
<p><span class="koboSpan" id="kobo.62.1">For each dependency, we would have to implement one adapter with at least one associated input and output port. </span><span class="koboSpan" id="kobo.62.2">Each adapter would have to map from one domain model to another. </span><span class="koboSpan" id="kobo.62.3">This quickly becomes a chore to develop and maintain. </span><span class="koboSpan" id="kobo.62.4">If it’s a chore and requires more effort than it brings value, the team will take shortcuts to avoid it, resulting in an architecture that looks like a Hexagonal Architecture at first glance but doesn’t have the benefits </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">it promises.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">If we look at the original article introducing Hexagonal Architecture, it was never the intent of Hexagonal Architecture to encapsulate a single bounded context in ports and adapters.</span><span id="footnote-042-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-042"><span class="koboSpan" id="kobo.65.1">2</span></a></span><span class="koboSpan" id="kobo.66.1"> Instead, the intent is to encapsulate an </span><em class="itali"><span class="koboSpan" id="kobo.67.1">application</span></em><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">This application may consist of many bounded contexts or none </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">at all.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-042">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-042-backlink"><span class="koboSpan" id="kobo.70.1">2</span></a><span class="koboSpan" id="kobo.71.1">	The original article on Hexagonal Architecture: </span><a href="https://alistair.cockburn.us/hexagonal-architecture/"><span class="No-Break"><span class="koboSpan" id="kobo.72.1">https://alistair.cockburn.us/hexagonal-architecture/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.73.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.74.1">It </span><em class="itali"><span class="koboSpan" id="kobo.75.1">does </span></em><span class="koboSpan" id="kobo.76.1">make sense to wrap each bounded context in its own hexagon when we’re preparing to extract them into their own applications, that is, their own (micro)services. </span><span class="koboSpan" id="kobo.76.2">That means we should be very certain that the boundaries we’re putting between them are the right boundaries, however, and we don’t expect them </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">The takeaway here is that Hexagonal Architecture doesn’t provide a scalable solution for managing multiple bounded contexts in the same application. </span><span class="koboSpan" id="kobo.78.2">And it doesn’t have to. </span><span class="koboSpan" id="kobo.78.3">We can</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.79.1"> instead take inspiration from Domain-Driven Design to decouple our bounded contexts, because within a hexagon, we can do whatever </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">we like.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.81.1">Decoupled bounded contexts</span></h1>
<p><span class="koboSpan" id="kobo.82.1">In the previous section, we learned that the</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.83.1"> ports and adapters should encapsulate the whole application, not each bounded context separately. </span><span class="koboSpan" id="kobo.83.2">How do we keep the bounded contexts separate from each </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">other, then?</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">In a simple case, we might have bounded contexts that don’t communicate with each other. </span><span class="koboSpan" id="kobo.85.2">They provide completely separate paths through the code. </span><span class="koboSpan" id="kobo.85.3">In this case, we could build dedicated input and output ports for each bounded context like in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.86.1">Figure 13</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.87.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.89.1"><img alt="Figure 13.3 – If bounded contexts (dashed lines) don’t need to talk to each other, each can implement its own input ports and call its own output ports" src="image/Figure_13.3._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.90.1">Figure 13.3 – If bounded contexts (dashed lines) don’t need to talk to each other, each can implement its own input ports and call its own output ports</span></p>
<p><span class="koboSpan" id="kobo.91.1">This example shows a Hexagonal Architecture with two bounded contexts. </span><span class="koboSpan" id="kobo.91.2">A web adapter is driving the application and a database adapter is driven by the application. </span><span class="koboSpan" id="kobo.91.3">These adapters are representative of any other input and output adapters – not every application is a web application with </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">a database.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Each bounded context </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.94.1">exposes its own use cases via one or more dedicated input ports. </span><span class="koboSpan" id="kobo.94.2">The web adapter knows all input ports and thus can call the functionality of all </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">bounded contexts.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Instead of having dedicated input ports for each of our bounded contexts, we could also implement one “broad” input port through which the web adapter routes requests to </span><em class="itali"><span class="koboSpan" id="kobo.97.1">multiple </span></em><span class="koboSpan" id="kobo.98.1">bounded contexts. </span><span class="koboSpan" id="kobo.98.2">In this case, the boundaries between the contexts would be hidden from the outside of our hexagon. </span><span class="koboSpan" id="kobo.98.3">This may or may not be desirable depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the situation.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Furthermore, each bounded context defines its own output port to the database so that it can store and retrieve its data independently of any other </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">bounded context.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">While splitting the input ports per bounded context is optional, I would strongly recommend keeping the output ports that store and retrieve the domain data for a bounded context separate from other bounded contexts. </span><span class="koboSpan" id="kobo.102.2">If one bounded context is concerned with financial transactions and the other with user registrations, there should be one (or more) output port that is dedicated to storing and retrieving transaction data and another dedicated to storing and retrieving </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">registration data.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">Each bounded context should have its own persistence. </span><span class="koboSpan" id="kobo.104.2">If bounded contexts share output ports to store and retrieve data, they will quickly become strongly coupled because they both depend on the same data model. </span><span class="koboSpan" id="kobo.104.3">Imagine that we need to pull one bounded context out of the Hexagonal application and into its own microservice because we learned that it has different scalability requirements from the rest of the application. </span><span class="koboSpan" id="kobo.104.4">If that bounded context shares a database model with another bounded context, it becomes very hard to extract. </span><span class="koboSpan" id="kobo.104.5">We wouldn’t want the new microservice to reach into another application’s database, would we? </span><span class="koboSpan" id="kobo.104.6">For the same reason, we want to keep the database model of each bounded </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">context separate.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">As long as multiple bounded contexts are executed in the same runtime, they might share a physical database and participate in the same database transactions. </span><span class="koboSpan" id="kobo.106.2">But within that database, there should be clear boundaries between the data of different bounded contexts, for example, in the form of a separate database schema, or at least different </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">database tables.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Splitting up the input and output ports like this has the nice effect that the bounded contexts are completely decoupled. </span><span class="koboSpan" id="kobo.108.2">Each bounded context can evolve by itself without affecting the others</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.109.1"> in any way. </span><span class="koboSpan" id="kobo.109.2">But they are only decoupled because they’re not talking to each other. </span><span class="koboSpan" id="kobo.109.3">What if we have use cases that span multiple bounded contexts or if one bounded context needs to speak </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">to another?</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.111.1">Appropriately coupled bounded contexts</span></h1>
<p><span class="koboSpan" id="kobo.112.1">If all coupling could be </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.113.1">avoided, software architecture would be a lot easier. </span><span class="koboSpan" id="kobo.113.2">In real-world applications, a bounded context very likely needs the help of another bounded context to do </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">its work.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">An example is again our bounded context that is concerned with money transactions. </span><span class="koboSpan" id="kobo.115.2">For security reasons, we’ll want to log which user has issued a transaction. </span><span class="koboSpan" id="kobo.115.3">That means that our bounded context needs some information about the user, which lives in another bounded context. </span><span class="koboSpan" id="kobo.115.4">But our bounded context doesn’t need to be tightly coupled to the user </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">management context.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Instead of having to know the whole user object in our “transaction management” bounded context, it might be enough to just know the user’s ID. </span><span class="koboSpan" id="kobo.117.2">While a user object in the “registration” context is a complex object with many attributes, a representation of a user in the transaction context may only be a wrapper around the user ID. </span><span class="koboSpan" id="kobo.117.3">In the </span><em class="itali"><span class="koboSpan" id="kobo.118.1">Send money</span></em><span class="koboSpan" id="kobo.119.1"> use case, we could now just accept the ID of the user executing the transaction as input and then log it. </span><span class="koboSpan" id="kobo.119.2">We don’t need to couple the transaction context to all the other details of </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">a user.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">But we might want to validate that the user is not blocked from transactions. </span><span class="koboSpan" id="kobo.121.2">In this case, we can use a domain event.</span><span id="footnote-041-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-041"><span class="koboSpan" id="kobo.122.1">3</span></a></span><span class="supers ript"> </span><span class="koboSpan" id="kobo.123.1">Whenever the status of a user changes in the user management context, we trigger a domain event that can be received by other bounded contexts. </span><span class="koboSpan" id="kobo.123.2">Our transaction context might listen to events when a user is newly registered or has been blocked, for example. </span><span class="koboSpan" id="kobo.123.3">It can then store that information in its own database for later use in the </span><em class="itali"><span class="koboSpan" id="kobo.124.1">Send money</span></em><span class="koboSpan" id="kobo.125.1"> use case to validate the status of </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">the user.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-041">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-041-backlink"><span class="koboSpan" id="kobo.127.1">3</span></a><span class="koboSpan" id="kobo.128.1">	Events in Domain-Driven Design</span><em class="itali"><span class="koboSpan" id="kobo.129.1">: Implementing Domain-Driven Design</span></em><span class="koboSpan" id="kobo.130.1"> by Vaughn Vernon, Pearson, 2013, </span><a href="B19916_08.xhtml#_idTextAnchor071"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.131.1">Chapter 8</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.132.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.133.1">Another possible solution is to introduce an application service as the orchestrator between the user management and transaction contexts.</span><span id="footnote-040-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-040"><span class="koboSpan" id="kobo.134.1">4</span></a></span><span class="supers ript"> </span><span class="koboSpan" id="kobo.135.1">The application service implements the </span><em class="itali"><span class="koboSpan" id="kobo.136.1">Send money</span></em><span class="koboSpan" id="kobo.137.1"> input port. </span><span class="koboSpan" id="kobo.137.2">When called, it first asks the user management bounded context for the status of the user and then passes the status into the </span><em class="itali"><span class="koboSpan" id="kobo.138.1">Send money</span></em><span class="koboSpan" id="kobo.139.1"> use case provided by the transaction context – a different implementation, but the same effect as when using </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">domain events.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-040">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-040-backlink"><span class="koboSpan" id="kobo.141.1">4</span></a><span class="koboSpan" id="kobo.142.1">	Application Services in Domain-Driven Design</span><em class="itali"><span class="koboSpan" id="kobo.143.1">: Implementing Domain-Driven Design</span></em><span class="koboSpan" id="kobo.144.1"> by Vaughn Vernon, Pearson, 2013, </span><a href="B19916_14.xhtml#_idTextAnchor118"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.145.1">Chapter 14</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.146.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.147.1">These were just two examples of how to “appropriately” couple bounded contexts. </span><span class="koboSpan" id="kobo.147.2">If you haven’t yet, I recommend reading through the Domain-Driven Design literature to </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">get inspired.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">Coming back to </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.150.1">Hexagonal Architecture, appropriately coupling multiple bounded contexts may look something like in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.151.1">Figure 13</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.152.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.154.1"><img alt="Figure 13.4 – If we have use cases spanning multiple bounded contexts, we can introduce an application service to orchestrate and domain events to share information between contexts" src="image/Figure_13.4._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.155.1">Figure 13.4 – If we have use cases spanning multiple bounded contexts, we can introduce an application service to orchestrate and domain events to share information between contexts</span></p>
<p><span class="koboSpan" id="kobo.156.1">We have introduced an application service as the orchestrator above our bounded contexts. </span><span class="koboSpan" id="kobo.156.2">The input ports are now implemented by this service instead of by the bounded contexts themselves. </span><span class="koboSpan" id="kobo.156.3">The application service may call output ports to get the required information from other systems and then calls one or more domain services provided by the bounded contexts. </span><span class="koboSpan" id="kobo.156.4">In addition to orchestrating the calls to the bounded contexts, the application service also acts as a </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">transaction boundary </span></strong><span class="koboSpan" id="kobo.158.1">so that we can call multiple domain services in the same database transaction, </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">for example.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">The domain services within the bounded contexts each still use their own database output ports to keep the data model between the bounded contexts separated. </span><span class="koboSpan" id="kobo.160.2">We may decide that this separation is not necessary and use a single database output port instead (but we should be aware that sharing a data model leads to very </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">tight coupling).</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">The bounded contexts</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.163.1"> have access to a set of shared domain events that they can emit and listen to, respectively, to exchange information in a loosely </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">coupled fashion.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.165.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.166.1">Managing boundaries between domains is one of the hardest parts of software development. </span><span class="koboSpan" id="kobo.166.2">In a small code base, boundaries might not be necessary because the mental model of the whole code base still fits into our brain’s working memory. </span><span class="koboSpan" id="kobo.166.3">But as soon as the code base reaches a certain size, we should make sure to introduce boundaries between domains, so we can reason about each domain in isolation. </span><span class="koboSpan" id="kobo.166.4">If we don’t do this, dependencies will creep in, turning our code base into one of those dreaded “big balls </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">of mud.”</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">Hexagonal Architecture is all about managing a boundary between an application and the outside world. </span><span class="koboSpan" id="kobo.168.2">The boundary is made up of certain input ports provided by the application and certain output ports expected by </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">Hexagonal Architecture does not help us to manage finer-grained boundaries within our application. </span><span class="koboSpan" id="kobo.170.2">Inside our “hexagon,” we can do whatever we want. </span><span class="koboSpan" id="kobo.170.3">If the code base gets too big for our working memory, we should fall back to Domain-Driven Design or other concepts to create boundaries within our </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">In the next chapter, we will explore a lightweight method of creating boundaries that we can use with or without </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">Hexagonal Architecture.</span></span></p>
</div>
</body></html>