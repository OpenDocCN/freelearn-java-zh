- en: Epsilon GC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Epsilon GC
- en: Imagine that a software organization replaces its programmers with ones who
    don't know how to code, in order to calculate how long it will take for them to
    exhaust their funds and shut down. In this scenario, no new revenue is generated,
    while staff pay continues. In a similar manner, when you use the Epsilon **garbage
    collector** (**GC**), introduced in Java 11, the software application replaces
    its GC with Epsilon, which does not release memory—to calculate how long will
    it take for the **Java Virtual Machine** (**JVM**) to exhaust all its memory and
    shut down.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一个软件组织用不会编码的程序员替换了原来的程序员，以此来计算他们耗尽资金并关闭需要多长时间。在这种情况下，没有产生新的收入，而员工工资仍在继续。以类似的方式，当您使用在
    Java 11 中引入的 Epsilon **垃圾回收器**（**GC**）时，软件应用程序用 Epsilon 替换其 GC，它不会释放内存——以计算 Java
    虚拟机（**JVM**）耗尽所有内存并关闭需要多长时间。
- en: Epsilon is a **no-operation** (**no-op**) GC—that is, it doesn't collect any
    garbage. It only handles the allocation of memory. When the available Java heap
    is exhausted, the JVM shuts down.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Epsilon 是一个 **无操作**（**no-op**）GC——也就是说，它不会收集任何垃圾。它只处理内存分配。当可用的 Java 堆耗尽时，JVM
    关闭。
- en: If this GC seems weird to you, think again. The Epsilon GC has been added as
    a benchmark to test applications for performance, memory usage, latency, and throughput
    improvements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个 GC 对您来说看起来很奇怪，请再想想。Epsilon GC 被添加为基准，以测试应用程序的性能、内存使用、延迟和吞吐量改进。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why Epsilon is required
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要 Epsilon
- en: Features of Epsilon
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Epsilon 的特性
- en: Examples of working with Epsilon
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Epsilon 的示例
- en: Epsilon use cases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Epsilon 的用例
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work with the code in this chapter, you should have JDK version 11, or later,
    installed on your system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中的代码，您应该在您的系统上安装 JDK 版本 11 或更高版本。
- en: All of the code in this chapter can be accessed using this URL: [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码都可以通过以下网址访问：[https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)。
- en: Let's get started by exploring why we need a GC that doesn't collect any garbage.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探讨为什么我们需要一个不收集任何垃圾的 GC 开始。
- en: The motivation behind Epsilon GC
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Epsilon GC 的动机
- en: You may have seen posters that state that by the year 2050, there will be more
    plastic in our oceans than fish. We are still in the year 2019\. So, how can can
    marine analysts make predictions about 2050? There could be multiple ways of doing
    so. Perhaps they just assume that plastic is added without any cleanup, or perhaps
    they just use the current rate of increasing plastic pollution, or they might
    have applied another kind of algorithm.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能见过海报声称到 2050 年，我们海洋中的塑料将比鱼还多。 我们还在 2019 年。那么，海洋分析师是如何预测 2050 年的情况的呢？可能有多种方法。也许他们只是假设塑料被添加而没有清理，或者也许他们只是使用当前塑料污染增加的速率，或者他们可能应用了另一种算法。
- en: The essence of this statement is that by arriving at a number (such as the year
    2050), they can spread awareness about increasing marine plastic pollution. By
    stating that there will be *more plastic than fish*, they can get the attention
    of the masses and encourage them to get working now. People dread the worst; if
    you throw an alarming situation at them, they are more likely to react (in the
    suggested way).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话的本质是，通过得出一个数字（例如 2050 年），他们可以传播关于海洋塑料污染增加的意识。通过声称将有 *比鱼更多的塑料*，他们可以吸引大众的注意，并鼓励他们现在就开始工作。人们害怕最坏的情况；如果你向他们展示一个令人担忧的情况，他们更有可能做出反应（按照建议的方式）。
- en: Similarly, you could use Epsilon GC to predict the performance capabilities
    of your application. Because Epsilon GC can measure and tune the performance,
    memory usage, latency, and throughput of your applications without reclaiming
    the allocated memory. If you want to benchmark the application performance, Epsilon
    GC is the tool for you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用 Epsilon GC 来预测您应用程序的性能能力。因为 Epsilon GC 可以测量和调整应用程序的性能、内存使用、延迟和吞吐量，而无需回收分配的内存。如果您想对应用程序性能进行基准测试，Epsilon
    GC 是您的工具。
- en: Epsilon GC is used to benchmark other GCs against your applications, on multiple
    factors such as performance and memory usage in order to optimize your applications
    and use the best GCs that can work for your project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Epsilon GC 用于将其他 GC 与您的应用程序在多个因素上进行基准测试，例如性能和内存使用，以优化您的应用程序并使用最适合您项目的最佳 GC。
- en: Features of Epsilon
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Epsilon 的特性
- en: Epsilon doesn't clear the heap memory of unused objects; it only allocates memory.
    When the JVM runs out of memory, it shuts down with an `OutOfMemoryError` error.
    If a heap dump is enabled, Epsilon will perform a head dump, after throwing an `OutOfMemoryError`
    error.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Epsilon 不会清除未使用对象的堆内存；它只分配内存。当 JVM 内存不足时，它会通过抛出 `OutOfMemoryError` 错误来关闭。如果启用了堆转储，Epsilon
    将在抛出 `OutOfMemoryError` 错误后执行堆转储。
- en: Epsilon GC uses a simple, lock-free **Thread Local Allocation Buffer** (**TLAB**)
    allocation. This works by allocating contiguous sections of memory in a linear
    manner. One of the main benefits of TLAB allocation is that it binds a process
    to use the memory that has been allocated to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Epsilon GC 使用简单的、无锁的 **线程局部分配缓冲区**（**TLAB**）分配。这是通过以线性方式分配内存的连续部分来实现的。TLAB 分配的主要好处之一是它将进程绑定到已分配给它的内存。
- en: The barrier set used by Epsilon GC is completely empty, hence the name, **no-op**.
    Since it doesn't reclaim memory, it doesn't need to bother itself with maintaining
    the object graph, object marking, object compaction, or object copy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Epsilon GC 使用的屏障集完全为空，因此得名，**无操作**。由于它不回收内存，因此它不需要担心维护对象图、对象标记、对象压缩或对象复制。
- en: Will you ever have any latency overhead with Epsilon? Yes, it is possible. Your
    application might experience latency overhead while Epsilon **allocates** memory—that
    is, if the memory size is too large and the chunk of memory that is being allocated
    is also large.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您会使用 Epsilon 产生任何延迟开销吗？是的，这是可能的。当 Epsilon **分配**内存时，您的应用程序可能会遇到延迟开销——即如果内存大小太大，并且正在分配的内存块也很大。
- en: Latency and application performance
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟与应用程序性能
- en: Imagine your application processes thousands of messages every second. In this
    case, a latency of even one millisecond or more can have a performance impact
    on your system. The worst part is that you won't even know when your GC will kick
    in and start the collection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的应用程序每秒处理数千条消息。在这种情况下，即使是一毫秒或更长时间的延迟也可能对您的系统性能产生影响。最糟糕的是，您甚至不知道何时 GC 会启动并开始收集。
- en: I have a suggestion; execute your application with Epsilon GC as a benchmark
    that won't collect any garbage. Now execute your application with GCs of your
    choice, and analyze the logs. Now you can filter out the latency induced due to
    a GC—such as GC workers scheduling, GC barrier costs, or GC cycles. The performance
    of your system might also suffer due to issues that are not related to a GC—such
    as OS scheduling or compiler issues.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个建议；以不会收集任何垃圾的方式使用 Epsilon GC 执行您的应用程序作为基准。现在使用您选择的 GC 执行您的应用程序，并分析日志。现在您可以过滤出由于
    GC（如 GC 工作者调度、GC 屏障成本或 GC 周期）引起的延迟。您的系统性能也可能由于与 GC 无关的问题而受到影响——例如操作系统调度或编译器问题。
- en: GC-induced overheads versus system overheads
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC 引起的开销与系统开销
- en: A GC cycle has a latency overhead. For critical applications, this can affect
    the desired throughput. With a carefully selected combination of multiple parameters,
    such as heap size, allocation units, GC cycles duration, region size, and various
    other parameters, you can compare the performance of your application across various
    GCs (including Epsilon).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GC 周期存在延迟开销。对于关键应用，这可能会影响期望的吞吐量。通过仔细选择多个参数的组合，例如堆大小、分配单元、GC 周期持续时间、区域大小以及各种其他参数，您可以在各种
    GC（包括 Epsilon）之间比较您应用程序的性能。
- en: However, overheads can also be induced by the system, which is not related to
    a GC. Executing your applications with multiple GCs will enable you to separate
    out GC-induced overheads from system overheads and select the best GC for your
    application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开销也可能由系统引起，这与 GC 无关。使用多个 GC 执行您的应用程序将使您能够将 GC 引起的开销与系统开销分开，并选择最适合您应用程序的 GC。
- en: By using a no-op GC such as Epsilon, you can filter out the GC-induced performance
    issues with OS/compiler issues.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用无操作 GC（如 Epsilon），您可以过滤出由于 OS/编译器问题引起的 GC 引起的性能问题。
- en: Extremely short-lived work
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 极短生命周期的任务
- en: Imagine that you need to create an application that is extremely short-lived.
    When you exit an application, JVM shuts down, and all the heap memory is reclaimed.
    Since executing a GC cycle takes up some time (though as little as possible),
    you might consider using Epsilon GC with your application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您需要创建一个极短生命周期的应用程序。当您退出应用程序时，JVM 关闭，所有堆内存都会被回收。由于执行 GC 周期需要一些时间（尽管尽可能少），您可能会考虑使用
    Epsilon GC 与您的应用程序一起使用。
- en: Let's get started by using Epsilon GC with some example code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用一些示例代码来使用 Epsilon GC 开始吧。
- en: Getting started with the HelloEpsilon GC class
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 HelloEpsilon GC 类
- en: 'Let''s write a `HelloEpsilon` class and execute it using Epsilon GC. Here''s
    the sample code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个 `HelloEpsilon` 类，并使用 Epsilon GC 执行它。以下是示例代码：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To execute the preceding code using Epsilon GC, you must use the `-XX:+UnlockExperimentalVMOptions` option
    with the `-XX:+UseEpsilonGC` option, followed by the class to execute:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Epsilon GC 执行前面的代码，您必须使用 `-XX:+UnlockExperimentalVMOptions` 选项和 `-XX:+UseEpsilonGC`
    选项，然后是执行类：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot highlights the preceding command at the top; the remaining
    part includes the GC output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图突出显示了前面的命令在顶部；其余部分包括 GC 输出：
- en: '![](img/c6daacb2-2232-448f-ae8d-230939951465.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6daacb2-2232-448f-ae8d-230939951465.png)'
- en: 'As highlighted in the preceding screenshot, the following describes the GC
    output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，以下描述了 GC 输出：
- en: JVM uses the Epsilon GC
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 使用 Epsilon GC
- en: It outputs the `Hello to Epsilon GC!` string to the standard output
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Hello to Epsilon GC!` 字符串输出到标准输出
- en: It includes just one allocation of `` `792 KB` ``
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只包括一个 `792 KB` 的分配
- en: The literal meaning of Epsilon is an arbitrarily small amount. This aligns with
    its op-code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Epsilon 的字面意思是任意小的量。这与它的操作码相一致。
- en: 'Recently, I was delivering a session on Java 11 features, and one of the attendees
    had a query. He asked:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我在讲解 Java 11 特性时，一位与会者提出了一个问题。他问道：
- en: I understand that Epsilon GC doesn't garbage collect the Java heap, but does
    it garbage collect the stack memory?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我明白 Epsilon GC 不收集 Java 堆，但它是否收集栈内存？
- en: I think this is an important question. Often, we don't care about the details
    until we need them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是一个重要的问题。我们通常只有在需要时才关心细节。
- en: If you know the answer, this question might seem trivial to you. If not, let's
    answer this simple and important question in the next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道答案，这个问题可能对你来说微不足道。如果不知道，让我们在下一节中回答这个简单而重要的问题。
- en: Which memory area does GC collect – stack or heap?
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC 收集哪个内存区域——栈还是堆？
- en: JVM defines different memory management mechanisms with stack and heapmemory.
    All GCs clean up the heap memory area by reclaiming the space occupied by unused
    or unreferenced objects. The GCs don't reclaim space from stack memory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 定义了不同的堆栈和堆内存管理机制。所有 GC 通过回收未使用或未引用的对象占用的空间来清理堆内存区域。GC 不从栈内存中回收空间。
- en: The stack memory area is used by a current thread for the execution of a method.
    When the current thread completes the execution of the current method, stack memory
    is released (without involving a GC collection). The primitives are stored on
    stack memory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 栈内存区域由当前线程用于方法的执行。当当前线程完成当前方法的执行时，栈内存被释放（不涉及 GC 收集）。原始数据存储在栈内存上。
- en: 'In a method, the local primitive variables and references to objects (not the
    actual objects) are stored on the stack. The actual objects are stored on the
    heap. The local primitive variables and reference variables that are accessible
    after the execution of a method are defined in the heap memory area. In essence,
    the following takes place:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中，局部原始变量和对对象的引用（不是实际的对象）存储在栈上。实际的对象存储在堆上。在方法执行后可访问的局部原始变量和引用变量定义在堆内存区域。本质上，以下情况发生：
- en: All objects are stored on the heap.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对象都存储在堆上。
- en: The local object references are stored on the stack; the instance or static
    object references are stored on the heap.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部对象引用存储在栈上；实例或静态对象引用存储在堆上。
- en: The local primitive variables and their values are stored on the stack. The
    instance or static primitive variables and their values are stored on the heap.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部原始变量及其值存储在栈上。实例或静态原始变量及其值存储在堆上。
- en: Let's work with simple use cases where Epsilon GC can help you to improve the
    performance, memory usage, latency, and throughput of your applications.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些简单的用例，在这些用例中，Epsilon GC 可以帮助您提高应用程序的性能、内存使用、延迟和吞吐量。
- en: Memory pressure testing with Epsilon
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Epsilon 进行内存压力测试
- en: 'Imagine that you don''t want your application, or say, a section of your application,
    to use more than a certain amount of heap memory, such as 40 MB. How can you assert
    this? In this case, you can configure to execute your applications with `-Xmx40m`.
    Here''s some example code that adds the same string values as the key/value pair
    to `HashMap` and then removes it—by iterating it multiple times (`1_000_000` to
    be precise):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你不想你的应用程序，或者说，你应用程序的一部分使用超过一定数量的堆内存，比如40 MB。你怎么断言这一点？在这种情况下，你可以配置使用`-Xmx40m`来执行你的应用程序。以下是一些示例代码，它将相同的字符串值作为键/值对添加到`HashMap`中，然后通过多次迭代（精确到`1_000_000`）来删除它：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can execute it using the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令执行它：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code exits with `OutOfMemoryError`, as shown in the following
    screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码会因`OutOfMemoryError`而退出，如下面的截图所示：
- en: '![](img/8a3f3e98-3872-46b5-b148-396da347b9a8.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a3f3e98-3872-46b5-b148-396da347b9a8.png)'
- en: 'Let''s revisit the code that generated this output and check whether we can
    do something about it. At present, the code uses the `new` operator to create
    the same string values. Let''s see what happens if I modify it to use the string
    pool, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下生成此输出的代码，并检查我们是否可以对此做些什么。目前，代码使用`new`运算符创建相同的字符串值。让我们看看如果我将它修改为使用字符串池会发生什么，如下所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the execution of this modified code, try executing the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此修改后的代码时，尝试执行以下命令：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code doesn''t exit with `OutOfMemoryError` and completes the
    execution, as demonstrated in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不会因为`OutOfMemoryError`而退出，并完成执行，如下面的截图所示：
- en: '![](img/ea1f4a2b-e26a-49b4-a61f-821d1952672c.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea1f4a2b-e26a-49b4-a61f-821d1952672c.png)'
- en: Reducing garbage is just one of the solutions to out of memory errors. To prevent
    or delay a GC cycle, you can also tune your runtime using multiple parameters—such
    as increasing the heap size or by setting a minimum time before a GC cycle runs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 减少垃圾只是解决内存不足错误的一种方法。为了防止或延迟GC周期，你也可以通过调整多个参数来调整你的运行时——例如增加堆大小或设置GC周期运行前的最小时间。
- en: This brings me to a very interesting case; can you design a garbage-free application,
    that is, one that can work with Epsilon forever? I think we already have a few
    that are in production and are in use by developers (as covered in the next section).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想到了一个非常有趣的案例；你能设计一个无垃圾应用程序，也就是说，一个可以永久与Epsilon一起工作的应用程序吗？我认为我们已经有几个在生产中并且被开发者使用（如下一节所述）。
- en: Designing a garbage-free application
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个无垃圾应用程序
- en: 'In *Which memory area does GC collect – stack or heap?* section, I mentioned
    that a GC reclaims heap memory—which can include (non-local) primitive data types
    or objects. In your Java application, heap memory can be used by these variables
    and objects from either of the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在*哪个内存区域GC收集——栈还是堆？*部分，我提到GC回收堆内存——这可能包括（非局部）原始数据类型或对象。在你的Java应用程序中，堆内存可以由以下任一变量或对象使用：
- en: Third-party libraries used by your application
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应用程序使用的第三方库
- en: A JDK API
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK API
- en: Your application classes
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序类
- en: There are multiple ways to reduce garbage creation—by preferring primitive data
    over objects, reusing buffers, using object pools, dumping temporary object creation,
    and others.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以减少垃圾生成——通过优先使用原始数据类型而不是对象，重用缓冲区，使用对象池，丢弃临时对象创建，以及其他方法。
- en: Here's proof that this is possible. One of the most popular garbage-free applications
    Log4j, which is a logging application by Apache, runs by default in a so-called
    garbage-free mode. This means that it reuses objects and buffers and avoids the
    allocation of temporary objects as much as possible. It also has a so-called low
    garbage mode; this mode is not entirely garbage free, but it also does not use
    ThreadLocal fields.  You can visit [https://logging.apache.org/log4j/2.x/manual/garbagefree.html](https://logging.apache.org/log4j/2.x/manual/garbagefree.html)
    to learn more about it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个证明这是可能的例子。最受欢迎的无垃圾应用程序之一是Log4j，它是Apache的一个日志应用程序，默认情况下以所谓的无垃圾模式运行。这意味着它重用对象和缓冲区，并尽可能避免分配临时对象。它还有一个所谓的低垃圾模式；这种模式并不是完全无垃圾，但它也不使用ThreadLocal字段。你可以访问[https://logging.apache.org/log4j/2.x/manual/garbagefree.html](https://logging.apache.org/log4j/2.x/manual/garbagefree.html)了解更多信息。
- en: VM interface testing
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VM接口测试
- en: Java 10 has added a GC interface—to provide a clean GC development interface
    so that GC developers and HotSpot developers don't struggle to develop new GCs,
    and can locate the functionality of existing GCs with ease.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Java 10 添加了 GC 接口——提供一个干净的 GC 开发接口，以便 GC 开发者和 HotSpot 开发者不会在开发新的 GC 时感到困难，并且可以轻松定位现有
    GC 的功能。
- en: To a certain extent, Epsilon validates the GC interface. Since it doesn't reclaim
    memory, it doesn't really need to implement the methods that require it to maintain
    objects to reclaim, remove, or copy them. So, it can just inherit the default
    implementation (which isn't supposed to do any work). Since it works, Epsilon
    has helped in testing VM interfaces.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上，Epsilon 验证了 GC 接口。由于它不回收内存，因此实际上不需要实现那些需要它维护对象以回收、删除或复制它们的那些方法。所以，它可以直接继承默认实现（不应该做任何工作）。由于它有效，Epsilon
    有助于测试 VM 接口。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered Epsilon, a no-op GC that only allocates memory and
    doesn't free up the heap.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Epsilon，这是一个无操作 GC，它只分配内存而不释放堆内存。
- en: You can execute your applications with Epsilon and other GCs to measure your
    application's performance, memory usage, latency, and throughput—eventually using
    the best possible combinations—tuning your runtime environment and optimizing
    your applications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Epsilon 和其他 GC 来执行你的应用程序，以测量你的应用程序的性能、内存使用、延迟和吞吐量——最终使用最佳可能的组合——调整你的运行时环境并优化你的应用程序。
- en: In the next chapter, you'll get to work with one of the most exciting features
    of Java—the HTTP Client, which uses reactive streams to access resources over
    a network in a non-synchronous and non-blocking manner.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将有机会使用 Java 最激动人心的特性之一——HTTP 客户端，该客户端使用反应式流以非同步和非阻塞的方式通过网络访问资源。
