- en: Epsilon GC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that a software organization replaces its programmers with ones who
    don't know how to code, in order to calculate how long it will take for them to
    exhaust their funds and shut down. In this scenario, no new revenue is generated,
    while staff pay continues. In a similar manner, when you use the Epsilon **garbage
    collector** (**GC**), introduced in Java 11, the software application replaces
    its GC with Epsilon, which does not release memory—to calculate how long will
    it take for the **Java Virtual Machine** (**JVM**) to exhaust all its memory and
    shut down.
  prefs: []
  type: TYPE_NORMAL
- en: Epsilon is a **no-operation** (**no-op**) GC—that is, it doesn't collect any
    garbage. It only handles the allocation of memory. When the available Java heap
    is exhausted, the JVM shuts down.
  prefs: []
  type: TYPE_NORMAL
- en: If this GC seems weird to you, think again. The Epsilon GC has been added as
    a benchmark to test applications for performance, memory usage, latency, and throughput
    improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Epsilon is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of Epsilon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of working with Epsilon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Epsilon use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with the code in this chapter, you should have JDK version 11, or later,
    installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code in this chapter can be accessed using this URL: [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by exploring why we need a GC that doesn't collect any garbage.
  prefs: []
  type: TYPE_NORMAL
- en: The motivation behind Epsilon GC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have seen posters that state that by the year 2050, there will be more
    plastic in our oceans than fish. We are still in the year 2019\. So, how can can
    marine analysts make predictions about 2050? There could be multiple ways of doing
    so. Perhaps they just assume that plastic is added without any cleanup, or perhaps
    they just use the current rate of increasing plastic pollution, or they might
    have applied another kind of algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of this statement is that by arriving at a number (such as the year
    2050), they can spread awareness about increasing marine plastic pollution. By
    stating that there will be *more plastic than fish*, they can get the attention
    of the masses and encourage them to get working now. People dread the worst; if
    you throw an alarming situation at them, they are more likely to react (in the
    suggested way).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you could use Epsilon GC to predict the performance capabilities
    of your application. Because Epsilon GC can measure and tune the performance,
    memory usage, latency, and throughput of your applications without reclaiming
    the allocated memory. If you want to benchmark the application performance, Epsilon
    GC is the tool for you.
  prefs: []
  type: TYPE_NORMAL
- en: Epsilon GC is used to benchmark other GCs against your applications, on multiple
    factors such as performance and memory usage in order to optimize your applications
    and use the best GCs that can work for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Features of Epsilon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Epsilon doesn't clear the heap memory of unused objects; it only allocates memory.
    When the JVM runs out of memory, it shuts down with an `OutOfMemoryError` error.
    If a heap dump is enabled, Epsilon will perform a head dump, after throwing an `OutOfMemoryError`
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Epsilon GC uses a simple, lock-free **Thread Local Allocation Buffer** (**TLAB**)
    allocation. This works by allocating contiguous sections of memory in a linear
    manner. One of the main benefits of TLAB allocation is that it binds a process
    to use the memory that has been allocated to it.
  prefs: []
  type: TYPE_NORMAL
- en: The barrier set used by Epsilon GC is completely empty, hence the name, **no-op**.
    Since it doesn't reclaim memory, it doesn't need to bother itself with maintaining
    the object graph, object marking, object compaction, or object copy.
  prefs: []
  type: TYPE_NORMAL
- en: Will you ever have any latency overhead with Epsilon? Yes, it is possible. Your
    application might experience latency overhead while Epsilon **allocates** memory—that
    is, if the memory size is too large and the chunk of memory that is being allocated
    is also large.
  prefs: []
  type: TYPE_NORMAL
- en: Latency and application performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine your application processes thousands of messages every second. In this
    case, a latency of even one millisecond or more can have a performance impact
    on your system. The worst part is that you won't even know when your GC will kick
    in and start the collection.
  prefs: []
  type: TYPE_NORMAL
- en: I have a suggestion; execute your application with Epsilon GC as a benchmark
    that won't collect any garbage. Now execute your application with GCs of your
    choice, and analyze the logs. Now you can filter out the latency induced due to
    a GC—such as GC workers scheduling, GC barrier costs, or GC cycles. The performance
    of your system might also suffer due to issues that are not related to a GC—such
    as OS scheduling or compiler issues.
  prefs: []
  type: TYPE_NORMAL
- en: GC-induced overheads versus system overheads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GC cycle has a latency overhead. For critical applications, this can affect
    the desired throughput. With a carefully selected combination of multiple parameters,
    such as heap size, allocation units, GC cycles duration, region size, and various
    other parameters, you can compare the performance of your application across various
    GCs (including Epsilon).
  prefs: []
  type: TYPE_NORMAL
- en: However, overheads can also be induced by the system, which is not related to
    a GC. Executing your applications with multiple GCs will enable you to separate
    out GC-induced overheads from system overheads and select the best GC for your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: By using a no-op GC such as Epsilon, you can filter out the GC-induced performance
    issues with OS/compiler issues.
  prefs: []
  type: TYPE_NORMAL
- en: Extremely short-lived work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you need to create an application that is extremely short-lived.
    When you exit an application, JVM shuts down, and all the heap memory is reclaimed.
    Since executing a GC cycle takes up some time (though as little as possible),
    you might consider using Epsilon GC with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by using Epsilon GC with some example code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the HelloEpsilon GC class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a `HelloEpsilon` class and execute it using Epsilon GC. Here''s
    the sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the preceding code using Epsilon GC, you must use the `-XX:+UnlockExperimentalVMOptions` option
    with the `-XX:+UseEpsilonGC` option, followed by the class to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot highlights the preceding command at the top; the remaining
    part includes the GC output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6daacb2-2232-448f-ae8d-230939951465.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As highlighted in the preceding screenshot, the following describes the GC
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: JVM uses the Epsilon GC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It outputs the `Hello to Epsilon GC!` string to the standard output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes just one allocation of `` `792 KB` ``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The literal meaning of Epsilon is an arbitrarily small amount. This aligns with
    its op-code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recently, I was delivering a session on Java 11 features, and one of the attendees
    had a query. He asked:'
  prefs: []
  type: TYPE_NORMAL
- en: I understand that Epsilon GC doesn't garbage collect the Java heap, but does
    it garbage collect the stack memory?
  prefs: []
  type: TYPE_NORMAL
- en: I think this is an important question. Often, we don't care about the details
    until we need them.
  prefs: []
  type: TYPE_NORMAL
- en: If you know the answer, this question might seem trivial to you. If not, let's
    answer this simple and important question in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Which memory area does GC collect – stack or heap?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JVM defines different memory management mechanisms with stack and heapmemory.
    All GCs clean up the heap memory area by reclaiming the space occupied by unused
    or unreferenced objects. The GCs don't reclaim space from stack memory.
  prefs: []
  type: TYPE_NORMAL
- en: The stack memory area is used by a current thread for the execution of a method.
    When the current thread completes the execution of the current method, stack memory
    is released (without involving a GC collection). The primitives are stored on
    stack memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a method, the local primitive variables and references to objects (not the
    actual objects) are stored on the stack. The actual objects are stored on the
    heap. The local primitive variables and reference variables that are accessible
    after the execution of a method are defined in the heap memory area. In essence,
    the following takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: All objects are stored on the heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local object references are stored on the stack; the instance or static
    object references are stored on the heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local primitive variables and their values are stored on the stack. The
    instance or static primitive variables and their values are stored on the heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's work with simple use cases where Epsilon GC can help you to improve the
    performance, memory usage, latency, and throughput of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Memory pressure testing with Epsilon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you don''t want your application, or say, a section of your application,
    to use more than a certain amount of heap memory, such as 40 MB. How can you assert
    this? In this case, you can configure to execute your applications with `-Xmx40m`.
    Here''s some example code that adds the same string values as the key/value pair
    to `HashMap` and then removes it—by iterating it multiple times (`1_000_000` to
    be precise):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code exits with `OutOfMemoryError`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a3f3e98-3872-46b5-b148-396da347b9a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s revisit the code that generated this output and check whether we can
    do something about it. At present, the code uses the `new` operator to create
    the same string values. Let''s see what happens if I modify it to use the string
    pool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On the execution of this modified code, try executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code doesn''t exit with `OutOfMemoryError` and completes the
    execution, as demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea1f4a2b-e26a-49b4-a61f-821d1952672c.png)'
  prefs: []
  type: TYPE_IMG
- en: Reducing garbage is just one of the solutions to out of memory errors. To prevent
    or delay a GC cycle, you can also tune your runtime using multiple parameters—such
    as increasing the heap size or by setting a minimum time before a GC cycle runs.
  prefs: []
  type: TYPE_NORMAL
- en: This brings me to a very interesting case; can you design a garbage-free application,
    that is, one that can work with Epsilon forever? I think we already have a few
    that are in production and are in use by developers (as covered in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Designing a garbage-free application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Which memory area does GC collect – stack or heap?* section, I mentioned
    that a GC reclaims heap memory—which can include (non-local) primitive data types
    or objects. In your Java application, heap memory can be used by these variables
    and objects from either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Third-party libraries used by your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JDK API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your application classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple ways to reduce garbage creation—by preferring primitive data
    over objects, reusing buffers, using object pools, dumping temporary object creation,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: Here's proof that this is possible. One of the most popular garbage-free applications
    Log4j, which is a logging application by Apache, runs by default in a so-called
    garbage-free mode. This means that it reuses objects and buffers and avoids the
    allocation of temporary objects as much as possible. It also has a so-called low
    garbage mode; this mode is not entirely garbage free, but it also does not use
    ThreadLocal fields.  You can visit [https://logging.apache.org/log4j/2.x/manual/garbagefree.html](https://logging.apache.org/log4j/2.x/manual/garbagefree.html)
    to learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: VM interface testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 10 has added a GC interface—to provide a clean GC development interface
    so that GC developers and HotSpot developers don't struggle to develop new GCs,
    and can locate the functionality of existing GCs with ease.
  prefs: []
  type: TYPE_NORMAL
- en: To a certain extent, Epsilon validates the GC interface. Since it doesn't reclaim
    memory, it doesn't really need to implement the methods that require it to maintain
    objects to reclaim, remove, or copy them. So, it can just inherit the default
    implementation (which isn't supposed to do any work). Since it works, Epsilon
    has helped in testing VM interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered Epsilon, a no-op GC that only allocates memory and
    doesn't free up the heap.
  prefs: []
  type: TYPE_NORMAL
- en: You can execute your applications with Epsilon and other GCs to measure your
    application's performance, memory usage, latency, and throughput—eventually using
    the best possible combinations—tuning your runtime environment and optimizing
    your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll get to work with one of the most exciting features
    of Java—the HTTP Client, which uses reactive streams to access resources over
    a network in a non-synchronous and non-blocking manner.
  prefs: []
  type: TYPE_NORMAL
