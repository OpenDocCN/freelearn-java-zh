- en: Chapter 9. Polyglot Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are living in an era where one language is not enough. Developers are expected
    to be polyglot programmers and choose the right tool for a job. While it is always
    a subjective decision, we try to select languages and ecosystems based on various
    parameters such as execution speed, developer productivity, available libraries
    and resources, a team's comfort level with the language, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: When we are already carrying the cognitive load of working with different languages,
    Gradle turns out to be our good friend, as we don't have to change our build tool
    even if we are building projects in other languages. We can even use multiple
    languages in the same project and Gradle orchestrating the build for the entire
    project. Apart from the array of JVM-based languages, Gradle also supports C,
    C++, Objective C and others to produce native applications as well. Gradle is
    also an official build tool for the Android platform. The list of supported languages
    is on the rise. Apart from official plugins, there are many community-supported
    language plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Although throughout the book we have focused primarily on Java as the language,
    we could have very well used Groovy or Scala to write the examples. The `java`
    plugin (along with the `java-base` plugin, which is applied by the `java` plugin
    to the project) provides the basic functionality for the JVM-based projects. Language
    specific plugins such as `scala` and `groovy` extend the `java` plugin to support
    common idioms in a consistent manner. So, once we have used the `java` plugin,
    we are already familiar with what `sourceSet` is, how `configuration` works, how
    to add library dependencies, and so on, and this knowledge is readily useful when
    we use these language plugins. In this chapter, we will see how we can easily
    add more spice to Java projects by adding Groovy or Scala to the mix.
  prefs: []
  type: TYPE_NORMAL
- en: The polyglot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the code example, in this chapter, let's build a simple **Quote of the Day**
    service that returns a quote based on the day of the year. Since we might have
    fewer quotes in our store, the service should repeat the quotes in a cyclic fashion.
    Again, as usual, we will try to keep it as simple as possible to focus more on
    build aspects rather than the application logic. We will create two separate Gradle
    projects to implement the exact same functionality, once in Groovy then in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going into language-specific details, let''s start with defining the
    `QotdService` interface, which just declares only one method, `getQuote`. The
    contract is, as long as we pass the same date, we should get the same quote back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The logic to implement `getQuote` can use the `Date` object in any manner, such
    as using the entire date including the time for determining the quote. However,
    for the sake of simplicity, we will use only the day component of the `Date` object
    in our implementations. Also, because we want our interface to be open for future
    implementations, we let `getQuote` take a `Date` object as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This interface is a Java file that we will have in both projects. This is just
    to demonstrate the integration of Java and Groovy/Scala sources in one project.
  prefs: []
  type: TYPE_NORMAL
- en: Building Groovy projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first implement the `QotdService` interface in Groovy. Also, we will
    write some unit tests to make sure that the functionality works as expected. To
    start the project, let''s create the directory structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `src/main/java` directory is the default directory for Java sources. Similarly,
    `src/main/groovy` is used by default to compile Groovy source files. Again, it
    is just a convention, and the source directories' path and name can be easily
    configured via `sourceSets`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first write the build script for our Groovy project. Create a `build.gradle`
    file in the project root with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Building Groovy project is as simple as building a Java project. Instead of
    applying the `java` plugin, we apply the `groovy` plugin, which automatically
    applies the `java` plugin for us. Apart from applying the plugin, we also need
    to add Groovy as a library dependency so that it is available for compilation
    and is also available at runtime. We also add `junit` in the `testCompile` configuration
    so it is available for unit tests. We declare Maven central as the repository
    to be used, but this can be changed to any valid repository configuration that
    can serve our project's dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gradle build script is a Groovy DSL, and parts of Gradle are written in Groovy.
    However, like any other library that Gradle itself depends on at runtime, Groovy
    is not implicitly available to the project that we are building. Hence, we must
    explicitly declare Groovy as a project dependency, depending on whether we are
    using Groovy in production or test sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Groovy plugin takes care of compiling Java source files in the project as well.
    Let''s implement the `QotdService` interface in Groovy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of service accepts a list of quotes in a constructor. The
    `getQuote` method gets quote by the index in the list. To ensure that the computed
    index always stays within the range of the quote's size, we get the modulus of
    the day of the year and the list's size.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the service, let''s write very basic JUnit test cases in Groovy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We prepare the test data in setup, and each test case makes sure the contract
    of the quote service is maintained. As the quote's list contains only two quotes,
    they should repeat every alternate day.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the tests from the command line using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Building Scala projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following the last section, most of this section would be very predictable
    from the application build''s standpoint. So let''s quickly go through the gist
    of it. The directory structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'All Scala source files are read from `src/main/scala` `and src/test/scala`,
    unless configured using `sourceSets`. This time, the only plugin that we need
    to apply is the `scala` plugin, which just like the `groovy` plugin, implicitly
    applies the `java` plugin to our project. Let''s write the `build.gradle` file
    for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have to provide `scala-library` as a dependency. We also added `specs2`
    as a dependency for the test configuration. We are using JUnit runner for the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `specs2` is a popular Scala testing library, which supports both unit and
    acceptance testing and the BDD/TDD style of writing tests. More information is
    available at [http://etorreborre.github.io/specs2/](http://etorreborre.github.io/specs2/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the service''s Scala implementation, we can implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is not very idiomatic Scala, but that's out of scope of this
    book. The class takes the quotes `Seq` in the constructor and implements the `getQuote`
    method in a similar fashion to the Groovy counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the service is implemented, let''s verify that it honors the semantics
    of `QotdService` by writing unit tests. For brevity, we will cover only the important
    test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The task to run test cases is just the same as the Groovy counterpart. We can
    run tests using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Joint compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples in this chapter, we declared an interface in Java
    and implemented it in Groovy and Scala respectively. It was possible because the
    classes compiled by the `java` plugin are available to Groovy and Scala classes.
  prefs: []
  type: TYPE_NORMAL
- en: If we want a Java class to have access to Groovy or Scala classes for its compilation,
    then we must compile the Java source file using the **joint compilation** supported
    by the respective plugin. Both the `groovy` and `scala` plugins support joint
    compilation and can compile Java sources.
  prefs: []
  type: TYPE_NORMAL
- en: For referencing Groovy classes in a Java class, the easiest way is to move the
    corresponding Java source file into `src/main/groovy` (or in any of the Groovy
    `srcDirs` configured for `sourceSets`), and the Groovy compiler makes Groovy classes
    available to the Java class while compilation. The same goes for Scala joint compilation.
    We can put the Java files, which need Scala classes for their compilation, in
    any of the Scala `srcDirs` (`src/main/scala` by default).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The detailed official documentation for language plugins, discussed in this
    chapter, can be found at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java plugin**: [https://docs.gradle.org/current/userguide/java_plugin.html](https://docs.gradle.org/current/userguide/java_plugin.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Groovy plugin**: [https://docs.gradle.org/current/userguide/groovy_plugin.html](https://docs.gradle.org/current/userguide/groovy_plugin.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scala plugin**: [https://docs.gradle.org/current/userguide/scala_plugin.html](https://docs.gradle.org/current/userguide/scala_plugin.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The links to the official documentation for various languages and other plugins
    shipped with Gradle can be found at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.gradle.org/current/userguide/standard_plugins.html](https://docs.gradle.org/current/userguide/standard_plugins.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We took a simple example problem and implemented a solution in Groovy and Scala
    to demonstrate how Gradle makes polyglot project development easy. Instead of
    going into language and plugin-specific details and differences, we tried to focus
    on the commonality and consistency that Gradle brings to the table.
  prefs: []
  type: TYPE_NORMAL
