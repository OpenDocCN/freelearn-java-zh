<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer087">
			</div>
		</div>
		<div class="Content" id="_idContainer088">
			<h1 id="_idParaDest-241"><a id="_idTextAnchor246"/>11. Processes</h1>
		</div>
		<div class="Content" id="_idContainer089">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will quickly look at how Java handles processes. You will start by exploring the Runtime and <strong class="source-inline">ProcessBuilder</strong> classes, their functions, and how to launch them, in order to then create a process from either class. You'll then learn to send and receive data between parent and child, and how to store the outcomes of a process in a file. In this chapter's final activity, you will use these skills to create a parent process which will launch a child that will print an outcome (then captured by the parent) to the terminal.</p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor247"/>Introduction</h1>
			<p>The <strong class="source-inline">java.lang.Process</strong> class is used to look for information about, and launch, runtime processes. If you want to understand how the <strong class="source-inline">Process</strong> class works, you can start by looking at the <strong class="source-inline">Runtime</strong> class. All Java programs include an instance of the <strong class="source-inline">Runtime</strong> class. It is possible to get information about the <strong class="source-inline">Runtime</strong> class by calling the <strong class="source-inline">getRuntime()</strong> method and assigning its outcome to a variable of the <strong class="source-inline">Runtime</strong> class. With that, it is possible to obtain information about the <strong class="bold">JVM</strong> environment that commands your program:</p>
			<p class="source-code">public class Example01 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Runtime runtime = Runtime.getRuntime();</p>
			<p class="source-code">        System.out.println("Processors: " + runtime.availableProcessors());</p>
			<p class="source-code">        System.out.println("Total memory: " + runtime.totalMemory());</p>
			<p class="source-code">        System.out.println("Free memory: " + runtime.freeMemory());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Processes carry the information relating to a program being launched on a computer. Each operating system handles processes differently. What the <strong class="bold">JVM</strong> offers with the <strong class="source-inline">Process</strong> class is an opportunity to control them in the same way. This is done through a single method of the <strong class="source-inline">Runtime</strong> class, called <strong class="source-inline">exec()</strong>, which returns an object of the <strong class="source-inline">Process</strong> class. <strong class="source-inline">Exec</strong> has different implementations that allow you to simply issue a command, or to do so by modifying the environmental variable and even the directory the program will run from.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor248"/>Launching a Process</h1>
			<p>As mentioned earlier, a process is launched with <strong class="source-inline">exec()</strong>. Let's look at a simple example where we will call the Java compiler, something that is done the same way from the terminal on any operating system:</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">public class Example02 {</p>
			<p class="source-code">public static void main(String[] args) {</p>
			<p class="source-code">    Runtime runtime = Runtime.getRuntime();</p>
			<p class="source-code">    try {</p>
			<p class="source-code">        Process process = runtime.exec("firefox");</p>
			<p class="source-code">    } catch (IOException ioe) {</p>
			<p class="source-code">        System.out.println("WARNING: something happened with exec");</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>When running this example, if you happen to have Firefox installed, it will launch automatically. You could change that to be any other application on your computer. The program will exit with no error, but it will not do anything besides that. </p>
			<p>Now, let's add a couple of lines to the previous example so that the program you just opened will be closed after 5 seconds: </p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">import java.util.concurrent.TimeUnit;</p>
			<p class="source-code">public class Example03 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Runtime runtime = Runtime.getRuntime();</p>
			<p class="source-code">        Process process = null;</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            process = runtime.exec("firefox");</p>
			<p class="source-code">        } catch (IOException ioe) {</p>
			<p class="source-code">            System.out.println("WARNING: something happened with exec");</p>
			<p class="source-code">        }</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            process.waitFor(5, TimeUnit.SECONDS);</p>
			<p class="source-code">        } catch (InterruptedException ie) {</p>
			<p class="source-code">            System.out.println("WARNING: interruption happened");</p>
			<p class="source-code">        }</p>
			<p class="source-code">        process.destroy();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">waitFor(timeOut, timeUnit)</strong> method will wait for the process to end for 5 seconds. If it was <strong class="source-inline">waitFor()</strong> without parameters, it would wait for the program to end by itself. Following the 5-second timeout, the process variable will call the <strong class="source-inline">destroy()</strong> method, which will stop the process immediately. For this reason, opening and closing an application over a short period of time. </p>
			<p>There is an alternative way of launching a process that doesn't require the creation of a <strong class="source-inline">Runtime</strong> object. This other method makes use of the <strong class="source-inline">ProcessBuilder</strong> class. The construction of a <strong class="source-inline">ProcessBuilder</strong> object will require the actual command to be executed as a parameter. The following example is a revision of the previous one, with the addition of this new constructor:</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">public class Example04 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        ProcessBuilder processBuilder = new ProcessBuilder("firefox");</p>
			<p class="source-code">        Process process = null;</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            process = processBuilder.start();</p>
			<p class="source-code">        } catch (IOException ioe) {</p>
			<p class="source-code">            System.out.println("WARNING: something happened with exec");</p>
			<p class="source-code">        }</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            process.waitFor(10, TimeUnit.SECONDS);</p>
			<p class="source-code">        } catch (InterruptedException ie) {</p>
			<p class="source-code">            System.out.println("WARNING: interruption happened");</p>
			<p class="source-code">        }</p>
			<p class="source-code">        process.destroy();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>There are a couple of things you should be aware of. First, the process includes the call to the command as an argument in the constructor. However, that does not launch the process until you call <strong class="source-inline">processBuilder.start()</strong>. The only issue is that the object resulting from <strong class="source-inline">ProcessBuilder</strong> does not include the same method as the one coming from the <strong class="source-inline">Process</strong> API. For example, methods such as <strong class="source-inline">waitFor()</strong> and <strong class="source-inline">destroy()</strong> are not available, therefore, if those were needed, you would have to instantiate an object of <strong class="source-inline">Process</strong> before you could call it in your program.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor249"/>Sending Input to a Child Process</h2>
			<p>Once the process is running, it would be interesting to pass over some data to it. Let's make a small program that will <strong class="source-inline">echo</strong> whatever you type on the CLI back to it. Later, we will write a program that will launch the first application and that will send text for it to print. This simple <strong class="source-inline">echo</strong> program could be like the one in the following example:</p>
			<p class="source-code">public class Example05 {</p>
			<p class="source-code">    public static void main(String[] args) throws java.io.IOException</p>
			<p class="source-code">    {</p>
			<p class="source-code">        int c;</p>
			<p class="source-code">        System.out.print ("Let's echo: ");</p>
			<p class="source-code">        while ((c = System.in.read ()) != '\n')</p>
			<p class="source-code">        System.out.print ((char) c);</p>
			<p class="source-code">    <a id="_idTextAnchor250"/>}</p>
			<p class="source-code">}</p>
			<p>As you can see, this simple program will be reading from the <strong class="source-inline">System.in</strong> stream until you press <em class="italic">Enter</em>. Once that happens, it will exit gracefully:</p>
			<p class="source-code">Enter some text: Hello World</p>
			<p class="source-code">Hello World</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>In the first line of the preceding output, we enter the string '<strong class="source-inline">Hello World</strong>' for this example, which is echoed on the next line. Next, you can make another program that will launch this example and send some text to it:</p>
			<p class="source-code-heading">Example06.java</p>
			<p class="source-code">20     try {</p>
			<p class="source-code">21       process.waitFor(5, TimeUnit.SECONDS);</p>
			<p class="source-code">22     } catch (InterruptedException ie) {</p>
			<p class="source-code">23       System.out.println("WARNING: interrupted exception fired");</p>
			<p class="source-code">24     }</p>
			<p class="source-code">25</p>
			<p class="source-code">26     OutputStream out = process.getOutputStream();</p>
			<p class="source-code">27     Writer writer = new OutputStreamWriter(out);</p>
			<p class="source-code">28     writer.write("This is how we roll!\n"); // EOL to ensure the process sends          back</p>
			<p class="source-code">29</p>
			<p class="source-code">30     writer.flush();</p>
			<p class="source-code">31     process.destroy();</p>
			<p class="source-code">32   }</p>
			<p class="source-code">33 }</p>
			<p class="source-code-link"><a href="https://packt.live/2pEJLiw">https://packt.live/2pEJLiw</a></p>
			<p>This example has two interesting tricks that you need to look into. The first is the call to the previous example. Since we have to launch a Java application, we need to call the <strong class="source-inline">java</strong> executable with the <strong class="source-inline">cp</strong> parameter, which will indicate the directory in which <strong class="bold">JVM</strong> should be looking for the example compiled. You just compiled and tried out <em class="italic">Example05</em>, which means that there is already a compiled class in your computer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">After the call to the <strong class="source-inline">cp</strong> parameter, in Linux/macOS, you need to add a colon (<strong class="source-inline">:</strong>) before the name of the class, whereas in the case of Windows, you should use a semicolon (<strong class="source-inline">;</strong>).</p>
			<p>Once you compile this example, its relative path to the previous example is <strong class="source-inline">../../../../Example05/out/production/Example05</strong>. This might be completely different in your case, depending on how you named your project folders.</p>
			<p>The second thing to note is also highlighted in the code listing. There, you can see the declaration of the <strong class="source-inline">OutStream</strong> that is linked to the one coming from the process. In other words, we are linking an outgoing stream from <em class="italic">Example06</em> to the <strong class="source-inline">System.in</strong> in the <em class="italic">Example05</em> application. In order to be able to write strings to it, we construct a <strong class="source-inline">Writer</strong> object that exposes a <strong class="source-inline">write</strong> method with the ability to send strings to the stream.</p>
			<p>We can call this example from the CLI using: </p>
			<p class="source-code">usr@localhost:~/IdeaProjects/chapter11/[...]production/Example06$ java Example06</p>
			<p>The result is nothing. The reason for this is that <strong class="source-inline">System.out</strong> on the echo example (<em class="italic">Example05</em>) is not made available to the application that initiated the process. If we want to use it, we need to capture it inside <em class="italic">Example06</em>. We will see how to do that in the following section.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor251"/>Capturing the Output of a Child Process</h1>
			<p>We now have two different programs; one that can run by itself (<em class="italic">Example05</em>), and one that is executed from another one, which will also try to send information to it and capture its output. The purpose of this section is to capture the output from <em class="italic">Example05</em> and print it out to a terminal.</p>
			<p>To capture whatever is being sent by the child process to <strong class="source-inline">System.out</strong>, we need to create a <strong class="source-inline">BufferedReader</strong> in the parent class that will be fed from the <strong class="source-inline">InputStream</strong> that can be instantiated from the process. In other words, we need to enhance <em class="italic">Example06</em> with the following:</p>
			<p class="source-code">InputStream in = process.getInputStream();</p>
			<p class="source-code">Reader reader = new InputStreamReader(in);</p>
			<p class="source-code">BufferedReader bufferedReader = new BufferedReader(reader);</p>
			<p class="source-code">String line = bufferedReader.readLine();</p>
			<p class="source-code">System.out.println(line);</p>
			<p>The reason for needing a <strong class="source-inline">BufferedReader</strong> is that we are using the end of the line (<strong class="source-inline">EOL</strong> or "<strong class="source-inline">\n</strong>") as a marker for a message between processes. That allows the utilization of methods such as <strong class="source-inline">readLine()</strong>, which will block the program until it captures an EOL; otherwise, we could stick to the <strong class="source-inline">Reader</strong> object.</p>
			<p>Once you have added that to the example, calling the previous program from the terminal will result in the following output:</p>
			<p class="source-code">usr@localhost:~/IdeaProjects/chapter11/[...]production/Example06$ java Example06</p>
			<p class="source-code">Let's echo: This is how we roll!</p>
			<p>After this output, the program will end.</p>
			<p>An important aspect to consider is that since <strong class="source-inline">BufferedReader</strong> is of a buffered nature, it requires the use of <strong class="source-inline">flush()</strong> as a way to force the data we sent to the buffer to be sent out to the child process. Otherwise, it will be waiting forever when <strong class="bold">JVM</strong> gives it a priority, which eventually could bring the program to a stall.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor252"/>Storing the Output of a Child Process in a File</h1>
			<p>Wouldn't it be useful to store the data in a file? This is one of the reasons why you may be interested in having a process to run a program (or a series of programs) – capturing their output in a log file to study them. By adding a small modification to the process launcher, you could capture whatever it is that is sent to <strong class="source-inline">System.out</strong> by the other program. This is really powerful as you could make a program that could be used to launch any existing command in your operating system and capture all of its output, which could be used later to conduct some sort of forensic analysis of the outcomes:</p>
			<p class="source-code-heading">Example07.java</p>
			<p class="source-code">26         // write to the child's System.in</p>
			<p class="source-code">27         OutputStream out = process.getOutputStream();</p>
			<p class="source-code">28         Writer writer = new OutputStreamWriter(out);</p>
			<p class="source-code">29         writer.write("This is how we roll!\n");</p>
			<p class="source-code">30         writer.flush();</p>
			<p class="source-code">31 </p>
			<p class="source-code">32         // prepare the data logger</p>
			<p class="source-code">33         File file = new File("data.log");</p>
			<p class="source-code">34         FileWriter fileWriter = new FileWriter(file);</p>
			<p class="source-code">35         BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);</p>
			<p class="source-code">36 </p>
			<p class="source-code">37         // read from System.out from the child</p>
			<p class="source-code">38         InputStream in = process.getInputStream();</p>
			<p class="source-code">39         Reader reader = new InputStreamReader(in);</p>
			<p class="source-code">40         BufferedReader bufferedReader = new BufferedReader(reader);</p>
			<p class="source-code">41         String line = bufferedReader.readLine();</p>
			<p class="source-code-link"><a href="https://packt.live/33X3Wal">https://packt.live/33X3Wal</a></p>
			<p>The outcome will be not just writing the result to the terminal, but also creating a <strong class="source-inline">data.log</strong> file that will contain the exact same sentence.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor253"/>Activity 1: Making a Parent Process to Launch a Child Process</h2>
			<p>In this activity, we will create a parent process that will launch a child process that will print out an increasing series of numbers. The outcomes of the child process will be captured by the parent, which will print them to the terminal.</p>
			<p>To stop the program from running forever to reach infinity, the child process should stop when a certain number is reached. Let's take <strong class="source-inline">50</strong> as a limit for this activity, at which point the counter will exit.</p>
			<p>At the same time, the parent process will read the inputs and compare them with a certain number, for example, 37, after which the counter should restart. To ask the child process to restart, the parent should send a single-byte command to the child. Let's use an asterisk (<strong class="source-inline">*</strong>) for this activity. You should use the <strong class="source-inline">sleep()</strong> command so that printing on the terminal doesn't happen too quickly. A good configuration would be <strong class="source-inline">sleep(200)</strong>.</p>
			<p>Given the abovementioned brief, the expected output from running the child program on its own is as follows:</p>
			<p class="source-code">0</p>
			<p class="source-code">1</p>
			<p class="source-code">2</p>
			<p class="source-code">3</p>
			<p class="source-code">[...]</p>
			<p class="source-code">49</p>
			<p class="source-code">50</p>
			<p>But, when called from the parent program, the outcome should be:</p>
			<p class="source-code">0</p>
			<p class="source-code">1</p>
			<p class="source-code">2</p>
			<p class="source-code">[...]</p>
			<p class="source-code">36</p>
			<p class="source-code">37</p>
			<p class="source-code">0</p>
			<p class="source-code">1</p>
			<p class="source-code">[loops forever]</p>
			<ol>
				<li>The child should have an algorithm that looks like the following:<p class="source-code">int cont = 0;</p><p class="source-code">while(cont &lt;= 50) {</p><p class="source-code">  System.out.println(cont++);</p><p class="source-code">  sleep(200);</p><p class="source-code">  if (System.in.available() &gt; 0) {</p><p class="source-code">    ch = System.in.read();</p><p class="source-code">    if (ch == '*') {</p><p class="source-code">    cont = 0;</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>Here, there is a call to <strong class="source-inline">System.in.available()</strong> to check whether there is any data in the output buffer from the child program.</p></li>
				<li>On the other hand, the parent program should consider including something along the lines of:<p class="source-code">if (Integer.parseInt(line) == 37) {</p><p class="source-code">  writer.write('*');</p><p class="source-code">  writer.flush(); // needed because of the buffered output</p><p class="source-code">}</p></li>
			</ol>
			<p>This would detect whether the number that just arrived as a <strong class="source-inline">String</strong> will be converted to an <strong class="source-inline">Integer</strong>, and from there it would be compared to the limit we suggested for the counting to reset.</p>
			<p>We didn't go in-depth in terms of all of the methods offered by the <strong class="source-inline">Process</strong> class. It is therefore recommended to wrap the work in this chapter in good old-school reference documentation and visit JavaDoc to see what else this class has to offer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found at page 559. You can read more about the <strong class="source-inline">Process</strong> class on Oracle's official documentation: <a href="https://www.packtpub.com/application-development/mastering-java-9">https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html</a>.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor254"/>Summary</h1>
			<p>In this short chapter, you were introduced to the <strong class="source-inline">Process</strong> class in Java. You got to see how a process that outputs to <strong class="source-inline">System.out</strong> can be captured in the parent program. At the same time, you also saw how the parent can easily send data to the child. The examples showed that it is possible to launch not just your own programs, but also any other program, such as a web browser. The possibilities for building software automation with programs that include the <strong class="source-inline">Process</strong> API are endless.</p>
			<p>We also saw the importance of streams in terms of intra-process communication. Basically, you have to create streams on top of streams to develop more complex data structures, which will allow the code to run a lot faster. The next chapter will cover regular expressions.</p>
		</div>
	</body></html>