<html><head></head><body>
		<div id="_idContainer059">
			<h1 id="_idParaDest-191"><em class="italic"><a id="_idTextAnchor190"/>Chapter 10</em>: Exporting, Batching, Bulking, and Loading</h1>
			<p>Manipulating large amounts of data requires serious skills (know-how and programming skills) in exporting, batching, bulking, and loading data. Each of these areas requires a significant amount of code and a lot of time to be implemented and tested against real datasets. Fortunately, jOOQ provides comprehensive APIs that cover all these operations and expose them in a fluent style, while hiding the implementation details. In this context, our agenda includes the following:</p>
			<ul>
				<li>Exporting data in text, JSON, XML, CSV, charts, and <strong class="source-inline">INSERT</strong> statements</li>
				<li>Batching <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">MERGE</strong>, and <strong class="source-inline">Record</strong></li>
				<li>Bulking queries</li>
				<li>Loading JSON, CSV, arrays, and <strong class="source-inline">Record</strong></li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor191"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter10">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter10</a>.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/>Exporting data</h1>
			<p>Exporting (or formatting) data<a id="_idIndexMarker1019"/> is achievable via the <strong class="source-inline">org.jooq.Formattable</strong> API. jOOQ exposes a suite of <strong class="source-inline">format()</strong> and <strong class="source-inline">formatFoo()</strong> methods that can be used to format <strong class="source-inline">Result</strong> and <strong class="source-inline">Cursor</strong> (remember <strong class="source-inline">fetchLazy()</strong> from <a href="B16833_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>, <em class="italic">Fetching and Mapping</em>) as text, JSON, XML, CSV, XML, charts, and <strong class="source-inline">INSERT</strong> statements. As you can see in the documentation, all these methods come in different flavors capable of exporting data into a string or a file via the Java <strong class="source-inline">OutputStream</strong> or <strong class="source-inline">Writer</strong> APIs.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>Exporting as text</h2>
			<p>I'm sure <a id="_idIndexMarker1020"/>that you have already seen in your console output something similar to the following:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B16833_Figure_10.1.jpg" alt="Figure 10.1 – Tabular text data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Tabular text data</p>
			<p>This textual tabular representation can be achieved via the <strong class="source-inline">format()</strong> method. A flavor of this method takes an integer argument representing the maximum number of records to include in the formatted result (by default, jOOQ logs just the first five records of the result formatted via jOOQ's text export, but we can easily format and log all the <strong class="source-inline">fetch</strong> records as <strong class="source-inline">result.format(result.size()</strong>). But, if you need a fine-tuning of this output, then jOOQ has a dedicated immutable class named <strong class="source-inline">TXTFormat</strong> with a lot of intuitive options available in the documentation. Using this class in conjunction with exporting the resulting text into a file named <strong class="source-inline">result.txt</strong> via <strong class="source-inline">format</strong><strong class="source-inline">(Writer writer, TXTFormat format)</strong> can be done as shown in the following example:</p>
			<pre class="source-code">try (BufferedWriter bw = Files.newBufferedWriter(</pre>
			<pre class="source-code">  Paths.get("result.txt"), StandardCharsets.UTF_8,</pre>
			<pre class="source-code">  StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) {</pre>
			<pre class="source-code"> ctx.select(PRODUCTLINE.PRODUCT_LINE, PRODUCT.PRODUCT_ID,  </pre>
			<pre class="source-code">            PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">    .from(PRODUCTLINE)</pre>
			<pre class="source-code">    .join(PRODUCT).onKey()</pre>
			<pre class="source-code">    .fetch()</pre>
			<pre class="source-code">    .format(bw, new TXTFormat().maxRows(25).minColWidth(20)); </pre>
			<pre class="source-code">} catch (IOException ex) { // handle exception }</pre>
			<p>You can see this <a id="_idIndexMarker1021"/>example in the bundled code, <strong class="source-inline">Format</strong> (available for MySQL and PostgreSQL), next to other examples.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Exporting JSON</h2>
			<p>Exporting <strong class="source-inline">Result</strong>/<strong class="source-inline">Cursor</strong> as JSON can be done via <strong class="source-inline">formatJSON()</strong> and its overloads. Without arguments, <strong class="source-inline">formatJSON()</strong> produces a JSON containing two main arrays: an <a id="_idIndexMarker1022"/>array named <strong class="source-inline">"fields"</strong>, representing a header (as you'll see later, this can be useful for importing the JSON into the database), and an array named <strong class="source-inline">"records"</strong>, which wraps the fetched data. Here is such an output:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code"> "fields": [</pre>
			<pre class="source-code">  {"schema": "public", "table": "productline", "name": </pre>
			<pre class="source-code">   "product_line", "type": "VARCHAR"},</pre>
			<pre class="source-code">  {"schema": "public", "table": "product", "name": </pre>
			<pre class="source-code">   "product_id", "type": "BIGINT"},</pre>
			<pre class="source-code">  {"schema": "public", "table": "product", "name": </pre>
			<pre class="source-code">   "product_name", "type": "VARCHAR"}</pre>
			<pre class="source-code"> ],</pre>
			<pre class="source-code"> "records": [</pre>
			<pre class="source-code">  ["Vintage Cars", 80, "1936 Mercedes Benz 500k Roadster"],</pre>
			<pre class="source-code">  ["Vintage Cars", 29, "1932 Model A Ford J-Coupe"],</pre>
			<pre class="source-code">  ...  </pre>
			<pre class="source-code"> ]</pre>
			<pre class="source-code">}</pre>
			<p>So, this JSON can be obtained via the <strong class="source-inline">formatJSON()</strong> method without arguments, or via <strong class="source-inline">formatJSON(JSONFormat.DEFAULT_FOR_RESULTS)</strong>. If we want to render only the <strong class="source-inline">"records"</strong> array and avoid rendering the header represented by the <strong class="source-inline">"fields"</strong> array, then we can rely on <strong class="source-inline">formatJSON(JSONFormat.DEFAULT_FOR_RECORDS)</strong>. This produces something as shown<a id="_idIndexMarker1023"/> here (as you'll see later, this can also be imported back into the database):</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">  ["Vintage Cars", 80, "1936 Mercedes Benz 500k Roadster"],</pre>
			<pre class="source-code">  ["Vintage Cars", 29, "1932 Model A Ford J-Coupe"],</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">]</pre>
			<p><strong class="source-inline">DEFAULT_FOR_RESULTS</strong> and <strong class="source-inline">DEFAULT_FOR_RECORDS</strong> are two statics of the immutable <strong class="source-inline">org.jooq.JSONFormat</strong> used to fine-tune JSON imports/exports. When these statics are not enough, we can instantiate <strong class="source-inline">JSONFormat</strong> and fluently append a suite of intuitive options such as the ones from this example (check all the available options in the jOOQ documentation):</p>
			<pre class="source-code">JSONFormat jsonFormat = new JSONFormat()</pre>
			<pre class="source-code">   .indent(4)      // defaults to 2</pre>
			<pre class="source-code">   .header(false)  // default to true</pre>
			<pre class="source-code">   .newline("\r")  // "\n" is default</pre>
			<pre class="source-code">   .recordFormat(</pre>
			<pre class="source-code">      JSONFormat.RecordFormat.OBJECT); // defaults to ARRAY    </pre>
			<p>Further, let's use <strong class="source-inline">jsonFormat</strong> in the context of exporting a JSON into a file via <strong class="source-inline">formatJSON(Writer writer, JSONFormat format)</strong>: </p>
			<pre class="source-code">try ( BufferedWriter bw = Files.newBufferedWriter(</pre>
			<pre class="source-code">  Paths.get("resultObject.json"), StandardCharsets.UTF_8,</pre>
			<pre class="source-code">  StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) {</pre>
			<pre class="source-code">  ctx.select(PRODUCTLINE.PRODUCT_LINE, PRODUCT.PRODUCT_ID, </pre>
			<pre class="source-code">             PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">     .from(PRODUCTLINE)</pre>
			<pre class="source-code">     .join(PRODUCT).onKey()                    </pre>
			<pre class="source-code">     .fetch()</pre>
			<pre class="source-code">     .formatJSON(bw, jsonFormat);</pre>
			<pre class="source-code">} catch (IOException ex) { // handle exception }</pre>
			<p>The resulting<a id="_idIndexMarker1024"/> JSON looks like this (also importable into the database):</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">  {</pre>
			<pre class="source-code">    "product_line": "Vintage Cars",</pre>
			<pre class="source-code">    "product_id": 80,</pre>
			<pre class="source-code">    "product_name": "1936 Mercedes Benz 500k Roadster"</pre>
			<pre class="source-code">  },  </pre>
			<pre class="source-code">…</pre>
			<pre class="source-code">]</pre>
			<p>If we fetch a single <strong class="source-inline">Record</strong> (so, not <strong class="source-inline">Result</strong>/<strong class="source-inline">Cursor</strong>, via <strong class="source-inline">fetchAny()</strong>, for instance), then <strong class="source-inline">formatJSON()</strong> will return an array containing only the data, as in this sample of fetching <strong class="source-inline">Record3&lt;String, Long, String&gt;</strong>:</p>
			<pre class="source-code">["Classic Cars",2,"1952 Alpine Renault 1300"]</pre>
			<p>But, if we explicitly mention <strong class="source-inline">JSONFormat.RecordFormat.OBJECT</strong>, then this becomes the following:</p>
			<pre class="source-code">{"product_line":"Classic Cars","product_id":2,</pre>
			<pre class="source-code"> "product_name":"1952 Alpine Renault 1300"}</pre>
			<p>You can check<a id="_idIndexMarker1025"/> out this example in the bundled code, <em class="italic">Format</em> (available for MySQL and PostgreSQL), next to other examples including formatting a UDT, an array type, and an embeddable type as JSON.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>Export XML</h2>
			<p>Exporting <strong class="source-inline">Result</strong>/<strong class="source-inline">Cursor</strong> as XML can be done via <strong class="source-inline">formatXML()</strong> and its overloads. Without<a id="_idIndexMarker1026"/> arguments, <strong class="source-inline">formatXML()</strong> produces an XML containing two main elements: an element named <strong class="source-inline">&lt;fields/&gt;</strong>, representing a header, and an element named <strong class="source-inline">&lt;records/&gt;</strong>, which wraps the fetched data. Here is such an output:</p>
			<pre class="source-code">&lt;result xmlns="http:..."&gt;</pre>
			<pre class="source-code">&lt;fields&gt;</pre>
			<pre class="source-code">  &lt;field schema="public" table="productline" </pre>
			<pre class="source-code">           name="product_line" type="VARCHAR"/&gt;</pre>
			<pre class="source-code">  &lt;field schema="public" table="product" </pre>
			<pre class="source-code">           name="product_id" type="BIGINT"/&gt;</pre>
			<pre class="source-code">  &lt;field schema="public" table="product" </pre>
			<pre class="source-code">           name="product_name" type="VARCHAR"/&gt;</pre>
			<pre class="source-code">&lt;/fields&gt;</pre>
			<pre class="source-code">&lt;records&gt;</pre>
			<pre class="source-code">  &lt;record xmlns="http:..."&gt;</pre>
			<pre class="source-code">    &lt;value field="product_line"&gt;Vintage Cars&lt;/value&gt;</pre>
			<pre class="source-code">    &lt;value field="product_id"&gt;80&lt;/value&gt;</pre>
			<pre class="source-code">    &lt;value field="product_name"&gt;1936 Mercedes Benz ...&lt;/value&gt;</pre>
			<pre class="source-code">  &lt;/record&gt;</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">&lt;/records&gt;</pre>
			<pre class="source-code">&lt;/result&gt;</pre>
			<p>The jOOQ <a id="_idIndexMarker1027"/>code that produced this output is as follows:</p>
			<pre class="source-code">ctx.select(PRODUCTLINE.PRODUCT_LINE, </pre>
			<pre class="source-code">           PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .join(PRODUCT).onKey()</pre>
			<pre class="source-code">   .fetch()</pre>
			<pre class="source-code">   .formatXML();</pre>
			<p>So, this XML can be obtained via the <strong class="source-inline">formatXML()</strong> method without arguments or via <strong class="source-inline">formatXML(XMLFormat.DEFAULT_FOR_RESULTS)</strong>. If we want to keep only the <strong class="source-inline">&lt;records/&gt;</strong> element and avoid rendering the <strong class="source-inline">&lt;fields/&gt;</strong> element, then use <strong class="source-inline">formatJXML(XMLFormat.DEFAULT_FOR_RECORDS)</strong>. This is an output sample:</p>
			<pre class="source-code">&lt;result&gt;</pre>
			<pre class="source-code"> &lt;record&gt;</pre>
			<pre class="source-code">  &lt;value field="product_line"&gt;Vintage Cars&lt;/value&gt;</pre>
			<pre class="source-code">  &lt;value field="product_id"&gt;80&lt;/value&gt;</pre>
			<pre class="source-code">  &lt;value field="product_name"&gt;1936 Mercedes Benz ...&lt;/value&gt;</pre>
			<pre class="source-code"> &lt;/record&gt;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">&lt;/result&gt;</pre>
			<p><strong class="source-inline">DEFAULT_FOR_RESULTS</strong> and <strong class="source-inline">DEFAULT_FOR_RECORDS</strong> are two statics of the immutable <strong class="source-inline">org.jooq.XMLFormat</strong>, used to fine-tune XML imports/exports. Besides these, we can instantiate <strong class="source-inline">XMLFormat</strong> and fluently append a suite of intuitive options. For instance, the previous snippets of XML are rendered based on the default record format, <strong class="source-inline">XMLFormat.RecordFormat.VALUE_ELEMENTS_WITH_FIELD_ATTRIBUTE</strong>; notice the <strong class="source-inline">&lt;value/&gt;</strong> element and the <strong class="source-inline">field</strong> attribute. But, using <strong class="source-inline">XMLFormat</strong>, we can go for two other options: <strong class="source-inline">VALUE_ELEMENTS</strong> and <strong class="source-inline">COLUMN_NAME_ELEMENTS</strong>. The former<a id="_idIndexMarker1028"/> formats the records using just the <strong class="source-inline">&lt;value/&gt;</strong> element as follows:</p>
			<pre class="source-code">&lt;record xmlns="http:..."&gt;</pre>
			<pre class="source-code">  &lt;value&gt;Vintage Cars&lt;/value&gt;</pre>
			<pre class="source-code">  &lt;value&gt;29&lt;/value&gt;</pre>
			<pre class="source-code">  &lt;value&gt;1932 Model A Ford J-Coupe&lt;/value&gt;</pre>
			<pre class="source-code">&lt;/record&gt;</pre>
			<p><strong class="source-inline">COLUMN_NAME_ELEMENTS</strong> uses the column names as elements. Let's use this setting next to <strong class="source-inline">header(false)</strong> to format the <strong class="source-inline">MANAGER.MANAGER_EVALUATION</strong> UDT (available in the PostgreSQL schema):</p>
			<pre class="source-code">ctx.select(MANAGER.MANAGER_ID, MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">   .from(MANAGER)</pre>
			<pre class="source-code">   .fetch()</pre>
			<pre class="source-code">   .formatXML(new XMLFormat()</pre>
			<pre class="source-code">    .header(false)</pre>
			<pre class="source-code">    .recordFormat(XMLFormat.RecordFormat.COLUMN_NAME_ELEMENTS))</pre>
			<p>The resulting XML looks like this:</p>
			<pre class="source-code">&lt;record xmlns="http..."&gt;</pre>
			<pre class="source-code"> &lt;manager_id&gt;1&lt;/manager_id&gt;</pre>
			<pre class="source-code"> &lt;manager_evaluation&gt;</pre>
			<pre class="source-code">  &lt;record xmlns="http..."&gt;</pre>
			<pre class="source-code">    &lt;communication_ability&gt;67&lt;/communication_ability&gt;</pre>
			<pre class="source-code">    &lt;ethics&gt;34&lt;/ethics&gt;</pre>
			<pre class="source-code">    &lt;performance&gt;33&lt;/performance&gt;</pre>
			<pre class="source-code">    &lt;employee_input&gt;66&lt;/employee_input&gt;</pre>
			<pre class="source-code">  &lt;/record&gt;</pre>
			<pre class="source-code"> &lt;/manager_evaluation&gt;</pre>
			<pre class="source-code">&lt;/record&gt;</pre>
			<p>If we fetch a single <strong class="source-inline">Record</strong> (so, no <strong class="source-inline">Result</strong>/<strong class="source-inline">Cursor</strong> via <strong class="source-inline">fetchAny()</strong>, for instance) then <strong class="source-inline">formatXML()</strong> will return an XML containing only the data, as in this sample of fetching <strong class="source-inline">Record3&lt;String, Long, String&gt;</strong>:</p>
			<pre class="source-code">&lt;record&gt;</pre>
			<pre class="source-code">  &lt;value field="product_line"&gt;Classic Cars&lt;/value&gt;</pre>
			<pre class="source-code">  &lt;value field="product_id"&gt;2&lt;/value&gt;</pre>
			<pre class="source-code">  &lt;value field="product_name"&gt;1952 Alpine Renault 1300&lt;/value&gt;</pre>
			<pre class="source-code">&lt;/record&gt;</pre>
			<p>Of course, you <a id="_idIndexMarker1029"/>can alter this default output via <strong class="source-inline">XMLFormat</strong>. For instance, let's consider that we have this record:</p>
			<pre class="source-code">&lt;Record3&lt;String, Long, String&gt; oneResult = …;</pre>
			<p>And, let's apply <strong class="source-inline">RecordFormat.COLUMN_NAME_ELEMENTS</strong>:</p>
			<pre class="source-code">String xml = oneResult.formatXML(new XMLFormat().recordFormat(</pre>
			<pre class="source-code">             XMLFormat.RecordFormat.COLUMN_NAME_ELEMENTS));</pre>
			<p>The rendered XML is as follows:</p>
			<pre class="source-code">&lt;record xmlns="http://..."&gt;</pre>
			<pre class="source-code">  &lt;product_line&gt;Classic Cars&lt;/product_line&gt;</pre>
			<pre class="source-code">  &lt;product_id&gt;2&lt;/product_id&gt;</pre>
			<pre class="source-code">  &lt;product_name&gt;1952 Alpine Renault 1300&lt;/product_name&gt;</pre>
			<pre class="source-code">&lt;/record&gt;</pre>
			<p>Consider this example next to others (including exporting XML into a file) in the bundled code, <strong class="source-inline">Format</strong> (available for MySQL and PostgreSQL).</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Exporting HTML</h2>
			<p>Exporting <strong class="source-inline">Result</strong>/<strong class="source-inline">Cursor</strong> as HTML can be done via <strong class="source-inline">formatHTML()</strong> and its overloads. By <a id="_idIndexMarker1030"/>default, jOOQ attempts to wrap the fetched data in a simple HTML table, therefore, expect to see tags such as <strong class="source-inline">&lt;table/&gt;</strong>, <strong class="source-inline">&lt;th/&gt;</strong>, and <strong class="source-inline">&lt;td/&gt;</strong> in the resultant HTML. For instance, formatting the <strong class="source-inline">MANAGER.MANAGER_EVALUATION</strong> UDT (available in the PostgreSQL schema) can be done as follows:</p>
			<pre class="source-code">ctx.select(MANAGER.MANAGER_NAME, MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">   .from(MANAGER)</pre>
			<pre class="source-code">   .fetch()</pre>
			<pre class="source-code">   .formatHTML();</pre>
			<p>The resultant HTML looks like this:</p>
			<pre class="source-code">&lt;table&gt;</pre>
			<pre class="source-code"> &lt;thead&gt;</pre>
			<pre class="source-code">  &lt;tr&gt;</pre>
			<pre class="source-code">   &lt;th&gt;manager_name&lt;/th&gt;</pre>
			<pre class="source-code">   &lt;th&gt;manager_evaluation&lt;/th&gt;</pre>
			<pre class="source-code">  &lt;/tr&gt;</pre>
			<pre class="source-code"> &lt;/thead&gt;</pre>
			<pre class="source-code"> &lt;tbody&gt;</pre>
			<pre class="source-code">  &lt;tr&gt;</pre>
			<pre class="source-code">   &lt;td&gt;Joana Nimar&lt;/td&gt;</pre>
			<pre class="source-code">   &lt;td&gt;(67, 34, 33, 66)&lt;/td&gt;</pre>
			<pre class="source-code">  &lt;/tr&gt;</pre>
			<pre class="source-code">  ...</pre>
			<p>Notice that the value of <strong class="source-inline">MANAGER_EVALUATION</strong>, (<em class="italic">67, 34, 33, 66</em>), is wrapped in a <strong class="source-inline">&lt;td/&gt;</strong> tag. But, maybe<a id="_idIndexMarker1031"/> you'd like to obtain something like this:</p>
			<pre class="source-code">&lt;h1&gt;Joana Nimar&lt;/h1&gt;</pre>
			<pre class="source-code">&lt;table&gt;</pre>
			<pre class="source-code"> &lt;thead&gt;</pre>
			<pre class="source-code">  &lt;tr&gt;</pre>
			<pre class="source-code">   &lt;th&gt;communication_ability&lt;/th&gt;</pre>
			<pre class="source-code">   &lt;th&gt;ethics&lt;/th&gt;</pre>
			<pre class="source-code">   &lt;th&gt;performance&lt;/th&gt;</pre>
			<pre class="source-code">   &lt;th&gt;employee_input&lt;/th&gt;</pre>
			<pre class="source-code">  &lt;/tr&gt;</pre>
			<pre class="source-code"> &lt;/thead&gt;</pre>
			<pre class="source-code"> &lt;tbody&gt;</pre>
			<pre class="source-code">  &lt;tr&gt;</pre>
			<pre class="source-code">   &lt;td&gt;67&lt;/td&gt;</pre>
			<pre class="source-code">   &lt;td&gt;34&lt;/td&gt;</pre>
			<pre class="source-code">   &lt;td&gt;33&lt;/td&gt;</pre>
			<pre class="source-code">   &lt;td&gt;66&lt;/td&gt;</pre>
			<pre class="source-code">  &lt;/tr&gt;</pre>
			<pre class="source-code"> &lt;/tbody&gt;</pre>
			<pre class="source-code">&lt;/table&gt;</pre>
			<p>We can obtain this HTML by decorating our query as follows:</p>
			<pre class="source-code">ctx.select(MANAGER.MANAGER_NAME, MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">   .from(MANAGER)</pre>
			<pre class="source-code">   .fetch()</pre>
			<pre class="source-code">   .stream()</pre>
			<pre class="source-code">   .map(e -&gt; "&lt;h1&gt;".concat(e.value1().concat("&lt;/h1&gt;"))</pre>
			<pre class="source-code">                   .concat(e.value2().formatHTML()))</pre>
			<pre class="source-code">   .collect(joining("&lt;br /&gt;"))</pre>
			<p>Check out more <a id="_idIndexMarker1032"/>examples in the bundled code, <em class="italic">Format</em> (available for MySQL and PostgreSQL).</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Exporting CSV</h2>
			<p>Exporting <strong class="source-inline">Result</strong>/<strong class="source-inline">Cursor</strong> as CSV can be done via <strong class="source-inline">formatCSV()</strong> and its overloads. By default, jOOQ renders<a id="_idIndexMarker1033"/> a CSV file as the one here:</p>
			<pre class="source-code">city,country,dep_id,dep_name</pre>
			<pre class="source-code">Bucharest,"","",""</pre>
			<pre class="source-code">Campina,Romania,3,Accounting</pre>
			<pre class="source-code">Campina,Romania,14,IT</pre>
			<pre class="source-code">…</pre>
			<p>Among the handy overloads, we have <strong class="source-inline">formatCSV</strong><strong class="source-inline">(boolean header, char delimiter, String nullString)</strong>. Via this method, we can specify whether the CSV header should be rendered (by default, <strong class="source-inline">true</strong>), the record's delimiter (by default, a <em class="italic">comma</em>), and a string for representing <strong class="source-inline">NULL</strong> values (by default, <strong class="source-inline">""</strong>). Next to this method, we also have a suite of combinations of these arguments such as <strong class="source-inline">formatCSV(char delimiter, String nullString)</strong>, <strong class="source-inline">formatCSV(char delimiter)</strong>, and <strong class="source-inline">formatCSV(boolean header, char delimiter)</strong>. Here is an example that renders the header (default) and uses <strong class="source-inline">TAB</strong> as a delimiter and <strong class="source-inline">"N/A"</strong> for representing <strong class="source-inline">NULL</strong> values:</p>
			<pre class="source-code">ctx.select(OFFICE.CITY, OFFICE.COUNTRY,   </pre>
			<pre class="source-code">           DEPARTMENT.DEPARTMENT_ID.as("dep_id"),  </pre>
			<pre class="source-code">           DEPARTMENT.NAME.as("dep_name"))</pre>
			<pre class="source-code">   .from(OFFICE).leftJoin(DEPARTMENT).onKey().fetch()</pre>
			<pre class="source-code">   .formatCSV('\t', "N/A");</pre>
			<p>The <a id="_idIndexMarker1034"/>resulting CSV looks like this:</p>
			<pre class="source-code">City       country    dep_id     dep_name</pre>
			<pre class="source-code">Bucharest  N/A        N/A        N/A</pre>
			<pre class="source-code">Campina    Romania    3          Accounting</pre>
			<pre class="source-code">…</pre>
			<pre class="source-code">Hamburg    Germany    N/A        N/A</pre>
			<pre class="source-code">London     UK         N/A        N/A</pre>
			<pre class="source-code">NYC        USA        4          Finance</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">Paris      France     2          Sales</pre>
			<p>Whenever we need more options, we can rely on the immutable <strong class="source-inline">CSVFormat</strong>. Here is an example of using <strong class="source-inline">CSVFormat</strong> and exporting the result in a file:</p>
			<pre class="source-code">try (BufferedWriter bw = Files.newBufferedWriter(</pre>
			<pre class="source-code">  Paths.get("result.csv"), StandardCharsets.UTF_8,</pre>
			<pre class="source-code">  StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) {</pre>
			<pre class="source-code">  ctx.select(OFFICE.CITY, OFFICE.COUNTRY,</pre>
			<pre class="source-code">             DEPARTMENT.DEPARTMENT_ID, DEPARTMENT.NAME)</pre>
			<pre class="source-code">    .from(OFFICE).leftJoin(DEPARTMENT).onKey()</pre>
			<pre class="source-code">    .fetch()</pre>
			<pre class="source-code">     .formatCSV(bw, new CSVFormat()</pre>
			<pre class="source-code">        .delimiter("|").nullString("{null}"));</pre>
			<pre class="source-code">} catch (IOException ex) { // handle exception }</pre>
			<p>The complete code <a id="_idIndexMarker1035"/>next to other examples is available in the bundled code, <em class="italic">Format</em> (available for MySQL and PostgreSQL).</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Exporting a chart</h2>
			<p>Exporting <strong class="source-inline">Result</strong>/<strong class="source-inline">Cursor</strong> as a <a id="_idIndexMarker1036"/>chart may result in something as observed in this figure:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B16833_Figure_10.2.jpg" alt="Figure 10.2 – jOOQ chart sample&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – jOOQ chart sample</p>
			<p>This is an area chart containing three graphs: <em class="italic">a</em>, <em class="italic">b</em>, and <em class="italic">c</em>. Graph <strong class="source-inline">a</strong> represents <strong class="source-inline">PRODUCT.BUY_PRICE</strong>, graph <em class="italic">b</em> represents <strong class="source-inline">PRODUCT.MSRP</strong>, and graph <em class="italic">c</em> represents <strong class="source-inline">avg(ORDERDETAIL.PRICE_EACH)</strong>. While this chart can be displayed on the console, it can be exported to a file as shown here:</p>
			<pre class="source-code">try (BufferedWriter bw = Files.newBufferedWriter(</pre>
			<pre class="source-code"> Paths.get("result2Chart.txt"), StandardCharsets.UTF_8,</pre>
			<pre class="source-code"> StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) {</pre>
			<pre class="source-code"> ctx.select(PRODUCT.PRODUCT_ID, PRODUCT.BUY_PRICE, </pre>
			<pre class="source-code">            field("avg_price"), PRODUCT.MSRP)</pre>
			<pre class="source-code">  .from(PRODUCT, lateral(select(</pre>
			<pre class="source-code">        avg(ORDERDETAIL.PRICE_EACH).as("avg_price"))  </pre>
			<pre class="source-code">       .from(ORDERDETAIL)</pre>
			<pre class="source-code">       .where(PRODUCT.PRODUCT_ID.eq(ORDERDETAIL.PRODUCT_ID))))</pre>
			<pre class="source-code">    .limit(5).fetch()</pre>
			<pre class="source-code">    .formatChart(bw, cf);</pre>
			<pre class="source-code">} catch (IOException ex) { // handle exception }</pre>
			<p>Obviously, the chart<a id="_idIndexMarker1037"/> is obtained via the <strong class="source-inline">formatChart()</strong> method. More precisely, in this example, via <strong class="source-inline">formatChart</strong><strong class="source-inline">(Writer writer, ChartFormat format)</strong>. The <strong class="source-inline">ChartFormat</strong> class is immutable and contains a suite of options for customizing the chart. While you can check all of them in the jOOQ documentation, here is the <strong class="source-inline">cf</strong> used in this example:</p>
			<pre class="source-code">DecimalFormat decimalFormat = new DecimalFormat("#.#");</pre>
			<pre class="source-code">ChartFormat cf = new ChartFormat()</pre>
			<pre class="source-code"> .showLegends(true, true)      // show legends  </pre>
			<pre class="source-code"> .display(ChartFormat.Display.DEFAULT) // or,</pre>
			<pre class="source-code">                               // HUNDRED_PERCENT_STACKED</pre>
			<pre class="source-code"> .categoryAsText(true)         // category as text</pre>
			<pre class="source-code"> .type(ChartFormat.Type.AREA)  // area chart type</pre>
			<pre class="source-code"> .shades('a', 'b', 'c')        // shades of PRODUCT.BUY_PRICE, </pre>
			<pre class="source-code">                               // PRODUCT.MSRP, </pre>
			<pre class="source-code">                               // avg(ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code"> .values(1, 2, 3)              // value source column numbers</pre>
			<pre class="source-code"> .numericFormat(decimalFormat);// numeric format</pre>
			<p>The<a id="_idIndexMarker1038"/> complete code next to other examples is available in the bundled code in the application named <em class="italic">Format</em> (available for MySQL and PostgreSQL).</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Exporting INSERT statements</h2>
			<p>jOOQ can<a id="_idIndexMarker1039"/> export <strong class="source-inline">Result</strong>/<strong class="source-inline">Cursor</strong> as <strong class="source-inline">INSERT</strong> statements via the <strong class="source-inline">formatInsert()</strong> method and its overloads. By default, if the first record is <strong class="source-inline">TableRecord</strong>, then <strong class="source-inline">formatInsert()</strong> uses the first record's <strong class="source-inline">TableRecord.getTable()</strong> method to generate <strong class="source-inline">INSERT</strong> statements into this table, otherwise, it generates <strong class="source-inline">INSERT</strong> statements into <strong class="source-inline">UNKNOWN_TABLE</strong>. In both cases, jOOQ calls the <strong class="source-inline">Result.fields()</strong> method to determine the column names.</p>
			<p>Here is an example that exports the generated <strong class="source-inline">INSERT</strong> statements into a file on disk. The <strong class="source-inline">INSERT</strong> statements are generated into a database table named <strong class="source-inline">product_stats</strong> specified via <strong class="source-inline">formatInsert(Writer writer, Table&lt;?&gt; table, Field&lt;?&gt;… fields)</strong>:</p>
			<pre class="source-code">try (BufferedWriter bw = Files.newBufferedWriter(</pre>
			<pre class="source-code">  Paths.get("resultInserts.txt"), StandardCharsets.UTF_8,</pre>
			<pre class="source-code">  StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) {</pre>
			<pre class="source-code">  ctx.select(PRODUCT.PRODUCT_ID, PRODUCT.BUY_PRICE, </pre>
			<pre class="source-code">             field("avg_price"), PRODUCT.MSRP)</pre>
			<pre class="source-code">     .from(PRODUCT, lateral(select(</pre>
			<pre class="source-code">       avg(ORDERDETAIL.PRICE_EACH).as("avg_price")) </pre>
			<pre class="source-code">       .from(ORDERDETAIL)</pre>
			<pre class="source-code">       .where(PRODUCT.PRODUCT_ID.eq(ORDERDETAIL</pre>
			<pre class="source-code">         .PRODUCT_ID))))</pre>
			<pre class="source-code">     .limit(5)</pre>
			<pre class="source-code">     .fetch()</pre>
			<pre class="source-code">     .formatInsert(bw, table("product_stats"));</pre>
			<pre class="source-code">} catch (IOException ex) { // handle exception }</pre>
			<p>A generated <strong class="source-inline">INSERT</strong> statement looks like the following:</p>
			<pre class="source-code">INSERT INTO product_stats VALUES (29, 108.06, 114.23, 127.13);</pre>
			<p>The complete <a id="_idIndexMarker1040"/>code next to other examples, including exporting <strong class="source-inline">INSERT</strong> statements for UDT, JSON, array, and embeddable types, is available in the bundled code, <strong class="source-inline">Format</strong> (available for MySQL and PostgreSQL). Next, let's talk about batching.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/>Batching</h1>
			<p>Batching <a id="_idIndexMarker1041"/>can be the perfect solution for avoiding performance penalties caused by a significant number of separate database/network round trips representing inserts, deletes, updates, merges, and so on. For instance, without batching, having 1,000 inserts requires 1,000 separate round trips, while employing batching with a batch size of 30 will result in 34 separate round trips. The more inserts (statements) we have, the more helpful batching is. </p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>Batching via DSLContext.batch()</h2>
			<p>The <strong class="source-inline">DSLContext</strong> class <a id="_idIndexMarker1042"/>exposes a suite of <strong class="source-inline">batch()</strong> methods that allow us to execute a set of queries in batch mode. So, we have the following <strong class="source-inline">batch()</strong> methods:</p>
			<pre class="source-code">BatchBindStep batch(String sql)</pre>
			<pre class="source-code">BatchBindStep batch(Query query)</pre>
			<pre class="source-code">Batch batch(String... queries)</pre>
			<pre class="source-code">Batch batch(Query... queries)</pre>
			<pre class="source-code">Batch batch(Queries queries)</pre>
			<pre class="source-code">Batch batch(Collection&lt;? extends Query&gt; queries)</pre>
			<pre class="source-code">Batch batch(String sql, Object[]... bindings)</pre>
			<pre class="source-code">Batch batch(Query query, Object[]... bindings)</pre>
			<p>Behind the <a id="_idIndexMarker1043"/>scenes, jOOQ implements these methods via JDBC's <strong class="source-inline">addBatch()</strong>. Each query is accumulated in the batch via <strong class="source-inline">addBatch()</strong>, and in the end, it calls the JDBC <strong class="source-inline">executeBatch()</strong> method to send the batch to the database.</p>
			<p>For instance, let's assume that we need to batch a set of <strong class="source-inline">INSERT</strong> statements into the <strong class="source-inline">SALE</strong> table. If you have a Hibernate (JPA) background, then you know that this kind of batch will not work because the <strong class="source-inline">SALE</strong> table has an auto-incremented primary key, and Hibernate will automatically disable/prevent insert batching. But, jOOQ doesn't have such issues, so batching a set of inserts into a table having an auto-incremented primary key can be done via <strong class="source-inline">batch(Query... queries)</strong>, as follows:</p>
			<pre class="source-code">int[] result = ctx.batch(</pre>
			<pre class="source-code">  ctx.insertInto(SALE, SALE.FISCAL_YEAR, SALE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">         SALE.SALE_, SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">     .values(2005, 1370L, 1282.64, 1, 0.0),</pre>
			<pre class="source-code">  ctx.insertInto(SALE, SALE.FISCAL_YEAR, SALE.EMPLOYEE_NUMBER,</pre>
			<pre class="source-code">           SALE.SALE_, SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">     .values(2004, 1370L, 3938.24, 1, 0.0),</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code"> ).execute();</pre>
			<p>The returned array contains the number of affected rows per <strong class="source-inline">INSERT</strong> statement (in this case, <strong class="source-inline">[1, 1, 1, …]</strong>). While executing several queries without bind values can be done as you just saw, jOOQ allows us to execute one query several times with bind values as follows:</p>
			<pre class="source-code">int[] result = ctx.batch(</pre>
			<pre class="source-code">  ctx.insertInto(SALE, SALE.FISCAL_YEAR,SALE.EMPLOYEE_NUMBER,  </pre>
			<pre class="source-code">        SALE.SALE_, SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">     .values((Integer) null, null, null, null, null))</pre>
			<pre class="source-code">     .bind(2005, 1370L, 1282.64, 1, 0.0)</pre>
			<pre class="source-code">     .bind(2004, 1370L, 3938.24, 1, 0.0)</pre>
			<pre class="source-code">     ...</pre>
			<pre class="source-code"> .execute();</pre>
			<p>Notice <a id="_idIndexMarker1044"/>that you will have to provide <em class="italic">dummy</em> bind values for the original query, and this is commonly achieved via <strong class="source-inline">null</strong> values, as in this example. jOOQ generates a single query (<strong class="source-inline">PreparedStatement</strong>) with placeholders (<strong class="source-inline">?</strong>) and will loop the bind values to populate the batch. Whenever you see that <strong class="source-inline">int[]</strong> contains a negative value (for instance, <strong class="source-inline">-2</strong>) it means that the affected row count value couldn't be determined by JDBC.</p>
			<p>In most cases, JDBC prepared statements are better, so, whenever possible, jOOQ relies on <strong class="source-inline">PreparedStatement</strong> (<a href="http://www.jooq.org/doc/latest/manual/sql-execution/statement-type/">www.jooq.org/doc/latest/manual/sql-execution/statement-type/</a>). But, we can easily switch to static statements (<strong class="source-inline">java.sql.Statement</strong>) via <strong class="source-inline">setStatementType()</strong> or <strong class="source-inline">withStatementType()</strong> as in the following example (you can also apply this globally via <strong class="source-inline">@Bean</strong>):</p>
			<pre class="source-code">int[] result = ctx.configuration().derive(new  </pre>
			<pre class="source-code"> Settings().withStatementType(StatementType.STATIC_STATEMENT))</pre>
			<pre class="source-code"> .dsl().batch(</pre>
			<pre class="source-code">    ctx.insertInto(SALE, SALE.FISCAL_YEAR,   </pre>
			<pre class="source-code">          SALE.EMPLOYEE_NUMBER, SALE.SALE_, SALE.FISCAL_MONTH,  </pre>
			<pre class="source-code">          SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">       .values((Integer) null, null, null, null, null))</pre>
			<pre class="source-code">       .bind(2005, 1370L, 1282.64, 1, 0.0)</pre>
			<pre class="source-code">       .bind(2004, 1370L, 3938.24, 1, 0.0)</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">   .execute();</pre>
			<p>This time, the bind values will be automatically inlined into a static batch query. This is the same as the first examples from this section, which use <strong class="source-inline">batch(Query... queries)</strong>.</p>
			<p>Obviously, using<a id="_idIndexMarker1045"/> binding values is also useful for inserting (updating, deleting, and so on) a collection of objects. For instance, consider the following list of <strong class="source-inline">SimpleSale</strong> (POJO):</p>
			<pre class="source-code">List&lt;SimpleSale&gt; sales = List.of(</pre>
			<pre class="source-code">   new SimpleSale(2005, 1370L, 1282.64, 1, 0.0),</pre>
			<pre class="source-code">   new SimpleSale(2004, 1370L, 3938.24, 1, 0.0),</pre>
			<pre class="source-code">   new SimpleSale(2004, 1370L, 4676.14, 1, 0.0));</pre>
			<p>First, we define the proper <strong class="source-inline">BatchBindStep</strong> containing one <strong class="source-inline">INSERT</strong> (it could be <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and so on, as well):</p>
			<pre class="source-code">BatchBindStep batch = ctx.batch(ctx.insertInto(SALE, </pre>
			<pre class="source-code">      SALE.FISCAL_YEAR, SALE.EMPLOYEE_NUMBER, SALE.SALE_,    </pre>
			<pre class="source-code">      SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .values((Integer) null, null, null, null, null));</pre>
			<p>Second, we bind the values and execute the batch:</p>
			<pre class="source-code">sales.forEach(s -&gt; batch.bind(s.getFiscalYear(), </pre>
			<pre class="source-code">    s.getEmployeeNumber(), s.getSale(), </pre>
			<pre class="source-code">    s.getFiscalMonth(),s.getRevenueGrowth()));</pre>
			<pre class="source-code">batch.execute();</pre>
			<p>You can find these examples in the bundled code, <strong class="source-inline">BatchInserts</strong>, next to examples for batching updates, <strong class="source-inline">BatchUpdates</strong>, and deletes, <strong class="source-inline">BatchDeletes</strong>, as well. But, we can also <a id="_idIndexMarker1046"/>combine all these kinds of statements in a single <strong class="source-inline">batch()</strong> method, as follows:</p>
			<pre class="source-code">int[] result = ctx.batch(</pre>
			<pre class="source-code"> ctx.insertInto(SALE, SALE.FISCAL_YEAR,SALE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">      SALE.SALE_, SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">    .values(2005, 1370L, 1282.64, 1, 0.0),</pre>
			<pre class="source-code"> ctx.insertInto(SALE, SALE.FISCAL_YEAR, SALE.EMPLOYEE_NUMBER,</pre>
			<pre class="source-code">  SALE.SALE_, SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .values(2004, 1370L, 3938.24, 1, 0.0),                    </pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code"> ctx.update(EMPLOYEE).set(EMPLOYEE.SALARY,   </pre>
			<pre class="source-code">   EMPLOYEE.SALARY.plus(1_000))</pre>
			<pre class="source-code">    .where(EMPLOYEE.SALARY.between(100_000, 120_000)),</pre>
			<pre class="source-code"> ctx.update(EMPLOYEE).set(EMPLOYEE.SALARY, </pre>
			<pre class="source-code">   EMPLOYEE.SALARY.plus(5_000))</pre>
			<pre class="source-code">    .where(EMPLOYEE.SALARY.between(65_000, 80_000)),</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code"> ctx.deleteFrom(BANK_TRANSACTION)</pre>
			<pre class="source-code">    .where(BANK_TRANSACTION.TRANSACTION_ID.eq(1)),</pre>
			<pre class="source-code"> ctx.deleteFrom(BANK_TRANSACTION)</pre>
			<pre class="source-code">    .where(BANK_TRANSACTION.TRANSACTION_ID.eq(2)),</pre>
			<pre class="source-code"> ...   </pre>
			<pre class="source-code"> ).execute();</pre>
			<p>While using <strong class="source-inline">batch()</strong> methods, jOOQ will always preserve your order of statements and will send all these statements in a single batch (round trip) to the database. This example is available in an application named <em class="italic">CombineBatchStatements</em>.</p>
			<p>During <a id="_idIndexMarker1047"/>the batch preparation, the statements are accumulated in memory, so you have to pay attention to avoid memory issues such as OOMs. You can easily emulate a batch size by calling the jOOQ batch in a <strong class="source-inline">for</strong> loop that limits the number of statements to a certain value. You can execute all batches in a single transaction (in case of an issue, roll back all batches) or execute each batch in a separate transaction (in case of an issue, roll back only the last batch). You can see these approaches in the bundled code, <strong class="source-inline">EmulateBatchSize</strong>.</p>
			<p>While a synchronous batch ends up with an <strong class="source-inline">execute()</strong> call, an asynchronous batch ends up with an <strong class="source-inline">executeAsync()</strong> call. For example, consider the application named <em class="italic">AsyncBatch</em>. Next, let's talk about batching records.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>Batching records</h2>
			<p>Batching records <a id="_idIndexMarker1048"/>is another story. The jOOQ API for batching records relies on a set of dedicated methods per statement type as follows:</p>
			<ul>
				<li><strong class="source-inline">INSERT</strong>: <strong class="source-inline">batchInsert()</strong> follows <strong class="source-inline">TableRecord.insert()</strong> semantics</li>
				<li><strong class="source-inline">UPDATE</strong>: <strong class="source-inline">batchUpdate()</strong> follows <strong class="source-inline">UpdatableRecord.update()</strong> semantics</li>
				<li><strong class="source-inline">DELETE</strong>: <strong class="source-inline">batchDelete()</strong> follows <strong class="source-inline">UpdatableRecord.delete()</strong> semantics</li>
				<li><strong class="source-inline">MERGE</strong>: <strong class="source-inline">batchMerge()</strong> follows <strong class="source-inline">UpdatableRecord.merge()</strong> semantics</li>
				<li><strong class="source-inline">INSERT</strong>/<strong class="source-inline">UPDATE</strong>: <strong class="source-inline">batchStore()</strong> follows <strong class="source-inline">UpdatableRecord.store()</strong> semantics</li>
			</ul>
			<p>Next, we'll cover each of these statements but before that, let's point out an important aspect. By default, all these methods create batch operations for executing a certain type of query with bind values. jOOQ preserves the order of the records as long as the records generate the same SQL with bind variables, otherwise, the order is changed to group together the records that share the same SQL with bind variables. So, in the best-case scenario, when all records generate the same SQL with bind variables, there will be a single batch operation, while in the worst-case scenario, the number of records will be equal to the number of batch operations. In short, the number of batch operations that will be executed is equal to the number of distinct rendered SQL statements.</p>
			<p>If we switch<a id="_idIndexMarker1049"/> from the default <strong class="source-inline">PreparedStatement</strong> to a static <strong class="source-inline">Statement </strong>(<strong class="source-inline">StatementType.STATIC_STATEMENT</strong>), then the record values are inlined. This time, there will be just one batch operation and the order of records is preserved exactly. Obviously, this is preferable when the order of records must be preserved and/or the batch is very large, and rearranging the records can be time-consuming and results in a significant number of batch operations.</p>
			<h3>Batch records insert, update, and delete</h3>
			<p>Let's consider the following set of <strong class="source-inline">Record</strong>:</p>
			<pre class="source-code">SaleRecord sr1 = new SaleRecord(…, 2005, 1223.23, 1370L, …);</pre>
			<pre class="source-code">SaleRecord sr2 = new SaleRecord(…, 2004, 5483.33, 1166L, …);</pre>
			<pre class="source-code">SaleRecord sr3 = new SaleRecord(…, 2005, 9022.21, 1370L, …);</pre>
			<p>Inserting these records in batch can be done as follows:</p>
			<pre class="source-code">int[] result = ctx.batchInsert(sr3, sr1, sr2).execute();</pre>
			<p>In this case, these <a id="_idIndexMarker1050"/>records are inserted in a single batch operation since the generated SQL with bind variables is the same for <strong class="source-inline">sr1</strong> to <strong class="source-inline">sr3</strong>. Moreover, the batch preserves the order of records as given (<strong class="source-inline">sr3</strong>, <strong class="source-inline">sr1</strong>, and <strong class="source-inline">sr2</strong>). If we want to <a id="_idIndexMarker1051"/>update, and respectively to delete these records, then we <a id="_idIndexMarker1052"/>replace <strong class="source-inline">batchInsert()</strong> with <strong class="source-inline">batchUpdate()</strong>, and, respectively, <strong class="source-inline">batchDelete()</strong>. You can also have these records in a collection and pass that collection to <strong class="source-inline">batchInsert()</strong>, as in this example:</p>
			<pre class="source-code">List&lt;SaleRecord&gt; sales = List.of(sr3, sr1, sr2);</pre>
			<pre class="source-code">int[] result = ctx.batchInsert(sales).execute();</pre>
			<p>Next, let's consider a mix of records:</p>
			<pre class="source-code">SaleRecord sr1 = new SaleRecord(…);</pre>
			<pre class="source-code">SaleRecord sr2 = new SaleRecord(…);</pre>
			<pre class="source-code">BankTransactionRecord bt1 = new BankTransactionRecord(…);</pre>
			<pre class="source-code">SaleRecord sr3 = new SaleRecord(…);</pre>
			<pre class="source-code">SaleRecord sr4 = new SaleRecord(…);</pre>
			<pre class="source-code">BankTransactionRecord bt2 = new BankTransactionRecord(…);</pre>
			<p>Calling <strong class="source-inline">batchInsert(bt1, sr1, sr2, bt2, sr4, sr3)</strong> is executed in two batch <a id="_idIndexMarker1053"/>operations, one for <strong class="source-inline">SaleRecord</strong> and one for <strong class="source-inline">BankTransactionRecord</strong>. jOOQ will group <strong class="source-inline">SaleRecord</strong> (<strong class="source-inline">sr1</strong>, <strong class="source-inline">sr2</strong>, <strong class="source-inline">sr3</strong>, and <strong class="source-inline">sr4</strong>) in one <a id="_idIndexMarker1054"/>batch operation and <strong class="source-inline">BankTransactionRecord</strong> (<strong class="source-inline">bt1</strong> and <strong class="source-inline">bt2</strong>) in another batch operation, so the order of records in not preserved (or, is partially preserved) since (<strong class="source-inline">bt1</strong>, <strong class="source-inline">sr1</strong>, <strong class="source-inline">sr2</strong>, <strong class="source-inline">bt2</strong>, <strong class="source-inline">sr4</strong>, and <strong class="source-inline">sr3</strong>) may <a id="_idIndexMarker1055"/>become ((<strong class="source-inline">bt1</strong> and <strong class="source-inline">bt2</strong>), (<strong class="source-inline">sr1</strong>, <strong class="source-inline">sr2</strong>, <strong class="source-inline">sr4</strong>, and <strong class="source-inline">sr3</strong>)).</p>
			<p>Finally, let's consider these records:</p>
			<pre class="source-code">SaleRecord sr1 = new SaleRecord();</pre>
			<pre class="source-code">sr1.setFiscalYear(2005);</pre>
			<pre class="source-code">sr1.setSale(1223.23);</pre>
			<pre class="source-code">sr1.setEmployeeNumber(1370L);</pre>
			<pre class="source-code">sr1.setTre"d("UP");</pre>
			<pre class="source-code">sr1.setFiscalMonth(1);</pre>
			<pre class="source-code">sr1.setRevenueGrowth(0.0);</pre>
			<pre class="source-code">SaleRecord sr2 = new SaleRecord();</pre>
			<pre class="source-code">sr2.setFiscalYear(2005);</pre>
			<pre class="source-code">sr2.setSale(9022.21);</pre>
			<pre class="source-code">sr2.setFiscalMonth(1);</pre>
			<pre class="source-code">sr2.setRevenueGrowth(0.0);</pre>
			<pre class="source-code">SaleRecord sr3 = new SaleRecord();</pre>
			<pre class="source-code">sr3.setFiscalYear(2003);</pre>
			<pre class="source-code">sr3.setSale(8002.22);</pre>
			<pre class="source-code">sr3.setEmployeeNumber(1504L);</pre>
			<pre class="source-code">sr3.setFiscalMonth(1);</pre>
			<pre class="source-code">sr3.setRevenueGrowth(0.0);</pre>
			<p>If we <a id="_idIndexMarker1056"/>execute <strong class="source-inline">batchInsert(sr3, sr2, sr1)</strong>, then there <a id="_idIndexMarker1057"/>will be three batch operations, since <strong class="source-inline">sr1</strong>, <strong class="source-inline">sr2</strong>, and <strong class="source-inline">sr3</strong> produce three SQLs that will different <a id="_idIndexMarker1058"/>bind variables. The order of records is preserved as <strong class="source-inline">sr3</strong>, <strong class="source-inline">sr2</strong>, and <strong class="source-inline">sr1</strong>. The same flow applies for <strong class="source-inline">batchUpdate()</strong> and <strong class="source-inline">batchDelete()</strong>.</p>
			<p>Any of these examples can take advantage of JDBC static statements by simply adding the <strong class="source-inline">STATIC_STATEMENT</strong> setting as follows:</p>
			<pre class="source-code">int[] result = ctx.configuration().derive(new Settings()</pre>
			<pre class="source-code">  .withStatementType(StatementType.STATIC_STATEMENT))</pre>
			<pre class="source-code">  .dsl().batchInsert/Update/…(…).execute();</pre>
			<p>You can practice these examples in <em class="italic">BatchInserts</em>, <em class="italic">BatchUpdates</em>, and <em class="italic">BatchDeletes</em>.</p>
			<h3>Batch merge</h3>
			<p>As you <a id="_idIndexMarker1059"/>already know from the bullet list from the <em class="italic">Batching records</em> section, <strong class="source-inline">batchMerge()</strong> is useful for executing batches of <strong class="source-inline">MERGE</strong> statements. Mainly, <strong class="source-inline">batchMerge()</strong> conforms to the <strong class="source-inline">UpdatableRecord.merge()</strong> semantics covered in <a href="B16833_09.xhtml#_idTextAnchor162"><em class="italic">Chapter 9</em></a>, <em class="italic">CRUD, Transactions, and Locking</em>.</p>
			<p>In other words, <strong class="source-inline">batchMerge()</strong> renders the synthetic <strong class="source-inline">INSERT ... ON DUPLICATE KEY UPDATE</strong> statement emulated depending on dialect; in MySQL, via <strong class="source-inline">INSERT ... ON DUPLICATE KEY UPDATE</strong>, in PostgreSQL, via <strong class="source-inline">INSERT ... ON CONFLICT</strong>, and in SQL Server and Oracle, via <strong class="source-inline">MERGE INTO</strong>. Practically, <strong class="source-inline">batchMerge()</strong> renders an <strong class="source-inline">INSERT ... ON DUPLICATE KEY UPDATE</strong> statement independent of the fact that the record has been previously fetched from the database or is <a id="_idIndexMarker1060"/>created now. The number of distinct rendered SQL statements gives us the number of batches. So, by default (which means default settings, default changed flags, and no optimistic locking), jOOQ renders a query that delegates to the database the decision between insert and update based on the primary key uniqueness. Let's consider the following records: </p>
			<pre class="source-code">SaleRecord sr1 = new SaleRecord(1L, 2005, 1223.23, ...);</pre>
			<pre class="source-code">SaleRecord sr2 = new SaleRecord(2L, 2004, 543.33, ...);</pre>
			<pre class="source-code">SaleRecord sr3 = new SaleRecord(9999L, 2003, 8002.22, ...);</pre>
			<p>We execute a merge in batch as shown here:</p>
			<pre class="source-code">int[] result = ctx.batchMerge(sr1, sr2, sr3).execute();</pre>
			<p>For instance, in PostgreSQL, the render SQL is as follows:</p>
			<pre class="source-code">INSERT INTO "public"."sale" ("sale_id", </pre>
			<pre class="source-code">                             "fiscal_year", ..., "trend")</pre>
			<pre class="source-code">  VALUES (?, ?, ..., ?) ON CONFLICT ("sale_id") DO</pre>
			<pre class="source-code">  UPDATE SET "sale_id" = ?, </pre>
			<pre class="source-code">             "fiscal_year" = ?, ..., "trend" = ?</pre>
			<pre class="source-code">  WHERE "public"."sale"."sale_id" = ?</pre>
			<p>Because <strong class="source-inline">sr1</strong> (having primary key <em class="italic">1</em>) and <strong class="source-inline">sr2</strong> (having primary key <em class="italic">2</em>) already exist in the <strong class="source-inline">SALE</strong> table, the database will decide to update them, while <strong class="source-inline">sr3</strong> (having primary key <em class="italic">9999</em>) will be inserted, since it doesn't exist in the database. There will be just one batch since the generated SQL with bind variables is the same for all <strong class="source-inline">SaleRecord</strong>. The order of records is preserved. More examples are available in <strong class="source-inline">BatchMerges</strong>.</p>
			<h3>Batch store</h3>
			<p><strong class="source-inline">batchStore()</strong> is <a id="_idIndexMarker1061"/>useful for executing <strong class="source-inline">INSERT</strong> or <strong class="source-inline">UPDATE</strong> statements in the batch. Mainly, <strong class="source-inline">batchStore()</strong> conforms to <strong class="source-inline">UpdatableRecord.store()</strong>, which was covered in the previous chapter. So, unlike <strong class="source-inline">batchMerge()</strong>, which delegates the decision of choosing between update or insert to the database, <strong class="source-inline">batchStore()</strong> allows jOOQ to decide whether INSERT or UPDATE should be<a id="_idIndexMarker1062"/> rendered by analyzing the state of the primary key's value.</p>
			<p>For instance, let's rely on defaults (which means default settings, default changed flags, and no optimistic locking), the following two records are used for executing in a batch store:</p>
			<pre class="source-code">SaleRecord sr1 = new SaleRecord(9999L,</pre>
			<pre class="source-code">                                2005, 1223.23, 1370L, ...);</pre>
			<pre class="source-code">SaleRecord sr2 = ctx.selectFrom(SALE)</pre>
			<pre class="source-code">   .where(SALE.SALE_ID.eq(1L)).fetchOne();</pre>
			<pre class="source-code">sr2.setFiscalYear(2006);</pre>
			<pre class="source-code">int[] result = ctx.batchStore(sr1, sr2).execute();</pre>
			<p>Since <strong class="source-inline">sr1</strong> is a brand-new <strong class="source-inline">SaleRecord</strong>, it will result in <strong class="source-inline">INSERT</strong>. On the other hand, <strong class="source-inline">sr2</strong> was fetched from the database and it was updated, so it will result in <strong class="source-inline">UPDATE</strong>. Obviously, the generated SQL statements are not the same, therefore, there will be two batch operations and the order will be preserved as <strong class="source-inline">sr1</strong> and <strong class="source-inline">sr2</strong>.</p>
			<p>Here is another example that updates <strong class="source-inline">SaleRecord</strong> and adds a few more:</p>
			<pre class="source-code">Result&lt;SaleRecord&gt; sales = ctx.selectFrom(SALE).fetch();</pre>
			<pre class="source-code"> // update all sales</pre>
			<pre class="source-code"> sales.forEach(sale -&gt; { sale.setTrend("UP"); });</pre>
			<pre class="source-code"> // add more new sales</pre>
			<pre class="source-code"> sales.add(new SaleRecord(...));</pre>
			<pre class="source-code"> sales.add(new SaleRecord(...));</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code"> int[] result = ctx.batchStore(sales)</pre>
			<pre class="source-code">  .execute();</pre>
			<p>We have two <a id="_idIndexMarker1063"/>batch operations: a batch that contains all updates needed to update the fetched <strong class="source-inline">SaleRecord</strong> and a batch that contains all inserts needed to insert the new <strong class="source-inline">SaleRecord</strong>.</p>
			<p>In the bundled code, you can find more examples that couldn't be listed here because they are large, so take your time to practice examples from <strong class="source-inline">BatchStores</strong>. This was the last topic of this section. Next, let's talk about the <em class="italic">batched connection</em> API.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>Batched connection</h2>
			<p>Besides the<a id="_idIndexMarker1064"/> batching capabilities covered so far, jOOQ also comes with an API named <strong class="source-inline">org.jooq.tools.jdbc.BatchedConnection</strong>. Its main purpose is to buffer already existing jOOQ/JDBC statements and execute them in batches without requiring us to change the SQL strings or the order of execution. We can use <strong class="source-inline">BatchedConnection</strong> explicitly or indirectly via <strong class="source-inline">DSLContext.batched</strong><strong class="source-inline">(BatchedRunnable runnable)</strong> or <strong class="source-inline">DSLContext.batchedResult</strong><strong class="source-inline">(BatchedCallable&lt;T&gt; callable)</strong>. The difference between them consists of the fact that the former returns <strong class="source-inline">void</strong> and the latter returns <strong class="source-inline">T</strong>.</p>
			<p>For instance, let's assume that we have a method (service) that produces a lot of <strong class="source-inline">INSERT</strong> and <strong class="source-inline">UPDATE</strong> statements:</p>
			<pre class="source-code">void insertsAndUpdates(Configuration c) {</pre>
			<pre class="source-code">   DSLContext ctxLocal = c.dsl();</pre>
			<pre class="source-code">   ctxLocal.insertInto(…).execute();</pre>
			<pre class="source-code">   …</pre>
			<pre class="source-code">   ctxLocal.update(…).execute();</pre>
			<pre class="source-code">   …</pre>
			<pre class="source-code">}</pre>
			<p>To improve the <a id="_idIndexMarker1065"/>performance of this method, we can simply add batch-collecting code via <strong class="source-inline">DSLContext.batched()</strong>, as here:</p>
			<pre class="source-code">public void batchedInsertsAndUpdates() {</pre>
			<pre class="source-code">   ctx.batched(this::insertsAndUpdates);</pre>
			<pre class="source-code">}</pre>
			<p>Of course, if <strong class="source-inline">INSERT</strong> statements are produced by an <strong class="source-inline">inserts(Configuration c)</strong> method and <strong class="source-inline">UPDATE</strong> statements by another method, <strong class="source-inline">updates(Configuration c)</strong>, then both of them should be collected:</p>
			<pre class="source-code">public void batchedInsertsAndUpdates() {</pre>
			<pre class="source-code">   ctx.batched((Configuration c) -&gt; {</pre>
			<pre class="source-code">      inserts(c);</pre>
			<pre class="source-code">      updates(c);</pre>
			<pre class="source-code">   });</pre>
			<pre class="source-code">}</pre>
			<p>Moreover, this API can be used for batching jOOQ records as well. Here is a sample:</p>
			<pre class="source-code">ctx.batched(c -&gt; {</pre>
			<pre class="source-code">  Result&lt;SaleRecord&gt; records = c.dsl().selectFrom(SALE)</pre>
			<pre class="source-code">     .limit(5).fetch();</pre>
			<pre class="source-code">  records.forEach(record -&gt; {</pre>
			<pre class="source-code">    record.setTrend("CONSTANT");</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    record.store();</pre>
			<pre class="source-code">  });</pre>
			<pre class="source-code">});</pre>
			<p>Or, here is <a id="_idIndexMarker1066"/>another example:</p>
			<pre class="source-code">List&lt;SaleRecord&gt; sales = List.of(</pre>
			<pre class="source-code">  new SaleRecord(...), new SaleRecord(...), ...</pre>
			<pre class="source-code">);</pre>
			<pre class="source-code">ctx.batched(c -&gt; {</pre>
			<pre class="source-code">  for (SaleRecord sale : sales) {</pre>
			<pre class="source-code">    c.dsl().insertInto(SALE)</pre>
			<pre class="source-code">           .set(sale)</pre>
			<pre class="source-code">           .onDuplicateKeyUpdate()</pre>
			<pre class="source-code">           .set(SALE.SALE_, sale.getSale())</pre>
			<pre class="source-code">           .execute();</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}); // batching is happening here</pre>
			<p>Notice that jOOQ will preserve exactly your order of statements and this order may affect the number of batch operations. Read carefully the following note, since it is very important to have it in your mind while working with this API.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">jOOQ automatically creates a new batch every time it detects that:</p>
			<p class="callout">- The SQL string changes (even whitespace is considered a change).</p>
			<p class="callout">- A query produces results (for instance, <strong class="source-inline">SELECT</strong>); such queries are not part of the batch.</p>
			<p class="callout">- A static statement occurs after a prepared statement (or vice versa).</p>
			<p class="callout">- A JDBC interaction is invoked (transaction committed, connection closed, and so on).</p>
			<p class="callout">- The batch size threshold is reached.</p>
			<p>As an important limitation, notice that the affected row count value will be reported always by the JDBC <strong class="source-inline">PreparedStatement.executeUpdate()</strong> as 0.</p>
			<p>Notice<a id="_idIndexMarker1067"/> that the last bullet from the previous note refers to a batch size threshold. Well, this API can take advantage of <strong class="source-inline">Settings.batchSize()</strong>, which sets the maximum batch statement size as here:</p>
			<pre class="source-code">@Bean</pre>
			<pre class="source-code">public Settings jooqSettings() {</pre>
			<pre class="source-code">   return new Settings().withBatchSize(30);</pre>
			<pre class="source-code">}</pre>
			<p>Moreover, if we rely on <strong class="source-inline">BatchedConnection</strong> explicitly, then we can wrap the JDBC connection and specify the batch size as an argument via the <strong class="source-inline">BatchedConnection(Connection delegate, int batchSize)</strong> constructor as follows (here, the batch size is set to 2; consider reading the comments):</p>
			<pre class="source-code">try ( BatchedConnection conn = new BatchedConnection(</pre>
			<pre class="source-code"> DriverManager.getConnection(</pre>
			<pre class="source-code">     "jdbc:mysql://localhost:3306/classicmodels", </pre>
			<pre class="source-code">     "root", "root"), 2)) {</pre>
			<pre class="source-code">  try ( PreparedStatement stmt = conn.prepareStatement(</pre>
			<pre class="source-code">    "insert into `classicmodels`.`sale` (`fiscal_year`, </pre>
			<pre class="source-code">    `employee_number`, `sale`, `fiscal_month`, </pre>
			<pre class="source-code">    `revenue_growth`) " + "values (?, ?, ?, ?, ?);")) {</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">   // the next 2 statements will become the first batch    </pre>
			<pre class="source-code">   stmt.setInt(1, 2004);</pre>
			<pre class="source-code">   stmt.setLong(2, 1166L);</pre>
			<pre class="source-code">   stmt.setDouble(3, 543.33);</pre>
			<pre class="source-code">   stmt.setInt(4, 1);</pre>
			<pre class="source-code">   stmt.setDouble(5, 0.0);</pre>
			<pre class="source-code">   stmt.executeUpdate();</pre>
			<pre class="source-code">   stmt.setInt(1, 2005);</pre>
			<pre class="source-code">   stmt.setLong(2, 1370L);</pre>
			<pre class="source-code">   stmt.setDouble(3, 9022.20);</pre>
			<pre class="source-code">   stmt.setInt(4, 1);</pre>
			<pre class="source-code">   stmt.setDouble(5, 0.0);</pre>
			<pre class="source-code">   stmt.executeUpdate();</pre>
			<pre class="source-code">   // reached batch limit so this is the second batch</pre>
			<pre class="source-code">   stmt.setInt(1, 2003);</pre>
			<pre class="source-code">   stmt.setLong(2, 1166L);</pre>
			<pre class="source-code">   stmt.setDouble(3, 3213.0);</pre>
			<pre class="source-code">   stmt.setInt(4, 1);</pre>
			<pre class="source-code">   stmt.setDouble(5, 0.0);</pre>
			<pre class="source-code">   stmt.executeUpdate();</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  // since the following SQL string is different, </pre>
			<pre class="source-code">  // next statements represents the third batch</pre>
			<pre class="source-code">  try ( PreparedStatement stmt = conn.prepareStatement(</pre>
			<pre class="source-code">   "insert into `classicmodels`.`sale` (`fiscal_year`, </pre>
			<pre class="source-code">    `employee_number`, `sale`, `fiscal_month`, </pre>
			<pre class="source-code">      `revenue_growth`,`trend`) " </pre>
			<pre class="source-code">      + "values (?, ?, ?, ?, ?, ?);")) {</pre>
			<pre class="source-code">     stmt.setInt(1, 2004);</pre>
			<pre class="source-code">     stmt.setLong(2, 1166L);</pre>
			<pre class="source-code">     stmt.setDouble(3, 4541.35);</pre>
			<pre class="source-code">     stmt.setInt(4, 1);</pre>
			<pre class="source-code">     stmt.setDouble(5, 0.0);</pre>
			<pre class="source-code">     stmt.setString(6, "UP");</pre>
			<pre class="source-code">     stmt.executeUpdate();</pre>
			<pre class="source-code">     stmt.setInt(1, 2005);</pre>
			<pre class="source-code">     stmt.setLong(2, 1370L);</pre>
			<pre class="source-code">     stmt.setDouble(3, 1282.64);</pre>
			<pre class="source-code">     stmt.setInt(4, 1);</pre>
			<pre class="source-code">     stmt.setDouble(5, 0.0);</pre>
			<pre class="source-code">     stmt.setString(6, "DOWN");</pre>
			<pre class="source-code">     stmt.executeUpdate();</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">} catch (SQLException ex) { … } </pre>
			<p>Moreover, <strong class="source-inline">BatchedConnection</strong> implements <strong class="source-inline">java.sql.Connection</strong>, so you can use the<a id="_idIndexMarker1068"/> entire arsenal of <strong class="source-inline">Connection</strong> methods, including methods for shaping the behavior of transactions. More examples are available in <strong class="source-inline">Batched</strong>.</p>
			<p>Next, let's tackle two special cases encountered in PostgreSQL and SQL Server.</p>
			<h3>Batching and fetching sequences in PostgreSQL/Oracle</h3>
			<p>As you<a id="_idIndexMarker1069"/> know, PostgreSQL/Oracle can rely on sequences for providing primary keys (and other unique values). For instance, our PostgreSQL <strong class="source-inline">employee</strong> table uses the following sequence for producing <a id="_idIndexMarker1070"/>sequence values for <strong class="source-inline">employee_number</strong>:</p>
			<pre class="source-code">CREATE TABLE "employee" (</pre>
			<pre class="source-code">  "employee_number" BIGINT NOT NULL,</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  CONSTRAINT "employee_pk" PRIMARY KEY ("employee_number"),</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">);</pre>
			<pre class="source-code">CREATE SEQUENCE "employee_seq" START 100000 INCREMENT 10   </pre>
			<pre class="source-code">        MINVALUE 100000 MAXVALUE 10000000 </pre>
			<pre class="source-code">        OWNED BY "employee"."employee_number";</pre>
			<p>But, in the context of batching, fetching the <strong class="source-inline">employee</strong> primary keys from the application requires a database round trip (<strong class="source-inline">SELECT</strong>) for each primary key. Obviously, it is a performance penalty to have a batch of <em class="italic">n</em> <strong class="source-inline">INSERT</strong> statements and execute <em class="italic">n</em> round trips (<strong class="source-inline">SELECT</strong> statements) just to fetch their primary keys. Fortunately, jOOQ leverages at least two solutions. One of them is to inline sequence references in SQL statements (the <strong class="source-inline">EMPLOYEE_SEQ.nextval()</strong> call):</p>
			<pre class="source-code">int[] result = ctx.batch(</pre>
			<pre class="source-code">  ctx.insertInto(EMPLOYEE, EMPLOYEE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">                 EMPLOYEE.LAST_NAME, ...)</pre>
			<pre class="source-code">     .values(EMPLOYEE_SEQ.nextval(), val("Lionel"), ...),</pre>
			<pre class="source-code">  ctx.insertInto(EMPLOYEE, EMPLOYEE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">                 EMPLOYEE.LAST_NAME...)</pre>
			<pre class="source-code">     .values(EMPLOYEE_SEQ.nextval(), val("Ion"), ...),</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code"> ).execute();</pre>
			<p>Another <a id="_idIndexMarker1071"/>approach is to <a id="_idIndexMarker1072"/>pre-fetch a number of <em class="italic">n</em> primary keys via <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">var ids = ctx.fetch(EMPLOYEE_SEQ.nextvals(n));</pre>
			<p>Then, use these primary keys in batch (notice the <strong class="source-inline">ids.get(n).value1()</strong> call):</p>
			<pre class="source-code">int[] result = ctx.batch(</pre>
			<pre class="source-code">  ctx.insertInto(EMPLOYEE, EMPLOYEE.EMPLOYEE_NUMBER,  </pre>
			<pre class="source-code">                 EMPLOYEE.LAST_NAME, ...)</pre>
			<pre class="source-code">     .values(ids.get(0).value1(), "Lionel", ...),</pre>
			<pre class="source-code">  ctx.insertInto(EMPLOYEE, EMPLOYEE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">                 EMPLOYEE.LAST_NAME, ...)</pre>
			<pre class="source-code">     .values(ids.get(1).value1(), "Ion", ...),</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">).execute();</pre>
			<p>Both of these examples rely on the <strong class="source-inline">public static final EMPLOYEE_SEQ</strong> field or, more precisely, on <strong class="source-inline">jooq.generated.Sequences.EMPLOYEE_SEQ</strong>. Mainly, the jOOQ Code Generator will generate a sequence object per database sequence and each such object has access to methods such as <strong class="source-inline">nextval()</strong>, <strong class="source-inline">currval()</strong>, <strong class="source-inline">nextvals(int n)</strong>, and others, which will be covered in <a href="B16833_11.xhtml#_idTextAnchor209"><em class="italic">Chapter 11</em></a>, <em class="italic">jOOQ Keys</em>.</p>
			<p>Of course, if you <a id="_idIndexMarker1073"/>rely on an auto-generated sequence from (<strong class="source-inline">BIG</strong>)<strong class="source-inline">SERIAL</strong> or on a sequence associated as default (for example, in the <strong class="source-inline">sale</strong> table, we have a sequence associated to <strong class="source-inline">sale_id</strong> as <strong class="source-inline">DEFAULT NEXTVAL ('sale_seq')</strong>), then the simplest way to batch is to omit the primary key field in statements, and the database will do the rest. The<a id="_idIndexMarker1074"/> previous examples, along with many more, are available in <em class="italic">BatchInserts</em> for PostgreSQL.</p>
			<h3>SQL Server IDENTITY columns and explicit values</h3>
			<p>Inserting <a id="_idIndexMarker1075"/>explicit values for the SQL Server <strong class="source-inline">IDENTITY</strong> columns results in the error <em class="italic">Cannot insert explicit value for identity column in table 'table_name' when </em><strong class="source-inline">IDENTITY_INSERT</strong><em class="italic"> is set to </em><strong class="source-inline">OFF</strong>. Bypassing this error can be done by setting <strong class="source-inline">IDENTITY_INSERT</strong> to <strong class="source-inline">ON</strong> before <strong class="source-inline">INSERT</strong>. In the context of batching, this can be done as shown here:</p>
			<pre class="source-code">int[] result = ctx.batch(</pre>
			<pre class="source-code">  ctx.query("SET IDENTITY_INSERT [sale] ON"),</pre>
			<pre class="source-code">  ctx.insertInto(SALE, SALE.SALE_ID, SALE.FISCAL_YEAR, …)</pre>
			<pre class="source-code">     .values(1L, 2005, …),</pre>
			<pre class="source-code">  ctx.insertInto(SALE, SALE.SALE_ID, SALE.FISCAL_YEAR, …)</pre>
			<pre class="source-code">     .values(2L, 2004, …),</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">  ctx.query("SET IDENTITY_INSERT [sale] OFF")</pre>
			<pre class="source-code">).execute();</pre>
			<p>You can find this example in <strong class="source-inline">BatchInserts</strong> for SQL Server. Next, let's talk about bulking.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor204"/>Bulking</h1>
			<p>Writing<a id="_idIndexMarker1076"/> bulk queries in jOOQ is just a matter of using the jOOQ DSL API. For instance, a bulk insert SQL looks like this:</p>
			<pre class="source-code">INSERT IGNORE INTO `classicmodels`.`order` (</pre>
			<pre class="source-code">  `order_date`, `required_date`, `shipped_date`, </pre>
			<pre class="source-code">  `status`, `comments`, `customer_number`, `amount`) </pre>
			<pre class="source-code">VALUES (?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?), </pre>
			<pre class="source-code">       (?, ?, ?, ?, ?, ?, ?)</pre>
			<p>This can be expressed in jOOQ by chaining the <strong class="source-inline">values()</strong> call:</p>
			<pre class="source-code">ctx.insertInto(ORDER)</pre>
			<pre class="source-code">   .columns(ORDER.ORDER_DATE, ORDER.REQUIRED_DATE,</pre>
			<pre class="source-code">            ORDER.SHIPPED_DATE, ORDER.STATUS, </pre>
			<pre class="source-code">            ORDER.COMMENTS,ORDER.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">            ORDER.AMOUNT)</pre>
			<pre class="source-code">    .values(LocalDate.of(2004,10,22), LocalDate.of(2004,10,23),</pre>
			<pre class="source-code">     LocalDate.of(2004,10,23", "Shipped",</pre>
			<pre class="source-code">     "New order inserted...", 363L, BigDecimal.valueOf(322.59))</pre>
			<pre class="source-code">    .values(LocalDate.of(2003,12,2), LocalDate.of(2003,1,3),</pre>
			<pre class="source-code">     LocalDate.of(2003,2,26), "Resolved",</pre>
			<pre class="source-code">     "Important order ...", 128L, BigDecimal.valueOf(455.33))</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    .onDuplicateKeyIgnore() // onDuplicateKeyUpdate().set(...)</pre>
			<pre class="source-code">   .execute()</pre>
			<p>Or, you<a id="_idIndexMarker1077"/> can use a bulk update SQL as follows:</p>
			<pre class="source-code">update `classicmodels`.`sale` </pre>
			<pre class="source-code">set </pre>
			<pre class="source-code">  `classicmodels`.`sale`.`sale` = case when  </pre>
			<pre class="source-code">  `classicmodels`.`sale`.`employee_number` = ? then (</pre>
			<pre class="source-code">    `classicmodels`.`sale`.`sale` + ?</pre>
			<pre class="source-code">  ) when `classicmodels`.`sale`.`employee_number` = ? then (</pre>
			<pre class="source-code">    `classicmodels`.`sale`.`sale` + ?</pre>
			<pre class="source-code">  ) when `classicmodels`.`sale`.`employee_number` = ? then (</pre>
			<pre class="source-code">    `classicmodels`.`sale`.`sale` + ?</pre>
			<pre class="source-code">  ) end </pre>
			<pre class="source-code">where </pre>
			<pre class="source-code">  `classicmodels`.`sale`.`employee_number` in (?, ?, ?)</pre>
			<p>It can be expressed in jOOQ as follows:</p>
			<pre class="source-code">ctx.update(SALE).set(SALE.SALE_,</pre>
			<pre class="source-code">case_()</pre>
			<pre class="source-code"> .when(SALE.EMPLOYEE_NUMBER.eq(1370L), SALE.SALE_.plus(100))</pre>
			<pre class="source-code"> .when(SALE.EMPLOYEE_NUMBER.eq(1504L), SALE.SALE_.plus(500))</pre>
			<pre class="source-code"> .when(SALE.EMPLOYEE_NUMBER.eq(1166L), SALE.SALE_.plus(1000)))</pre>
			<pre class="source-code">.where(SALE.EMPLOYEE_NUMBER.in(1370L, 1504L, 1166L))</pre>
			<pre class="source-code">.execute();</pre>
			<p>More examples are available in <strong class="source-inline">Bulk</strong> for MySQL. Next, let's talk about the <em class="italic">Loader</em> API, which has built-in bulk support.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/>Loading (the Loader API)</h1>
			<p>Whenever <a id="_idIndexMarker1078"/>we need to load (import) our database tables with data coming from different sources (CSV, JSON, and so on), we can rely on the jOOQ Loader API (<strong class="source-inline">org.jooq.Loader</strong>). This is a fluent API that allows us to smoothly tackle the most important challenges, such as handling duplicate keys, bulking, batching, committing, and error handling.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor206"/>The Loader API syntax</h2>
			<p>Typically, we have a<a id="_idIndexMarker1079"/> file containing the data to be imported in a common format such as CSV or JSON, and we customize the Loader API general syntax to fit our needs:</p>
			<pre class="source-code">ctx.loadInto(TARGET_TABLE)</pre>
			<pre class="source-code">   .[options]</pre>
			<pre class="source-code">   .[source and source to target mapping]</pre>
			<pre class="source-code">   .[listeners]</pre>
			<pre class="source-code">   .[execution and error handling]</pre>
			<p>While <strong class="source-inline">TARGET_TABLE</strong> is obviously the table in which the data should be imported, let's see what options we have.</p>
			<h3>Options</h3>
			<p>We can mainly distinguish between three types of options that can be used for customizing <a id="_idIndexMarker1080"/>the import process: options for handling duplicate keys, throttling options, and options for handling failures (errors). The following diagram highlights each category of options and the valid paths that can be used for chaining these options fluently:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B16833_Figure_10.3.jpg" alt="Figure 10.3 – The Loader API options&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – The Loader API options</p>
			<p>Let's explore each of these categories, starting with the one for tackling duplicate keys.</p>
			<h4>Duplicate keys options</h4>
			<p>A duplicate key occurs <a id="_idIndexMarker1081"/>when a unique key exists in the table and we attempt to import a record having the same key. By unique key, jOOQ means any unique key, not only primary keys.</p>
			<p>So, handling duplicate keys can be done via <strong class="source-inline">onDuplicateKeyError()</strong>, which is the default, or via <strong class="source-inline">onDuplicateKeyIgnore()</strong> or <strong class="source-inline">onDuplicateKeyUpdate()</strong>. The default behavior throws an exception if there are any duplicate keys.</p>
			<p>By explicitly using <strong class="source-inline">onDuplicateKeyIgnore()</strong>, we instruct jOOQ to skip any duplicate key without throwing an exception (this is the synthetic <strong class="source-inline">ON DUPLICATE KEY IGNORE</strong> clause, which can be emulated by jOOQ depending on dialect). We can instruct <a id="_idIndexMarker1082"/>jOOQ to execute <strong class="source-inline">UPDATE</strong> instead of <strong class="source-inline">INSERT</strong> via <strong class="source-inline">onDuplicateKeyUpdate()</strong> (this is the synthetic <strong class="source-inline">ON DUPLICATE KEY UPDATE</strong> clause, which can be emulated by jOOQ depending on dialect). </p>
			<h4>Throttling options</h4>
			<p>There are three <a id="_idIndexMarker1083"/>throttling options that can be used to fine-tune the import. These options refer to bulking, batching, and committing. jOOQ allows us to explicitly use any combination of these options or to rely on the following defaults: no bulking, batching, and committing.</p>
			<p>Bulking can be set via <strong class="source-inline">bulkNone()</strong> (which is the default and means that no bulking will be used), <strong class="source-inline">bulkAfter(int rows)</strong> (which allows us to specify how many rows will be inserted in one bulk via a multi-row <strong class="source-inline">INSERT</strong> (<strong class="source-inline">insert into ... (...) values (?, ?, ?,...), (?, ?, ?,...), (?, ?, ?,...), ...</strong>), and <strong class="source-inline">bulkAll()</strong> (which attempts to create one bulk from the entire source of data).</p>
			<p>As you can see from <em class="italic">Figure 10.3</em>, <strong class="source-inline">bulkNone()</strong> is the only one that can be chained after all options used for handling duplicate values. The <strong class="source-inline">bulkAfter()</strong> and <strong class="source-inline">bulkAll()</strong> methods can be chained only after <strong class="source-inline">onDuplicateKeyError()</strong>. Moreover, <strong class="source-inline">bulkNone()</strong>, <strong class="source-inline">bulkAfter()</strong>, and <strong class="source-inline">bulkAll()</strong> are mutually exclusive.</p>
			<p>Batching can be avoided via the default <strong class="source-inline">batchNone()</strong>, or it can be explicitly set via <strong class="source-inline">batchAfter(int bulk)</strong> or <strong class="source-inline">batchAll()</strong>. Explicitly specifying the number of bulk statements that should be sent to the server as a single JDBC batch statement can be accomplished via <strong class="source-inline">batchAfter(int bulk)</strong>. On the other hand, sending a single batch containing all bulks can be done via <strong class="source-inline">batchAll()</strong>. If bulking is not used (<strong class="source-inline">bulkNone()</strong>) then it is as if each row represents a bulk, so, for instance, <strong class="source-inline">batchAfter(3)</strong> means to create batches of three rows each.</p>
			<p>As you can see from <em class="italic">Figure 10.3</em>, <strong class="source-inline">batchNone()</strong>, <strong class="source-inline">batchAfter()</strong>, and <strong class="source-inline">batchAll()</strong> are mutually exclusive.</p>
			<p>Finally, committing data to the database can be controlled via four dedicated methods. By default, <strong class="source-inline">commitNone()</strong> leaves committing and rolling back operations up to client code (for instance, via <strong class="source-inline">commitNone()</strong>, we can allow Spring Boot to handle commit and rollback). But, if we want to commit after a certain number of batches, then we have to use <strong class="source-inline">commitAfter(int batches)</strong> or the handy <strong class="source-inline">commitEach()</strong> method, which is equivalent to <strong class="source-inline">commitAfter(1)</strong>. And, if we decide to commit all batches at once, then we need <strong class="source-inline">commitAll()</strong>. If batching is not used (relying on <strong class="source-inline">batchNone()</strong>), then it is as if each batch is a bulk, (for instance, <strong class="source-inline">commitAfter(3)</strong> means to commit after every three bulks). If bulking is not used either (relying on <strong class="source-inline">bulkNone()</strong>), then it is as if each<a id="_idIndexMarker1084"/> bulk is a row (for instance, <strong class="source-inline">commitAfter(3)</strong> means to commit after every three rows).</p>
			<p>As you can see from <em class="italic">Figure 10.3</em>, <strong class="source-inline">commitNone()</strong>, <strong class="source-inline">commitAfter()</strong>, <strong class="source-inline">commitEach()</strong>, and <strong class="source-inline">commitAll()</strong> are mutually exclusive.</p>
			<h4>Error options</h4>
			<p>Attempting <a id="_idIndexMarker1085"/>to manipulate (import) large amounts of data is a process quite prone to errors. While some of the errors are fatal and should stop the importing process, others can be safely ignored or postponed to be resolved after import. In the case of fatal errors, the Loader API relies on a method named <strong class="source-inline">onErrorAbort()</strong>. If an error occurs, then the Loader API stops the import process. On the other hand, we have <strong class="source-inline">onErrorIgnore()</strong>, which instructs the Loader API to skip any insert that caused an error and try to execute the next one.</p>
			<h4>Special cases</h4>
			<p>While finding<a id="_idIndexMarker1086"/> the optimal combination of these options is a matter of benchmarking, there are several things that you should know, as follows:</p>
			<ul>
				<li>If there are no unique keys in our table then <strong class="source-inline">onDuplicateKeyUpdate()</strong> acts exactly as <strong class="source-inline">onDuplicateKeyIgnore()</strong>.</li>
				<li>If <strong class="source-inline">bulkAll()</strong> + <strong class="source-inline">commitEach()</strong> or <strong class="source-inline">bulkAll()</strong> + <strong class="source-inline">commitAfter()</strong> is used, then jOOQ forces the usage of <strong class="source-inline">commitAll()</strong>.</li>
				<li>If <strong class="source-inline">batchAll()</strong> + <strong class="source-inline">commitEach()</strong> or <strong class="source-inline">batchAll()</strong> + <strong class="source-inline">commitAfter()</strong> is used, then jOOQ forces the usage of <strong class="source-inline">commitAll()</strong>.</li>
			</ul>
			<p>Next, let's quickly cover the supported sources of data.</p>
			<h3>Importing data sources</h3>
			<p>Providing the<a id="_idIndexMarker1087"/> source of data can be accomplished via dedicated methods that are specific to the supported different data types. For instance, if the data source is a CSV file, then we rely on the <strong class="source-inline">loadCSV()</strong> method; if it is a JSON file, then we rely on the <strong class="source-inline">loadJSON()</strong> method; and if it is an XML file, then we rely on <strong class="source-inline">loadXML()</strong>. Moreover, we can import arrays via <strong class="source-inline">loadArrays()</strong> and jOOQ <strong class="source-inline">Record</strong>s via <strong class="source-inline">loadRecords()</strong>. </p>
			<p>The <strong class="source-inline">loadCSV()</strong>, <strong class="source-inline">loadJSON()</strong>, and <strong class="source-inline">loadXML()</strong> methods come in 10+ flavors that allow us to load data from <strong class="source-inline">String</strong>, <strong class="source-inline">File</strong>, <strong class="source-inline">InputStream</strong>, and <strong class="source-inline">Reader</strong>. On the other hand, <strong class="source-inline">loadArrays()</strong> and <strong class="source-inline">loadRecords()</strong> allow us to load data from an array, <strong class="source-inline">Iterable</strong>, <strong class="source-inline">Iterator</strong>, or <strong class="source-inline">Stream</strong>.</p>
			<h3>Listeners</h3>
			<p>The <a id="_idIndexMarker1088"/>Loader API comes with import listeners to be chained for keeping track of import progress. We mainly have <strong class="source-inline">onRowStart(LoaderRowListener listener)</strong> and <strong class="source-inline">onRowEnd</strong><strong class="source-inline">(LoaderRowListener listener)</strong>. The former specifies a listener to be invoked before processing the current row, while the latter specifies a listener to be invoked after processing the current row. <strong class="source-inline">LoaderRowListener</strong> is a functional interface.</p>
			<h3>Execution and error handling</h3>
			<p>After the <a id="_idIndexMarker1089"/>Loader API is executed, we have access to meaningful feedback that is available through the returned <strong class="source-inline">org.jooq.Loader</strong>. For instance, we <a id="_idIndexMarker1090"/>can find out the number of executed bulks/batches via the <strong class="source-inline">executed()</strong> method, the number of processed rows via the <strong class="source-inline">processed()</strong> method, the number of stored rows (<strong class="source-inline">INSERT</strong>/<strong class="source-inline">UPDATE</strong>) via the <strong class="source-inline">stored()</strong> method, the number of ignored rows (caused by errors or duplicate keys) via the <strong class="source-inline">ignored()</strong> method, and the potential errors via the <strong class="source-inline">errors()</strong> method as <strong class="source-inline">List&lt;LoaderError&gt;</strong>. As you'll see in the next section of examples, <strong class="source-inline">LoaderError</strong> contains details about the errors (if any).</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>Examples of using the Loader API</h2>
			<p>Finally, after all this theory, it is time to see some examples<a id="_idIndexMarker1091"/> of loading CSV, JSON, <strong class="source-inline">Record</strong>, and arrays. All these examples are executed and dissected in the context of Spring Boot <strong class="source-inline">@Transactional</strong>. Feel free to practice them under the jOOQ transactional context by simply removing <strong class="source-inline">@Transactional</strong> and wrapping the code as follows:</p>
			<pre class="source-code">ctx.transaction(configuration -&gt; {</pre>
			<pre class="source-code">   // Loader API code</pre>
			<pre class="source-code">   configuration.dsl()…</pre>
			<pre class="source-code">});</pre>
			<p>So, let's start by loading some CSV.</p>
			<h3>Loading CSV</h3>
			<p>Loading CSV is<a id="_idIndexMarker1092"/> accomplished via the <strong class="source-inline">loadCSV()</strong> method. Let's start with a simple example based on the following typical CSV file (<strong class="source-inline">in.csv</strong>):</p>
			<pre class="source-code">sale_id,fiscal_year,sale,employee_number,…,trend</pre>
			<pre class="source-code">1,2003,5282.64,1370,0,…,UP</pre>
			<pre class="source-code">2,2004,1938.24,1370,0,…,UP</pre>
			<pre class="source-code">3,2004,1676.14,1370,0,…,DOWN</pre>
			<pre class="source-code">…</pre>
			<p>Obviously, this data should be imported in the <strong class="source-inline">sale</strong> table, so <strong class="source-inline">TARGET_TABLE</strong> (<strong class="source-inline">Table&lt;R&gt;</strong>) that should be passed to <strong class="source-inline">loadInto()</strong> is <strong class="source-inline">SALE</strong>. Pointing jOOQ to this file is accomplished via the <strong class="source-inline">loadCSV()</strong> method as follows:</p>
			<pre class="source-code">ctx.loadInto(SALE)</pre>
			<pre class="source-code">   .loadCSV(Paths.get("data", "csv", "in.csv").toFile(), </pre>
			<pre class="source-code">            StandardCharsets.UTF_8)</pre>
			<pre class="source-code">   .fieldsCorresponding()</pre>
			<pre class="source-code">   .execute();</pre>
			<p>This code relies on the default options. Notice the call of the <strong class="source-inline">fieldsCorresponding()</strong> method. This method signals to jOOQ that all input fields having a corresponding field in <strong class="source-inline">SALE</strong> (with the same name) should be loaded. Practically, in this case, all fields from the CSV file have a correspondent in the <strong class="source-inline">SALE</strong> table, so all of them will be imported.</p>
			<p>But, obviously, this is not always the case. Maybe we want to load only a subset of scattered fields. In such cases, simply pass <em class="italic">dummy</em> nulls for the field indexes (positions) that shouldn't be loaded (this is an index/position-based field mapping). This time, let's collect the number of processed rows as well via <strong class="source-inline">processed()</strong>:</p>
			<pre class="source-code">int processed = ctx.loadInto(SALE)</pre>
			<pre class="source-code"> .loadCSV(Paths.get("data", "csv", "in.csv").toFile(), </pre>
			<pre class="source-code">         StandardCharsets.UTF_8)</pre>
			<pre class="source-code"> .fields(null, SALE.FISCAL_YEAR, SALE.SALE_, </pre>
			<pre class="source-code">         null, null, null, null, SALE.FISCAL_MONTH, </pre>
			<pre class="source-code">         SALE.REVENUE_GROWTH,SALE.TREND)</pre>
			<pre class="source-code"> .execute()</pre>
			<pre class="source-code"> .processed();</pre>
			<p>This code<a id="_idIndexMarker1093"/> loads from CSV only <strong class="source-inline">SALE.FISCAL_YEAR</strong>, <strong class="source-inline">SALE.SALE_</strong>, <strong class="source-inline">SALE.FISCAL_MONTH</strong>, <strong class="source-inline">SALE.REVENUE_GROWTH</strong>, and <strong class="source-inline">SALE.TREND</strong>. Notice that we've used the <strong class="source-inline">fields()</strong> method instead of <strong class="source-inline">fieldsCorresponding()</strong>, since <strong class="source-inline">fields()</strong> allows us to keep only the desired fields and skip the rest. A sample of the resultant <strong class="source-inline">INSERT</strong> (in MySQL dialect) looks like this:</p>
			<pre class="source-code">INSERT INTO `classicmodels`.`sale` (`fiscal_year`, `sale`, </pre>
			<pre class="source-code">               `fiscal_month`, `revenue_growth`, `trend`) </pre>
			<pre class="source-code">VALUES (2005, 5243.1, 1, 0.0, 'DOWN')</pre>
			<p>While this CSV file is a typical one (first line header, data separated by a comma, and so on), sometimes we have to deal with CSV files that are quite customized, such as the following one:</p>
			<pre class="source-code">1|2003|5282.64|1370|0|{null}|{null}|1|0.0|*UP*</pre>
			<pre class="source-code">2|2004|1938.24|1370|0|{null}|{null}|1|0.0|*UP*</pre>
			<pre class="source-code">3|2004|1676.14|1370|0|{null}|{null}|1|0.0|*DOWN*</pre>
			<pre class="source-code">…</pre>
			<p>This CSV file contains the same data as the previous one expect that there is no header line, the data separator is <strong class="source-inline">|</strong>, the quote mark is <strong class="source-inline">*</strong>, and the <strong class="source-inline">null</strong> values are represented as <strong class="source-inline">{null}</strong>. Loading this CSV file into <strong class="source-inline">SALE</strong> requires the following code:</p>
			<pre class="source-code">List&lt;LoaderError&gt; errors = ctx.loadInto(SALE)</pre>
			<pre class="source-code"> .loadCSV(Paths.get("data", "csv", "in.csv").toFile(), </pre>
			<pre class="source-code">       StandardCharsets.UTF_8)</pre>
			<pre class="source-code"> .fields(SALE.SALE_ID, SALE.FISCAL_YEAR, SALE.SALE_, </pre>
			<pre class="source-code">         SALE.EMPLOYEE_NUMBER, SALE.HOT, SALE.RATE, SALE.VAT, </pre>
			<pre class="source-code">         SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH, SALE.TREND)</pre>
			<pre class="source-code"> .ignoreRows(0) </pre>
			<pre class="source-code"> .separator('|').nullString("{null}").quote('*') </pre>
			<pre class="source-code"> .execute()</pre>
			<pre class="source-code"> .errors();</pre>
			<p>First of all, since<a id="_idIndexMarker1094"/> there is no header, we rely on <strong class="source-inline">fields()</strong> to explicitly specify the list of fields (<strong class="source-inline">SALE_ID</strong> is mapped to index <strong class="source-inline">1</strong> in CSV, <strong class="source-inline">FISCAL_YEAR</strong> to index <strong class="source-inline">2</strong>, and so on). Next, we call <strong class="source-inline">ignoreRows(0)</strong>; by default, jOOQ skips the first line, which is considered the header of the CSV file, but since there is no header in this case, we have to instruct jOOQ to take into account the first line as a line containing data. Obviously, this method is useful for skipping <em class="italic">n</em> rows as well. Taking it a step further, we call <strong class="source-inline">separator()</strong>, <strong class="source-inline">nullString()</strong>, and <strong class="source-inline">quote()</strong> to override the defaults. Finally, we call <strong class="source-inline">errors()</strong> and collect potential errors in <strong class="source-inline">List&lt;LoaderError&gt;</strong>. This is an optional step and is not related to this particular example. In the bundled code (<em class="italic">LoadCSV</em> for MySQL), you can see how to loop this list and extract valuable information about what happened during the loading process. Moreover, you'll see more examples of loading CSV files. Next, let's explore more examples for loading a JSON file.</p>
			<h3>Loading JSON</h3>
			<p>Loading JSON is <a id="_idIndexMarker1095"/>done via the <strong class="source-inline">loadJSON()</strong> method. Let's start with a JSON file:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "fields": [</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">      "schema": "classicmodels",</pre>
			<pre class="source-code">      "table": "sale",</pre>
			<pre class="source-code">      "name": "sale_id",</pre>
			<pre class="source-code">      "type": "BIGINT"</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">  ],</pre>
			<pre class="source-code">  "records": [</pre>
			<pre class="source-code">    [1, 2003, 5282.64, 1370, 0, null, null, 1, 0.0, "UP"],</pre>
			<pre class="source-code">    [2, 2004, 1938.24, 1370, 0, null, null, 1, 0.0, "UP"],</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">  ]</pre>
			<pre class="source-code">}</pre>
			<p>This JSON file<a id="_idIndexMarker1096"/> was previously exported via <strong class="source-inline">formatJSON()</strong>. Notice the <strong class="source-inline">"fields"</strong> header, which is useful for loading this file into the <strong class="source-inline">SALE</strong> table via the mapping provided by the <strong class="source-inline">fieldsCorresponding()</strong> method. Without a header, the <strong class="source-inline">fieldsCorresponding()</strong> method cannot produce the expected results since the input fields are missing. But, if we rely on the <strong class="source-inline">fields()</strong> method, then we can list the desired fields (all or a subset of them) and count on index-based mapping without worrying about the presence or absence of the <strong class="source-inline">"fields"</strong> header. Moreover, this time, let's add an <strong class="source-inline">onRowEnd()</strong> listener as well:</p>
			<pre class="source-code">ctx.loadInto(SALE)</pre>
			<pre class="source-code">   .loadJSON(Paths.get("data", "json", "in.json").toFile(), </pre>
			<pre class="source-code">       StandardCharsets.UTF_8)</pre>
			<pre class="source-code">   .fields(null, SALE.FISCAL_YEAR, SALE.SALE_, null, null, </pre>
			<pre class="source-code">        null, null, SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH,</pre>
			<pre class="source-code">        SALE.TREND)</pre>
			<pre class="source-code">   .onRowEnd(ll -&gt; {</pre>
			<pre class="source-code">     System.out.println("Processed row: " </pre>
			<pre class="source-code">        + Arrays.toString(ll.row()));</pre>
			<pre class="source-code">     System.out.format("Executed: %d, ignored: %d, processed: </pre>
			<pre class="source-code">        %d, stored: %d\n", ll.executed(), ll.ignored(), </pre>
			<pre class="source-code">        ll.processed(), ll.stored());</pre>
			<pre class="source-code">     })</pre>
			<pre class="source-code">   .execute();</pre>
			<p>After<a id="_idIndexMarker1097"/> each row is processed you'll see an output in the log as shown here:</p>
			<pre class="source-code">Processed row: [28, 2005, 5243.1, 1504, …, DOWN]</pre>
			<pre class="source-code">Executed: 28, ignored: 0, processed: 28, stored: 28</pre>
			<p>But, let's look at a JSON file without the <strong class="source-inline">"fields"</strong> header, as follows:</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">      "fiscal_month": 1,</pre>
			<pre class="source-code">      "revenue_growth": 0.0,</pre>
			<pre class="source-code">      "hot": 0,</pre>
			<pre class="source-code">      "vat": null,</pre>
			<pre class="source-code">      "rate": null,</pre>
			<pre class="source-code">      "sale": 5282.64013671875,</pre>
			<pre class="source-code">      "trend": "UP",</pre>
			<pre class="source-code">      "sale_id": 1,</pre>
			<pre class="source-code">      "fiscal_year": 2003,</pre>
			<pre class="source-code">      "employee_number": 1370</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">     …</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">…</pre>
			<p>This kind of <a id="_idIndexMarker1098"/>JSON can be loaded via <strong class="source-inline">fieldsCorresponding()</strong> or via <strong class="source-inline">fields()</strong>. Since the field names are available as JSON keys, the <strong class="source-inline">fieldsCorresponding()</strong> method maps them correctly. Using <strong class="source-inline">fields()</strong> should be done by keeping in mind the order of keys in this JSON. So, <strong class="source-inline">"fiscal_month"</strong> is on index <strong class="source-inline">1</strong>, <strong class="source-inline">"revenue_growth"</strong> on index <strong class="source-inline">2</strong>, and so on. Here is an example that loads only <strong class="source-inline">"fiscal_month"</strong>, <strong class="source-inline">"revenue_growth"</strong>, <strong class="source-inline">"sale"</strong>, <strong class="source-inline">"fiscal_year"</strong>, and <strong class="source-inline">"employee_number"</strong>:</p>
			<pre class="source-code">int processed = ctx.loadInto(SALE)</pre>
			<pre class="source-code">  .loadJSON(Paths.get("data", "json", "in.json").toFile(), </pre>
			<pre class="source-code">        StandardCharsets.UTF_8)</pre>
			<pre class="source-code">  .fields(SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH, </pre>
			<pre class="source-code">          null, null, null, SALE.SALE_, null, null, </pre>
			<pre class="source-code">          SALE.FISCAL_YEAR, SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">  .execute()</pre>
			<pre class="source-code">  .processed();</pre>
			<p>But, sometimes, the missing data is in JSON itself, as here:</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">      "sale_id": 1,</pre>
			<pre class="source-code">      "fiscal_year": 2003,</pre>
			<pre class="source-code">      "sale": 5282.64 </pre>
			<pre class="source-code">      "fiscal_month": 1,</pre>
			<pre class="source-code">      "revenue_growth": 0.0</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">…</pre>
			<p>Here is another example:</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">  [</pre>
			<pre class="source-code">    1,</pre>
			<pre class="source-code">    2003,</pre>
			<pre class="source-code">    5282.64,</pre>
			<pre class="source-code">    1,</pre>
			<pre class="source-code">    0.0</pre>
			<pre class="source-code">  ],</pre>
			<pre class="source-code">…</pre>
			<p>This time, in both<a id="_idIndexMarker1099"/> cases, we must rely on <strong class="source-inline">fields()</strong>, as here:</p>
			<pre class="source-code">ctx.loadInto(SALE)</pre>
			<pre class="source-code">   .loadJSON(Paths.get("data", "json", "in.json").toFile(), </pre>
			<pre class="source-code">      StandardCharsets.UTF_8)</pre>
			<pre class="source-code">   .fields(SALE.SALE_ID, SALE.FISCAL_YEAR, SALE.SALE_, </pre>
			<pre class="source-code">     SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)      </pre>
			<pre class="source-code">   .execute();</pre>
			<p>Next, let's assume that we have a JSON file that should be imported into the database using batches of size <strong class="source-inline">2</strong> (rows), so we need <strong class="source-inline">batchAfter(2)</strong>. The commit (as in all the previous examples) will be accomplished by Spring Boot via <strong class="source-inline">@Transactional</strong>:</p>
			<pre class="source-code">@Transactional</pre>
			<pre class="source-code">public void loadJSON () {</pre>
			<pre class="source-code"> int executed = ctx.loadInto(SALE)</pre>
			<pre class="source-code">  .batchAfter(2)// each *batch* has 2 rows</pre>
			<pre class="source-code">  .commitNone() // this is default, so it can be omitted</pre>
			<pre class="source-code">  .loadJSON(Paths.get("data", "json", "in.json").toFile(), </pre>
			<pre class="source-code">     StandardCharsets.UTF_8)</pre>
			<pre class="source-code">  .fieldsCorresponding()</pre>
			<pre class="source-code">  .execute()</pre>
			<pre class="source-code">  .executed();</pre>
			<pre class="source-code">}</pre>
			<p>Since <strong class="source-inline">commitNone()</strong> is the <a id="_idIndexMarker1100"/>default behavior, it could be omitted. Essentially, <strong class="source-inline">commitNone()</strong> allows <strong class="source-inline">@Transactional</strong> to handle the commit/rollback actions. By default, <strong class="source-inline">@Transactional</strong> commits the transaction at the end of the annotated method. If something goes wrong, the entire payload (all batches) is rolled back. But, if you remove <strong class="source-inline">@Transactional</strong>, then <strong class="source-inline">auto-commit</strong> <strong class="source-inline">=true</strong> goes into action. This commits after each batch (so, after every two rows). If something goes wrong, then there is no rollback action, but the loading process is aborted immediately since we rely on the default settings, <strong class="source-inline">onDuplicateKeyError()</strong> and <strong class="source-inline">onErrorAbort()</strong>. If we remove <strong class="source-inline">@Transactional</strong> and set <strong class="source-inline">auto-commit</strong> to <strong class="source-inline">false</strong> (<strong class="source-inline">spring.datasource.hikari.auto-commit=false</strong>), then nothing commits.</p>
			<p>This example returns the number of executed batches via <strong class="source-inline">executed()</strong>. For instance, if there are 36 rows processed with <strong class="source-inline">batchAfter(2)</strong>, then <strong class="source-inline">executed()</strong> returns 18. </p>
			<p>Next, let's consider a JSON file that contains duplicate keys. Every time a duplicate key is found, the Loader API should skip it, and, in the end, it should report the number of ignored <a id="_idIndexMarker1101"/>rows. Moreover, the Loader API should commit after each batch of three rows:</p>
			<pre class="source-code">int ignored = ctx.loadInto(SALE)</pre>
			<pre class="source-code"> .onDuplicateKeyIgnore()</pre>
			<pre class="source-code"> .batchAfter(3) // each *batch* has 3 rows</pre>
			<pre class="source-code"> .commitEach()  // commit each batch</pre>
			<pre class="source-code"> .loadJSON(Paths.get("data", "json", "in.json").toFile(), </pre>
			<pre class="source-code">     StandardCharsets.UTF_8)</pre>
			<pre class="source-code"> .fieldsCorresponding()</pre>
			<pre class="source-code"> .execute()</pre>
			<pre class="source-code"> .ignored();</pre>
			<p>If you want to execute <strong class="source-inline">UPDATE</strong> instead of ignoring duplicate keys, just replace <strong class="source-inline">onDuplicateKeyIgnore()</strong> with <strong class="source-inline">onDuplicateKeyUpdate()</strong>.</p>
			<p>Finally, let's import a JSON using <strong class="source-inline">bulkAfter(2)</strong>, <strong class="source-inline">batchAfter(3)</strong>, and <strong class="source-inline">commitAfter(3)</strong>. In other words, each bulk has two rows, and each batch has three bulks. Therefore, six rows commit after three batches, that is nine bulks, so after 18 rows, you get the following:</p>
			<pre class="source-code">int inserted = ctx.loadInto(SALE)</pre>
			<pre class="source-code"> .bulkAfter(2)   // each *bulk* has 2 rows</pre>
			<pre class="source-code"> .batchAfter(3)  // each *batch* has 3 *bulks*, so 6 rows</pre>
			<pre class="source-code"> .commitAfter(3) // commit after 3 *batches*, so after 9 </pre>
			<pre class="source-code">                 // *bulks*, so after 18 rows</pre>
			<pre class="source-code"> .loadJSON(Paths.get("data", "json", "in.json").toFile(),  </pre>
			<pre class="source-code">      StandardCharsets.UTF_8)</pre>
			<pre class="source-code"> .fieldsCorresponding()</pre>
			<pre class="source-code"> .execute()</pre>
			<pre class="source-code"> .stored();</pre>
			<p>If something <a id="_idIndexMarker1102"/>goes wrong, the last uncommitted batch is rolled back without affecting the already committed batches. More examples are available in the bundled code, <strong class="source-inline">LoadJSON</strong>, for MySQL.</p>
			<h3>Loading records</h3>
			<p>Loading jOOQ <strong class="source-inline">Record</strong> via the<a id="_idIndexMarker1103"/> Loader API is a straightforward process accomplished via the <strong class="source-inline">loadRecords()</strong> method. Let's consider the following set of records:</p>
			<pre class="source-code">Result&lt;SaleRecord&gt; result1 = …;</pre>
			<pre class="source-code">Result&lt;Record3&lt;Integer, Double, String&gt;&gt; result2 = …;</pre>
			<pre class="source-code">Record3&lt;Integer, Double, String&gt;[] result3 = …;</pre>
			<pre class="source-code">SaleRecord r1 = new SaleRecord(1L, …);</pre>
			<pre class="source-code">SaleRecord r2 = new SaleRecord(2L, …);</pre>
			<pre class="source-code">SaleRecord r3 = new SaleRecord(3L, …);</pre>
			<p>Loading them can be done as follows:</p>
			<pre class="source-code">ctx.loadInto(SALE)</pre>
			<pre class="source-code">   .loadRecords(result1)</pre>
			<pre class="source-code">   .fields(null, SALE.FISCAL_YEAR, SALE.SALE_,    </pre>
			<pre class="source-code">           SALE.EMPLOYEE_NUMBER, SALE.HOT, SALE.RATE, SALE.VAT, </pre>
			<pre class="source-code">           SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH, SALE.TREND)</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">ctx.loadInto(SALE).loadRecords(result2/result3) </pre>
			<pre class="source-code">   .fieldsCorresponding()                    </pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">ctx.loadInto(SALE).loadRecords(r1, r2, r3) </pre>
			<pre class="source-code">   .fieldsCorresponding()                    </pre>
			<pre class="source-code">   .execute();</pre>
			<p>Let's look <a id="_idIndexMarker1104"/>at loading the following map of <strong class="source-inline">Record</strong>:</p>
			<pre class="source-code">Map&lt;CustomerRecord, CustomerdetailRecord&gt; result = …;</pre>
			<p>So, <strong class="source-inline">CustomerRecord</strong> should be loaded in <strong class="source-inline">CUSTOMER</strong>, and <strong class="source-inline">CustomerdetailRecord</strong> should be loaded in <strong class="source-inline">CUSTOMERDETAIL</strong>. For this, we can use <strong class="source-inline">Map.keySet()</strong> and <strong class="source-inline">Map.values()</strong> as follows:</p>
			<pre class="source-code">ctx.loadInto(CUSTOMER)</pre>
			<pre class="source-code">   .onDuplicateKeyIgnore()</pre>
			<pre class="source-code">   .loadRecords(result.keySet())</pre>
			<pre class="source-code">   .fieldsCorresponding()                    </pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">ctx.loadInto(CUSTOMERDETAIL)  </pre>
			<pre class="source-code">   .onDuplicateKeyIgnore()</pre>
			<pre class="source-code">   .loadRecords(result.values())</pre>
			<pre class="source-code">   .fieldsCorresponding()                    </pre>
			<pre class="source-code">   .execute();</pre>
			<p>More examples are available in the bundled code, <strong class="source-inline">LoadRecords</strong>, for MySQL.</p>
			<h3>Loading arrays</h3>
			<p>Loading arrays is accomplished via the <strong class="source-inline">loadArrays()</strong> method. Let's consider the following <a id="_idIndexMarker1105"/>array containing data that should be loaded into the <strong class="source-inline">SALE</strong> table:</p>
			<pre class="source-code">Object[][] result = ctx.selectFrom(…).fetchArrays();</pre>
			<p>Loading this array can be done as follows:</p>
			<pre class="source-code">ctx.loadInto(SALE)                    </pre>
			<pre class="source-code">   .loadArrays(Arrays.stream(result)) // Arrays.asList(result)</pre>
			<pre class="source-code">   .fields(null, SALE.FISCAL_YEAR, SALE.SALE_, </pre>
			<pre class="source-code">           SALE.EMPLOYEE_NUMBER, SALE.HOT, SALE.RATE, SALE.VAT, </pre>
			<pre class="source-code">           SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH, SALE.TREND)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Here is another example that relies on <strong class="source-inline">loadArrays(Object[]... os)</strong>:</p>
			<pre class="source-code">int executed = ctx.loadInto(SALE)</pre>
			<pre class="source-code">   .onDuplicateKeyIgnore()</pre>
			<pre class="source-code">   .batchAfter(2)</pre>
			<pre class="source-code">   .commitEach()  </pre>
			<pre class="source-code">   .loadArrays(</pre>
			<pre class="source-code">     new Object[]{1, 2005, 582.64, 1370, 0,… , "UP"},</pre>
			<pre class="source-code">     new Object[]{2, 2005, 138.24, 1370, 0,… , "DOWN"},</pre>
			<pre class="source-code">     new Object[]{3, 2005, 176.14, 1370, 0,… , "DOWN"})</pre>
			<pre class="source-code">   .fields(SALE.SALE_ID, SALE.FISCAL_YEAR, SALE.SALE_, </pre>
			<pre class="source-code">           SALE.EMPLOYEE_NUMBER, SALE.HOT, SALE.RATE, </pre>
			<pre class="source-code">           SALE.VAT, SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH,  </pre>
			<pre class="source-code">           SALE.TREND)</pre>
			<pre class="source-code">   .execute()</pre>
			<pre class="source-code">   .ignored();</pre>
			<p>You can check out <a id="_idIndexMarker1106"/>these examples next to others not listed here in the bundled code, <strong class="source-inline">LoadArrays</strong>, for MySQL. It is time to summarize this chapter.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor208"/>Summary</h1>
			<p>In this chapter, we've covered four important topics: exporting, batching, bulking, and loading. As you saw, jOOQ comes with dedicated APIs for accomplishing each of these tasks that require a lot of complex code under the hood. Frequently, jOOQ simplifies the complexity (as usual) and allows us to focus on what we have to do and less on how we do it. For instance, it is amazing to see that it takes seconds to write a snippet of code for loading a CSV or a JSON file into the database while having fluent and smooth support for error handling control, diagnosis output, bulking, batching, and committing control.</p>
			<p>In the next chapter, we will cover the jOOQ keys.</p>
		</div>
	</body></html>