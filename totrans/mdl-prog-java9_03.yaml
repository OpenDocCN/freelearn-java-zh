- en: Handling Inter-Module Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we created our first Java 9 module and set up the beginnings
    of the address book application. However, we built the whole application as a
    single module, and thus, we didn''t really leverage any of the cool new features
    of modularity. Here''s what you''ll learn to do in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll break the application up into two separate modules, and thereby create
    your second Java module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn how to establish dependencies between those two modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn more about the module descriptor configuration that's required
    to wire in two separate modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll revisit the compilation and execution steps with multiple modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This all starts with breaking our monolithic address book viewer application
    into two modules. Breaking the single module into two dependent modules has two
    consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the application up into modular parts enables these modular parts to
    potentially be reused in multiple other applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's an opportunity to define the interface for the modules. It lets you, as
    the module author, define what the module exports and how it should be used and
    consumed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at both of these in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the second module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by splitting the address book application into two separate modules.
    The obvious candidate for moving to its own module is the sorting logic. At this
    point, there''s nothing about the sorting class, `SortUtil`, that has anything
    to do with the address book. We''ve designed the class to be generic and provide
    functionality to sort any list. That''s good practice in general, but it makes
    additional sense when breaking it out as a separate module. What we will do is
    move the code related to sorting into a brand new module, called `packt.sortutil`.
    Here are the steps at a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new module called `packt.sortutil`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the code related to sorting into this newly created module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the `packt.sortutil` module to define its interface--what it exports
    and how the module needs to be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the `packt.addressbook` module to use the new `packt.sortutil` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new module. We''ve looked at the four steps to create
    a module in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb),
    *Creating Your First Java Module*, already. We know what the module name is. Next,
    the module structure requires creating a module root directory in the source folder.
    Just like the `packt.addressbook` folder resides in the `src` folder and holds
    all the contents of the `packt.addressbook` module, the `packt.sortutil` module
    requires the creation of a folder named `packt.sortutil` in the same `src` location.
    What makes this folder a module root folder is the presence of the module descriptor
    `module-info.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the folder structure at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a module, we can move the necessary classes from the `packt.addressbook`
    module into the `packt.sortutil` module. There''s just one class related to sorting--`SortUtil.java`.
    With the package folders located at the module folder, the folder structure after
    moving the class over should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When creating a module, you'd typically also configure the interface, that is,
    defining the module's inputs and outputs. We didn't do this to the `packt.addressbook`
    module in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb), *Creating
    Your First Java Module* because it existed as a standalone module. However, that's
    not the case anymore in this chapter, since we'll now need the two modules `packt.addressbook`
    and `packt.sortutil` to work together. This involves updating the `module-info.java`
    file for both the modules to provide this information. But let's skip this step
    for now and examine the default behavior first. Let's observe what happens if
    we don't add any module configuration and compile the two modules with empty module
    definition files.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling two modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the module path (the `src` directory) has two modules. We can now run the
    `javac` command to compile all classes in both modules, since we are supplying
    `src` as the module source path.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `packt.sortutil` is the simpler of the two modules. Since it doesn't have
    any external dependencies, this should just work like the `packt.addressbook`
    module did in the previous chapter. Let's look at the `packt.addressbook` module.
    Things are more interesting here. Since we've moved the sort related classes to
    the `packt.sortutil` module, the `packt.addressbook` module doesn't have the classes
    in the `packt.util` package anymore. But there is code in the module that still
    uses it. Notice what happens when we try to compile both the modules with the
    same command as the previous chapter. This time, since we are compiling two modules,
    we specify both the module names to the  `--module` argument separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The error you get should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, note that the errors are only from compiling the `packt.addressbook`
    module. This means that the compilation of the `packt.sortutil` module succeeded!
    The three errors in the preceding output are specifically about the `Main.java`
    file. The compiler clearly doesn't see the `SortUtil` class and it complains it
    is missing. But is it really missing? We do have a public `SortUtil` class available
    in the `src` folder, but since it is in a different module folder, the compiler
    doesn't seem to see it, even though the class itself is `public`. This brings
    up an important new change relating to class visibility in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Just because a class is marked `public` in Java 9, it doesn't necessarily mean
    it is visible to all other types.
  prefs: []
  type: TYPE_NORMAL
- en: This is a radical change from the way `public` types work in Java 8 and earlier.
    Before Java 9, if you had a public class or interface in the classpath, it was
    available for any other type in the classpath to import and use. This is no longer
    the case with the module source path in Java 9!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring module dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of a module being a walled garden by default. By default, any Java type
    in a module is accessible *only* to the types inside the same module. Previously,
    the `SortUtil` class was in the `packt.addressbook` module and was thus accessible
    to other types in that module. Move it to a different module however, and it is
    not accessible to types in the original module anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given two modules, **A** and **B**, for any type in module A to access a type
    in module B, two conditions need to be satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: Module A needs to declare its dependency on module B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module B needs to declare that it's okay with that type being accessed externally
    by other modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If either of these conditions isn't met, the type being accessed in module B
    is said to be *not readable* by module A. We'll cover the topics of readability
    and accessibility in sufficient detail in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability*, but, for now, note that these
    are two important requirements. Let's apply these to the `packt.addressbook` and
    `packt.sortutil` modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to have the `packt.addressbook` module declare that it is dependent
    on the `packt.sortutil` module. It is using a class from that module, and there''s
    no way you can compile or run the module without it. The way to declare a dependency
    on a module is by using the `requires` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Following the `requires` keyword is the name of the module that is required.
    And yes, you can only require other modules, and not packages or classes. This
    line is enough for the compiler and runtime to look up types from the module that
    is being *required* any time those types are being used in the module. A module
    could depend on multiple other modules. So, it's actually common to have multiple
    such `requires` lines of code in a module declaration.
  prefs: []
  type: TYPE_NORMAL
- en: When a compiler tries to compile a module, imagine that it looks at this list
    of modules specified with the `requires` clause and says "Okay, I understand that
    this module requires all these other modules. While I compile this module, anytime
    I see a type being used in the code of this module that belongs to another module
    that is required, I'll go look at the module that contains the type and make sure
    it exports the type being used." Since every dependent module could potentially
    require other modules, this is a recursive process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what does a module *exporting* a type mean? This is where we get to the
    second of the two preceding conditions. Every module needs to specifically declare
    what types in its module are okay for use outside the module. In our case, the
    `packt.sortutil` module needs to declare that the `SortUtil` class is allowed
    to be used outside its own module. This is done in the `sortutil` module''s declaration
    file, using the `exports` keyword followed by the package you want to export.
    When a module `exports` a package, all the types belonging to that package are
    allowed access outside the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we want to export the `packt.util.SortUtil` class. So, we *export*
    the package `packt.util` thereby exporting the class within it.
  prefs: []
  type: TYPE_NORMAL
- en: Again, note that you *require* modules and *export* packages. There are several
    reasons why the language designers decided to use the `exports` syntax with packages
    rather than having developers export individual types. The most obvious reason,
    of course, is that it is much more convenient than the tedium of having to export
    each class at an individual type level.
  prefs: []
  type: TYPE_NORMAL
- en: We've introduced a handful of new keywords so far--`module`, `requires`, and
    `exports`. You might be wondering if they are reserved words in the Java language
    as of Java 9\. Are you in trouble if you've been using these as variable names
    all over your code today? The answer is no! These and other module related keywords
    we'll be learning in this book are what are called *restricted keywords*. You
    can still continue to use them in your code, but only when they are used in the
    context of a module descriptor, the compiler knows what they mean and it treats
    the keywords accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With both the conditions for cross-module access of types now satisfied, let''s
    compile the code again from one directory above the module path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `--module-source-path` parameter specifies where the compiler can
    find all the Java modules that are required to do its job compiling your code.
    And, the `--module` indicates the two modules to be compiled--`packt.addressbook`
    and `packt.sortutil`. The compiler finds both the module root folders in the module
    source path and compiles them into their respective classes.
  prefs: []
  type: TYPE_NORMAL
- en: The compilation should quietly succeed. Just like last time, you'll notice that
    the `out` folder has a `.class` file corresponding to every `.java` file in each
    of the two modules, including the module descriptors, the two `module-info.java`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: You can execute the `Main` class in the `packt.addressbook` module like before.
    For illustration, I'll use the terser  `-m` option (instead of `--module`) to
    specify the module and class to start execution. They both mean the same and can
    be used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here as well, the `--module-path` option specifies where the Java runtime needs
    to look to find the modules required to execute the code. The runtime detects
    that the class it needs to start execution with (`Main`) is a part of the module
    `packt.addressbook` and since that module has a dependency on another module (`packt.sortutil`),
    it searches the location specified by the `module-path` option (the `out` directory
    here) to find the depended module. Thanks to our compile step placing the compiled
    module in the same location, the runtime finds it and the execution proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: You should see the contacts successfully sorted by last name. Note that, to
    run this code, you just specified the `packt.addressbook` module and the `Main`
    class, and we didn't have to provide any information to the runtime about the
    dependent `packt.sortutil` module. This is because the Java runtime is reading
    off the same module descriptor (the `module-info.class` file this time) to know
    that the `packt.sortutil` module is required and so leverages the right class
    files from both modules as and when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram explaining the behavior of the two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'What we''ve done is isolated the sorting functionality into its own module
    so that it can be used by other Java 9 modular applications that need sorting.
    All that any Java 9 module has to do in order to use `packt.sortutil` is:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `requires packt.sortutil` line in the definition of the module that
    needs the sorting functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `packt.util.SortUtil` class and call the `sortList()` method to sort
    any `List` of objects as long as the objects are `Comparable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is great, but before we share our new `packt.sortutil` library for the
    world to use, let's think about the library's API for a bit.
  prefs: []
  type: TYPE_NORMAL
- en: What I mean by a library's API is the code required to be used by the consumers
    of your library in order to access it. In the case of the simplistic `packt.sortutil`
    library, for example, the API is a single method `sortList()` on the class `packt.util.SortUtil`.
    More functional libraries obviously have multiple classes and methods that could
    potentially be called by their consumers.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a library, before you allow others to use it, you have to very
    carefully define and finalize the library's API. The reason being that, once others
    start using your library, it becomes harder to make changes to the library's public
    API. Any changes to the API in future versions of your library would mean requiring
    all the consumers of your library update their code to work with the new API.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the `packt.sortutil` module contains just one class. We will be evolving
    the module in the next chapters, but for now, one change I'd like to do is to
    make the `SortUtil` class as lightweight as possible. That class acts as the *programming
    interface* to the `packt.sortutil` library, so making sure the class is as simple
    as it can be with fewer lines of code makes it less susceptible to possible changes
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve this is by moving the actual sorting functionality to an
    *implementation* class and have `SortUtil` just delegate the sorting logic to
    that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we create a `BubbleSortUtil` class that has the same structure
    as the `SortUtil` class has so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then update the `SortUtil` to just call `BubbleSortUtilImpl` class''s
    `sortList` method to delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is much better, because if you'd like to change the structure of the library
    or the sorting logic, as long as you keep the structure of `SortUtil` unchanged,
    the consumers of your library don't have to change their code. The `SortUtil`
    class is still tightly coupled to `BubbleSortUtil` in that it is directly instantiating
    it, but we'll be improving this is in a subsequent chapter, so let's live with
    it for now.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code at this stage should result in the same output as last time.
    Now, before we announce to the world that our `packt.sortutil` module is ready
    for consumption, think back to the problem Jack faced in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*. He had created a sorting library JAR file with
    pretty much the same design as far as classes are concerned--an internal `BubbleSortUtilImpl`
    and an external `SortUtil`. The problem he ran into was the fact that a certain
    class is either *internal* or *external* was only a matter of convention and wasn't
    enforceable without Jack lumping his code into a single package just to leverage
    the package-private mechanisms. Developers using his library started to use the
    `BubbleSortUtilImpl` class that they weren't supposed to use. Let's see if we
    have the same problem with our `sortutil` module, and if so, if there are better
    tools to protect certain classes using the module system in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simple. Yes, we have the same problem that Jack ran into. Any
    consumer of the `sortutil` module could easily use `BubbleSortUtilImpl` directly.
    That''s because the class is in a package that''s exported from the module. We''d
    like to avoid that by encapsulating the class and prevent its usage outside the
    module. How do we do that? Simple! Just move the class to another package! Like
    we''ve already seen, the Java Platform Module System expects us to specify what
    packages are visible outside the module. If any type is accessible outside any
    module, it''s only because it belongs to an exported package in that module. Which
    is why refactoring the type into a new package is a potential solution. As long
    as the new package doesn''t show up with the `exports` clause in the module definition
    file of the module, the classes in the package are effectively hidden from outside
    use, like we''ve already seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a diagram of the modules, revisited with our newest change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that packages in Java are not hierarchical. In this example, the packages
    `packt.util` and `packt.util.impl` are two separate packages that are not related
    in any way. Just because you've exported the package `packt.util`, it doesn't
    mean that you are automatically exporting `packt.util.impl` also. Nor does it
    mean that `packt.util.impl` is somehow *within *`packt.util`. That's not how packages
    work in Java. These are two entirely different packages, and totally unrelated
    as far as package semantics are concerned.
  prefs: []
  type: TYPE_NORMAL
- en: The state of the code at this time is in the bundled source code. Compiling
    and executing the code as before should give us the same results. However, we
    have solved a major problem related to class encapsulation that we discussed in
    [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing
    Java 9 Modularity*.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the potential impact of this encapsulation on a library developer.
    Before Java 9, every `public` type that was shipped in a library could have been
    used and accessed by the consumers of the library. Now, with Java 9 modules, a
    library developer has full control over what classes can be used and what are
    just internal. So, the library developer can refactor the *internal* library code
    without having to worry about them potentially being used. Thanks to the module
    contract, they are inaccessible and hence guaranteed to be unused in code outside
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: Module versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one aspect of module dependency that you might have noticed is missing
    from what we've covered so far--versioning. When you declare a module definition,
    can you specify a version number for the module? Also, when you specify that a
    certain module requires another module, can you also specify which version of
    module it needs? The answer to both the questions is no. For various reasons,
    module versioning is not a feature that's available in the Java Module system.
    It is not a problem the Java platform attempts to solve.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage and utility with module versioning comes with dependency
    management. Think of tools like Maven or Gradle. These tools allow you to configure
    specific versions of external dependencies which they can then automatically download
    for you from some remote repository, and then make them available in the classpath.
    The Java platform does not attempt to do this, or to solve any dependency management
    problems. It assumes that all the dependencies are already available, perhaps
    assembled by a tool like Maven or Gradle. In [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*, I had mentioned how build tools like Maven or
    Gradle achieve predictability and consistency in assembling dependencies, but
    they cannot validate the accuracy or completeness of what's assembled. This is
    where the Java module system steps in. The platform assumes that all the necessary
    source files and classes are already there! Whatever your build tools are, and
    whatever the means you take to assemble your code and libraries, the Java platform
    works on what you have as a result and *then* makes sure the module contracts
    are being met.
  prefs: []
  type: TYPE_NORMAL
- en: This is a nuanced topic, and the reasoning can be debated extensively, but it's
    important to remember that module versioning is not available in Java 9\. To manage
    multiple versions of modules, you are free to use whatever tools or processes
    you have already been using to pull in jars and libraries. In [Chapter 12](part0187.html#5IAP60-ed2405f4162b4f86b565edd6b6d679fb),
    *Using Build Tools and Testing Java Modules*, we examine how to integrate a Maven
    multi-module project with a Java 9 modular application to leverage the best of
    both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Rethinking package structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fact that you are required to *export* package names from modules has an
    interesting implication on the way we organize our types into packages in Java
    9\. Historically, the package construct has been used by Java developers to provide
    *namespaces* for Java types. While these namespaces created by package names serve
    the purpose, at least in theory, to prevent type name collisions and to affect
    visibility of package-private member variables and types, they also serve a slightly
    more informal purpose of grouping related types for search-ability and maintainability
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: There's an additional significance to packages in Java 9 that affects how you
    group your classes and other types into packages--visibility outside modules.
    For instance, if you need to hide type *A* within a module and export type *B*
    to outside the module, you are essentially required to place types *A* and *B*
    in two separate packages. In most cases, typical internal classes of libraries
    are associated with different namespaces and packages in the pre-Java 9 world
    anyway, so this shouldn't be a big change in the way we do this. But it's important
    to note that this new change could factor into our decision to place classes in
    one package versus another.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen two modules and inter-modular dependency, I'd like you to
    introduce you to the concept of a module graph. You'll likely see this in a lot
    of Java documentation over time as a good way to represent relationships between
    modules. The way to draw a module graph is to plot modules as nodes and the relationships
    between modules with an arrow. If module *A* depends on module *B*, the arrow
    is drawn from *A* to *B*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the module graph for the code we have in the address book application
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is very simple at this time, but as we learn more about the module system
    and evolve our code, we'll be coming back to this module graph and adding detail
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding module path arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our example application is comprised of two Java modules. We have the source
    of both those modules in the module source path. In reality, it's common to be
    working on module sources that depend on compiled third-party modules pulled in
    as dependencies. In such cases, you'll need to provide to the compiler the module
    source path containing the module source files, and the module path for the compiled
    dependencies. The compiler needs a distinction between the code it needs to compile
    (in  `--module-source-path`) and the location of compiled dependencies and libraries
    ( `--module-path`). When it comes to execution, you just pass in  `--module-path`
    pointing to the compiled modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the command line argument values passed to the compiler and runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  `--module-source-path` |  `--module-path` |'
  prefs: []
  type: TYPE_TB
- en: '| `javac` | Locations of all source modules | Locations of compiled modules
    that the source modules depend on. |'
  prefs: []
  type: TYPE_TB
- en: '| `java` | <Not provided> | Location of all compiled modules - including app
    modules and compiled module dependencies |'
  prefs: []
  type: TYPE_TB
- en: Revisiting classpath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen that the new Java 9 platform comes with some new abilities to do
    module level compilation and execution using the `--module-source-path` and the `--module-path`
    arguments. It is now module-aware and knows what to do in order to compile and
    execute Java 9 modules. It's very likely that these flags are going to find increased
    usage as developers embrace Java modularity.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, there's a familiar compiler parameter that will, over time,
    see decreased usage--the `-classpath` parameter. The classpath that has been a
    concept that's essential to programming in Java for so many years, is for the
    most part, not required anymore!
  prefs: []
  type: TYPE_NORMAL
- en: For about two decades now, the Java classpath has played the crucial role of
    being the home for all the classes in any given Java application. Any Java application
    is obviously made up of multiple classes, often in multiple jar files. As a Java
    developer, all you had to do to get a class into play was to add it to the classpath.
    That would guarantee that the runtime would see it. Of course, there are still
    access modifiers such as `private`, `public`, and `protected` that control who
    gets to access a given Java type. But still, the presence of a class file in a
    classpath was all it took to make it *available* to the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider the new world where there are no standalone class files and everything
    is made up of modules. A Java 9 modular application is comprised of a number of
    different modules that have dependency on one another. Given the module paths,
    the compiler and runtime can now know where all the classes are. Also, thanks
    to the module convention, the classes that belong to the module reside in the
    module folder itself. In this case, why does Java need any other information to
    access the classes required for an application? The concept of a classpath isn't
    even needed anymore!
  prefs: []
  type: TYPE_NORMAL
- en: Wait! Before you let go of everything you've learned about classpaths from your
    memory, I should let you know that what I'm describing is the ideal scenario.
    Yes, ideally, classpath will likely hold lesser importance in Java in the future.
    However, we are still not done with it yet. We will be revisiting classpaths a
    few times in this book, especially in the context of working with older codebases
    and when migrating code to Java 9\. More on that in [Chapter 10](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Preparing Your Code for Java 9* .
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the classpath problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing
    Java 9 Modularity*, we looked at two problems faced by our friends Jack and Amit:'
  prefs: []
  type: TYPE_NORMAL
- en: Jack couldn't easily *encapsulate* internal library types and prevent use of
    that type outside the library, while retaining the ability to freely use them
    inside his own library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amit couldn't *reliably* assemble a set of compiled Java code and guarantee
    that all the dependencies and imports of those types are sufficiently met before
    the program actually hits the dependency at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have we solved these problems with the module system? Thankfully, yes!
  prefs: []
  type: TYPE_NORMAL
- en: We've already seen how the Java module's encapsulation prevents certain types
    from being accessed outside the module, even if the type is `public`, unless the
    package they belong to is explicitly exported. Indeed, we applied the same concept
    to hide the `BubbleSortUtilImpl` class from external use. When it comes time to
    upgrade our library, should we feel the need to modify (or even remove) that class,
    we can rest assured that the only consumer of that code is in the library itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the second problem--runtime verification? It turns out, the Java
    runtime refers to the same `module-info` module descriptor (this time in `.class`
    format) to figure this out. You ran the `Main` class in the `packt.addressbook`
    module and it worked fine because the runtime found the dependent module `packt.sortutil`
    in the module path. Let''s see what happens if it doesn''t find it. If I were
    to delete the compiled `sortutil` directory in the `out` directory, and run `packt.addressbook/packt.addressbook.Main`
    again, notice the error you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The error message points out that the `packt.sortutil` module is not found,
    but the important thing to notice here is *when* the error is thrown. It's not
    when the class is loaded and the runtime tries to find the dependent types that
    it encounters this error. The error occurs right at the VM initialization time
    as the message clearly mentions. This is a huge advantage when it comes to reliability
    of your Java code. If there are potential errors, the runtime catches that right
    at initialization and not at some arbitrary point in time during execution.
  prefs: []
  type: TYPE_NORMAL
- en: One of the requirements that the module system was designed to meet is to achieve
    *fidelity across phases*. What does this mean? You've seen how the module descriptor
    enabled you to build modules, encapsulate types, and verify availability of the
    necessary dependencies by allowing you to specify the contract about each module.
    These benefits affect not only the compilation process of your code, but also
    the runtime process. The same module definition that lets the compiler know something
    is wrong when a required module is missing can also provide the runtime with the
    same information! Thanks to the module descriptor being compiled into the code
    as a class file, the Java runtime can also read the same descriptor and know well
    in advance if every module that is depended upon by the code that needs to be
    run is available. You get the same behavior and error checking across the compilation
    and execution phases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've created a second Java module and established inter-module
    dependency. We learned how to set up `requires` and `exports` in module definition
    files. With two modules, we are finally able to see the modularity features that
    attempt to solve some of the problems in code organization and management that
    we've discussed in [Chapter 1,](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)
    *Introducing Java 9 Modularity*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of how to create Java 9 modules and use
    them in other modules, let's focus our attention to the platform itself. Java
    9 not only comes with the module system that's meant for developers to use in
    order to create modules, it also comes with a completely revamped JRE and JDK
    that are themselves modularized. In the next chapter, you'll learn about the modularization
    of the platform, how it affects developers, and how it is, in a way, essential
    for bringing in modularity support into the Java language.
  prefs: []
  type: TYPE_NORMAL
