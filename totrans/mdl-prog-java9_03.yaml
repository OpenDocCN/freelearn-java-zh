- en: Handling Inter-Module Dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理模块间依赖
- en: 'In the last chapter, we created our first Java 9 module and set up the beginnings
    of the address book application. However, we built the whole application as a
    single module, and thus, we didn''t really leverage any of the cool new features
    of modularity. Here''s what you''ll learn to do in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了我们的第一个Java 9模块，并设置了地址簿应用程序的初步设置。然而，我们构建了整个应用程序作为一个单一模块，因此，我们没有真正利用模块化的任何新特性。在本章中，你将学习以下内容：
- en: You'll break the application up into two separate modules, and thereby create
    your second Java module
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将把应用程序拆分为两个独立的模块，从而创建你的第二个Java模块
- en: You'll learn how to establish dependencies between those two modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将学习如何在这两个模块之间建立依赖关系
- en: You'll learn more about the module descriptor configuration that's required
    to wire in two separate modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将学习更多关于配置模块描述符以连接两个独立模块所需的内容。
- en: You'll revisit the compilation and execution steps with multiple modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将重新审视具有多个模块的编译和执行步骤
- en: 'This all starts with breaking our monolithic address book viewer application
    into two modules. Breaking the single module into two dependent modules has two
    consequences:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都始于将我们的单体地址簿查看器应用程序拆分为两个模块。将单个模块拆分为两个依赖模块有两个后果：
- en: Breaking the application up into modular parts enables these modular parts to
    potentially be reused in multiple other applications.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序拆分为模块化部分，使得这些模块化部分有可能在多个其他应用程序中重用。
- en: It's an opportunity to define the interface for the modules. It lets you, as
    the module author, define what the module exports and how it should be used and
    consumed.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个定义模块接口的机会。它允许你，作为模块作者，定义模块导出什么以及如何使用和消费它。
- en: We'll look at both of these in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中探讨这两个方面。
- en: Creating the second module
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建第二个模块
- en: 'Let''s start by splitting the address book application into two separate modules.
    The obvious candidate for moving to its own module is the sorting logic. At this
    point, there''s nothing about the sorting class, `SortUtil`, that has anything
    to do with the address book. We''ve designed the class to be generic and provide
    functionality to sort any list. That''s good practice in general, but it makes
    additional sense when breaking it out as a separate module. What we will do is
    move the code related to sorting into a brand new module, called `packt.sortutil`.
    Here are the steps at a high level:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将地址簿应用程序拆分为两个独立的模块开始。显然，将排序逻辑移动到其自身的模块是一个合适的候选。在这个阶段，关于排序类`SortUtil`的任何内容都与地址簿无关。我们已经设计了该类以通用性为目标，并提供对任何列表进行排序的功能。这在一般情况下是好的实践，但在将其拆分为独立的模块时更有意义。我们将要做的是将有关排序的代码移动到一个全新的模块中，该模块称为`packt.sortutil`。以下是高层次上的步骤：
- en: Create a new module called `packt.sortutil`.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`packt.sortutil`的新模块。
- en: Move the code related to sorting into this newly created module.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与排序相关的代码移动到这个新创建的模块中。
- en: Configure the `packt.sortutil` module to define its interface--what it exports
    and how the module needs to be used.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`packt.sortutil`模块以定义其接口——它导出什么以及如何使用该模块。
- en: Configure the `packt.addressbook` module to use the new `packt.sortutil` module.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`packt.addressbook`模块以使用新的`packt.sortutil`模块。
- en: 'Let''s start by creating a new module. We''ve looked at the four steps to create
    a module in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb),
    *Creating Your First Java Module*, already. We know what the module name is. Next,
    the module structure requires creating a module root directory in the source folder.
    Just like the `packt.addressbook` folder resides in the `src` folder and holds
    all the contents of the `packt.addressbook` module, the `packt.sortutil` module
    requires the creation of a folder named `packt.sortutil` in the same `src` location.
    What makes this folder a module root folder is the presence of the module descriptor
    `module-info.java`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的模块开始。我们已经在前面的[第2章](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb)，“创建你的第一个Java模块”中探讨了创建模块的四个步骤。我们知道模块的名称。接下来，模块结构需要创建源文件夹中的模块根目录。就像`packt.addressbook`文件夹位于`src`文件夹中并包含`packt.addressbook`模块的所有内容一样，`packt.sortutil`模块需要在相同的`src`位置创建一个名为`packt.sortutil`的文件夹。使这个文件夹成为模块根文件夹的是模块描述符`module-info.java`的存在：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s the folder structure at this point:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的文件夹结构如下：
- en: '![](img/00037.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00037.jpeg)'
- en: 'Now that we have a module, we can move the necessary classes from the `packt.addressbook`
    module into the `packt.sortutil` module. There''s just one class related to sorting--`SortUtil.java`.
    With the package folders located at the module folder, the folder structure after
    moving the class over should look as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模块，我们可以将必要的类从`packt.addressbook`模块移动到`packt.sortutil`模块。只有一个与排序相关的类`SortUtil.java`。由于包文件夹位于模块文件夹中，移动类后的文件夹结构应该如下所示：
- en: '![](img/00038.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00038.jpeg)'
- en: When creating a module, you'd typically also configure the interface, that is,
    defining the module's inputs and outputs. We didn't do this to the `packt.addressbook`
    module in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb), *Creating
    Your First Java Module* because it existed as a standalone module. However, that's
    not the case anymore in this chapter, since we'll now need the two modules `packt.addressbook`
    and `packt.sortutil` to work together. This involves updating the `module-info.java`
    file for both the modules to provide this information. But let's skip this step
    for now and examine the default behavior first. Let's observe what happens if
    we don't add any module configuration and compile the two modules with empty module
    definition files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模块时，你通常会配置接口，即定义模块的输入和输出。我们在[第2章](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb)“创建你的第一个Java模块”中没有对`packt.addressbook`模块这样做，因为它作为一个独立模块存在。然而，在本章中情况不再如此，因为我们现在需要两个模块`packt.addressbook`和`packt.sortutil`协同工作。这涉及到更新两个模块的`module-info.java`文件以提供这些信息。但现在我们先跳过这一步，先观察默认行为。让我们观察如果我们不添加任何模块配置，并且使用空的模块定义文件编译两个模块会发生什么。
- en: Compiling two modules
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译两个模块
- en: Now the module path (the `src` directory) has two modules. We can now run the
    `javac` command to compile all classes in both modules, since we are supplying
    `src` as the module source path.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模块路径（`src`目录）有两个模块。我们现在可以运行`javac`命令来编译两个模块中的所有类，因为我们提供了`src`作为模块源路径。
- en: Here, `packt.sortutil` is the simpler of the two modules. Since it doesn't have
    any external dependencies, this should just work like the `packt.addressbook`
    module did in the previous chapter. Let's look at the `packt.addressbook` module.
    Things are more interesting here. Since we've moved the sort related classes to
    the `packt.sortutil` module, the `packt.addressbook` module doesn't have the classes
    in the `packt.util` package anymore. But there is code in the module that still
    uses it. Notice what happens when we try to compile both the modules with the
    same command as the previous chapter. This time, since we are compiling two modules,
    we specify both the module names to the  `--module` argument separated by a comma.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`packt.sortutil`是两个模块中较简单的一个。由于它没有任何外部依赖，这应该就像前一章中`packt.addressbook`模块所做的那样工作。让我们看看`packt.addressbook`模块。这里的情况更有趣。由于我们将排序相关的类移动到了`packt.sortutil`模块，`packt.addressbook`模块不再有`packt.util`包中的类。但模块中仍有代码在使用它。注意当我们尝试使用与上一章相同的命令编译这两个模块时会发生什么。这次，由于我们正在编译两个模块，我们指定了两个模块名称到`--module`参数，用逗号分隔。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The error you get should look something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的错误应该看起来像这样：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Firstly, note that the errors are only from compiling the `packt.addressbook`
    module. This means that the compilation of the `packt.sortutil` module succeeded!
    The three errors in the preceding output are specifically about the `Main.java`
    file. The compiler clearly doesn't see the `SortUtil` class and it complains it
    is missing. But is it really missing? We do have a public `SortUtil` class available
    in the `src` folder, but since it is in a different module folder, the compiler
    doesn't seem to see it, even though the class itself is `public`. This brings
    up an important new change relating to class visibility in Java 9.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意错误仅来自编译`packt.addressbook`模块。这意味着`packt.sortutil`模块的编译是成功的！前一个输出中的三个错误特别关于`Main.java`文件。编译器显然没有看到`SortUtil`类，并抱怨它缺失。但它真的缺失了吗？我们确实在`src`文件夹中有一个公共的`SortUtil`类，但由于它位于不同的模块文件夹中，编译器似乎没有看到它，尽管这个类本身是`public`的。这引发了一个与Java
    9中类可见性相关的重要新变化。
- en: Just because a class is marked `public` in Java 9, it doesn't necessarily mean
    it is visible to all other types.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为一个类在Java 9中被标记为`public`，并不意味着它对所有其他类型都是可见的。
- en: This is a radical change from the way `public` types work in Java 8 and earlier.
    Before Java 9, if you had a public class or interface in the classpath, it was
    available for any other type in the classpath to import and use. This is no longer
    the case with the module source path in Java 9!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Java 8及之前版本中`public`类型的操作方式有根本性的不同。在Java 9之前，如果你在类路径中有公共类或接口，它对类路径中的任何其他类型都是可用的，可以导入和使用。但在Java
    9的模块源路径中，情况不再是这样了！
- en: Configuring module dependency
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置模块依赖
- en: Think of a module being a walled garden by default. By default, any Java type
    in a module is accessible *only* to the types inside the same module. Previously,
    the `SortUtil` class was in the `packt.addressbook` module and was thus accessible
    to other types in that module. Move it to a different module however, and it is
    not accessible to types in the original module anymore.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块想象成一个默认的围栏。默认情况下，模块中的任何Java类型都只能被同一模块中的类型访问。之前，`SortUtil`类位于`packt.addressbook`模块中，因此该模块中的其他类型可以访问它。但是，如果将其移动到不同的模块，它就不再对原始模块中的类型可访问了。
- en: 'Given two modules, **A** and **B**, for any type in module A to access a type
    in module B, two conditions need to be satisfied:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个模块，**A**和**B**，要使模块A中的任何类型访问模块B中的类型，需要满足两个条件：
- en: Module A needs to declare its dependency on module B
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块A需要声明它对模块B的依赖
- en: Module B needs to declare that it's okay with that type being accessed externally
    by other modules
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块B需要声明它允许其他模块外部访问该类型
- en: If either of these conditions isn't met, the type being accessed in module B
    is said to be *not readable* by module A. We'll cover the topics of readability
    and accessibility in sufficient detail in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability*, but, for now, note that these
    are two important requirements. Let's apply these to the `packt.addressbook` and
    `packt.sortutil` modules.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个条件中的任何一个没有满足，那么在模块B中被访问的类型就被说成是模块A不可读的。我们将在[第6章](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb)中详细讨论可读性和可访问性的主题，*模块解析、可访问性和可读性*，但现在请注意，这些是两个重要的要求。让我们将这些应用到`packt.addressbook`和`packt.sortutil`模块上。
- en: 'First, we need to have the `packt.addressbook` module declare that it is dependent
    on the `packt.sortutil` module. It is using a class from that module, and there''s
    no way you can compile or run the module without it. The way to declare a dependency
    on a module is by using the `requires` keyword:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要让`packt.addressbook`模块声明它依赖于`packt.sortutil`模块。它正在使用该模块中的一个类，没有它是无法编译或运行模块的。声明对模块的依赖的方式是使用`requires`关键字：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Following the `requires` keyword is the name of the module that is required.
    And yes, you can only require other modules, and not packages or classes. This
    line is enough for the compiler and runtime to look up types from the module that
    is being *required* any time those types are being used in the module. A module
    could depend on multiple other modules. So, it's actually common to have multiple
    such `requires` lines of code in a module declaration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`requires`关键字之后是所需模块的名称。是的，你只能要求其他模块，而不能是包或类。这一行就足够编译器和运行时在需要使用这些类型时从被要求的模块中查找类型了。一个模块可能依赖于多个其他模块。因此，在模块声明中通常会有多个这样的`requires`行代码。
- en: When a compiler tries to compile a module, imagine that it looks at this list
    of modules specified with the `requires` clause and says "Okay, I understand that
    this module requires all these other modules. While I compile this module, anytime
    I see a type being used in the code of this module that belongs to another module
    that is required, I'll go look at the module that contains the type and make sure
    it exports the type being used." Since every dependent module could potentially
    require other modules, this is a recursive process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器尝试编译一个模块时，想象一下它会查看由`requires`子句指定的模块列表，并说：“好的，我明白这个模块需要所有这些其他模块。在我编译这个模块的过程中，每次我看到在模块代码中使用属于所需模块的类型时，我会查看包含该类型的模块，并确保它导出了正在使用的类型。”由于每个依赖模块可能还需要其他模块，这是一个递归过程。
- en: 'Now what does a module *exporting* a type mean? This is where we get to the
    second of the two preceding conditions. Every module needs to specifically declare
    what types in its module are okay for use outside the module. In our case, the
    `packt.sortutil` module needs to declare that the `SortUtil` class is allowed
    to be used outside its own module. This is done in the `sortutil` module''s declaration
    file, using the `exports` keyword followed by the package you want to export.
    When a module `exports` a package, all the types belonging to that package are
    allowed access outside the module:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一个模块*导出*一个类型是什么意思呢？这就引出了前面提到的两个条件中的第二个。每个模块都需要明确声明其模块中哪些类型可以在模块外部使用。在我们的例子中，`packt.sortutil`模块需要声明`SortUtil`类可以在其模块外部使用。这是在`sortutil`模块的声明文件中完成的，使用`exports`关键字后跟你想导出的包。当一个模块导出一个包时，该包中所有的类型都可以在模块外部访问：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our case, we want to export the `packt.util.SortUtil` class. So, we *export*
    the package `packt.util` thereby exporting the class within it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们想要导出`packt.util.SortUtil`类。因此，我们导出包`packt.util`，从而导出其内部的类。
- en: Again, note that you *require* modules and *export* packages. There are several
    reasons why the language designers decided to use the `exports` syntax with packages
    rather than having developers export individual types. The most obvious reason,
    of course, is that it is much more convenient than the tedium of having to export
    each class at an individual type level.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，你需要*要求*模块和*导出*包。语言设计者决定使用`exports`语法而不是让开发者单独导出类型，这有几个原因。最明显的原因当然是，这比在单个类型级别上逐个导出每个类要方便得多。
- en: We've introduced a handful of new keywords so far--`module`, `requires`, and
    `exports`. You might be wondering if they are reserved words in the Java language
    as of Java 9\. Are you in trouble if you've been using these as variable names
    all over your code today? The answer is no! These and other module related keywords
    we'll be learning in this book are what are called *restricted keywords*. You
    can still continue to use them in your code, but only when they are used in the
    context of a module descriptor, the compiler knows what they mean and it treats
    the keywords accordingly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了一些新的关键字——`module`、`requires`和`exports`。你可能想知道，从Java 9开始，这些是否是Java语言中的保留字。如果你今天一直在代码中使用这些作为变量名，你会遇到麻烦吗？答案是：不会！这些以及其他我们将在本书中学习的与模块相关的关键字被称为*受限关键字*。你仍然可以在代码中使用它们，但只有在模块描述符的上下文中使用时，编译器才能理解它们的含义，并相应地处理这些关键字。
- en: 'With both the conditions for cross-module access of types now satisfied, let''s
    compile the code again from one directory above the module path:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类型跨模块访问的条件都已满足，让我们再次从模块路径上一级目录编译代码：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, the `--module-source-path` parameter specifies where the compiler can
    find all the Java modules that are required to do its job compiling your code.
    And, the `--module` indicates the two modules to be compiled--`packt.addressbook`
    and `packt.sortutil`. The compiler finds both the module root folders in the module
    source path and compiles them into their respective classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`--module-source-path`参数指定了编译器可以找到所有必需的Java模块的位置，以便编译你的代码。而`--module`参数表示要编译的两个模块——`packt.addressbook`和`packt.sortutil`。编译器在模块源路径中找到这两个模块的根文件夹，并将它们编译成相应的类。
- en: The compilation should quietly succeed. Just like last time, you'll notice that
    the `out` folder has a `.class` file corresponding to every `.java` file in each
    of the two modules, including the module descriptors, the two `module-info.java`
    files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编译应该会静默成功。就像上次一样，你会注意到`out`文件夹中有与每个模块中的每个`.java`文件对应的`.class`文件，包括模块描述符，两个`module-info.java`文件。
- en: You can execute the `Main` class in the `packt.addressbook` module like before.
    For illustration, I'll use the terser  `-m` option (instead of `--module`) to
    specify the module and class to start execution. They both mean the same and can
    be used interchangeably.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像以前一样在`packt.addressbook`模块中执行`Main`类。为了说明，我将使用更简洁的`-m`选项（而不是`--module`）来指定模块和要启动执行的类。它们的意思相同，可以互换使用。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here as well, the `--module-path` option specifies where the Java runtime needs
    to look to find the modules required to execute the code. The runtime detects
    that the class it needs to start execution with (`Main`) is a part of the module
    `packt.addressbook` and since that module has a dependency on another module (`packt.sortutil`),
    it searches the location specified by the `module-path` option (the `out` directory
    here) to find the depended module. Thanks to our compile step placing the compiled
    module in the same location, the runtime finds it and the execution proceeds.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`--module-path`选项指定Java运行时需要查找的位置，以找到执行代码所需的模块。运行时检测到它需要以`Main`类开始执行，而`Main`类是`packt.addressbook`模块的一部分，并且该模块依赖于另一个模块（`packt.sortutil`），因此它搜索`module-path`选项指定的位置（这里的`out`目录）以找到依赖的模块。多亏了我们的编译步骤将编译后的模块放在相同的位置，运行时找到了它，并且执行继续进行。
- en: You should see the contacts successfully sorted by last name. Note that, to
    run this code, you just specified the `packt.addressbook` module and the `Main`
    class, and we didn't have to provide any information to the runtime about the
    dependent `packt.sortutil` module. This is because the Java runtime is reading
    off the same module descriptor (the `module-info.class` file this time) to know
    that the `packt.sortutil` module is required and so leverages the right class
    files from both modules as and when necessary.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到联系人已按姓氏成功排序。请注意，为了运行此代码，你只需指定了`packt.addressbook`模块和`Main`类，我们不需要向运行时提供任何有关依赖的`packt.sortutil`模块的信息。这是因为Java运行时正在读取相同的模块描述符（这次是`module-info.class`文件），以了解需要`packt.sortutil`模块，因此根据需要从两个模块中利用正确的类文件。
- en: 'Here is a diagram explaining the behavior of the two modules:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个解释两个模块行为的图示：
- en: '![](img/00039.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00039.jpeg)'
- en: 'What we''ve done is isolated the sorting functionality into its own module
    so that it can be used by other Java 9 modular applications that need sorting.
    All that any Java 9 module has to do in order to use `packt.sortutil` is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是将排序功能独立到一个自己的模块中，以便其他需要排序功能的Java 9模块化应用可以使用。任何Java 9模块要使用`packt.sortutil`，只需做以下事情：
- en: Add the `requires packt.sortutil` line in the definition of the module that
    needs the sorting functionality.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要排序功能的模块定义中添加`requires packt.sortutil`行。
- en: Import the `packt.util.SortUtil` class and call the `sortList()` method to sort
    any `List` of objects as long as the objects are `Comparable`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`packt.util.SortUtil`类并调用`sortList()`方法，以对任何`List`对象进行排序，只要这些对象是`Comparable`的。
- en: This is great, but before we share our new `packt.sortutil` library for the
    world to use, let's think about the library's API for a bit.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但在我们分享新的`packt.sortutil`库供全世界使用之前，让我们先思考一下库的API。
- en: What I mean by a library's API is the code required to be used by the consumers
    of your library in order to access it. In the case of the simplistic `packt.sortutil`
    library, for example, the API is a single method `sortList()` on the class `packt.util.SortUtil`.
    More functional libraries obviously have multiple classes and methods that could
    potentially be called by their consumers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的库的API是指消费者为了访问库而需要使用的代码。例如，在简单的`packt.sortutil`库中，API是`packt.util.SortUtil`类上的单个方法`sortList()`。显然，功能更强大的库有多个类和方法，这些类和方法可能被消费者调用。
- en: When you create a library, before you allow others to use it, you have to very
    carefully define and finalize the library's API. The reason being that, once others
    start using your library, it becomes harder to make changes to the library's public
    API. Any changes to the API in future versions of your library would mean requiring
    all the consumers of your library update their code to work with the new API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个库，在允许其他人使用它之前，你必须非常仔细地定义和最终确定库的API。原因是，一旦其他人开始使用你的库，就很难对库的公共API进行更改。你库未来版本中API的任何更改都意味着要求所有使用你库的消费者更新他们的代码以与新API兼容。
- en: Right now, the `packt.sortutil` module contains just one class. We will be evolving
    the module in the next chapters, but for now, one change I'd like to do is to
    make the `SortUtil` class as lightweight as possible. That class acts as the *programming
    interface* to the `packt.sortutil` library, so making sure the class is as simple
    as it can be with fewer lines of code makes it less susceptible to possible changes
    in the future.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`packt.sortutil`模块只包含一个类。我们将在接下来的章节中逐步完善该模块，但就目前而言，我想进行的一个改动是使`SortUtil`类尽可能轻量。该类作为`packt.sortutil`库的*编程接口*，因此确保该类尽可能简单，代码行数尽可能少，使其在未来可能的变化中更加稳健。
- en: One way to achieve this is by moving the actual sorting functionality to an
    *implementation* class and have `SortUtil` just delegate the sorting logic to
    that class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种方法是将实际的排序功能移动到一个*实现*类中，并让`SortUtil`仅将排序逻辑委托给该类。
- en: 'Let''s assume we create a `BubbleSortUtil` class that has the same structure
    as the `SortUtil` class has so far:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们创建一个`BubbleSortUtil`类，其结构与迄今为止的`SortUtil`类相同：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then update the `SortUtil` to just call `BubbleSortUtilImpl` class''s
    `sortList` method to delegate:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更新`SortUtil`，使其仅调用`BubbleSortUtilImpl`类的`sortList`方法进行委托：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is much better, because if you'd like to change the structure of the library
    or the sorting logic, as long as you keep the structure of `SortUtil` unchanged,
    the consumers of your library don't have to change their code. The `SortUtil`
    class is still tightly coupled to `BubbleSortUtil` in that it is directly instantiating
    it, but we'll be improving this is in a subsequent chapter, so let's live with
    it for now.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做更好，因为如果你想要更改库的结构或排序逻辑，只要保持`SortUtil`的结构不变，你的库的用户就不需要更改他们的代码。`SortUtil`类仍然与`BubbleSortUtil`紧密耦合，因为它直接实例化它，但我们在下一章中会改进这一点，所以现在我们就先这样吧。
- en: Running the code at this stage should result in the same output as last time.
    Now, before we announce to the world that our `packt.sortutil` module is ready
    for consumption, think back to the problem Jack faced in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*. He had created a sorting library JAR file with
    pretty much the same design as far as classes are concerned--an internal `BubbleSortUtilImpl`
    and an external `SortUtil`. The problem he ran into was the fact that a certain
    class is either *internal* or *external* was only a matter of convention and wasn't
    enforceable without Jack lumping his code into a single package just to leverage
    the package-private mechanisms. Developers using his library started to use the
    `BubbleSortUtilImpl` class that they weren't supposed to use. Let's see if we
    have the same problem with our `sortutil` module, and if so, if there are better
    tools to protect certain classes using the module system in Java 9.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段运行代码应该会产生与上次相同的输出。现在，在我们向世界宣布`packt.sortutil`模块准备投入使用之前，回顾一下杰克在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)中遇到的问题，*介绍Java
    9模块化*。他创建了一个具有与类相关的相同设计的排序库JAR文件——一个内部的`BubbleSortUtilImpl`和一个外部的`SortUtil`。他遇到的问题是，某个类是*内部*的还是*外部*的，这仅仅是一个惯例，如果没有杰克将他的代码打包到一个单独的包中以便利用包私有机制，这是无法强制执行的。使用他的库的开发者开始使用他们不应该使用的`BubbleSortUtilImpl`类。让我们看看我们是否有与`sortutil`模块相同的问题，如果有，是否有更好的工具可以使用Java
    9的模块系统来保护某些类。
- en: 'The answer is simple. Yes, we have the same problem that Jack ran into. Any
    consumer of the `sortutil` module could easily use `BubbleSortUtilImpl` directly.
    That''s because the class is in a package that''s exported from the module. We''d
    like to avoid that by encapsulating the class and prevent its usage outside the
    module. How do we do that? Simple! Just move the class to another package! Like
    we''ve already seen, the Java Platform Module System expects us to specify what
    packages are visible outside the module. If any type is accessible outside any
    module, it''s only because it belongs to an exported package in that module. Which
    is why refactoring the type into a new package is a potential solution. As long
    as the new package doesn''t show up with the `exports` clause in the module definition
    file of the module, the classes in the package are effectively hidden from outside
    use, like we''ve already seen:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单。是的，我们遇到了杰克遇到过的同样的问题。任何使用`sortutil`模块的消费者都可以轻松地直接使用`BubbleSortUtilImpl`。这是因为该类位于一个从模块导出的包中。我们希望通过封装这个类来防止它在模块外部被使用。我们该如何做呢？很简单！只需将这个类移动到另一个包中！就像我们已经看到的，Java平台模块系统期望我们指定哪些包可以在模块外部可见。如果任何类型可以在任何模块外部访问，那仅仅是因为它属于该模块中导出的包。这就是为什么将类型重构到新包中是一个潜在的解决方案。只要新包在模块的定义文件中没有出现在`exports`子句中，该包中的类就有效地对外部使用隐藏，就像我们已经看到的：
- en: '![](img/00040.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00040.jpeg)'
- en: 'Here''s a diagram of the modules, revisited with our newest change:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们最新更改后重新审视的模块图：
- en: '![](img/00041.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00041.jpeg)'
- en: Remember that packages in Java are not hierarchical. In this example, the packages
    `packt.util` and `packt.util.impl` are two separate packages that are not related
    in any way. Just because you've exported the package `packt.util`, it doesn't
    mean that you are automatically exporting `packt.util.impl` also. Nor does it
    mean that `packt.util.impl` is somehow *within *`packt.util`. That's not how packages
    work in Java. These are two entirely different packages, and totally unrelated
    as far as package semantics are concerned.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Java中的包不是分层的。在这个例子中，包`packt.util`和`packt.util.impl`是两个完全独立的包，它们之间没有任何关系。仅仅因为你导出了`packt.util`包，并不意味着你自动导出了`packt.util.impl`。也不意味着`packt.util.impl`以某种方式*位于*`packt.util`内部。这并不是Java中包的工作方式。这些是完全不同的两个包，在包语义上完全无关。
- en: The state of the code at this time is in the bundled source code. Compiling
    and executing the code as before should give us the same results. However, we
    have solved a major problem related to class encapsulation that we discussed in
    [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing
    Java 9 Modularity*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此时代码的状态是在捆绑的源代码中。像以前一样编译和执行代码应该会给我们相同的结果。然而，我们已经解决了我们在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)，“介绍Java
    9模块化”中讨论的与类封装相关的一个主要问题。
- en: Think about the potential impact of this encapsulation on a library developer.
    Before Java 9, every `public` type that was shipped in a library could have been
    used and accessed by the consumers of the library. Now, with Java 9 modules, a
    library developer has full control over what classes can be used and what are
    just internal. So, the library developer can refactor the *internal* library code
    without having to worry about them potentially being used. Thanks to the module
    contract, they are inaccessible and hence guaranteed to be unused in code outside
    the module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这种封装对库开发者的潜在影响。在Java 9之前，任何在库中发布的`public`类型都可以被库的消费者使用和访问。现在，有了Java 9模块，库开发者可以完全控制哪些类可以被使用，哪些只是内部的。因此，库开发者可以重构*内部*库代码，而无需担心它们可能被使用。多亏了模块契约，它们是不可访问的，因此在模块外部的代码中保证不会被使用。
- en: Module versioning
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块版本化
- en: There's one aspect of module dependency that you might have noticed is missing
    from what we've covered so far--versioning. When you declare a module definition,
    can you specify a version number for the module? Also, when you specify that a
    certain module requires another module, can you also specify which version of
    module it needs? The answer to both the questions is no. For various reasons,
    module versioning is not a feature that's available in the Java Module system.
    It is not a problem the Java platform attempts to solve.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们之前所涵盖的内容中缺少了模块依赖的一个方面——版本化。当你声明一个模块定义时，你能为模块指定一个版本号吗？同样，当你指定某个模块需要另一个模块时，你也能指定它需要的模块版本吗？两个问题的答案都是否定的。由于各种原因，模块版本化不是Java模块系统中的一个功能。这不是Java平台试图解决的问题。
- en: The biggest advantage and utility with module versioning comes with dependency
    management. Think of tools like Maven or Gradle. These tools allow you to configure
    specific versions of external dependencies which they can then automatically download
    for you from some remote repository, and then make them available in the classpath.
    The Java platform does not attempt to do this, or to solve any dependency management
    problems. It assumes that all the dependencies are already available, perhaps
    assembled by a tool like Maven or Gradle. In [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*, I had mentioned how build tools like Maven or
    Gradle achieve predictability and consistency in assembling dependencies, but
    they cannot validate the accuracy or completeness of what's assembled. This is
    where the Java module system steps in. The platform assumes that all the necessary
    source files and classes are already there! Whatever your build tools are, and
    whatever the means you take to assemble your code and libraries, the Java platform
    works on what you have as a result and *then* makes sure the module contracts
    are being met.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模块版本化的最大优点和实用性体现在依赖管理上。想想像Maven或Gradle这样的工具。这些工具允许你配置外部依赖项的特定版本，然后它们可以自动从某个远程仓库为你下载，并将其添加到类路径中。Java平台并不试图做这件事，或者解决任何依赖管理问题。它假设所有依赖项都已经可用，可能是由Maven或Gradle这样的工具组装的。在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)“介绍Java
    9模块化”中，我提到了像Maven或Gradle这样的构建工具如何实现依赖组装的可预测性和一致性，但它们无法验证所组装内容的准确性或完整性。这就是Java模块系统介入的地方。平台假设所有必要的源文件和类都已经存在！无论你的构建工具是什么，无论你采取什么方式来组装你的代码和库，Java平台都会在你得到的结果上工作，然后确保模块合约得到满足。
- en: This is a nuanced topic, and the reasoning can be debated extensively, but it's
    important to remember that module versioning is not available in Java 9\. To manage
    multiple versions of modules, you are free to use whatever tools or processes
    you have already been using to pull in jars and libraries. In [Chapter 12](part0187.html#5IAP60-ed2405f4162b4f86b565edd6b6d679fb),
    *Using Build Tools and Testing Java Modules*, we examine how to integrate a Maven
    multi-module project with a Java 9 modular application to leverage the best of
    both worlds.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙的话题，其推理可以广泛辩论，但重要的是要记住，模块版本化在Java 9中是不可用的。为了管理多个模块版本，你可以自由地使用你之前用来拉入jar和库的任何工具或流程。在[第12章](part0187.html#5IAP60-ed2405f4162b4f86b565edd6b6d679fb)“使用构建工具和测试Java模块”中，我们探讨了如何将Maven多模块项目与Java
    9模块化应用程序集成，以利用两者的最佳之处。
- en: Rethinking package structure
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新思考包结构
- en: The fact that you are required to *export* package names from modules has an
    interesting implication on the way we organize our types into packages in Java
    9\. Historically, the package construct has been used by Java developers to provide
    *namespaces* for Java types. While these namespaces created by package names serve
    the purpose, at least in theory, to prevent type name collisions and to affect
    visibility of package-private member variables and types, they also serve a slightly
    more informal purpose of grouping related types for search-ability and maintainability
    of code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从模块中*导出*包名的这一事实，对我们在Java 9中组织类型到包中的方式有着有趣的含义。从历史上看，包结构一直被Java开发者用来为Java类型提供*命名空间*。虽然由包名创建的这些命名空间在理论上至少可以防止类型名称冲突，并影响包私有成员变量和类型的可见性，但它们还服务于一个稍微不那么正式的目的，即为了代码的可搜索性和可维护性而将相关类型分组。
- en: There's an additional significance to packages in Java 9 that affects how you
    group your classes and other types into packages--visibility outside modules.
    For instance, if you need to hide type *A* within a module and export type *B*
    to outside the module, you are essentially required to place types *A* and *B*
    in two separate packages. In most cases, typical internal classes of libraries
    are associated with different namespaces and packages in the pre-Java 9 world
    anyway, so this shouldn't be a big change in the way we do this. But it's important
    to note that this new change could factor into our decision to place classes in
    one package versus another.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中的包具有额外的意义，这会影响你如何将类和其他类型分组到包中——模块外的可见性。例如，如果你需要在一个模块内隐藏类型 *A* 并将类型 *B*
    导出至模块外，你本质上需要将类型 *A* 和 *B* 放置在两个不同的包中。在大多数情况下，典型的库内部类在 Java 9 之前的世界中已经与不同的命名空间和包相关联，所以这不应该对我们做这件事的方式造成太大改变。但重要的是要注意，这个新的变化可能会影响我们决定将类放在一个包还是另一个包中的决策。
- en: Now that we've seen two modules and inter-modular dependency, I'd like you to
    introduce you to the concept of a module graph. You'll likely see this in a lot
    of Java documentation over time as a good way to represent relationships between
    modules. The way to draw a module graph is to plot modules as nodes and the relationships
    between modules with an arrow. If module *A* depends on module *B*, the arrow
    is drawn from *A* to *B*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了两个模块和模块间的依赖关系，我想向你介绍模块图的概念。你可能会在未来的许多 Java 文档中看到它，作为表示模块之间关系的好方法。绘制模块图的方法是将模块作为节点，用箭头表示模块之间的关系。如果模块
    *A* 依赖于模块 *B*，箭头将从 *A* 指向 *B*。
- en: 'Here''s the module graph for the code we have in the address book application
    so far:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是到目前为止地址簿应用程序中的代码的模块图：
- en: '![](img/00042.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: It is very simple at this time, but as we learn more about the module system
    and evolve our code, we'll be coming back to this module graph and adding detail
    to it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这很简单，但随着我们更多地了解模块系统并改进我们的代码，我们将回到这个模块图并添加更多细节。
- en: Understanding module path arguments
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模块路径参数
- en: Our example application is comprised of two Java modules. We have the source
    of both those modules in the module source path. In reality, it's common to be
    working on module sources that depend on compiled third-party modules pulled in
    as dependencies. In such cases, you'll need to provide to the compiler the module
    source path containing the module source files, and the module path for the compiled
    dependencies. The compiler needs a distinction between the code it needs to compile
    (in  `--module-source-path`) and the location of compiled dependencies and libraries
    ( `--module-path`). When it comes to execution, you just pass in  `--module-path`
    pointing to the compiled modules.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序由两个 Java 模块组成。我们有两个模块的源代码在模块源路径中。实际上，通常我们会处理依赖于作为依赖项拉入的编译第三方模块的模块源代码。在这种情况下，你需要向编译器提供包含模块源文件的模块源路径，以及编译依赖项的模块路径。编译器需要在需要编译的代码（`--module-source-path`）和编译依赖项和库的位置（`--module-path`）之间进行区分。当涉及到执行时，你只需传递指向编译模块的
    `--module-path`。
- en: 'Here are the command line argument values passed to the compiler and runtime:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是传递给编译器和运行时的命令行参数值：
- en: '|  |  `--module-source-path` |  `--module-path` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|  |  `--module-source-path` |  `--module-path` |'
- en: '| `javac` | Locations of all source modules | Locations of compiled modules
    that the source modules depend on. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `javac` | 所有源模块的位置 | 源模块所依赖的编译模块的位置。 |'
- en: '| `java` | <Not provided> | Location of all compiled modules - including app
    modules and compiled module dependencies |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `java` | <未提供> | 所有编译模块的位置 - 包括应用程序模块和编译模块依赖项 |'
- en: Revisiting classpath
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾类路径
- en: We've seen that the new Java 9 platform comes with some new abilities to do
    module level compilation and execution using the `--module-source-path` and the `--module-path`
    arguments. It is now module-aware and knows what to do in order to compile and
    execute Java 9 modules. It's very likely that these flags are going to find increased
    usage as developers embrace Java modularity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，新的 Java 9 平台提供了一些新的能力来进行模块级别的编译和执行，使用 `--module-source-path` 和 `--module-path`
    参数。现在它是模块感知的，并且知道如何编译和执行 Java 9 模块。随着开发者接受 Java 模块化，这些标志可能会得到更广泛的使用。
- en: At the same time, there's a familiar compiler parameter that will, over time,
    see decreased usage--the `-classpath` parameter. The classpath that has been a
    concept that's essential to programming in Java for so many years, is for the
    most part, not required anymore!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，有一个熟悉的编译器参数，随着时间的推移，其使用频率将逐渐降低——那就是`-classpath`参数。多年来，类路径一直是Java编程中一个至关重要的概念，但现在大部分情况下不再需要了！
- en: For about two decades now, the Java classpath has played the crucial role of
    being the home for all the classes in any given Java application. Any Java application
    is obviously made up of multiple classes, often in multiple jar files. As a Java
    developer, all you had to do to get a class into play was to add it to the classpath.
    That would guarantee that the runtime would see it. Of course, there are still
    access modifiers such as `private`, `public`, and `protected` that control who
    gets to access a given Java type. But still, the presence of a class file in a
    classpath was all it took to make it *available* to the runtime.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的二十年中，Java类路径扮演了至关重要的角色，成为任何给定Java应用程序中所有类的家园。显然，任何Java应用程序都由多个类组成，通常分布在多个jar文件中。作为一个Java开发者，你只需将类添加到类路径中，就可以让它发挥作用。这会保证运行时能够看到它。当然，仍然有`private`、`public`和`protected`这样的访问修饰符来控制谁可以访问给定的Java类型。但即便如此，类文件在类路径中的存在就足以使其对运行时**可用**。
- en: Now, consider the new world where there are no standalone class files and everything
    is made up of modules. A Java 9 modular application is comprised of a number of
    different modules that have dependency on one another. Given the module paths,
    the compiler and runtime can now know where all the classes are. Also, thanks
    to the module convention, the classes that belong to the module reside in the
    module folder itself. In this case, why does Java need any other information to
    access the classes required for an application? The concept of a classpath isn't
    even needed anymore!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一个新世界，其中没有独立的类文件，一切都是由模块组成的。Java 9模块化应用程序由多个相互依赖的不同模块组成。给定模块路径，编译器和运行时现在可以知道所有类的位置。此外，多亏了模块约定，属于模块的类位于模块文件夹本身中。在这种情况下，为什么Java还需要其他信息来访问应用程序所需的类？类路径的概念甚至不再需要了！
- en: Wait! Before you let go of everything you've learned about classpaths from your
    memory, I should let you know that what I'm describing is the ideal scenario.
    Yes, ideally, classpath will likely hold lesser importance in Java in the future.
    However, we are still not done with it yet. We will be revisiting classpaths a
    few times in this book, especially in the context of working with older codebases
    and when migrating code to Java 9\. More on that in [Chapter 10](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Preparing Your Code for Java 9* .
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！在你将关于类路径的所有知识从记忆中抹去之前，我应该告诉你，我所描述的是理想情况。是的，理想情况下，类路径在Java中将可能变得不那么重要。然而，我们还没有完全结束它。在这本书中，我们还将多次回顾类路径，特别是在处理旧代码库和将代码迁移到Java
    9时。更多内容请参阅[第10章](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb)，*为Java
    9准备你的代码*。
- en: Revisiting the classpath problems
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次审视类路径问题
- en: 'In [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing
    Java 9 Modularity*, we looked at two problems faced by our friends Jack and Amit:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)，*介绍Java 9模块化*中，我们探讨了我们的朋友杰克和阿米特面临的问题：
- en: Jack couldn't easily *encapsulate* internal library types and prevent use of
    that type outside the library, while retaining the ability to freely use them
    inside his own library
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杰克无法轻易**封装**内部库类型，防止在库外部使用该类型，同时保留在库内部自由使用它们的能力
- en: Amit couldn't *reliably* assemble a set of compiled Java code and guarantee
    that all the dependencies and imports of those types are sufficiently met before
    the program actually hits the dependency at runtime
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿米特无法**可靠地**组装一组编译后的Java代码，并保证在程序实际运行时遇到依赖之前，所有这些类型及其依赖和导入都得到了充分的满足
- en: Have we solved these problems with the module system? Thankfully, yes!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否通过模块系统解决了这些问题？幸运的是，是的！
- en: We've already seen how the Java module's encapsulation prevents certain types
    from being accessed outside the module, even if the type is `public`, unless the
    package they belong to is explicitly exported. Indeed, we applied the same concept
    to hide the `BubbleSortUtilImpl` class from external use. When it comes time to
    upgrade our library, should we feel the need to modify (or even remove) that class,
    we can rest assured that the only consumer of that code is in the library itself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到Java模块的封装如何防止某些类型在模块外部被访问，即使该类型是`public`的，除非它们所属的包被明确导出。实际上，我们应用了相同的概念来隐藏`BubbleSortUtilImpl`类的外部使用。当升级我们的库时，如果我们觉得需要修改（甚至删除）该类，我们可以放心，唯一使用该代码的消费者就在库本身。
- en: 'How about the second problem--runtime verification? It turns out, the Java
    runtime refers to the same `module-info` module descriptor (this time in `.class`
    format) to figure this out. You ran the `Main` class in the `packt.addressbook`
    module and it worked fine because the runtime found the dependent module `packt.sortutil`
    in the module path. Let''s see what happens if it doesn''t find it. If I were
    to delete the compiled `sortutil` directory in the `out` directory, and run `packt.addressbook/packt.addressbook.Main`
    again, notice the error you get:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第二个问题——运行时验证？结果证明，Java运行时引用相同的`module-info`模块描述符（这次是`.class`格式）来解决这个问题。您在`packt.addressbook`模块中运行了`Main`类，并且它运行正常，因为运行时在模块路径中找到了依赖模块`packt.sortutil`。让我们看看如果没有找到会发生什么。如果我要删除`out`目录中的编译`sortutil`目录，并再次运行`packt.addressbook/packt.addressbook.Main`，请注意您会得到的错误：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The error message points out that the `packt.sortutil` module is not found,
    but the important thing to notice here is *when* the error is thrown. It's not
    when the class is loaded and the runtime tries to find the dependent types that
    it encounters this error. The error occurs right at the VM initialization time
    as the message clearly mentions. This is a huge advantage when it comes to reliability
    of your Java code. If there are potential errors, the runtime catches that right
    at initialization and not at some arbitrary point in time during execution.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息指出未找到`packt.sortutil`模块，但这里需要注意的重要事情是错误抛出的 *时间*。错误并不是在类加载和运行时尝试查找依赖类型时遇到的，正如消息清楚地提到的，错误发生在虚拟机初始化时间。这对于Java代码的可靠性来说是一个巨大的优势。如果有潜在的错误，运行时会在初始化时捕捉到，而不是在执行过程中的某个任意时间点。
- en: One of the requirements that the module system was designed to meet is to achieve
    *fidelity across phases*. What does this mean? You've seen how the module descriptor
    enabled you to build modules, encapsulate types, and verify availability of the
    necessary dependencies by allowing you to specify the contract about each module.
    These benefits affect not only the compilation process of your code, but also
    the runtime process. The same module definition that lets the compiler know something
    is wrong when a required module is missing can also provide the runtime with the
    same information! Thanks to the module descriptor being compiled into the code
    as a class file, the Java runtime can also read the same descriptor and know well
    in advance if every module that is depended upon by the code that needs to be
    run is available. You get the same behavior and error checking across the compilation
    and execution phases.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统被设计用来满足的一个要求是达到 *跨阶段的一致性*。这是什么意思呢？您已经看到模块描述符如何让您构建模块、封装类型，并通过允许您指定每个模块的合约来验证必要依赖项的可用性。这些好处不仅影响您代码的编译过程，也影响运行时过程。同一个模块定义让编译器知道当缺少所需的模块时有什么错误，也可以向运行时提供相同的信息！由于模块描述符被编译成类文件，Java运行时也可以读取相同的描述符，并提前知道需要运行的代码所依赖的每个模块是否可用。您在编译和执行阶段都能获得相同的行为和错误检查。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've created a second Java module and established inter-module
    dependency. We learned how to set up `requires` and `exports` in module definition
    files. With two modules, we are finally able to see the modularity features that
    attempt to solve some of the problems in code organization and management that
    we've discussed in [Chapter 1,](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)
    *Introducing Java 9 Modularity*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个第二个Java模块，并建立了模块间的依赖关系。我们学习了如何在模块定义文件中设置`requires`和`exports`。有了两个模块，我们终于能够看到试图解决我们在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)“介绍Java
    9模块化”中讨论的代码组织和管理的某些问题的模块化特性。
- en: Now that we have a basic understanding of how to create Java 9 modules and use
    them in other modules, let's focus our attention to the platform itself. Java
    9 not only comes with the module system that's meant for developers to use in
    order to create modules, it also comes with a completely revamped JRE and JDK
    that are themselves modularized. In the next chapter, you'll learn about the modularization
    of the platform, how it affects developers, and how it is, in a way, essential
    for bringing in modularity support into the Java language.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何创建 Java 9 模块以及在其他模块中使用它们有了基本了解，让我们将注意力集中在平台本身上。Java 9 不仅带来了旨在供开发者使用以创建模块的模块系统，还带来了一个完全重制的
    JRE 和 JDK，它们自身也是模块化的。在下一章中，你将了解平台的模块化，它如何影响开发者，以及它在某种程度上对于将模块化支持引入 Java 语言是至关重要的。
