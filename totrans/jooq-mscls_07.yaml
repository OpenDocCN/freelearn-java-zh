- en: '*Chapter 5*: Tackling Different Kinds of SELECT, INSERT, UPDATE, DELETE, and
    MERGE'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common scenario for jOOQ beginners originates from having a plain valid SQL
    that should be expressed via the jOOQ DSL API. While the jOOQ DSL API is extremely
    intuitive and easy to learn, the lack of practice may still lead to scenarios
    where we simply cannot find or intuit the proper DSL methods that should be chained
    to express a certain SQL.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter addresses this kind of issue via a comprehensive collection of
    popular queries, which gives you the chance to practice jOOQ DSL syntax based
    on the Java-based schema. More precisely, our aim is to express, in jOOQ DSL syntax,
    a carefully harvested list of `SELECT`, `INSERT`, `UPDATE`, `DELETE`, and `MERGE`
    statements that are used in our day-to-day job.
  prefs: []
  type: TYPE_NORMAL
- en: This way, by the end of this chapter, you should have funneled a significant
    number of SQLs through the jOOQ DSL syntax and tried them out against MySQL, PostgreSQL,
    SQL Server, and Oracle databases in Java applications based on Maven and Gradle.
    Being dialect-agnostic, jOOQ DSL excels at handling tons of dialect-specific issues
    by emulating a valid syntax, therefore, this is also a good chance to taste this
    aspect for these four popular databases.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, even if you see some performance tips, our focus is not on finding
    the best SQL or the most optimal SQL for a certain use case. This is not our goal!
    Our goal is to learn the jOOQ DSL syntax at a decent level that allows writing
    almost any `SELECT`, `INSERT`, `UPDATE`, `DELETE`, and `MERGE` statement in a
    productive manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, our agenda contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Expressing `SELECT` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressing `INSERT` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressing `UPDATE` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressing `DELETE` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressing `MERGE` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter05](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Expressing SELECT statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will express/write via jOOQ DSL syntax a wide range of `SELECT`
    statements, including common projections, popular subqueries, scalar and correlated
    subqueries, unions, and row value expressions. We'll start with the commonly used
    projections.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing commonly used projections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By *commonly used projections*, we understand the projections written against
    the well-known dummy table, `DUAL`. As you most probably know, the `DUAL` table
    is specific to Oracle; it's mostly unnecessary in MySQL (although jOOQ still renders
    it for MySQL 5.7 compatibility) and doesn't exist in PostgreSQL and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, even if the SQL standard requires a `FROM` clause, jOOQ never
    requires such a clause and it renders the `DUAL` table whenever it is needed/supported.
    For example, selecting *0* and *1* can be done via the `selectZero()` and `selectOne()`methods
    (these statics are available in `org.jooq.impl.DSL`). The latter (`selectOne()`),
    including some alternatives, is exemplified next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As a parenthesis, the DSL class also expose three helpers for expressing the
    commonly used `0 literal (DSL.zero())`, `1 literal (DSL.one())`, and `2 literal
    (DSL.two())`. So, while selectZero() results in a new DSL subselect for a constant
    0 literal, the zero() represents the 0 literal itself. Selecting ad hoc values
    can be done as follows (since we cannot use plain values in `select()`, we rely
    on the `val()` method introduced in [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*, to obtain the proper parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it can be done via the `values()` table constructor, which allows us to
    express in-memory temporary tables. With jOOQ, the `values()` table constructor
    can be used to create tables that can be used in a `SELECT` statement''s `FROM`
    clause. Notice how we specified the column aliases ("derived column lists") along
    with the table alias (`"t"`) for the `values()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another alternative to `selectOne()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify an explicit `FROM` clause to point out some specific tables.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the purpose of offering `selectOne()` and the like is not really
    to allow for querying `ctx.selectOne().fetch()`, but to be used in queries where
    the projection doesn''t matter, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the code bundled with this book, you can find more examples that are not
    listed here. Take your time to explore the *CommonlyUsedProjections* application.
    Next, let's tackle `SELECT` subqueries or subselects.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing SELECT to fetch only the needed data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with jOOQ DSL may target a simple `SELECT` query of the `SELECT all_columns
    FROM table` or `SELECT * FROM table` type. This kind of query can be written in
    jOOQ as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we rely on the generated Java-based schema (obtained via the jOOQ generator
    as you saw in [*Chapter 2*](B16833_02.xhtml#_idTextAnchor024), *Customizing the
    jOOQ Level of Involvement*), jOOQ can infer the fields (columns) of the `ORDER`
    table and explicitly render them in the generated query. But, if you need to render
    the `*` itself instead of the list of fields, then you can use the handy `asterisk()`
    method, as in the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As Lukas Eder mentioned: "*Perhaps worth stressing more heavily here that the
    asterisk (*`*`*) is not the same thing as the other three ways of querying all
    columns. The asterisk (*`*`*) projects all the columns from the live database
    schema including the ones that jOOQ doesn''t know. The other three approaches
    project all the columns that jOOQ knows but those columns may no longer exist
    in the live database schema. There may be a mismatch, which is especially important
    when mapping to records (for instance, using* `selectFrom()`*, or* `into(recordtype)`*).
    Even so, when using *, and when all the tables in* `from()` *are known to jOOQ,
    jOOQ will try to expand the asterisk in order to access all converters and data
    type bindings, and embeddable records, and other things*."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, notice that such queries may fetch more data than needed, and relying
    on `*` instead of a list of columns may come with performance penalties, which
    are discussed in this article: [https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/](https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/).
    When I say that *it may fetch more data than needed*, I refer to the scenarios
    that process only a subset of the fetched result set, while the rest of it is
    simply discarded. Fetching data can be an expensive (especially, time-consuming)
    operation, therefore, fetching data just to discard it is a waste of resources
    and it can lead to long-running transactions that affect the application''s scalability.
    This is a common scenario in JPA-based applications (for instance, in Spring Boot,
    `spring.jpa.open-in-view=true` may lead to loading more data than is needed).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Among others, Tanel Poder''s article mentions one thing that a lot of beginners
    overlook. By forcing the database to do "*useless, mandatory work*" (you''ll love
    this article for sure: [https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/](https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/))
    via a `*` projection, it can no longer apply some optimizations to the query,
    for example, join elimination, which is essential for complex queries ([https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/#some-query-plan-optimizations-not-possible](https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/#some-query-plan-optimizations-not-possible)).'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a subset of columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a rule of thumb, fetching more data than needed is a common cause of persistence
    layer performance penalties. Therefore, if all you need is a subset of columns
    from `ORDER`, then simply enlist them explicitly in `SELECT` as `select(ORDER.ORDER_ID,
    ORDER.ORDER_DATE, ORDER.REQUIRED_DATE, ORDER.SHIPPED_DATE, ORDER.CUSTOMER_NUMBER)`.
    Sometimes, the needed subset of columns is almost equal to (but not equal to)
    the total number of fields/columns. In such cases, instead of enlisting the subset
    of columns as previously, it is more practical to point out the fields/columns
    that should be excluded via the `except()` method. Here is an example of fetching
    all fields/columns from `ORDER` except `ORDER.COMMENTS` and `ORDER.STATUS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that applies the SQL `nvl()` function to the `OFFICE.CITY`
    field. Whenever `OFFICE.CITY` is `null`, we fetch the `N/A` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to attach an alias to a condition, then we first need to wrap this
    condition in a field via the `field()` method. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the result set table-like head of this query looks as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16833_Figure_5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the `* EXCEPT (...)` syntax is inspired by BigQuery, which also
    has a `* REPLACE (...)` syntax that jOOQ plans to implement. You can track its
    progress here: [https://github.com/jOOQ/jOOQ/issues/11198](https://github.com/jOOQ/jOOQ/issues/11198).'
  prefs: []
  type: TYPE_NORMAL
- en: In the code bundled with this book (`SelectOnlyNeededData`), you can see more
    examples of juggling with the `asterisk()` and `except()` methods to materialize
    different scenarios that involve one or more tables.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a subset of rows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides using predicates, fetching only a subset of rows is commonly accomplished
    via the `LIMIT ... OFFSET` clause. Unfortunately, this clause is not part of the
    SQL standard and it is understood only by a limited number of database vendors
    such as MySQL and PostgreSQL. Nevertheless, jOOQ allows us to use `LIMIT ... OFFSET`
    via the `limit()` and `offset()` methods and will handle all aspects of emulating
    a compatible syntax for the used dialect. Here is an example of rendering `LIMIT
    10 OFFSET 5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the same thing (the same query and result) but expressed via the `limit(Number
    offset, Number numberOfRows)` flavor (pay attention that the offset is the first
    argument – the order of arguments inherited from MySQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And, jOOQ will render the following SQL depending on the database vendor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Commonly, the arguments of `LIMIT` and `OFFSET` are some hard-coded integers.
    But, jOOQ allows us to use `Field` as well. For instance, here we use a scalar
    subquery in `LIMIT` (the same thing can be done in `OFFSET`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As a note from Lukas Eder, "*Starting with version 3.15, jOOQ generates standard
    SQL for* `OFFSET … FETCH` *in PostgreSQL, not the vendor-specific* `LIMIT … OFFSET`
    *anymore. This is to provide native support for* `FETCH NEXT … ROWS WITH TIES`*.
    Maybe, a future jOOQ will also offer the SQL Standard 2011 Oracle''s/SQL Server''s
    syntax:* `OFFSET n ROW[S] FETCH { FIRST | NEXT } m [ PERCENT ] ROW[S] { ONLY |
    WITH TIES }`." Track it here: [https://github.com/jOOQ/jOOQ/issues/2803](https://github.com/jOOQ/jOOQ/issues/2803).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the previous queries use an explicit `ORDER BY` to avoid unpredictable
    results. If we omit `ORDER BY`, then jOOQ will emulate it on our behalf whenever
    it is needed. For instance, `OFFSET` (unlike `TOP`) requires `ORDER BY` in SQL
    Server, and if we omit `ORDER BY`, then jOOQ will render it on our behalf as in
    the following SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Since we touched on this emulation topic, let's have a note that you should
    be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the coolest things about jOOQ is the capability to emulate the valid
    and optimal SQL syntax when the user database is lacking a specific feature (consider
    reading this article: [https://blog.jooq.org/2018/03/13/top-10-sql-dialect-emulations-implemented-in-jooq/](https://blog.jooq.org/2018/03/13/top-10-sql-dialect-emulations-implemented-in-jooq/)).
    The jOOQ documentation mentions that "*jOOQ API methods which are not annotated
    with the* `org.jooq.Support` *annotation (*`@Support`*), or which are annotated
    with the* `@Support` *annotation, but without any SQL dialects can be safely used
    in all SQL dialects. The aforementioned* `@Support` *annotation does not only
    designate which databases natively support a feature. It also indicates that a
    feature is emulated by jOOQ for some databases lacking this feature*." Moreover,
    whenever jOOQ doesn''t support some vendor-specific functionality/syntax, the
    solution is to use plain SQL templating. This is dissected in a future chapter
    of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more examples, please consider the code bundled with this book. You''ll
    find a collection of 15+ examples, including several corner cases as well. For
    instance, in `EXAMPLE 10.1` and `10.2`, you can see an example of fetching the
    rows in a certain order via the jOOQ `sortAsc()` method (if you are in such a
    position, then I suggest you read this article as well: [https://blog.jooq.org/2014/05/07/how-to-implement-sort-indirection-in-sql/](https://blog.jooq.org/2014/05/07/how-to-implement-sort-indirection-in-sql/)).
    Or, in `EXAMPLE 11`, you can see how to choose at runtime between `WHERE ... IN`
    and `WHERE ... NOT IN` statements via the jOOQ `org.jooq.Comparator` API and a
    Boolean variable. Moreover, in `EXAMPLE 15` and `16`, you can see the usage of
    the `SelectQuery` API for fetching columns from different tables. Take your time
    and practice each of these examples. I''m pretty sure that you''ll learn a lot
    of tricks from them. The application is named `SelectOnlyNeededData`. For now,
    let''s talk about expressing subselects in jOOQ.'
  prefs: []
  type: TYPE_NORMAL
- en: Expressing SELECT subqueries (subselects)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Roughly speaking, a `SELECT` subquery (or subselect) is represented by a `SELECT`
    statement nested in another `SELECT` statement. Commonly, they appear in the `WHERE`
    or the `FROM` clauses, but it is no surprise to see them in the `HAVING` clause
    or combined with database views.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s take the following plain SQL containing a subselect in
    the `WHERE` clause as part of the predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In jOOQ, we can express this query straightforwardly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we have used the `IN` statement via the jOOQ `in()` method. In the
    same manner, you can use other statements supported by jOOQ, such as `NOT IN`
    (`notIn()`), `BETWEEN` (`between()`), `LIKE` (`like()`), and many others. Always
    pay attention to using `NOT IN` and that it's a peculiar behavior regarding `NULL`
    originating from the subquery ([https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/in-predicate/](https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/in-predicate/)).
  prefs: []
  type: TYPE_NORMAL
- en: Almost any SQL statement has a jOOQ equivalent implementation, therefore, take
    your time and scan the jOOQ API to cover it as much as possible. This is the right
    direction in becoming a jOOQ power user.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: In subselects of type `SELECT foo...`, `(SELECT buzz)` is a common case to use
    both `DSLContext.select()` and `DSL.select()` as `ctx.select(foo) ... (select(buzz))`.
    The `DSLContext.select()` method is used for the outer `SELECT` in order to obtain
    a reference to a database configured connection, while for the inner or nested
    `SELECT`, we can use `DSL.select()` or `DSLContext.select()`. However, using `DSL.select()`
    for the inner `SELECT` is more convenient because it can be statically imported
    and referenced simply as `select()`. Notice that using `DSL.select()`for both
    types of `SELECT` or only for the inner `SELECT` leads to an exception of type
    *Cannot execute query. No Connection configured*. But, of course, you can still
    execute `DSL.select()` via `DSLContext.fetch(ResultQuery)` and the like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s have another plain SQL that has a subselect in the `FROM` clause,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, let''s express the subselect via a derived table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach relies on `table(select(…))`. Practically, `table``(Select<R>)`
    is a synonym for `asTable()`. Choose the one that you find more fluent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use this derived table to express the outer `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Since jOOQ cannot infer the field types of a user-defined derived table, we
    can rely on coercing to fill up the expected types of the `sen` and `avgs` fields
    (for a quick reminder of the *coercing* goal, please revisit [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*), or `saleTable.field(name, type)`, as here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The jOOQ API is so flexible and rich that it allows us to express the same
    SQL in multiple ways. It depends on us to choose the most convenient approach
    in a certain scenario. For example, if we consider that the SQL part `WHERE (employee_number
    = saleTable.sen AND sale < saleTable.avgs)`can be written as `WHERE (employee_number
    = sen AND sale < avgs)`, then we can extract the following fields as local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we can use them in the derived table and outer `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can eliminate the explicitly derived table and embed the subselect in
    a fluent style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we removed the explicit `saleTable` alias as well. As MySQL complains
    (and not only), every derived table requires an alias, but we don't have to worry
    about it. jOOQ knows this and will generate an alias on our behalf (something
    similar to `alias_25088691`). But, if your benchmarks reveal that alias generation
    is not negligible, then it is better to supply an explicit alias. As Lukas Eder
    says, "*However, the generated alias is based deterministically on the SQL string,
    in order to be stable, which is important for execution plan caches (for instance,
    Oracle, SQL Server, irrelevant in MySQL, PostgreSQL)*."
  prefs: []
  type: TYPE_NORMAL
- en: Consider more examples in the bundled code. For instance, if you are interested
    in using `SELECT` nested in`INSERT`, `UPDATE`, and `DELETE`, then you can find
    examples in the bundled code. The application is named *SampleSubqueries*. Next,
    let's talk about scalar subqueries.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing scalar subqueries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A scalar subquery selects only one column/expression and returns only one row.
    It can be used in an SQL query anywhere that a column/expression can be used.
    For example, let''s assume plain SQL that selects the employees with a salary
    greater than or equal to the average salary plus *25,000*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'In jOOQ, this query is generated by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Have you noticed the `...ge(select(...))` construct? In the left-hand of `ge()`
    we have a `Field`, but in the right-hand we have a `Select`. This is possible
    thanks to `ge(Select<? extends Record1<T>> select)`, which is a very handy shortcut
    that saves us from the explicit usage of `field()` as `ge(field(select(...)))`,
    or from `asField()` as `ge(select(...).asField())`. We can also write conditions
    such as `select(...).ge(select(...))`. But, what is the difference between `field()`
    and `asField()`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have another example that inserts a new `PRODUCT` (I''ve listed only
    the relevant part):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert the value of `PRODUCT.MSRP` as the average `Field`. This can be done
    as we did via `field(Select<? extends Record1<T>> s)` or via `asField()`. If we
    go with `asField()`, then we write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'But, `asField()` returns this result provider as a `Field<?/Object>` object.
    In other words, `asField()` loses type information and so isn''t type-safe. By
    losing type information, `asField()` allows us to accidentally introduce type-safety-related
    errors that cannot be detected until runtime, or even worse, that will produce
    unexpected results. Here, we have typed `array(PRODUCT.MSRP)` instead of `avg(PRODUCT.MSRP)`
    but we have no complaints until runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you won''t be writing such blabbering, but the idea is that using
    `asField()` in such contexts is prone to other data type incompatibilities that
    might be hard to spot and might produce unexpected results. So, let''s keep `asField()`
    for queries as `SELECT b.*, (SELECT foo FROM a) FROM b`, and let''s focus on `field()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Do you think this code will compile? The correct answer is no! Your IDE will
    immediately signal a data type incompatibility. While `PRODUCT.MSRP` is `BigDecimal`,
    `(array(PRODUCT.MSRP))` is `Field<BigDecimal[]>`, so `INSERT` is wrong. Replace
    `array()` with `avg()`. Problem solved!
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code (`ScalarSubqueries`), you have more examples, including
    using scalar queries nested in `INSERT`, `UPDATE`, and `DELETE`. Next, let's talk
    about correlated subqueries.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing correlated subqueries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A correlated subquery (or repeating subquery) uses the values of the outer query
    for computing its values. Since it depends on the outer query, a correlated subquery
    can't be executed independently as a standalone subquery. As Lukas Eder mentioned,
    "*In any case, no RDBMS is forced to naively execute a correlated subquery once
    for each row evaluated by the outer query (obviously, if such a thing would happen,
    then this may come with an overhead in performance if the correlated subquery
    must be executed for a significant number of times). Many RDBMS would optimize
    a correlated subquery by applying a transformation to a join or semi-join. Other,
    such as Oracle 11g and later, optimizes correlated subqueries thanks to scalar
    subquery caching*." ([https://blogs.oracle.com/oraclemagazine/on-caching-and-evangelizing-sql](https://blogs.oracle.com/oraclemagazine/on-caching-and-evangelizing-sql))
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following plain SQL representing a correlated scalar subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Expressing this query in jOOQ can be done as follows (notice that we want to
    preserve the `s1` and `s2` aliases in the rendered SQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you spot this: `...where(s1.SALE_.eq(select(max(s2.SALE_))`? No `asField()`
    /`field()` required! The query didn''t need to call `asField()`/`field()`, because
    there''s a convenience overload provided by jOOQ as `Field<T>.eq(Select<? extends
    Record1<T>>)`. Yes, I know I already told you about it earlier, but I just wanted
    to enforce it again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as you probably intuited, this correlated subquery, which relies on
    repeatedly self-joined tables, can be expressed more efficiently via `GROUP BY`
    as follows (this time, we don''t preserve the aliases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `GROUP BY` is *much* better, because it eliminates that self-join,
    turning *O(n*2*)* into *O(n).* As Lukas Eder shared, "*With modern SQL, self-joins
    are almost never really needed anymore. Beginners might think that these self-joins
    are the way to go, when they can be quite detrimental,* [https://twitter.com/MarkusWinand/status/1118147557828583424](https://twitter.com/MarkusWinand/status/1118147557828583424)*,
    O(n*2) *in the worst case*." So, before jumping in to write such correlated subqueries,
    try to evaluate some alternatives and compare the execution plans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example based on the following plain SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this query compares the average buy price (or list price) of all products
    with all the sale prices of each product. If this average is greater than any
    of the sale prices of a product, then the product is fetched in the result set.
    In jOOQ, this can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you have a comprehensive list of examples, including examples
    containing `WHERE (NOT) EXISTS`, `ALL`, and `ANY`. As Lukas Eder says, "*It is
    worth mentioning that the name of ALL and ANY is "quantifier" and the comparison
    is called quantified comparison predicate. These are much more elegant than comparing
    with* `MIN()` *or* `MAX()`*, or using* `ORDER BY .. LIMIT 1`*, especially when
    row value expressions are used*." Moreover, you can check out examples of using
    correlated subqueries nested in `INSERT`, `UPDATE`, and `DELETE`. The application
    is named *CorrelatedSubqueries*. Next, let's talk about writing row expressions
    in jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing row expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Row value expressions are quite handy for writing elegant multi-row predicates.
    jOOQ represents row value expressions via the `org.jooq.Row` interface. Its usage
    is straightforward, as the following plain SQL shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'In jOOQ, this can be expressed via `row()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code (`RawValueExpression`), you can practice examples of using
    row value expressions with comparison predicates, `BETWEEN` and `OVERLAPS` predicates
    (jOOQ supports overlapping dates and arbitrary row value expressions of degree
    2 – how cool is that?!), and `NULL`. Next, let's tackle the `UNION` and `UNION
    ALL` operators.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing the UNION and UNION ALL operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UNION` and `UNION ALL` operators are useful for combining two or more
    result sets from different `SELECT` statements or `SELECT`s into one result set.
    `UNION` eliminates duplicate rows from the results of the `SELECT` statements,
    while `UNION ALL` doesn''t do this. To work, the number and order of columns must
    correspond in both queries and the data types must be the same or at least compatible.
    Let''s consider the following SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ renders `UNION` via the `union()` method and `UNION ALL` via the `unionAll()`
    method. The previous SQL is rendered via `union()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Lukas Eder noted that *"*`UNION` *(*`ALL`*) acts differently with respect to*
    `NULL` *than other operators, meaning that two* `NULL` *values are 'not distinct.'
    So* `SELECT NULL UNION SELECT NULL` *produces only one row, just like* `SELECT
    NULL INTERSECT SELECT NULL`*.**"*
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can practice more examples, including `UNION` and `ORDER
    BY`, `UNION` and `LIMIT`, `UNION` and `HAVING`, `UNION` and `SELECT INTO` (MySQL
    and PostgreSQL), `UNION ALL`, and so on. Unfortunately, there is no space here
    to list and dissect these examples, therefore, consider the application named
    *SelectUnions*. Next, let's cover the `INTERSECT` and `EXCEPT` operators.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing the INTERSECT (ALL) and EXCEPT (ALL) operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `INTERSECT` operator produces only the values (rows) that are returned by
    (or common to) both subselects. The `EXCEPT` operator (or `MINUS` in Oracle) produces
    only the values that occur in the first (or left) subselect and don't occur in
    the second (or right) subselect. While `INTERSECT` and `EXCEPT` remove duplicates
    from their results, `INTERSECT ALL` and `EXCEPT ALL` don't do this. Exactly as
    in the case of `UNION`, to work, the number and order of columns must correspond
    in both queries and the data types must be the same or at least compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following plain SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'In jOOQ, this can be expressed via `intersect()` as follows (for rendering
    `INTERSECT ALL`, use the `intersectAll()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'By replacing the SQL `INTERSECT` with `EXCEPT` and, in jOOQ, the `intersect()`
    method with `except()` we can obtain an `EXCEPT` use case (for `EXCEPT ALL`, use
    the `exceptAll()` method). Here is the plain SQL (this time, let''s add an `ORDER
    BY` clause as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'And the jOOQ code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Nevertheless, if your database doesn't support these operators (for example,
    MySQL), then you have to emulate them. There are several ways to accomplish this
    and in the application named *IntersectAndExcept* (for MySQL), you can see a non-exhaustive
    list of solutions that emulate `INTERSECT` (`ALL`) based on `IN` (useful when
    no duplicates or `NULL` are present) and `WHERE EXISTS`, and emulate `EXCEPT`
    (`ALL`) based on `LEFT OUTER JOIN` and `WHERE NOT EXISTS`. Of course, feel free
    to check out the examples from *IntersectAndExcept* for PostgreSQL, SQL Server,
    and Oracle as well. Notice that Oracle 18c (used in our applications) supports
    only `INTERSECT` and `EXCEPT`, while Oracle20c supports all these four operators.
    Next, let's tackle the well-known `SELECT DISTINCT` and more.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing distinctness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'jOOQ comes with a suite of methods for expressing distinctness in our queries.
    We have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT DISTINCT` via `selectDistinct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IS` (`NOT`) `DISTINCT FROM` via `isDistinctFrom()` and `isNotDistinctFrom()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COUNT (DISTINCT...)` via `countDistinct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AVG`/`SUM`/`MIN`/`MAX (DISTINCT ...)` via `avg`/`sum`/`min`/`maxDistinct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL `DISTINCT ON` via `selectDistinct().on()` or `distinctOn()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example of `IS DISTINCT FROM` as follows (in MySQL, `IS DISTINCT
    FROM` is represented by the `<=>` operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'And jOOQ renders this query via the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the used dialect, jOOQ emulates the correct syntax. While for MySQL,
    jOOQ renders the `<=>` operator, for Oracle, it relies on `DECODE` and `INTERSECT`,
    and for SQL Server, it relies on `INTERSECT`. PostgreSQL supports `IS DISTINCT
    FROM`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see an example of PostgreSQL''s `DISTINCT ON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'And the jOOQ code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: It is definitely worth mentioning here that jOOQ emulates this PostgreSQL-specific
    `DISTINCT ON` for MySQL, SQL Server, Oracle, and so on, via the `row_number()`
    window function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can write jOOQ queries that emulate `DISTINCT ON` as well. For
    instance, the following example fetches the employee numbers of the maximum sales
    per fiscal year via jOOQ''s `rowNumber()` and `qualify()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'A classical scenario solved via `DISTINCT ON` relies on selecting some distinct
    column(s) while ordering by other column(s). For instance, the following query
    relies on the PostgreSQL `DISTINCT ON` to fetch the distinct employee numbers
    ordered by minimum sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this can be emulated without `DISTINCT ON` as well. Here is an alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code (`SelectDistinctOn`), you can find examples that cover all
    the bullets of the previous list. Take your time to practice them and get familiar
    with jOOQ syntax. Moreover, don't stop at these examples; feel free to experiment
    as much as possible with `SELECT`.
  prefs: []
  type: TYPE_NORMAL
- en: That's all about `SELECT`. Next, let's start talking about inserts.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing INSERT statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will express different kinds of inserts including `INSERT
    ... VALUES`, `INSERT ... SET`, `INSERT ... RETURNING`, and `INSERT ...DEFAULT
    VALUES` via the jOOQ DSL syntax. Let's start with the well-known `INSERT ... VALUES`
    insert, which is supported by most database vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing INSERT ... VALUES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jOOQ supports `INSERT ... VALUES` via the `insertInto()` and `values()` methods.
    Optionally, we can use the `columns()` method for separating the name of the table
    in which we insert from the list of fields/columns that we insert. To trigger
    the actual `INSERT` statement, we have to explicitly call `execute()`; pay attention
    to this aspect since jOOQ novices tend to forget this call at the end of the insert/update/delete
    expressions. This method returns the number of rows affected by this `INSERT`
    statement as an integer value (`0`), which means that nothing happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following jOOQ type-safe expression will render an `INSERT`
    statement that can be successfully executed against at least MySQL, PostgreSQL,
    SQL Server, and Oracle (the primary key of the `ORDER` table, `ORDER.ORDER_ID`,
    is auto-generated, therefore, it can be omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, using `columns()`, it can be expressed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'If the entire list of columns/fields is omitted (for example, for verbosity
    reasons), then the jOOQ expression is non-type-safe and you have to explicitly
    specify a value for each field/column of the table, including for the field/column
    representing an auto-generated primary key and the fields/columns having default
    values, otherwise you''ll get an exception, as *the number of values must match
    the number of fields*. Moreover, you have to pay attention to the order of values;
    jOOQ matches the values to the fields only if you follow the order of arguments
    defined in the constructor of the `Record` class generated for the table in which
    we insert (for example, in this case, the order of arguments from the constructor
    of `OrderRecord`). As Lukas Eder adds, "*The* `Record` *constructor parameter
    order is also derived, like everything else, from the order of columns as declared
    in DDL, which is always the source of truth*." In this context, specifying an
    explicit dummy value for the auto-generated primary key (or other field) can rely
    on the almost universal (and standard SQL) way, SQL `DEFAULT`, or `DSL.default_()`/`DSL.defaultValue()`
    in jOOQ (attempting to use `NULL` instead of SQL `DEFAULT` produces implementation-specific
    behavior):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'In PostgreSQL, we can use the `ORDER_SEQ.nextval()` call as well; `ORDER_SEQ`
    is the explicit sequence associated with the `ORDER` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Generally speaking, we can use the explicit or auto-assigned sequence (if the
    primary key is of the (`BIG`)`SERIAL` type) associated with the table and call
    the `nextval()` method. jOOQ defines a `currval()` method as well, representing
    the current value of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server is quite challenging because it cannot insert explicit values for
    the identity column when `IDENTITY_INSERT` is set to `OFF` ([https://github.com/jOOQ/jOOQ/issues/1818](https://github.com/jOOQ/jOOQ/issues/1818)).
    Until jOOQ comes up with an elegant workaround, you can rely on a batch of three
    queries: one query sets `IDENTITY_INSERT` to `ON`, one query is `INSERT`, and
    the last query sets `IDENTITY_INSERT` to `OFF`. But, even so, this is useful only
    for specifying an explicit valid primary key. The SQL `DEFAULT` or `NULL` values,
    or any other dummy values, are not allowed as explicit identity values. SQL Server
    will simply attempt to use the dummy value as the primary key and will end up
    with an error. As Lukas Eder said, "*In some other RDBMS you''d still get an exception
    if the auto-generated value is* `GENERATED ALWAYS AS IDENTITY` *(as opposed to*
    `GENERATED BY DEFAULT AS IDENTITY`*), and you''re trying to insert an explicit
    value*."'
  prefs: []
  type: TYPE_NORMAL
- en: No matter whether the primary key is of an auto-generated type or not, if you
    specify it explicitly (manually) as a valid value (not a dummy and not a duplicate
    key), then `INSERT` succeeds in all these four databases (of course, in SQL Server,
    in the context of `IDENTITY_INSERT` set to `ON`).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Omitting the column list was interesting to explain `DEFAULT` and identities/sequences,
    but it's really not recommended to omit the column list in `INSERT`. So, you'd
    better strive to use the column list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For inserting multiple rows, you can simply add a `values()` call per row in
    fluent style or use a loop to iterate a list of rows (typically, a list of records)
    and reuse the same `values()` call with different values. In the end, don''t forget
    to call `execute()`. This approach (and not only) is available in the bundled
    code. But, starting with jOOQ 3.15.0, this can be done via `valuesOfRecords()`
    or `valuesOfRows()`. For instance, consider a list of records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'We can insert this list into the database via `valuesOfRecords()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example with a list of rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we can use `valuesOfRows()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you need to collect data (for instance, POJOs) into a list or array
    of `RowN`, you can use the built-in `toRowList()` respectively `toRowArray()`
    collectors. You can find examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other thoughts, inserting `Record` can be done in several ways; for a quick
    reminder of jOOQ records, please revisit [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*. For now, let''s insert the following `SaleRecord` corresponding
    to the `SALE` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert `sr`, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can even do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can attach the record to the current configuration via `attach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to insert a POJO requires us to wrap it first in the corresponding `Record`.
    This can be done via the `newRecord()` method, which can load a jOOQ-generated
    record from your POJO or the jOOQ-generated POJO. Here is an example for the jOOQ-generated
    `Sale` POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach relies on the handy `Record.from(POJO)` method, as follows
    (basically, this time you use an explicit instance of `SaleRecord`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '`Record.from()` comes in several flavors that allow us to populate `Record`
    from an array or even `Map` of values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you need to reset a `Record` primary key (or another field), call
    the `reset()` method as in the following scenario, which resets the manually assigned
    primary key and allows the database to generate one on our behalf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: 'Nevertheless, the `reset()` method resets both the *changed* flag (which tracks
    record changes) and *value* (in this case, the primary key). If you want to reset
    only the value (primary key or another field), then you can rely on the `changed``(Field<?>
    field, boolean changed)` method as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Well, these were just a handful of examples. Many more, including using UDTs
    (in PostgreSQL and Oracle) and user-defined functions in `INSERT`, are available
    in the bundled code in the application named *InsertValues*. Next, let's talk
    about `INSERT ... SET`.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing INSERT ... SET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`INSERT ... SET` is an alternative to `INSERT ... VALUES`, having an `UPDATE`-like
    syntax, and is commonly used in MySQL (but not only so). Practically, instead
    of listing columns and values separately, in `INSERT ... SET`, we write field-value
    pairs via the `set(field, value)` method. This is more readable since we can easily
    identify the value of each field. Let''s look at an example of inserting two rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax works for `Record` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: Since `INSERT … SET` and `INSERT … VALUES` are equivalent, jOOQ emulates `INSERT
    … SET` as `INSERT … VALUES` for all databases supported by jOOQ. The complete
    application is named *InsertSet*. Next, let's tackle the `INSERT ... RETURNING`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing INSERT ... RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The particularity of `INSERT ... RETURNING` relies on the fact that it can return
    what was inserted (fetch back something that we need further). This may resume
    returning the primary key of the inserted row(s) or other fields as well (for
    instance, other sequences, default generated values, and trigger results). PostgreSQL
    has native support for `INSERT ... RETURNING`. Oracle also supports `INSERT ...
    RETURNING`, and jOOQ generates a PL/SQL anonymous block for it (not always). SQL
    Server supports `OUTPUT`, which is almost the same (apart from how trigger-generated
    values are affected). Other databases have poor support, and jOOQ has to emulate
    it on our behalf. In such cases, jOOQ relies on the JDBC `getGeneratedKeys()`
    method to retrieve the inserted primary keys. Moreover, if the generated primary
    keys (or other columns) cannot be retrieved directly, jOOQ may need to execute
    an additional `SELECT` to achieve this goal and this may lead to race conditions
    (for instance, such `SELECT` are needed in MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: The jOOQ API for `INSERT ... RETURNING` contains the `returningResult()` method
    that comes in different flavors. It comes with different lists of arguments allowing
    us to specify which fields should be returned. If all fields should be returned,
    then simply use it without arguments. If only the primary key should be returned
    (being a popular use case for database auto-generated primary keys such us MySQL's
    `AUTO_INCREMENT` or PostgreSQL's (`BIG`)`SERIAL`, which automatically produces
    a sequence), then simply specify it as `returningResult(pk_field)`. If the primary
    key has multiple fields (a composite primary key), then list all of its fields
    separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that returns the primary key of a single insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there is a single result, we fetch it via the `fetchOne()` method. Fetching
    multiple primary keys can be done via `fetch()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the returned result contains three primary keys. Returning more/other
    fields can be done as follows (the result looks like an *n-cols x n-rows* table):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at a more interesting example. In our database schema, the
    `CUSTOMER` and `CUSTOMERDETAIL` tables are in a one-to-one relationship and share
    the primary key value. In other words, the `CUSTOMER` primary key is at the same
    time the primary key and foreign key in `CUSTOMERDETAIL`; this way, there is no
    need to maintain a separate foreign key. So, we have to use the `CUSTOMER` returned
    primary key for inserting the corresponding row in `CUSTOMERDETAIL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with JPA, then you can recognize an elegant alternative
    to `@MapsId` here.
  prefs: []
  type: TYPE_NORMAL
- en: The first `INSERT` (inner `INSERT`) will insert a row in `CUSTOMER` and will
    return the generated primary key via `returningResult()`. Next, the second `INSERT`
    (outer `INSERT`) will insert a row in `CUSTOMERDETAIL` using this returned primary
    key as a value for the `CUSTOMERDETAIL.CUSTOMER_NUMBER` primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the `returningResult()` method can also return expressions such as
    `returningResult(A.concat(B).as("C"))`.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, take your time and check out the bundled code, which comes with many
    more examples. The application is named *InsertReturning*. Next, let's talk about
    `INSERT ... DEFAULT VALUES`.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing INSERT ... DEFAULT VALUES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The straightforward approach for inserting default values is to omit the fields
    having default values from `INSERT`. For example, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: The `PRODUCT` fields that are not listed (`PRODUCT_DESCRIPTION`, `PRODUCT_UID`,
    `SPECS`, and `QUANTITY_IN_STOCK`) will take advantage of implicit default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The jOOQ API comes with `defaultValues()`, `defaultValue()`, and `default_()`
    methods for explicitly pointing out the fields that should rely on default values.
    The former is useful for inserting a single row having only default values; if
    you check the database schema, you can notice that the `MANAGER` table has a default
    value for each of its columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the `defaultValue()` method (or `default_()`) allows us
    to point to the fields that should rely on default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-type-safe version of this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: 'The same result can be obtained by specifying the types of columns. For example,
    the previous `defaultValue(PRODUCT.QUANTITY_IN_STOCK)` calls can be written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'Inserting `Record` with default values can be done quite simply, as in the
    following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: Using default values is useful to fill up those fields that will be later updated
    (for example, via subsequent updates, trigger-generated values, and so on) or
    if we simply don't have values.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named *InsertDefaultValues*. Next, let's talk about
    jOOQ and `UPDATE` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing UPDATE statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will express different kinds of updates, including `UPDATE
    ... SET`, `UPDATE ... FROM`, and `UPDATE ... RETURNING`, and update using row
    value expressions via the jOOQ DSL syntax. At the time of writing, jOOQ supports
    updates against a single table, while updates against multiple tables represent
    a work in progress task.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing UPDATE ... SET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The straightforward `UPDATE ... SET` statement can be expressed in jOOQ via
    the `set(field, value)` method, as in the following example (don''t forget to
    call `execute()` to trigger the update):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered SQL for MySQL dialect will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: Looks like a classic `UPDATE`, right? Notice that jOOQ automatically renders
    only the updated columns. If you are coming from JPA, then you know that Hibernate
    JPA renders, by default, all columns and we have to rely on `@DynamicUpdate` to
    obtain the same thing as jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out another example for increasing the employee salary by an amount computed
    based on their sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the generated SQL for SQL Server dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this is an `UPDATE` without a `WHERE` clause and jOOQ will log
    a message as `A statement is executed without WHERE clause`. This is just friendly
    information that you can ignore if you have omitted the `WHERE` clause on purpose.
    But, if you know that this was not done on purpose, then you may want to avoid
    such situations by relying on the jOOQ `withExecuteUpdateWithoutWhere()` setting.
    You can choose from several behaviors including throwing an exception, as in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use `Configuration.derive()`, not `Configuration.set()`, because
    if the `DSLContext` is injected, `Configuration` is global and shared. Using `Configuration.set()`
    will affect the global settings. If this is the desired behavior, then it is better
    to rely on a separate `@Bean`, as you already saw in this book.
  prefs: []
  type: TYPE_NORMAL
- en: This time, whenever we attempt to execute `UPDATE` without the `WHERE` clause,
    `UPDATE` doesn't take any action and jOOQ throws an exception of the `org.jooq.exception.DataAccessException`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating `Record` is also quite simple. Check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: As you'll see in the bundled code, using `DSLContext.newRecord()` is also an
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing UPDATE using row value expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Updating using row value expressions is a very handy tool, and jOOQ expresses
    such updates in a very clean and intuitive way. Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: 'The produced SQL for PostgreSQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if row value expressions are particularly useful for writing subselects,
    as in the previous example, it doesn''t mean that you cannot write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be useful for reusing fields with minimum verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's tackle the `UPDATE ... FROM` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing UPDATE ... FROM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the `UPDATE ... FROM` syntax, we can join additional tables to an `UPDATE`
    statement. Notice that this `FROM` clause is vendor-specific supported in PostgreSQL
    and SQL Server, but not supported in MySQL and Oracle (however, when you read
    this book, jOOQ may have already emulated this syntax, so check it out). Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: 'And the SQL rendered for PostgreSQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's tackle the `UPDATE ... RETURNING` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing UPDATE ... RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`UPDATE ... RETURNING` is like `INSERT ... RETURNING` but for `UPDATE`. This
    is supported natively by PostgreSQL and is emulated by jOOQ for SQL Server and
    Oracle. In jOOQ DSL, we express `UPDATE ... RETURNING` via `returningResult()`
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL rendered for PostgreSQL is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `UPDATE ... RETURNING` for logically chaining multiple updates.
    For example, let''s assume that we want to increase the salary of an employee
    with the average of their sales and the credit limit of their customers with the
    returned salary multiplied by two. We can express these two `UPDATE` statements
    fluently via `UPDATE ... RETURNING` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: However, pay attention to potential race conditions, given that there are two
    round trips hidden in what looks like a single query.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing this example and many others can be done via the application named
    *UpdateSamples*. Next, let's tackle the `DELETE` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing DELETE statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expressing `DELETE` statements in jOOQ can be done via the `DSLContext.delete()`
    and `DSLContext.deleteFrom()` API or via `DSLContext.deleteQuery()` and `DSLContext.executeDelete()`,
    respectively. While the first three methods receive an argument of the `Table<R>`
    type, the `executeDelete()`method is useful for deleting a record as `TableRecord<?>`
    or `UpdatableRecord<?>`. As you can see from the following example, `delete()`
    and `deleteFrom()` work exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these expressions render this SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining `DELETE` and row value expressions is useful for deleting via subselects,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: One important aspect of `DELETE` resumes to cascading deletion from parent to
    child. Whenever possible, it is a good idea to rely on database support for accomplishing
    `DELETE` cascading tasks. For example, you can use `ON DELETE CASCADE` or a stored
    procedure that implements the cascading deletion logic. As Lukas Eder highlights,
    "*The rule of thumb is to* `CASCADE` *compositions (UML speak) and to* `RESTRICT`
    *or* `NO ACTION`*, or* `SET NULL` *(if supported) aggregations. In other words,
    if the child cannot live without the parent (composition), then delete it with
    the parent. Otherwise, raise an exception (*`RESTRICT`*,* `NO ACTION`*), or set
    the reference to* `NULL`*. jOOQ might support* `DELETE ... CASCADE` *in the future:*
    [https://github.com/jOOQ/jOOQ/issues/7367](https://github.com/jOOQ/jOOQ/issues/7367)."
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if none of these approaches are possible, then you can do it via jOOQ
    as well. You can write a chain of separate `DELETE` statements or rely on `DELETE
    ... RETURNING` as in the following examples, which delete `PRODUCTLINE` via cascading
    (`PRODUCTLINE` – `PRODUCTLINEDETAIL` – `PRODUCT` – `ORDERDETAIL`). In order to
    delete `PRODUCTLINE`, we have to delete all its products from `PRODUCT` and the
    corresponding record from `PRODUCTLINEDETAIL`. To delete all products of `PRODUCTLINE`
    from `PRODUCT`, we have to delete all references for these products from `ORDERDETAIL`.
    So, we start deleting from `ORDERDETAIL`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: This jOOQ fluent expression renders four `DELETE` statements, which you can
    check in the bundled code. The challenge here consists of guaranteeing the roll-back
    functionality if something goes wrong. But, having the jOOQ expression in a Spring
    Boot `@Transactional` method, the roll-back functionality is out of the box. This
    is much better than the JPA cascading via `CascadeType.REMOVE` or `orphanRemoval=true`,
    which are very prone to *N + 1* issues. jOOQ allows us to control both what is
    deleted, and how this takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other thoughts, deleting `Record` (`TableRecord` or `UpdatableRecord`) can
    be done via `executeDelete()`, as in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: Exactly as in the case of `UPDATE`, if we attempt to perform `DELETE` without
    a `WHERE` clause, then jOOQ will inform us in a friendly way via a message. We
    can take control of what should happen in such cases via the `withExecuteDeleteWithoutWhere()`
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can see `withExecuteDeleteWithoutWhere()` next to many
    other examples that have not been listed here. The complete application is named
    *DeleteSamples*. Next, let's talk about `MERGE` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing MERGE statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MERGE` statement is quite a powerful tool; it allows us to perform `INSERT`/`UPDATE`
    and even `DELETE` on a table known as the *target table* from a table known as
    the *source table*. I strongly suggest you read this article, especially if you
    need a quick reminder of the `MERGE` statement: [https://blog.jooq.org/2020/04/10/the-many-flavours-of-the-arcane-sql-merge-statement/](https://blog.jooq.org/2020/04/10/the-many-flavours-of-the-arcane-sql-merge-statement/).'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL and PostgreSQL support a `MERGE` flavor known as `UPSERT` (`INSERT` or
    `UPDATE`) via `ON DUPLICATE KEY UPDATE`, respectively via `ON CONFLICT DO UPDATE`
    clauses. You can find examples of these statements next to the well-known `INSERT
    IGNORE INTO` (MySQL) and `ON CONFLICT DO NOTHING` (PostgreSQL) clauses in the
    code bundled with this book. By the way, we can use all these statements interchangeably
    (for example, we can use `onConflictDoNothing()` with MySQL and `onDuplicateKeyIgnore()`
    with PostgreSQL), since jOOQ will always emulate the correct syntax. We can even
    use them with SQL Server and Oracle, as jOOQ will emulate them via the `MERGE
    INTO` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server and Oracle have support for `MERGE INTO` with different additional
    clauses. Here is an example of exploiting the `WHEN MATCHED THEN UPDATE` (jOOQ
    `whenMatchedThenUpdate()`) and `WHEN NOT MATCHED THEN INSERT` (jOOQ `whenNotMatchedThenInsert()`)
    clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered SQL for the SQL Server dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at another example using the `WHEN MATCHED THEN DELETE` (jOOQ
    `whenMatchedThenDelete()`) and `WHEN NOT MATCHED THEN INSERT` (jOOQ `whenNotMatchedThenInsert()`)
    clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: 'This works flawlessly in SQL Server, but it doesn''t work in Oracle because
    Oracle doesn''t support the `WHEN MATCHED THEN DELETE` clause. But, we can easily
    obtain the same result by combining `WHEN MATCHED THEN UPDATE` with `DELETE WHERE`
    (obtained via the jOOQ `thenDelete()`) clause. This works because, in Oracle,
    you can add a `DELETE WHERE` clause, but only together with an `UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '`WHEN MATCHED THEN UPDATE` is obtained via jOOQ''s `whenMatchedAnd()`; this
    is the jOOQ implementation for the `WHEN MATCHED AND <some predicate> THEN` clause,
    but in this case, it is rendered as `WHEN MATCHED THEN UPDATE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `DELETE WHERE` clause in SQL Server and in Oracle works the same.
    An important aspect of using the `DELETE WHERE` clause consists of which table
    the `DELETE WHERE` clause references. This clause can target the rows before or
    after an update. The following `MERGE` example updates all the rows in the *target
    table* that have a matching row in the *source table*. The `DELETE WHERE` clause
    deletes only those rows that were matched by `UPDATE` (this is `DELETE` after
    `UPDATE`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows that `DELETE WHERE` can match against values of
    the rows before `UPDATE` as well. This time, `DELETE WHERE` references the *source
    table*, so the status is checked against the source not against the result of
    `UPDATE` (this is `DELETE` before `UPDATE`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can practice more examples. The application is named
    *MergeSamples*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a comprehensive resource for examples of expressing popular
    `SELECT`, `INSERT`, `UPDATE`, `DELETE`, and `MERGE` statements in the jOOQ DSL
    syntax relying on the Java-based schema.
  prefs: []
  type: TYPE_NORMAL
- en: For brevity, we couldn't list all the examples here, but I strongly recommend
    you take each application and practice the examples against your favorite database.
    The main goal is to get you familiar with the jOOQ syntax and to become capable
    of expressing any plain SQL via the jOOQ API in a productive amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we continue this adventure with a very exciting topic:
    expressing `JOIN` in jOOQ.'
  prefs: []
  type: TYPE_NORMAL
