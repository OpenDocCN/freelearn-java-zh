- en: Chapter 1. Introduction to FP, Reactive, and Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。FP、响应式和Scala简介
- en: 'In our first chapter, we will learn the basic concepts of **Functional Programing**
    (**FP**), reactive programming, and the Scala language. These concepts are listed
    as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一章中，我们将学习函数式编程（**FP**）、响应式编程和Scala语言的基本概念。这些概念如下所示：
- en: Setting up a Scala development environment with Eclipse Scala IDE.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse Scala IDE设置Scala开发环境。
- en: Basic constructs of the language like var, val, for, if, switch, and operator
    overload.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言的基本结构，如var、val、for、if、switch和操作符重载。
- en: The difference between FP and object-oriented programming.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程与面向对象编程之间的区别。
- en: 'Principles of pure FP: immutability, no side effects, state discipline, composition,
    and higher order functions.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数式编程（FP）的原则：不可变性、无副作用、状态纪律、组合和高级函数。
- en: Concepts of FP such as lambda, recursion, for comprehensions, partial functions,
    Monads, currying, and functions.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP的概念，如lambda、递归、for推导、部分函数、Monads、柯里化和函数。
- en: Pattern Matcher, recursion, reflection, package objects, and concurrency.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配、递归、反射、包对象和并发。
- en: Let's get going!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Functional programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: 'FP is not new at all. The very first implementation of FP is Lisp and is dated
    from the 1950s. Currently, we are living in a post-functional programming era,
    where we have the strong math principles and ideas from the 50s mixed with the
    most modern and beautiful piece of engineering, also know as the **Java Virtual
    Machine** (**JVM**). Scala is a post-functional programming language built on
    top of the JVM. Being on top of the JVM gives us a lot of benefits such as the
    following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: FP根本不新。FP的第一个实现是Lisp，始于20世纪50年代。目前，我们正处于一个后函数式编程时代，那时我们拥有50年代强大的数学原理和思想，与现代最美丽和先进的工程技术相结合，也称为**Java虚拟机**（**JVM**）。Scala是一种基于JVM的后函数式编程语言。位于JVM之上为我们带来了许多好处，如下所示：
- en: 'Scala is a post-functional programming language built on top of the JVM. Being
    on top of the JVM gives us a lot of benefits such as the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是一种基于JVM的函数式编程语言。位于JVM之上为我们带来了许多好处，如下所示：
- en: '**Reliability and performance**: Java is used by 10 out of 10 top websites
    we have currently, like Netflix, Apple, Uber, Twitter, Yahoo, eBay, Yelp, LinkedIn,
    Google, Amazon, and many others. JVM is the best solution at scale and is battle-tested
    by these web-scale companies.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性和性能**：Java被我们目前排名前10的网站中的10个使用，如Netflix、Apple、Uber、Twitter、Yahoo、eBay、Yelp、LinkedIn、Google、Amazon等。JVM是规模化的最佳解决方案，并且已经由这些网站规模公司进行了实战测试。'
- en: '**Native JVM eco-system**: Full access to all of the Java ecosystem including
    frameworks, libraries, servers, and tools.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生JVM生态系统**：完全访问包括框架、库、服务器和工具在内的所有Java生态系统。'
- en: '**Operations leverage**: Your operation team can run Scala in the same way
    they run Java.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作利用**：您的操作团队可以像运行Java一样运行Scala。'
- en: '**Legacy code leverage**: Scala allows you to easily integrate Scala code with
    Java code. This feature is great because it enables Java legacy system integration
    inside the box.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遗留代码利用**：Scala允许您轻松地将Scala代码与Java代码集成。这个特性非常棒，因为它使得Java遗留系统集成变得容易。'
- en: '**Java interoperability**: A code written in Scala can be accessed in Java.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java互操作性**：用Scala编写的代码可以在Java中访问。'
- en: Scala was created in 2001 at EPFL by Martin Odersky. Scala is a strong static-typed
    language, and was inspired by another functional language called **Haskell**.
    Scala addresses several criticisms of the Java language, and delivers a better
    developer experience through less code and more concise programs, without losing
    performance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是由Martin Odersky于2001年在EPFL创建的。Scala是一种强静态类型语言，并受到了另一种名为**Haskell**的函数式语言的启发。Scala解决了Java语言的几个批评，并通过更少的代码和更简洁的程序，在不损失性能的情况下提供了更好的开发者体验。
- en: Scala and Java share the same infrastructure as the JVM, but in terms of design,
    Scala is a different language in comparison with Java. Java is an imperative object-oriented
    language and Scala is a post-functional, multiparadigm programing language. FP
    works with different principles than **object-oriented programing** (**OOP**).
    OOP got very popular and well established in enterprise thanks to languages like
    Java, C#, Ruby, and Python. However, languages like Scala, Clojure, F#, and Swift
    are gaining a huge momentum, and FP has grown a lot in the last 10 years. Most
    of the new languages are pure functional, post-functional, or hybrid (like Java
    8). In this book, you will see Scala code compared with Java code so you can see
    by yourself how Scala is way more compact, objective, and direct than Java and
    imperative OOP languages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 和 Java 与 JVM 具有相同的底层结构，但在设计上，Scala 与 Java 相比是不同的语言。Java 是一种命令式面向对象的语言，而
    Scala 是一种后函数式、多范式的编程语言。FP 与 **面向对象编程**（**OOP**）的工作原理不同。OOP 由于 Java、C#、Ruby 和 Python
    等语言而变得非常流行和稳固。然而，Scala、Clojure、F# 和 Swift 等语言正在获得巨大的动力，FP 在过去 10 年中得到了很大的发展。大多数新的语言都是纯函数式、后函数式或混合（如
    Java 8）。在这本书中，你将看到 Scala 代码与 Java 代码的比较，这样你可以亲自看到 Scala 相比 Java 和命令式 OOP 语言要紧凑、客观和直接得多。
- en: FP started at academia and spread to the world; FP is everywhere. Big Data and
    Stream processing solutions like Hadoop and Spark (built on top of Scala and Akka)
    are built on top of FP ideas and principles. FP spread to UI with **RxJavaScript **-
    you can even find FP in a database with Datomic (Clojure). Languages like Clojure
    and Scala made FP more practical and attractive to enterprise and professional
    developers. In this book, we will be exploring both principles and practical aspects
    of the Scala language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: FP 从学术界开始，传播到全世界；FP 到处都是。像 Hadoop 和 Spark 这样的大数据和流处理解决方案（建立在 Scala 和 Akka 之上）都是建立在
    FP 思想和原则之上的。FP 传播到 UI，有了 **RxJavaScript** - 你甚至可以在 Datomic（Clojure）数据库中找到 FP。像
    Clojure 和 Scala 这样的语言使 FP 对企业和专业开发者更加实用和有吸引力。在这本书中，我们将探讨 Scala 语言的原理和实践方面。
- en: Principles of functional programming
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程原理
- en: FP is a way of thinking, a specific style of constructing and building programs.
    Having an FP language helps a lot in terms of syntax, but at the end of the day,
    it's all about ideas and developer mindset. FP favors disciplined state management
    and immutability in a declarative programming way rather than the imperative programming
    mostly used by OOP languages such as Java, Python, and Ruby.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: FP 是一种思考方式，一种构建和构建程序的具体风格。拥有 FP 语言在语法方面有很大帮助，但最终，一切都关于思想和开发者心态。FP 倾向于以声明式编程方式管理纪律状态和不可变性，而不是像
    Java、Python 和 Ruby 这样的 OOP 语言主要使用的命令式编程。
- en: FP has roots in math back to **Lambda calculus **- a formal system developed
    in the 1930s. Lambda calculus is a mathematical abstraction and not a programming
    language, but it is easy to see its concepts in programming languages nowadays.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: FP 的根源可以追溯到数学中的 **Lambda 演算** - 20 世纪 30 年代开发的一种形式系统。Lambda 演算是一种数学抽象，不是编程语言，但如今在编程语言中很容易看到其概念。
- en: Imperative programming uses statements to change the program state. In other
    words, this means you give commands to the program to perform actions. This way
    of thinking describes a sequence of steps on how the program needs to operate.
    What you need to keep in mind is the kind of style focus on how FP works in a
    different way, focusing on what the program should accomplish without telling
    the program how to do it. When you are coding in FP, you tend to use fewer variables,
    for loops, and IFS, and write more functions and make function composition.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程使用语句来改变程序状态。换句话说，这意味着你向程序下达命令以执行操作。这种方式描述了程序需要操作的步骤序列。你需要记住的是，FP 的工作方式关注于程序应该完成什么，而不是告诉程序如何去做。当你用
    FP 编码时，你倾向于使用更少的变量、循环和条件语句，并编写更多的函数和函数组合。
- en: 'The following are the CORE principles of FP:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 FP 的核心原理：
- en: Immutability
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Disciplined state
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纪律状态
- en: Pure functions and no side effects/disciplined states
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数和无副作用/纪律状态
- en: First class functions and high order functions
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首类函数和高阶函数
- en: Type systems
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型系统
- en: Referential transparency
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明性
- en: Let's understand these principles in detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解这些原理。
- en: Immutability
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: The concept of immutability is the CORE of FP, and it means that once you assign
    a value to something, that value won't change. This is very important, because
    it eliminates side effects (anything outside of the local function scope), for
    instance, changing other variables outside the function. Immutability makes it
    easier to read code, because you know the function that you are using is a pure
    function. Since your function has a disciplined state and does not change other
    variables outside of the function, you don't need to look at the code outside
    the function definition. This sounds like you're not working with state at all,
    so how would it be possible to write professional applications this way? Well,
    you will change state but in a very disciplined way. You will create another instance
    or another pointer to that instance, but you won't change that variable's value.
    Having immutability is the key to having better, faster, and more correct programs,
    because you don't need to use locks and your code is parallel by nature.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性概念是FP的核心，这意味着一旦你给某个东西赋值，该值就不会改变。这非常重要，因为它消除了副作用（任何在局部函数作用域之外的东西），例如，在函数外部更改其他变量。不可变性使得代码更容易阅读，因为你知道你正在使用的函数是一个纯函数。由于你的函数具有规范的状态且不更改函数外部的其他变量，因此你不需要查看函数定义外的代码。这听起来像你根本不处理状态，那么你怎么可能以这种方式编写专业应用程序呢？好吧，你会改变状态，但以一种非常规范的方式。你会创建另一个实例或指向该实例的另一个指针，但你不会改变该变量的值。拥有不可变性是拥有更好、更快、更正确程序的关键，因为你不需要使用锁，而且你的代码天生就是并行的。
- en: Disciplined state
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范的状态
- en: 'Shared mutable state is evil, because it is much harder to scale and to run
    it concurrently. What is shared mutable state? A simple way to see it is as a
    global variable that all your functions have access to. Why is this bad? First
    of all, because it is hard to keep this state correct since there are many functions
    that have direct access to this state. Second, if you are performing refactoring,
    this kind of code is often the hardest to refactor as well. It''s also hard to
    read this code. This is because you can never trust the local method, since your
    local method is just one part of the program. And with mutable state, you need
    to look up for all the functions that use that variable, in order to understand
    the logic. It''s hard to debug for the very same reason. When you are coding with
    FP principles in mind, you avoid, as much as possible, having a shared mutable
    state. Of course you can have state, but you should keep it local, which means
    inside your function. This is the state discipline: you use state, but in a very
    disciplined way. This is simple, but it could be hard especially if you are a
    professional developer, because this aspect is now usual to see in enterprise
    languages such as Java, .NET, Ruby, and Python.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 共享可变状态是邪恶的，因为它很难扩展和并发运行。什么是共享可变状态？一个简单的方式来理解它就是将其视为一个所有函数都可以访问的全局变量。为什么这很糟糕？首先，因为很难保持这个状态正确，因为有许多函数可以直接访问这个状态。其次，如果你正在进行重构，这种代码通常也是最难重构的。阅读这种代码也很困难。这是因为你永远不能信任局部方法，因为你的局部方法只是程序的一部分。并且带有可变状态，你需要查找所有使用该变量的函数，以便理解逻辑。调试也是如此困难。当你带着FP原则进行编码时，你应尽可能避免共享可变状态。当然，你可以有状态，但你应该将其保持为局部状态，这意味着在函数内部。这就是状态纪律：你使用状态，但以一种非常规范的方式。这很简单，但如果你是一名专业开发者，这可能很难，因为这种方面现在在Java、.NET、Ruby和Python等企业语言中很常见。
- en: Pure functions and no side effects
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数和无副作用
- en: Pure functions are the ones with no side effects. Side effects are bad, because
    they are unpredictable and make your software hard to test. Let's say you have
    a method that receives no parameters and returns nothing--this is one of the worst
    things we could have, because how do you test it? How can you reuse this code?
    This is not what we call a pure function. What are the possible side effects?
    Database call, global variables, IO call, and so on. This makes sense, but you
    cannot have a program with just pure functions, because it won't be practical.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是没有副作用的函数。副作用很糟糕，因为它们是不可预测的，并使你的软件难以测试。假设你有一个没有参数接收且不返回任何内容的方法——这是我们可能遇到的最糟糕的事情之一，因为你怎么测试它？你怎么重用这段代码？这并不是我们所说的纯函数。可能有哪些副作用？数据库调用、全局变量、IO调用等等。这很有道理，但你不能只使用纯函数，因为这样不实用。
- en: First-class functions and higher-order functions
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一等函数和高级函数
- en: First-class means that the language treats functions as first-class citizens.
    In other words, it means having language support to pass functions as arguments
    to other functions and to return values as functions. First-class function also
    implies that the language allows you to store functions as variables or any other
    data structure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首类意味着语言将函数视为一等公民。换句话说，这意味着语言支持将函数作为参数传递给其他函数，并将值作为函数返回。首类函数还意味着语言允许你将函数存储为变量或任何其他数据结构。
- en: Higher-order functions are related to First-class functions, but they are not
    the same thing. Higher-order functions often means language support for partial
    functional application and Currying. Higher-order functions are a mathematical
    concept where functions operate with other functions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数与首类函数相关，但它们不是同一回事。高阶函数通常意味着语言支持部分函数应用和柯里化。高阶函数是一个数学概念，其中函数与其他函数一起操作。
- en: Partial functions are when you can fix a value (argument) to a particular function,
    which you may or may not change later on. This is great for function composition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数是指你可以将一个值（参数）固定到特定的函数上，你以后可能改变也可能不改变。这对于函数组合来说很棒。
- en: Currying is a technique to transform a function with multiple parameters in
    a sequence of functions with each function having a single argument. Scala language
    does not force currying, however, languages like ML and Haskell almost always
    use this kind of technique.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是一种将具有多个参数的函数转换为一系列函数的技术，每个函数只有一个参数。Scala语言并不强制使用柯里化，然而，像ML和Haskell这样的语言几乎总是使用这种技术。
- en: Type systems
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型系统
- en: 'Type system is all about the compiler. The idea is simple: you create a type
    system, and by doing so, you leverage the compiler to avoid all kinds of mistakes
    and errors. This is because the compiler helps in making sure that you only have
    the right types as arguments, turn statements, function composition, and so on.
    The compiler will not allow you do make any basic mistakes. Scala and Haskell
    are examples of languages that are Strong-type. Meanwhile, Common Lisp, Scheme,
    and Clojure are dynamic languages that may accept wrong values during compilation
    time. One of the biggest benefits of the strong type system is that you have to
    write fewer tests, because the compiler will take care of several issues for you.
    For instance, if you have a function that receives a string, it could be dangerous,
    because you can pass pretty much anything in a string. However, if you have a
    function that receives a type called salesman, then you don''t write a validation
    to check if it is a salesman. All this may sound silly, but in a real application,
    this saves lots of lines of code and makes you program better. Another great benefit
    of strong typing is that you have better documentation, as your code becomes your
    documentation, and it''s way more clear what you can or can''t do.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统完全关乎编译器。其理念很简单：你创建一个类型系统，通过这样做，你可以利用编译器来避免各种错误和错误。这是因为编译器有助于确保你只有正确的类型作为参数、转换语句、函数组合等等。编译器不会允许你犯任何基本错误。Scala和Haskell是强类型语言的例子。与此同时，Common
    Lisp、Scheme和Clojure是动态语言，它们可能在编译时接受错误值。强类型系统最大的好处之一是你必须编写的测试更少，因为编译器会为你处理几个问题。例如，如果你有一个接收字符串的函数，这可能很危险，因为你可以几乎在字符串中传递任何东西。然而，如果你有一个接收名为salesman类型的函数，那么你不需要编写验证来检查它是否是salesman。所有这些可能听起来很愚蠢，但在实际应用中，这可以节省大量的代码并使你的程序编写得更好。强类型的另一个巨大好处是，你将拥有更好的文档，因为你的代码成为你的文档，而且可以更清楚地了解你可以或不能做什么。
- en: Referential transparency
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指称透明性
- en: Referential transparency is a concept which works close with pure functions
    and immutability since your program has fewer assignment statements, and often
    when you have it, you tend to never change that value. This is great because you
    eliminate side effects with this technique. During program execution, any variable
    can be replaced since there are no side effects, and the program becomes referentially
    transparent. Scala language makes this concept very clear the moment you declare
    a variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 指称透明性是一个与纯函数和不可变性紧密相关的概念，因为你的程序有较少的赋值语句，并且当你有它时，你往往永远不会改变那个值。这很好，因为你可以用这种技术消除副作用。在程序执行期间，由于没有副作用，任何变量都可以被替换，程序变得指称透明。Scala语言在声明变量时使这个概念非常清晰。
- en: Installing Java 8 and Scala 2.11
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Java 8和Scala 2.11
- en: Scala requires JVM to work, so we need get the JDK 8 before installing Scala.
    Go to the Oracle website, and download and install JDK 8 from [http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html](http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 需要 JVM 才能运行，因此我们在安装 Scala 之前需要获取 JDK 8。访问 Oracle 网站，并从 [http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html](http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html)
    下载并安装 JDK 8。
- en: 'Once you''ve downloaded Java, we need to add Java to the `PATH` variable; otherwise,
    you can use the terminal. We do this as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 Java 后，我们需要将 Java 添加到 `PATH` 变量中；否则，你可以使用终端。我们这样做如下：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next step is to create the environment variable called `JAVA_HOME`, and
    to put the Java 8 binaries in the `PATH` variable. In Linux, we need to edit the
    `~/.bashrc` file, and export the variables we need, like in the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个名为 `JAVA_HOME` 的环境变量，并将 Java 8 二进制文件放入 `PATH` 变量中。在 Linux 中，我们需要编辑 `~/.bashrc`
    文件，并导出所需的变量，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the file, and then on the same terminal we need to source the file via
    `$ source ~/.bashrc`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，在同一终端中，我们需要通过 `$ source ~/.bashrc` 命令来源文件。
- en: 'Now we can test our Java 8 installation. Just type in `$ java -version`. You
    should see something like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们的 Java 8 安装。只需输入 `$ java -version`。你应该会看到如下类似的内容：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's get started. We will be using the latest Scala version 2.11.8\. However,
    the code inside this book should work with any Scala 2.11.x version. First of
    all, let's download Scala from [http://www.scala-lang.org/](http://www.scala-lang.org/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。我们将使用最新的 Scala 版本 2.11.8。然而，这本书中的代码应该与任何 Scala 2.11.x 版本兼容。首先，让我们从 [http://www.scala-lang.org/](http://www.scala-lang.org/)
    下载 Scala。
- en: Scala works on Windows, Mac, and Linux. For this book, I will show how to use
    Scala on Ubuntu Linux(Debian-based). Open your browser and go to [http://www.scala-lang.org/download/](http://www.scala-lang.org/download/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 在 Windows、Mac 和 Linux 上都能运行。对于这本书，我将展示如何在基于 Debian 的 Ubuntu Linux 上使用
    Scala。打开你的浏览器并访问 [http://www.scala-lang.org/download/](http://www.scala-lang.org/download/)。
- en: 'Download `scala 2.11.8`: it will be a TGZ file. Extract it and add it to your
    path; otherwise, you can use the terminal. Do this as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 `scala 2.11.8`：它将是一个 TGZ 文件。解压它并将其添加到你的路径中；否则，你可以使用终端。这样做如下：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next step is to create the environment variable called `SCALA_HOME`, and
    to put the Scala binaries in the `PATH` variable. In Linux, we need to edit the
    `~/.bashrc` file and export the variables we need, like in the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个名为 `SCALA_HOME` 的环境变量，并将 Scala 二进制文件放入 `PATH` 变量中。在 Linux 中，我们需要编辑 `~/.bashrc`
    文件并导出所需的变量，如下所示：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save the file, and then, on the same terminal, we need to source the file via
    `$ source ~/.bashrc`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，在同一终端中，我们需要通过 `$ source ~/.bashrc` 命令来源文件。
- en: 'Now we can test our Scala installation. Just type in `$ scala -version`. You
    should see something like the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们的 Scala 安装。只需输入 `$ scala -version`。你应该会看到如下类似的内容：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You have successfully installed Java 8 and Scala 2.11\. Now we are ready to
    start learning the FP principles in Scala. For this, we will be using the Scala
    REPL in the beginning. Scala REPL is bundled with the default Scala installation,
    and you just need to type `$ scala` in your terminal as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功安装了 Java 8 和 Scala 2.11。现在我们准备好开始学习 Scala 中的 FP 原则了。为此，我们将在开始时使用 Scala
    REPL。Scala REPL 是默认 Scala 安装的一部分，你只需在终端中输入 `$ scala`，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Congratulations! You have installed Java 8 and Scala 2.11 successfully.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经成功安装了 Java 8 和 Scala 2.11。
- en: Read Eval Print and Loop - REPL
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取、评估、打印和循环 - REPL
- en: '**Read Eval Print and Loop** (**REPL**) is also know as a language shell. Many
    other languages have shells, like Lisp, Python, and Ruby for instance. The REPL
    is a simple environment to experiment the language in. It''s possible to write
    very complex programs using REPL, but this is not the REPL goal. Using REPL does
    not invalidate the usage of an IDE like Eclipse or IntelliJ IDEA. REPL is ideal
    for testing simple commands and programs without having to spend much time configuring
    projects like you do with an IDE. The Scala REPL allows you to create a variable,
    functions, classes, and complex functions as well. There is a history of every
    command you perform; there is some level of autocomplete too. As a REPL user,
    you can print variable values and call functions.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取评估打印循环**（**REPL**）也被称为语言外壳。许多其他语言都有外壳，例如 Lisp、Python 和 Ruby 等。REPL 是一个简单的环境，可以用来实验语言。使用
    REPL 可以编写非常复杂的程序，但这不是 REPL 的目标。使用 REPL 并不影响像 Eclipse 或 IntelliJ IDEA 这样的 IDE 的使用。REPL
    是测试简单命令和程序的理想选择，无需像使用 IDE 那样花费大量时间配置项目。Scala REPL 允许你创建变量、函数、类以及复杂的函数。每个命令都有一个历史记录；也有一定程度的自动完成。作为一个
    REPL 用户，你可以打印变量值并调用函数。'
- en: Scala Hello World using the REPL
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REPL 的 Scala Hello World
- en: 'Let''s get started. Go ahead, open your terminal, and type `$ scala` in order
    to open the Scala REPL. Once the REPL is open, you can just type `"Hello World"`.
    By doing this, you perform two operations: eval and print. The Scala REPL will
    create a variable called `res0`, and store your String there. Then it will print
    the content of the `res0` variable.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。打开你的终端，输入 `$ scala` 以打开 Scala REPL。一旦 REPL 打开，你只需输入 `"Hello World"`。通过这样做，你执行了两个操作：评估和打印。Scala
    REPL 将创建一个名为 `res0` 的变量，并将你的字符串存储在那里。然后它将打印 `res0` 变量的内容。
- en: Scala REPL Hello World program
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL Hello World 程序
- en: 'We will see how to create Hello World program in Scala REPL as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在 Scala REPL 中创建 Hello World 程序，如下所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Scala is a hybrid language, which means it is object-oriented and functional
    as well. You can create classes and objects in Scala. Next we will create a complete
    Hello World application using classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是一种混合语言，这意味着它既是面向对象的，也是函数式的。你可以在 Scala 中创建类和对象。接下来我们将使用类创建一个完整的 Hello
    World 应用程序。
- en: Scala object-oriented HelloWorld program
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala 面向对象的 Hello World 程序
- en: 'We will see how to create object-oriented HelloWorld program in Scala REPL
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在 Scala REPL 中创建面向对象的 Hello World 程序，如下所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing you need to realize is that we use the word object instead of
    class. The Scala language has different constructs compared to Java. Object is
    a singleton in Scala. It's the same as coding the singleton pattern in Java.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先你需要意识到，我们使用的是 object 而不是 class。与 Java 相比，Scala 语言有不同的结构。在 Scala 中，Object 是一个单例。这与在
    Java 中编写单例模式相同。
- en: 'Next we see the word `def` that is used in Scala to create functions. In the
    preceding program, we create the main function similar to the way we do it in
    Java, and we call the built-in function `println` in order to print the String
    Hello World. Scala imports some Java objects and packages by default. Coding in
    Scala does not require you to type, for instance, `System.out.println("Hello World")`,
    but you can if you want. Let''s take a look at it in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看到 Scala 中用于创建函数的 `def` 关键字。在前面的程序中，我们创建了一个类似于 Java 中创建的方式的 main 函数，并调用内置函数
    `println` 来打印字符串 Hello World。Scala 默认导入了一些 Java 对象和包。在 Scala 中编码不需要你输入，例如，`System.out.println("Hello
    World")`，但如果你愿意，你也可以这样做。让我们在下面的代码中看看它：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can and we will do better. Scala has some abstractions for a console application,
    so we can write this code with a lesser number of lines of code. To accomplish
    this goal, we need to extend the Scala class App. When we extend from App, we
    perform inheritance and we don't need to define the main function. We can just
    put all the code in the body of the class, which is very convenient and makes
    the code clean and simple to read.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以，我们也将做得更好。Scala 为控制台应用程序提供了一些抽象，因此我们可以用更少的代码行数来编写这个代码。为了实现这个目标，我们需要扩展 Scala
    类 App。当我们从 App 继承时，我们执行了继承，我们不需要定义 main 函数。我们只需将所有代码放入类的主体中，这非常方便，使得代码整洁且易于阅读。
- en: Scala HelloWorld App in the Scala REPL
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的 Scala HelloWorld App
- en: 'We will see how to create Scala HelloWorld App in Scala REPL as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在 Scala REPL 中创建 Scala HelloWorld App，如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After coding the HelloWorld object in the Scala REPL we can ask the REPL what
    HelloWorld is, and as you might realize, the REPL will answer that HelloWorld
    is an object. This is a very convenient Scala way to code console applications,
    because we can have a Hello World application with just three lines of code. Sadly,
    to have the same program in Java, it required way more code. Java is a great language
    for performance, but it is a verbose language compared with Scala, for instance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala REPL中编码了HelloWorld对象之后，我们可以询问REPL HelloWorld是什么，正如你可能意识到的，REPL会回答HelloWorld是一个对象。这是Scala编写控制台应用程序的一种非常方便的方法，因为我们只需三行代码就可以有一个Hello
    World应用程序。遗憾的是，要在Java中实现相同的程序，需要更多的代码。Java是一种性能出色的语言，但与Scala相比，它是一种冗长的语言。
- en: Java HelloWorld application
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java HelloWorld应用程序
- en: 'We will see how to create Java HelloWorld application as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何创建Java HelloWorld应用程序如下：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Java app required six lines of code, while in Scala, we were able to do
    the same with 50% less code (three lines of code). This is a very simple application.
    When we are coding complex applications, this difference gets bigger, as a Scala
    application ends up with way less code than Java.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序需要六行代码，而在Scala中，我们能够用50%的代码（三行代码）完成同样的工作。这是一个非常简单的应用程序。当我们编写复杂的应用程序时，这种差异会更大，因为Scala应用程序的代码量远少于Java。
- en: 'Remember, we use an object in Scala in order to have a Singleton (Design Pattern
    that makes sure you have just one instance of a class), and if we want the same
    in Java, the code would be something like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在Scala中使用对象是为了有一个单例（确保只有一个类实例的设计模式），如果我们想在Java中实现相同的功能，代码可能如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's not just about the size of the code, but also about consistency and the
    language providing more abstractions for you. If you write less code, you will
    have fewer bugs in your software at the end of the day.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅关乎代码的大小，还关乎一致性和语言为你提供更多的抽象。如果你编写的代码更少，最终你的软件中出现的错误也会更少。
- en: Scala language - the basics
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala语言 - 基础知识
- en: Scala is a statically typed language with a very expressive type system which
    enforces abstractions in a safe yet coherent manner. All values in Scala are Java
    objects (primitives which are unboxed at runtime), because at the end of the day,
    Scala runs on the Java JVM. Scala enforces immutability as a core FP principle.
    This enforcement happens in multiple aspects of the Scala language, for instance,
    when you create a variable, you do it in an immutable way, when you use an collection,
    you will use a immutable collection. Scala also lets you use mutable variables
    and mutable structures, but by design, it favors immutable ones.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是一种静态类型语言，具有非常表达性的类型系统，以安全且连贯的方式强制执行抽象。Scala中的所有值都是Java对象（在运行时未装箱的原生类型），因为最终，Scala是在Java
    JVM上运行的。Scala强制执行不可变性作为核心的FP原则。这种强制执行在Scala语言的多个方面发生，例如，当你创建一个变量时，你以不可变的方式创建它，当你使用集合时，你会使用不可变集合。Scala还允许你使用可变变量和可变结构，但按照设计，它更倾向于不可变结构。
- en: Scala variables - var and val
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala变量 - var和val
- en: When you are coding in Scala, you create variables using the operator `var`,
    or you can use the operator `val`. The operator `var` allows you to create a mutable
    state, which is fine as long as you make it local, follow the CORE-FP principles
    and avoid a mutable shared state.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Scala中编码时，你使用运算符`var`创建变量，或者你可以使用运算符`val`。`var`运算符允许你创建可变状态，只要你将其本地化，遵循CORE-FP原则，并避免可变共享状态，这是可以的。
- en: Scala REPL var usage
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的var使用
- en: 'We will see how to use var in Scala REPL as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用var如下：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, Scala has a more interesting construct called `val`. Using the `val`
    operator makes your variables immutable, and this means you can't change the value
    once you've set it. If you try to change the value of the `val` variable in Scala,
    the compiler will give you an error. As a Scala developer, you should use the
    variable `val` as much as possible, because that's a good FP mindset, and it will
    make your programs better. In Scala, everything is an object; there are no primitives
    -- the `var` and `val` rules apply for everything it could but an `Int` or `String`
    or even a class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Scala有一个更有趣的结构叫做`val`。使用`val`运算符使你的变量不可变，这意味着一旦设置了值，就不能更改它。如果你尝试更改Scala中`val`变量的值，编译器会给你一个错误。作为一个Scala开发者，你应该尽可能多地使用`val`变量，因为这是一种良好的FP思维模式，并且会使你的程序更好。在Scala中，一切都是对象；没有原生类型
    -- `var`和`val`规则适用于所有可能的对象，除了`Int`或`String`甚至是一个类。
- en: Scala val usage at the Scala REPL
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala在Scala REPL中的val使用
- en: 'We will see how to use val in Scala REPL as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用`val`，如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating immutable variables
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建不可变变量
- en: Right now, let's see how we define the most common types in Scala such as `Int`,
    `Double`, `Boolean`, and `String`. Remember, you can create these variables using
    `val` or `var` depending on your needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Scala中定义最常见的数据类型，如`Int`、`Double`、`Boolean`和`String`。记住，你可以根据需要使用`val`或`var`创建这些变量。
- en: Scala variable type in the Scala REPL
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的Scala变量类型
- en: 'We will see Scala variable type in Scala REPL as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中查看Scala变量类型，如下所示：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the variables in the preceding code, we did not define the type. Scala language
    figures it out for us. However, it is possible to specify the type if you want.
    In Scala, the type comes after the name of the variable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们没有定义变量的类型。Scala语言会为我们解决这个问题。然而，如果你想指定类型，也是可能的。在Scala中，类型位于变量名称之后。
- en: Scala variables with explicit typing at the Scala REPL
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的具有显式类型的Scala变量
- en: 'We will see Scala variables with explicit typing at Scala REPL as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Scala REPL中看到具有显式类型的Scala变量，如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Scala conditional and loops statements
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala的条件和循环语句
- en: Like any other language, Scala has support for conditional statements like `if`
    and `else`. While Java has a switch statement, Scala has a more powerful and functional
    structure called Pattern Matcher, which we will cover later in this chapter. Scala
    allows you to use `if` statements during variable assignments, which is very practical
    as well as useful.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他语言一样，Scala支持`if`和`else`这样的条件语句。虽然Java有`switch`语句，但Scala有一个更强大且功能性的结构，称为模式匹配器（Pattern
    Matcher），我们将在本章后面介绍。Scala允许你在变量赋值时使用`if`语句，这既实用又有用。
- en: If statements in Scala REPL
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Scala REPL中的if语句
- en: 'We will see how to use `if` statements in Scala REPL as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用`if`语句，如下所示：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, you can see that we set the variable `y` based on an
    `if` condition. Scala `if` conditions are very powerful, and they also can be
    used in return statements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到我们根据`if`条件设置了变量`y`。Scala的`if`条件非常强大，并且也可以用于返回语句。
- en: If statements in return statements in Scala REPL
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Scala REPL中的返回语句中的if语句
- en: 'We will see how to use `if` statements in return statements in Scala REPL as
    follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中的返回语句中使用`if`语句，如下所示：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Scala supports `else` statements too, and you also can use them in variables
    and return statements as wellas follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Scala也支持`else`语句，你还可以在变量和返回语句中使用它们，如下所示：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now you will learn how to use for loops in Scala. For loops are very powerful
    in Scala. We will start with the basics and later we will move on to functional
    loops used for comprehensions, also know as `List` comprehensions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将学习如何在Scala中使用for循环。在Scala中，for循环非常强大。我们将从基础知识开始，稍后我们将继续介绍用于列表推导的函数式循环，也称为`List`推导。
- en: In Scala, for loops work with ranges, which is another Scala data structure
    that represents numbers from a starting point to an end point. The range is created
    using the left arrow operator(`<-`). Scala allows you to have multiple ranges
    in the same for loop as long as you use the semicolon(`;`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，for循环与范围（range）一起工作，范围是Scala的另一种数据结构，表示从起点到终点的数字。范围是通过左箭头运算符（`<-`）创建的。只要你在同一个for循环中使用分号（`;`），Scala就允许你在同一个for循环中有多个范围。
- en: You also can use `if` statements in order to filter data inside for loops, and
    work smoothly with `List` structures. Scala allows you to create variables inside
    a for loop as well. Right now, let's see some code which illustrates the various
    for loop usages in Scala language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在for循环中使用`if`语句来过滤数据，并顺畅地与`List`结构一起工作。Scala允许你在for循环中创建变量。现在，让我们看看一些代码，这些代码展示了Scala语言中各种for循环的使用。
- en: Basic for loop in Scala REPL
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的基本for循环
- en: 'We will see how to use basic for loop in Scala REPL as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用基本for循环，如下所示：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Right now, we will create a for loop using a Scala data structure called `List`.
    This is very useful, because in the first line of code, you can define a `List`
    as well as set its values in the same line. Since we are using the `List` structure,
    you don't need to pass any other argument besides the `List` itself.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用名为`List`的Scala数据结构创建一个for循环。这非常有用，因为在代码的第一行，你可以定义一个`List`以及设置其值。由于我们使用的是`List`结构，因此除了`List`本身之外，你不需要传递任何其他参数。
- en: For with List in Scala REPL
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Scala REPL中使用带有List的for循环
- en: 'We will see how to `use` for with `List` in Scala REPL as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用`for`与`List`，如下所示：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we can use for loops with `if` statements in order to apply some filtering.
    Later in this book, we will approach a more functional way to approach filtering
    using functions. For this code, let's say we want to get just the even numbers
    on the list and print them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: For with if statements for filtering - Scala REPL
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use `for` with `if` statements in Scala REPL as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Java code for filtering even numbers
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Scala language, we just need two lines of code to perform this filtering,
    whereas in Java it would have required at least eleven lines of code as you see
    in the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For comprehensions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Also known as list or sequence comprehensions, for comprehensions are one of
    the FP ways to perform loops. This is a language support to create `List` structure
    or collections based on other collections. This task is performed in a `SetBuilder`
    notation. Another way to accomplish the same goal would be by using the `Map`
    and `filter` functions, which we will cover later in this chapter. For comprehensions
    can be used in a generator form, which would introduce new variables and values,
    or in a reductionist way, which would filter values resulting into a new collection
    or sequence. The syntax is: `for (expt) yield e`, where the `yield` operator will
    add new values to a new collection/sequence that will be created from the original
    sequence.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: For comprehension in Scala REPL
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use `for` comprehension in Scala REPL as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we create a set of names. As you can see, Scala, by default,
    prefers immutable data structures and uses `immutable.Set`. When we apply the
    `for` loop, we are simply filtering only the `names` which contain a specific
    substring, and then, using the `yield` operator, we are creating a new `Set` structure.
    The `yield` operator will keep the structure you are using. For instance, if we
    use `List` structure, it would create a `List` instead of a `Set structure`, the
    `yield` operator will always keep the same data collection you have on the variable.
    Another interesting aspect of the preceding code is the fact that we are holding
    the result of the `for` comprehension in a variable called Brazilians. Java does
    not have `for` comprehensions, but we could use similar code although it would
    require way more lines of code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Java code for performing filtering with collections
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use Java code for performing filtering with collections as
    follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Scala collections
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to create the `List` and `Set` structures
    in Scala in an immutable way. Now we will learn to work with the `List` and `Set`
    structures in a mutable way, and also with other collections such as sequences,
    tuples, and Maps. Let''s take a look at the Scala collections hierarchy tree,
    as shown in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Scala collections](img/image00231.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Now let's take a look at the Scala Seq class hierarchy. As you can see, Seq
    is traversable as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Scala collections](img/image00232.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Scala collections extend from traversable, which is the main trait of all collection's
    descends. `List` structures, for instance, extend from Seq class hierarchy, which
    means sequence - `List` is a kind of sequence. All these trees are immutable or
    mutable depending on the Scala package you end up using.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to perform basic mutable operations with `List` structures in
    Scala. In order to have filter and removal operations, we need use a `Buffer` sequence as
    follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's see the next set of code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Creating, removing, and getting an item from a mutable list in Scala REPL
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to create, remove, and get an item from a mutable list in Scala
    REPL as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Have you ever wanted to return multiple values in a method? Well, in Java you
    have to create a class, but in Scala, there is a more convenient way to perform
    this task, and you won't need to create new classes each time. Tuples allow you
    to return or simply hold multiple values in methods without having to create a
    specific type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Scala tuples
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Scala tuples as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Scala has special methods called `_1` and `_2` which you can use to retrieve
    a tuple's values. The only thing you have to keep in mind is the fact that values
    are kept in the order of insertion in the tuple.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Scala has a very practical and useful collection library. A Map, for instance,
    is a key/value pair that can be retrieved based on the key, which is unique. However,
    Map values do not need to be unique. Like other Scala collections, you have mutable
    and immutable Map collections. Keep in mind that Scala favors immutable collections
    over mutable ones.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Scala immutable Map in Scala REPL
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Scala immutable Map in Scala REPL as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, Scala uses `scala.collection.immutable.Map` when you create
    a Map using `Map()`. Both keys and values are iterable, and you can have access
    to all the keys with the `keys` method or to all the values using the `values`
    method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Scala mutable Maps at Scala REPL
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Scala mutable Map in Scala REPL as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you are dealing with mutable state, you have to be explicit and this is great
    in Scala, because it increases developers' awareness and avoids mutable shared
    state by default. So, in order to have a mutable Map, we need to explicitly create
    the Map with `scala.collection.mutable.HashMap`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monads are combinable parametrized container types which have support for higher-order
    functions. Remember higher-order functions are functions which receive functions
    as parameters and return functions as results. One of the most used functions
    in FP is Map. Map takes a function, applies it to each element in the container,
    and returns a new container.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Scala Map function in Scala REPL
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Map function in Scala REPL as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we created a list of numbers containing 1,2,3,4,5, and
    6\. We also defined a Scala function called `doubleIt`, which receives an integer
    and multiplies it by `2.0` resulting in a double number. The `map` function calls
    `doubleIt` for each element in the `List (1,2,3,4,5,6)`, and the result is a new
    container, a brand new `List` instance containing the new values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Scala has some syntactical sugar which helps us to be more productive. For instance,
    you may realize that in the previous code, we also did - `2.0 * _`. The underscore
    is a special operator for this specific case -- it means the current value is
    being iterated into the collection. Scala will create a function from this expression
    for us.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have realized, `map` functions are pretty useful for lots of reasons:
    one reason is that you can do complex computations without using the `for` loop
    explicitly, and this makes your code functional. Secondly, we can use a `map`
    function to convert element types from one type to another. That''s what we did
    in the previous code: we transformed a list of integers into a list of doubles. Look
    at the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `map` function operates over several data structures and not only collections,
    as you can see in the previous code. You can use the `map` function on pretty
    much everything in Scala language.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function is great, but you can end up with nested structures. That's
    why, when we are working with Monads, we use a slightly different version of the
    `map` function called `flatMap`, which works in a very similar way to the `map`
    function, but returns the values in a flat form instead of nested values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a monad, you need to have a method called `flatMap`. Other
    function languages such as Haskell call `flatMap` as `bind`, and use the operator
    `>>=`. The syntax changes with the language, but the concept is the same.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Monads can be built in different ways. In Scala, we need a single argument constructor
    which will work as a monad factory. Basically, the constructor receives one type,
    `A`, and returns `Monad[A]` or just `M[A]`. For instance, `unit(A)` for a `List`
    will be `== List[A]` and `unit(A)`, where a is an Option `== Option[A]`. In Scala,
    you don't need to have unit; this is optional. To have a monad in Scala, you need
    to have map and `flatMap` implemented.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with Monads will make you write a little bit more code than before.
    However, you will get a way better API, which will be easier to reuse and your
    potential complexity will be managed, because you won''t need to write a complex
    code full of `if` and for loops. The possibilities are expressed through the types,
    and the compiler can check it for you. Let us see a simple monad example in Scala
    language:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Option Monad in Scala
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see option Monad in Scala as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In Haskell, this also known as the Maybe monad. Option means optional value,
    because we are not 100% sure if the value will be present. In order to express
    a value, we use the `Some` type, and in order to express the lack of value, we
    use none. Option Monads are great, they make your code more explicit, because
    a method might receive or return an option, which means you are explicitly saying
    this could be null. However, this technique is not only more expressive but also
    safer, since you won't get a null pointer, because you have a container around
    the value. Although, if you call the method `get` in `Option` and it is none,
    you will get a `NoSuchelementException`. In order to fix this, you can use the
    method `getOrElse`, and you can supply a fallback value which will be used in
    the case of none. Alright, but you might be wondering where the `flatMap` method
    is. Don't worry, Scala implements this method for us into the `Option` abstraction,
    so you can  use it with no issues.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The Scala REPL can perform autocomplete for you. If you type **C** + **Tab**,
    you will see all the available methods for the `Some` class. The `map` function
    is available for you to use, and as I said before, there is no unit function in
    Scala whatsoever. However, it is not wrong if you add in your APIs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: A list of all methods using the Scala REPL
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the list of all methods using the Scala REPL:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Scala class, traits, and OO programming
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a hybrid post-functional language, Scala allows you to write OO code and
    create classes as well. Right now we will learn how to create classes and functions
    inside classes, and also how to work with traits, which are similar to Java interfaces
    in concept but way more powerful in practice.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: A simple Scala class in Scala REPL
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see a simple Scala class in Scala REPL as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At first glance, the preceding code looks like Java. But let's add constructors,
    getters, and setters, and then you can see how much we can accomplish with just
    a few lines of code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Scala plain old Java object in Scala REPL
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala plain old Java object in Scala REPL:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Constructors in Scala are just lines of code. You might realize that we get
    the `name` variable, and apply a function to change the given name to upper case
    in the preceding example. If you want, you can put as many lines as you want,
    and you can perform as many computations as you wish.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: On this same code, we perform method overriding as well, because we override
    the `toString` method. In Scala, in order to do an override, you need to use the
    `override` operator in front of the function definition.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We just wrote a **Plain Old Java Object** (**POJO**) with very few lines of
    code in Scala. Scala has a special annotation called `@scala.beans.BeanProperty`,
    which generates the getter and setter method for you. This is very useful, and
    saves lots of lines of code. However, the target needs to be public; you can't
    a apply `BeanProperty` annotation on top of a private `var` or `val` object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Person class in Java
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Person class in Java:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Traits and inheritance
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible to do inheritance in Scala as well. For such a task, you use the
    operator `extend` after the class definition. Scala just allows you to extend
    one class, just like Java. Java does not allow multiple inheritance like C++.
    However, Scala allows it by using the Mixing technique with traits. Scala traits
    are like Java interface, but you can also add concrete code, and you are allowed
    to have as many traits as you want in your code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Scala inheritance code in Scala REPL
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala inheritance code in Scala REPL:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Scala does not make constructors inheritance like Java. So you need to rewrite
    the constructors and pass the values through a super class. All code inside the
    class will be the secondary constructor. All code inside parentheses `()` in the
    class definition will be the primary constructor. It's possible to have multiple
    constructors using the `this` operator. For this particular implementation, we
    changed the default behavior and added new constructor code in order to make the
    given name lower case, instead of the default uppercase defined by the `Person`
    superclass.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Scala traits sample code in Scala REPL
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala traits sample code in Scala REPL:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, we created multiple traits. One is called Car, which
    is the mother trait. Traits support inheritance as well, and we have it with the
    `SportCar` trait which extends from the `Car` trait. The `SportCar` trait demands
    a variable called brand, and defines a concrete implementation of the function
    run. Finally, we have a class called `BMW` which extends from multiple traits
    -- this technique is called **mixing.**
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Scala traits using variable mixing technique at Scala REPL
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala traits using variable mixing technique at Scala REPL:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Scala is a very powerful language indeed. It's possible to add traits to a variable
    at runtime. When you define a variable, you can use the `with` operator after
    the assignment. This is a very useful feature, because it makes it easier to make
    function composition. You can have multiple specialized traits and just add them
    in your variables as you need them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Scala allows you to create the `type` alias as well, this is a very simple technique
    which will increase the readability of your code. It's just a simple alias.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Scala type alias sample in Scala REPL
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala type alias sample in Scala REPL:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When you are coding with Scala, it is highly recommended that you use the `type`
    alias and traits for everything, because that way you will get more advantages
    with your compiler, and you will avoid writing unnecessary code and unnecessary
    unit tests.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Case classes
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not done yet in terms of the OO features in Scala; there is another
    very interesting way to work with classes in Scala: the so-called case classes.
    Case classes are great because you can have a class with way less number of lines
    of code and case classes can be part of a Pattern Matcher.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Scala case classes feature in Scala REPL
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala case classes feature in Scala REPL:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is the Scala way to work with classes. Because this is so much easier and
    compact, you pretty much create a class with one line of code, and you can have
    the `equals` and `hashcode` methods for free.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Pattern Matcher
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you code in Java, you can use a Switch statement. However, in Scala, we
    have a more powerful feature called Pattern Matcher, which is a kind of switch
    but on steroids.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Simple Pattern Matcher in Scala
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Simple Pattern Matcher in Scala:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Scala uses Pattern Matcher for error handling. Java does not have Pattern Matcher
    like Scala. It's similar to a switch statement; however, Pattern Matcher can be
    used in a method return statement as you can see in the preceding code. Scala
    developers can specify a special operator called `_` (Underscore), which allows
    you to specify anything in the Pattern Matcher scope. This behavior is similar
    to `else` in an `if` conditional. However, in Scala, you can use `_` in several
    places, and not only as the otherwise clause, like in Java switch.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in Scala is similar to error handling in Java. We use try...catch
    blocks. The main difference is that you have to use Pattern Matcher in Scala,
    which is great because it adds more flexibility to your code. Pattern Matcher
    in Scala can operate against many data structures like case classes, collections,
    integers, and strings.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is pretty simple and straightforward. Next we will see a
    more complex and advanced code using the Scala Pattern Matcher feature.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Advanced pattern matcher in Scala REPL
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an Advanced Pattern Matcher using Scala REPL:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Pattern Matcher can be used in a very functional way. For instance, in the preceding
    code, we use the Pattern Matcher for recursion. There is no need to create a variable
    to store the result, we can put the Pattern Matcher straight to the function return,
    which is very convenient and saves lots of lines of code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Advanced complex pattern matcher in Scala REPL
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an Advanced complex Pattern Matcher using Scala REPL:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The Scala Pattern Matcher is really amazing. We just used an `if` statement
    in the middle of the Pattern Matcher, and also `_` to specify a match for any
    kind of red value. We also used case classes in the middle of the Pattern Matcher
    expressions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partial functions are great for function composition. They can operate with
    case statements as we just learned from Pattern Matcher. Partial functions are
    great in the sense of function composition. They allow us to define a function
    in steps. Scala frameworks and libraries use this feature a lot to create abstractions
    and callback mechanisms. It's also possible to check if a partial function is
    being supplied or not.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions are predictable, because the caller can check beforehand if
    the value will be applied to the partial function or not. Partial function can
    be coded with or without case-like statements.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Simple Partial function in Scala REPL
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a simple Partial function using Scala REPL:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Partial functions are Scala classes. They have some methods you need to provide,
    for instance, `apply` and `isDefinedAt`. The function `isDefinedAt` is used by
    the caller to check if the `PartialFunction` will accept and operate with the
    value supplied. The `apply` function will do the work when the `PartialFunction`
    is executed by Scala.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Scala PartialFunction without OO using case statements in Scala REPL
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala PartialFunction without OO using case statements in Scala
    REPL:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Scala was a more fluent way to work with `PartialFunction` using the `case`
    statements. When you use the `case` statements, you don't need to supply the `apply`
    and `isDefinedAt` functions, since the Pattern Matcher takes care of that.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: PartialFunction composition in Scala REPL
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a PartialFunction composition in Scala REPL:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Scala allows us to compose as many `PartialFunctions` as we want. `PartialFunction`
    composition happens with the `orElse` function. In the preceding code, we defined
    an immutable variable called `even`, which verifies even numbers. Secondly, we
    created a second immutable variable called `odd`, which checks for odd numbers.
    Then we did the composition, and created a third `PartialFunction` called `evenOrOdd`
    with compose even and odd using the `orElse` operator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Package objects
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala has packages like Java. However, Scala packages are also objects, and
    you can have code inside a package. Java does not have the same power as Scala
    in terms of packages. If you add code to a package, it will be available to all
    classes and functions within that package.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: package.scala
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your `package.scala` file should contain the following code
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is the Scala package object. There is this special token called `package`
    object which you use to define common code to all classes, objects, and functions
    that are defined inside this package or sub-package. For this case, we define
    a value of PI as a constant and also one object holder containing the String values
    for `Odd` and `Even`. There are also three helper functions, which can and will
    be used by the classes inside this package.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: MainApp.scala
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your `MainApp.scala` file should contain the following code
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see in the preceding code, this new object is placed in the package:
    `com.packait.scala.book.commons`. Another interesting thing is the fact that we
    don''t have any import statement here because of the `package` object feature.
    When you compile and run this program, you will see the following output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Scala uses the `Package` object a great deal providing lots of shortcuts and
    convenience for all Scala developers. The following is the Scala `package` object
    definition:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Functions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any great FP language, Scala has lots of built-in functions. These functions
    make our code more fluent and functional; now it''s time to learn some of these
    functions:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Partial application
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala, the underscore(`_`) means different things in different contexts.
    The underscore can be used to partially apply a function. It means a value will
    be supplied later. This feature is useful for function composition and allows
    you to reuse functions. Let's see some code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Partial function in Scala REPL
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an example using Partial function in Scala REPL:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, first, we define a function called `sum`, which takes
    two `Int` parameters and calculates a sum of these two parameters. Later, we define
    a function and hold it as a variable called `add6`. For the `add6` function definition,
    we just call the sum function passing `6` and `_`. Scala will get the parameter
    passed through `add6`, and pass it through the `sum` function.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Curried functions
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This feature is very popular in function languages like Haskell. Curried functions
    are similar to partial applications, because they allow some arguments to pass now
    and others later. However, they are a little bit different.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Curried functions - Scala REPL
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an example using curried function in Scala REPL:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For the preceding code, we create a curried function in the function definition.
    Scala allows us to transform regular/normal functions into curried functions.
    The following code shows the usage of the `curried` function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Curried transformation in Scala REPL
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an example using curried transformation in Scala REPL:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Operator overloading
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like C++, Scala permits operator overload. This feature is great for creating
    custom **Domain Specific Languages** (**DSL**), which can be useful to create
    better software abstractions or even internal or external APIs for developers,
    or for business people. You should use this feature with wisdom -- imagine if all
    frameworks decide to overload the same operators with implicits! You might run
    into trouble. Scala is a very flexible language compared to Java. However, you
    need to be careful, otherwise you could create code that's hard to maintain or
    even incompatible with other Scala applications, libraries, or functions.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Scala operator overloading in Scala REPL
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an example using Scala operator overloading in Scala REPL:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, we have two functions called `+`. One of this functions receives
    a `MyNumber` case class, and the other receives a `Int` value. You can use OO
    in Scala with regular classes and functions as well if you wish. We're also favoring
    immutability here because we always create a new instance of `MyNumber` when the
    operation `+` happens.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Implicits
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implicits allow you to do magic in Scala. With great power comes great responsibility.
    Implicits allow to you create very powerful DSL, but they also allow you to get
    crazy, so do it with wisdom. You are allowed to have implicit functions, classes,
    and objects. The Scala language and other core frameworks from the Scala ecosystem
    like Akka and PlayFramework use implicits many times.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Scala Implicits in SCALA REPL
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: To use implicits, you need to use the keyword `implicit` before a function.
    Scala will implicitly call that function when it is appropriate. For this case,
    it will call to convert the `String` type to `Int` type as we can see.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Parameter at Scala REPL
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For this other case, given in the last code, we use an implicit parameter in
    the function `sum`. We also used a curried function here. We defined the `implicit`
    function first, and then called the `sum` function. This technique is good for
    externalized functions configuration and values you would let it hard code. It
    also saves lines of code, because you don't need to pass a parameter to all functions
    all the time, so it's quite handy.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Futures
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Futures enable an efficient way to write parallel operations in a nonblocking
    IO fashion. Futures are placeholder objects for values that might not exist yet.
    Futures are composable, and they work with callbacks instead of traditional blocking
    code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Simple Future code in Scala REPL
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In order to work with futures in Scala, we have to import `concurrent.Future`.
    We also need an executor, which is a way to work with threads. Scala has a default
    set of execution services. You can tweak it if you like, however, for now we can
    just use the defaults; to do that, we just import `concurrent.ExecutionContext.Implicits.global`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to retrieve the `Future` value. Scala has a very explicit API,
    which makes the developer's life easier, and also gives good samples for how we
    should code our own APIs. Future has a method called `value`, which returns `Option[scala.util.Try[A]]`
    where `A` is the generic type you are using for the future; for our case, it's
    a String `A`. `Try` is a different way to do a try...catch, and this is safer,
    because the caller knows beforehand that the code they are calling may fail. `Try[Optional]`
    means that Scala will try to run some code and the code may fail -- even if it
    does not fail, you might receive `None` or `Some`. This type of system makes everybody's
    lives better, because you can have `Some` or `None` as the Option return. Futures
    are a kind of callback. For our previous sample code, the result was obtained
    quite quickly, however, we often use futures to call external APIs, REST services,
    Microservices, SOAP Webservices, or any code that takes time to run and might
    not get completed. Futures also work with Pattern Matcher. Let's see another sample
    code.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: A complete Future sample at Scala REPL
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There is a function called `createFuture`, which creates `Future[Int]` each
    time you call it. In the preceding code, we use `scala.util.Random` to generate
    random numbers between 0 and 99\. If the number is even, we return a `0`, which
    means success. However, if the number is odd, we return a `RuntimeException`,
    which will mean a failure.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a second function called `evaluateFuture`, which receives any Future.
    We allow a result of any kind of generic parameterized type of function, because
    we used the magic underscore `_`. Then we apply Pattern Matcher with two case
    classes: `Success` and `Failure`. In both the cases, we just print on `stdin`.
    We also use another interesting and handy Scala feature called String interpolation.
    We need to we start the String with `s` before `""`. This allows us to use expressions
    with `$` and `${}` to evaluate any variable in the context. This is a different
    approach for String concatenation from what we have done so far. Later, we made
    `6` calls for the `evaluteFuture` function, passing a new Future each time, created
    by the function `createFuture`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programing and RxScala
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is better, scalable, and a faster way to build applications.
    Reactive Programing can be done with OO languages, however, they make a lot of
    sense with FP languages. When FP is married to Reactive Programing, we get something
    called **Functional Reactive Programing** (**FRP**). Scala FRP can be used for
    many purposes like GUI, Robotics, and Music, because it gives you a better model
    to model time. Reactive programming is a new technique, which works with Streams(also
    known as Data Flows). Streams is a way to think and code applications in a way
    which can express data transformations and flow. The main idea is to propagate
    changes through a circuit or flow. Yes, we are talking about a new way to do async
    programming.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The main library for Reactive Programing is called **Reactive Extensions** (**Rx**)
    - [http://reactivex.io/](http://reactivex.io/)), originally built for .NET by
    Eric Meijer. It combines the best ideas from the Observer and Iterator Patterns,
    and FP. Rx has implementations for many languages like Scala, Java, Python, .NET,
    PHP, and others ([https://github.com/ReactiveX](https://github.com/ReactiveX)).
    Coding with Rx is easy, and you can create Streams, combine with query-like operators,
    and also listen (subscribe) to any observable Streams to perform data transformations.
    Rx is used by many successful companies today like Netflix, GitHub, Microsoft,
    SoundCloud, Couchbase, Airbnb, Trello, and several others. In this book, we will
    use RxScala, which is the Scala implementation of the Reactive Streams.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows the main class/concepts you need to know in order
    to work with Rx.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '| **Term / Class** | **Concept** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| Observable | Create async composable Streams from sources. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| Observer | A callback function type. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| Subscription | The bound between the Subscriber and the Observable. Receives
    notifications from Observables. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: Reactive Streams is also the name of a common specification trying to consolidate
    and standardize the reactive stream processing, There are several implementations
    such as RxJava/RxScala, Reactor, Akka, Slick, and Vert.x. You can find more at
    [https://github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Back to the Observables -- we can perform all kinds of operations with observables.
    For instance, we can filter, select, aggregate, compose, perform time-based operations,
    and apply backpressure. There are two big wins with Observables instead of callbacks.
    First of all, Observables are not opinionated about how low-level I/O and threading
    happens, and secondly, when you are doing complex code, callbacks tend to be nested,
    and that is when things get ugly and hard to read. Observables have a simple way
    to do composition thanks to FP.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Observables push values to consumers whenever values are available, which is
    great because then the values can arrive in sync or async fashion. Rx provides
    a series of collection operators to do all sorts of data transformations you may need.
    Let's see some code now. We will use RxScala version 0.26.1, which is compatible
    with RxJava version 1.1.1+. RxScala is just a wrapper for RxJava (Created by Netflix).
    Why not use RxJava straight? Because the syntax won't be pleasant; with RxScala,
    we can have a fluent Scala experience. RxJava is great, however, Java syntax for
    this is not pleasant - as Scala is, in fact, pretty ugly.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Simple Observables Scala with RxScala
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you run this preceding Scala program, you will see the following output:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Simple Observables Scala with RxScala - Execution in the console
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you try to run this code in the Scala REPL, it will fail, because we need
    the RxScala and RxJava dependencies. For this, we will need SBT and dependency
    management. Do not worry, we will cover how to work with SBT in our Scala application
    in the next chapter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the observables, we need to import the Scala Observable. Make
    sure you get it from the Scala package, because if you get the Java one, you will
    have issues: in the very first part of the code, we will get numbers starting
    from 0 each 100 milliseconds, and this code would run forever. To avoid this,
    we use the take function to put a limit into the collection, so we will get the
    first five values. Then, later, we subscribe to the observer, and when data is
    ready, our code will run. For the first sample, it''s pretty easy, we are just
    printing the values we have got. There is a thread sleep in this program, otherwise,
    the program would terminate, and you would not see any value on the console.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the code does something more interesting. First of all, it
    creates an Observable from a static list of values, which are 1,2,3, and 4\. We
    apply a reduce function into the elements, which will sum all the elements with
    each other, and then we subscribe and print the result.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Complex Scala with RxScala Observables
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding first part of the code creates an Observable with numbers from
    1 to 10, and then applies a `filter` function, which will get only the even numbers.
    It then reduces them, calculates their sum, and lastly, prints the solution. You
    can visualize it as depicted in the following image:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Complex Scala with RxScala Observables](img/image00233.jpeg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: For the second part of the code, we create two different observables. The first
    one is with even numbers and the second one is with odd numbers. These two observables
    are decoupled from each other; you can control as many observables you want. Later
    on, the code uses a merge function to join these two observables into a third
    and new observable containing the content of the first and second observables.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![Complex Scala with RxScala Observables](img/image00234.jpeg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: Merging 2 Observables
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: There are many functions and options, and you can see the whole list at [http://rxmarbles.com/](http://rxmarbles.com/)
    and [https://github.com/ReactiveX/RxScala](https://github.com/ReactiveX/RxScala).
    For the sake of simplicity, for now, we are just working with numbers. Later,
    we will use this to do more advance compositions including database calls and
    external web services calls.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basic concepts of FP, Reactive Programing, and
    the Scala language. We learned about the basic constructs of the Scala language
    and Functional Programming, functions, collections, and OO in Scala, and concurrent
    programming with Futures.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to use SBT to build Scala projects. We will learn how
    to compile and run Scala applications using SBT.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
