- en: Chapter 1. Introduction to FP, Reactive, and Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our first chapter, we will learn the basic concepts of **Functional Programing**
    (**FP**), reactive programming, and the Scala language. These concepts are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Scala development environment with Eclipse Scala IDE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic constructs of the language like var, val, for, if, switch, and operator
    overload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between FP and object-oriented programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Principles of pure FP: immutability, no side effects, state discipline, composition,
    and higher order functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts of FP such as lambda, recursion, for comprehensions, partial functions,
    Monads, currying, and functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern Matcher, recursion, reflection, package objects, and concurrency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FP is not new at all. The very first implementation of FP is Lisp and is dated
    from the 1950s. Currently, we are living in a post-functional programming era,
    where we have the strong math principles and ideas from the 50s mixed with the
    most modern and beautiful piece of engineering, also know as the **Java Virtual
    Machine** (**JVM**). Scala is a post-functional programming language built on
    top of the JVM. Being on top of the JVM gives us a lot of benefits such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala is a post-functional programming language built on top of the JVM. Being
    on top of the JVM gives us a lot of benefits such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability and performance**: Java is used by 10 out of 10 top websites
    we have currently, like Netflix, Apple, Uber, Twitter, Yahoo, eBay, Yelp, LinkedIn,
    Google, Amazon, and many others. JVM is the best solution at scale and is battle-tested
    by these web-scale companies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native JVM eco-system**: Full access to all of the Java ecosystem including
    frameworks, libraries, servers, and tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations leverage**: Your operation team can run Scala in the same way
    they run Java.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legacy code leverage**: Scala allows you to easily integrate Scala code with
    Java code. This feature is great because it enables Java legacy system integration
    inside the box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java interoperability**: A code written in Scala can be accessed in Java.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala was created in 2001 at EPFL by Martin Odersky. Scala is a strong static-typed
    language, and was inspired by another functional language called **Haskell**.
    Scala addresses several criticisms of the Java language, and delivers a better
    developer experience through less code and more concise programs, without losing
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Scala and Java share the same infrastructure as the JVM, but in terms of design,
    Scala is a different language in comparison with Java. Java is an imperative object-oriented
    language and Scala is a post-functional, multiparadigm programing language. FP
    works with different principles than **object-oriented programing** (**OOP**).
    OOP got very popular and well established in enterprise thanks to languages like
    Java, C#, Ruby, and Python. However, languages like Scala, Clojure, F#, and Swift
    are gaining a huge momentum, and FP has grown a lot in the last 10 years. Most
    of the new languages are pure functional, post-functional, or hybrid (like Java
    8). In this book, you will see Scala code compared with Java code so you can see
    by yourself how Scala is way more compact, objective, and direct than Java and
    imperative OOP languages.
  prefs: []
  type: TYPE_NORMAL
- en: FP started at academia and spread to the world; FP is everywhere. Big Data and
    Stream processing solutions like Hadoop and Spark (built on top of Scala and Akka)
    are built on top of FP ideas and principles. FP spread to UI with **RxJavaScript **-
    you can even find FP in a database with Datomic (Clojure). Languages like Clojure
    and Scala made FP more practical and attractive to enterprise and professional
    developers. In this book, we will be exploring both principles and practical aspects
    of the Scala language.
  prefs: []
  type: TYPE_NORMAL
- en: Principles of functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FP is a way of thinking, a specific style of constructing and building programs.
    Having an FP language helps a lot in terms of syntax, but at the end of the day,
    it's all about ideas and developer mindset. FP favors disciplined state management
    and immutability in a declarative programming way rather than the imperative programming
    mostly used by OOP languages such as Java, Python, and Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: FP has roots in math back to **Lambda calculus **- a formal system developed
    in the 1930s. Lambda calculus is a mathematical abstraction and not a programming
    language, but it is easy to see its concepts in programming languages nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative programming uses statements to change the program state. In other
    words, this means you give commands to the program to perform actions. This way
    of thinking describes a sequence of steps on how the program needs to operate.
    What you need to keep in mind is the kind of style focus on how FP works in a
    different way, focusing on what the program should accomplish without telling
    the program how to do it. When you are coding in FP, you tend to use fewer variables,
    for loops, and IFS, and write more functions and make function composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the CORE principles of FP:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disciplined state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions and no side effects/disciplined states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First class functions and high order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's understand these principles in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of immutability is the CORE of FP, and it means that once you assign
    a value to something, that value won't change. This is very important, because
    it eliminates side effects (anything outside of the local function scope), for
    instance, changing other variables outside the function. Immutability makes it
    easier to read code, because you know the function that you are using is a pure
    function. Since your function has a disciplined state and does not change other
    variables outside of the function, you don't need to look at the code outside
    the function definition. This sounds like you're not working with state at all,
    so how would it be possible to write professional applications this way? Well,
    you will change state but in a very disciplined way. You will create another instance
    or another pointer to that instance, but you won't change that variable's value.
    Having immutability is the key to having better, faster, and more correct programs,
    because you don't need to use locks and your code is parallel by nature.
  prefs: []
  type: TYPE_NORMAL
- en: Disciplined state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shared mutable state is evil, because it is much harder to scale and to run
    it concurrently. What is shared mutable state? A simple way to see it is as a
    global variable that all your functions have access to. Why is this bad? First
    of all, because it is hard to keep this state correct since there are many functions
    that have direct access to this state. Second, if you are performing refactoring,
    this kind of code is often the hardest to refactor as well. It''s also hard to
    read this code. This is because you can never trust the local method, since your
    local method is just one part of the program. And with mutable state, you need
    to look up for all the functions that use that variable, in order to understand
    the logic. It''s hard to debug for the very same reason. When you are coding with
    FP principles in mind, you avoid, as much as possible, having a shared mutable
    state. Of course you can have state, but you should keep it local, which means
    inside your function. This is the state discipline: you use state, but in a very
    disciplined way. This is simple, but it could be hard especially if you are a
    professional developer, because this aspect is now usual to see in enterprise
    languages such as Java, .NET, Ruby, and Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions and no side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pure functions are the ones with no side effects. Side effects are bad, because
    they are unpredictable and make your software hard to test. Let's say you have
    a method that receives no parameters and returns nothing--this is one of the worst
    things we could have, because how do you test it? How can you reuse this code?
    This is not what we call a pure function. What are the possible side effects?
    Database call, global variables, IO call, and so on. This makes sense, but you
    cannot have a program with just pure functions, because it won't be practical.
  prefs: []
  type: TYPE_NORMAL
- en: First-class functions and higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First-class means that the language treats functions as first-class citizens.
    In other words, it means having language support to pass functions as arguments
    to other functions and to return values as functions. First-class function also
    implies that the language allows you to store functions as variables or any other
    data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions are related to First-class functions, but they are not
    the same thing. Higher-order functions often means language support for partial
    functional application and Currying. Higher-order functions are a mathematical
    concept where functions operate with other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions are when you can fix a value (argument) to a particular function,
    which you may or may not change later on. This is great for function composition.
  prefs: []
  type: TYPE_NORMAL
- en: Currying is a technique to transform a function with multiple parameters in
    a sequence of functions with each function having a single argument. Scala language
    does not force currying, however, languages like ML and Haskell almost always
    use this kind of technique.
  prefs: []
  type: TYPE_NORMAL
- en: Type systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type system is all about the compiler. The idea is simple: you create a type
    system, and by doing so, you leverage the compiler to avoid all kinds of mistakes
    and errors. This is because the compiler helps in making sure that you only have
    the right types as arguments, turn statements, function composition, and so on.
    The compiler will not allow you do make any basic mistakes. Scala and Haskell
    are examples of languages that are Strong-type. Meanwhile, Common Lisp, Scheme,
    and Clojure are dynamic languages that may accept wrong values during compilation
    time. One of the biggest benefits of the strong type system is that you have to
    write fewer tests, because the compiler will take care of several issues for you.
    For instance, if you have a function that receives a string, it could be dangerous,
    because you can pass pretty much anything in a string. However, if you have a
    function that receives a type called salesman, then you don''t write a validation
    to check if it is a salesman. All this may sound silly, but in a real application,
    this saves lots of lines of code and makes you program better. Another great benefit
    of strong typing is that you have better documentation, as your code becomes your
    documentation, and it''s way more clear what you can or can''t do.'
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Referential transparency is a concept which works close with pure functions
    and immutability since your program has fewer assignment statements, and often
    when you have it, you tend to never change that value. This is great because you
    eliminate side effects with this technique. During program execution, any variable
    can be replaced since there are no side effects, and the program becomes referentially
    transparent. Scala language makes this concept very clear the moment you declare
    a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Java 8 and Scala 2.11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala requires JVM to work, so we need get the JDK 8 before installing Scala.
    Go to the Oracle website, and download and install JDK 8 from [http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html](http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve downloaded Java, we need to add Java to the `PATH` variable; otherwise,
    you can use the terminal. We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the environment variable called `JAVA_HOME`, and
    to put the Java 8 binaries in the `PATH` variable. In Linux, we need to edit the
    `~/.bashrc` file, and export the variables we need, like in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Save the file, and then on the same terminal we need to source the file via
    `$ source ~/.bashrc`
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test our Java 8 installation. Just type in `$ java -version`. You
    should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's get started. We will be using the latest Scala version 2.11.8\. However,
    the code inside this book should work with any Scala 2.11.x version. First of
    all, let's download Scala from [http://www.scala-lang.org/](http://www.scala-lang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Scala works on Windows, Mac, and Linux. For this book, I will show how to use
    Scala on Ubuntu Linux(Debian-based). Open your browser and go to [http://www.scala-lang.org/download/](http://www.scala-lang.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Download `scala 2.11.8`: it will be a TGZ file. Extract it and add it to your
    path; otherwise, you can use the terminal. Do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the environment variable called `SCALA_HOME`, and
    to put the Scala binaries in the `PATH` variable. In Linux, we need to edit the
    `~/.bashrc` file and export the variables we need, like in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Save the file, and then, on the same terminal, we need to source the file via
    `$ source ~/.bashrc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test our Scala installation. Just type in `$ scala -version`. You
    should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You have successfully installed Java 8 and Scala 2.11\. Now we are ready to
    start learning the FP principles in Scala. For this, we will be using the Scala
    REPL in the beginning. Scala REPL is bundled with the default Scala installation,
    and you just need to type `$ scala` in your terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have installed Java 8 and Scala 2.11 successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Read Eval Print and Loop - REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Read Eval Print and Loop** (**REPL**) is also know as a language shell. Many
    other languages have shells, like Lisp, Python, and Ruby for instance. The REPL
    is a simple environment to experiment the language in. It''s possible to write
    very complex programs using REPL, but this is not the REPL goal. Using REPL does
    not invalidate the usage of an IDE like Eclipse or IntelliJ IDEA. REPL is ideal
    for testing simple commands and programs without having to spend much time configuring
    projects like you do with an IDE. The Scala REPL allows you to create a variable,
    functions, classes, and complex functions as well. There is a history of every
    command you perform; there is some level of autocomplete too. As a REPL user,
    you can print variable values and call functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Scala Hello World using the REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started. Go ahead, open your terminal, and type `$ scala` in order
    to open the Scala REPL. Once the REPL is open, you can just type `"Hello World"`.
    By doing this, you perform two operations: eval and print. The Scala REPL will
    create a variable called `res0`, and store your String there. Then it will print
    the content of the `res0` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Scala REPL Hello World program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to create Hello World program in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Scala is a hybrid language, which means it is object-oriented and functional
    as well. You can create classes and objects in Scala. Next we will create a complete
    Hello World application using classes.
  prefs: []
  type: TYPE_NORMAL
- en: Scala object-oriented HelloWorld program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to create object-oriented HelloWorld program in Scala REPL
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you need to realize is that we use the word object instead of
    class. The Scala language has different constructs compared to Java. Object is
    a singleton in Scala. It's the same as coding the singleton pattern in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we see the word `def` that is used in Scala to create functions. In the
    preceding program, we create the main function similar to the way we do it in
    Java, and we call the built-in function `println` in order to print the String
    Hello World. Scala imports some Java objects and packages by default. Coding in
    Scala does not require you to type, for instance, `System.out.println("Hello World")`,
    but you can if you want. Let''s take a look at it in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can and we will do better. Scala has some abstractions for a console application,
    so we can write this code with a lesser number of lines of code. To accomplish
    this goal, we need to extend the Scala class App. When we extend from App, we
    perform inheritance and we don't need to define the main function. We can just
    put all the code in the body of the class, which is very convenient and makes
    the code clean and simple to read.
  prefs: []
  type: TYPE_NORMAL
- en: Scala HelloWorld App in the Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to create Scala HelloWorld App in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After coding the HelloWorld object in the Scala REPL we can ask the REPL what
    HelloWorld is, and as you might realize, the REPL will answer that HelloWorld
    is an object. This is a very convenient Scala way to code console applications,
    because we can have a Hello World application with just three lines of code. Sadly,
    to have the same program in Java, it required way more code. Java is a great language
    for performance, but it is a verbose language compared with Scala, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Java HelloWorld application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to create Java HelloWorld application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Java app required six lines of code, while in Scala, we were able to do
    the same with 50% less code (three lines of code). This is a very simple application.
    When we are coding complex applications, this difference gets bigger, as a Scala
    application ends up with way less code than Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, we use an object in Scala in order to have a Singleton (Design Pattern
    that makes sure you have just one instance of a class), and if we want the same
    in Java, the code would be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's not just about the size of the code, but also about consistency and the
    language providing more abstractions for you. If you write less code, you will
    have fewer bugs in your software at the end of the day.
  prefs: []
  type: TYPE_NORMAL
- en: Scala language - the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala is a statically typed language with a very expressive type system which
    enforces abstractions in a safe yet coherent manner. All values in Scala are Java
    objects (primitives which are unboxed at runtime), because at the end of the day,
    Scala runs on the Java JVM. Scala enforces immutability as a core FP principle.
    This enforcement happens in multiple aspects of the Scala language, for instance,
    when you create a variable, you do it in an immutable way, when you use an collection,
    you will use a immutable collection. Scala also lets you use mutable variables
    and mutable structures, but by design, it favors immutable ones.
  prefs: []
  type: TYPE_NORMAL
- en: Scala variables - var and val
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are coding in Scala, you create variables using the operator `var`,
    or you can use the operator `val`. The operator `var` allows you to create a mutable
    state, which is fine as long as you make it local, follow the CORE-FP principles
    and avoid a mutable shared state.
  prefs: []
  type: TYPE_NORMAL
- en: Scala REPL var usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use var in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, Scala has a more interesting construct called `val`. Using the `val`
    operator makes your variables immutable, and this means you can't change the value
    once you've set it. If you try to change the value of the `val` variable in Scala,
    the compiler will give you an error. As a Scala developer, you should use the
    variable `val` as much as possible, because that's a good FP mindset, and it will
    make your programs better. In Scala, everything is an object; there are no primitives
    -- the `var` and `val` rules apply for everything it could but an `Int` or `String`
    or even a class.
  prefs: []
  type: TYPE_NORMAL
- en: Scala val usage at the Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use val in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating immutable variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, let's see how we define the most common types in Scala such as `Int`,
    `Double`, `Boolean`, and `String`. Remember, you can create these variables using
    `val` or `var` depending on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Scala variable type in the Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Scala variable type in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For the variables in the preceding code, we did not define the type. Scala language
    figures it out for us. However, it is possible to specify the type if you want.
    In Scala, the type comes after the name of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Scala variables with explicit typing at the Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Scala variables with explicit typing at Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Scala conditional and loops statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other language, Scala has support for conditional statements like `if`
    and `else`. While Java has a switch statement, Scala has a more powerful and functional
    structure called Pattern Matcher, which we will cover later in this chapter. Scala
    allows you to use `if` statements during variable assignments, which is very practical
    as well as useful.
  prefs: []
  type: TYPE_NORMAL
- en: If statements in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use `if` statements in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that we set the variable `y` based on an
    `if` condition. Scala `if` conditions are very powerful, and they also can be
    used in return statements.
  prefs: []
  type: TYPE_NORMAL
- en: If statements in return statements in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use `if` statements in return statements in Scala REPL as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Scala supports `else` statements too, and you also can use them in variables
    and return statements as wellas follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now you will learn how to use for loops in Scala. For loops are very powerful
    in Scala. We will start with the basics and later we will move on to functional
    loops used for comprehensions, also know as `List` comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: In Scala, for loops work with ranges, which is another Scala data structure
    that represents numbers from a starting point to an end point. The range is created
    using the left arrow operator(`<-`). Scala allows you to have multiple ranges
    in the same for loop as long as you use the semicolon(`;`).
  prefs: []
  type: TYPE_NORMAL
- en: You also can use `if` statements in order to filter data inside for loops, and
    work smoothly with `List` structures. Scala allows you to create variables inside
    a for loop as well. Right now, let's see some code which illustrates the various
    for loop usages in Scala language.
  prefs: []
  type: TYPE_NORMAL
- en: Basic for loop in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use basic for loop in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Right now, we will create a for loop using a Scala data structure called `List`.
    This is very useful, because in the first line of code, you can define a `List`
    as well as set its values in the same line. Since we are using the `List` structure,
    you don't need to pass any other argument besides the `List` itself.
  prefs: []
  type: TYPE_NORMAL
- en: For with List in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to `use` for with `List` in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can use for loops with `if` statements in order to apply some filtering.
    Later in this book, we will approach a more functional way to approach filtering
    using functions. For this code, let's say we want to get just the even numbers
    on the list and print them.
  prefs: []
  type: TYPE_NORMAL
- en: For with if statements for filtering - Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use `for` with `if` statements in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Java code for filtering even numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Scala language, we just need two lines of code to perform this filtering,
    whereas in Java it would have required at least eleven lines of code as you see
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Also known as list or sequence comprehensions, for comprehensions are one of
    the FP ways to perform loops. This is a language support to create `List` structure
    or collections based on other collections. This task is performed in a `SetBuilder`
    notation. Another way to accomplish the same goal would be by using the `Map`
    and `filter` functions, which we will cover later in this chapter. For comprehensions
    can be used in a generator form, which would introduce new variables and values,
    or in a reductionist way, which would filter values resulting into a new collection
    or sequence. The syntax is: `for (expt) yield e`, where the `yield` operator will
    add new values to a new collection/sequence that will be created from the original
    sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: For comprehension in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use `for` comprehension in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create a set of names. As you can see, Scala, by default,
    prefers immutable data structures and uses `immutable.Set`. When we apply the
    `for` loop, we are simply filtering only the `names` which contain a specific
    substring, and then, using the `yield` operator, we are creating a new `Set` structure.
    The `yield` operator will keep the structure you are using. For instance, if we
    use `List` structure, it would create a `List` instead of a `Set structure`, the
    `yield` operator will always keep the same data collection you have on the variable.
    Another interesting aspect of the preceding code is the fact that we are holding
    the result of the `for` comprehension in a variable called Brazilians. Java does
    not have `for` comprehensions, but we could use similar code although it would
    require way more lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Java code for performing filtering with collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to use Java code for performing filtering with collections as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Scala collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to create the `List` and `Set` structures
    in Scala in an immutable way. Now we will learn to work with the `List` and `Set`
    structures in a mutable way, and also with other collections such as sequences,
    tuples, and Maps. Let''s take a look at the Scala collections hierarchy tree,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scala collections](img/image00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's take a look at the Scala Seq class hierarchy. As you can see, Seq
    is traversable as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scala collections](img/image00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Scala collections extend from traversable, which is the main trait of all collection's
    descends. `List` structures, for instance, extend from Seq class hierarchy, which
    means sequence - `List` is a kind of sequence. All these trees are immutable or
    mutable depending on the Scala package you end up using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to perform basic mutable operations with `List` structures in
    Scala. In order to have filter and removal operations, we need use a `Buffer` sequence as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's see the next set of code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, removing, and getting an item from a mutable list in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how to create, remove, and get an item from a mutable list in Scala
    REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Have you ever wanted to return multiple values in a method? Well, in Java you
    have to create a class, but in Scala, there is a more convenient way to perform
    this task, and you won't need to create new classes each time. Tuples allow you
    to return or simply hold multiple values in methods without having to create a
    specific type.
  prefs: []
  type: TYPE_NORMAL
- en: Scala tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Scala tuples as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Scala has special methods called `_1` and `_2` which you can use to retrieve
    a tuple's values. The only thing you have to keep in mind is the fact that values
    are kept in the order of insertion in the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Scala has a very practical and useful collection library. A Map, for instance,
    is a key/value pair that can be retrieved based on the key, which is unique. However,
    Map values do not need to be unique. Like other Scala collections, you have mutable
    and immutable Map collections. Keep in mind that Scala favors immutable collections
    over mutable ones.
  prefs: []
  type: TYPE_NORMAL
- en: Scala immutable Map in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Scala immutable Map in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Scala uses `scala.collection.immutable.Map` when you create
    a Map using `Map()`. Both keys and values are iterable, and you can have access
    to all the keys with the `keys` method or to all the values using the `values`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Scala mutable Maps at Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Scala mutable Map in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you are dealing with mutable state, you have to be explicit and this is great
    in Scala, because it increases developers' awareness and avoids mutable shared
    state by default. So, in order to have a mutable Map, we need to explicitly create
    the Map with `scala.collection.mutable.HashMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monads are combinable parametrized container types which have support for higher-order
    functions. Remember higher-order functions are functions which receive functions
    as parameters and return functions as results. One of the most used functions
    in FP is Map. Map takes a function, applies it to each element in the container,
    and returns a new container.
  prefs: []
  type: TYPE_NORMAL
- en: Scala Map function in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see Map function in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a list of numbers containing 1,2,3,4,5, and
    6\. We also defined a Scala function called `doubleIt`, which receives an integer
    and multiplies it by `2.0` resulting in a double number. The `map` function calls
    `doubleIt` for each element in the `List (1,2,3,4,5,6)`, and the result is a new
    container, a brand new `List` instance containing the new values.
  prefs: []
  type: TYPE_NORMAL
- en: Scala has some syntactical sugar which helps us to be more productive. For instance,
    you may realize that in the previous code, we also did - `2.0 * _`. The underscore
    is a special operator for this specific case -- it means the current value is
    being iterated into the collection. Scala will create a function from this expression
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have realized, `map` functions are pretty useful for lots of reasons:
    one reason is that you can do complex computations without using the `for` loop
    explicitly, and this makes your code functional. Secondly, we can use a `map`
    function to convert element types from one type to another. That''s what we did
    in the previous code: we transformed a list of integers into a list of doubles. Look
    at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `map` function operates over several data structures and not only collections,
    as you can see in the previous code. You can use the `map` function on pretty
    much everything in Scala language.
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function is great, but you can end up with nested structures. That's
    why, when we are working with Monads, we use a slightly different version of the
    `map` function called `flatMap`, which works in a very similar way to the `map`
    function, but returns the values in a flat form instead of nested values.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a monad, you need to have a method called `flatMap`. Other
    function languages such as Haskell call `flatMap` as `bind`, and use the operator
    `>>=`. The syntax changes with the language, but the concept is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Monads can be built in different ways. In Scala, we need a single argument constructor
    which will work as a monad factory. Basically, the constructor receives one type,
    `A`, and returns `Monad[A]` or just `M[A]`. For instance, `unit(A)` for a `List`
    will be `== List[A]` and `unit(A)`, where a is an Option `== Option[A]`. In Scala,
    you don't need to have unit; this is optional. To have a monad in Scala, you need
    to have map and `flatMap` implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with Monads will make you write a little bit more code than before.
    However, you will get a way better API, which will be easier to reuse and your
    potential complexity will be managed, because you won''t need to write a complex
    code full of `if` and for loops. The possibilities are expressed through the types,
    and the compiler can check it for you. Let us see a simple monad example in Scala
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: Option Monad in Scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see option Monad in Scala as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In Haskell, this also known as the Maybe monad. Option means optional value,
    because we are not 100% sure if the value will be present. In order to express
    a value, we use the `Some` type, and in order to express the lack of value, we
    use none. Option Monads are great, they make your code more explicit, because
    a method might receive or return an option, which means you are explicitly saying
    this could be null. However, this technique is not only more expressive but also
    safer, since you won't get a null pointer, because you have a container around
    the value. Although, if you call the method `get` in `Option` and it is none,
    you will get a `NoSuchelementException`. In order to fix this, you can use the
    method `getOrElse`, and you can supply a fallback value which will be used in
    the case of none. Alright, but you might be wondering where the `flatMap` method
    is. Don't worry, Scala implements this method for us into the `Option` abstraction,
    so you can  use it with no issues.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The Scala REPL can perform autocomplete for you. If you type **C** + **Tab**,
    you will see all the available methods for the `Some` class. The `map` function
    is available for you to use, and as I said before, there is no unit function in
    Scala whatsoever. However, it is not wrong if you add in your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: A list of all methods using the Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the list of all methods using the Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Scala class, traits, and OO programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a hybrid post-functional language, Scala allows you to write OO code and
    create classes as well. Right now we will learn how to create classes and functions
    inside classes, and also how to work with traits, which are similar to Java interfaces
    in concept but way more powerful in practice.
  prefs: []
  type: TYPE_NORMAL
- en: A simple Scala class in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see a simple Scala class in Scala REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, the preceding code looks like Java. But let's add constructors,
    getters, and setters, and then you can see how much we can accomplish with just
    a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Scala plain old Java object in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala plain old Java object in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Constructors in Scala are just lines of code. You might realize that we get
    the `name` variable, and apply a function to change the given name to upper case
    in the preceding example. If you want, you can put as many lines as you want,
    and you can perform as many computations as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: On this same code, we perform method overriding as well, because we override
    the `toString` method. In Scala, in order to do an override, you need to use the
    `override` operator in front of the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: We just wrote a **Plain Old Java Object** (**POJO**) with very few lines of
    code in Scala. Scala has a special annotation called `@scala.beans.BeanProperty`,
    which generates the getter and setter method for you. This is very useful, and
    saves lots of lines of code. However, the target needs to be public; you can't
    a apply `BeanProperty` annotation on top of a private `var` or `val` object.
  prefs: []
  type: TYPE_NORMAL
- en: Person class in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Person class in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Traits and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible to do inheritance in Scala as well. For such a task, you use the
    operator `extend` after the class definition. Scala just allows you to extend
    one class, just like Java. Java does not allow multiple inheritance like C++.
    However, Scala allows it by using the Mixing technique with traits. Scala traits
    are like Java interface, but you can also add concrete code, and you are allowed
    to have as many traits as you want in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Scala inheritance code in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala inheritance code in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Scala does not make constructors inheritance like Java. So you need to rewrite
    the constructors and pass the values through a super class. All code inside the
    class will be the secondary constructor. All code inside parentheses `()` in the
    class definition will be the primary constructor. It's possible to have multiple
    constructors using the `this` operator. For this particular implementation, we
    changed the default behavior and added new constructor code in order to make the
    given name lower case, instead of the default uppercase defined by the `Person`
    superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Scala traits sample code in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala traits sample code in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created multiple traits. One is called Car, which
    is the mother trait. Traits support inheritance as well, and we have it with the
    `SportCar` trait which extends from the `Car` trait. The `SportCar` trait demands
    a variable called brand, and defines a concrete implementation of the function
    run. Finally, we have a class called `BMW` which extends from multiple traits
    -- this technique is called **mixing.**
  prefs: []
  type: TYPE_NORMAL
- en: Scala traits using variable mixing technique at Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala traits using variable mixing technique at Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Scala is a very powerful language indeed. It's possible to add traits to a variable
    at runtime. When you define a variable, you can use the `with` operator after
    the assignment. This is a very useful feature, because it makes it easier to make
    function composition. You can have multiple specialized traits and just add them
    in your variables as you need them.
  prefs: []
  type: TYPE_NORMAL
- en: Scala allows you to create the `type` alias as well, this is a very simple technique
    which will increase the readability of your code. It's just a simple alias.
  prefs: []
  type: TYPE_NORMAL
- en: Scala type alias sample in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala type alias sample in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When you are coding with Scala, it is highly recommended that you use the `type`
    alias and traits for everything, because that way you will get more advantages
    with your compiler, and you will avoid writing unnecessary code and unnecessary
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Case classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not done yet in terms of the OO features in Scala; there is another
    very interesting way to work with classes in Scala: the so-called case classes.
    Case classes are great because you can have a class with way less number of lines
    of code and case classes can be part of a Pattern Matcher.'
  prefs: []
  type: TYPE_NORMAL
- en: Scala case classes feature in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala case classes feature in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is the Scala way to work with classes. Because this is so much easier and
    compact, you pretty much create a class with one line of code, and you can have
    the `equals` and `hashcode` methods for free.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern Matcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you code in Java, you can use a Switch statement. However, in Scala, we
    have a more powerful feature called Pattern Matcher, which is a kind of switch
    but on steroids.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Pattern Matcher in Scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Simple Pattern Matcher in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Scala uses Pattern Matcher for error handling. Java does not have Pattern Matcher
    like Scala. It's similar to a switch statement; however, Pattern Matcher can be
    used in a method return statement as you can see in the preceding code. Scala
    developers can specify a special operator called `_` (Underscore), which allows
    you to specify anything in the Pattern Matcher scope. This behavior is similar
    to `else` in an `if` conditional. However, in Scala, you can use `_` in several
    places, and not only as the otherwise clause, like in Java switch.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in Scala is similar to error handling in Java. We use try...catch
    blocks. The main difference is that you have to use Pattern Matcher in Scala,
    which is great because it adds more flexibility to your code. Pattern Matcher
    in Scala can operate against many data structures like case classes, collections,
    integers, and strings.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is pretty simple and straightforward. Next we will see a
    more complex and advanced code using the Scala Pattern Matcher feature.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced pattern matcher in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an Advanced Pattern Matcher using Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Pattern Matcher can be used in a very functional way. For instance, in the preceding
    code, we use the Pattern Matcher for recursion. There is no need to create a variable
    to store the result, we can put the Pattern Matcher straight to the function return,
    which is very convenient and saves lots of lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced complex pattern matcher in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an Advanced complex Pattern Matcher using Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The Scala Pattern Matcher is really amazing. We just used an `if` statement
    in the middle of the Pattern Matcher, and also `_` to specify a match for any
    kind of red value. We also used case classes in the middle of the Pattern Matcher
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partial functions are great for function composition. They can operate with
    case statements as we just learned from Pattern Matcher. Partial functions are
    great in the sense of function composition. They allow us to define a function
    in steps. Scala frameworks and libraries use this feature a lot to create abstractions
    and callback mechanisms. It's also possible to check if a partial function is
    being supplied or not.
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions are predictable, because the caller can check beforehand if
    the value will be applied to the partial function or not. Partial function can
    be coded with or without case-like statements.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Partial function in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a simple Partial function using Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Partial functions are Scala classes. They have some methods you need to provide,
    for instance, `apply` and `isDefinedAt`. The function `isDefinedAt` is used by
    the caller to check if the `PartialFunction` will accept and operate with the
    value supplied. The `apply` function will do the work when the `PartialFunction`
    is executed by Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Scala PartialFunction without OO using case statements in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a Scala PartialFunction without OO using case statements in Scala
    REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Scala was a more fluent way to work with `PartialFunction` using the `case`
    statements. When you use the `case` statements, you don't need to supply the `apply`
    and `isDefinedAt` functions, since the Pattern Matcher takes care of that.
  prefs: []
  type: TYPE_NORMAL
- en: PartialFunction composition in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is a PartialFunction composition in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Scala allows us to compose as many `PartialFunctions` as we want. `PartialFunction`
    composition happens with the `orElse` function. In the preceding code, we defined
    an immutable variable called `even`, which verifies even numbers. Secondly, we
    created a second immutable variable called `odd`, which checks for odd numbers.
    Then we did the composition, and created a third `PartialFunction` called `evenOrOdd`
    with compose even and odd using the `orElse` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Package objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala has packages like Java. However, Scala packages are also objects, and
    you can have code inside a package. Java does not have the same power as Scala
    in terms of packages. If you add code to a package, it will be available to all
    classes and functions within that package.
  prefs: []
  type: TYPE_NORMAL
- en: package.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your `package.scala` file should contain the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is the Scala package object. There is this special token called `package`
    object which you use to define common code to all classes, objects, and functions
    that are defined inside this package or sub-package. For this case, we define
    a value of PI as a constant and also one object holder containing the String values
    for `Odd` and `Even`. There are also three helper functions, which can and will
    be used by the classes inside this package.
  prefs: []
  type: TYPE_NORMAL
- en: MainApp.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your `MainApp.scala` file should contain the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, this new object is placed in the package:
    `com.packait.scala.book.commons`. Another interesting thing is the fact that we
    don''t have any import statement here because of the `package` object feature.
    When you compile and run this program, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Scala uses the `Package` object a great deal providing lots of shortcuts and
    convenience for all Scala developers. The following is the Scala `package` object
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any great FP language, Scala has lots of built-in functions. These functions
    make our code more fluent and functional; now it''s time to learn some of these
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala, the underscore(`_`) means different things in different contexts.
    The underscore can be used to partially apply a function. It means a value will
    be supplied later. This feature is useful for function composition and allows
    you to reuse functions. Let's see some code.
  prefs: []
  type: TYPE_NORMAL
- en: Partial function in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an example using Partial function in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, first, we define a function called `sum`, which takes
    two `Int` parameters and calculates a sum of these two parameters. Later, we define
    a function and hold it as a variable called `add6`. For the `add6` function definition,
    we just call the sum function passing `6` and `_`. Scala will get the parameter
    passed through `add6`, and pass it through the `sum` function.
  prefs: []
  type: TYPE_NORMAL
- en: Curried functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This feature is very popular in function languages like Haskell. Curried functions
    are similar to partial applications, because they allow some arguments to pass now
    and others later. However, they are a little bit different.
  prefs: []
  type: TYPE_NORMAL
- en: Curried functions - Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an example using curried function in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: For the preceding code, we create a curried function in the function definition.
    Scala allows us to transform regular/normal functions into curried functions.
    The following code shows the usage of the `curried` function.
  prefs: []
  type: TYPE_NORMAL
- en: Curried transformation in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an example using curried transformation in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like C++, Scala permits operator overload. This feature is great for creating
    custom **Domain Specific Languages** (**DSL**), which can be useful to create
    better software abstractions or even internal or external APIs for developers,
    or for business people. You should use this feature with wisdom -- imagine if all
    frameworks decide to overload the same operators with implicits! You might run
    into trouble. Scala is a very flexible language compared to Java. However, you
    need to be careful, otherwise you could create code that's hard to maintain or
    even incompatible with other Scala applications, libraries, or functions.
  prefs: []
  type: TYPE_NORMAL
- en: Scala operator overloading in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an example using Scala operator overloading in Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have two functions called `+`. One of this functions receives
    a `MyNumber` case class, and the other receives a `Int` value. You can use OO
    in Scala with regular classes and functions as well if you wish. We're also favoring
    immutability here because we always create a new instance of `MyNumber` when the
    operation `+` happens.
  prefs: []
  type: TYPE_NORMAL
- en: Implicits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implicits allow you to do magic in Scala. With great power comes great responsibility.
    Implicits allow to you create very powerful DSL, but they also allow you to get
    crazy, so do it with wisdom. You are allowed to have implicit functions, classes,
    and objects. The Scala language and other core frameworks from the Scala ecosystem
    like Akka and PlayFramework use implicits many times.
  prefs: []
  type: TYPE_NORMAL
- en: Scala Implicits in SCALA REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: To use implicits, you need to use the keyword `implicit` before a function.
    Scala will implicitly call that function when it is appropriate. For this case,
    it will call to convert the `String` type to `Int` type as we can see.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Parameter at Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For this other case, given in the last code, we use an implicit parameter in
    the function `sum`. We also used a curried function here. We defined the `implicit`
    function first, and then called the `sum` function. This technique is good for
    externalized functions configuration and values you would let it hard code. It
    also saves lines of code, because you don't need to pass a parameter to all functions
    all the time, so it's quite handy.
  prefs: []
  type: TYPE_NORMAL
- en: Futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Futures enable an efficient way to write parallel operations in a nonblocking
    IO fashion. Futures are placeholder objects for values that might not exist yet.
    Futures are composable, and they work with callbacks instead of traditional blocking
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Future code in Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In order to work with futures in Scala, we have to import `concurrent.Future`.
    We also need an executor, which is a way to work with threads. Scala has a default
    set of execution services. You can tweak it if you like, however, for now we can
    just use the defaults; to do that, we just import `concurrent.ExecutionContext.Implicits.global`.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to retrieve the `Future` value. Scala has a very explicit API,
    which makes the developer's life easier, and also gives good samples for how we
    should code our own APIs. Future has a method called `value`, which returns `Option[scala.util.Try[A]]`
    where `A` is the generic type you are using for the future; for our case, it's
    a String `A`. `Try` is a different way to do a try...catch, and this is safer,
    because the caller knows beforehand that the code they are calling may fail. `Try[Optional]`
    means that Scala will try to run some code and the code may fail -- even if it
    does not fail, you might receive `None` or `Some`. This type of system makes everybody's
    lives better, because you can have `Some` or `None` as the Option return. Futures
    are a kind of callback. For our previous sample code, the result was obtained
    quite quickly, however, we often use futures to call external APIs, REST services,
    Microservices, SOAP Webservices, or any code that takes time to run and might
    not get completed. Futures also work with Pattern Matcher. Let's see another sample
    code.
  prefs: []
  type: TYPE_NORMAL
- en: A complete Future sample at Scala REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There is a function called `createFuture`, which creates `Future[Int]` each
    time you call it. In the preceding code, we use `scala.util.Random` to generate
    random numbers between 0 and 99\. If the number is even, we return a `0`, which
    means success. However, if the number is odd, we return a `RuntimeException`,
    which will mean a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a second function called `evaluateFuture`, which receives any Future.
    We allow a result of any kind of generic parameterized type of function, because
    we used the magic underscore `_`. Then we apply Pattern Matcher with two case
    classes: `Success` and `Failure`. In both the cases, we just print on `stdin`.
    We also use another interesting and handy Scala feature called String interpolation.
    We need to we start the String with `s` before `""`. This allows us to use expressions
    with `$` and `${}` to evaluate any variable in the context. This is a different
    approach for String concatenation from what we have done so far. Later, we made
    `6` calls for the `evaluteFuture` function, passing a new Future each time, created
    by the function `createFuture`.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programing and RxScala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is better, scalable, and a faster way to build applications.
    Reactive Programing can be done with OO languages, however, they make a lot of
    sense with FP languages. When FP is married to Reactive Programing, we get something
    called **Functional Reactive Programing** (**FRP**). Scala FRP can be used for
    many purposes like GUI, Robotics, and Music, because it gives you a better model
    to model time. Reactive programming is a new technique, which works with Streams(also
    known as Data Flows). Streams is a way to think and code applications in a way
    which can express data transformations and flow. The main idea is to propagate
    changes through a circuit or flow. Yes, we are talking about a new way to do async
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: The main library for Reactive Programing is called **Reactive Extensions** (**Rx**)
    - [http://reactivex.io/](http://reactivex.io/)), originally built for .NET by
    Eric Meijer. It combines the best ideas from the Observer and Iterator Patterns,
    and FP. Rx has implementations for many languages like Scala, Java, Python, .NET,
    PHP, and others ([https://github.com/ReactiveX](https://github.com/ReactiveX)).
    Coding with Rx is easy, and you can create Streams, combine with query-like operators,
    and also listen (subscribe) to any observable Streams to perform data transformations.
    Rx is used by many successful companies today like Netflix, GitHub, Microsoft,
    SoundCloud, Couchbase, Airbnb, Trello, and several others. In this book, we will
    use RxScala, which is the Scala implementation of the Reactive Streams.
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows the main class/concepts you need to know in order
    to work with Rx.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Term / Class** | **Concept** |'
  prefs: []
  type: TYPE_TB
- en: '| Observable | Create async composable Streams from sources. |'
  prefs: []
  type: TYPE_TB
- en: '| Observer | A callback function type. |'
  prefs: []
  type: TYPE_TB
- en: '| Subscription | The bound between the Subscriber and the Observable. Receives
    notifications from Observables. |'
  prefs: []
  type: TYPE_TB
- en: Reactive Streams is also the name of a common specification trying to consolidate
    and standardize the reactive stream processing, There are several implementations
    such as RxJava/RxScala, Reactor, Akka, Slick, and Vert.x. You can find more at
    [https://github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm).
  prefs: []
  type: TYPE_NORMAL
- en: Back to the Observables -- we can perform all kinds of operations with observables.
    For instance, we can filter, select, aggregate, compose, perform time-based operations,
    and apply backpressure. There are two big wins with Observables instead of callbacks.
    First of all, Observables are not opinionated about how low-level I/O and threading
    happens, and secondly, when you are doing complex code, callbacks tend to be nested,
    and that is when things get ugly and hard to read. Observables have a simple way
    to do composition thanks to FP.
  prefs: []
  type: TYPE_NORMAL
- en: Observables push values to consumers whenever values are available, which is
    great because then the values can arrive in sync or async fashion. Rx provides
    a series of collection operators to do all sorts of data transformations you may need.
    Let's see some code now. We will use RxScala version 0.26.1, which is compatible
    with RxJava version 1.1.1+. RxScala is just a wrapper for RxJava (Created by Netflix).
    Why not use RxJava straight? Because the syntax won't be pleasant; with RxScala,
    we can have a fluent Scala experience. RxJava is great, however, Java syntax for
    this is not pleasant - as Scala is, in fact, pretty ugly.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Observables Scala with RxScala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this preceding Scala program, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Observables Scala with RxScala - Execution in the console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you try to run this code in the Scala REPL, it will fail, because we need
    the RxScala and RxJava dependencies. For this, we will need SBT and dependency
    management. Do not worry, we will cover how to work with SBT in our Scala application
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the observables, we need to import the Scala Observable. Make
    sure you get it from the Scala package, because if you get the Java one, you will
    have issues: in the very first part of the code, we will get numbers starting
    from 0 each 100 milliseconds, and this code would run forever. To avoid this,
    we use the take function to put a limit into the collection, so we will get the
    first five values. Then, later, we subscribe to the observer, and when data is
    ready, our code will run. For the first sample, it''s pretty easy, we are just
    printing the values we have got. There is a thread sleep in this program, otherwise,
    the program would terminate, and you would not see any value on the console.'
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the code does something more interesting. First of all, it
    creates an Observable from a static list of values, which are 1,2,3, and 4\. We
    apply a reduce function into the elements, which will sum all the elements with
    each other, and then we subscribe and print the result.
  prefs: []
  type: TYPE_NORMAL
- en: Complex Scala with RxScala Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding first part of the code creates an Observable with numbers from
    1 to 10, and then applies a `filter` function, which will get only the even numbers.
    It then reduces them, calculates their sum, and lastly, prints the solution. You
    can visualize it as depicted in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Complex Scala with RxScala Observables](img/image00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For the second part of the code, we create two different observables. The first
    one is with even numbers and the second one is with odd numbers. These two observables
    are decoupled from each other; you can control as many observables you want. Later
    on, the code uses a merge function to join these two observables into a third
    and new observable containing the content of the first and second observables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Complex Scala with RxScala Observables](img/image00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Merging 2 Observables
  prefs: []
  type: TYPE_NORMAL
- en: There are many functions and options, and you can see the whole list at [http://rxmarbles.com/](http://rxmarbles.com/)
    and [https://github.com/ReactiveX/RxScala](https://github.com/ReactiveX/RxScala).
    For the sake of simplicity, for now, we are just working with numbers. Later,
    we will use this to do more advance compositions including database calls and
    external web services calls.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basic concepts of FP, Reactive Programing, and
    the Scala language. We learned about the basic constructs of the Scala language
    and Functional Programming, functions, collections, and OO in Scala, and concurrent
    programming with Futures.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to use SBT to build Scala projects. We will learn how
    to compile and run Scala applications using SBT.
  prefs: []
  type: TYPE_NORMAL
