- en: Chapter 5. Multiprojects Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are familiar with the build script syntax, we are prepared to handle
    more complex project structures. In this chapter, we will focus on builds spanning
    across multiple projects, their interdependencies, and many more things in between.
  prefs: []
  type: TYPE_NORMAL
- en: As the projects code base grows, many times, it is desirable to split it into
    multiple modules based on layers, responsibilities, artifacts produced, or sometimes
    even depending on development teams, to effectively break the work down. Whatever
    is the reason, the reality is big projects are broken down into smaller subprojects
    sooner or later. Also, a build tool such as Gradle is completely capable of handling
    the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The multiproject directory layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A multiproject (or multimodule, as some prefer to call it) is a group of projects
    that are logically related to each other and often have the same develop-build-release
    cycles. The directory structure is important for laying out the strategy for building
    such projects. Typically, a top-level root project contains one or more subprojects.
    The root project may contain source sets of its own, may contain only the integration
    tests that test the integration of the subprojects, or may even act just as a
    master build without any source and tests. Gradle supports every such configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The arrangement of subprojects relative to the root project may be flat, that
    is, all the subprojects are the direct children of the root project (as shown
    in sample 1) or are hierarchical, such that the subproject may also have nested
    child projects (as shown in sample 2) or any hybrid directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s refer to the following directory structure as sample 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In sample 1, we see a fictitious example project in which all the subprojects
    are the direct children of the root project and are siblings of each other. Just
    for the sake of this example, we broke our app into three subprojects named `:repository`,
    `:services`, and `:web-app`. As their names suggest, a repository contains the
    data access code, whereas services is the layer encapsulating the business rules
    in the form of a consumable API. The `web-app` contains only the web application-specific
    code such as controllers and view templates. However, note that the `:web-app`
    project may depend on the `:services` project, which in turn may depend on the
    `:repository` project. We will soon see how these dependencies work.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse the multiproject structure with multiple source directories in
    a single project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a relatively more complex structure and call it sample 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our app has now evolved and to cater for more needs, we have added more functionalities
    to it. We have created more subprojects such as a desktop client for our app and
    a command-line interface. In sample 2, the root project is split into three projects
    (groups), which have their own child projects. In this example, every directory
    can be treated as a project. The purpose of this sample is to only show one of
    the possible directory structures. Gradle does not impose one directory structure
    over another.
  prefs: []
  type: TYPE_NORMAL
- en: One might wonder, where do we put all the `build.gradle` files and what goes
    in them? It depends on our needs and how we want to structure our build. We will
    answer all these questions shortly after we understand what is `settings.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: The settings.gradle file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During initialization, Gradle reads the `settings.gradle` file to figure out
    which projects are to take part in a build. Gradle creates an object of type `Setting`.
    This happens even before any `build.gradle` is parsed. It is usually placed in
    the root project parallel to `build.gradle`. It is recommended to put `setting.gradle`
    in the root project, otherwise we have to explicitly tell Gradle the location
    to the settings file with the command-line option `-c`. Adding these two files
    to sample 1''s directory structure would gives us something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The most common use of `settings.gradle` is to enlist all the subprojects participating
    in the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also, this is all that is required to tell Gradle that the current build is
    a multiproject build. Of course, this not the end of the story and there is a
    lot more that we can do with multiproject builds, but this is the bare minimum
    and sometimes just enough to get multiproject builds working.
  prefs: []
  type: TYPE_NORMAL
- en: The methods and properties of `Settings` are available in the `settings.gradle`
    file and are implicitly called on a `Settings` instance just the way the methods
    of `Project` API are available in the `build.gradle` file, as we saw in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Are you wondering why a colon (`:`) is used before the project name in the
    preceding section? It denotes the project path relative to the root project. However,
    the `include` method allows level 1 subproject names to omit the colon. So, the
    `include` call can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s just query the projects by calling the task `projects` from the command
    line. The `projects` task lists all the projects available in a Gradle build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In case of nesting that is more than one level deep, like in sample 2, all
    the projects must be included in the root project `settings.gradle` with the syntax
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can find more information on `Settings` at the *Settings* DSL documentation
    ([http://www.gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html](http://www.gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html))
    and the *Settings* API documentation ([http://www.gradle.org/docs/current/javadoc/org/gradle/api/initialization/Settings.html](http://www.gradle.org/docs/current/javadoc/org/gradle/api/initialization/Settings.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Organizing build logic in multiproject builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gradle gives us the flexibility to create one build file for all projects or
    individual build file per project; you can also mix and match. Let''s start with
    adding a simple task to our root project''s `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating a task with an action that just prints a message. Now, let''s
    check what tasks are available on our root project. From the `root` directory,
    let''s call the task `tasks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'No wonder, the `sayHello` task is available on the root project. However, what
    if we just want to see the tasks available on a subproject? Let''s say `:repository`.
    For a multiproject build, we can call tasks on any nested project using the `gradle
    <project-path>:<task-name>` syntax or by going into the subproject directory and
    executing `gradle <task-name>`. So now, if we execute the following code, we won''t
    see the `sayHello` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `sayHello` is only defined for the root project; hence,
    it is not available on the subproject.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a build logic to all projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Before trying to understand the code snippet, let''s run the familiar task
    again. Firstly, from the root project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from the repository project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The content inside the closure being passed to `allproject` would look exactly
    like a single-project `build.gradle` file. We can even apply plugins, declare
    repositories and dependencies, and so on. So, in essence, we can write any build
    logic that is common to all projects and then it will be applied to all projects.
    The `allprojects` method can also be used to query the project object in the current
    build. Refer to the API of the project for more details on `allprojects`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pass the `--all` flag to the `tasks` task, we will see the `whoami` task
    being present on all the child projects, in addition to the `root` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to just execute `whoami` on a specific project, let''s say `:repository`,
    it''s as simple as the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute `whoami` without any project path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Wow, Gradle goes an extra mile to ensure that the child project tasks with the
    same name are also executed when we execute the task from the parent project.
    This comes in very handy when we think about tasks such as `assemble`, where we
    actually want all the subprojects to assemble, or test, which tests the root and
    also the subprojects.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what about executing a task only on the root project? Indeed, a valid
    scenario. Remember the absolute task path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The colon makes all the difference. Here, we are referring to `whoami` of the
    `root` project only. No other task matches the same path. For example, repository's
    `whoami` has a path `repository:whoami`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `cd` in the `repository` directory and then execute the `whoami`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So the task execution is context-sensitive. Here, by default, Gradle assumes
    that the task has to be called on the current project only. Nice, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a little more dynamic code to our existing `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, depending on the project name, we are setting the task name to be `describe`,
    prefixed to the project name. So all projects get their tasks, but the name won''t
    be the same. We add an action that just prints the project name. If we execute
    the `tasks` on our project now, we can see the task names include the project
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Although the example is very trivial, we learn a few things. Firstly, the `allprojects`
    blocks are additive as most of the other methods in Gradle. We added the second
    `allprojects` block and both worked just fine. Secondly, the task name can be
    dynamically assigned, for example, using the project name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can call any of the `describe*` tasks from the project root. Also,
    as we might guess, the task name is unique; we don''t need to prepend the project
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s `cd` into the `repository` directory and list tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We see only the applicable tasks for the current project, which is `repository`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying build logic to subprojects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s continue further with our example. Here, the root project will not have
    any source sets as all the Java code is going to be in one of the three child
    projects. Hence, wouldn''t it be wise to apply a `java` plugin to only child projects?
    This is exactly where the `subprojects` method comes into the picture, that is,
    when we want to apply some build logic only on subprojects without affecting the
    parent project. Its usage is similar to `allprojects`. Let''s just apply the `java`
    plugin to all subprojects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, running `gradle tasks` should show us the tasks added by the `java` plugin
    as well. Although it might appear that these tasks are available on the root project,
    it's actually not so. Check the output of `gradle -q tasks --all` in this case.
    The tasks being there on the child project can be called from the root project,
    but this does not mean they are present on the root project. The tasks added by
    the `java` plugin will only be available on subprojects, whereas tasks such as
    help tasks will be available on all projects.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency on subprojects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the beginning of the chapter, we mentioned that a subproject might depend
    on another subproject(s) just the way it can depend on the external library dependency.
    For example, the `services` project's compilation depends on the `repository`
    project, which means we need the compiled classes from the `repository` project
    to be available on the compilation classpath of the `services` project.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we can, of course, create a `build.gradle` file in the `services`
    project and put the dependency declaration there. However, just for the sake of
    showing an alternate way, we will put this declaration in the `root` project's
    `build.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `allprojects` or `subprojects`, we need a finer mechanism to configure
    only a single project from the `root` project's `build.gradle`. As it turns out,
    it is very easy using the `project` method. This method accepts a closure just
    like the `allprojects` and `subprojects` methods in addition to the project name
    on which the closure will be applied. In the configuration phase, the closure
    is executed on that project's object.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add this to the root project''s `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are configuring dependencies only for the `services` project. In the
    `dependencies` block, we declare that the `:repository` project is the compile
    time dependency for the `services` project. This is more or less similar to the
    external library declaration; instead of the library name in the `group-id:artifact-id:version`
    notation, we used `project(:sub-project)` to refer to a subproject.
  prefs: []
  type: TYPE_NORMAL
- en: 'We had also said that the `web-app` project depends on the `services` project.
    So this time, let''s use `web-app`''s own `build.gradle` to declare this dependency.
    We will create a `build.gradle` file in the `web-app` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is a project-specific build file, we can just add the `dependencies`
    block as we would in any other project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s visualize the dependencies of the web project, using the `dependencies`
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Gradle shows us the dependencies of the `web-app` under various configurations.
    Also, we can clearly see that Gradle understands the transitive dependency; hence,
    it shows `web-app` transitively dependent on `repository` through `services`.
    Note that we have not actually declared any external dependencies (such as `servlet-api`)
    in any of the projects, otherwise they would also show up here.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth taking a look at the variations of the `configure` methods on the
    `project` object in order to filter and configure selected projects. More information
    on the `configure` method can be found at [https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short chapter, we learned that Gradle supports flexible directory structure
    for complex project hierarchies and allows us to choose the right structure for
    our build. We then looked at the importance of `settings.gradle` in the context
    of mutliprojects build. We then saw various ways of applying a build logic to
    all projects, subprojects, or only a single project. Finally, took a small example
    of inter-project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This is all we need to worry about in terms of the Gradle syntax. Now the next
    chapters will majorly focus on the functionalities that various plugins add to
    our builds and how we can configure them.
  prefs: []
  type: TYPE_NORMAL
