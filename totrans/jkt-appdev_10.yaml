- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Jakarta EE Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta EE Security standardizes application security across all Jakarta EE-compliant
    application servers. The API includes standardized access to identity stores,
    which allow a uniform way of retrieving user credentials from a relational or
    **Lightweight Directory Access Protocol** (**LDAP**) database, as well as allowing
    us to implement access to custom identity stores. Jakarta EE Security includes
    authentication mechanism support, allowing us to authenticate a user in a standard
    way. Several authentication mechanisms are supported, such as the basic authentication
    supported by most browsers, client certificates, and HTML forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Identity stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Example source code for this chapter can be found on GitHub at the following
    link: [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch10_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch10_src).'
  prefs: []
  type: TYPE_NORMAL
- en: Identity stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identity stores provide access to a persistence storage system, such as a relational
    or LDAP database, where user credentials are stored. The Jakarta EE Security API
    supports relational and LDAP databases directly, and it allows us to integrate
    with custom identity stores, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an identity store stored in a relational database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To authenticate a secured resource, such as a servlet or RESTful web service,
    against credentials stored in a relational database, annotate an application-scoped
    CDI bean with the `@DatabaseIdentityStoreDefinition` annotation, as illustrated
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the JNDI name for the JDBC connection for the relational database
    containing user credentials is `java:global/jdbc/userauthdbDatasource`, which
    is the value we provided to the `dataSourceLookup` attribute of the `@``DatabaseIdentityStoreDefinition`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The `callerQuery` parameter of `@DatabaseIdentityStoreDefinition` is used to
    specify the SQL query used to retrieve the username and password for the user
    we are authenticating. The values retrieved from the database must match the values
    provided by the user (via an authentication mechanism, which we will discuss in
    the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Most secured applications have different types of users, separated into roles;
    for example, an application could have “regular” users plus administrators. Administrators
    would be allowed to perform certain actions that regular users would not. For
    example, administrators could be able to reset user passwords and add or remove
    users from the system. The `groupsQuery` attribute of `@DatabaseIdentityStoreDefinition`
    allows us to retrieve all roles for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an identity store stored in an LDAP database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To secure resources against credentials stored in an LDAP database, we need
    to annotate the resource to be secured (such as a servlet or RESTful web service)
    with the `@LdapIdentityStoreDefinition` annotation; the following example illustrates
    how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `url` attribute of `@LdapIdentityStoreDefinition` is used to specify the
    URL of the LDAP server containing user credentials for our application; its `callerBaseDn`
    attribute is used to specify the LDAP base distinguished name to verify user credentials
    supplied by the user, and, finally, its `groupSearchBase` attribute is used to
    retrieve the roles for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Custom identity stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, we may need to integrate our application security with an identity
    store not directly supported by the Security API. For example, we may have a requirement
    to integrate with an existing commercial security product. For such cases, the
    Jakarta EE Security API allows us to roll out our own identity store definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle custom identity stores, we need to create an application-scoped CDI
    bean (refer to [*Chapter 2*](B21231_02.xhtml#_idTextAnchor022)), and the bean
    must implement the `IdentityStore` interface, as illustrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `validate()` method is defined in the `IdentityStore` interface provided
    by the security API in our example. We implement this method so that we can use
    custom validation in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are hard coding valid credentials into the code; do not do
    this for real applications as this would be a major security risk.
  prefs: []
  type: TYPE_NORMAL
- en: The `validate()` method defined in the `IdentityStore` interface accepts an
    instance of a class implementing the `Credential` interface as its sole argument.
    In the body of our method, we cast it down to `UserNamePasswordCredential`, and
    then we invoke its `compareTo()` method, passing the expected username and password.
    If the provided credentials match either one of the expected set of credentials,
    then we allow the user to successfully log in. We do this by returning an instance
    of `CredentialValidationResult` containing the username and `Set` containing all
    the roles that the user has in our application.
  prefs: []
  type: TYPE_NORMAL
- en: If the supplied credentials don’t match either of the expected credentials,
    then we prevent the user from logging in by returning `CredentialValidationResult.INVALID_RESULT`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to access user credential information via identity
    stores, we’ll focus our attention on the different authentication mechanisms provided
    by Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication mechanisms provide a way for the user to provide their credentials
    so that they can be authenticated against an identity store.
  prefs: []
  type: TYPE_NORMAL
- en: The Jakarta EE Security API provides support for the HTTP Basic authentication
    mechanism provided by most browsers, as well as form authentication, which is
    the most common authentication mechanism where users provide their credentials
    via an HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: Form authentication by default submits a form to the security servlet provided
    by the Jakarta EE implementation. If we need more flexibility or to better align
    with other Jakarta EE technologies, the Security API provides custom form authentication
    as well, which allows us as application developers to have more control over how
    to authenticate users attempting to access our application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A basic authentication mechanism can be achieved by annotating the resource
    as secure (i.e, a servlet or RESTful web service) with the `@``BasicAuthenticationMechanismDefinition`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We declare the user roles that are allowed to access the secured resource via
    the `@HttpConstraint` annotation, which is an attribute of the `@ServletSecurity`
    annotation. In our example, only users with the `admin` role are allowed to access
    the secured resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using basic authentication will cause a window to pop up in the browser asking
    for a username and a password, as illustrated in *Figure 10**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Basic authentication login prompt](img/B21231_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Basic authentication login prompt
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user enters the correct credentials and has the necessary role, access
    is granted to the protected resource, as shown in *Figure 10**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Successful basic authentication](img/B21231_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Successful basic authentication
  prefs: []
  type: TYPE_NORMAL
- en: If the user enters incorrect credentials, the login popup will show up again,
    allowing the user to re-enter their credentials.
  prefs: []
  type: TYPE_NORMAL
- en: If the user enters the correct credentials but does not have the appropriate
    role to access the protected resource, the server will return an HTTP 403 error
    code, indicating that the user is forbidden from accessing the protected resource.
  prefs: []
  type: TYPE_NORMAL
- en: Form authentication mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way we can authenticate our users is to develop an HTML form to collect
    the user’s credentials, and then delegate authentication to the Jakarta EE Security
    API. The first step when following this approach is to develop an HTML page containing
    a form where the user can log in to the application, as illustrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the example, the HTML form used for logging in must submit an HTTP
    POST request, and the value for its `action` attribute must be `j_security_check`.
    Now, `j_security_check` maps to a servlet provided by the Jakarta EE Security
    API. We don’t need to develop any validation logic ourselves. The form must have
    a couple of input fields, one for the username and one for the password. The names
    for these fields must be `j_username` and `j_password` respectively; the security
    servlet provided by the Jakarta EE API will retrieve these values and authenticate
    the user automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we need to provide an HTML page where the user will be redirected
    if login fails. The page can have any valid HTML markup. In our example, we simply
    provide an error message and a link to direct the user back to the login page
    so that they can try to log in again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side, all we need to do is annotate the secured resource with
    the `@FormAuthenticationMechanismDefinition` annotation, which will let the Jakarta
    EE Security API know we are using form-based authentication, and what HTML pages
    to use to log in or to display when logging in fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@FormAuthenticationMechanismDefinition` annotation has a required `loginToContinue`
    attribute. The value of this attribute must be an instance of the `@LoginToContinue`
    annotation. `@LoginToContinue` has two required attributes: `loginPage` and `errorPage`.
    The value of these attributes must indicate the path for the login page and the
    path of the page to display in case of authentication failure, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After building and deploying our code, and then attempting to access a protected
    resource, the user is automatically redirected to our login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Form authentication mechanism](img/B21231_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Form authentication mechanism
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user enters the correct credentials and has the appropriate role, then
    access to the protected resource is granted, as illustrated in *Figure 10**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Successful form authentication](img/B21231_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Successful form authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'If invalid credentials are entered, then the user is directed to our custom
    error page, as shown in *Figure 10**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Unsuccessful form authentication](img/B21231_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Unsuccessful form authentication
  prefs: []
  type: TYPE_NORMAL
- en: Custom form authentication mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way we can authenticate users in our application is to use a **custom
    form authentication mechanism**. This type of authentication mechanism is useful
    when we want to integrate our application with a web framework, such as Jakarta
    Faces. In our next example, we will illustrate how to do just that: integrating
    the Jakarta EE Security API with Jakarta Faces via custom form authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use custom form authentication in our applications, we need to use the aptly
    named `@CustomFormAuthenticationMechanismDefinition` annotation, as illustrated
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just like `@FormAuthenticationMechanismDefinition` we saw previously, the `@CustomFormAuthenticationMechanismDefinition`
    annotation has a `loginToContinue` attribute that takes an instance of the `@LoginToContinue`
    annotation as its value. In this case, since we are integrating with Jakarta Faces,
    the value of the `loginPage` attribute of `@LoginToContinue` must point to the
    path of a Facelets page used for the user to log in. When using Jakarta Faces
    to authenticate the user, it is expected that the login page will display an error
    message if authentication fails. Therefore, we need to leave the `errorPage` attribute
    of `@``LoginToContinue` blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our login page is a standard Facelets page that collects user credentials and
    redirects to a CDI bean that acts as a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our login page has input fields for `userName` and `password`, and it stores
    those values in a CDI named bean (not shown as it is trivial) via value binding
    expressions. When the user clicks on the `loginController` CDI named bean that
    performs the actual authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our `LoginController` class, we need to inject an instance of `jakarta.security.enterprise.SecurityContext`
    since we will need it for authentication. We implement the authentication logic
    in our `login()` method. The first thing we need to do is create an instance of
    `UsernamePasswordCredential`, passing the user-entered username and password as
    parameters to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We then create an instance of `jakarta.security.enterprise.authentication.mechanism.http.AuthenticationParameters`
    by invoking the static `withParams()` method on `AuthenticationParameters`, then
    invoking the `credential()` method on the resulting instance of `AuthenticationParameters`,
    and passing the instance of `UserNamePasswordCredential` we just created as a
    parameter. This returns yet another instance of `AuthenticationParameters`, which
    we can use to actually validate the user-entered credentials.
  prefs: []
  type: TYPE_NORMAL
- en: We validate user-entered credentials by invoking the `authenticate()` method
    on our `SecurityContext` instance, passing the HTTP `Request` and `Response` objects
    as parameters, as well as the instance of `AuthenticationParameters` containing
    the user-entered credentials. This method invocation will return an instance of
    `AuthenticationStatus`. We need to check the returned instance to determine whether
    the user entered valid credentials.
  prefs: []
  type: TYPE_NORMAL
- en: If `SecurityContext.authenticate()` returns `AuthenticationStatus.SEND_CONTINUE`,
    then the user-entered credentials are valid, and we can allow the user to access
    the requested resource. If instead, the method returns `AuthenticationStatus.SEND_FAILURE`,
    then the user-entered credentials are invalid, and we need to prevent the user
    from accessing the protected resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'After deploying and running our application, when a user attempts to access
    a protected resource, he is automatically redirected to a login page, which in
    this case, since we are using custom form authentication, is implemented using
    Jakarta Faces. This is illustrated in *Figure 10**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Custom form authentication](img/B21231_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Custom form authentication
  prefs: []
  type: TYPE_NORMAL
- en: Entering correct credentials directs the user to the protected resource (not
    shown) while entering incorrect credentials directs the user back to the login
    page, which should show an appropriate error message as shown in *Figure 10**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Custom form authentication failure](img/B21231_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Custom form authentication failure
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that custom form authentication is flexible enough to integrate
    with any web application framework, although it is most commonly used with Jakarta
    Faces as discussed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the Jakarta Security API. We discussed the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to access different types of identity stores to retrieve user credentials,
    such as relational databases or LDAP databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Security API provides the ability to integrate with custom identity
    stores, in case we need to access one not directly supported, and how to use different
    authentication mechanisms to allow access to our secured Jakarta EE applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement the basic authentication mechanism provided by all web browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a form-based authentication mechanism, where we provide custom
    HTML pages used for authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use custom form authentication, so that we can integrate our application
    security with a web framework such as Jakarta Faces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the security features provided by Jakarta EE allows us to develop secure
    applications. The API is flexible enough to allow integration with arbitrary data
    stores, as well as any Java web application framework.
  prefs: []
  type: TYPE_NORMAL
