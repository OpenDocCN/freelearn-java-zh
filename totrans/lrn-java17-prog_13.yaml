- en: '*Chapter 11*: Network Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will describe and discuss the most popular network protocols
    – **User Datagram Protocol** (**UDP**), **Transmission Control Protocol** (**TCP**),
    **HyperText Transfer Protocol** (**HTTP**), and **WebSocket** – and their support
    from the **Java Class Library** (**JCL**). We will demonstrate how to use these
    protocols and how to implement client-server communication in Java code. We will
    also review **Uniform Resource Locator** (**URL**)-based communication and the
    latest **Java HTTP Client API**. After studying this chapter, you will be able
    to create server and client applications that communicate using the **UDP**, **TCP**,
    and **HTTP** protocols as well as **WebSocket**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Network protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDP-based communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP-based communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDP versus TCP protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL-based communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the HTTP 2 Client API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a standalone application HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to use all the most popular protocols
    to send/receive messages between the client and server. You will also learn how
    to create a server as a separate project and how to create and use a common shared
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or code editor of your choosing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*, of this book. The files with the code examples for this chapter are
    available on GitHub in the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository, in the `examples/src/main/java/com/packt/learnjava/ch11_network` folder,
    and in the `common` and `server` folders, as separate projects.
  prefs: []
  type: TYPE_NORMAL
- en: Network protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Network programming is a vast area. The **internet protocol** (**IP**) suite
    consists of four layers, each of which has a dozen or more protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The link layer**: The group of protocols used when a client is physically
    connected to the host; three core protocols include the **Address Resolution Protocol**
    (**ARP**), the **Reverse Address Resolution** **Protocol** (**RARP**), and the
    **Neighbor Discovery Protocol** (**NDP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10011010.00010111.11111110.00010001`, which results in an IP address of `154.23.254.17`.
    The examples in this chapter use IPv4\. The industry, though, is slowly switching
    to IPv6\. An example of an IPv6 address is `594D:1A1B:2C2D:3E3F:4D4A:5B5A:6B4E:7FF2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The transport layer**: The group of host-to-host communication services.
    It includes TCP, also known as the TCP/IP protocol, and UDP (which we are going
    to discuss shortly). The other protocols in this group are the **Datagram Congestion
    Control Protocol** (**DCCP**) and the **Stream Control Transmission Protocol**
    (**SCTP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The application layer**: The group of protocols and interface methods used
    by hosts in a communication network. It includes **Telnet**, **File Transfer Protocol**
    (**FTP**), **Domain Name System** (**DNS**), **Simple Mail Transfer Protocol**
    (**SMTP**), **Lightweight Directory Access Protocol** (**LDAP**), **Hypertext
    Transfer Protocol** (**HTTP**), **Hypertext Transfer Protocol Secure** (**HTTPS**),
    and **Secure Shell** (**SSH**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The link layer is the lowest layer; it is used by the internet layer, which
    is, in turn, used by the transport layer. This transport layer is then used by
    the application layer in support of the protocol implementations.
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, Java does not provide access to the protocols of the link
    layer and the internet layer. This means that Java does not allow you to create
    custom transport protocols that, for example, serve as an alternative to TCP/IP.
    That is why, in this chapter, we will review only the protocols of the transport
    layer (TCP and UDP) and the application layer (HTTP). We will explain and demonstrate
    how Java supports them and how a Java application can take advantage of this support.
  prefs: []
  type: TYPE_NORMAL
- en: Java supports the TCP and UDP protocols with classes of the `java.net` package,
    while the HTTP protocol can be implemented in the Java application using the classes
    of the `java.net.http` package (which was introduced with Java 11).
  prefs: []
  type: TYPE_NORMAL
- en: Both the TCP and UDP protocols can be implemented in Java using *sockets*. Sockets
    are identified by a combination of an IP address and a port number, and they represent
    a connection between two applications. Since the UDP protocol is somewhat simpler
    than the TCP protocol, we’ll start with UDP.
  prefs: []
  type: TYPE_NORMAL
- en: UDP-based communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UDP protocol was designed by David P. Reed in 1980\. It allows applications
    to send messages called **datagrams** using a simple connectionless communication
    model with a minimal protocol mechanism such as a checksum, for data integrity.
    It has no handshaking dialogs and, thus, does not guarantee message delivery or
    preserve the order of messages. It is suitable for those cases when dropping messages
    or mixing up orders are preferred instead of waiting for retransmission.
  prefs: []
  type: TYPE_NORMAL
- en: 'A datagram is represented by the `java.net.DatagramPacket` class. An object
    of this class can be created using one of the six constructors; the following
    two constructors are the most commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DatagramPacket(byte[] buffer, int length)`: This constructor creates a datagram
    packet and is used to receive the packets; `buffer` holds the incoming datagram,
    while `length` is the number of bytes to be read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatagramPacket(byte[] buffer, int length, InetAddress address, int port)`:
    This creates a datagram packet and is used to send the packets; `buffer` holds
    the packet data, `length` is the packet data length, `address` holds the destination
    IP address, and `port` is the destination port number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once constructed, the `DatagramPacket` object exposes the following methods
    that can be used to extract data from the object or set/get its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void setAddress(InetAddress iaddr)`: This sets the destination IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InetAddress getAddress()`: This returns the destination or source IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void setData(byte[] buf)`: This sets the data buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void setData(byte[] buf, int offset, int length)`: This sets the data buffer,
    data offset, and length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void setLength(int length)`: This sets the length for the packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[] getData()`: This returns the data buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int getLength()`: This returns the length of the packet that is to be sent
    or received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int getOffset()`: This returns the offset of the data that is to be sent or
    received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void setPort(int port)`: This sets the destination port number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int getPort()`: This returns the port number where data is to be sent or received
    from. Once a `DatagramPacket` object is created, it can be sent or received using
    the `DatagramSocket` class, which represents a connectionless socket for sending
    and receiving datagram packets. An object of this class can be created using one
    of six constructors; the following three constructors are the most commonly used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatagramSocket()`: This creates a datagram socket and binds it to any available
    port on the local host machine. It is typically used to create a sending socket
    because the destination address (and port) can be set inside the packet (see the
    preceding `DatagramPacket` constructors and methods).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatagramSocket(int port)`: This creates a datagram socket and binds it to
    the specified port on the local host machine. It is used to create a receiving
    socket when any local machine address (called a `DatagramSocket(int port, InetAddress
    address)`: This creates a datagram socket and binds it to the specified port and
    the specified local address; the local port must be between `0` and `65535`. It
    is used to create a receiving socket when a particular local machine address needs
    to be bound.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two methods of the `DatagramSocket` object are the most commonly
    used for sending and receiving messages (or packets):'
  prefs: []
  type: TYPE_NORMAL
- en: '`void send(DatagramPacket p)`: This sends the specified packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void receive(DatagramPacket p)`: This receives a packet by filling the specified
    `DatagramPacket` object’s buffer with the data received. The specified `DatagramPacket`
    object also contains the sender’s IP address and the port number on the sender’s
    machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at a code example. Here is the UDP message receiver that
    exits after the message has been received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the receiver is listening for a text message (it interprets
    each byte as a character) on any address of the local machine on port `3333`.
    It uses a buffer of 16 bytes only; as soon as the buffer is filled with the received
    data, the receiver prints its content and exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the UDP message sender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the sender constructs a packet with the message, the local machine
    address, and the same port as the one that the receiver uses. After the constructed
    packet is sent, the sender exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the sender now, but without the receiver running, there is nobody
    to get the message. So, we’ll start the receiver first. It listens on port `3333`,
    but there is no message coming – so it waits. Then, we run the sender and the
    receiver displays the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the buffer is smaller than the message, it was only partially received
    – the rest of the message is lost. That’s why we increase the buffer size to 30\.
    Also, we can create an infinite loop and let the receiver run indefinitely (see
    the `UdpReceiver2` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing so, we can run the sender several times. Here is what the receiver
    `UdpReceiver2` prints if we run the sender three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, all three messages are received. If you run the receiver `UdpReceiver2`,
    do not forget to stop it manually after you don’t need to run it anymore. Otherwise,
    it continues running indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: So, this is the basic idea of the UDP protocol. The sender sends a message to
    a certain address and port even if no socket *listens* on this address and port.
    It does not require establishing any kind of connection before sending the message,
    which makes the UDP protocol faster and more lightweight than the TCP protocol
    (which requires you to establish the connection first). This way, the TCP protocol
    takes message sending to another level of reliability by making sure that the
    destination exists and that the message can be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: TCP-based communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP was designed by the **Defense Advanced Research Projects Agency** (**DARPA**)
    in the 1970s for use in the **Advanced Research Projects Agency Network** (**ARPANET**).
    It complements IP and, thus, is also referred to as TCP/IP. The TCP protocol,
    even by its name, indicates that it provides reliable (that is, error-checked
    or controlled) data transmission. It allows the ordered delivery of bytes in an
    IP network and is widely used by the web, email, secure shell, and file transfer.
  prefs: []
  type: TYPE_NORMAL
- en: An application that uses TCP/IP is not even aware of all the handshaking that
    takes place between the socket and the transmission details – such as network
    congestion, traffic load balancing, duplication, and even the loss of some IP
    packets. The underlying protocol implementation of the transport layer detects
    these problems, resends the data, reconstructs the order of the sent packets,
    and minimizes network congestion.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the UDP protocol, TCP/IP-based communication is focused on accurate
    delivery at the expense of the delivery period. That’s why it is not used for
    real-time applications, such as voice over IP, where reliable delivery and correct
    sequential ordering are required. However, if every bit needs to arrive exactly
    as it was sent and in the same sequence, then TCP/IP is irreplaceable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support such behavior, TCP/IP communication maintains a session throughout
    the communication. The session is identified by the client address and port. Each
    session is represented by an entry in a table on the server. This contains all
    the metadata about the session: the client IP address and port, the connection
    status, and the buffer parameters. However, these details are usually hidden from
    the application developer, so we won’t go into any more detail here. Instead,
    we will turn to the Java code.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the UDP protocol, the TCP/IP protocol implementation in Java uses
    sockets. But instead of the `java.net.DatagramSocket` class that implements the
    UDP protocol, the TCP/IP-based sockets are represented by the `java.net.ServerSocket`
    and `java.net.Socket` classes. They allow messages to be sent and received between
    two applications, one of them being a server and the other a client.
  prefs: []
  type: TYPE_NORMAL
- en: The `ServerSocket` and `SocketClass` classes perform very similar jobs. The
    only difference is that the `ServerSocket` class has the `accept()` method, which
    *accepts* the request from the client. This means that the server has to be up
    and ready to receive the request first. Then, the connection is initiated by the
    client that creates its own socket that sends the connection request (from the
    constructor of the `Socket` class). The server then accepts the request and creates
    a local socket connected to the remote socket (on the client side).
  prefs: []
  type: TYPE_NORMAL
- en: After establishing the connection, data transmission can occur using I/O streams
    as described in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121), *Strings,
    Input/Output, and Files*. The `Socket` object has the `getOutputStream()` and
    `getInputStream()` methods that provide access to the socket’s data streams. Data
    from the `java.io.OutputStream` object on the local computer appears as coming
    from the `java.io.InputStream` object on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a closer look at the `java.net.ServerSocket` and `java.net.Socket`
    classes and then run some examples of their usage.
  prefs: []
  type: TYPE_NORMAL
- en: The java.net.ServerSocket class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `java.net.ServerSocket` class has four constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ServerSocket()`: This creates a server socket object that is not bound to
    a particular address and port. It requires the use of the `bind()` method to bind
    the socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServerSocket(int port)`: This creates a server socket object bound to the
    provided port. The `port` value must be between `0` and `65535`. If the port number
    is specified as a value of `0`, this means that the port number needs to be bound
    automatically. This port number can then be retrieved by calling `getLocalPort()`.
    By default, the maximum queue length for incoming connections is `50`. This means
    that the maximum parallel incoming connections are `50` by default. Exceeding
    connections will be refused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServerSocket(int port, int backlog)`: This provides the same functionality
    as the `ServerSocket(int port)` constructor and allows you to set the maximum
    queue length for incoming connections by means of the `backlog` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServerSocket(int port, int backlog, InetAddress bindAddr)`: This creates a
    server socket object that is similar to the preceding constructor, but also bound
    to the IP address provided. When the `bindAddr` value is `null`, it will default
    to accepting connections on any or all local addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following four methods of the `ServerSocket` class are the most commonly
    used, and they are essential for establishing a socket’s connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void bind(SocketAddress endpoint)`: This binds the `ServerSocket` object to
    a specific IP address and port. If the provided address is `null`, then the system
    will pick up a port and a valid local address automatically (which can be later
    retrieved using the `getLocalPort()`, `getLocalSocketAddress()`, and `getInetAddress()`
    methods). Additionally, if the `ServerSocket` object was created by the constructor
    without any parameters, then this method, or the following `bind()` method, needs
    to be invoked before a connection can be established.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void bind(SocketAddress endpoint, int backlog)`: This acts in a similar way
    to the preceding method; the `backlog` argument is the maximum number of pending
    connections on the socket (that is, the size of the queue). If the `backlog` value
    is less than or equal to `0`, then an implementation-specific default will be
    used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void setSoTimeout(int timeout)`: This sets the value (in milliseconds) of
    how long the socket waits for a client after the `accept()` method is called.
    If the client has not called and the timeout expires, a `java.net.SocketTimeoutException`
    exception is thrown, but the `ServerSocket` object remains valid and can be reused.
    The `timeout` value of `0` is interpreted as an infinite timeout (the `accept()`
    method blocks until a client calls).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Socket accept()`: This blocks until a client calls or the timeout period (if
    set) expires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other methods of the class allow you to set or get other properties of the `Socket`
    object and they can be used for better dynamic management of the socket connection.
    You can refer to the online documentation of the class to understand the available
    options in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a server implementation using the `ServerSocket`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the preceding code. In the try-with-resources statement,
    we create `Socket`, `DataInputStream`, and `DataOutputStream` objects based on
    our newly created socket, and the `BufferedReader` object to read the user input
    from the console (we will use it to enter the data). While creating the socket,
    the `accept()` method blocks until a client tries to connect to port `3333` of
    the local server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code enters an infinite loop. First, it reads the bytes sent by the
    client as a Unicode character string encoded in a modified UTF-8 format by using
    the `readUTF()` method of `DataInputStream`. The result is printed with the `"Client
    said: "` prefix. If the received message is an `"end"` string, then the code exits
    the loop and the server’s program exits. If the message is not `"end"`, then the
    `"Say something: "` prompt is displayed on the console and the `readLine()` method
    blocks until a user types something and clicks *Enter*.'
  prefs: []
  type: TYPE_NORMAL
- en: The server takes the input from the screen and writes it as a Unicode character
    string to the output stream using the `writeUtf()` method. As we mentioned already,
    the output stream of the server is connected to the input stream of the client.
    If the client reads from the input stream, it receives the message sent by the
    server. If the sent message is `"end"`, then the sever exits the loop and the
    program. If not, then the loop body is executed again.
  prefs: []
  type: TYPE_NORMAL
- en: The described algorithm assumes that the client exits only when it sends or
    receives the `"end"` message. Otherwise, the client generates an exception if
    it tries to send a message to the server afterward. This demonstrates the difference
    between the UDP and TCP protocols that we mentioned already – TCP is based on
    the session that is established between the server and client sockets. If one
    side drops it, the other side immediately encounters an error.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s review an example of a TCP-client implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The java.net.Socket class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `java.net.Socket` class should now be familiar to you since it was used
    in the preceding example. We used it to access the input and output streams of
    the connected sockets. Now we are going to review the `Socket` class systematically
    and explore how it can be used to create a TCP client. The `Socket` class has
    five constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Socket()`: This creates an unconnected socket. It uses the `connect()` method
    to establish a connection of this socket with a socket on a server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Socket(String host, int port)`: This creates a socket and connects it to the
    provided port on the `host` server. If it throws an exception, the connection
    to the server is not established; otherwise; you can start sending data to the
    server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Socket(InetAddress address, int port)`: This acts similarly to the preceding
    constructor, except that the host is provided as an `InetAddress` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Socket(String host, int port, InetAddress localAddr, int localPort)`: This
    works similarly to the preceding constructor, except that it also allows you to
    bind the socket to the provided local address and port (if the program is run
    on a machine with multiple IP addresses). If the provided `localAddr` value is
    `null`, any local address is selected. Alternatively, if the provided `localPort`
    value is `null`, then the system picks up a free port in the bind operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Socket(InetAddress address, int port, InetAddress localAddr, int localPort)`:
    This acts similarly to the preceding constructor, except that the local address
    is provided as an `InetAddress` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the following two methods of the `Socket` class that we have used
    already:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InputStream getInputStream()`: This returns an object that represents the
    source (the remote socket) and brings the data (inputs them) into the program
    (the local socket).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OutputStream getOutputStream()`: This returns an object that represents the
    source (the local socket) and sends the data (outputs them) to a remote socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s now examine the TCP-client code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `TcpClient` code looks almost exactly the same as the `TcpServer`
    code we reviewed. The only principal difference is that the `new Socket("localhost",
    3333)` constructor attempts to establish a connection with the `"localhost:3333"`
    server immediately, so it expects that the `localhost` server is up and listening
    on port `3333`; the rest is the same as the server code.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the only reason we need to use the `ServerSocket` class is to allow
    the server to run while waiting for the client to connect to it; everything else
    can be done using only the `Socket` class.
  prefs: []
  type: TYPE_NORMAL
- en: Other methods of the `Socket` class allow you to set or get other properties
    of the `socket` object, and they can be used for better dynamic management of
    the socket connection. You can read the online documentation of the class to understand
    the available options in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Running the examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now run the `TcpServer` and `TcpClient` programs. If we start `TcpClient`
    first, we get `java.net.ConnectException` with the `TcpServer` program first.
    When it starts, no messages are displayed. Instead, it just waits until the client
    connects. So, we then start `TcpClient` and see the following message on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We type `Hello!` and then press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let’s look at the server-side screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We type `Hi!` on the server-side screen and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the client-side screen, we see the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can continue this dialog indefinitely until the server or the client sends
    the message `end`. Let’s make the client do it; the client says `end` and then
    exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the server follows suit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That’s all we wanted to demonstrate while discussing the TCP protocol. Now let’s
    review the differences between the UDP and TCP protocols.
  prefs: []
  type: TYPE_NORMAL
- en: UDP versus TCP protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The differences between the UDP and TCP/IP protocols can be listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: UDP simply sends data, whether the data receiver is up and running or not. That’s
    why UDP is better suited to sending data compared to many other clients using
    multicast distribution. TCP, on the other hand, requires establishing the connection
    between the client and the server first. The TCP client sends a special control
    message; the server receives it and responds with a confirmation. The client then
    sends a message to the server that acknowledges the server confirmation. Only
    after this is data transmission between the client and server possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP guarantees message delivery or raises an error, while UDP does not, and
    a datagram packet may be lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP guarantees the preservation of the order of messages on delivery, while
    UDP does not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result of these provided guarantees, TCP is slower than UDP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, protocols require headers to be sent along with the packet. The
    header size of a TCP packet is 20 bytes, while a datagram packet is 8 bytes. The
    UDP header contains `Length`, `Source Port`, `Destination Port`, and `Checksum`,
    while the TCP header contains `Sequence Number`, `Ack Number`, `Data Offset`,
    `Reserved`, `Control Bit`, `Window`, `Urgent Pointer`, `Options`, and `Padding`,
    in addition to the UDP headers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different application protocols are based on the TCP or UDP protocols. The **TCP**-based
    protocols are **HTTP**, **HTTPS**, **Telnet**, **FTP**, and **SMTP**. The **UDP**-based
    protocols are **Dynamic Host Configuration Protocol** (**DHCP**), **DNS**, **Simple
    Network Management Protocol** (**SNMP**), **Trivial File Transfer Protocol** (**TFTP**),
    **Bootstrap Protocol** (**BOOTP**), and early versions of the **Network File System**
    (**NFS**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can capture the difference between UDP and TCP in one sentence: the UDP
    protocol is faster and more lightweight than TCP, but less reliable. As with many
    things in life, you have to pay a higher price for additional services. However,
    not all these services will be needed in all cases, so think about the task at
    hand and decide which protocol to use based on your application requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: URL-based communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, it seems that everybody has some notion of a URL; those who use a
    browser on their computers or smartphones will see URLs every day. In this section,
    we will briefly explain the different parts that make up a URL and demonstrate
    how it can be used programmatically to request data from a website (or a file)
    or to send (post) data to a website.
  prefs: []
  type: TYPE_NORMAL
- en: The URL syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generally speaking, the URL syntax complies with the syntax of a **Uniform
    Resource Identifier** (**URI**) that has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The square brackets indicate that the component is optional. This means that
    a URI will consist of `scheme:path` at the very least. The `scheme` component
    can be `http`, `https`, `ftp`, `mailto`, `file`, `data`, or another value. The
    `path` component consists of a sequence of path segments separated by a slash
    (`/`). Here is an example of a URL consisting only of `scheme` and `path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding URL points to a file on a local filesystem that is relative to
    the directory where this URL is used. And here are examples that you are more
    familiar with: [https://www.google.com](https://www.google.com), [https://www.packtpub.com](https://www.packtpub.com).
    We will demonstrate how it works shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `path` component can be empty, but then the URL would seem useless. Nevertheless,
    an empty path is often used in conjunction with `authority`, which has the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The only required component of authority is `host`, which can be either an IP
    address (`137.254.120.50`, for example) or a domain name (`oracle.com`, for example).
  prefs: []
  type: TYPE_NORMAL
- en: The `userinfo` component is typically used with the `mailto` value of the `scheme`
    component, so `userinfo@host` represents an email address.
  prefs: []
  type: TYPE_NORMAL
- en: The `port` component, if omitted, assumes a default value. For example, if the
    `scheme` value is `http`, then the default `port` value is `80`, and if the `scheme`
    value is `https`, then the default `port` value is `443`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An optional `query` component of a URL is a sequence of key-value pairs separated
    by a delimiter (`&`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the optional `fragment` component is an identifier of a section of
    an HTML document, meaning that a browser can scroll this section into view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'It is necessary to mention that Oracle''s online documentation uses slightly
    different terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: '`protocol` instead of `scheme`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reference` instead of `fragment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file` instead of `path[?query][#fragment]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource` instead of `host[:port]path[?query][#fragment]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, from the Oracle documentation perspective, the URL is composed of `protocol`
    and `resource` values.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a look at the programmatic usage of URLs in Java.
  prefs: []
  type: TYPE_NORMAL
- en: The java.net.URL class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java, a URL is represented by an object of the `java.net.URL` class that
    has six constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`URL(String spec)`: This creates a `URL` object from the URL as a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URL(String protocol, String host, String file)`: This creates a `URL` object
    from the provided values of `protocol`, `host`, and `file` (`path` and `query`),
    and the default port number based on the `protocol` value provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URL(String protocol, String host, int port, String path)`: This creates a
    `URL` object from the provided values of `protocol`, `host`, `port`, and `file`
    (`path` and `query`). A `port` value of `-1` indicates that the default port number
    needs to be used based on the `protocol` value provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URL(String protocol, String host, int port, String file, URLStreamHandler
    handler)`: This acts in the same way as the preceding constructor and additionally
    allows you to pass in an object of the particular protocol handler; all the preceding
    constructors load default handlers automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URL(URL context, String spec)`: This creates a `URL` object that extends the
    `URL` object provided or overrides its components using the `spec` value provided,
    which is a string representation of a URL or some of its components. For example,
    if the scheme is present in both parameters, the scheme value from `spec` overrides
    the scheme value in `context` and many others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URL(URL context, String spec, URLStreamHandler handler)`: This acts in the
    same way as the preceding constructor and additionally allows you to pass in an
    object of the particular protocol handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once created, a `URL` object allows you to get the values of various components
    of the underlying URL. The `InputStream openStream()` method provides access to
    the stream of data received from the URL. In fact, it is implemented as `openConnection.getInputStream()`.
    The `URLConnection openConnection()` method of the `URL` class returns a `URLConnection`
    object with many methods that provide details about the connection to the URL,
    including the `getOutputStream()` method that allows you to send data to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the `UrlFileReader` code example that reads data from
    a `hello.txt` file, which is a local file that we created in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121),
    *Strings, Input/Output, and Files*. The file contains only one line: `Hello!`;
    here is the code that reads it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used a class loader to access the resource (`hello.txt`
    file) and construct a URL that points to it.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the preceding code is opening an input stream of data from a file
    and prints the incoming bytes as characters. The result is shown in the inline
    comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s demonstrate how Java code can read data from the URL that points
    to a source on the internet. Let’s call the Google search engine with the `Java`
    keyword (the `UrlSiteReader` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Here, we came up with the [https://www.google.com/search?q=Java&num=10](https://www.google.com/search?q=Java&num=10)
    URL and requested the properties after some research and experimentation. There
    is no guarantee that it will always work, so do not be surprised if it does not
    return the same data we describe. Besides, it is a live search, so the result
    may change at any time. When it works, Google will return pages of data.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code also demonstrates the difference in the values returned by
    the `getPath()` and `getFile()` methods. You can view the inline comments in the
    preceding code example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In comparison to the example of using a file URL, the Google search example
    used the `URLConnection` object because we need to set the request header fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Accept` tells the server what type of content the caller requests (`understands`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Connection` tells the server that the connection will be closed after the
    response is received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Accept-Language` tells the server which language the caller requests (`understands`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User-Agent` tells the server information about the caller; otherwise, the
    Google search engine (`www.google.com`) responds with a 403 (forbidden) HTTP code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The remaining code in the preceding example just reads from the input stream
    of data (HTML code) coming from the URL and prints it, line by line. We captured
    the result (copied it from the screen), pasted it into the online HTML Formatter
    ([https://jsonformatter.org/html-pretty-print](https://jsonformatter.org/html-pretty-print)),
    and ran it. The result is presented in the following screenshot and this may be
    different when you run it since Google functionality is evolving over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it looks like a typical page with the search results, except
    there is no Google image in the upper-left corner with the returned HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Beware that if you execute this code many times, Google may block your IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, it is possible to send (post) data to a URL. Here is an example
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code expects a server running on the `localhost` server on port
    `3333` that can process the `POST` request with the `"/something"` path. If the
    server does not check the method (is it `POST` or any other HTTP method) and it
    does not check the `User-Agent` value, there is no need to specify any of it.
    So, we comment the settings out and keep them there just to demonstrate how these,
    and similar, values can be set if required.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we used the `setDoOutput()` method to indicate that output has to
    be sent; by default, it is set to `false`. Then, we let the output stream send
    the query parameters to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of the preceding code is that the output stream has
    to be closed before the input stream is opened. Otherwise, the content of the
    output stream will not be sent to the server. While we did it explicitly, a better
    way to do it is by using the try-with-resources block that guarantees the `close()`
    method is called, even if an exception was raised anywhere in the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a better version of the preceding example (using try-with-resources
    blocks) in the `UrlPost` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code calls the `localhost` server on port `3333` with the
    URI `something`, and the query parameters `parameter1=value1&parameter2=value2`.
    Then, it immediately reads the response from the server, prints it, and exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how this example works, we also created a simple server that
    listens on port `3333` of `localhost` and has a handler assigned to process all
    the requests that come with the `"/something"` path (refer to the `Server` class
    in a separate project in the `server` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: To implement the server, we used the classes of the `com.sun.net.httpserver`
    package that comes with the JDK in the Java class library. It starts listening
    on port `3333` and blocks until the request comes with the `"/something"` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `common` library (a separate project in the `common` folder) that
    includes the `Prop` class, which provides access to the properties file in the
    `resources` folder. Please note how references to this library are included as
    the dependency in the `pom.xml` file of the `server` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Prop` class includes two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: We use the `Prop` class to get the value of the `port` property from the `app.properties`
    file of the `server` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the internal `PostHandler` class in the `server` project
    demonstrates that the URL comes without parameters: we print the URI and the path.
    They both have the same `"/something"` value; the parameters come from the body
    of the request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the request is processed, the server sends back the message *“Got it!
    Thanks.”* Let’s see how it works; we first run the server. This can be done in
    two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just run the `main()` method in the `Server` class using your IDE. Click any
    of the two green triangles, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the `common` folder and execute the following Maven command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command compiles code in the `common` project and builds the `common-1.0-SNAPSHOT.jar`
    file in the `target` subdirectory. Now, repeat the same command in the `server`
    folder and run the following command in the `server` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding command lists on the classpath two `.jar` files
    (those we have just built) and runs the `main()` method of the `Server` class.
  prefs: []
  type: TYPE_NORMAL
- en: The outcome is that the server is waiting for the client code to call it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s execute the client (the `UrlPost` class). We can also do this in
    two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just run the `main()` method in the `UrlPost` class using your IDE. Click any
    of the two green triangles, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the `examples` folder and execute the following Maven command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command compiles code in the `examples` project and builds a `examples-1.0-SNAPSHOT.jar`
    file in the `target` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command in the `examples` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the client code, observe the following output on the server-side
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the server received the parameters (or any other message for
    that matter) successfully. Now it can parse them and use them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the client-side screen, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This means that the client received the message from the server and exited as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the server in our example does not exit automatically and has to
    be stopped manually.
  prefs: []
  type: TYPE_NORMAL
- en: Other methods of the `URL` and `URLConnection` classes allow you to set/get
    other properties and can be used for more dynamic management of the client-server
    communication. There is also the `HttpUrlConnection` class (and other classes)
    in the `java.net` package that simplifies and enhances URL-based communication.
    You can read the online documentation of the `java.net` package to understand
    the available options better.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HTTP 2 Client API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP Client API was introduced with Java 9 as an incubating API in the `jdk.incubator.http`
    package. In Java 11, it was standardized and moved to the `java.net.http` package.
    It is a far richer and easier-to-use alternative to the `URLConnection` API. In
    addition to all the basic connection-related functionality, it provides non-blocking
    (asynchronous) requests and responses using `CompletableFuture` and supports both
    HTTP 1.1 and HTTP 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP 2 added the following new capabilities to the HTTP protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to send data in a binary format rather than textual format; the
    binary format is more efficient for parsing, more compact, and less susceptible
    to various errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is fully multiplexed, thus allowing multiple requests and responses to be
    sent concurrently using just one connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses header compression, thus reducing the overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows a server to push a response to the client’s cache if the client indicates
    that it supports HTTP 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The package contains the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClient`: This is used to send requests and receive responses both synchronously
    and asynchronously. An instance can be created using the static `newHttpClient()`
    method with default settings or by using the `HttpClient.Builder` class (returned
    by the static `newBuilder()` method) that allows you to customize the client configuration.
    Once created, the instance is immutable and can be used multiple times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpRequest`: This creates and represents an HTTP request with the destination
    URI, headers, and other related information. An instance can be created using
    the `HttpRequest.Builder` class (returned by the static `newBuilder()` method).
    Once created, the instance is immutable and can be sent multiple times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpRequest.BodyPublisher`: This publishes a body (for the `POST`, `PUT`,
    and `DELETE` methods) from a certain source, such as a string, a file, an input
    stream, or a byte array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpResponse`: This represents an HTTP response received by the client after
    an HTTP request has been sent. It contains the origin URI, headers, message body,
    and other related information. Once created, the instance can be queried multiple
    times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpResponse.BodyHandler`: This is a functional interface that accepts the
    response and returns an instance of `HttpResponse.BodySubscriber` that can process
    the response body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpResponse.BodySubscriber`: This receives the response body (its bytes)
    and transforms it into a string, a file, or a type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HttpRequest.BodyPublishers`, `HttpResponse.BodyHandlers`, and `HttpResponse.BodySubscribers`
    classes are factory classes that create instances of the corresponding classes.
    For example, the `BodyHandlers.ofString()` method creates a `BodyHandler` instance
    that processes the response body bytes as a string, while the `BodyHandlers.ofFile()`
    method creates a `BodyHandler` instance that saves the response body in a file.
  prefs: []
  type: TYPE_NORMAL
- en: You can read the online documentation of the `java.net.http` package to learn
    more about these and other related classes and interfaces. Next, we will take
    a look at and discuss some examples of HTTP API usage.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking HTTP requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code is an example of a simple HTTP client that sends a `GET`
    request to an HTTP server (see the `get()` method in the `HttpClientDemo` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a builder to configure an `HttpClient` instance. However, since
    we used default settings only, we can do it with the same result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the client’s functionality, we will use the same `Server` class
    that we used already. As a reminder, this is how it processes the client’s request
    and responds with `"Got it! Thanks."`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: 'If we launch this server and run the preceding client’s code, the server prints
    the following message on its screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The client did not send a message because it used the HTTP `GET` method. Nevertheless,
    the server responds, and the client’s screen shows the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `send()` method of the `HttpClient` class is blocked until the response
    has come back from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the HTTP `POST`, `PUT`, or `DELETE` methods produces similar results;
    let’s run the following code now (see the `post()` method in the `HttpClientDemo`
    class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this time the client posts the message `Hi there!` and the
    server’s screen shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `send()` method of the `HttpClient` class is blocked until the same response
    has come back from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far, the demonstrated functionality was not much different from the URL-based
    communication that we saw in the previous section. Now we are going to use the
    `HttpClient` methods that are not available in the URL streams.
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking (asynchronous) HTTP requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `sendAsync()` method of the `HttpClient` class allows you to send a message
    to a server without blocking. To demonstrate how it works, we will execute the
    following code (see the `getAsync1()` method in the `HttpClientDemo` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: In comparison to the example with the `send()` method (which returns the `HttpResponse`
    object), the `sendAsync()` method returns an instance of the `CompletableFuture<HttpResponse>`
    class. If you read the documentation of the `CompletableFuture<T>` class, you
    will see that it implements the `java.util.concurrent.CompletionStage` interface,
    which provides many methods that can be chained and allows you to set various
    functions to process the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an idea, here is the list of the methods declared in the `CompletionStage`
    interface: `acceptEither`, `acceptEitherAsync`, `acceptEitherAsync`, `applyToEither`,
    `applyToEitherAsync`, `applyToEitherAsync`, `handle`, `handleAsync`, `handleAsync`,
    `runAfterBoth`, `runAfterBothAsync`, `runAfterBothAsync`, `runAfterEither`, `runAfterEitherAsync`,
    `runAfterEitherAsync`, `thenAccept`, `thenAcceptAsync`, `thenAcceptAsync`, `thenAcceptBoth`,
    `thenAcceptBothAsync`, `thenAcceptBothAsync`, `thenApply`, `thenApplyAsync`, `thenApplyAsync`,
    `thenCombine`, `thenCombineAsync`, `thenCombineAsync`, `thenCompose`, `thenComposeAsync`,
    `thenComposeAsync`, `thenRun`, `thenRunAsync`, `thenRunAsync`, `whenComplete`,
    `whenCompleteAsync`, and `whenCompleteAsync`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will talk about functions and how they can be passed as parameters in [*Chapter
    13*](B18388_13_ePub.xhtml#_idTextAnchor281), *Functional Programming*. For now,
    we will just mention that the `resp -> System.out.println("Response: " + resp.statusCode()
    + " : " + resp.body())` construction represents the same functionality as the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: The `thenAccept()` method applies the passed-in functionality to the result
    returned by the previous method of the chain.
  prefs: []
  type: TYPE_NORMAL
- en: After the `CompletableFuture<Void>` instance is returned, the preceding code
    prints `The request was sent asynchronously...` message and blocks it on the `get()`
    method of the `CompletableFuture<Void>` object. This method has an overloaded
    version `get(long timeout, TimeUnit unit)`, with two parameters, `TimeUnit unit`
    and `long` `timeout`, which specify the number of the units, indicating how long
    the method should wait for the task that is represented by the `CompletableFuture<Void>`
    object to complete. In our case, the task is to send a message to the server and
    to get back the response (and process it using the function provided). If the
    task is not completed in the allotted time, the `get()` method is interrupted
    (and the stack trace is printed in the `catch` block).
  prefs: []
  type: TYPE_NORMAL
- en: The `Exit the client...` message should appear on the screen either in 5 seconds
    (in our case) or after the `get()` method returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the client, the server’s screen shows the following message again
    with the blocking HTTP `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The client’s screen displays the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `CompletableFuture<Void>` object around and call it at any time
    to get the result. In our case, the result is `void`, so the `get()` method simply
    indicates that the task was completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that the server returns the message, and so we can take advantage of
    it by using another method of the `CompletionStage` interface. We have chosen
    the `thenApply()` method, which accepts a function that returns a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `get()` method returns the value produced by the `resp -> "Server
    responded: " + resp.body()` function, so it should return the server message body;
    let’s run this code (see the `getAsync2()` method in the `HttpClientDemo` class)
    and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the `get()` method returns the server’s message as expected, and it is
    presented by the function and passed as a parameter to the `thenApply()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can use the HTTP `POST`, `PUT`, or `DELETE` methods for sending
    a message (see the `postAsync()` method in the `HttpClientDemo` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference from the previous example is that the server now displays
    the received client’s message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The client’s screen displays the same message as in the case of the `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The advantage of asynchronous requests is that they can be sent quickly and
    without needing to wait for each of them to complete. The HTTP 2 protocol supports
    it by multiplexing; for example, let’s send three requests as follows (see the
    `postAsyncMultiple()` method in the `HttpClientDemo` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'The server’s screen shows the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the arbitrary sequence of the incoming requests; this is because the
    client uses a pool of `Executors.newCachedThreadPool()` threads to send the messages.
    Each message is sent by a different thread, and the pool has its own logic for
    using the pool members (threads). If the number of messages is large, or if each
    of them consumes a significant amount of memory, it may be beneficial to limit
    the number of threads run concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HttpClient.Builder` class allows you to specify the pool that is used
    for acquiring the threads that send the messages (see the `postAsyncMultipleCustomPool()`
    method in the `HttpClientDemo` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: If we run the preceding code, the results will be the same, but the client will
    use only two threads to send messages. The performance may be a bit slower (in
    comparison to the previous example) as the number of messages grows. So, as is
    often the case in a software system design, you need to balance the amount of
    memory used and the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the executor, several other objects can be set on the `HttpClient`
    object to configure the connection to handle authentication, request redirection,
    cookie management, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Server push functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second (after multiplexing) significant advantage of the HTTP 2 protocol
    over HTTP 1.1 is allowing the server to push the response into the client’s cache
    if the client indicates that it supports HTTP 2\. Here is the client code that
    takes advantage of this feature (see the `push()` method in the `HttpClientDemo`
    class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the third parameter of the `sendAsync()` method. It is a function that
    handles the push response if one comes from the server. It is up to the client
    developer to decide how to implement this function; here is one possible example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: This implementation of the function does not do much. It just prints out the
    URI of the push origin. But, if necessary, it can be used to receive the resources
    from the server (for example, images that support the provided HTML) without requesting
    them. This solution saves the round-trip request-response model and shortens the
    time of the page loading. It also can be used for updating the information on
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: You can find many code examples of a server that sends push requests; all major
    browsers support this feature too.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP is based on the request-response model. A client requests a resource, and
    the server provides a response to this request. As we have demonstrated several
    times, the client initiates the communication. Without it, the server cannot send
    anything to the client. To get over this limitation, the idea was first introduced
    as a TCP connection in the HTML5 specification and, in 2008, the first version
    of the WebSocket protocol was designed.
  prefs: []
  type: TYPE_NORMAL
- en: It provides a full-duplex communication channel between the client and the server.
    After the connection is established, the server can send a message to the client
    at any time. Together with JavaScript and HTML5, the WebSocket protocol support
    allows web applications to present a far more dynamic user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket protocol specification defines WebSocket (`ws`) and WebSocket
    Secure (`wss`) as two schemes that are used for unencrypted and encrypted connections,
    respectively. The protocol does not support fragmentation, but allows all the
    other URI components described in the *URL syntax* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the classes that support the WebSocket protocol for a client are located
    in the `java.net` package. To create a client, we need to implement the `WebSocket.Listener`
    interface, which has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onText()`: Invoked when textual data has been received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onBinary()`: Invoked when binary data has been received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPing()`: Invoked when a ping message has been received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPong()`: Invoked when a pong message has been received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError()`: Invoked when an error has happened'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onClose()`: Invoked when a close message has been received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the methods of this interface are `default`. This means that you do not
    need to implement all of them, but only those that the client requires for a particular
    task (see the private `WsClient` class in the `HttpClientDemo` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: A server can be implemented in a similar way, but server implementation is beyond
    the scope of this book. To demonstrate the preceding client code, we are going
    to use a WebSocket server provided by the `echo.websocket.events` website. It
    allows a WebSocket connection and sends the received message back; such a server
    is typically called an **echo server**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We expect that our client will send the message after the connection is established.
    Then, it will receive (the same) message from the server, display it, and send
    back another message, and so on, until it is closed. The following code invokes
    the client that we created (see the `webSocket()` method in the `HttpClientDemo`
    class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a `WebSocket` object using the `WebSocket.Builder`
    class. The `buildAsync()` method returns the `CompletableFuture` object. The `join()`
    method of the `CompletableFuture` class returns the result value when complete,
    or throws an exception. If an exception is not generated, then, as we mentioned
    already, the `WebSocket` communication continues until either side sends a **Close**
    message. That is why our client waits for 200 milliseconds, and then sends the
    **Close** message and exits. If we run this code, we will see the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_11.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the client behaves as expected. To finish our discussion, we
    would like to mention the fact that all modern web browsers support the WebSocket
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you were presented with a description of the most popular
    network protocols: UDP, TCP/IP, and WebSocket. The discussion was illustrated
    with code examples using JCL. We also reviewed URL-based communication and the
    latest Java HTTP 2 Client API.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use the basic internet protocols to send/receive messages between
    client and server, and also know how to create a server as a separate project
    and how to create and use a common shared library.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter provides an overview of Java GUI technologies and demonstrates
    a GUI application using JavaFX, including code examples with control elements,
    charts, CSS, FXML, HTML, media, and various other effects. You will learn how
    to use JavaFX to create a GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name five network protocols of the application layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name two network protocols of the transport layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Java package includes classes that support the HTTP protocol?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which protocol is based on exchanging datagrams?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a datagram be sent to the IP address where there is no server running?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Java package contains classes that support UDP and TCP protocols?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does TCP stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is common between the TCP and TCP/IP protocols?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a TCP session identified?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name one principal difference between the functionality of `ServerSocket` and
    `Socket`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is faster, TCP or UDP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is more reliable, TCP or UDP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name three TCP-based protocols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following are the components of a URI? Select all that apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fragment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Title
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Authority
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Query
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `scheme` and `protocol`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a URI and a URL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Name two new features that HTTP 2 has that HTTP 1.1 does not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the fully qualified name of the `HttpClient` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the fully qualified name of the `WebSocket` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `HttpClient.newBuilder().build()` and `HttpClient.newHttpClient()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the fully qualified name of the `CompletableFuture` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
