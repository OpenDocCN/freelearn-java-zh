<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Introducing Java EE 7 &#x2013; EJBs"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Introducing Java EE 7 – EJBs</h1></div></div></div><p class="calibre8">In the previous chapter, you learned some basics about how to set up and deploy a Hello World application on WildFly. In this chapter, we will go a little deeper and learn how to create, deploy, and assemble Enterprise JavaBeans, which are at the heart of most Enterprise applications. Additionally, you will learn how to use Maven, a popular build tool, which can ease the packaging process of our beans.</p><p class="calibre8">In more detail, here is what you will learn in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">What changes are introduced by the new EJB 3.2 specification</li><li class="listitem">How to create a Java EE 7 Maven project</li><li class="listitem">How to develop a singleton EJB</li><li class="listitem">How to create stateless and stateful Enterprise JavaBeans</li><li class="listitem">How to add and manage schedulers and timers to your application</li><li class="listitem">How to make use of asynchronous APIs in an EJB project</li></ul></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Introducing Java EE 7 &#x2013; EJBs">
<div class="book" title="EJB 3.2 – an overview"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec18" class="calibre1"/>EJB 3.2 – an overview</h1></div></div></div><p class="calibre8">Based on the <span class="strong"><strong class="calibre9">Enterprise JavaBeans</strong></span> (<span class="strong"><strong class="calibre9">EJB</strong></span>) specification, Enterprise JavaBeans are components that typically implement the business <a id="id229" class="calibre1"/>logic of Java Enterprise Edition applications (for Java EE, note that Oracle advises against using JEE as the acronym for Java Enterprise Edition; for more information<a id="id230" class="calibre1"/> about acronyms for Java-related technologies, visit <a class="calibre1" href="https://java.net/projects/javaee-spec/pages/JEE">https://java.net/projects/javaee-spec/pages/JEE</a>). Because of their transactional nature, EJBs are also commonly used for the construction of the data access layer in many applications. However, in the newest version of the specification, container-managed transactions are no longer exclusive for Enterprise JavaBeans and can be reused in other parts of the Java EE platform.</p><p class="calibre8">There are basically three types of Enterprise JavaBeans:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Session beans</strong></span>: This<a id="id231" class="calibre1"/> is the most commonly used EJB type. The<a id="id232" class="calibre1"/> container manages multiple instances of every class that is defined as a session bean (with an exception for singletons, which have only one instance). When an operation implemented by EJB must be executed (for example, because a user has requested an update of an entity in the database), the container assigns a session bean instance for the specific user. This code is then executed on behalf of the calling client. The container is responsible for providing session beans with multiple system-level services, for example, security, transactions, or distribution of beans.</li><li class="listitem"><span class="strong"><strong class="calibre9">Message-driven beans</strong></span> (<span class="strong"><strong class="calibre9">MDB</strong></span>): MDBs <a id="id233" class="calibre1"/>are<a id="id234" class="calibre1"/> Enterprise beans that can asynchronously process messages sent by any JMS producer. (We will discuss MDBs in <a class="calibre1" title="Chapter 6. Developing Applications with JBoss JMS Provider" href="part0035_split_000.html#page">Chapter 6</a>, <span class="strong"><em class="calibre10">Developing Applications with JBoss JMS Provider</em></span>.)</li><li class="listitem"><span class="strong"><strong class="calibre9">Entity objects</strong></span>: An EJB is used to represent entities in a database. The newest <a id="id235" class="calibre1"/>version of the specification made this type <a id="id236" class="calibre1"/>of Enterprise JavaBeans optional, so they may not be supported in all containers (their support has also been dropped in WildFly). Entity objects will be removed from the specification in Java EE 8. Currently, in Java EE 7, the main persistence technology is Java Persistence API. We will discuss JPA in <a class="calibre1" title="Chapter 5. Combining Persistence with CDI" href="part0030_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre10">Combining Persistence with CDI</em></span>.</li></ul></div><p class="calibre8">Additionally, session beans can be divided into three subtypes based on their characteristics and usage scenarios.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Stateless session beans</strong></span> (<span class="strong"><strong class="calibre9">SLSB</strong></span>): These are objects whose instances have no conversational <a id="id237" class="calibre1"/>state with the<a id="id238" class="calibre1"/> client that has invoked an operation on them. This means that all these bean instances are equal when they are not servicing a client, and the container can prepare a pool for them to handle multiple requests in parallel. Because they do not store any state, their performance overhead is quite low. A common usage scenario for an SLSB would be a stateless service responsible for retrieving objects from a database.</li><li class="listitem"><span class="strong"><strong class="calibre9">Stateful session beans</strong></span> (<span class="strong"><strong class="calibre9">SFSB</strong></span>): SFSB<a id="id239" class="calibre1"/> supports conversational <a id="id240" class="calibre1"/>services with tightly coupled clients. A stateful session bean accomplishes a task for a particular client and it cannot be shared between multiple callers. It maintains the state for the duration of a client session. After session completion, the state is not retained. The container may decide to passivate (serialize and store for future usage) a stale SFSB. This is done to save <a id="id241" class="calibre1"/>resources of the application<a id="id242" class="calibre1"/> server or in some cases, to support SFSB failover mechanism in a domain of application servers (this is the case in JBoss AS 7 and WildFly). Starting from EJB 3.2, it is possible to disable passivation for a specific SFSB, although it may affect the server's stability and failover capability. A shopping cart could serve as a simple use case for an SFSB.</li><li class="listitem"><span class="strong"><strong class="calibre9">Singleton EJB</strong></span>: This<a id="id243" class="calibre1"/> is essentially similar to a <a id="id244" class="calibre1"/>stateless session bean; however, it uses a single instance to serve client requests. So, you can guarantee the use of the same instance across invocations. Singletons can use a richer life cycle for a set of events, along with the possibility to control when a bean is initialized. Also, a more strict locking policy to control concurrent access to the instance can be enforced, so that the shared state of the singleton bean can be used by multiple clients. If the application is distributed on multiple nodes of a domain, then every running JVM will have its own instance of the singleton bean. We will discuss this a little further in <a class="calibre1" title="Chapter 11. Clustering WildFly Applications" href="part0057_split_000.html#page">Chapter 11</a>, <span class="strong"><em class="calibre10">Clustering WildFly Applications</em></span>. Because of their special characteristics, singletons can be used to save the state of the application, cache, or initialize some resources during the application's startup.</li></ul></div><p class="calibre8">As we mentioned earlier, the container manages the instances of the beans, but the clients should call them through business interfaces. There are three types of a session bean's views available:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Local business interface</strong></span>: This session bean is used when the bean and its client<a id="id245" class="calibre1"/> are in the same container. It uses<a id="id246" class="calibre1"/> the pass-by-reference semantic, so the return values and method parameters are based on references and not copies of the objects.</li><li class="listitem"><span class="strong"><strong class="calibre9">Remote business interface</strong></span>: In this session bean, the locations of the client and <a id="id247" class="calibre1"/>the bean are independent (the<a id="id248" class="calibre1"/> client may reside in another container or without a container at all, for example, as a standalone application). Every parameter and return value is serialized and copied.</li><li class="listitem"><span class="strong"><strong class="calibre9">No-interface view</strong></span>: This session bean is a variant of the local business view that does <a id="id249" class="calibre1"/>not require a separate interface, that<a id="id250" class="calibre1"/> is, all <code class="email">public</code> methods of the bean class are automatically exposed to the caller.</li></ul></div><p class="calibre8">Since EJB 3.1, it is possible to use asynchronous methods. These are able to process client requests asynchronously, just like MDBs, except that they expose a typed interface and follow a more complex approach to process client requests. It is possible to use two approaches to achieve this kind of behavior:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Fire-and-forget asynchronous void methods, which are invoked by the client</li><li class="listitem">Retrieve-result-later asynchronous methods, which have the <code class="email">Future&lt;?&gt;</code> return type</li></ul></div><p class="calibre8">What more should you know about EJBs before proceeding? When you develop an Enterprise JavaBean, you have to follow some general rules, which are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Avoid using nonfinal static fields</li><li class="listitem">Don't manually create threads (we will cover this topic more deeply in <a class="calibre1" title="Chapter 12. Long-term Tasks' Execution" href="part0062_split_000.html#page">Chapter 12</a>, <span class="strong"><em class="calibre10">Long-term Tasks' Execution</em></span>)</li><li class="listitem">Don't use synchronization primitives (except in singletons with bean-managed concurrency)</li><li class="listitem">Manual file operations on the filesystem and listening on sockets are forbidden</li><li class="listitem">Native libraries should not be loaded</li></ul></div><p class="calibre8">Disobeying these rules could cause security and stability issues with the EJB container. A comprehensive list <a id="id251" class="calibre1"/>of disallowed activities can be found at <a class="calibre1" href="http://www.oracle.com/technetwork/java/restrictions-142267.html">http://www.oracle.com/technetwork/java/restrictions-142267.html</a> along with some explanations for specific points.</p><p class="calibre8">Since it's easier to grasp the concepts with real examples, in the next section, we will provide a concrete application example that introduces some of the features that we described in this section.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Developing singleton EJBs"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec19" class="calibre1"/>Developing singleton EJBs</h1></div></div></div><p class="calibre8">As the<a id="id252" class="calibre1"/> name implies, <code class="email">javax.ejb.Singleton</code> is a session bean that guarantees that there is at most one instance in the application.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre8">Besides this, singleton EJBs fill a well-known gap in EJB applications, that is, the ability to have an EJB notified when the application starts and also when the application stops. So, you can do all sorts of things with an EJB that you previously (before EJB 3.1) could only do with a load-on-startup servlet. EJB also gives you a place to hold data that pertains to the entire application and all the users using it, without the need for static class fields.</p></div><p class="calibre8">In order to<a id="id253" class="calibre1"/> turn your EJB into a singleton, all that is needed is to apply the <code class="email">@javax.ejb.Singleton</code> annotation on top of it.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre8">A singleton bean is similar to a stateful bean, in that, state information is maintained across method invocations. However, there is just one singleton bean for each server JVM, and it is shared by all of the EJBs and clients of an application. This type of bean provides a convenient means to maintain the overall state of an application. However, if the application is distributed on multiple machines (and therefore multiple JVMs), the singleton is unique on every one of them. Any application state must be synchronized between the nodes.</p></div><p class="calibre8">Another annotation that is worth learning is <code class="email">@javax.ejb.Startup</code>, which causes the bean to be instantiated by the container when the application starts. This invokes the method decorated with the <code class="email">@javax.annotation.PostConstruct</code> annotation if you have defined one in your EJB.</p><p class="calibre8">We now have enough information to understand our first EJB example. There is more than one alternative to create a Java Enterprise project. In the earlier chapter, we illustrated how to start from a project based on Eclipse Java EE (a dynamic web project), binding it later to a WildFly runtime installation. This is obviously the simplest choice, and you can easily run the examples contained in this book using this pattern; however, when it comes to enterprise solutions, it's no surprise that almost every project now uses some kind of build automation tool. For this book, we will propose Apache Maven, as it is one of the most popular choices, but not the only one. Gradle is a similar project that uses the Groovy language to describe project structure, dependencies, and build workflow.</p><p class="calibre8">Some of the <a id="id254" class="calibre1"/>benefits that you will achieve when turning to Maven projects include a well-defined dependency structure, the conventions of a project build's best practices, and project modular design, just to mention a few. Additionally, when you have an automated build process, you can use continuous integration tools (such as Jenkins) to schedule automated tests and deployments of your applications.</p><p class="calibre8">All major <a id="id255" class="calibre1"/>IDEs have built-in Maven support. This includes the Eclipse Java EE Luna release.</p><p class="calibre8">So, let's create our first Maven project directly from Eclipse. Navigate to <span class="strong"><strong class="calibre9">File</strong></span> | <span class="strong"><strong class="calibre9">New</strong></span> | <span class="strong"><strong class="calibre9">Other</strong></span> | <span class="strong"><strong class="calibre9">Maven</strong></span> | <span class="strong"><strong class="calibre9">Maven Project</strong></span>. This is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00030.jpeg" alt="Developing singleton EJBs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Click on <span class="strong"><strong class="calibre9">Next</strong></span>; you will be taken to the following intermediary screen:</p><div class="mediaobject"><img src="../images/00031.jpeg" alt="Developing singleton EJBs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Maven <a id="id256" class="calibre1"/>allows the use of archetypes when creating a new project. They define a project's basic dependencies, resources, structure, and so on. For example, you can use a web application archetype in order to get an empty project skeleton, which you can just build and deploy. Unfortunately, archetypes are often outdated, and you still need to adjust them for your needs. In order to use some Java EE 7 archetypes, you have to first define a repository and archetypes you would like to use, and then you can create a project. In real life, you will probably create every new project by just looking at your previous ones, without using any archetypes. So, here we will show how to create a project from scratch. You might also be interested in some additional Java EE-related tools such as JBoss Forge, whose description you will find in the <a class="calibre1" title="Appendix A. Rapid Development Using JBoss Forge" href="part0067_split_000.html#page">Appendix</a>, <span class="strong"><em class="calibre10">Rapid Development Using JBoss Forge</em></span>.</p><p class="calibre8">On the visible screen, check the <span class="strong"><strong class="calibre9">Create a simple project</strong></span> checkbox. With this option, we will skip the archetype selection. You can click on <span class="strong"><strong class="calibre9">Next</strong></span>. Now, you have to complete some basic project information. We are creating a server-side EJB application, which also has a standalone<a id="id257" class="calibre1"/> client. These two projects can share some common information, for example, about dependencies and their versions. Hence, we want to create a Maven multimodule project. In this first step, let's create a parent project that has a POM packaging. POM is a Maven convention used to describe the structure of a project and its modules. More information on this can be found in Sonatype free books that we mentioned in previous chapters.</p><p class="calibre8">You can complete the wizard by entering some package-specific information, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00032.jpeg" alt="Developing singleton EJBs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">For <span class="strong"><strong class="calibre9">Group ID</strong></span> (an abstract <a id="id258" class="calibre1"/>identifier with a similar role as in Java packages), you can use <code class="email">com.packtpub.wflydevelopment.chapter3</code>. For <span class="strong"><strong class="calibre9">Artifact ID</strong></span> (a simplified name of our project), just use <code class="email">ticket-agency</code>. Set the <span class="strong"><strong class="calibre9">Packaging</strong></span> field to <span class="strong"><strong class="calibre9">pom</strong></span>, and you can leave the default selection for the project's <span class="strong"><strong class="calibre9">Version</strong></span> field. Click on <span class="strong"><strong class="calibre9">Finish</strong></span> in order to complete the wizard.</p><p class="calibre8">Take a look <a id="id259" class="calibre1"/>at our newly created project. At the moment, it contains only <code class="email">pom.xml</code>, which will be the base for new modules. Navigate again to <span class="strong"><strong class="calibre9">File</strong></span> | <span class="strong"><strong class="calibre9">New</strong></span> | <span class="strong"><strong class="calibre9">Other</strong></span> | <span class="strong"><strong class="calibre9">Maven</strong></span> but now choose the <span class="strong"><strong class="calibre9">New Maven Module</strong></span>. You can now see the following screenshot:</p><div class="mediaobject"><img src="../images/00033.jpeg" alt="Developing singleton EJBs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Again, we want to skip the archetype selection, so check the <span class="strong"><strong class="calibre9">Create a simple project</strong></span> option. Under the <span class="strong"><strong class="calibre9">Parent Project</strong></span>, click on <span class="strong"><strong class="calibre9">Browse</strong></span> and select the parent we created a while ago. Under <span class="strong"><strong class="calibre9">Module Name</strong></span>, enter <code class="email">ticket-agency-ejb</code>. Click on <span class="strong"><strong class="calibre9">Next</strong></span>. You will be presented with the following screen.</p><div class="mediaobject"><img src="../images/00034.jpeg" alt="Developing singleton EJBs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Now, let's<a id="id260" class="calibre1"/> discuss the packaging type. There are a few possible archive types for Java EE deployments:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">The EJB module</strong></span>: This <a id="id261" class="calibre1"/>module usually contains<a id="id262" class="calibre1"/> classes for EJBs, packed as a .<code class="email">jar</code> file.</li><li class="listitem"><span class="strong"><strong class="calibre9">The web module</strong></span>: This <a id="id263" class="calibre1"/>archive can additionally <a id="id264" class="calibre1"/>contain web elements such as servlets, static web files, REST endpoints, and so on. It is packed as a <code class="email">.war</code> file (web archive) file.</li><li class="listitem"><span class="strong"><strong class="calibre9">The resource adapter module</strong></span>: This<a id="id265" class="calibre1"/> archive <a id="id266" class="calibre1"/>contains files related to JCA connectors (described in <a class="calibre1" title="Chapter 6. Developing Applications with JBoss JMS Provider" href="part0035_split_000.html#page">Chapter 6</a>, <span class="strong"><em class="calibre10">Developing Applications with JBoss JMS Provider</em></span>). It is packed as a <code class="email">.rar</code> file.</li><li class="listitem"><span class="strong"><strong class="calibre9">The Enterprise archive</strong></span>: This archive <a id="id267" class="calibre1"/>aggregates <a id="id268" class="calibre1"/>multiple Java EE modules (EJB, Web) with related descriptors. It is packed as a <code class="email">.ear</code> file.</li></ul></div><p class="calibre8">Here, we <a id="id269" class="calibre1"/>want to deploy only EJBs without any web elements, so let's set the packaging to EJB (if it is not visible in the Eclipse drop-down menu, just manually type it) and click on <span class="strong"><strong class="calibre9">Finish</strong></span>.</p><p class="calibre8">Follow the same steps to add a second module with the name <code class="email">ticket-agency-ejb-client</code> and JAR packaging . This will be a simple client for services exposed in <code class="email">ticket-agency-ejb</code>.</p><p class="calibre8">Now, look at our parent project <code class="email">pom.xml</code>. It should define two recently created modules, which are as follows:</p><div class="informalexample"><pre class="programlisting">    &lt;modules&gt;
        &lt;module&gt;ticket-agency-ejb&lt;/module&gt;
        &lt;module&gt;ticket-agency-ejb-client&lt;/module&gt;
    &lt;/modules&gt;</pre></div><p class="calibre8">The expected outcome of these operations should match the following screenshot, which has been taken from the Project Explorer view:</p><div class="mediaobject"><img src="../images/00035.jpeg" alt="Developing singleton EJBs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">As you <a id="id270" class="calibre1"/>can see, the <span class="strong"><strong class="calibre9">ticket-agency-ejb</strong></span> and <span class="strong"><strong class="calibre9">ticket-agency-ejb-client</strong></span> projects have been organized as a standard Maven project:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">src/main/java</code> will contain our source code</li><li class="listitem"><code class="email">src/main/resources</code> is meant for the configuration (containing a bare-bones <code class="email">ejb-jar.xml</code> configuration file for the EJB project)</li><li class="listitem"><code class="email">src/test/java</code> is used to store the test classes</li></ul></div><p class="calibre8">At the moment, we will focus on the main file <code class="email">pom.xml</code>, which needs to be aware of the Java EE dependencies.</p></div>

<div class="book" title="Developing singleton EJBs">
<div class="book" title="Configuring the EJB project object module (pom.xml)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec19" class="calibre1"/>Configuring the EJB project object module (pom.xml)</h2></div></div></div><p class="calibre8">Before digging into the <a id="id271" class="calibre1"/>code, first you need to configure Maven's <code class="email">pom.xml</code> configuration file further. This <a id="id272" class="calibre1"/>file is quite verbose, so we will illustrate just the core elements here that are required to understand our example, leaving the full listing to the code example package of this book.</p><p class="calibre8">The first thing we are going to add just after the properties section is a reference to Java EE 7 API, which is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax&lt;/groupId&gt;
        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
        &lt;version&gt;7.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></div><p class="calibre8">This dependency will add all Java EE 7.0 APIs' definitions. Scope is set to be provided, which means the dependency is available on the target environment (in our case, the application server), and does not need to be included in the built archive. This dependency is universal, and should work with all Application Servers that are compatible with Java EE 7.0, not only with WildFly.</p><p class="calibre8">We also want to add a second dependency, which is the JBoss logging API. Place this definition in the same <code class="email">&lt;dependencies&gt; &lt;/dependencies&gt;</code> tags, for example, below <code class="email">javaee-api</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt;
    &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt;
    &lt;version&gt;3.1.4.GA&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">The scope provided includes the enterprise dependencies and corresponds to adding a library to the compilation path. Therefore, it expects the JDK or a container to provide the dependency at runtime. Besides dependencies, we would like to configure the build process. The created project specifies the EJB packaging, but the build is performed with the JDK 1.5 compliance level and an old EJB version. This is why we want to add an additional block to <code class="email">pom.xml</code>, which is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
           &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
           &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1&lt;/version&gt;
            &lt;configuration&gt;
                &lt;!-- enforce Java 8 --&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
           &lt;/configuration&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
           &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
           &lt;artifactId&gt;maven-ejb-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
           &lt;configuration&gt;
                &lt;ejbVersion&gt;3.2&lt;/ejbVersion&gt;
                &lt;!-- Generate ejb-client for client project --&gt;
                &lt;generateClient&gt;true&lt;/generateClient&gt;
           &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</pre></div></div><p class="calibre8">This block does two<a id="id273" class="calibre1"/> things, which are as<a id="id274" class="calibre1"/> follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">maven-compiler-plugin</code> configuration enforces the usage of Java 8</li><li class="listitem">The <code class="email">maven-ejb-plugin</code> configuration defines that EJB 3.2 version was used, and enables generation of the EJB client (disabled by default) package for EJB client applications</li></ul></div><p class="calibre8">Also, check the <code class="email">src/main/resources/META-INF/ejb-jar.xml</code> file. It might contain the configuration from EJB 2.1. Instead, use the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ejb-jar 
         
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee"
         version="3.2"&gt;
    &lt;display-name&gt;ticket-agency-ejb&lt;/display-name&gt;
    &lt;ejb-client-jar&gt;ticket-agency-ejbClient.jar&lt;/ejb-client-jar&gt;
&lt;/ejb-jar&gt;</pre></div><p class="calibre8">At this point, you will be<a id="id275" class="calibre1"/> able<a id="id276" class="calibre1"/> to compile your project; so, we will start adding classes, but we will return to the <code class="email">pom.xml</code> file when it's time to deploy your artifact.</p></div></div>

<div class="book" title="Developing singleton EJBs">
<div class="book" title="Coding our EJB application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec20" class="calibre1"/>Coding our EJB application</h2></div></div></div><p class="calibre8">Creating EJB<a id="id277" class="calibre1"/> classes does not require getting <a id="id278" class="calibre1"/>mixed up with fancy wizards; all you need to do is add bare Java classes. Therefore, from the <span class="strong"><strong class="calibre9">File</strong></span> menu, go to <span class="strong"><strong class="calibre9">New</strong></span> | <span class="strong"><strong class="calibre9">Java Class</strong></span>, and enter <code class="email">TheatreBox</code> as the classname and <code class="email">com.packtpub.wflydevelopment.chapter3.control</code> as the package name.</p><p class="calibre8">We will add the following implementation to the class:</p><div class="informalexample"><pre class="programlisting">@Singleton
@Startup
@AccessTimeout(value = 5, unit = TimeUnit.MINUTES)
public class TheatreBox {

    private static final Logger logger = Logger.getLogger(TheatreBox.class);

    private Map&lt;Integer, Seat&gt; seats;

    @PostConstruct
    public void setupTheatre() {
        seats = new HashMap&lt;&gt;();
        int id = 0;
        for (int i = 0; i &lt; 5; i++) {
            addSeat(new Seat(++id, "Stalls", 40));
            addSeat(new Seat(++id, "Circle", 20));
            addSeat(new Seat(++id, "Balcony", 10));
        } 
        logger.info("Seat Map constructed.");
    }

    private void addSeat(Seat seat) {
        seats.put(seat.getId(), seat);
    }

    @Lock(READ)
    public Collection&lt;Seat&gt; getSeats() {
        return Collections.unmodifiableCollection(seats.values());
    }

    @Lock(READ)
    public int getSeatPrice(int seatId) throws NoSuchSeatException {
        return getSeat(seatId).getPrice();
    }

    @Lock(WRITE)
    public void buyTicket(int seatId) throws SeatBookedException, NoSuchSeatException {
        final Seat seat = getSeat(seatId);
        if (seat.isBooked()) {
            throw new SeatBookedException("Seat " + seatId + " already booked!");
        }
        addSeat(seat.getBookedSeat());
    }

    @Lock(READ)
    private Seat getSeat(int seatId) throws NoSuchSeatException {
        final Seat seat = seats.get(seatId);
        if (seat == null) {
            throw new NoSuchSeatException("Seat " + seatId + " does not exist!");
        }
        return seat;
    }
}</pre></div><p class="calibre8">Let's see <a id="id279" class="calibre1"/>our application code in detail; the void<a id="id280" class="calibre1"/> method <code class="email">setupTheatre</code> is invoked as soon as the application is deployed and takes care of assembling the theatre seats, creating a simple map of the <code class="email">Seat</code> objects. Seat identifiers are key factors in this map. This happens right after deployment because our bean is annotated with <code class="email">@Singleton</code> and <code class="email">@Startup</code> that force the container to initialize the bean during startup. Each <code class="email">Seat</code> object is constructed using a set of three field constructors, which includes the seat ID, its description, and the price (the booked field is initially set as false). This is given in the following code:</p><div class="informalexample"><pre class="programlisting">public class Seat {
    public Seat(int id, String name, int price) {
        this(id, name, price, false);
    }
    private Seat(int id, String name, int price, boolean booked) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.booked = booked;
    }
    public Seat getBookedSeat() {
        return new Seat(getId(), getName(), getPrice(), true);
    }
    // Other Constructors, Fields and Getters omitted for brevity
}</pre></div><p class="calibre8">Note that <a id="id281" class="calibre1"/>our <code class="email">Seat</code> object is an immutable <a id="id282" class="calibre1"/>one. After we create an instance, we will not be able to change its state (the value of the fields, all of them are final, and no setters are exposed). This means that when we return a <code class="email">Seat</code> object to the client (local or remote), it will be only available for reading.</p><p class="calibre8">Next, the singleton bean exposes four public methods; the <code class="email">getSeats</code> method returns an unmodifiable collection of <code class="email">Seat</code> objects, which will return the information regarding whether they have been reserved or not to the user. The collection must be unmodifiable because our Singleton exposes a no-interface view, which means that we are using the pass-by-reference semantic. If we will not protect the collection, then every change on an element of the returned collection will be done on our cache. What's more, the client can add or remove elements to our internal collection!</p><p class="calibre8">The <code class="email">getSeatPrice</code> method<a id="id283" class="calibre1"/> is an utility method, which will pick up the seat price and return it as <code class="email">int</code>, so it can be used to verify whether the user can afford to buy the ticket.</p><p class="calibre8">The <code class="email">getSeat</code> method<a id="id284" class="calibre1"/> returns an immutable <code class="email">Seat</code> object for a given ID. Once more, we return an immutable <code class="email">Seat</code> because we don't want the client to change the object without using the <code class="email">TheatherBox</code> bean.</p><p class="calibre8">Finally, the <code class="email">buyTicket</code> method<a id="id285" class="calibre1"/> is the one that actually buys the ticket and, therefore, sets the ticket as booked. We cannot change the value of an immutable object, but we can replace it with a new one, which contains another value. The newly created object is placed<a id="id286" class="calibre1"/> in the hashmap instead <a id="id287" class="calibre1"/>of the old one.</p></div></div>

<div class="book" title="Developing singleton EJBs">
<div class="book" title="Controlling bean concurrency"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec21" class="calibre1"/>Controlling bean concurrency</h2></div></div></div><p class="calibre8">As you <a id="id288" class="calibre1"/>might have noticed, the bean<a id="id289" class="calibre1"/> includes a <code class="email">@Lock</code> annotation on top of the methods managing our collection of <code class="email">Seat</code> objects. This kind of annotation is used to control the concurrency of the singleton.</p><p class="calibre8">Concurrent access to a singleton EJB is, by default, controlled by the container. Read/write access to a singleton is limited to one client at a time. However,it is possible to provide a finer level of concurrency control through the use of annotations. This can be achieved using the <code class="email">@Lock</code> annotation, whose arguments determine the type of concurrency access permitted.</p><p class="calibre8">By using a <code class="email">@Lock</code> annotation of type <code class="email">javax.ejb.LockType.READ</code>, multithreaded access will be allowed to the bean. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">    @Lock(READ)</strong></span>
    public Collection&lt;Seat&gt; getSeats() {
        return Collections.unmodifiableCollection(seats.values());
    }</pre></div><p class="calibre8">On the other hand, if we apply <code class="email">javax.ejb.LockType.WRITE</code>, the single-threaded access policy is enforced, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">    @Lock(WRITE)</strong></span>
    public void buyTicket(int seatId) throws SeatBookedException, NoSuchSeatException {
        final Seat seat = getSeat(seatId);
        if (seat.isBooked()) {
            throw new SeatBookedException("Seat " + seatId + " already booked!");
        }
        addSeat(seat.getBookedSeat());
    }</pre></div><p class="calibre8">The general idea is to use <code class="email">READ</code> type locks on methods that just read values from the cache and <code class="email">WRITE</code> type locks for methods that change the values of elements contained in the cache. Keep in mind that <code class="email">WRITE</code> type locks block all methods with <code class="email">READ</code> type locks. It is crucial that the singleton will have exclusive control of the modifications of its state. Lack of proper encapsulation mixed with the pass-by-reference semantic (used in local and no-interface views of EJBs) can lead to hard-to-find concurrency bugs. Using immutable objects as return values for singletons is a good strategy to solve these kind of problems. Another strategy would be to return only copies of our objects or switching to the pass-by-value semantic. The last strategy can be applied by switching to a remote business interface in the singleton.</p><p class="calibre8">In<a id="id290" class="calibre1"/> the <code class="email">TheatreBox</code> code, you have probably <a id="id291" class="calibre1"/>noticed a <code class="email">@AccessTimeout</code> annotation (with value <code class="email">5</code> and unit <code class="email">TimeUnit.MINUTES</code>). When you execute a query against a method with <code class="email">@Lock (WRITE)</code>, and if some other thread is already accessing it, then after 5 seconds of waiting, you will get a timeout exception. In order to change this behavior (for example, by prolonging the allowed wait time), you can specify a <code class="email">@javax.ejb.AccessTimout</code> annotation at the method or class level.</p><div class="book" title="Using bean-managed concurrency"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec24" class="calibre1"/>Using bean-managed concurrency</h3></div></div></div><p class="calibre8">The other <a id="id292" class="calibre1"/>possible option is to use a<a id="id293" class="calibre1"/> bean-managed concurrency strategy that can be pursued by applying the <code class="email">@javax.ejb.ConcurrencyManagement</code> annotation with an argument of <code class="email">ConcurrencyManagementType.BEAN</code>. This annotation will disable the effect of the <code class="email">@Lock</code> annotation we have used so far, putting the responsibility of ensuring that the singleton cache does not get corrupted on the developer.</p><p class="calibre8">So, in order to ensure that our bookings are preserved, we will need to use a well-known synchronized keyword on top of the <code class="email">buyTicket</code> method, which is as follows:</p><div class="informalexample"><pre class="programlisting">@Singleton
@Startup
<span class="strong"><strong class="calibre9">@ConcurrencyManagement(ConcurrencyManagementType.BEAN)</strong></span>
public class TheatreBox {
. . . .
  public <span class="strong"><strong class="calibre9">synchronized</strong></span> void buyTicket(int seatId) {
    final Seat seat = getSeat(seatId);
    if (seat.isBooked()) {
        throw new SeatBookedException("Seat " + seatId + " already booked!");
    }
    addSeat(seat.getBookedSeat());
}</pre></div><p class="calibre8">Since concurrent access is restricted when a thread enters the synchronized block, no other methods are allowed to access the object while the current thread is in the block. Using a synchronized block is equivalent to having a container-managed concurrency with default locks of type <code class="email">WRITE</code> on all methods. This is one of the few places in Java EE when <a id="id294" class="calibre1"/>the <a id="id295" class="calibre1"/>developer may use synchronization primitives without affecting the stability of the container.</p></div></div></div>

<div class="book" title="Developing singleton EJBs">
<div class="book" title="Cooking session beans"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec22" class="calibre1"/>Cooking session beans</h2></div></div></div><p class="calibre8">Our singleton <a id="id296" class="calibre1"/>EJB is equipped with the methods<a id="id297" class="calibre1"/> to handle our store of theatre seats. We will now add a couple of session beans to our project to manage the business logic, a stateless session bean that will provide a view of the theatre seats and stateful beans that will behave as a payment gateway to our system.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">The choice of splitting our information system into two different beans is not part of a design pattern in particular, but serves a different purpose. That is, we would like to show how to look up both types of beans from a remote client.</p></div></div></div>

<div class="book" title="Developing singleton EJBs">
<div class="book" title="Adding a stateless bean"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec23" class="calibre1"/>Adding a stateless bean</h2></div></div></div><p class="calibre8">So, the<a id="id298" class="calibre1"/> first bean we will create is <code class="email">com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfo</code>, which barely contains <a id="id299" class="calibre1"/>the logic to look up the list of theatre seats. In practice, this bean acts as a facade for our singleton bean, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Stateless
@Remote(TheatreInfoRemote.class)
public class TheatreInfo implements TheatreInfoRemote {
<span class="strong"><strong class="calibre9">    @EJB</strong></span>
<span class="strong"><strong class="calibre9">    private TheatreBox box;</strong></span>

    @Override
    public String printSeatList() {
        final Collection&lt;Seat&gt; seats = box.getSeats();
        final StringBuilder sb = new StringBuilder();
        for (Seat seat : seats) {
            sb.append(seat.toString());
            sb.append(System.lineSeparator());
        }
        return sb.toString();
    }
}</pre></div><p class="calibre8">Since we are planning to invoke this EJB from a remote client, we defined a remote interface for it with the <code class="email">@Remote(TheatreInfoRemote.class)</code> annotation.</p><p class="calibre8">Next, take a look at the <code class="email">@EJB TheatreBox</code> <code class="email">box</code>, which can be used to safely inject an EJB into<a id="id300" class="calibre1"/> your class without the need of a manual <a id="id301" class="calibre1"/>JNDI lookup. This practice can be used to increase the portability of your application between different application servers, where different JNDI rules might exist.</p><p class="calibre8">The remote interface of your bean will be as simple as the following code:</p><div class="informalexample"><pre class="programlisting">public interface TheatreInfoRemote {
    String printSeatList();
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">If you are planning to expose your EJB to local clients only (for example, to a servlet), you can leave out the remote interface definition and simply annotate your bean with <code class="email">@Stateless</code>. The application server will create a no-interface view of your session bean, which can safely be injected into your local clients such as servlets or other EJBs. Be mindful that this also changes the semantics of the methods parameters and return values. For remote views, they will be serialized and passed by value.</p></div></div></div>

<div class="book" title="Developing singleton EJBs">
<div class="book" title="Adding a stateful bean"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch03lvl2sec24" class="calibre1"/>Adding a stateful bean</h2></div></div></div><p class="calibre8">In order<a id="id302" class="calibre1"/> to keep track of how much money our customer<a id="id303" class="calibre1"/> has got in his pocket, we will need a session-aware component. Turning a Java class into a stateful session bean is just a matter of adding a <code class="email">@Stateful</code> annotation on top of it, as in our example <code class="email">com.packtpub.wflydevelopment.chapter3.boundary.TheatreBooker</code> class. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Stateful
@Remote(TheatreBookerRemote.class)
@AccessTimeout(value = 5, unit = TimeUnit.MINUTES)
public class TheatreBooker implements TheatreBookerRemote {
    private static final Logger logger = Logger.getLogger(TheatreBooker.class);

    @EJB
    private TheatreBox theatreBox;
    private int money;

    @PostConstruct
    public void createCustomer() {
        this.money = 100;
    }

    @Override
    public int getAccountBalance() {
        return money;
    }

    @Override
    public String bookSeat(int seatId) throws SeatBookedException, NotEnoughMoneyException, NoSuchSeatException {
        final int seatPrice = theatreBox.getSeatPrice(seatId);
        if (seatPrice &gt; money) {
            throw new NotEnoughMoneyException("You don't have enough money to buy this " + seatId + " seat!");
        }

<span class="strong"><strong class="calibre9">        theatreBox.buyTicket(seatId);</strong></span>
        money = money - seatPrice;

        logger.infov("Seat {0} booked.", seatId);
        return "Seat booked.";
    }
}</pre></div><p class="calibre8">As you<a id="id304" class="calibre1"/> can see, the previous bean bears a <code class="email">@PostConstruct</code> annotation to<a id="id305" class="calibre1"/> initialize a session variable (money) that will be used to check whether the customer has enough money to buy the ticket. When using EJBs, we don't use <code class="email">constructors</code> and <code class="email">destructors</code> to perform actions on an object to create or destroy. The reason is that the point object might not have injected all objects it depends on. The method annotated with <code class="email">@PostConstruct</code> is executed when object creation is already finished, that is, all objects are injected to it. There is a second annotation related to the EJB life cycle, <code class="email">@PreDestroy</code>, which is executed before the object is destroyed.</p><p class="calibre8">Besides this, the ultimate purpose of our SFSB is to invoke the <code class="email">buyTicket</code> method of our singleton after having performed some business checks.</p><p class="calibre8">If the business checks do not pass, the application will issue some exceptions. This is the case, for example, if the seat has already been booked or if the customer hasn't got enough money to buy the ticket. In order to keep our conversation going, it's important that our exception will be an extension of the generic <code class="email">Exception</code> class. Refer to the following code for more information:</p><div class="informalexample"><pre class="programlisting">public class SeatBookedException extends Exception {
  // some code 
}</pre></div><p class="calibre8">If we use a runtime exception (for example, <code class="email">EJBException</code>), the bean instance will be discarded, and the communication between the remote client and server will be dropped. So, always take care to choose the appropriate type of exception when dealing with EJBs—choose to throw a runtime exception if you are dealing with an unrecoverable scenario (the connection with the enterprise information system is dropped). This kind of exception is called a System Exception. On the other hand, consider throwing a checked exception (or simply not throwing exceptions at all), if you are dealing with a business kind of <a id="id306" class="calibre1"/>exception; for example, if the booked seat is <a id="id307" class="calibre1"/>already engaged. Recoverable exceptions are called Application Exceptions.</p><p class="calibre8">There is also a possibility to mark a runtime exception (which would normally be a System Exception) as a recoverable exception, using the <code class="email">@ApplicationException</code> annotation. You may even decide if the current transaction should be rolled back (which is the default behavior for system exceptions) using <code class="email">@ApplicationException</code> (with rollback <code class="email">true</code>) on an exception class or the <code class="email">EJBContext.setRollbackOnly</code> statement inside a business method. The decision to roll back a transaction is up to the developer, and in most cases, it depends on the business scenario.</p></div></div>
<div class="book" title="Deploying the EJB application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec20" class="calibre1"/>Deploying the EJB application</h1></div></div></div><p class="calibre8">As it is, you<a id="id308" class="calibre1"/> should be able to package your EJB project by issuing the following Maven goal and starting a command-line prompt from your project root:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn package</strong></span>
</pre></div><p class="calibre8">The preceding command will compile and package the application that needs to be copied into the <code class="email">deployments</code> folder of your application server. This is fine; however, we can expect lots more from Maven by installing just a couple of plugins. In our case, we will configure<a id="id309" class="calibre1"/> our project to use Maven's WildFly plugin by adding the following section:</p><div class="informalexample"><pre class="programlisting">&lt;build&gt;
<span class="strong"><strong class="calibre9">    &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;</strong></span>
    &lt;plugins&gt;
<span class="strong"><strong class="calibre9">        &lt;!-- WildFly plugin to deploy the application --&gt;</strong></span>
<span class="strong"><strong class="calibre9">        &lt;plugin&gt;</strong></span>
<span class="strong"><strong class="calibre9">            &lt;groupId&gt;org.wildfly.plugins&lt;/groupId&gt;</strong></span>
<span class="strong"><strong class="calibre9">            &lt;artifactId&gt;wildfly-maven-plugin&lt;/artifactId&gt;</strong></span>
<span class="strong"><strong class="calibre9">            &lt;version&gt;1.0.2.Final&lt;/version&gt;</strong></span>
<span class="strong"><strong class="calibre9">            &lt;configuration&gt;</strong></span>
<span class="strong"><strong class="calibre9">                &lt;filename&gt;${project.build.finalName}.jar&lt;/filename&gt;</strong></span>
<span class="strong"><strong class="calibre9">            &lt;/configuration&gt;</strong></span>
<span class="strong"><strong class="calibre9">        &lt;/plugin&gt;</strong></span>
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1&lt;/version&gt;
            &lt;configuration&gt;
                &lt;!-- enforce Java 8 --&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-ejb-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
            &lt;configuration&gt;
                &lt;ejbVersion&gt;3.2&lt;/ejbVersion&gt;
                &lt;!-- Generate ejb-client for client project --&gt;
                &lt;generateClient&gt;true&lt;/generateClient&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</pre></div><p class="calibre8">In the first part of the XML fragment, we specified the project's <code class="email">finalName</code> attribute, which will dictate the name of the packaged artifact (in our example, the project's name corresponds to our project's artifact ID, so it will be named <code class="email">ticket-agency-ejb.jar</code>).</p><p class="calibre8">The artifact ID named <code class="email">wildfly-maven-plugin</code> will actually trigger the WildFly Maven plugin that will be used to deploy our project.</p><p class="calibre8">So, once you have configured the WildFly plugin, your application can be deployed automatically by<a id="id310" class="calibre1"/> entering from your project root. This can be done by typing the following command in the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn wildfly:deploy</strong></span>
</pre></div><p class="calibre8">Since deployment is a repetitive task for a developer, it would be convenient to execute this operation from within the Eclipse environment. All you need is to create a new <span class="strong"><strong class="calibre9">Run Configurations</strong></span> setting from the upper menu by navigating to <span class="strong"><strong class="calibre9">Run</strong></span> | <span class="strong"><strong class="calibre9">Run Configurations</strong></span>.</p><p class="calibre8">Enter the project's base directory (hint: the <span class="strong"><strong class="calibre9">Browse Workspace...</strong></span> utility will help you pick up the project from your project list) and type your Maven goal into the <span class="strong"><strong class="calibre9">Goals</strong></span> textbox, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00036.jpeg" alt="Deploying the EJB application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Once this<a id="id311" class="calibre1"/> is done, please ensure that your WildFly instance is running. Click on <span class="strong"><strong class="calibre9">Apply</strong></span> to save your configuration and then click on <span class="strong"><strong class="calibre9">Run</strong></span> to execute the deployment of the application. The Maven plugin will activate and once it is verified that all classes are up to date, start deploying the applications to WildFly using the remote API. Note that you do not need to pass any username or password for the deployment. This is possible because you are deploying your application from the same machine that WildFly is installed on. A local user authentication is done under the hood so that programmers will not need to cover this on their development machines.</p><p class="calibre8">After issuing the command, you should expect a success message on the Maven console, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">INFO: JBoss Remoting version 4.0.3.Final
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ---------------------------------------------------------------</pre></div><p class="calibre8">On the other <a id="id312" class="calibre1"/>hand, on the WildFly console, you have quite a verbose output that points out some important EJB JNDI bindings (we will return to it in a minute) and informs us that the application has been deployed correctly. This is depicted in the following code:</p><div class="informalexample"><pre class="programlisting">09:09:32,782 INFO  [org.jboss.as.server] (management-handler-thread - 1) JBAS018562: Deployed "ticket-agency-ejb.jar"</pre></div><p class="calibre8">Despite the fact that we are working on WildFly, we can quite frequently see information from JBoss AS subsystems on the console. This is because WildFly is built straight on the JBoss AS 7 codebase, and should not be worried about.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating a remote EJB client"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec21" class="calibre1"/>Creating a remote EJB client</h1></div></div></div><p class="calibre8">Creating<a id="id313" class="calibre1"/> a remote EJB client for the WildFly application server is very similar to AS7. The big difference can be noticed between AS6 and newer releases.</p><p class="calibre8">As a matter of fact, previous versions of WildFly (JBoss AS versions before 7.x) used the JBoss naming project as the JNDI naming implementation, so developers are familiar with <code class="email">jnp:// PROVIDER_URL</code> to communicate with the application server.</p><p class="calibre8">Starting with AS7, the JNP project is no longer used—neither on the server side nor on the client side. The client side of the JNP project has now been replaced by the jboss-remote-naming project. There were various reasons why the JNP client was replaced by the jboss-remote-naming project. One of them was that the JNP project did not allow fine-grained security configurations while communicating with the JNDI server. The jboss-remote-naming project is backed by the jboss-remoting project which allows much more and better control over security.</p><p class="calibre8">Besides the new naming implementation in AS7 and WildFly, there is no longer any support to bind custom JNDI names to EJBs. So the beans are always bound to the spec's mandated <code class="email">java:global</code>, <code class="email">java:app</code>, and <code class="email">java:module</code> namespaces. Therefore, setting the JNDI name for the session bean element via an annotation or configuration file is no longer supported.</p><p class="calibre8">So, what <a id="id314" class="calibre1"/>will be the JNDI name used to invoke a stateless session bean? Here it is:</p><div class="informalexample"><pre class="programlisting">ejb:&lt;app-name&gt;/&lt;module-name&gt;/&lt;distinct-name&gt;/&lt;bean-name&gt;!&lt;fully-qualified-classname-of-the-remote-interface&gt;</pre></div><p class="calibre8">A bit verbose, isn't it? However, the following table will help you get through it:</p><div class="informalexample"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre23">Element</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">Description</p>
</th></tr></thead><tbody class="calibre24"><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">app-name</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">This<a id="id315" class="indexterm"/> is the enterprise application name (without <code class="literal">ear</code>), if your EJB has been packed in an EAR</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">module-name</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">This<a id="id316" class="indexterm"/> is the module name (without <code class="literal">.jar</code> or <code class="literal">.war</code>), where your EJB has been packed</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">distinct-name</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">Using <a id="id317" class="indexterm"/>this, you can optionally set a distinct name for each deployment unit</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">bean-name</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">This<a id="id318" class="indexterm"/> is the bean's class name</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">fully-qualified-classname-of-the-remote-interface</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">This is<a id="id319" class="indexterm"/> the fully qualified class name of the remote interface</p>
</td></tr></tbody></table></div><p class="calibre8">So the corresponding JNDI binding for your <code class="email">TheatreInfo EJB</code>, packaged into a file named <code class="email">ticket-agency-ejb.jar</code>, will be:</p><div class="informalexample"><pre class="programlisting">ejb:/ticket-agency-ejb//TheatreInfo! com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfoRemote</pre></div><p class="calibre8">On the other hand, stateful EJBs will contain one more attribute, <code class="email">?stateful</code>, at the bottom of the JNDI string; this will result in the following JNDI naming structure:</p><div class="informalexample"><pre class="programlisting">ejb:&lt;app-name&gt;/&lt;module-name&gt;/&lt;distinct-name&gt;/&lt;bean-name&gt;!&lt;fully-qualified-classname-of-the-remote-interface&gt;?stateful</pre></div><p class="calibre8">Also, here's the corresponding binding for the <code class="email">TheatreBooker</code> class:</p><div class="informalexample"><pre class="programlisting">ejb:/ticket-agency-ejb//TheatreBooker! com.packtpub.wflydevelopment.chapter3.boundary.TheatreBookerRemote?stateful</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">If you pay attention to the server logs, you will see that once your application is deployed, a set of JNDI bindings will be displayed on the server console. For example:</p><div class="informalexample"><pre class="programlisting">java:global/ticket-agency-ejb/TheatreInfo!com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfoRemote
java:app/ticket-agency-ejb/TheatreInfo!com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfoRemote
java:module/TheatreInfo!com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfoRemote
java:jboss/exported/ticket-agency-ejb/TheatreInfo!com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfoRemote</pre></div><p class="calibre8">Some of these bindings reflect the standard bindings as per Java EE specifications plus JBoss custom bindings (<code class="email">java:/jboss</code>). This information, as it is, is not relevant for us but can be use to build our EJB client lookup string by replacing the Java EE (or JBoss-specific prefix) with <code class="email">ejb:/</code>. For example, replace <code class="email">java:/global</code> with <code class="email">ejb:</code>, and you will save yourself the headache of referring to the EJB lookup string.</p></div><p class="calibre8">Once <a id="id320" class="calibre1"/>we are done with decoding the JNDI binding string, we will code our EJB client. We have already created a separate subproject for it (<code class="email">ticket-agency-ejb-client</code>) at the beginning of this chapter, but we must still complete its configuration before we dive into coding.</p></div>

<div class="book" title="Creating a remote EJB client">
<div class="book" title="Configuring the client's project object module"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec25" class="calibre1"/>Configuring the client's project object module</h2></div></div></div><p class="calibre8">Configuring<a id="id321" class="calibre1"/> the client dependencies (in <code class="email">pom.xml</code>) will basically require all the libraries that connect and transport <a id="id322" class="calibre1"/>data to the server, along with the required EJB client dependencies. The first thing we will add, just as we did for the server project, is the BOM for the EJB client dependencies, which is demonstrated in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;dependencyManagement&gt;
   &lt;dependencies&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.wildfly&lt;/groupId&gt;
         &lt;artifactId&gt;wildfly-ejb-client-bom&lt;/artifactId&gt;
         &lt;version&gt;8.1.0.Final&lt;/version&gt;
         &lt;type&gt;pom&lt;/type&gt;
         &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</pre></div><p class="calibre8">Next, we <a id="id323" class="calibre1"/>will add a set of dependencies <a id="id324" class="calibre1"/>that are needed to resolve the EJB interfaces (<code class="email">ticket-agency-ejb artifact</code>), the JBoss' transaction API (needed as EJBs are transaction-aware components), the <code class="email">jboss-ejb-api</code> and <code class="email">ejb-client</code> APIs, the <code class="email">org.jboss.xnio</code> and <code class="email">org.jboss.xnio</code> APIs (which provide a low-level input/output implementation), the <code class="email">org.jboss.remoting3</code> API (the core transport protocol), which in turn requires <code class="email">org.jboss.sasl</code> (to secure the transport), and finally, the <code class="email">org.jboss.marshalling</code> API (to serialize the objects that are sent to and received from the server). This is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;dependencies&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;com.packtpub.wflydevelopment.chapter3&lt;/groupId&gt;
      &lt;artifactId&gt;ticket-agency-ejb&lt;/artifactId&gt;
      &lt;type&gt;ejb-client&lt;/type&gt;
      &lt;version&gt;${project.version}&lt;/version&gt;
   &lt;/dependency&gt;
 
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.spec.javax.transaction&lt;/groupId&gt;
      &lt;artifactId&gt;jboss-transaction-api_1.2_spec&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
 
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.spec.javax.ejb&lt;/groupId&gt;
      &lt;artifactId&gt;jboss-ejb-api_3.2_spec&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
 
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss&lt;/groupId&gt;
      &lt;artifactId&gt;jboss-ejb-client&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
 
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.xnio&lt;/groupId&gt;
      &lt;artifactId&gt;xnio-api&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.xnio&lt;/groupId&gt;
      &lt;artifactId&gt;xnio-nio&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
 
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.remoting3&lt;/groupId&gt;
      &lt;artifactId&gt;jboss-remoting&lt;/artifactId&gt;
         &lt;version&gt;3.3.3.Final&lt;/version&gt;
         &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
 
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.sasl&lt;/groupId&gt;
      &lt;artifactId&gt;jboss-sasl&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
 
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.marshalling&lt;/groupId&gt;
      &lt;artifactId&gt;jboss-marshalling-river&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
   &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></div><p class="calibre8">Many<a id="id325" class="calibre1"/> of these dependencies <a id="id326" class="calibre1"/>use the runtime scope. This means that classes that are provided by them are not used directly by our code; they are not needed to be bundled within our application package, but they are required at runtime.</p></div></div>

<div class="book" title="Creating a remote EJB client">
<div class="book" title="Coding the EJB client"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec26" class="calibre1"/>Coding the EJB client</h2></div></div></div><p class="calibre8">We <a id="id327" class="calibre1"/>are done with the configuration. We will finally<a id="id328" class="calibre1"/> proceed with adding a new Java class <code class="email">com.packtpub.wflydevelopment.chapter3.client.TicketAgencyClient</code>, which will communicate with the ticket booking machine's EJB application. This is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">public class TicketAgencyClient {

    private static final Logger logger = Logger.getLogger(TicketAgencyClient.class.getName());

    public static void main(String[] args) throws Exception {
<span class="strong"><strong class="calibre9">        Logger.getLogger("org.jboss").setLevel(Level.SEVERE);  [1]</strong></span>
        Logger.getLogger("org.xnio").setLevel(Level.SEVERE);

        new TicketAgencyClient().run();
    }
    private final Context context;
    private TheatreInfoRemote theatreInfo;
    private TheatreBookerRemote theatreBooker;

    public TicketAgencyClient() throws NamingException {
<span class="strong"><strong class="calibre9">        final Properties jndiProperties = new Properties(); [2]</strong></span>
        jndiProperties.setProperty(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming");
        this.context = new InitialContext(jndiProperties);
    }

    private enum Command { [3]
        BOOK, LIST, MONEY, QUIT, INVALID;

        public static Command parseCommand(String stringCommand) {
            try {
                return valueOf(stringCommand.trim().toUpperCase());
            } catch (IllegalArgumentException iae) {
                return INVALID;
            }
        }
    }

    private void run() throws NamingException {
<span class="strong"><strong class="calibre9">        this.theatreInfo = lookupTheatreInfoEJB();  [4]</strong></span>
<span class="strong"><strong class="calibre9">        this.theatreBooker = lookupTheatreBookerEJB();  [5]</strong></span>

<span class="strong"><strong class="calibre9">        showWelcomeMessage(); [6]</strong></span>

        while (true) {
            final String stringCommand = IOUtils.readLine("&gt; ");
<span class="strong"><strong class="calibre9">            final Command command = Command.parseCommand(stringCommand); [7]</strong></span>
            switch (command) {
                case BOOK:
                    handleBook();
                    break;
                case LIST:
                    handleList();
                    break;
                case MONEY:
                    handleMoney();
                    break;
                case QUIT:
                    handleQuit();
                    break;

                default:
                    logger.warning("Unknown command " + stringCommand);
            }
        }
    }

    private void handleBook() {
        int seatId;

        try {
            seatId = IOUtils.readInt("Enter SeatId: ");
        } catch (NumberFormatException e1) {
            logger.warning("Wrong SeatId format!");
            return;
        }

        try {
            final String retVal = theatreBooker.bookSeat(seatId);
            System.out.println(retVal);
        } catch (SeatBookedException | NotEnoughMoneyException | NoSuchSeatException e) {
            logger.warning(e.getMessage());
            return;
        }
    }

    private void handleList() {
        logger.info(theatreInfo.printSeatList());
    }

    private void handleMoney() {
        final int accountBalance = theatreBooker.getAccountBalance();
        logger.info("You have: " + accountBalance + " money left.");
    }

    private void handleQuit() {
        logger.info("Bye");
        System.exit(0);
    }
    private TheatreInfoRemote lookupTheatreInfoEJB() throws NamingException {
        return (TheatreInfoRemote) context.lookup("ejb:/ticket-agency-ejb//TheatreInfo!com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfoRemote");
    }

    private TheatreBookerRemote lookupTheatreBookerEJB() throws NamingException {
        return (TheatreBookerRemote) context.lookup("ejb:/ticket-agency-ejb//TheatreBooker!com.packtpub.wflydevelopment.chapter3.boundary.TheatreBookerRemote?stateful");
    }

    private void showWelcomeMessage() {
        System.out.println("Theatre booking system");
        System.out.println("=====================================");
        System.out.println("Commands: book, list,money, quit");
    }
}</pre></div><p class="calibre8">Let's see the most interesting points. First, in the main function, we set some logging rules <code class="email">[1]</code> in order to avoid mixing the JBoss remoting log messages with the console application information.</p><p class="calibre8">Next, we <a id="id329" class="calibre1"/>create the <code class="email">TicketAgencyClient</code> object and <a id="id330" class="calibre1"/>execute its <code class="email">run</code> method. During object creation, we prepare the <code class="email">InitialContext</code> object (further used to lookup remote objects). To do this, we will need a set of <code class="email">[2]</code> properties, which specify what type of <code class="email">ejb-client</code> is used.</p><p class="calibre8">In <code class="email">[3]</code>, we define a <code class="email">Command</code> enum, which represents console commands that users can send to this application. The<a id="id331" class="calibre1"/> <code class="email">run()</code> method first performs the lookup of the SLSB and SFSB (<code class="email">[4]</code> and <code class="email">[5]</code>) remote EJBs, and then shows the welcome message (<code class="email">[6]</code>). In the infinite loop, we wait for the user to enter a command and parse it (<code class="email">[7]</code>). Depending on the user's choice we can book a seat, list seats' information, get available money, or quit the application.</p><div class="book" title="Adding the EJB client configuration"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec25" class="calibre1"/>Adding the EJB client configuration</h3></div></div></div><p class="calibre8">As you <a id="id332" class="calibre1"/>can see from the preceding code snippet, there is no indication about the location of the server where the EJBs are running. It is possible to specify this by code, but in this sample, we will choose the simpler way and add <code class="email">jboss-ejb-client.properties</code> file in the client's classpath.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note20" class="calibre1"/>Note</h3><p class="calibre8">In Maven, the appropriate location for most of the resource files (like mentioned properties) is the <code class="email">src/main/resources</code> directory.</p></div><p class="calibre8">The contents of the <code class="email">jboss-ejb-client.properties</code> file are as follows:</p><div class="informalexample"><pre class="programlisting">remote.connections=default
remote.connection.default.host=localhost
remote.connection.default.port=8080</pre></div><p class="calibre8">There is also a <code class="email">remote.connectionprovider.create.options.org .xnio.Options.SSL_ENABLED</code> property, which enables the encryption of the XNIO connection; otherwise, plaintext will be used. (In <a class="calibre1" title="Chapter 10. Securing WildFly Applications" href="part0054_split_000.html#page">Chapter 10</a>, <span class="strong"><em class="calibre10">Securing WildFly Applications</em></span>, we will discuss using SSL to secure the connection between the client and server.)</p><p class="calibre8">The <code class="email">remote.connections</code> property can be set to define a list of logical names that will be used for <a id="id333" class="calibre1"/>connection purposes by the <code class="email">remote.connection.[name].host</code> and <code class="email">remote.connection.[name].port</code> attributes. If you <a id="id334" class="calibre1"/>define more than one connection, as in the following example, the connections will be split across various destinations, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">remote.connections=host1,host2 
remote.connection.host1.host=192.168.0.1
remote.connection.host2.host=192.168.0.2
remote.connection.host1.port=8080
remote.connection.host2.port=8080</pre></div><p class="calibre8">The default port used by the remoting framework is <code class="email">8080</code>.</p><p class="calibre8">You may wonder how EJB remoting can work on the same port as the HTTP protocol. Starting from WildFly, remoting uses the HTTP protocol upgrade mechanism. The first connection is done on the <code class="email">8080</code> port (via HTTP), then it is upgraded to EJB remoting, and switched to another port (chosen by WildFly).</p></div></div></div>

<div class="book" title="Creating a remote EJB client">
<div class="book" title="Running the client application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec27" class="calibre1"/>Running the client application</h2></div></div></div><p class="calibre8">In order<a id="id335" class="calibre1"/> to run your client application, the <a id="id336" class="calibre1"/>last requirement will be to add the required Maven plugins, which are needed to run the remote EJB client. This is given in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;build&gt;
   &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;
   &lt;plugins&gt;
      &lt;!-- maven-compiler-plugin here --&gt;
 
      &lt;plugin&gt;
         &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
         &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
         &lt;version&gt;1.2.1&lt;/version&gt;
         &lt;executions&gt;
            &lt;execution&gt;
               &lt;goals&gt;
                  &lt;goal&gt;exec&lt;/goal&gt;
               &lt;/goals&gt;
            &lt;/execution&gt;
         &lt;/executions&gt;
         &lt;configuration&gt;
            &lt;executable&gt;java&lt;/executable&gt;
            &lt;workingDirectory&gt;${project.build.directory}/exec-working-directory&lt;/workingDirectory&gt;
            &lt;arguments&gt;
               &lt;argument&gt;-classpath&lt;/argument&gt;
               &lt;classpath /&gt;
            &lt;argument&gt;com.packtpub.wflydevelopment.chapter3.client.TicketAgencyClient&lt;/argument&gt;
            &lt;/arguments&gt;
         &lt;/configuration&gt;
      &lt;/plugin&gt;
   &lt;/plugins&gt;
&lt;/build&gt;</pre></div><p class="calibre8">As you can<a id="id337" class="calibre1"/> see in the preceding code<a id="id338" class="calibre1"/> snippet, besides the <code class="email">maven-compiler-plugin</code> configuration that we omitted for the sake of brevity (we discussed it in the server project), we have included <code class="email">exec-maven-plugin</code>, which adds the ability to execute Java programs using the <code class="email">exec</code> goal.</p><p class="calibre8">Once all the plugins are in place, you can compile and execute your project by issuing the following Maven goal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn package exec:exec</strong></span>
</pre></div><p class="calibre8">The preceding command can be executed either from a shell (positioned in the project's <code class="email">root</code> folder) or from your Eclipse runtime configuration, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00037.jpeg" alt="Running the client application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">If executed from the Eclipse environment, you should be able to see the following GUI screenshot:</p><div class="mediaobject"><img src="../images/00038.jpeg" alt="Running the client application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">At the <a id="id339" class="calibre1"/>moment, our application provides <a id="id340" class="calibre1"/>three functions: a book to book a seat, a list to list all the theatre seats, and money to retrieve the account balance. In the next sections, we will enrich our application by adding some more commands.</p><div class="book" title="Adding user authentication"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec26" class="calibre1"/>Adding user authentication</h3></div></div></div><p class="calibre8">If you<a id="id341" class="calibre1"/> are running this example from a client <a id="id342" class="calibre1"/>that is located on the same machine as the application server, the remoting framework will silently allow communication between the client and your EJB's classes. On the other hand, for a client located on a remote system, you will be required to provide authentication for your requests. In order to add an application user, launch the <code class="email">add-user.sh</code> (or <code class="email">add-user.bat</code>) script, which is located at <code class="email">JBOSS_HOME/bin</code>.</p><p class="calibre8">Here's a transcript of a user creation example:</p><div class="informalexample"><pre class="programlisting">What type of user do you wish to add?
 a) Management User (mgmt-users.properties)
 b) Application User (application-users.properties)
(a): b

Enter the details of the new user to add.
Using realm 'ApplicationRealm' as discovered from the existing property files.
Username : ejbuser
Password requirements are listed below. To modify these restrictions edit the add-user.properties configuration file.
 - The password must not be one of the following restricted values {root, admin, administrator}
 - The password must contain at least 8 characters, 1 alphanumeric character(s), 1 digit(s), 1 non-alphanumeric symbol(s)
 - The password must be different from the username
Password :
Re-enter Password :
What groups do you want this user to belong to? (Please enter a comma separated list, or leave blank for none)[  ]:
About to add user 'ejbuser' for realm 'ApplicationRealm'
Is this correct yes/no? yes
Added user 'ejbuser' to file 'C:\Programs\Dev\Servers\wildfly-8.0.0.Final\standalone\configuration\application-users.properties'
Added user 'ejbuser' to file 'C:\Programs\Dev\Servers\wildfly-8.0.0.Final\domain\configuration\application-users.properties'
Added user 'ejbuser' with groups  to file 'C:\Programs\Dev\Servers\wildfly-8.0.0.Final\standalone\configuration\application-roles.properties'
Added user 'ejbuser' with groups  to file 'C:\Programs\Dev\Servers\wildfly-8.0.0.Final\domain\configuration\application-roles.properties'
Is this new user going to be used for one AS process to connect to another AS process?
e.g. for a slave host controller connecting to the master or for a Remoting connection for server to server EJB calls.
yes/no? no
Press any key to continue . . .</pre></div><p class="calibre8">The defined <a id="id343" class="calibre1"/>user will be added for you in<a id="id344" class="calibre1"/> the <code class="email">application-user.properties</code> file located in your <code class="email">configuration</code> folder.</p><p class="calibre8">This file contains the default security realm named <code class="email">ApplicationRealm</code>. This security realm uses the following format to store passwords:</p><div class="informalexample"><pre class="programlisting">username=HEX( MD5( username ':' realm ':' password))</pre></div><p class="calibre8">With the passwords you've just entered, the file will contain the following entry:</p><div class="informalexample"><pre class="programlisting">ejbuser=dc86450aab573bd2a8308ea69bcb8ba9</pre></div><p class="calibre8">Now, insert the username and password information into <code class="email">jboss-ejb-client.properties</code>:</p><div class="informalexample"><pre class="programlisting">remote.connection.default.username=ejbuser
remote.connection.default.password=ejbuser123</pre></div><p class="calibre8">Now, with <a id="id345" class="calibre1"/>all the previous information <a id="id346" class="calibre1"/>in the right place, you will be able to connect to your EJB application from a client that does not reside on the same machine as the server.</p><p class="calibre8">You can also force the normal authentication process on your local machine, by adding the following line to the <code class="email">jboss-ejb-client</code> properties:</p><div class="informalexample"><pre class="programlisting">remote.connection.default.connect.options.org.xnio.Options.SASL_DISALLOWED_MECHANISMS=JBOSS-LOCAL-USER</pre></div></div></div></div>

<div class="book" title="Creating a remote EJB client">
<div class="book" title="Using the EJB timer service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec28" class="calibre1"/>Using the EJB timer service</h2></div></div></div><p class="calibre8">Applications<a id="id347" class="calibre1"/> that model business workflows<a id="id348" class="calibre1"/> often rely on timed notifications. The timer service of the enterprise bean container enables you to schedule timed notifications for all types of enterprise beans, except for stateful session beans. You can schedule a timed notification to occur according to a calendar schedule either at a specific time, after the duration of a time period, or at timed intervals.</p><p class="calibre8">There can be two <a id="id349" class="calibre1"/>main types of EJB timers: programmatic <a id="id350" class="calibre1"/>timers and automatic timers. Programmatic timers are <a id="id351" class="calibre1"/>set by explicitly calling one of the timer creation methods<a id="id352" class="calibre1"/> of the <code class="email">TimerService</code> interface. Automatic timers are created upon the successful deployment of an enterprise bean, which contains a method annotated with the <code class="email">java.ejb.Schedule</code> or <code class="email">java.ejb.Schedules</code> annotations. Let's see both approaches in the following sections.</p><div class="book" title="Programmatic timer creation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec27" class="calibre1"/>Programmatic timer creation</h3></div></div></div><p class="calibre8">To create <a id="id353" class="calibre1"/>a timer, the bean invokes one of the <code class="email">create</code> methods<a id="id354" class="calibre1"/> of the <code class="email">TimerService</code> interface. These methods allow for either single-action, interval, or calendar-based timers to be created.</p><p class="calibre8">The simplest way to get a <code class="email">TimerService</code> instance is to use resource injection. For example, in the <code class="email">TheatreBox</code> singleton EJB, we will use the <code class="email">@Resource</code> annotation to inject a <code class="email">TimerService</code> object, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@Resource</strong></span>
<span class="strong"><strong class="calibre9">TimerService timerService;</strong></span>

private static final long DURATION = TimeUnit.SECONDS.toMillis(6);</pre></div><p class="calibre8">The duration <a id="id355" class="calibre1"/>specifies the time (in milliseconds) when<a id="id356" class="calibre1"/> the single timer is fired. The method that will fire the timer will use the <code class="email">TimerService</code> instance to invoke <code class="email">createSingleActionTimer</code>, passing the duration and an instance of the <code class="email">TimerConfig</code> class as an argument, which may optionally contain some basic information (such as the description of the timer). This is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">public void createTimer(){
    timerService.createSingleActionTimer(DURATION, new TimerConfig());
}</pre></div><p class="calibre8">Next, we will create a callback method named <code class="email">timeout</code> and use the <code class="email">@Timeout</code> annotation <a id="id357" class="calibre1"/>on top of the method. In the <code class="email">timeout</code> method, we could, for example, reinitialize our singleton by invoking the <code class="email">setupTheatre</code> method. Nothing fancy; however, this should give you an idea of how to get working with a single action timer. Refer to the following code for more information:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@Timeout</strong></span>
public void timeout(Timer timer){
    logger.info("Re-building Theatre Map."); 
    setupTheatre();
}</pre></div></div><div class="book" title="Scheduling timer events"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec28" class="calibre1"/>Scheduling timer events</h3></div></div></div><p class="calibre8">If you<a id="id358" class="calibre1"/> want to schedule timed notifications<a id="id359" class="calibre1"/> at fixed intervals, the simplest way is to use the <code class="email">@Schedule</code> annotation. The <code class="email">@Schedule</code> annotation takes a series of comma-delimited settings to <a id="id360" class="calibre1"/>express a time period or set of time periods, much as the Unix <code class="email">cron</code> utility does. Each setting corresponds to a unit of time such as an hour or minute. A simple repeating event occurring every minute can be expressed using the <code class="email">@Schedule</code> annotation as follows:</p><div class="informalexample"><pre class="programlisting">@Schedule(second="0", minute= "*", hour= "*")</pre></div><p class="calibre8">You can find some more details about building the time string at.</p><p class="calibre8">For the purpose of our example, we will create a stateless session bean, which will act as an automatic buying system and therefore, buy tickets at our ticketing store. So, we will add one competitor in our quest for the best seat in the theatre! The following code snippet<a id="id361" class="calibre1"/> explains this:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class AutomaticSellerService {

    private static final Logger logger = Logger.getLogger(AutomaticSellerService.class);

    @EJB
    private TheatreBox theatreBox;

<span class="strong"><strong class="calibre9">    @Resource</strong></span>
<span class="strong"><strong class="calibre9">    private TimerService timerService;  [1]</strong></span>

<span class="strong"><strong class="calibre9">    @Schedule(hour = "*", minute = "*/1", persistent = false)  [2]</strong></span>
    public void automaticCustomer() throws NoSuchSeatException {
        final Optional&lt;Seat&gt; seatOptional = findFreeSeat();
        if (!seatOptional.isPresent()) {
            cancelTimers();
            logger.info("Scheduler gone!");
            return; // No more seats
        }

        final Seat seat = seatOptional.get();

        try {
<span class="strong"><strong class="calibre9">            theatreBox.buyTicket(seat.getId());   [3]</strong></span>
        } catch (SeatBookedException e) {
            // do nothing, user booked this seat in the meantime
        }

        logger.info("Somebody just booked seat number " + seat.getId());
    }

    private Optional&lt;Seat&gt; findFreeSeat() {
        final Collection&lt;Seat&gt; list = theatreBox.getSeats();
        return list.stream()
            .filter(seat -&gt; !seat.isBooked())
            .findFirst();
    }
    private void cancelTimers() {  [4]
        for (Timer timer : timerService.getTimers()) {
<span class="strong"><strong class="calibre9">            timer.cancel();</strong></span>
        }
    }
}</pre></div><p class="calibre8">The first<a id="id362" class="calibre1"/> thing we should account for is the<a id="id363" class="calibre1"/> resource injection of the <code class="email">Timer</code> object <code class="email">[1]</code>, which will be used in the <code class="email">cancelTimers</code> method <code class="email">[4]</code> to cancel all the scheduling when the theatre is fully booked. Please note that the <code class="email">timerService.getTimers()</code> method retrieves all active timers associated only with the current bean. In order to get all timers from your application module, you have to use the <code class="email">timerService.getAllTimers()</code> method, which was added recently in EJB 3.2.</p><p class="calibre8">Next, pay attention to the <code class="email">Schedule</code> annotation <code class="email">[2]</code> we are using, which will fire a non-persistent timer each minute.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre8">Persistent timers (the default option) can survive application and server crashes. When the system recovers, any persistent timers will be recreated and missed callback events will be executed.</p><p class="calibre8">When a replay of missed timer events is not desired, a non-persistent timer should be used, as shown in the preceding example.</p></div><p class="calibre8">When an action is fired, the <code class="email">automaticCustomer</code> method starts scanning the theatre seats for an available seat. (Nothing too complex; <code class="email">findSeat</code> starts looking from the first available seat.)</p><p class="calibre8">Finally, if there are seats still available, the <code class="email">buyTicket</code> method <code class="email">[3]</code> of the <code class="email">TheatreBox</code> singleton will be used to short circuit the purchase of the seat (obviously, we won't need to check the money for our automatic customer).</p></div></div></div>

<div class="book" title="Creating a remote EJB client">
<div class="book" title="Adding asynchronous methods to our EJBs"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec29" class="calibre1"/>Adding asynchronous methods to our EJBs</h2></div></div></div><p class="calibre8">Before <a id="id364" class="calibre1"/>the EJB 3.1 specification, the <a id="id365" class="calibre1"/>only way to provide asynchronous<a id="id366" class="calibre1"/> capabilities to enterprise applications was using message-driven bean recipes. This remains substantially a best practice, and we are going to discuss this in depth in <a class="calibre1" title="Chapter 6. Developing Applications with JBoss JMS Provider" href="part0035_split_000.html#page">Chapter 6</a>, <span class="strong"><em class="calibre10">Developing Applications with JBoss JMS Provider</em></span>; however, in some cases, it might be desirable (and easier) to use these asynchronous features from a component that follows the classical request-reply pattern.</p><p class="calibre8">You can make the EJB's method asynchronous by simply tagging it with the <code class="email">@Asynchronous</code> annotation. Each time this method is invoked, it will immediately return, regardless of how long the method actually takes to complete.</p><p class="calibre8">This can be used in one of two ways:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first technique is a fire-and-forget manner, where the request is made up of the EJB and the client is not concerned about the success or failure of the request.</li><li class="listitem">The second modus operandi invokes<a id="id367" class="calibre1"/> the<a id="id368" class="calibre1"/> method <a id="id369" class="calibre1"/>but does not wait for the method to be completed. The method returns a <code class="email">Future</code> object. This object is used later to determine the result of the request.</li></ul></div><div class="book" title="Using fire-and-forget asynchronous calls"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec29" class="calibre1"/>Using fire-and-forget asynchronous calls</h3></div></div></div><p class="calibre8">If you<a id="id370" class="calibre1"/> don't care about<a id="id371" class="calibre1"/> the async result, you can just have your <code class="email">async</code> method return void. For this purpose, we will add a new method named <code class="email">bookSeatAsync</code> to <code class="email">TheatreBooker</code> and simply tag it as <code class="email">@Asynchronous</code>. This is shown in the following screenshot:</p><div class="informalexample"><pre class="programlisting"> @Asynchronous
 public void bookSeatAsync(int seatId) throws NotEnoughMoneyException, NoSuchSeatException, SeatBookedException {
        bookSeat(seatId);
}</pre></div><p class="calibre8">As you can see, this method does not return anything; it just executes our synchronous <code class="email">bookSeet</code> method. We will need to use some other instruments to check whether the transaction was completed successfully. For example, we can check from the theatre list whether the seat has been booked successfully.</p></div><div class="book" title="Returning a Future object to the client"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec30" class="calibre1"/>Returning a Future object to the client</h3></div></div></div><p class="calibre8">The<a id="id372" class="calibre1"/> other <a id="id373" class="calibre1"/>available<a id="id374" class="calibre1"/> option consists of returning a <code class="email">java.util.concurrent.Future</code> object, which can later be inspected by our clients so that they know the outcome of our transaction. This is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">@Asynchronous
@Override
public Future&lt;String&gt; bookSeatAsync(int seatId) {
        try {
            Thread.sleep(10000);
            bookSeat(seatId);
            return new AsyncResult&lt;&gt;("Booked seat: " + seatId + ". Money left: " + money);
        } catch (NoSuchSeatException | SeatBookedException | NotEnoughMoneyException | InterruptedException e) {
            return new AsyncResult&lt;&gt;(e.getMessage());
        }
    }</pre></div><p class="calibre8">In this <a id="id375" class="calibre1"/>case, calls to the asynchronous<a id="id376" class="calibre1"/> <code class="email">bookSeatAsync</code> method simply results, behind <a id="id377" class="calibre1"/>the scenes, in a <code class="email">Runnable</code> or <code class="email">Callable Java</code> object being created, which wraps the method and parameters you provide. This <code class="email">Runnable</code> (or callable) object is given to an <code class="email">Executor</code> object, which is simply a work queue attached to a thread pool.</p><p class="calibre8">After adding the work to the queue, the proxy version of the method returns a Future implementation that is linked to <code class="email">Runnable</code>, which is now waiting in the queue.</p><p class="calibre8">When <code class="email">Runnable</code> finally executes the <code class="email">bookSeatAsync</code> method, it takes the return value and sets it to <code class="email">Future</code>, making it available to the caller.</p><p class="calibre8">When dealing with <code class="email">Future</code> objects, the client code needs to be adapted. As a matter of fact, in standard synchronous calls, we used exceptions to intercept some events such as when the customer does not have enough money to complete the transaction. When using <code class="email">Future</code> calls, there's a change in this paradigm. The call to the asynchronous method is detached from the client; however, we have the option to check if the <code class="email">Future</code> work has been completed with the <code class="email">isDone</code> method issued on the Future return value.</p><p class="calibre8">For this purpose, let's add a <code class="email">bookasync</code> command to <code class="email">TicketAgencyClient</code>, which will issue asynchronous booking and a mail command that will simulate the reading of the outcome by e-mail, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">private final List&lt;Future&lt;String&gt;&gt; lastBookings = new ArrayList&lt;&gt;(); [1]
 // Some code
  <span class="strong"><strong class="calibre9">  case BOOKASYNC:</strong></span>
<span class="strong"><strong class="calibre9">        handleBookAsync();</strong></span>
<span class="strong"><strong class="calibre9">        break;</strong></span>
<span class="strong"><strong class="calibre9">    case MAIL:</strong></span>
<span class="strong"><strong class="calibre9">        handleMail();</strong></span>
<span class="strong"><strong class="calibre9">        break; </strong></span>
// Some code
private void handleBookAsync() {
    String text = IOUtils.readLine("Enter SeatId: ");
    int seatId;

    try {
        seatId = Integer.parseInt(text);
    } catch (NumberFormatException e1) {
        logger.warning("Wrong seatId format!");
        return;
    }

<span class="strong"><strong class="calibre9">    lastBookings.add(theatreBooker.bookSeatAsync(seatId));  [2]</strong></span>
    logger.info("Booking issued. Verify your mail!");
}

private void handleMail() {
    boolean displayed = false;
    final List&lt;Future&lt;String&gt;&gt; notFinished = new ArrayList&lt;&gt;();
    for (Future&lt;String&gt; booking : lastBookings) {
<span class="strong"><strong class="calibre9">        if (booking.isDone()) {  [3]</strong></span>
            try {
                final String result = booking.get();
                logger.info("Mail received: " + result);
                displayed = true;
            } catch (InterruptedException | ExecutionException e) {
                logger.warning(e.getMessage());
            }
        } else {
            notFinished.add(booking);
        }
    }

    lastBookings.retainAll(notFinished);
    if (!displayed) {
        logger.info("No mail received!");
    }
}</pre></div><p class="calibre8">As<a id="id378" class="calibre1"/> you can see from the previous <a id="id379" class="calibre1"/>code snippet, we issue an asynchronous <a id="id380" class="calibre1"/>booking <code class="email">[2]</code> and add <code class="email">Future&lt;?&gt;</code> to <code class="email">lastBookings</code> list <code class="email">[1]</code>. On the EJB side, we introduced a pause of 10 seconds to complete the booking so that later on, we can check if the work has been completed by checking the <code class="email">isDone</code> method <code class="email">[3]</code> of the <code class="email">lastBookings</code> list elements object.</p><p class="calibre8">Here is a screenshot of our richer client application:</p><div class="mediaobject"><img src="../images/00039.jpeg" alt="Returning a Future object to the client" class="calibre11"/></div><p class="calibre12"> </p></div></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec22" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we went through the EJB basics and changes in EJB 3.2 by following a simple lab example, which was enriched progressively. This example showed how the Maven project can be used from within the Eclipse environment to assist you in assembling the project with all the necessary dependencies.</p><p class="calibre8">Up to now, we have just coded a remote standalone client for our application. In the next chapter, we will see how to add a web frontend to our example using the context and dependency injections, to bridge the gap between the web tier and enterprise tier.</p></div></body></html>