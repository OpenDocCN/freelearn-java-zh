- en: Chapter 2. Communication in JSF
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. JSF 中的通信
- en: Communication is the core of a JSF application, and is one of the main aspects
    that dictate the architecture of such an application. Thinking of the big picture,
    you need to identify—right from the start—the main parts and how they will communicate
    with one another and with the end user. After selecting design patterns, drawing
    the UML diagrams, and sketching the architecture and the application flow, it's
    time to get to work and start implementing the communication pipes using forms,
    parameters, arguments, values, pages, beans, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通信是 JSF 应用程序的核心，也是决定此类应用程序架构的主要方面之一。从大局出发，你需要从一开始就确定主要部分以及它们将如何相互以及与最终用户进行通信。在选择了设计模式、绘制
    UML 图、草拟架构和应用流程之后，是时候开始工作并开始使用表单、参数、参数、值、页面、Bean 等实现通信管道了。
- en: 'Fortunately, JSF provides many solutions for ensuring a powerful and flexible
    communication layer between JSF components and also between JSF and XHTML pages,
    the JavaScript code, and other third-party components. In this chapter, we will
    cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JSF 提供了许多解决方案，以确保 JSF 组件之间以及 JSF 和 XHTML 页面、JavaScript 代码和其他第三方组件之间有一个强大且灵活的通信层。在本章中，我们将涵盖以下主题：
- en: Using context parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文参数
- en: Passing request parameters with the `<f:param>` tag
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `<f:param>` 标签传递请求参数
- en: Working with view parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与视图参数一起工作
- en: Calling actions on GET requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GET 请求中调用动作
- en: Passing attributes with the `<f:attribute>` tag
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `<f:attribute>` 标签传递属性
- en: Setting property values via action listeners
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过动作监听器设置属性值
- en: Passing parameters using the Flash scope
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flash 范围传递参数
- en: Replacing the `<f:param>` tag with the JSTL `<c:set>` tag
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 JSTL `<c:set>` 标签替换 `<f:param>` 标签
- en: Sending data through cookies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Cookie 发送数据
- en: Working with hidden fields
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与隐藏字段一起工作
- en: Sending passwords
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送密码
- en: Accessing UI component attributes programmatically
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式访问 UI 组件属性
- en: Passing parameters via method expressions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过方法表达式传递参数
- en: Communicating via the `binding` attribute
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `binding` 属性进行通信
- en: Passing and getting parameters
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递和获取参数
- en: As you will see in the next sections, JSF provides several approaches to pass/get
    parameters to/from Facelets, managed beans, UI components, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一节中看到的，JSF 提供了多种方法来传递/获取参数到/从 Facelets、管理 Bean、UI 组件等。
- en: Using context parameters
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用上下文参数
- en: 'Context parameters are defined in the `web.xml` file using the `<context-param>`
    tag. This tag allows two important children: `<param-name>`, which indicates the
    parameter name, and `<param-value>`, which indicates the parameter value. For
    example, a user-defined context parameter looks like the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文参数使用 `<context-param>` 标签在 `web.xml` 文件中定义。此标签允许两个重要的子标签：`<param-name>`，表示参数名称，以及
    `<param-value>`，表示参数值。例如，一个用户定义的上下文参数如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, in a JSF page, you can access this parameter as shown in the following
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 JSF 页面中，你可以像以下代码所示访问此参数：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In a managed bean, the same context parameter can be accessed via the `getInitParameter`
    method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个管理 Bean 中，可以通过 `getInitParameter` 方法访问相同的上下文参数：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The complete application is named `ch2_27`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch2_27`。
- en: Passing request parameters with the <f:param> tag
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `<f:param>` 标签传递请求参数
- en: Sometimes, you need to pass parameters from a Facelet to a managed bean or to
    another Facelet. In this case, you may need the `<f:param>` tag, which can be
    used to add query string name-value pairs to a request, or put simply, to send
    request parameters. Commonly, the `<f:param>` tag is used inside the `<h:commandButton>`
    and `<h:commandLink>` tags for sending request parameters to a managed bean. For
    example, the following snippet of code adds two parameters to the request when
    the form is submitted. These parameters are accessed in the `PlayersBean` bean;
    the first parameter is named `playerNameParam` and the second one is named `playerSurnameParam`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要从 Facelet 将参数传递到管理 Bean 或另一个 Facelet。在这种情况下，你可能需要 `<f:param>` 标签，它可以用于向请求添加查询字符串名称-值对，或者简单地说，发送请求参数。通常，`<f:param>`
    标签用于 `<h:commandButton>` 和 `<h:commandLink>` 标签内部，用于向管理 Bean 发送请求参数。例如，以下代码片段在表单提交时向请求添加两个参数。这些参数在
    `PlayersBean` Bean 中访问；第一个参数名为 `playerNameParam`，第二个参数名为 `playerSurnameParam`。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, when the button is clicked, the request parameters are sent
    and the `parametersAction` method is called (via `action` or `actionListener`).
    When the application flow reaches this method, the two request parameters are
    already available for use. You can easily extract them inside this method by accessing
    the request parameters map through the current `FacesContext` instance as shown
    in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当按钮被点击时，请求参数被发送并且调用`parametersAction`方法（通过`action`或`actionListener`）。当应用程序流程到达此方法时，两个请求参数已经可用于使用。你可以通过当前`FacesContext`实例访问请求参数映射，如以下代码所示来轻松提取它们：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The values of both the parameters are stored in the `playerName` and `playerSurname`
    managed beans'' properties (these can be modified further without affecting the
    original parameters), but you can easily display the parameters'' values using
    the `param` EL reserved word in *some_page* (remember the *EL implicit objects*
    section of [Chapter 1](ch01.html "Chapter 1. Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)"), *Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)*, which explains that `param` is a predefined
    variable referring to the request parameter map):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数的值都存储在`playerName`和`playerSurname`托管Bean的属性中（这些可以进一步修改而不会影响原始参数），但你可以通过在*some_page*中使用`param`
    EL保留字轻松显示参数值（记住[第1章](ch01.html "第1章。通过表达式语言(EL 3.0)动态访问JSF应用程序数据")中的*EL隐含对象*部分，*通过表达式语言(EL
    3.0)动态访问JSF应用程序数据*，该部分解释了`param`是一个预定义变量，它引用请求参数映射）：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `<f:param>` tag can also be used inside the `<h:outputFormat>` tag to substitute
    message parameters; `<f:param>` is used to pass parameters to a UI component as
    shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:param>`标签也可以在`<h:outputFormat>`标签内部使用，以替换消息参数；`<f:param>`用于将参数传递给UI组件，如下所示：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code''s output is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '**Name: Rafael Surname: Nadal**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**姓名：拉斐尔 姓氏：纳达尔**'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to execute some initialization tasks (or something else) after setting
    the managed bean properties but before an action method is called (if it exists),
    then you can define a public void method annotated with `@PostConstruct`. In this
    example, the `init` method will be called before the `parametersAction` method,
    and the passed request parameters are available through the request map.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在设置托管Bean属性之后但在调用动作方法之前（如果存在的话）执行一些初始化任务（或其他操作），那么你可以定义一个带有`@PostConstruct`注解的public
    void方法。在此示例中，`init`方法将在`parametersAction`方法之前被调用，并且传递的请求参数可以通过请求映射获得。
- en: 'The `init` method is shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`方法如下所示：'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example is wrapped into the application named `ch2_1`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch2_1`的应用程序中。
- en: 'If you think that it is not a very convenient approach to access the request
    map in the managed bean, then you can use `@ManagedProperty`, which sets the parameter
    as a managed bean property and links its value to the request parameter:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为在托管Bean中访问请求映射不是一个非常方便的方法，那么你可以使用`@ManagedProperty`，它将参数设置为托管Bean属性并将其值链接到请求参数：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The values are set immediately after the bean's construction and are available
    during `@PostConstruct`, but keep in mind that `@ManagedProperty` is usable only
    with beans managed by JSF (`@ManagedBean`), not with beans managed by CDI (`@Named`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值在Bean构造后立即设置，并在`@PostConstruct`期间可用，但请注意，`@ManagedProperty`仅适用于由JSF管理的Bean（`@ManagedBean`），而不是由CDI管理的Bean（`@Named`）。
- en: This example is wrapped into the application named `ch2_2` which is available
    in the code bundle of this chapter. You may also be interested in the application
    `ch2_3`, which is another example of using `<f:param>`, `@ManagedProperty`, and
    `@PostConstruct`. In this example, the `<h:commandButton>` action indicates another
    JSF page instead of a managed bean method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch2_2`的应用程序中，该应用程序位于本章的代码包中。你可能还对名为`ch2_3`的应用程序感兴趣，它是使用`<f:param>`、`@ManagedProperty`和`@PostConstruct`的另一个示例。在此示例中，`<h:commandButton>`动作指示另一个JSF页面而不是托管Bean方法。
- en: 'The `<f:param>` tag can be used to pass request parameters directly between
    Facelets, without involving a managed bean. Usually, this happens in the `<h:link>`
    tag, as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:param>`标签可以用来在Facelets之间直接传递请求参数，而不涉及托管Bean。通常，这发生在`<h:link>`标签中，如下所示：'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the **Send Rafael Nadal** link is clicked, JSF will use the prepared URL
    containing the `result.xhtml` file''s resource name and the request parameters,
    `playerNameParam` and `playerSurnameParam`. Both the parameters are displayed
    in the `result.xhtml` file as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**发送拉斐尔·纳达尔**链接时，JSF 将使用包含 `result.xhtml` 文件资源名称和请求参数 `playerNameParam` 和
    `playerSurnameParam` 的准备好的 URL。这两个参数在 `result.xhtml` 文件中如下显示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you check the URL generated by the `<h:link>` tag in the browser address
    bar, then you will see something like the following URL:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查浏览器地址栏中由 `<h:link>` 标签生成的 URL，你将看到如下类似的 URL：
- en: '`http://`*hostname*`/ch2_4/faces/result.xhtml?playerNameParam=Rafael&playerSurnameParam=Nadal`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://`*主机名*`/ch2_4/faces/result.xhtml?playerNameParam=Rafael&playerSurnameParam=Nadal`'
- en: This example is wrapped into the application named `ch2_4`. In that application,
    you can also see an example using the `<h:commandButton>` tag. Notice that, in
    this case, we need to wrap the `<h:commandButton>` tag in a `<h:form>` tag, which
    is submitted using the POST request; therefore, the request parameters are not
    visible in the URL anymore.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被包裹在名为 `ch2_4` 的应用程序中。在那个应用程序中，你还可以看到一个使用 `<h:commandButton>` 标签的示例。请注意，在这种情况下，我们需要将
    `<h:commandButton>` 标签包裹在 `<h:form>` 标签中，该表单通过 POST 请求提交；因此，请求参数不再可见于 URL 中。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `<f:param>` tag cannot be fortified with declarative/imperative validations
    and/or conversions. You need to accomplish this task by yourself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:param>` 标签不能通过声明性/命令性验证和/或转换来加强。你需要自己完成这个任务。'
- en: Do not try to place the `<f:param>` tag inside the `<h:inputText>` tag or any
    other input component. That will simply not work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试将 `<f:param>` 标签放置在 `<h:inputText>` 标签或任何其他输入组件内部。那样根本不会起作用。
- en: Working with view parameters
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与视图参数一起工作
- en: Starting with JSF 2.0, we can use a new category of parameters, known as **view
    parameters**. These kinds of parameters are implemented by the `UIViewParameter`
    class (that extends the `UIInput` class) and are defined in Facelets using the
    `<f:viewParam>` tag. Through this tag, we can declaratively register the `UIViewParameter`
    class as metadata for the parent view; this is why the `<f:viewParam>` tag is
    nested in the `<f:metadata>` tag.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.0 开始，我们可以使用一类新的参数，称为**视图参数**。这类参数由 `UIViewParameter` 类（该类扩展了 `UIInput`
    类）实现，并在 Facelets 中使用 `<f:viewParam>` 标签定义。通过这个标签，我们可以声明性地将 `UIViewParameter` 类注册为父视图的元数据；这就是为什么
    `<f:viewParam>` 标签嵌套在 `<f:metadata>` 标签中的原因。
- en: 'Starting with JSF 2.0, the metadata concept was materialized in a section of
    a view, which provides the following two main advantages (the section is demarcated
    by the `<f:metadata>` tag):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.0 开始，元数据概念在视图的一部分中实现，这提供了以下两个主要优势（该部分由 `<f:metadata>` 标签界定）：
- en: The content of this section is readable without having the entire view available
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此部分的内容在没有整个视图的情况下也是可读的
- en: At the initial request, components from this section can accomplish different
    things before the view is rendered
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始请求时，该部分的组件在视图渲染之前可以完成不同的事情
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with JSF 2.2, the metadata section (and subsequent components) is detected
    via a public static method, named the `hasMetadata` (`UIViewRoot`) method. This
    method was added in `javax.faces.view.ViewMetadata` and returns `true` if there
    is a metadata section and `false` otherwise. Among other benefits, the main advantage
    of using the `<f:viewParam>` tag is the URL bookmarking support.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.2 开始，元数据部分（以及随后的组件）通过一个名为 `hasMetadata` 的公共静态方法（`UIViewRoot`）检测。此方法添加在
    `javax.faces.view.ViewMetadata` 中，如果存在元数据部分则返回 `true`，否则返回 `false`。除了其他好处外，使用
    `<f:viewParam>` 标签的主要优势是支持 URL 书签。
- en: 'For better understanding, let''s look at a simple example of using the `<f:viewParam>`
    tag. The following pieces of code are from the same page, `index.xhtml`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们看看使用 `<f:viewParam>` 标签的一个简单示例。以下代码片段来自同一页面，`index.xhtml`：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s see what is happening at the initial request. First, let''s focus
    on the first block of code: here, JSF gets the request parameter''s values by
    their names (`playernameparam` and `playersurnameparam`) from the page URL and
    applies the specified converter/validators (these are optional). After conversion/validation
    succeeds, before the view is rendered, JSF binds the values of the `playernameparam`
    and `playersurnameparam` request parameters to the managed bean properties, `playerName`
    and `playerSurname`, by calling the `setPlayerName` and `setPlayerSurname` methods
    (called only if we provide request parameters in the URL). If the `value` attribute
    is missing, then JSF sets request parameters as request attributes on names, `playernameparam`
    and `playersurnameparam`, available via `#{playernameparam}` and `#{playersurnameparam}`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看初始请求时发生了什么。首先，让我们关注第一段代码：在这里，JSF 通过名称（`playernameparam` 和 `playersurnameparam`）从页面
    URL 中获取请求参数的值，并应用指定的转换器/验证器（这些是可选的）。在转换/验证成功后，在视图渲染之前，JSF 通过调用 `setPlayerName`
    和 `setPlayerSurname` 方法（仅在 URL 中提供请求参数时调用）将 `playernameparam` 和 `playersurnameparam`
    请求参数的值绑定到管理 Bean 属性 `playerName` 和 `playerSurname`。如果缺少 `value` 属性，则 JSF 将请求参数作为请求属性设置在名称
    `playernameparam` 和 `playersurnameparam` 上，可通过 `#{playernameparam}` 和 `#{playersurnameparam}`
    访问。
- en: 'The page''s initial URL should be something like the following one:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的初始 URL 应该类似于以下内容：
- en: '`http://`*hostname*`/ch2_5/?playernameparam=Rafael&playersurnameparam=Nadal`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://`*hostname*`/ch2_5/?playernameparam=Rafael&playersurnameparam=Nadal`'
- en: In the second block of code, the values of the managed bean properties, `playerName`
    and `playerSurname`, are displayed (the `getPlayerName` and `getPlayerSurname`
    methods are called); they should reflect the values of the request parameters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二段代码中，显示管理 Bean 属性 `playerName` 和 `playerSurname` 的值（调用 `getPlayerName` 和
    `getPlayerSurname` 方法）；它们应该反映请求参数的值。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the `UIViewParameter` class extends the `UIInput` class, the managed bean
    properties are set during the **Update Model** phase only.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `UIViewParameter` 类扩展了 `UIInput` 类，管理 Bean 属性仅在 **更新模型** 阶段设置。
- en: This example is wrapped into the application named `ch2_5`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包含在名为 `ch2_5` 的应用程序中。
- en: View parameters can be included in links (the GET query string) by using the
    `includeViewParams="true"` attribute in the `<h:link>` tag, or the `includeViewParams=true`
    request parameter in any URL. Both these cases can be seen in the upcoming examples.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 视图参数可以通过在 `<h:link>` 标签中使用 `includeViewParams="true"` 属性或在任何 URL 中使用 `includeViewParams=true`
    请求参数包含在链接（GET 查询字符串）中。这两种情况将在下面的示例中看到。
- en: 'In the `index.xhtml` file, you can have something like the following code,
    in which view parameters are included through the request parameter:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.xhtml` 文件中，你可以有如下代码，其中通过请求参数包含视图参数：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The initial URL can be:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 初始 URL 可以是：
- en: '`http://`*hostname*`/ch2_6/?playernameparam=Rafael&playersurnameparam=Nadal`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://`*hostname*`/ch2_6/?playernameparam=Rafael&playersurnameparam=Nadal`'
- en: 'The view parameters, `playernameparam` and `playersurnameparam`, will be extracted
    from this URL and bound to the managed bean properties, `playerName` and `playerSurname`.
    Optionally, both properties can be further altered by the user through two `<h:inputText>`
    tags, or other UI components. (If the initial URL does not contain the view parameters,
    then the `<h:inputText>` generated fields will be empty.) The button rendered
    through the `<h:commandButton>` tag will redirect the flow to the `results.xhtml`
    page and will include the view parameters in the new URL. The values of the view
    parameters will reflect the values of the corresponding managed bean properties,
    since the form is submitted before the following URL is composed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 视图参数，`playernameparam` 和 `playersurnameparam`，将从此 URL 中提取并绑定到管理 Bean 属性，`playerName`
    和 `playerSurname`。可选地，这两个属性可以通过两个 `<h:inputText>` 标签或其它 UI 组件由用户进一步修改。如果初始 URL
    不包含视图参数，则由 `<h:inputText>` 生成的字段将为空。通过 `<h:commandButton>` 标签渲染的按钮将重定向到 `results.xhtml`
    页面，并将视图参数包含在新 URL 中。视图参数的值将反映相应管理 Bean 属性的值，因为表单是在以下 URL 组合之前提交的：
- en: '`http://`*hostname*`/ch2_6/faces/results.xhtml?playernameparam=Rafael&playersurnameparam=Nadal`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://`*hostname*`/ch2_6/faces/results.xhtml?playernameparam=Rafael&playersurnameparam=Nadal`'
- en: 'The `results.xhtml` file (or any other page that the `index.xhtml` file directs)
    will use the `<f:viewParam>` tag to take parameters from the GET request into
    bound properties, as shown in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`results.xhtml` 文件（或 `index.xhtml` 文件指向的任何其他页面）将使用 `<f:viewParam>` 标签从 GET
    请求中获取参数到绑定属性，如下面的代码所示：'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you prefer to use a `<h:link>` tag in conjunction with the `includeViewParams`
    attribute set to `true`, then the `index.xhtml` file will be as follows (in this
    case, there is no form submission and no POST request):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用`<h:link>`标签，并且将`includeViewParams`属性设置为`true`，那么`index.xhtml`文件将如下所示（在这种情况下，没有表单提交和POST请求）：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These examples are wrapped into the application named `ch2_6`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例被封装在名为`ch2_6`的应用程序中。
- en: 'You can use the `includeViewParams` request parameter in any URL, which means
    that you can use it in managed beans to include view parameters in the navigation
    links as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何URL中使用`includeViewParams`请求参数，这意味着你可以在管理Bean中使用它，在导航链接中包含视图参数，如下所示：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And the action method is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 操作方法如下：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The complete application is named `ch2_7` and is available in the code bundle
    of this chapter on the Packt Publishing website.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为`ch2_7`，可在Packt Publishing网站的该章节代码包中找到。
- en: 'As you know from the previous code, the `UIViewParameter` class extends the
    `UIInput` class, which means that it inherits all attributes, such as `required`
    and `requiredMessage`. When the URL must contain view parameters, you can use
    these two attributes to ensure that the application flow is controlled and the
    user is correctly informed. The following is the example code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，`UIViewParameter`类扩展了`UIInput`类，这意味着它继承了所有属性，例如`required`和`requiredMessage`。当URL必须包含视图参数时，你可以使用这两个属性来确保应用程序流程得到控制，并且用户得到正确通知。以下是一个示例代码：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the initial URL does not contain the view parameters (one or both), then
    you will receive a message that report this fact. This example is wrapped into
    the application named `ch2_9`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始URL不包含视图参数（一个或两个），那么你将收到一条消息，报告这一事实。此示例被封装在名为`ch2_9`的应用程序中。
- en: 'Moreover, view parameters support fine-grained conversion and validation. You
    can use `<f:validator>` and `<f:converter>`, or the `validator` and `converter`
    attributes inherited from the `UIInput` class. Supposing that you have a custom
    validator, named `PlayerValidator` (its implementation is not really relevant),
    the following is its code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，视图参数支持细粒度的转换和验证。你可以使用`<f:validator>`和`<f:converter>`，或者从`UIInput`类继承的`validator`和`converter`属性。假设你有一个名为`PlayerValidator`的自定义验证器（其实际实现并不重要），以下是其代码：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, you can attach it to a view parameter as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将其附加到视图参数上，如下所示：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding snippet of code accomplishes the following tasks:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段完成了以下任务：
- en: Gets the request parameters' values by their names, `playernameparam` and `playersurnameparam`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称获取请求参数的值，`playernameparam`和`playersurnameparam`
- en: Converts and validates (in this case, validates) parameters
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换并验证（在这种情况下，验证）参数
- en: If conversions and validations end successfully, then the parameters are set
    in managed bean properties
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果转换和验证成功结束，则参数被设置在管理Bean属性中
- en: Any validation failure will result in a message being displayed
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何验证失败都将导致显示一条消息
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the customize messages style, you can attach a `<h:message>` tag to the
    `<f:viewParam>` tag.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义消息样式，你可以将`<h:message>`标签附加到`<f:viewParam>`标签上。
- en: This example is wrapped into the application named `ch2_10`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch2_10`的应用程序中。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to preserve the view parameters over validation failures, then you
    need to use a broader scope than `@RequestScoped`, such as `@ViewScoped`, or to
    manually preserve the request parameters for the subsequent requests through the
    `<f:param>` tag in the command components.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望保留验证失败后的视图参数，那么你需要使用比`@RequestScoped`更广泛的范围，例如`@ViewScoped`，或者通过命令组件中的`<f:param>`标签手动保留请求参数以供后续请求使用。
- en: 'Sometimes, you may need a converter for a view parameter. For example, if you
    try to pass a `java.util.Date` parameter as a view parameter from a managed bean,
    you will probably will code it as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要一个视图参数的转换器。例如，如果你尝试从一个管理Bean中将`java.util.Date`参数作为视图参数传递，你可能会这样编写代码：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, in the `date.xhtml` file, you need to convert the view parameter from
    string to `date`, and for this, you may use the `<f:convertDateTime>` converter,
    as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`date.xhtml`文件中，你需要将视图参数从字符串转换为`date`，为此，你可以使用以下代码中的`<f:convertDateTime>`转换器：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Of course, a custom converter can also be used. The complete application is
    named `ch2_29`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以使用自定义转换器。完整的应用程序名为`ch2_29`。
- en: 'Among so many advantages of using the `<f:viewParam>` tag, we have a gap. When
    view parameters are set in managed bean properties, the set values are not available
    in `@PostConstruct`; therefore, you cannot perform initialization or preload tasks
    directly. You can quickly fix this by attaching the `preRenderView` event listener,
    as shown in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `<f:viewParam>` 标签的许多优点中，我们有一个差距。当视图参数设置在管理 Bean 属性中时，设置的值在 `@PostConstruct`
    中不可用；因此，你无法直接执行初始化或预加载任务。你可以通过附加 `preRenderView` 事件监听器来快速修复这个问题，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `init` method is shown as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 方法如下所示：'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The set values are not available in `@PostConstruct` when using the `<f:viewParam>`
    tag. You can fix this by attaching the `preRenderView` event listener, or, as
    you will see next, the `<f:viewAction>` tag.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<f:viewParam>` 标签时，设置的值在 `@PostConstruct` 中不可用。你可以通过附加 `preRenderView` 事件监听器来修复这个问题，或者，如你将看到的，通过
    `<f:viewAction>` 标签。
- en: This example is wrapped into the application named `ch2_8`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包含在名为 `ch2_8` 的应用程序中。
- en: Well, there is one more aspect that I'd like to discuss here. The `UIViewParameter`
    class (`<f:viewParam>`) is a stateful component that stores its value in state.
    This is very nice as the value is available over postbacks, even if it doesn't
    come from the page URL anymore or the managed bean is request scoped. So, you
    need to indicate view parameters only once, and not for every request. But, there
    are a few drawbacks of this behavior—the most significant being calling the setter
    method at each postback (you don't want this in view beans). Another one is calling,
    for each postback, the method indicated through the `preRenderView` event handler;
    this can be fixed using a test as shown in the following code. The complete application
    is named `ch2_28`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里还有一个我想讨论的方面。`UIViewParameter` 类 (`<f:viewParam>`) 是一个有状态的组件，它将值存储在状态中。这很好，因为即使在值不再来自页面
    URL 或管理 Bean 是请求作用域的情况下，值仍然在回发中可用。因此，你只需要指示一次视图参数，而不是每次请求都要指示。但是，这种行为的缺点有几个——最显著的是在每次回发时调用设置方法（你不想在视图
    Bean 中这样做）。另一个缺点是在每次回发时调用通过 `preRenderView` 事件处理器指示的方法；这可以通过以下代码中的测试来修复。完整的应用程序命名为
    `ch2_28`。
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Maybe the most painful drawback is converting and validating view parameters
    at each postback. Obviously, this is not the behavior you are expecting to see.
    In order to call a converter/validator only when the page URL contains the request
    parameters, you need to alter the `UIViewParameter` class implementation by writing
    a custom implementation. You can try to write a stateless `UIViewParameter` class
    or to control the conversion/validation calls. Of course, you have to keep in
    mind that altering the default implementation may lead to more or less unpredictable
    drawbacks. As an alternative, you can use the `<o:viewParam>` tag from OmniFaces,
    which fixes these issues. A relevant example can be seen at [http://showcase.omnifaces.org/components/viewParam](http://showcase.omnifaces.org/components/viewParam).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最痛苦的缺点是在每次回发时转换和验证视图参数。显然，这不是你期望看到的行为。为了仅在页面 URL 包含请求参数时调用转换器/验证器，你需要通过编写自定义实现来修改
    `UIViewParameter` 类的实现。你可以尝试编写一个无状态的 `UIViewParameter` 类或控制转换/验证调用。当然，你必须记住，修改默认实现可能会导致更多或更不可预测的缺点。作为替代方案，你可以使用
    OmniFaces 的 `<o:viewParam>` 标签，它解决了这些问题。相关示例可以在 [http://showcase.omnifaces.org/components/viewParam](http://showcase.omnifaces.org/components/viewParam)
    上看到。
- en: So, as a final conclusion of this section, the `<f:viewParam>` tag is used to
    capture the request parameters. Moreover, it can be used with the `<h:link>` and
    `<h:button>` tags to send outgoing request parameters, or in non-JSF forms, to
    send data to JSF pages that use the `<f:viewParam>` tag, or to make JSF results
    pages bookmarkable in a POST-redirect-GET flow. On the other hand, the `<f:viewParam>`
    tag doesn't sustain the `<h:form>` tag to use GET or provide access to random
    JSF pages via the GET request.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为本节的最终结论，`<f:viewParam>` 标签用于捕获请求参数。此外，它可以与 `<h:link>` 和 `<h:button>` 标签一起使用，以发送出站请求参数，或者在非
    JSF 表单中，将数据发送到使用 `<f:viewParam>` 标签的 JSF 页面，或者使 JSF 结果页面在 POST-redirect-GET 流中可书签。另一方面，`<f:viewParam>`
    标签不支持 `<h:form>` 标签使用 GET 或通过 GET 请求提供对随机 JSF 页面的访问。
- en: Calling actions on GET requests
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 GET 请求上调用动作
- en: Starting with JSF 2.2, we can deal with calling actions on GET requests by using
    the new generic **view action** feature (well-known in Seam 2 and 3). This new
    feature is materialized in the `<f:viewAction>` tag, which is declared as a child
    of the metadata facet, `<f:metadata>`. This allows the view action to be part
    of the JSF life cycle for faces/non-faces requests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.2 开始，我们可以通过使用新的通用 **视图操作** 功能（在 Seam 2 和 3 中广为人知）来处理在 GET 请求上调用操作。这个新功能体现在
    `<f:viewAction>` 标签中，它被声明为元数据面 `<f:metadata>` 的子标签。这允许视图操作成为 faces/non-faces 请求的生命周期的一部分。
- en: 'In the preceding section, we saw how to attach a custom validator to a `<f:viewParam>`
    tag for validating view parameters. The same thing can be accomplished using the
    `<f:viewAction>` tag, when the validation method is declared in the managed bean
    instead of being a separate implementation of the `Validator` interface. For example,
    in the `index.xhtml` file, you may have the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何将自定义验证器附加到 `<f:viewParam>` 标签上以验证视图参数。当验证方法在托管 Bean 中声明而不是作为
    `Validator` 接口的独立实现时，可以使用 `<f:viewAction>` 标签完成同样的事情。例如，在 `index.xhtml` 文件中，您可能有以下代码：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, the following `validateData` method is just a common method
    declared in `PlayersBean`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，下面的 `validateData` 方法只是在 `PlayersBean` 中声明的一个普通方法：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example is wrapped into the application named `ch2_11`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例被封装在名为 `ch2_11` 的应用程序中。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `<f:viewAction>` tag and the `preRenderView` event listener are not the
    same!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:viewAction>` 标签和 `preRenderView` 事件监听器不是相同的！'
- en: 'The preceding note underlines our next discussion. You may think that they
    are the same because in the preceding example, you can replace `<f:viewAction>`
    with `preRenderView` and obtain the same effect (result). Well, it is true that
    they are partially the same, but a few existing differences are important, as
    you can see in the following four bullets:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的说明强调了我们的下一个讨论。您可能会认为它们是相同的，因为在先前的示例中，您可以替换 `<f:viewAction>` 为 `preRenderView`
    并获得相同的效果（结果）。确实，它们在某种程度上是相同的，但以下四个要点中的一些现有差异很重要，如下所示：
- en: 'By default, the `preRenderView` event listener is executed on postback requests,
    while the view action is not. In the case of the `preRenderView` event listener,
    you need to overcome this by testing the request type as follows:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`preRenderView` 事件监听器在回发请求上执行，而视图操作则不会。在 `preRenderView` 事件监听器的情况下，您需要通过以下方式测试请求类型来克服这一点：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For example, the following code will try to apply some modifications over the
    set values using the `preRenderView` event listener:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，以下代码将尝试使用 `preRenderView` 事件监听器对集合值应用一些修改：
- en: '[PRE28]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `init` method is declared in `PlayersBean` and it just turns the set values
    to uppercase, as shown in the following code:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`init` 方法在 `PlayersBean` 中声明，它只是将集合值转换为大写，如下面的代码所示：'
- en: '[PRE29]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, when the JSF page is rendered, the set values are used in uppercase,
    and further requests can be accomplished (for example, you may want to call the
    method `#{playersBean.userAction()}` when a certain button is clicked). But, each
    further request will call the `init` method again (after the `userAction` method),
    because the `preRenderView` event listener is executed at postback time. Except
    for the case when this is the desired functionality, you need to programmatically
    test the postbacks to prevent the following `init` method code from being executed:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，当 JSF 页面渲染时，将使用大写形式的集合值，并且可以完成进一步的请求（例如，当某个按钮被点击时，您可能想调用 `#{playersBean.userAction()}`
    方法）。但是，每个进一步的请求都会再次调用 `init` 方法（在 `userAction` 方法之后），因为 `preRenderView` 事件监听器在回发时执行。除非这是期望的功能，否则您需要通过编程测试回发以防止以下
    `init` 方法代码被执行：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Well, this is not the same in the case of the `<f:viewAction>` tag. Replace
    the `preRenderView` event listener with the `<f:viewAction>` tag, as shown in
    the following code:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嗯，在 `<f:viewAction>` 标签的情况下，情况并不相同。将 `preRenderView` 事件监听器替换为 `<f:viewAction>`
    标签，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `<f:viewAction>` tag supports an attribute named `onPostback` which is
    set to `false` by default, meaning that the `init` method will not be called on
    postback requests. Of course, if you set it to `true`, then it will function contrary;
    but, notice that in the case of the `preRenderView` event listener, the `init`
    method is called after the `userAction` method, while in the case of the `<f:viewAction>`
    tag, the `init` method is called before the `userAction` method, as shown in the
    following line of code:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<f:viewAction>`标签支持一个名为`onPostback`的属性，默认设置为`false`，这意味着在回发请求上不会调用`init`方法。当然，如果你将其设置为`true`，那么它将起相反的作用；但是，请注意，在`preRenderView`事件监听器的情况下，`init`方法是在`userAction`方法之后调用的，而在`<f:viewAction>`标签的情况下，`init`方法是在`userAction`方法之前调用的，如下面的代码行所示：'
- en: '[PRE32]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The example based on the `preRenderView` event listener is wrapped in the application
    named `ch_12_1`, while for the `<f:viewAction>` tag it is named `ch_12_2`.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于`preRenderView`事件监听器的示例被封装在名为`ch_12_1`的应用程序中，而对于`<f:viewAction>`标签，它被命名为`ch_12_2`。
- en: The view action has navigation capabilities, while the `preRenderView` event
    listener doesn't. While the view action can naturally accomplish navigation tasks,
    the `preRenderView` event listener requires explicit navigation based on the JSF
    API.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图操作具有导航能力，而`preRenderView`事件监听器则没有。虽然视图操作可以自然地完成导航任务，但`preRenderView`事件监听器需要基于JSF
    API进行显式导航。
- en: 'For example, if you modify the preceding `init` method to return the `start.xhtml`
    view, then you will probably change it as shown in the following code:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果你将前面的`init`方法修改为返回`start.xhtml`视图，那么你可能需要将其修改如下面的代码所示：
- en: '[PRE33]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But, this will not work with the `preRenderView` event listener! You will need
    to add explicit navigation by returning void and replacing the return `"start"`
    code line with the following code:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，这不会与`preRenderView`事件监听器一起工作！你需要通过返回`void`并替换返回`"start"`代码行来添加显式导航：
- en: '[PRE34]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you drop the `preRenderView` event listener and use the `<f:viewAction>`
    tag instead, then the preceding `init` method will correctly navigate to `start.xhtml`
    without involving an explicit call of the navigation handler.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你移除`preRenderView`事件监听器并使用`<f:viewAction>`标签代替，那么前面的`init`方法将正确导航到`start.xhtml`，而不需要显式调用导航处理程序。
- en: The example based on the `preRenderView` event listener is wrapped in the application
    named `ch_13_1`, while for the `<f:viewAction>` tag it is named `ch_13_2`.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于`preRenderView`事件监听器的示例被封装在名为`ch_13_1`的应用程序中，而对于`<f:viewAction>`标签，它被命名为`ch_13_2`。
- en: 'Moreover, the `<f:viewAction>` tag supports declarative navigation. So, you
    can write a navigation rule in the `faces-config.xml` file that is consulted before
    the page is rendered. For example:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`<f:viewAction>`标签支持声明性导航。因此，你可以在`faces-config.xml`文件中编写一个导航规则，在页面渲染之前进行查询。例如：
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, the `rafa.xhtml` page will be rendered instead of the `start.xhtml` page.
    This example is wrapped into the application named `ch2_13_3`.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，将渲染`rafa.xhtml`页面而不是`start.xhtml`页面。此示例被封装在名为`ch2_13_3`的应用程序中。
- en: 'By default, the view action is executed in the **Invoke Application** phase.
    But, it can be executed in the **Apply Request Values** phase by setting the `immediate`
    attribute to `true`, as shown in the following code:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，视图操作是在**调用应用程序**阶段执行的。但是，通过将`immediate`属性设置为`true`，它也可以在**应用请求值**阶段执行，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Moreover, you can specify in which phase to execute the action using the `phase`
    attribute whose value represents the phase name as a predefined constant. For
    example:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，你可以使用`phase`属性指定执行动作的阶段，其值表示阶段名称作为预定义的常量。例如：
- en: '[PRE37]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The supported values are `APPLY_REQUEST_VALUES`, `INVOKE_APPLICATION`, `PROCESS_VALIDATIONS`,
    and `UPDATE_MODEL_VALUES`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 支持的值有`APPLY_REQUEST_VALUES`、`INVOKE_APPLICATION`、`PROCESS_VALIDATIONS`和`UPDATE_MODEL_VALUES`。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The view action can be placed into a view metadata facet that doesn't contain
    other view parameters.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 视图操作可以放置在不含其他视图参数的视图元数据面上。
- en: Passing attributes with the <f:attribute> tag
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`<f:attribute>`标签传递属性
- en: When the `<f:param>` tag does not satisfy your needs, maybe the `<f:attribute>`
    tag will. This tag allows you to pass the value of an attribute of a component
    or to pass a parameter to a component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当`<f:param>`标签不能满足你的需求时，也许`<f:attribute>`标签可以。这个标签允许你传递组件的属性值，或者将参数传递给组件。
- en: 'For example, you can assign the value of the attribute named `value` of a `<h:commandButton>`
    tag as shown in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将`<h:commandButton>`标签的属性`value`的值分配，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will render a button labeled **Send Rafael Nadal**. Its code is given
    as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染一个标签为**发送拉斐尔·纳达尔**的按钮。其代码如下：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Moreover, the `<f:attribute>` tag can be used to pass a parameter to a component,
    as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`<f:attribute>`标签可以用来向组件传递参数，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the action listener method, you can extract the attributes'' values as shown
    in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作监听器方法中，你可以提取属性值，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This example is wrapped into the application named `ch2_14`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch2_14`的应用程序中。
- en: 'If you are a fan of PrimeFaces ([http://primefaces.org/](http://primefaces.org/)),
    then you will probably find the next example useful. One of the greatest built-in
    components of PrimeFaces is the `<p:fileUpload>` tag, which can be used, obviously,
    to upload files. Sometimes, besides the files that will be uploaded, you need
    to pass some extra parameters, for example, the files'' owner name and surname.
    Well, the `<p:fileUpload>` tag doesn''t come with a solution for this, but the
    `<f:attribute>` tag can be helpful. The following is the code of a classic `<p:fileUpload>`
    tag with the `<f:attribute>` tag:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢PrimeFaces([http://primefaces.org/](http://primefaces.org/))，那么你可能觉得下一个例子很有用。PrimeFaces最伟大的内置组件之一是`<p:fileUpload>`标签，它可以用来上传文件。有时，除了要上传的文件外，你还需要传递一些额外的参数，例如文件的所有者的名字和姓氏。嗯，`<p:fileUpload>`标签没有提供解决方案，但`<f:attribute>`标签可能会有所帮助。以下是一个经典的带有`<f:attribute>`标签的`<p:fileUpload>`标签的代码：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `handleFileUpload` method is responsible for the upload-specific steps
    (skipped in the following code), but it can also access the values passed by the
    `<f:attribute>` tag:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleFileUpload`方法负责上传特定的步骤（以下代码中省略），但它也可以访问通过`<f:attribute>`标签传递的值：'
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you are not a fan of PrimeFaces, then you might probably think that this
    example is useless, but maybe you are a fan of some other third-party library,
    such as RichFaces, ICEFaces, and MyFaces. You can apply this technique for other
    component libraries as well.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是PrimeFaces的粉丝，那么你可能认为这个例子没有用，但你可能喜欢其他第三方库，比如RichFaces、ICEFaces和MyFaces。你也可以将这项技术应用于其他组件库。
- en: This example is wrapped into the application named `ch2_15`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch2_15`的应用程序中。
- en: 'Another case when the `<f:attribute>` tag can be useful is when dynamically
    passing parameters in conjunction with UI components bound to the managed bean
    using the `binding` attribute. This is very useful, especially because there is
    no solution provided by JSF for passing parameters to the getters/setters methods
    of the bound UI components, as shown in the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:attribute>` 标签在动态传递参数时非常有用，特别是当与绑定到管理Bean的UI组件一起使用`binding`属性时。这非常有用，尤其是在JSF没有提供将参数传递给绑定UI组件的getter/setter方法的解决方案时，如下面的代码所示：'
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Now, the value of the `<h:inputText>` tag should contain the value set via the
    `<f:attribute>` tag. Be careful to use only unique names for the attributes and
    to not interfere (try to overwrite) with the default attributes of the UI component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`<h:inputText>`标签的值应包含通过`<f:attribute>`标签设置的值。请注意，仅使用唯一的属性名称，并且不要干扰（尝试覆盖）UI组件的默认属性。
- en: 'Also, the `PlayersBean` managed bean''s code is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`PlayersBean` 管理Bean的代码如下：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, all the parameters passed this way are accessible via the `getAttributes`
    method of the parent UI component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过这种方式传递的所有参数都可以通过父UI组件的`getAttributes`方法访问。
- en: This example is wrapped into the application named `ch2_23`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch2_23`的应用程序中。
- en: Setting property values via action listeners
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过动作监听器设置属性值
- en: 'The `<f:setPropertyActionListener>` tag uses an action listener (created by
    the framework) to directly set a value into a managed bean property; it is placed
    within a component derived from the `ActionSource` class. The `target` attribute
    indicates the managed bean property, while the `value` attribute indicates the
    value of the property, as shown in the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:setPropertyActionListener>`标签使用动作监听器（由框架创建）直接将值设置到管理Bean的属性中；它放置在由`ActionSource`类派生的组件中。`target`属性指示管理Bean属性，而`value`属性指示属性的值，如下面的代码所示：'
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, in the `PlayersBean` managed bean, the setter methods are called and the
    values are set; `logger` is useful to see the application flow and to understand
    how listeners are fired, as shown in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`PlayersBean`管理Bean中，调用setter方法并设置值；`logger`有助于查看应用程序流程和理解监听器是如何触发的，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the button labeled **Send Rafael Nadal 1** is clicked, the application
    output will be as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击标记为**发送给拉斐尔·纳达尔1**的按钮时，应用程序的输出将如下所示：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that action listeners are executed in the order they are defined,
    which means that the presence of the `<f:setPropertyActionListener>` tag can affect
    the order in which the listeners are fired.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，动作监听器是按照它们定义的顺序执行的，这意味着`<f:setPropertyActionListener>`标签的存在可能会影响监听器被触发的顺序。
- en: 'This note is important! For a clear understanding, take a look at the following
    snippet of code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注释很重要！为了清楚地理解，请查看以下代码片段：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following code is of the `parametersAction` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`parametersAction`方法：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Well, this code does not work as expected! Probably, you think that the setters
    method is called first and the `parametersAction` method later; therefore, the
    set values are available in the action method. But, the following output will
    prove the opposite:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这段代码没有按预期工作！你可能认为设置器方法首先被调用，然后是`parametersAction`方法；因此，设置的值在动作方法中可用。但是，以下输出将证明相反：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'So, the properties are set after the command action listener is fired! To fix
    this issue, you can use the `action` attribute instead of `actionListener`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，属性是在命令动作监听器触发后设置的！为了解决这个问题，您可以使用`action`属性而不是`actionListener`：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Of course, you need to adjust the `parametersAction` method accordingly, as
    shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要根据以下代码相应地调整`parametersAction`方法：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, the output will reflect the following desired result:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出将反映以下期望的结果：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This example is wrapped into the application named `ch2_16`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子被包裹在名为`ch2_16`的应用中。
- en: Passing parameters using the Flash scope
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Flash作用域传递参数
- en: The new JSF Flash scope is a very handy tool when you need to pass parameters
    between user views without the need to store them in the session. The Flash scope
    is simple to understand if you keep in mind that variables stored in the Flash
    scope will be available over a redirection and they will be eliminated afterwards.
    This is really useful when implementing a POST-redirect-GET pattern.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 新的JSF Flash作用域是一个非常有用的工具，当你需要在用户视图之间传递参数而不需要在会话中存储它们时。如果你记住存储在Flash作用域中的变量将在重定向后可用，并在之后被消除，那么Flash作用域就很容易理解。这在实现POST-redirect-GET模式时非常有用。
- en: 'For a better understanding, let''s suppose the following scenario:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们假设以下场景：
- en: A player (user) needs to register on the ATP website. Among other information,
    he will provide his name and surname and click on the **Register** button. This
    is accomplished in the `index.xhtml` page.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家（用户）需要在ATP网站上注册。在提供其他信息的同时，他需要输入自己的姓名和姓氏，然后点击**注册**按钮。这一步骤在`index.xhtml`页面中完成。
- en: The application flow redirects the player to the page `terms.xhtml`. On this
    page, the user can see a welcome message containing his name and surname and some
    terms and conditions that must be accepted (using the **Accept** button) or rejected
    (using the **Reject** button).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用流程将玩家重定向到`terms.xhtml`页面。在这个页面上，用户可以看到包含他姓名和姓氏的欢迎消息，以及一些必须接受（使用**接受**按钮）或拒绝（使用**拒绝**按钮）的条款和条件。
- en: If the **Reject** button is clicked, then the user is redirected to the `index.xhtml`
    home page, and the form registration fields will reveal the information provided
    by him earlier. Moreover, he will see a generated message stating **Terms rejected!
    Player not registered!**. This is outputted by the `<h:message>` tag.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点击了**拒绝**按钮，那么用户将被重定向到`index.xhtml`主页，并且表单注册字段将显示他之前提供的信息。此外，他还将看到一个生成的消息，声明**条款被拒绝！玩家未注册**！这是由`<h:message>`标签输出的。
- en: If the **Accept** button is clicked, then the user is redirected to a page named
    `done.xhtml`. On this page, the user will see a generated message stating **Terms
    accepted and player registered!** and another message stating *Name Surname* **successfully
    registered!**. The first message is outputted by the `<h:message>` tag, while
    the second one by the `<h:outputText>` tag.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点击了**接受**按钮，那么用户将被重定向到名为`done.xhtml`的页面。在这个页面上，用户将看到一个生成的消息，声明**条款已接受，玩家已注册**！以及另一个消息，声明*姓名
    姓氏***已成功注册**！第一个消息由`<h:message>`标签输出，而第二个消息由`<h:outputText>`标签输出。
- en: 'The following is a screenshot of both the scenarios:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对两种场景的截图：
- en: '![Passing parameters using the Flash scope](img/6466EN_02_01.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![使用Flash作用域传递参数](img/6466EN_02_01.jpg)'
- en: Obviously, you can implement this flow only if you store the submitted values
    somewhere, because they will not survive during the redirect process. This means
    that using a managed bean in the request scope cannot be a valid option. But,
    if we add in discussion the new Flash scope, then things become more favorable
    for the request scoped bean.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，只有将提交的值存储在某个地方，你才能实现这个流程，因为这些值在重定向过程中不会存活。这意味着在请求作用域中使用管理bean不是一个有效的选择。但是，如果我们讨论新的Flash作用域，那么对于请求作用域bean来说，事情就会变得更加有利。
- en: 'It will be much easier to follow this idea if you take a quick look at the
    following code of the request scoped bean, named `PlayersBean`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你快速查看以下名为`PlayersBean`的请求作用域bean的代码，将更容易理解这个想法：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Also, take a look at the start page, `index.xhtml`. Its code is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，看一下起始页面`index.xhtml`。其代码如下：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So, the submission process begins when the user clicks on the button labeled
    **Register**. JSF will call the `addValuesToFlashAction` method, which is responsible
    for putting the submitted values to the Flash scope; this will ensure that the
    values will survive during redirect to the `terms.xhtml` page.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，提交过程开始于用户点击标有**注册**的按钮。JSF将调用`addValuesToFlashAction`方法，该方法负责将提交的值放入Flash作用域；这将确保值在重定向到`terms.xhtml`页面时仍然存活。
- en: If the user rejects the terms and conditions, then he is redirected to the `index.xhtml`
    page. Here, you need to repopulate the registration form fields with the user-inserted
    values. For this, you can use the `preRenderView` event, which will load the values
    from the Flash scope during the render response phase by calling the `pullValuesFromFlashAction`
    method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户拒绝条款和条件，那么他会重定向到`index.xhtml`页面。在这里，你需要用用户输入的值重新填充注册表单字段。为此，你可以使用`preRenderView`事件，该事件在渲染响应阶段通过调用`pullValuesFromFlashAction`方法从Flash作用域中加载值。
- en: 'Next, let''s focus on the `terms.xhtml` page; its code is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们关注`terms.xhtml`页面；其代码如下：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'First, this page displays the entered values wrapped into a welcome message.
    The values are obtained from the Flash scope using the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个页面会显示一个欢迎信息，其中包含了输入的值。这些值是通过以下代码从Flash作用域中获取的：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice that this approach has two functions, which are listed as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这种方法有两个功能，如下所示：
- en: 'It obtains the values from the Flash scope, which could also be accomplished
    with the following lines:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从Flash作用域中获取值，这也可以通过以下行完成：
- en: '[PRE59]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It tells JSF to keep the values in the Flash scope for the next request. This
    is needed because values put to the Flash scope survive only one redirect and
    then are deleted. We have already fired a redirect when we have navigated from
    the `index.xhtml` page to the `terms.xhtml` page. But, another redirect will appear
    when the **Accept** or **Reject** button is clicked.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这告诉JSF在下一个请求中保持Flash作用域中的值。这是必需的，因为放入Flash作用域的值在经过一次重定向后就会被删除。当我们从`index.xhtml`页面导航到`terms.xhtml`页面时，我们已经触发了一个重定向。但是，当点击**接受**或**拒绝**按钮时，还会出现另一个重定向。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Values stored in the Flash scope survive only one redirect and then are deleted.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在Flash作用域中的值在经过一次重定向后就会被删除。
- en: Furthermore, the page displays both the buttons for navigating back to the `index.xhtml`
    page and forward to the `done.xhtml` page. The **Accept** button will call the
    `termsAcceptedAction` method, which will basically preserve messages across redirects
    (it calls the `setKeepMessages` method) and redirects the flow to the `done.xhtml`
    page. In the same manner, the **Reject** button calls the `termsRejectedAction`
    method, preserves messages in the Flash scope, and redirects the flow to the `index.xhtml`
    page.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，页面还显示了返回`index.xhtml`页面的按钮和前进到`done.xhtml`页面的按钮。**接受**按钮将调用`termsAcceptedAction`方法，该方法基本上会在重定向之间保留消息（调用`setKeepMessages`方法）并将流程重定向到`done.xhtml`页面。同样，**拒绝**按钮调用`termsRejectedAction`方法，保留Flash作用域中的消息，并将流程重定向到`index.xhtml`页面。
- en: 'The `done.xhtml` page is presented using the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`done.xhtml`页面是通过以下代码展示的：'
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `preRenderView` event listener is used again for obtaining the values from
    the Flash scope.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`preRenderView`事件监听器从Flash作用域中获取值。
- en: This example is wrapped into the application named `ch2_21`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子被封装在名为`ch2_21`的应用程序中。
- en: Replacing the <f:param> tag with the JSTL <c:set> tag
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用JSTL的`<c:set>`标签替换`<f:param>`标签
- en: 'Sometimes, the JSTL `<c:set>` tag can solve issues that the JSF `<f:param>`
    tag can''t. Probably, you know that we can pass parameters to the `<ui:include>`
    tag using the `<f:param>` tag, as shown in the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，JSTL `<c:set>`标签可以解决JSF `<f:param>`标签无法解决的问题。可能你已经知道，我们可以使用`<f:param>`标签将参数传递给`<ui:include>`标签，如下所示：
- en: '[PRE61]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Well, this approach triggers an issue! Now, the `Rafael Nadal Page` value will
    be available in the included page through EL, `#{rafa}`, but will not be available
    in the constructor of the managed bean of the included page!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这种方法会引发一个问题！现在，`Rafael Nadal 页面`的值将通过EL在包含的页面中可用，`#{rafa}`，但不会在包含页面的托管Bean构造函数中可用！
- en: 'It is time for the `<c:set>` tag to save the situation; therefore, the code
    will be changed to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使用`<c:set>`标签保存情况了；因此，代码将更改为以下内容：
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Done! Now, in the constructor of the managed bean, the value can be extracted
    as shown in the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，在托管Bean的构造函数中，值可以按照以下代码提取：
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the *Configuring system event listeners* section in [Chapter 4](ch04.html
    "Chapter 4. JSF Configurations Using XML Files and Annotations – Part 1"), *JSF
    Configurations Using XML Files and Annotations – Part 1*, you will see how to
    work with system events dedicated to the Flash scope.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。使用XML文件和注解配置JSF – 第1部分")的*配置系统事件监听器*部分，你将看到如何处理针对Flash作用域的系统事件。
- en: Sending data through cookies
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过cookie发送数据
- en: 'JSF provides a request cookie map that can be used to work with HTTP cookies.
    Setting cookies can be easily accomplished through JavaScript; the following are
    just some helper methods:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: JSF提供了一个请求cookie映射，可用于处理HTTP cookies。通过JavaScript设置cookie可以轻松完成；以下是一些辅助方法：
- en: 'The JavaScript method for setting a cookie is as follows:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置cookie的JavaScript方法如下：
- en: '[PRE64]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The JavaScript method for deleting a cookie by the name is as follows:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过名称删除cookie的JavaScript方法如下：
- en: '[PRE65]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The JavaScript method for extracting a cookie by the name is as follows:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称提取cookie的JavaScript方法如下：
- en: '[PRE66]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s suppose that you have two cookies named `name` and `surname`, as shown
    in the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个名为`name`和`surname`的cookie，如下所示：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'JSF can access these cookies through the following request cookie map:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: JSF可以通过以下请求cookie映射访问这些cookie：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'JSF also provides several getters and setters methods for working with cookies.
    These methods are given in the following table:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: JSF还提供了几个用于处理cookie的获取器和设置器方法。这些方法如下表所示：
- en: '| Getter methods | Setter methods |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 获取方法 | 设置方法 |'
- en: '| --- | --- |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `String getComment()` | `setComment(String arg)` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `String getComment()` | `setComment(String arg)` |'
- en: '| `String getDomain()` | `setDomain(String arg)` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `String getDomain()` | `setDomain(String arg)` |'
- en: '| `String getName()` | `setHttpOnly(boolean arg)` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `String getName()` | `setHttpOnly(boolean arg)` |'
- en: '| `String getPath()` | `setPath(String arg)` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `String getPath()` | `setPath(String arg)` |'
- en: '| `String getValue()` | `setValue(String arg)` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `String getValue()` | `setValue(String arg)` |'
- en: '| `int getMaxAge()` | `setMaxAge(int arg)` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `int getMaxAge()` | `setMaxAge(int arg)` |'
- en: '| `boolean getSecure()` | `setSecure(boolean arg)` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `boolean getSecure()` | `setSecure(boolean arg)` |'
- en: '| `int getVersion()` | `setVersion(int arg)` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `int getVersion()` | `setVersion(int arg)` |'
- en: '| `boolean isHttpOnly()` |   |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `boolean isHttpOnly()` |   |'
- en: This example is wrapped into the application named `ch2_18` and can be found
    in the code bundle of this chapter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包含在名为`ch2_18`的应用程序中，可以在本章的代码包中找到。
- en: Working with hidden fields
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理隐藏字段
- en: 'Hidden fields can sometimes be very useful! Passing data in a subtle manner
    can be the perfect choice for dealing with temporary data or information provided
    by the user that should be used again and again. JSF offers the `<h:inputHidden>`
    tag to pass hidden parameters. The following code passes two hidden parameters
    to a managed bean:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏字段有时非常有用！以微妙的方式传递数据可能是处理临时数据或用户提供的应重复使用的信息的完美选择。JSF提供了`<h:inputHidden>`标签来传递隐藏参数。以下代码将两个隐藏参数传递给托管Bean：
- en: '[PRE69]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Usually, setting hidden field values from JavaScript is a common practice.
    When the button **Send Rafael Nadal** is clicked, the JavaScript function named
    `setHiddenValues` is called; this happens before the form submission. The `setHiddenValues`
    function is given in the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，从JavaScript设置隐藏字段值是一种常见做法。当点击**发送拉斐尔·纳达尔**按钮时，名为`setHiddenValues`的JavaScript函数会被调用；这发生在表单提交之前。`setHiddenValues`函数的代码如下：
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Next, the hidden parameters are set in the indicated managed bean properties
    and the `parametersAction` method is called—the set values are ready to use!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，隐藏参数在指定的管理 Bean 属性中设置，并调用 `parametersAction` 方法——设置的值已准备好使用！
- en: This example is wrapped into the application named `ch2_17` and can be found
    in the code bundle of this chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为 `ch2_17` 的应用程序中，并可在本章的代码包中找到。
- en: Sending passwords
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送密码
- en: 'JSF provides a dedicated tag named `<h:inputSecret>` for rendering the following
    well-known HTML code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 提供了一个名为 `<h:inputSecret>` 的专用标签来渲染以下众所周知的 HTML 代码：
- en: '[PRE71]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For example, you can use it as shown in the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以像以下代码所示使用它：
- en: '[PRE72]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This example is wrapped into the application named `ch2_19`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为 `ch2_19` 的应用程序中。
- en: Accessing UI component attributes programmatically
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过程序访问 UI 组件属性
- en: 'Accessing UI component attributes from managed beans using the JSF API is not
    a common approach, but sometimes you may find it useful. For example, let''s suppose
    that we have the following form:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSF API 从管理 Bean 访问 UI 组件属性不是一种常见的方法，但有时它可能很有用。例如，假设我们有以下表单：
- en: '[PRE73]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, you want to obtain the values of the components with IDs, `playerNameId`
    and `playerSurnameId`, in the `processAction` method. Moreover, you want to set
    the value of the component with the ID, `playerNameId`, as `RAFAEL`. Programmatically
    (using the JSF API), you can achieve this as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你想要在 `processAction` 方法中获取具有 ID 的组件 `playerNameId` 和 `playerSurnameId` 的值。此外，你想要将具有
    ID 的组件 `playerNameId` 的值设置为 `RAFAEL`。通过程序（使用 JSF API），你可以这样实现：
- en: '[PRE74]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: First, you need to obtain access to `UIViewRoot`, which is the top level UI
    component—the root of the `UIComponent` tree. Then, you can search by the ID for
    the desired UI component through the UI components tree using the `findComponent`
    method. Each UI component provides the `getAttributes` method, which can be used
    to gain access to the UI component attributes by their names. At this point, you
    can extract an attribute value using the `get` method, or set a new attribute
    value using the `put` method.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要获取对 `UIViewRoot` 的访问权限，它是顶级 UI 组件——`UIComponent` 树的根。然后，你可以通过 `findComponent`
    方法在 UI 组件树中通过 ID 搜索所需的 UI 组件。每个 UI 组件都提供了 `getAttributes` 方法，可以通过名称访问 UI 组件属性。此时，你可以使用
    `get` 方法提取属性值，或者使用 `put` 方法设置新的属性值。
- en: This example is wrapped into the application named `ch2_20`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为 `ch2_20` 的应用程序中。
- en: Passing parameters via method expressions
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过方法表达式传递参数
- en: 'Passing parameters using method expressions is an elegant solution to send
    parameters as arguments to an action method of a managed bean. For example, let''s
    focus on the following snippet of code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法表达式传递参数是将参数作为参数传递给管理 Bean 的操作方法的优雅解决方案。例如，让我们关注以下代码片段：
- en: '[PRE75]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As you can see in the following code, the `action` attribute indicates a method
    that gets two arguments:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下代码中所见，`action` 属性指示一个接收两个参数的方法：
- en: '[PRE76]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the same manner, you can pass numeric values or objects.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，你可以传递数值或对象。
- en: This example is wrapped into the application named `ch2_26`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为 `ch2_26` 的应用程序中。
- en: Communicating via the binding attribute
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过绑定属性进行通信
- en: JSF UI components support an attribute named `binding`, which is rarely used
    and, sometimes, poorly understood. The story behind its meaning can be stretched
    over several pages or summed up in some golden rules. We will start with the binding
    lifespan and a brief overview and will end with the important rules that should
    be taken into account when you decide to used it in production.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: JSF UI 组件支持一个名为 `binding` 的属性，它很少使用，有时理解得也不够好。其含义背后的故事可以扩展到几页纸，或者总结为一些黄金法则。我们将从绑定生命周期和简要概述开始，并以在生产环境中使用时应考虑的重要规则结束。
- en: If we want to localize the moment in time when the `binding` attribute enters
    the fray, we can refer to the moment when the JSF view is built or restored; the
    result of building/restoring the view is present in the component tree. So, before
    the component tree is deliverable, JSF needs to inspect all `binding` attributes.
    For each of them, JSF will check the presence of a pre-existing (precreated) component.
    If a pre-existing component is found, then it is used; otherwise, JSF will automatically
    create a brand new one, and will pass it as an argument to the setter method that
    corresponds to that `binding` attribute. In addition, JSF adds a reference of
    the component in the view state. Furthermore, a postback request (a form submit)
    will tell JSF to restore the view, which will restore the components and bindings
    based on view state.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要定位`binding`属性进入战斗的时刻，我们可以参考JSF视图构建或恢复的时刻；构建/恢复视图的结果存在于组件树中。因此，在组件树可交付之前，JSF需要检查所有`binding`属性。对于每一个，JSF都会检查是否存在一个预存在的（预先创建的）组件。如果找到了预存在的组件，则使用它；否则，JSF将自动创建一个新的，并将其作为参数传递给对应于该`binding`属性的setter方法。此外，JSF在视图状态中添加了组件的引用。此外，回发请求（表单提交）会告诉JSF恢复视图，这将根据视图状态恢复组件和绑定。
- en: 'Now that you know what happens with the `binding` attribute, let''s enumerate
    some important aspects of using it:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了`binding`属性的作用，让我们列举一些使用它的重要方面：
- en: After each request (initial or postback), JSF creates an instance of the component
    indicated by the `binding` attribute.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个请求（初始或回发）之后，JSF都会根据`binding`属性创建组件的实例。
- en: At the restore view (at the postback), after the component instance is created,
    JSF populates it from the view state, based on the stored reference.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恢复视图（回发）时，组件实例创建后，JSF根据存储的引用填充它。
- en: When you bind a component to a bean property (of type `UIComponent`), you actually
    bind the whole component. This kind of binding is a very rare use case, and it
    may be useful when you want to work/expose a component's methods that are not
    available in the view or you need to alter the component's children in a programmatic
    fashion. Moreover, you can alter the component's attributes and instantiate the
    component rather than letting the page author do so.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将一个组件绑定到一个bean属性（类型为`UIComponent`）时，实际上你绑定的是整个组件。这种绑定是一个非常罕见的使用场景，当你想要工作/公开组件在视图中不可用的方法，或者你需要以编程方式更改组件的子组件时，它可能很有用。此外，你可以更改组件的属性并实例化组件，而不是让页面作者这样做。
- en: Since JSF instantiates the component at each request, the bean must be in the
    request scope; otherwise, the component may be shared between different views.
    The view scope may also be a solution.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于JSF在每个请求中实例化组件，因此bean必须在请求作用域中；否则，组件可能会在不同视图之间共享。视图作用域也可能是一个解决方案。
- en: The `binding` attribute is also used to bind the component to the current view,
    without the need of a bean. This is useful to gain access to the state of a component
    from another component.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`属性也用于将组件绑定到当前视图，而不需要bean。这对于从另一个组件访问组件的状态非常有用。'
- en: Binding a component without a bean property will put the component in the EL
    scope. This happens when the component tree is built; therefore, EL is perfectly
    capable to reveal the bound component at the rendering stage, which takes place
    after the component tree was built.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有bean属性绑定组件，则将组件放入EL作用域。这发生在组件树构建时；因此，EL完全能够揭示在渲染阶段绑定的组件，这个阶段发生在组件树构建之后。
- en: 'For example, a `<h:dataTable>` tag has three useful properties: `first`, `rows`,
    and `rowCount`. If you bind a `<h:dataTable>` tag to the current view, then outside
    of this component, you can access these properties as shown in the following line
    of code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`<h:dataTable>`标签有三个有用的属性：`first`、`rows`和`rowCount`。如果你将一个`<h:dataTable>`标签绑定到当前视图，那么在这个组件外部，你可以像以下代码行所示访问这些属性：
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'For example, you can set the `rows` property as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以按照以下方式设置`rows`属性：
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Also, display the `rowCount` and `first` properties as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，按照以下方式显示`rowCount`和`first`属性：
- en: '[PRE79]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The complete application is named `ch2_32`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch2_32`。
- en: 'We can accomplish the same thing from a bean. First, we bind the `<h:dataTable>`
    tag to a bean property of type `HtmlDataTable` as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个豆子中完成相同的事情。首先，我们将`<h:dataTable>`标签绑定到类型为`HtmlDataTable`的bean属性，如下所示：
- en: '[PRE80]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, in `PlayersBean`, we add the following code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`PlayersBean`中，我们添加以下代码：
- en: '[PRE81]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The complete application is named `ch2_31`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch2_31`。
- en: Managed bean communication
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管Bean通信
- en: 'Until now, we have focused especially on the communication between Facelets
    and managed beans. In this section, we will cover another important aspect regarding
    JSF communication—managed beans communication. We will discuss the following topics:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们特别关注了Facelets和托管Bean之间的通信。在本节中，我们将介绍JSF通信的另一个重要方面——托管Bean之间的通信。我们将讨论以下主题：
- en: Injecting a managed bean into another bean
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将托管Bean注入到另一个Bean中
- en: Communication between managed beans using the application/session map
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序/会话映射进行托管Bean之间的通信
- en: Accessing other managed beans programmatically
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式访问其他托管Bean
- en: Injecting a managed bean into another bean
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将托管Bean注入到另一个Bean中
- en: 'A managed bean can be injected into another managed bean using `@ManagedProperty`.
    For example, let''s suppose that you have a managed bean in the session scope
    that stores a player name and surname, as shown in the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@ManagedProperty`将托管Bean注入到另一个托管Bean中。例如，假设你有一个会话作用域的托管Bean，用于存储玩家名和姓氏，如下面的代码所示：
- en: '[PRE82]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, let''s suppose that you want to have access to this bean''s properties
    from another view scoped bean, named `ProfileBean`. For this, you can use `@ManagedProperty`
    as shown in the following code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想从另一个名为`ProfileBean`的视图作用域Bean中访问这个Bean的属性。为此，你可以使用`@ManagedProperty`，如下面的代码所示：
- en: '[PRE83]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A Facelet that calls the `greetingsAction` method will draw something like
    the following line in the log:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`greetingsAction`方法的Facelet将在日志中绘制如下行：
- en: '[PRE84]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The presence of the `@PostConstruct` method is optional, but it is good to know
    that this is the earliest place where an injected dependency is available.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostConstruct`方法的存在是可选的，但了解这是注入依赖最早可用的位置是好的。'
- en: This example is wrapped into the application named `ch2_22`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch2_22`的应用程序中。
- en: 'If you want to use CDI beans, then you can accomplish the same thing as shown
    in the following code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用CDI Bean，那么你可以像以下代码那样完成相同的事情：
- en: '[PRE85]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This example is wrapped into the application named `ch2_30`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch2_30`的应用程序中。
- en: Communication between managed beans using the application/session map
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用应用程序/会话映射进行托管Bean之间的通信
- en: Communication between managed beans can be ensured through an application map
    or a session map, depending on what kind of communication is needed, during multiple
    browser sessions or during one browser session.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要，托管Bean之间的通信可以通过应用程序映射或会话映射来确保，无论是在多个浏览器会话中还是在单个浏览器会话中。
- en: 'The advantage of using the application/session map is in the fact that multiple
    beans can communicate with each other independent of their scopes. First, you
    need to define a helper class that provides two static methods, one for adding
    a value into the application map and one for deleting a value from the application
    map, as shown in the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用程序/会话映射的优点在于，多个Bean可以独立于它们的作用域相互通信。首先，你需要定义一个辅助类，它提供两个静态方法，一个用于将值添加到应用程序映射中，另一个用于从应用程序映射中删除值，如下面的代码所示：
- en: '[PRE86]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, you can improvise a simple scenario: in one managed bean (request scoped),
    put some values into the application map, and in another managed bean (session
    scoped), get those values. So, the first bean code is as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以即兴创作一个简单的场景：在一个托管Bean（请求作用域）中，将一些值放入应用程序映射中，在另一个托管Bean（会话作用域）中获取这些值。因此，第一个Bean的代码如下：
- en: '[PRE87]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The managed beans that extract these values from the application map are given
    out as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序映射中提取这些值的托管Bean如下所示：
- en: '[PRE88]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This example is wrapped into the application named `ch2_24`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch2_24`的应用程序中。
- en: Accessing other managed beans programmatically
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式访问其他托管Bean
- en: 'Sometimes, you may need to access one managed bean from an event listener class
    or another managed bean. Suppose that we have a managed bean on session scope,
    named `PlayersBean`, and one on request scope, named `ProfileBean`, and you want
    to programmatically access `PlayersBean` inside `ProfileBean`. Supposing that
    `PlayersBean` has been created, you can accomplish this task in the following
    ways:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要从一个事件监听器类或另一个托管Bean中访问一个托管Bean。假设我们有一个会话作用域的托管Bean，名为`PlayersBean`，还有一个请求作用域的托管Bean，名为`ProfileBean`，并且你想要在`ProfileBean`中以编程方式访问`PlayersBean`。假设`PlayersBean`已经被创建，你可以通过以下方式完成此任务：
- en: 'Use the `evaluateExpressionGet` method inside `ProfileBean` as follows:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ProfileBean`内部使用`evaluateExpressionGet`方法如下：
- en: '[PRE89]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Use the `createValueExpression` method inside `ProfileBean` as follows:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ProfileBean` 中如下使用 `createValueExpression` 方法：
- en: '[PRE90]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In order to make things simpler, when you need to programmatically create a
    value expression, you can use a simple helper method and pass only the expression
    and class, as follows:'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使事情更简单，当你需要以编程方式创建一个值表达式时，你可以使用一个简单的辅助方法，并只传递表达式和类，如下所示：
- en: '[PRE91]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Use `ELResolver` inside `ProfileBean` as follows:'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ProfileBean` 中如下使用 `ELResolver`：
- en: '[PRE92]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `evaluateExpressionGet` method is the most common one.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluateExpressionGet` 方法是最常见的一种。'
- en: This example is wrapped into the application named `ch2_25`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为 `ch2_25` 的应用程序中。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Communication in JSF is one of the most important aspects, since the entire
    application's flow spins around the capability of processing and sharing data
    between JSF components. As you have seen, there are many ways to pass/get parameters
    and to access managed beans from other managed beans, but choosing the right ones
    for obtaining a robust, harmonious, balanced application depends on experience.
    This chapter covers a wide range of solutions for building communication pipes
    between JSF components, but, as any developer knows, there is always a case that
    requires a new approach!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 中，通信是其中一个最重要的方面，因为整个应用程序的流程都是围绕处理和共享 JSF 组件之间数据的能力展开的。正如你所看到的，有多种方式传递/获取参数以及从其他管理
    Bean 访问管理 Bean，但选择正确的方法以获得稳健、和谐、平衡的应用程序取决于经验。本章涵盖了在 JSF 组件之间构建通信管道的广泛解决方案，但正如任何开发者都知道的，总会有需要新方法的情况！
- en: See you in the next chapter, where we will talk about JSF scopes.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在下一章中见到我们，我们将讨论 JSF 作用域。
