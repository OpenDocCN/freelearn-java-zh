- en: Chapter 2. Communication in JSF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication is the core of a JSF application, and is one of the main aspects
    that dictate the architecture of such an application. Thinking of the big picture,
    you need to identify—right from the start—the main parts and how they will communicate
    with one another and with the end user. After selecting design patterns, drawing
    the UML diagrams, and sketching the architecture and the application flow, it's
    time to get to work and start implementing the communication pipes using forms,
    parameters, arguments, values, pages, beans, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, JSF provides many solutions for ensuring a powerful and flexible
    communication layer between JSF components and also between JSF and XHTML pages,
    the JavaScript code, and other third-party components. In this chapter, we will
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using context parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing request parameters with the `<f:param>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with view parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling actions on GET requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing attributes with the `<f:attribute>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting property values via action listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters using the Flash scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the `<f:param>` tag with the JSTL `<c:set>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data through cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with hidden fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing UI component attributes programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters via method expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating via the `binding` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing and getting parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you will see in the next sections, JSF provides several approaches to pass/get
    parameters to/from Facelets, managed beans, UI components, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using context parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Context parameters are defined in the `web.xml` file using the `<context-param>`
    tag. This tag allows two important children: `<param-name>`, which indicates the
    parameter name, and `<param-value>`, which indicates the parameter value. For
    example, a user-defined context parameter looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in a JSF page, you can access this parameter as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In a managed bean, the same context parameter can be accessed via the `getInitParameter`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch2_27`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing request parameters with the <f:param> tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you need to pass parameters from a Facelet to a managed bean or to
    another Facelet. In this case, you may need the `<f:param>` tag, which can be
    used to add query string name-value pairs to a request, or put simply, to send
    request parameters. Commonly, the `<f:param>` tag is used inside the `<h:commandButton>`
    and `<h:commandLink>` tags for sending request parameters to a managed bean. For
    example, the following snippet of code adds two parameters to the request when
    the form is submitted. These parameters are accessed in the `PlayersBean` bean;
    the first parameter is named `playerNameParam` and the second one is named `playerSurnameParam`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, when the button is clicked, the request parameters are sent
    and the `parametersAction` method is called (via `action` or `actionListener`).
    When the application flow reaches this method, the two request parameters are
    already available for use. You can easily extract them inside this method by accessing
    the request parameters map through the current `FacesContext` instance as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The values of both the parameters are stored in the `playerName` and `playerSurname`
    managed beans'' properties (these can be modified further without affecting the
    original parameters), but you can easily display the parameters'' values using
    the `param` EL reserved word in *some_page* (remember the *EL implicit objects*
    section of [Chapter 1](ch01.html "Chapter 1. Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)"), *Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)*, which explains that `param` is a predefined
    variable referring to the request parameter map):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<f:param>` tag can also be used inside the `<h:outputFormat>` tag to substitute
    message parameters; `<f:param>` is used to pass parameters to a UI component as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code''s output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name: Rafael Surname: Nadal**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to execute some initialization tasks (or something else) after setting
    the managed bean properties but before an action method is called (if it exists),
    then you can define a public void method annotated with `@PostConstruct`. In this
    example, the `init` method will be called before the `parametersAction` method,
    and the passed request parameters are available through the request map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init` method is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch2_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think that it is not a very convenient approach to access the request
    map in the managed bean, then you can use `@ManagedProperty`, which sets the parameter
    as a managed bean property and links its value to the request parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The values are set immediately after the bean's construction and are available
    during `@PostConstruct`, but keep in mind that `@ManagedProperty` is usable only
    with beans managed by JSF (`@ManagedBean`), not with beans managed by CDI (`@Named`).
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_2` which is available
    in the code bundle of this chapter. You may also be interested in the application
    `ch2_3`, which is another example of using `<f:param>`, `@ManagedProperty`, and
    `@PostConstruct`. In this example, the `<h:commandButton>` action indicates another
    JSF page instead of a managed bean method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<f:param>` tag can be used to pass request parameters directly between
    Facelets, without involving a managed bean. Usually, this happens in the `<h:link>`
    tag, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the **Send Rafael Nadal** link is clicked, JSF will use the prepared URL
    containing the `result.xhtml` file''s resource name and the request parameters,
    `playerNameParam` and `playerSurnameParam`. Both the parameters are displayed
    in the `result.xhtml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the URL generated by the `<h:link>` tag in the browser address
    bar, then you will see something like the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://`*hostname*`/ch2_4/faces/result.xhtml?playerNameParam=Rafael&playerSurnameParam=Nadal`'
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_4`. In that application,
    you can also see an example using the `<h:commandButton>` tag. Notice that, in
    this case, we need to wrap the `<h:commandButton>` tag in a `<h:form>` tag, which
    is submitted using the POST request; therefore, the request parameters are not
    visible in the URL anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<f:param>` tag cannot be fortified with declarative/imperative validations
    and/or conversions. You need to accomplish this task by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Do not try to place the `<f:param>` tag inside the `<h:inputText>` tag or any
    other input component. That will simply not work.
  prefs: []
  type: TYPE_NORMAL
- en: Working with view parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with JSF 2.0, we can use a new category of parameters, known as **view
    parameters**. These kinds of parameters are implemented by the `UIViewParameter`
    class (that extends the `UIInput` class) and are defined in Facelets using the
    `<f:viewParam>` tag. Through this tag, we can declaratively register the `UIViewParameter`
    class as metadata for the parent view; this is why the `<f:viewParam>` tag is
    nested in the `<f:metadata>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with JSF 2.0, the metadata concept was materialized in a section of
    a view, which provides the following two main advantages (the section is demarcated
    by the `<f:metadata>` tag):'
  prefs: []
  type: TYPE_NORMAL
- en: The content of this section is readable without having the entire view available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the initial request, components from this section can accomplish different
    things before the view is rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, the metadata section (and subsequent components) is detected
    via a public static method, named the `hasMetadata` (`UIViewRoot`) method. This
    method was added in `javax.faces.view.ViewMetadata` and returns `true` if there
    is a metadata section and `false` otherwise. Among other benefits, the main advantage
    of using the `<f:viewParam>` tag is the URL bookmarking support.
  prefs: []
  type: TYPE_NORMAL
- en: 'For better understanding, let''s look at a simple example of using the `<f:viewParam>`
    tag. The following pieces of code are from the same page, `index.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what is happening at the initial request. First, let''s focus
    on the first block of code: here, JSF gets the request parameter''s values by
    their names (`playernameparam` and `playersurnameparam`) from the page URL and
    applies the specified converter/validators (these are optional). After conversion/validation
    succeeds, before the view is rendered, JSF binds the values of the `playernameparam`
    and `playersurnameparam` request parameters to the managed bean properties, `playerName`
    and `playerSurname`, by calling the `setPlayerName` and `setPlayerSurname` methods
    (called only if we provide request parameters in the URL). If the `value` attribute
    is missing, then JSF sets request parameters as request attributes on names, `playernameparam`
    and `playersurnameparam`, available via `#{playernameparam}` and `#{playersurnameparam}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The page''s initial URL should be something like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://`*hostname*`/ch2_5/?playernameparam=Rafael&playersurnameparam=Nadal`'
  prefs: []
  type: TYPE_NORMAL
- en: In the second block of code, the values of the managed bean properties, `playerName`
    and `playerSurname`, are displayed (the `getPlayerName` and `getPlayerSurname`
    methods are called); they should reflect the values of the request parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the `UIViewParameter` class extends the `UIInput` class, the managed bean
    properties are set during the **Update Model** phase only.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_5`.
  prefs: []
  type: TYPE_NORMAL
- en: View parameters can be included in links (the GET query string) by using the
    `includeViewParams="true"` attribute in the `<h:link>` tag, or the `includeViewParams=true`
    request parameter in any URL. Both these cases can be seen in the upcoming examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `index.xhtml` file, you can have something like the following code,
    in which view parameters are included through the request parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial URL can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://`*hostname*`/ch2_6/?playernameparam=Rafael&playersurnameparam=Nadal`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The view parameters, `playernameparam` and `playersurnameparam`, will be extracted
    from this URL and bound to the managed bean properties, `playerName` and `playerSurname`.
    Optionally, both properties can be further altered by the user through two `<h:inputText>`
    tags, or other UI components. (If the initial URL does not contain the view parameters,
    then the `<h:inputText>` generated fields will be empty.) The button rendered
    through the `<h:commandButton>` tag will redirect the flow to the `results.xhtml`
    page and will include the view parameters in the new URL. The values of the view
    parameters will reflect the values of the corresponding managed bean properties,
    since the form is submitted before the following URL is composed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://`*hostname*`/ch2_6/faces/results.xhtml?playernameparam=Rafael&playersurnameparam=Nadal`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `results.xhtml` file (or any other page that the `index.xhtml` file directs)
    will use the `<f:viewParam>` tag to take parameters from the GET request into
    bound properties, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to use a `<h:link>` tag in conjunction with the `includeViewParams`
    attribute set to `true`, then the `index.xhtml` file will be as follows (in this
    case, there is no form submission and no POST request):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These examples are wrapped into the application named `ch2_6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `includeViewParams` request parameter in any URL, which means
    that you can use it in managed beans to include view parameters in the navigation
    links as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And the action method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch2_7` and is available in the code bundle
    of this chapter on the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know from the previous code, the `UIViewParameter` class extends the
    `UIInput` class, which means that it inherits all attributes, such as `required`
    and `requiredMessage`. When the URL must contain view parameters, you can use
    these two attributes to ensure that the application flow is controlled and the
    user is correctly informed. The following is the example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the initial URL does not contain the view parameters (one or both), then
    you will receive a message that report this fact. This example is wrapped into
    the application named `ch2_9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, view parameters support fine-grained conversion and validation. You
    can use `<f:validator>` and `<f:converter>`, or the `validator` and `converter`
    attributes inherited from the `UIInput` class. Supposing that you have a custom
    validator, named `PlayerValidator` (its implementation is not really relevant),
    the following is its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can attach it to a view parameter as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet of code accomplishes the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the request parameters' values by their names, `playernameparam` and `playersurnameparam`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts and validates (in this case, validates) parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If conversions and validations end successfully, then the parameters are set
    in managed bean properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any validation failure will result in a message being displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the customize messages style, you can attach a `<h:message>` tag to the
    `<f:viewParam>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_10`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to preserve the view parameters over validation failures, then you
    need to use a broader scope than `@RequestScoped`, such as `@ViewScoped`, or to
    manually preserve the request parameters for the subsequent requests through the
    `<f:param>` tag in the command components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you may need a converter for a view parameter. For example, if you
    try to pass a `java.util.Date` parameter as a view parameter from a managed bean,
    you will probably will code it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `date.xhtml` file, you need to convert the view parameter from
    string to `date`, and for this, you may use the `<f:convertDateTime>` converter,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Of course, a custom converter can also be used. The complete application is
    named `ch2_29`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among so many advantages of using the `<f:viewParam>` tag, we have a gap. When
    view parameters are set in managed bean properties, the set values are not available
    in `@PostConstruct`; therefore, you cannot perform initialization or preload tasks
    directly. You can quickly fix this by attaching the `preRenderView` event listener,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init` method is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The set values are not available in `@PostConstruct` when using the `<f:viewParam>`
    tag. You can fix this by attaching the `preRenderView` event listener, or, as
    you will see next, the `<f:viewAction>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_8`.
  prefs: []
  type: TYPE_NORMAL
- en: Well, there is one more aspect that I'd like to discuss here. The `UIViewParameter`
    class (`<f:viewParam>`) is a stateful component that stores its value in state.
    This is very nice as the value is available over postbacks, even if it doesn't
    come from the page URL anymore or the managed bean is request scoped. So, you
    need to indicate view parameters only once, and not for every request. But, there
    are a few drawbacks of this behavior—the most significant being calling the setter
    method at each postback (you don't want this in view beans). Another one is calling,
    for each postback, the method indicated through the `preRenderView` event handler;
    this can be fixed using a test as shown in the following code. The complete application
    is named `ch2_28`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Maybe the most painful drawback is converting and validating view parameters
    at each postback. Obviously, this is not the behavior you are expecting to see.
    In order to call a converter/validator only when the page URL contains the request
    parameters, you need to alter the `UIViewParameter` class implementation by writing
    a custom implementation. You can try to write a stateless `UIViewParameter` class
    or to control the conversion/validation calls. Of course, you have to keep in
    mind that altering the default implementation may lead to more or less unpredictable
    drawbacks. As an alternative, you can use the `<o:viewParam>` tag from OmniFaces,
    which fixes these issues. A relevant example can be seen at [http://showcase.omnifaces.org/components/viewParam](http://showcase.omnifaces.org/components/viewParam).
  prefs: []
  type: TYPE_NORMAL
- en: So, as a final conclusion of this section, the `<f:viewParam>` tag is used to
    capture the request parameters. Moreover, it can be used with the `<h:link>` and
    `<h:button>` tags to send outgoing request parameters, or in non-JSF forms, to
    send data to JSF pages that use the `<f:viewParam>` tag, or to make JSF results
    pages bookmarkable in a POST-redirect-GET flow. On the other hand, the `<f:viewParam>`
    tag doesn't sustain the `<h:form>` tag to use GET or provide access to random
    JSF pages via the GET request.
  prefs: []
  type: TYPE_NORMAL
- en: Calling actions on GET requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can deal with calling actions on GET requests by using
    the new generic **view action** feature (well-known in Seam 2 and 3). This new
    feature is materialized in the `<f:viewAction>` tag, which is declared as a child
    of the metadata facet, `<f:metadata>`. This allows the view action to be part
    of the JSF life cycle for faces/non-faces requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding section, we saw how to attach a custom validator to a `<f:viewParam>`
    tag for validating view parameters. The same thing can be accomplished using the
    `<f:viewAction>` tag, when the validation method is declared in the managed bean
    instead of being a separate implementation of the `Validator` interface. For example,
    in the `index.xhtml` file, you may have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the following `validateData` method is just a common method
    declared in `PlayersBean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch2_11`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<f:viewAction>` tag and the `preRenderView` event listener are not the
    same!
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding note underlines our next discussion. You may think that they
    are the same because in the preceding example, you can replace `<f:viewAction>`
    with `preRenderView` and obtain the same effect (result). Well, it is true that
    they are partially the same, but a few existing differences are important, as
    you can see in the following four bullets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `preRenderView` event listener is executed on postback requests,
    while the view action is not. In the case of the `preRenderView` event listener,
    you need to overcome this by testing the request type as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, the following code will try to apply some modifications over the
    set values using the `preRenderView` event listener:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `init` method is declared in `PlayersBean` and it just turns the set values
    to uppercase, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, when the JSF page is rendered, the set values are used in uppercase,
    and further requests can be accomplished (for example, you may want to call the
    method `#{playersBean.userAction()}` when a certain button is clicked). But, each
    further request will call the `init` method again (after the `userAction` method),
    because the `preRenderView` event listener is executed at postback time. Except
    for the case when this is the desired functionality, you need to programmatically
    test the postbacks to prevent the following `init` method code from being executed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Well, this is not the same in the case of the `<f:viewAction>` tag. Replace
    the `preRenderView` event listener with the `<f:viewAction>` tag, as shown in
    the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<f:viewAction>` tag supports an attribute named `onPostback` which is
    set to `false` by default, meaning that the `init` method will not be called on
    postback requests. Of course, if you set it to `true`, then it will function contrary;
    but, notice that in the case of the `preRenderView` event listener, the `init`
    method is called after the `userAction` method, while in the case of the `<f:viewAction>`
    tag, the `init` method is called before the `userAction` method, as shown in the
    following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The example based on the `preRenderView` event listener is wrapped in the application
    named `ch_12_1`, while for the `<f:viewAction>` tag it is named `ch_12_2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The view action has navigation capabilities, while the `preRenderView` event
    listener doesn't. While the view action can naturally accomplish navigation tasks,
    the `preRenderView` event listener requires explicit navigation based on the JSF
    API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if you modify the preceding `init` method to return the `start.xhtml`
    view, then you will probably change it as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But, this will not work with the `preRenderView` event listener! You will need
    to add explicit navigation by returning void and replacing the return `"start"`
    code line with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you drop the `preRenderView` event listener and use the `<f:viewAction>`
    tag instead, then the preceding `init` method will correctly navigate to `start.xhtml`
    without involving an explicit call of the navigation handler.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The example based on the `preRenderView` event listener is wrapped in the application
    named `ch_13_1`, while for the `<f:viewAction>` tag it is named `ch_13_2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Moreover, the `<f:viewAction>` tag supports declarative navigation. So, you
    can write a navigation rule in the `faces-config.xml` file that is consulted before
    the page is rendered. For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the `rafa.xhtml` page will be rendered instead of the `start.xhtml` page.
    This example is wrapped into the application named `ch2_13_3`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By default, the view action is executed in the **Invoke Application** phase.
    But, it can be executed in the **Apply Request Values** phase by setting the `immediate`
    attribute to `true`, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Moreover, you can specify in which phase to execute the action using the `phase`
    attribute whose value represents the phase name as a predefined constant. For
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The supported values are `APPLY_REQUEST_VALUES`, `INVOKE_APPLICATION`, `PROCESS_VALIDATIONS`,
    and `UPDATE_MODEL_VALUES`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The view action can be placed into a view metadata facet that doesn't contain
    other view parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Passing attributes with the <f:attribute> tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `<f:param>` tag does not satisfy your needs, maybe the `<f:attribute>`
    tag will. This tag allows you to pass the value of an attribute of a component
    or to pass a parameter to a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can assign the value of the attribute named `value` of a `<h:commandButton>`
    tag as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render a button labeled **Send Rafael Nadal**. Its code is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, the `<f:attribute>` tag can be used to pass a parameter to a component,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the action listener method, you can extract the attributes'' values as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch2_14`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are a fan of PrimeFaces ([http://primefaces.org/](http://primefaces.org/)),
    then you will probably find the next example useful. One of the greatest built-in
    components of PrimeFaces is the `<p:fileUpload>` tag, which can be used, obviously,
    to upload files. Sometimes, besides the files that will be uploaded, you need
    to pass some extra parameters, for example, the files'' owner name and surname.
    Well, the `<p:fileUpload>` tag doesn''t come with a solution for this, but the
    `<f:attribute>` tag can be helpful. The following is the code of a classic `<p:fileUpload>`
    tag with the `<f:attribute>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handleFileUpload` method is responsible for the upload-specific steps
    (skipped in the following code), but it can also access the values passed by the
    `<f:attribute>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you are not a fan of PrimeFaces, then you might probably think that this
    example is useless, but maybe you are a fan of some other third-party library,
    such as RichFaces, ICEFaces, and MyFaces. You can apply this technique for other
    component libraries as well.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_15`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another case when the `<f:attribute>` tag can be useful is when dynamically
    passing parameters in conjunction with UI components bound to the managed bean
    using the `binding` attribute. This is very useful, especially because there is
    no solution provided by JSF for passing parameters to the getters/setters methods
    of the bound UI components, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, the value of the `<h:inputText>` tag should contain the value set via the
    `<f:attribute>` tag. Be careful to use only unique names for the attributes and
    to not interfere (try to overwrite) with the default attributes of the UI component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the `PlayersBean` managed bean''s code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all the parameters passed this way are accessible via the `getAttributes`
    method of the parent UI component.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_23`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting property values via action listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `<f:setPropertyActionListener>` tag uses an action listener (created by
    the framework) to directly set a value into a managed bean property; it is placed
    within a component derived from the `ActionSource` class. The `target` attribute
    indicates the managed bean property, while the `value` attribute indicates the
    value of the property, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `PlayersBean` managed bean, the setter methods are called and the
    values are set; `logger` is useful to see the application flow and to understand
    how listeners are fired, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When the button labeled **Send Rafael Nadal 1** is clicked, the application
    output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that action listeners are executed in the order they are defined,
    which means that the presence of the `<f:setPropertyActionListener>` tag can affect
    the order in which the listeners are fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'This note is important! For a clear understanding, take a look at the following
    snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is of the `parametersAction` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, this code does not work as expected! Probably, you think that the setters
    method is called first and the `parametersAction` method later; therefore, the
    set values are available in the action method. But, the following output will
    prove the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the properties are set after the command action listener is fired! To fix
    this issue, you can use the `action` attribute instead of `actionListener`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you need to adjust the `parametersAction` method accordingly, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the output will reflect the following desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch2_16`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters using the Flash scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new JSF Flash scope is a very handy tool when you need to pass parameters
    between user views without the need to store them in the session. The Flash scope
    is simple to understand if you keep in mind that variables stored in the Flash
    scope will be available over a redirection and they will be eliminated afterwards.
    This is really useful when implementing a POST-redirect-GET pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better understanding, let''s suppose the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: A player (user) needs to register on the ATP website. Among other information,
    he will provide his name and surname and click on the **Register** button. This
    is accomplished in the `index.xhtml` page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application flow redirects the player to the page `terms.xhtml`. On this
    page, the user can see a welcome message containing his name and surname and some
    terms and conditions that must be accepted (using the **Accept** button) or rejected
    (using the **Reject** button).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the **Reject** button is clicked, then the user is redirected to the `index.xhtml`
    home page, and the form registration fields will reveal the information provided
    by him earlier. Moreover, he will see a generated message stating **Terms rejected!
    Player not registered!**. This is outputted by the `<h:message>` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the **Accept** button is clicked, then the user is redirected to a page named
    `done.xhtml`. On this page, the user will see a generated message stating **Terms
    accepted and player registered!** and another message stating *Name Surname* **successfully
    registered!**. The first message is outputted by the `<h:message>` tag, while
    the second one by the `<h:outputText>` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a screenshot of both the scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing parameters using the Flash scope](img/6466EN_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, you can implement this flow only if you store the submitted values
    somewhere, because they will not survive during the redirect process. This means
    that using a managed bean in the request scope cannot be a valid option. But,
    if we add in discussion the new Flash scope, then things become more favorable
    for the request scoped bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be much easier to follow this idea if you take a quick look at the
    following code of the request scoped bean, named `PlayersBean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, take a look at the start page, `index.xhtml`. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: So, the submission process begins when the user clicks on the button labeled
    **Register**. JSF will call the `addValuesToFlashAction` method, which is responsible
    for putting the submitted values to the Flash scope; this will ensure that the
    values will survive during redirect to the `terms.xhtml` page.
  prefs: []
  type: TYPE_NORMAL
- en: If the user rejects the terms and conditions, then he is redirected to the `index.xhtml`
    page. Here, you need to repopulate the registration form fields with the user-inserted
    values. For this, you can use the `preRenderView` event, which will load the values
    from the Flash scope during the render response phase by calling the `pullValuesFromFlashAction`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s focus on the `terms.xhtml` page; its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'First, this page displays the entered values wrapped into a welcome message.
    The values are obtained from the Flash scope using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this approach has two functions, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It obtains the values from the Flash scope, which could also be accomplished
    with the following lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It tells JSF to keep the values in the Flash scope for the next request. This
    is needed because values put to the Flash scope survive only one redirect and
    then are deleted. We have already fired a redirect when we have navigated from
    the `index.xhtml` page to the `terms.xhtml` page. But, another redirect will appear
    when the **Accept** or **Reject** button is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Values stored in the Flash scope survive only one redirect and then are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the page displays both the buttons for navigating back to the `index.xhtml`
    page and forward to the `done.xhtml` page. The **Accept** button will call the
    `termsAcceptedAction` method, which will basically preserve messages across redirects
    (it calls the `setKeepMessages` method) and redirects the flow to the `done.xhtml`
    page. In the same manner, the **Reject** button calls the `termsRejectedAction`
    method, preserves messages in the Flash scope, and redirects the flow to the `index.xhtml`
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `done.xhtml` page is presented using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `preRenderView` event listener is used again for obtaining the values from
    the Flash scope.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_21`.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the <f:param> tag with the JSTL <c:set> tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, the JSTL `<c:set>` tag can solve issues that the JSF `<f:param>`
    tag can''t. Probably, you know that we can pass parameters to the `<ui:include>`
    tag using the `<f:param>` tag, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Well, this approach triggers an issue! Now, the `Rafael Nadal Page` value will
    be available in the included page through EL, `#{rafa}`, but will not be available
    in the constructor of the managed bean of the included page!
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time for the `<c:set>` tag to save the situation; therefore, the code
    will be changed to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Now, in the constructor of the managed bean, the value can be extracted
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the *Configuring system event listeners* section in [Chapter 4](ch04.html
    "Chapter 4. JSF Configurations Using XML Files and Annotations – Part 1"), *JSF
    Configurations Using XML Files and Annotations – Part 1*, you will see how to
    work with system events dedicated to the Flash scope.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data through cookies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSF provides a request cookie map that can be used to work with HTTP cookies.
    Setting cookies can be easily accomplished through JavaScript; the following are
    just some helper methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript method for setting a cookie is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The JavaScript method for deleting a cookie by the name is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The JavaScript method for extracting a cookie by the name is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s suppose that you have two cookies named `name` and `surname`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'JSF can access these cookies through the following request cookie map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'JSF also provides several getters and setters methods for working with cookies.
    These methods are given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Getter methods | Setter methods |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `String getComment()` | `setComment(String arg)` |'
  prefs: []
  type: TYPE_TB
- en: '| `String getDomain()` | `setDomain(String arg)` |'
  prefs: []
  type: TYPE_TB
- en: '| `String getName()` | `setHttpOnly(boolean arg)` |'
  prefs: []
  type: TYPE_TB
- en: '| `String getPath()` | `setPath(String arg)` |'
  prefs: []
  type: TYPE_TB
- en: '| `String getValue()` | `setValue(String arg)` |'
  prefs: []
  type: TYPE_TB
- en: '| `int getMaxAge()` | `setMaxAge(int arg)` |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean getSecure()` | `setSecure(boolean arg)` |'
  prefs: []
  type: TYPE_TB
- en: '| `int getVersion()` | `setVersion(int arg)` |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean isHttpOnly()` |   |'
  prefs: []
  type: TYPE_TB
- en: This example is wrapped into the application named `ch2_18` and can be found
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with hidden fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hidden fields can sometimes be very useful! Passing data in a subtle manner
    can be the perfect choice for dealing with temporary data or information provided
    by the user that should be used again and again. JSF offers the `<h:inputHidden>`
    tag to pass hidden parameters. The following code passes two hidden parameters
    to a managed bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, setting hidden field values from JavaScript is a common practice.
    When the button **Send Rafael Nadal** is clicked, the JavaScript function named
    `setHiddenValues` is called; this happens before the form submission. The `setHiddenValues`
    function is given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Next, the hidden parameters are set in the indicated managed bean properties
    and the `parametersAction` method is called—the set values are ready to use!
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_17` and can be found
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Sending passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSF provides a dedicated tag named `<h:inputSecret>` for rendering the following
    well-known HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you can use it as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch2_19`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing UI component attributes programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Accessing UI component attributes from managed beans using the JSF API is not
    a common approach, but sometimes you may find it useful. For example, let''s suppose
    that we have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you want to obtain the values of the components with IDs, `playerNameId`
    and `playerSurnameId`, in the `processAction` method. Moreover, you want to set
    the value of the component with the ID, `playerNameId`, as `RAFAEL`. Programmatically
    (using the JSF API), you can achieve this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: First, you need to obtain access to `UIViewRoot`, which is the top level UI
    component—the root of the `UIComponent` tree. Then, you can search by the ID for
    the desired UI component through the UI components tree using the `findComponent`
    method. Each UI component provides the `getAttributes` method, which can be used
    to gain access to the UI component attributes by their names. At this point, you
    can extract an attribute value using the `get` method, or set a new attribute
    value using the `put` method.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_20`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters via method expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Passing parameters using method expressions is an elegant solution to send
    parameters as arguments to an action method of a managed bean. For example, let''s
    focus on the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following code, the `action` attribute indicates a method
    that gets two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In the same manner, you can pass numeric values or objects.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_26`.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating via the binding attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSF UI components support an attribute named `binding`, which is rarely used
    and, sometimes, poorly understood. The story behind its meaning can be stretched
    over several pages or summed up in some golden rules. We will start with the binding
    lifespan and a brief overview and will end with the important rules that should
    be taken into account when you decide to used it in production.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to localize the moment in time when the `binding` attribute enters
    the fray, we can refer to the moment when the JSF view is built or restored; the
    result of building/restoring the view is present in the component tree. So, before
    the component tree is deliverable, JSF needs to inspect all `binding` attributes.
    For each of them, JSF will check the presence of a pre-existing (precreated) component.
    If a pre-existing component is found, then it is used; otherwise, JSF will automatically
    create a brand new one, and will pass it as an argument to the setter method that
    corresponds to that `binding` attribute. In addition, JSF adds a reference of
    the component in the view state. Furthermore, a postback request (a form submit)
    will tell JSF to restore the view, which will restore the components and bindings
    based on view state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know what happens with the `binding` attribute, let''s enumerate
    some important aspects of using it:'
  prefs: []
  type: TYPE_NORMAL
- en: After each request (initial or postback), JSF creates an instance of the component
    indicated by the `binding` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the restore view (at the postback), after the component instance is created,
    JSF populates it from the view state, based on the stored reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you bind a component to a bean property (of type `UIComponent`), you actually
    bind the whole component. This kind of binding is a very rare use case, and it
    may be useful when you want to work/expose a component's methods that are not
    available in the view or you need to alter the component's children in a programmatic
    fashion. Moreover, you can alter the component's attributes and instantiate the
    component rather than letting the page author do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since JSF instantiates the component at each request, the bean must be in the
    request scope; otherwise, the component may be shared between different views.
    The view scope may also be a solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `binding` attribute is also used to bind the component to the current view,
    without the need of a bean. This is useful to gain access to the state of a component
    from another component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding a component without a bean property will put the component in the EL
    scope. This happens when the component tree is built; therefore, EL is perfectly
    capable to reveal the bound component at the rendering stage, which takes place
    after the component tree was built.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, a `<h:dataTable>` tag has three useful properties: `first`, `rows`,
    and `rowCount`. If you bind a `<h:dataTable>` tag to the current view, then outside
    of this component, you can access these properties as shown in the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you can set the `rows` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, display the `rowCount` and `first` properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch2_32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can accomplish the same thing from a bean. First, we bind the `<h:dataTable>`
    tag to a bean property of type `HtmlDataTable` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `PlayersBean`, we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch2_31`.
  prefs: []
  type: TYPE_NORMAL
- en: Managed bean communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we have focused especially on the communication between Facelets
    and managed beans. In this section, we will cover another important aspect regarding
    JSF communication—managed beans communication. We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting a managed bean into another bean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between managed beans using the application/session map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing other managed beans programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting a managed bean into another bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A managed bean can be injected into another managed bean using `@ManagedProperty`.
    For example, let''s suppose that you have a managed bean in the session scope
    that stores a player name and surname, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s suppose that you want to have access to this bean''s properties
    from another view scoped bean, named `ProfileBean`. For this, you can use `@ManagedProperty`
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A Facelet that calls the `greetingsAction` method will draw something like
    the following line in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The presence of the `@PostConstruct` method is optional, but it is good to know
    that this is the earliest place where an injected dependency is available.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_22`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use CDI beans, then you can accomplish the same thing as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch2_30`.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between managed beans using the application/session map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Communication between managed beans can be ensured through an application map
    or a session map, depending on what kind of communication is needed, during multiple
    browser sessions or during one browser session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using the application/session map is in the fact that multiple
    beans can communicate with each other independent of their scopes. First, you
    need to define a helper class that provides two static methods, one for adding
    a value into the application map and one for deleting a value from the application
    map, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can improvise a simple scenario: in one managed bean (request scoped),
    put some values into the application map, and in another managed bean (session
    scoped), get those values. So, the first bean code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The managed beans that extract these values from the application map are given
    out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch2_24`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing other managed beans programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may need to access one managed bean from an event listener class
    or another managed bean. Suppose that we have a managed bean on session scope,
    named `PlayersBean`, and one on request scope, named `ProfileBean`, and you want
    to programmatically access `PlayersBean` inside `ProfileBean`. Supposing that
    `PlayersBean` has been created, you can accomplish this task in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `evaluateExpressionGet` method inside `ProfileBean` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `createValueExpression` method inside `ProfileBean` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to make things simpler, when you need to programmatically create a
    value expression, you can use a simple helper method and pass only the expression
    and class, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `ELResolver` inside `ProfileBean` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `evaluateExpressionGet` method is the most common one.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch2_25`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication in JSF is one of the most important aspects, since the entire
    application's flow spins around the capability of processing and sharing data
    between JSF components. As you have seen, there are many ways to pass/get parameters
    and to access managed beans from other managed beans, but choosing the right ones
    for obtaining a robust, harmonious, balanced application depends on experience.
    This chapter covers a wide range of solutions for building communication pipes
    between JSF components, but, as any developer knows, there is always a case that
    requires a new approach!
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next chapter, where we will talk about JSF scopes.
  prefs: []
  type: TYPE_NORMAL
