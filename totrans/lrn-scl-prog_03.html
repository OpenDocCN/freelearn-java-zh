<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deep Dive into Functions</h1>
                </header>
            
            <article>
                
<p>Scala combines both object-oriented and functional programming paradigms. In particular, functions are a first-class language concept. They can be defined in a variety of ways, assigned to variables, passed as parameters, and stored in data structures. Scala gives a lot of flexibility with regard to how these actions can be performed.</p>
<p>We'll start this chapter by looking in detail at different flavors of defining a function. We'll then go on and apply the knowledge about types from the previous chapter to make our functions polymorphic and higher order. We'll study recursion, tail recursion, and trampolining as important aspects of functional programming for the JVM. Finally, we'll evaluate peculiarities related to the fact that functions in Scala are implemented in an object-oriented way.</p>
<p class="mce-root"/>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Ways to define a function</li>
<li>Polymorphic functions</li>
<li>Higher order functions</li>
<li>Recursion</li>
<li>Trampolining</li>
<li>Object-oriented aspects of functions</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<ul>
<li>JDK 1.8+</li>
<li>SBT 1.2+</li>
</ul>
<p>The source code for this chapter is available under <a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter03">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter03</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Ways to define a function</h1>
                </header>
            
            <article>
                
<p>To provide some common ground for the readers with different levels of Scala knowledge, let's recap how a function can be defined<span><span>. We'll start with the basic approaches such as</span></span> <span><span>defining a method and placing it in different scopes to create a local function. Then we'll look at more interesting aspects, for example closing over scope, partial application, different ways to specify function literals, and, finally, currying.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function as a method</h1>
                </header>
            
            <article>
                
<p>Most Scala developers came to it from Java. Because of this, probably the most common way is to define a method inside of a class, trait, or an object, like in the following familiar example:</p>
<pre><span>class </span>MethodDefinition {<br/>  <span>def </span>eq(arg1: <span>String</span>, arg2: Int): Boolean = ! nonEqual(arg1, arg2)<br/>  <span>private def </span>nonEq(a: <span>String</span>, b: Int) = a != b.toString<br/>}</pre>
<p>By convention, we've explicitly defined a return type for the public method in the same way that we would do for the return type in Java. For the non recursive function, the result type can be omitted. We've done this for the private method. </p>
<p>The type declaration for the value parameters is mandatory.</p>
<p>Each value parameter can have one default value assigned to it:</p>
<pre><span>def </span>defaultValues(a: <span>String </span>= <span>"default"</span>)(b: Int = <span>0</span>, c: <span>String </span>= a)(<span>implicit </span>d: Long = b, e: <span>String </span>= a) = <span>???</span></pre>
<p>The preceding snippet also demonstrates that it is possible to define multiple groups of value parameters. The parameters from the last group can be implicit and also can be provided with default values. The default values from consecutive groups can refer to the parameters defined in previous groups as <kbd>e</kbd> refers to the default value of <kbd>c</kbd>, which is <kbd>a</kbd>.</p>
<p>The type of the value parameter prefixed with<span> <kbd>=&gt;</kbd> means that this parameter should not be evaluated at the moment the method is called, but instead each time the parameter is referenced in the body of the method. Such arguments are called <em>by-name parameters</em> and basically, they represent a zero-argument method with the argument's return type:</span></p>
<pre>scala&gt; def byName(int: =&gt; Int) = {<br/>     | println(int)<br/>     | println(int)<br/>     | }<br/>byName: (int: =&gt; Int)Unit<br/>scala&gt; byName({ println("Calculating"); 10 * 2 })<br/>Calculating<br/>20<br/>Calculating<br/>20</pre>
<p>In this example, we can see how the passed block of code is executed twice, matching the number of usages inside the method's body.</p>
<p>The <kbd>*</kbd> (star) can be added as a suffix to the name of the type of the last value parameter to denote that this is a <em>repeated</em> <em>parameter</em> and it takes a number of arguments of the defined type. The given arguments are then available in the method body as a <kbd>collection<span>.Seq</span></kbd><span> of the specified type:</span></p>
<pre><span>def </span>variable(a: <span>String</span>, b: Int*): Unit = {<br/>  <span>val </span>bs: collection.Seq[Int] = b<br/>}<br/><br/>variable(<span>"vararg"</span>, <span>1</span>, <span>2</span>, <span>3</span>)<br/>variable(<span>"Seq"</span>, <span>Seq</span>(<span>1</span>, <span>2</span>, <span>3</span>): _*)</pre>
<p>It is illegal to pass the <kbd>Seq</kbd> direct in place of repeated parameters. The last line in the previous snippet shows the <kbd>:_*</kbd> syntax to mark the last parameter as a <em>sequence argument.</em> The repeated parameter can't take default values.</p>
<p>Arguments in the method definition have names. These names can be used to call the method by providing arguments in any order (as opposed to the order specified in the definition of the method):</p>
<pre><span>def </span>named(first: Int, second: <span>String</span>, third: Boolean) = <span>s"</span><span>$</span>first<span>, </span><span>$</span>second<span>, </span><span>$</span>third<span>"<br/></span><span><br/></span>named(third = <span>false</span>, first = <span>10</span>, second = <span>"Nice"</span>)<br/>named(<span>10</span>, third = <span>true</span>, second = <span>"Cool"</span>)</pre>
<p>The named and normal arguments can be mixed, as shown in the last line of the previous code. In this case, the positional arguments must be specified first.</p>
<p>Until now, we defined our examples in the scope of the enclosing class or object. But Scala gives more flexibility in this regard. A method can be defined in any valid scope. This makes it local to the enclosing block and thus limits its visibility. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Local functions</h1>
                </header>
            
            <article>
                
<p>Here is an example of two <span>functions</span> that are local to the enclosing method:</p>
<pre><span>def </span>average(in: Int*): Int = {<br/> <span>def </span>sum(in: Int*): Int = in.sum<br/> <span>def </span>count(in: Int*): Int = in.size<br/> sum(in:_*)/count(in:_*)<br/>}</pre>
<p>In this example, we have both <kbd>sum</kbd> and <kbd>count</kbd> defined inside of the <kbd>average</kbd> definition, which makes them inaccessible from the outside:</p>
<pre>scala&gt; :type sum<br/>       ^<br/>       error: not found: value sum<br/><br/>scala&gt; :type count<br/>       ^<br/>       error: not found: value count</pre>
<p>As already mentioned, the <span>function</span> does not need to be nested in another method. The enclosing block can be of any kind, for example, a variable definition. For instance, consider if the <kbd>average</kbd> function from the previous example was only defined in order to calculate a single average:</p>
<pre><span>val </span><span>items </span>= <span>Seq</span>(<span>1</span>,<span>2</span>,<span>3</span>,<span>4</span>,<span>5</span>)<br/><span>val </span><span>avg </span>= <span>average</span>(<span>items</span>:_*)</pre>
<p>We could rewrite both code blocks as follows:</p>
<pre><span>val </span><span>items </span>= <span>Seq</span>(<span>1</span>,<span>2</span>,<span>3</span>,<span>4</span>,<span>5</span>)<br/><span>val </span><span>avg </span>= {<br/>  <span>def </span>sum(in: Int*): Int = in.sum<br/>  <span>def </span>count(in: Int*): Int = in.size<br/>  sum(<span>items</span>:_*)/count(<span>items</span>:_*)<br/>}</pre>
<p>The scope visibility rules apply for methods the same way as for other language constructs. Because of this, the parameters of the <kbd>outer</kbd> method are visible to the inner functions and don't need to be passed explicitly. We can rewrite our first example again using this rule, as follows:</p>
<pre><span>def </span>averageNoPassing(in: Int*): Int = {<br/>  <span>def </span>sum: Int = in.sum<br/>  <span>def </span>count: Int = in.size<br/>  sum /count<br/>}</pre>
<p>There is a special name for the functions that refer to the definitions from the enclosing block, <em>closures</em>. Let's discuss them a little more deeply.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Closures</h1>
                </header>
            
            <article>
                
<p>In our function definitions, we've referred to two different types of variables: the ones that are provided as parameters (<em>bound variables</em>) and others, which were defined in the enclosing block (<em>free variables</em>). The free variable is named so, because the function itself does not give any meaning to it.</p>
<p>A function that does not refer to any free variable is self-sufficient and the compiler can translate it to the bytecode in any context. Another way to state this is to say that this definition is closed in itself. It is named, accordingly, a <em>closed term</em>. A function referring to the free variables, on the other hand, can only be compiled in a context where all of these variables are defined. Therefore it is called <em>open term</em> and it closes over the free variables at the moment it is compiled, hence the name <em>closure </em>(over the free variables).</p>
<p>The usual scope resolution rules apply for closures in the same way that they apply for variables and other definitions as demonstrated by the next snippet:</p>
<pre>scala&gt; def outerA = {<br/>     | val free = 5<br/>     | def innerA = {<br/>     | val free = 20<br/>     | def closure(in: Int) = free + in<br/>     | closure(10)<br/>     | }<br/>     | innerA + free<br/>     | }<br/>outerA: Int<br/><br/>scala&gt; outerA<br/>res3: Int = 35</pre>
<p class="mce-root"/>
<p>The <kbd>res3</kbd> is calculated as <kbd>outerA.free (5) + innerA.free (20) + closure.in(10)</kbd>.</p>
<p>The free variable must be defined before the closure, otherwise, the compiler will complain:</p>
<pre>scala&gt; def noReference(in: Int) = {<br/>     | def closure(input: Int) = input + free + in<br/>     | }<br/>           def closure(input: Int) = input + free + in<br/>                                             ^<br/>On line 2: error: not found: value free<br/><br/>scala&gt; def forwardReference(in: Int) = {<br/>     | def closure(input: Int) = input + free + in<br/>     | val free = 30<br/>     | }<br/>           def closure(input: Int) = input + free + in<br/>                                             ^<br/>On line 2: error: forward reference extends over definition of value free</pre>
<p>The first try fails because we forgot to define a free variable. The second is still unsuccessful because the free variable is defined after the closure.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Partial application and functions</h1>
                </header>
            
            <article>
                
<p>Until now, the methods and variables were handled the same way by the compiler. Can we exploit the similarities further and return a method as a result of another method and store it into the variable? Let's give it a try:</p>
<pre>scala&gt; object Functions {<br/>     |   def method(name: String) = {<br/>     |     def function(in1: Int, in2: String): String = name + in2<br/>     |     function<br/>     |   }<br/>     |   val function = method("name")<br/>     | }<br/>           function<br/>           ^<br/>On line 4: error: missing argument list for method function<br/>       Unapplied methods are only converted to functions when a function type is expected.<br/>       You can make this conversion explicit by writing `function _` or `function(_,_)` instead of `function`.</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Unfortunately, it didn't work. We tried to create and return a function from within a method and assign this function to a variable, but the compiler does not allow this. However, it gives us a useful hint about what we are doing wrong!</p>
<p>It turns out that functions and methods are different for the compiler and methods can only be passed in the form of an instance of the enclosing class. This distinction is related to the fact that everything in the JVM is represented as an instance of some class. Because of this, the methods we define become methods of the class, and methods are not first-class citizens in the JVM. Scala works around this approach by having a hierarchy of classes representing functions of different arities. Thus, in order for us to be able to return a method from another method, the former must become a function. And the compiler gave us a hint as to how to achieve this: by using <kbd>_</kbd> (underscore) in the place where the parameters are expected.</p>
<pre>scala&gt; object Functions {<br/>     | def method(name: String) = {<br/>     | def function(in1: Int, in2: String): String = name + in2<br/>     | function _<br/>     | }<br/>     | val function = method("name")<br/>     | }<br/>defined object Functions</pre>
<p>The partial application can have two forms: a single underscore replacing the whole parameter list, or a single underscore replacing each parameter. Thus, for the partial application of the function we've just defined, both <kbd>function _</kbd> or <kbd>function(_,_)</kbd> would be appropriate. </p>
<p>The partial application syntax can be used to create <em>shortcuts</em> for functions defined elsewhere, by importing and partially applying them at the same time:</p>
<pre><span>val </span><span>next </span>= Math.<span>nextAfter </span>_<br/><span>next</span>(<span>10f</span>, <span>20f</span>)<br/><span>val </span><span>/\ </span>= Math.<span>hypot</span>(_, _)<br/><span>/\ </span>(<span>10 </span>, <span>20</span>)</pre>
<p>In general, for the function of N parameters, the partial application means specifying 0 =&lt; M &lt; N parameters and leaving the rest undefined, basically applying the function to some part of the parameter list. This partial application gives a function of (N-M) parameters and the same type of result as the original function back. In our previous example, we defined M to be zero and thus the signature of the resulting function remained unchanged. But the very fact of there being a partial application has converted our method into the function, which allowed us to further work with it as with a value.</p>
<p>In the case, if 0&lt; M &lt;N,  the underscores go into the place of the parameters that are not applied at the moment:</p>
<pre><span>def </span>four(one: <span>String</span>, two: Int, three: Boolean, four: Long) = ()<br/><span>val </span><span>applyTwo </span>= <span>four</span>(<span>"one"</span>, _: Int, <span>true</span>, _: Long)</pre>
<p>We applied the first and third arguments and left the second and fourth unapplied. The compiler requires us to provide a type ascription for missing parameters in order to use it while inferring the type of the resulting function.</p>
<p>The parameter names defined for methods are lost during the partial application and so are default values. The repeated parameters are converted to the <kbd>Seq</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function literals </h1>
                </header>
            
            <article>
                
<p>We can inspect the type of the <kbd>applyTwo</kbd> function using REPL:</p>
<pre>scala&gt; :type Functions.applyTwo<br/>(Int, Long) =&gt; Unit</pre>
<p>This is what the type of a first-class function looks like! In general, the type of function has right and left parts separated by the <kbd>=&gt;</kbd>. The left part defines the types of the arguments, the right part—the type of the result. The implementation follows the same pattern and is called <em>function literal</em>. Here is an example of the full definition for a function of four arguments:</p>
<pre><span>val </span><span>hash</span>: (Int, Boolean, <span>String</span>, Long) =&gt; Int = (a, b, c, d) =&gt; {<br/>  <span>val </span>ab = <span>31 </span>* a.hashCode() + b.hashCode()<br/>  <span>val </span>abc = <span>31 </span>* ab + c.hashCode<br/>  <span>31 </span>* abc + d.hashCode()<br/>}</pre>
<p>On the implementation side, we have a code block which consists of three expressions and therefore is wrapped in curly braces. Please note that we define our function as a <kbd>val</kbd>. </p>
<p>Usually, the function literal can be defined using simplified syntax. For instance, the type inference allows leaving the definition of the result type. The type definition, in this case, disappears altogether, because the type definitions for the parameters will move close to the parameter names exactly as in the definition of a method:</p>
<pre><span>val </span><span>hashInferred </span>= (a: Int, b: Boolean, c: <span>String</span>, d: Long) =&gt;<br/>  // ... same implementation as before</pre>
<p>On the application side, the compiler can help us to simplify the definition even more. Let's consider an example:</p>
<pre><span>def </span>printHash(hasher: <span>String </span>=&gt; Int)(s: <span>String</span>): Unit = <br/><span>  println</span>(hasher(s))</pre>
<p>We could have the following equal definitions for the <kbd>hasher</kbd> function. The full definition looks like the next code block:</p>
<pre><span>val </span><span>hasher1</span>: <span>String </span>=&gt; Int = s =&gt; s.hashCode<br/><span>val </span><span>hasher2 </span>= (s: <span>String</span>) =&gt; s.hashCode<br/>printHash(hasher1)("Full")<br/>printHash(hasher2)("Inferred result type")<br/><br/></pre>
<p>This snippet illustrates four different ways to represent a function literal:</p>
<ul>
<li>Defined inline: <kbd>printHash((s: String) =&gt; s.hashCode)("inline")</kbd></li>
<li>Defined inline with type inference for the function parameter: <kbd>printHash((s: String) =&gt; s.hashCode)("inline")</kbd></li>
<li>Defined inline with type inference for the function parameter (this is known as <em>target typing</em>): <kbd>printHash((s) =&gt; s.hashCode)("inline")</kbd></li>
<li>The parentheses around single argument can be omitted: <kbd>printHash(s =&gt; s.hashCode)("single argument parentheses")</kbd></li>
<li>In the case, if an argument is used in the implementation of the function, at most once we can go further and use placeholder syntax: <kbd>printHash(_.hashCode)("placeholder syntax")</kbd></li>
</ul>
<p>In fact, the placeholder syntax is quite powerful and can also be used to define functions of multiple parameters as well as functions that are not in the target typing <span>position. Here is an example of a function that calculates a hash code for four instances of  <kbd>Int</kbd> using the placeholder syntax:</span></p>
<pre><span>scala&gt; val </span><span>hashPlaceholder </span>= <br/>(_: Int) * <span>31</span>^<span>4 </span>+ (_: Int) * <span>31</span>^<span>3 </span>+ (_: Int) * <span>31</span>^<span>2 </span>+ (_: Int) * <span>31<br/><br/>scala&gt; :type hashPlaceholder<br/>(Int, Int, Int, Int) =&gt; Int<br/></span></pre>
<p>This syntax looks close to the partial application syntax, but represents a completely different language feature.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Currying</h1>
                </header>
            
            <article>
                
<p>Speaking about partial application, we have not referred to one special case of this, <em>currying</em>. Currying is in a sense a partial application where we take a function of N arguments and apply partial application for each argument in a row each time, to produce a function that takes one argument less. We repeat this process until we're left with N functions, each taking one argument. If it sounds complicated, consider the next example of a function of two arguments: </p>
<pre><span>def </span>sum(a: Int, b: Int) = a + b</pre>
<p> Using two parameter lists, we can rewrite it as follows:</p>
<pre><span>def </span>sumAB(a: Int)(b: Int) = a + b</pre>
<p>The type of this method is <kbd>(a: Int)(b: Int): Int</kbd> or expressed as a function: </p>
<pre>:type sumAB _<br/>Int =&gt; (Int =&gt; Int)</pre>
<p>This is a function that takes an <kbd>Int</kbd> and returns a function from <kbd>Int</kbd> to <kbd>Int</kbd>! The number of arguments is not limited to just two of course:</p>
<pre>scala&gt; val sum6 = (a: Int) =&gt; (b: Int) =&gt; (c: Int) =&gt; (d: Int) =&gt; (e: Int) =&gt; (f: Int) =&gt; a + b + c + d+ e + f<br/>sum6: Int =&gt; (Int =&gt; (Int =&gt; (Int =&gt; (Int =&gt; (Int =&gt; Int)))))</pre>
<p>The placeholder syntax will give us the same functionality, but in <em>uncurried</em> form:</p>
<pre>scala&gt; val sum6Placeholder = (_: Int) + (_: Int) + (_: Int) + (_: Int) + (_: Int) + (_: Int)<br/>sum6Placeholder: (Int, Int, Int, Int, Int, Int) =&gt; Int</pre>
<p>Currying is not very important in Scala compared to some other functional programming languages, but it is good to know as a useful functional programming concept.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Polymorphism and higher order functions</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>Until now, we've played with</span><span> functions that operate on only one type of data (<em>monomorphic functions</em>). Now, we will finally apply our type system knowledge to build functions that work for multiple types. Functions that take type parameters are called <em>polymorphic functions</em> similar to polymorphic methods implemented in an object-oriented hierarchy of classes (<em>subtype polymorphism</em>). For functions in Scala, it is called <em>parametric polymorphism</em>. </span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Polymorphic functions</h1>
                </header>
            
            <article>
                
<p><span>We have already used polymorphic functions when we played with <kbd>Glass</kbd> examples in the previous chapter:</span></p>
<pre><span>sealed trait </span>Glass[+<span>Contents</span>]<br/><span>case class </span>Full[<span>Contents</span>](c: <span>Contents</span>) <span>extends </span>Glass[<span>Contents</span>]<br/><span>case object </span>EmptyGlass <span>extends </span>Glass[Nothing]<br/><span>case class </span>Water(purity: Int)<br/><br/><span>def </span>drink(glass: Glass[Water]): Unit = <span>???<br/><br/>scala&gt; :type drink _<br/>Glass[Water] =&gt; Unit<br/><br/></span></pre>
<p>The <kbd>drink</kbd> method is monomorphic and thus can only be applied to the argument of the type <kbd>Glass[Water]</kbd>, not even for an <kbd>EmptyGlass</kbd>. Of course, we don't want to implement a separate method for every possible type of content out there. Instead, we implement our functions in a polymorphic way:</p>
<pre>def drinkAndRefill[C](glass: Glass[C]): Glass[C] = glass<br/>drinkAndRefill: [C](glass: Glass[C])Glass[C]<br/><br/>scala&gt; :type drinkAndRefill _<br/>Glass[Nothing] =&gt; Glass[Nothing]<br/><br/>scala&gt; :type drinkAndRefill[Water] _<br/>Glass[Water] =&gt; Glass[Water]</pre>
<p>The type parameter is available in the body of the method. In this case, we specify that the result should have the same type of content as the argument.</p>
<p>Of course, it is possible to further constrain type parameter as we did before:</p>
<pre><span>def </span>drinkAndRefillWater[<span>B </span>&gt;: Water, <span>C </span>&gt;: <span>B</span>](glass: Glass[<span>B</span>]): Glass[<span>C</span>] = glass<br/><br/>scala&gt; :type drinkAndRefillWater[Water, Water] _<br/>Glass[Water] =&gt; Glass[Water]</pre>
<p>Here, our method accepts any glass as long as it is a glass of water and allows anything more specific than water to be filled in it.</p>
<p>Both examples also demonstrate that we can specify a type parameter during the partial application in order to have a monomorphic function of some specific type. Otherwise, the compiler applies the bottom type parameter the same way as it does when we define a polymorphic function using a function literal:</p>
<pre>scala&gt; def drinkFun[B] = (glass: Glass[B]) =&gt; glass<br/>drinkFun: [B]=&gt; Glass[B] =&gt; Glass[B]<br/><br/>scala&gt; :type drinkFun<br/>Glass[Nothing] =&gt; Glass[Nothing]<br/><br/>scala&gt; drinkFun(Full(Water))<br/>res17: Glass[Water.type] = Full(Water)</pre>
<p>The inferred result type is correct at the moment of function application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Higher-order functions</h1>
                </header>
            
            <article>
                
<p>So far, we have discussed function literals and we've created a <kbd>printHash</kbd> function, which we used to demonstrate different forms of passing functions into methods:</p>
<pre><span>scala&gt; def </span>printHash(hasher: <span>String </span>=&gt; Int)(s: <span>String</span>): Unit = <br/><span>  println</span>(hasher(s))<br/>printHash: (hasher: String =&gt; Int)(s: String)Unit</pre>
<p>The <kbd>printHash</kbd> takes two parameters: the <kbd>hasher</kbd> function and a string to hash. Or, in functional form:</p>
<pre>scala&gt; :type printHash _<br/>(String =&gt; Int) =&gt; (String =&gt; Unit)</pre>
<p>Our function is <kbd>curried</kbd> as it takes one argument (a <kbd>String =&gt; Int</kbd> <span>function</span>) and returns another function, <kbd>String =&gt; Unit</kbd>. The fact that <kbd>printHash</kbd> takes a function as an argument is reflected by saying that <kbd>printHash</kbd> is a <strong>higher order function</strong> (<strong>HOF</strong>). There is nothing else special about HOFs except the fact that one or multiple parameters are functions. They work just as normal functions, can be assigned and passed over, partially applied and be polymorphic:</p>
<pre><span>def </span>printHash[<span>A</span>](hasher: <span>A </span>=&gt; Int)(s: <span>A</span>): Unit = <span>println</span>(hasher(s))</pre>
<p>In fact, HOFs usually apply function(s) given as parameter(s) to another parameter in some creative ways and therefore are almost always polymorphic.</p>
<p class="mce-root"/>
<p>Let's take another look at our <kbd>printHash</kbd> example. There is nothing in particular that requires a <kbd>hasher</kbd> function to calculate a hash; the function carried out by the <kbd>hasher</kbd> is independent of the logic of the <kbd>printHash</kbd>. Interestingly, this is the case more often than one would expect and it leads to the definition of HOF, for example:</p>
<pre>def printer[A, B, C &lt;: A](f: A =&gt; B)(a: C): Unit = println(f(a))</pre>
<p>Our printing logic does not require the given function to have any specific type of an argument or result. The only limitation we need to enforce is that it is possible to call the function with the given argument, which we formulate with the type constraint <kbd>C &lt;: A</kbd>. The nature of the function and an argument can also be anything, and it is common to use short neutral names when defining a HOF because of this. This is how our new definition can be used in practice:</p>
<pre>scala&gt; printer((_: String).hashCode)("HaHa")<br/>2240498<br/>scala&gt; printer((_: Int) / 2)(42)<br/>21</pre>
<p>The compiler needs to know the type of the function, and therefore we need to define it as a part of the placeholder syntax. We can help the compiler by changing the order of the parameters of the function:</p>
<pre><span>def </span>printer[<span>A</span>, <span>B</span>, <span>C </span>&lt;: <span>A</span>](a: <span>C</span>)(f: <span>A </span>=&gt; <span>B</span>): Unit = <span>println</span>(f(a))</pre>
<p>With this definition, it will be possible to infer the <kbd>C</kbd> first and then use the inferred type to enforce the type of <kbd>f</kbd>:</p>
<pre>scala&gt; printer("HoHo")(_.length)<br/>4<br/>scala&gt; printer(42)(identity)<br/>42</pre>
<p>The <kbd>identity</kbd> function is defined as <kbd>def identity[A](x: A): A = x</kbd> in the standard library.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Recursion and trampolining</h1>
                </header>
            
            <article>
                
<p>There is a special case of a function calling another function<span>—t</span>he function calling itself. Such functions are called <em>recursive</em>. Recursive functions can be head-recursive or tail-recursive. There is also an approach to model recursive calls in an object-oriented way called <em>trampolining</em>. Recursion is very convenient and often uses the technique in functional programming, so let's take a close look at these concepts.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Recursion</h1>
                </header>
            
            <article>
                
<p>Recursion is used to implement recurring logic without relying on loops and the internal states associated with them. The recursive behavior is defined by two properties:</p>
<ul>
<li><strong>Base case</strong>: The simplest terminating case, in which no recursive calls are needed anymore</li>
<li><strong>Recursive case</strong>: The set of rules describing how to reduce any other state to the base case</li>
</ul>
<p>One of the possible examples for recursive implementation can be reversing a string. The two recursive properties would be:</p>
<ul>
<li>The base case is an empty or single-char string. In this case, the reversed string is just the same string as given.</li>
<li>The recursive case for the string of length N can be reduced to the case of a string of length N-1 by taking the first char of the string and appending it to the reversed tail of the given string.</li>
</ul>
<p>This is how we implement this logic in Scala:</p>
<pre><span>def </span>reverse(s: <span>String</span>): <span>String </span>= {<br/>  <span>if </span>(s.length &lt; <span>2</span>) s<br/>  <span>else </span><span>reverse</span>(s.tail) + s.head<br/>}</pre>
<p>So, this is easier implemented than explained, right? </p>
<p>One important aspect of our implementation in a recursive case is that it first makes the recursive call and then adds the rest of the string to the result. Such functions are <span>head-recursive (but usually just called recursive) in the sense that the recursive call stays in the head of the computation. This works in a similar way to the depth-first algorithm, with the implementation first going down to the terminal case and then building up the result from the bottom up:</span></p>
<pre>scala&gt; println(reverse("Recursive function call"))<br/>llac noitcnuf evisruceR</pre>
<p>The nested function calls are naturally kept in the stack during runtime. Because of this, functions that work fine for inputs of smaller size might blow up the stack for bigger inputs, crashing the whole application:</p>
<pre>scala&gt; println(reverse("ABC" * 100000))<br/>java.lang.StackOverflowError<br/>  at scala.collection.StringOps$.slice$extension(StringOps.scala:548)<br/>  at scala.collection.StringOps$.tail$extension(StringOps.scala:1026)<br/>  at ch03.Recursion$.reverse(Recursion.scala:7)<br/>  at ch03.Recursion$.reverse(Recursion.scala:7)<br/>  at ch03.Recursion$.reverse(Recursion.scala:7)<br/>  ...</pre>
<p>It is possible to increase the size of memory reserved for a stack in JVM, but often there is a better solution—tail recursion.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tail recursion</h1>
                </header>
            
            <article>
                
<p>In the tail-recursive function, the recursive call is done as the very last activity. Because of this, it is possible to "finish" all the "preparations" for the call and then just "jump" back to the beginning of the function with new arguments. The Scala compiler rewrites tail-recursive calls as loops and hence such recursive invocations do not consume the stack at all. Usually, to make a recursive function tail-recursive, either some kind of state<span> or some sort of and/or local helper function is </span>introduced.</p>
<p>Let's rewrite our reverse function in the tail-recursive way:</p>
<pre><span>def </span>tailRecReverse(s: <span>String</span>): <span>String </span>= {<br/>  <span>def </span>reverse(s: <span>String</span>, acc: <span>String</span>): <span>String </span>=<br/>    <span>if </span>(s.length &lt; <span>2</span>) s + acc<br/>    <span>else </span>reverse(s.tail, s.head + acc)<br/>  reverse(s, <span>""</span>)<br/>}</pre>
<p>In this implementation, we've defined a local tail-recursive function, <kbd>reverse</kbd>, which shadows the argument <kbd>s</kbd> so that we do not unintentionally reference it, and also introduces an <kbd>acc</kbd> argument, which is needed to carry over the remaining part of the string. Now the reverse is called after the head of the string and <kbd>acc</kbd> are glued together. To return the result, we call the helper function with the original argument and an empty accumulator.</p>
<p>This implementation does not consume the stack, which we can check by throwing an exception in the base case and inspecting the stack trace:</p>
<pre>scala&gt; println(inspectReverse("Recursive function call"))<br/>java.lang.Exception<br/>  at $line19.$read$$iw$$iw$.reverse$1(&lt;console&gt;:3)<br/>  at $line19.$read$$iw$$iw$.inspectReverse(&lt;console&gt;:5)</pre>
<p class="mce-root"/>
<p>At the moment we're finishing the reversing of the string, we still have just a single recursive call in the stack. Sometimes it confuses the developer as it appears as if the recursive call would not be made. In this case, it is possible to disable tail-call optimization by using the <strong>notailcalls</strong> compiler option.</p>
<p>Sometimes the opposite is happening and a (presumably) tail-recursive call overflows the stack at runtime because the developer overlooked a recursive call in the head position. To eliminate the possibility for such kinds of error there is a special annotation for tail-recursive calls, <kbd>@scala.annotation.tailrec</kbd>:</p>
<pre><span>def </span>inspectReverse(s: <span>String</span>): <span>String </span>= {<br/>  <span>@scala.annotation.tailrec<br/></span><span>  </span><span>def </span>reverse(s: <span>String</span>, acc: <span>String</span>): <span>String </span>= ...<br/>}</pre>
<p>The compiler will fail to compile head-recursive functions with this annotation:</p>
<pre>scala&gt; @scala.annotation.tailrec<br/>     | def reverse(s: String): String = {<br/>     | if (s.length &lt; 2) s<br/>     | else reverse(s.tail) + s.head<br/>     | }<br/>           else reverse(s.tail) + s.head<br/>                                ^<br/>On line 4: error: could not optimize @tailrec annotated method reverse: it contains a recursive call not in tail position</pre>
<p>It seems as if we're on the safe side with properly annotated tail-recursive functions? Well, not 100%, because there is also a possibility that some functions cannot be made tail-recursive at all.</p>
<p>One of the examples, when tail recursion cannot be implemented, is mutual recursion. <span>Two functions are mutually recursive if the first calls the second, and the second calls the first. </span></p>
<div class="packt_infobox">In mathematics, a Hofstadter sequence is a member of a family of related integer sequences defined by nonlinear recurrence relations. You can learn more about them in Wikipedia at <a href="https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences">https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences</a>.</div>
<p><span>One of the examples of such functions is <kbd>Hofstadter</kbd> Female and Male sequences, </span>defined as follows:</p>
<pre><span>def </span>F(n:Int): Int = <span>if </span>(n == <span>0</span>) <span>1 </span><span>else </span>n - <span>M</span>(<span>F</span>(n-<span>1</span>))<br/><span>def </span>M(n:Int): Int = <span>if </span>(n == <span>0</span>) <span>0 </span><span>else </span>n - <span>F</span>(<span>M</span>(n-<span>1</span>))</pre>
<p>Another example of a non-tail-recursive function is an Ackerman function (more about it can be found at <a href="https://en.wikipedia.org/wiki/Ackermann_function">https://en.wikipedia.org/wiki/Ackermann_function</a>) with the following definition:</p>
<pre><span>val </span><span>A</span>: (Long, Long) =&gt; Long = (m, n) =&gt;<br/>  <span>if </span>(m == <span>0</span>) n + <span>1<br/></span><span>  </span><span>else if </span>(n == <span>0</span>) <span>A</span>(m - <span>1</span>, <span>1</span>)<br/>  <span>else </span><span>A</span>(m - <span>1</span>, <span>A</span>(m, n - <span>1</span>))</pre>
<p>It is very simple, but not primitive recursive, it is stack-hungry, and it overflows the stack even with moderate values of m and n:</p>
<pre>scala&gt; A(4,2)<br/>java.lang.StackOverflowError<br/>  at .A(&lt;console&gt;:4)<br/>  at .A(&lt;console&gt;:4)<br/>...</pre>
<p>There is a special technique called trampolining to implement non-tail-recursive functions on JVM.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Trampolining</h1>
                </header>
            
            <article>
                
<p>In essence, <em>trampolining</em> is replacing recursive function calls with objects representing these calls. This way the recursive computation is built up in the heap instead of the stack, and it is possible to represent much deeper recursive calls just because of the bigger size of the heap.</p>
<p>The Scala <kbd><span class="pl-en">util</span><span>.</span></kbd><span class="pl-en"><kbd>control.</kbd><span><kbd>TailCalls</kbd> implementation provides a ready-to-use abstraction for trampolined recursive calls. Remember that we have two general cases in recursion that break down to three concrete cases? These are:</span></span></p>
<ul>
<li>The base case</li>
<li>The recursive case, which can be:
<ul>
<li>Head recursion</li>
<li>Tail recursion</li>
</ul>
</li>
</ul>
<p>The representation reflects them by following three protected case classes:</p>
<pre><span>case class Done[A](value: A) extends TailRec[A]<br/>case class </span>Call[<span>A</span>](rest: () =&gt; TailRec[<span>A</span>]) <span>extends </span>TailRec[<span>A</span>]<span><br/></span><span>case class </span>Cont[<span>A</span>, <span>B</span>](a: TailRec[<span>A</span>], f: <span>A </span>=&gt; TailRec[<span>B</span>]) <span>extends </span>TailRec[<span>B</span>]</pre>
<p>As these are protected, we can't use them directly, but are expected to use special helper methods instead. Let's take a look at them by re implementing our Ackerman function:</p>
<pre><span>import </span>util.control.TailCalls._<br/><br/><span>def </span>tailA(m: <span>BigInt</span>, n: <span>BigInt</span>): TailRec[<span>BigInt</span>] = {<br/>  <span>if </span>(m == <span>0</span>) <span>done</span>(n + <span>1</span>)<br/>  <span>else if </span>(n == <span>0</span>) <span>tailcall</span>(<span>tailA</span>(m - <span>1</span>, <span>1</span>))<br/>  <span>else </span><span>tailcall</span>(<span>tailA</span>(m, n - <span>1</span>)).flatMap(<span>tailA</span>(m - <span>1</span>, _))<br/>}<br/><span>def </span>A(m: Int, n: Int): <span>BigInt </span>= <span>tailA</span>(m, n).result</pre>
<p>We wrap our recursive calls into the <kbd>tailcall</kbd> method, which creates an instance of a <kbd>Call</kbd>. The recursive call is a bit more complex than the base case because we first need to recursively wrap the internal call and then use the <kbd>flatMap</kbd> method provided by the <kbd>TailRec</kbd> to pass the result into the outer recursive call.</p>
<p>The <kbd>A</kbd> is just a helper method to unlift the result of the calculation from the <kbd>TailRec</kbd>. We're using <kbd>BigInt</kbd> to represent the result because now, as the implementation is stack safe, it can return quite huge numbers:</p>
<pre>scala&gt; Trampolined.A(4,2).toString.length<br/><br/></pre>
<p>Now, as we've seen how to represent recursive functions as objects, it is time to reveal another truth about Scala functions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Object-oriented aspects of functions</h1>
                </header>
            
            <article>
                
<p>We mentioned that Scala is a fusion of object-oriented and functional paradigms. Because of this, Scala has functions as a first-class element of the language. Also because of this, everything is an object in Scala. This is partly related to the fact that everything is an object or a primitive type in the JVM, but Scala goes further and also hides primitives behind objects.</p>
<p>It turns out that functions are also objects! Depending on the number of arguments, they extend one of the special traits. Also because of their object-oriented nature, it is possible to implement additional features by defining additional methods on the implementing class. This is how partial function is implemented. It is also natural to utilize companion objects to define <span>common </span>logic for functions so that it can be easily reused. It's even possible to write some custom implementation of a function, though it is seldom a good idea.</p>
<p>Each of these aspects is worth a deep dive, but to really understand them, we need to start with some implementation details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions are traits</h1>
                </header>
            
            <article>
                
<p>Each function in Scala implements a <kbd>FunctionN</kbd> <span>trait, </span>where N is an arity of the function. The zero-argument function is translated by the compiler to the implementation of <kbd>Function0</kbd>, of one argument—to <kbd>Function1</kbd> and so on, up to <kbd>Function22</kbd>. This complexity is needed because of the static nature of the language. Does it mean it is not possible to define functions of more than 22 arguments? Well, it is always possible to define a function using currying or multiple parameter lists, so this is not really a limitation.</p>
<p>Function literals are just a syntactic sugar accepted by the compiler for developers' convenience. This is how the desugared signature of our previously defined Ackerman function looks:</p>
<pre><span>val </span><span>A</span>: Function2[Long, Long, Long] = (m, n) =&gt;<br/>  <span>if </span>(m == <span>0</span>) n + <span>1<br/></span><span>  </span><span>else if </span>(n == <span>0</span>) <span>A</span>.apply(m - <span>1</span>, <span>1</span>)<br/>  <span>else </span><span>A</span>.apply(m - <span>1</span>, <span>A</span>.apply(m, n - <span>1</span>))</pre>
<p>And the (simplified) definition of <kbd>Function2</kbd> in the standard library is like this:</p>
<pre><span>trait </span>Function2[<span>-T1</span>, <span>-T2</span>, <span>+R</span>] <span>extends </span>AnyRef { self =&gt;<br/><span>  </span><span>def </span>apply(v1: <span>T1</span>, v2: <span>T2</span>): <span>R<br/>  ...<br/>}</span></pre>
<p>Remember our co- and contravariance discussion in the previous chapter? Here we have it in action; the arguments are contravariant and the result type is covariant.</p>
<p>It turns out that the compiler rewrites our definition as an instance of an anonymous class implementing this trait:</p>
<pre><span>val </span><span>objectOrientedA</span>: Function2[Long, Long, Long] = <br/><span>  new </span>Function2[Long, Long, Long] {<br/>    <span>def </span>apply(m: Long, n: Long): Long =<br/>      <span>if </span>(m == <span>0</span>) n + <span>1<br/></span><span>      </span><span>else if </span>(n == <span>0</span>) <span>objectOrientedA</span>(m - <span>1</span>, <span>1</span>)<br/>      <span>else </span><span>objectOrientedA</span>(m - <span>1</span>, <span>objectOrientedA</span>(m, n - <span>1</span>))<br/>}</pre>
<p>And the instance of this class can then be passed over, assigned to a variable, stored into data structures, and so on. The <kbd>FunctionN</kbd> trait also defines a few helper methods that implement function-related functionality at the library level, as opposed to the language syntax. One example is a conversion of a normal function into the <kbd>curried</kbd> form, which for <kbd>Function2[T1,T2,R]</kbd> is defined as <kbd>def curried: T1 =&gt; T2 =&gt; R = (x1: T1) =&gt; (x2: T2) =&gt; apply(x1, x2) </kbd></p>
<pre>scala&gt; objectOrientedA.curried<br/>res9: Long =&gt; (Long =&gt; Long)</pre>
<p><span>This method is available for any function.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Partial functions</h1>
                </header>
            
            <article>
                
<p>The possibility of having additional methods gives a way do define concepts that would be hard to state otherwise, at least without extending the language itself. One such example is <em>partial functions</em>. A partial function is a function that is undefined for some values of its arguments. The classical example is a division that is not defined, for the divider equals zero. But actually, it is possible to have arbitrary domain rules that make some function partial. For instance, we could decide that our string reverse function should be undefined for empty strings.</p>
<p>There are a couple of possibilities for implementing such constraints in a program:</p>
<ul>
<li>Throw an exception for arguments for which the function is not defined</li>
<li>Constrain the type of an argument so that it is only possible to pass a valid argument to the function, for example using refined types</li>
<li>Reflect the partiality in the return type, for example using <kbd>Option</kbd> or <kbd>Either</kbd></li>
</ul>
<p>There are obvious tradeoffs related to each of these approaches and in Scala, the first one is preferred as most natural. But, to better model the partial nature of the function, there is a special trait available in the standard library: </p>
<pre><span>trait </span>PartialFunction[<span>-A</span>, <span>+B</span>] <span>extends </span>(<span>A </span>=&gt; <span>B</span>)</pre>
<p>The key difference to normal function is that there is an additional method available that allows us to check whether the function is defined for some argument or not:</p>
<pre><span>def </span>isDefinedAt(x: <span>A</span>): Boolean</pre>
<p>This allows the user of the function to do something different for "invalid" input values.</p>
<p class="mce-root"/>
<p class="mce-root">For example, let's imagine we've invented a very efficient method to check if a string is a palindrome. Then we could define our reverse function as two partial functions, one that is only defined for palindromes and does nothing and another that is defined only for non-palindromes and does the actual reverse action:</p>
<pre><span>val </span><span>doReverse</span>: PartialFunction[<span>String</span>, <span>String</span>] = {<br/>  <span>case </span>str <span>if </span>!<span>isPalindrome</span>(str) =&gt; str.reverse<br/>}<br/><span>val </span><span>noReverse</span>: PartialFunction[<span>String</span>, <span>String</span>] = {<br/>  <span>case </span>str <span>if </span><span>isPalindrome</span>(str) =&gt; str<br/>}<br/><span>def </span>reverse = <span>noReverse </span>orElse <span>doReverse<br/></span></pre>
<p>Here we're using syntactic sugar again to define our partial functions as a pattern match and compiler creates <kbd>isDefinedAt</kbd> method for us. Our two partial functions are combined into the total function using the <kbd>orElse</kbd> method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function object</h1>
                </header>
            
            <article>
                
<p>The <kbd>orElse</kbd> method for partial function and <kbd>curried</kbd> method for a normal function earlier are just two examples of function-related methods predefined in the standard library.</p>
<p>Similar to the <kbd>curried</kbd> method defined for every function instance (except <kbd>Function0</kbd> and <kbd>Function1</kbd>) there is another one, <kbd>tupled</kbd>, which converts a function of N arguments into the function of one argument which is a <kbd>TupleN</kbd>. </p>
<p>Besides that, there is a companion object, <kbd>scala.Function</kbd>, that incorporates a few methods that are useful for higher order functional programming, most notably a <kbd>const</kbd> function, which always returns its argument, and a <kbd>chain</kbd> function, which combines a list of functions into a single function as in the following example:</p>
<pre>val upper = (_: String).toUpperCase<br/>def fill(c: Char) = c.toString * (_: String).length<br/>def filter(c: Char) = (_: String).filter(_ == c)<br/><br/>val chain = List(upper, filter('L'), fill('*'))<br/>val allAtOnce = Function.chain(chain)<br/><br/>scala&gt; allAtOnce("List(upper, filter('a'), fill('C'))")<br/>res11: String = ****</pre>
<p><kbd>allAtOnce</kbd> is a function that is similar to the one that could be constructed by combining our three original functions with <kbd>andThen</kbd> (which is defined in the <kbd>FunctionN</kbd> trait):</p>
<pre><span>val </span><span>static </span>= <span>upper </span>andThen <span>filter</span>(<span>'a'</span>) andThen <span>fill</span>(<span>'C'</span>)</pre>
<p>But <kbd><span>allAtOnce</span></kbd> is built in a dynamic manner.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Extending functions</h1>
                </header>
            
            <article>
                
<p>Nothing prevents a developer from extending a <kbd>FunctionN</kbd> trait the same way it is done with <kbd>PartialFunction</kbd>, though it seldom makes sense because of the limitations imposed by the referential transparency constraint. This means that such an implementation of the function should not have a shared state, nor should it mutate state. </p>
<p>It might be tempting, for example, to implement a loaner pattern as a function, so that a used resource would be automatically closed after function application, but it won't be referentially transparent and thus won't satisfy the requirements for a function.</p>
<p>Here is how the implementation could look:</p>
<pre><span>class </span>Loan[<span>-T </span>&lt;: AutoCloseable, <span>+R</span>](app: <span>T </span>=&gt; <span>R</span>) <span>extends </span>(<span>T </span>=&gt; <span>R</span>) {<br/>  <span>override def </span>apply(t: <span>T</span>): <span>R </span>= <span>try </span>app(t) <span>finally </span>t.close()<br/>}</pre>
<p>And this is what happens if we call it:</p>
<pre>scala&gt; new Loan((_: java.io.BufferedReader).readLine())(Console.in)<br/>res13: String = Hello<br/><br/>scala&gt; [error] (run-main-0) java.io.IOException: Stream Closed<br/>[error] java.io.IOException: Stream Closed<br/>[error] at java.io.FileInputStream.read0(Native Method)<br/>[error] at java.io.FileInputStream.read(FileInputStream.java:207)<br/>[error] at jline.internal.NonBlockingInputStream.read(NonBlockingInputStream.java:245)<br/>...</pre>
<p>Unfortunately, it is not even possible to test whether the second call would produce the same result (obviously it will not) because we broke the REPL by closing the <kbd>Console.in</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">Functions represent another side of the blend of object-oriented and functional features in Scala. They can be defined in a number of ways, including the partial application of methods, function literals, and partial functions. Functions can be defined in any scope. If a function closes over variables available in scope, it is called <strong>closure</strong>.</p>
<p class="p1">Polymorphic functions implement an idea similar to polymorphism in object orientation, but apply that idea for types of parameters and of the result. This is called parametric polymorphism. It is especially useful when defining functions accepting other functions as arguments, so-called higher order functions.</p>
<p class="p1">There are two ways to implement recursion and only tail-recursive functions are stack safe in the JVM. For the functions which cannot be made tail-recursive, there is a way to represent the call chain in the heap by encoding it as objects. This approach is called trampolining and it is supported in the standard library.</p>
<p class="p1">Functions are first-class values in Scala because they are implemented as anonymous classes extending <kbd>FunctionN</kbd> traits. This not only makes it possible to work with functions as with normal variables, but it also allows for the provision of extended function implementations with additional properties, for example, a <kbd>PartialFunction</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What will be a type of following function in <kbd>curried</kbd> form: <kbd>(Int, String) =&gt; (Long, Boolean, Int) =&gt; String</kbd> ? </li>
<li>Describe the difference between a partially applied function and a partial function</li>
<li>Define a signature and implement a function <kbd>uncurry</kbd> for a <kbd>curried</kbd> function of three arguments <kbd>A =&gt; B =&gt; C =&gt; R</kbd></li>
<li>Implement a head-recursive function for factorial calculation n! = n * (n-1) * (n-2) * ... * 1</li>
<li>Implement a tail-recursive function for factorial calculation</li>
<li>Implement a recursive function for factorial calculation using trampolining</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<div class="book-top-block-info-anl cf">
<p class="book-top-block-info-authors left">Mads Hartmann and Ruslan Shevchenko, <em>Professional Scala</em>:<span> Write the type-safe code concise and expressive in an environment that lets you build for the JVM, browser, and more.</span></p>
</div>
<p><span>Vikash Sharma, </span><em>Learning Scala Programming</em>: <span>Learn how to write scalable and concurrent programs in Scala, a language that grows with you.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>