- en: '7\. Recursion II: Lazy Sequences'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 递归 II：惰性序列
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, as we continue our exploration of recursive techniques, we
    will focus on lazy evaluation. We will write functions that safely produce potentially
    infinite lazy sequences, use lazy evaluation to consume linear data, produce lazily
    evaluated tree structures from linear data, and write functions that consume tree structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，随着我们继续探索递归技术，我们将重点关注惰性评估。我们将编写能够安全地产生可能无限长的惰性序列的函数，使用惰性评估来消费线性数据，从线性数据中产生惰性评估的树结构，并编写消费树结构的函数。
- en: By the end of this chapter, you will be able to think about new ways of understanding
    and solving problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够思考新的理解和解决问题的方法。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'At its simplest, a **lazy sequence** is a hybrid of two things:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，一个 **惰性序列** 是两件事物的混合体：
- en: A *list* (not a vector!) of zero or more items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含零个或多个项的 *列表*（不是向量！）
- en: A *reference* to possible future items of the list that can be computed if necessary
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对列表可能未来项的 *引用*，这些项在必要时可以计算
- en: 'In other words, there''s a real part and a virtual part. Most of the time,
    you don''t need to think about this distinction. That''s the whole point of lazy
    sequences: the virtual part becomes real when you need it, if you need it. When
    you can stay away from the edge cases, you don''t need to worry about the virtual
    part because as soon as it''s needed, it will become real.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，有一个实部和虚部。大多数时候，你不需要考虑这种区别。这正是惰性序列的全部意义：当你需要时，虚部才会变成实部。如果你可以避开边缘情况，你就不需要担心虚部，因为一旦需要，它就会变成实部。
- en: 'Over the last few chapters, we''ve already used lazy sequences in many different
    ways. They are an important, distinctive feature of Clojure and they are something
    that you''ll use every day as a Clojure programmer. You''ve seen by now that they
    are list-like structures with a twist: while you are using the first elements
    of the list, the rest of the list may not exist during runtime. Remember that
    in a lazy sequence, the individual items are not computed until they are needed.
    Or, to use the vocabulary of Clojure, they are not realized until they are consumed.
    You can define a potentially infinite lazy sequence and then only use, and compute,
    the first three items.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们已经以许多不同的方式使用了惰性序列。它们是Clojure的重要、独特特性，作为Clojure程序员，你每天都会用到它们。到现在为止，你已经看到它们是类似列表的结构，但有所区别：当你使用列表的第一个元素时，列表的其余部分在运行时可能不存在。记住，在惰性序列中，各个项只有在需要时才会被计算。或者，用Clojure的术语来说，它们只有在被消费时才会被实现。你可以定义一个可能无限的惰性序列，然后只使用和计算前三个项。
- en: Up to now, the lazy sequences we've used were returned by core Clojure functions,
    such as `iterate`, which we looked at briefly in *Chapter 6*, *Recursion and Looping*,
    or familiar functions such as `map` and `filter`, which we saw in *Chapter 4*,
    *Mapping and Filtering*. The next step forward in this path is learning to write
    your own functions to produce lazy sequences.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的惰性序列是由核心Clojure函数返回的，例如 `iterate`，我们在 *第6章*，*递归和循环* 中简要介绍了它，或者熟悉的功能，例如
    `map` 和 `filter`，我们在 *第4章*，*映射和过滤* 中看到了它们。在这个路径上的下一步是学习编写自己的函数来产生惰性序列。
- en: 'When working in Clojure, lazy sequences are used all the time, as you''ve already
    seen by now. Writing functions to build your own lazy sequences is an advanced
    step and is more prone to errors. It should be considered the final option when
    dealing with sequences. Here is a rough guide to when deciding which techniques
    to use for solving a sequence-related problem:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Clojure中工作时，惰性序列被频繁使用，正如你现在所看到的。编写函数来构建你自己的惰性序列是一个高级步骤，更容易出错。在处理序列时，它应该被视为最后的选项。以下是在决定解决序列相关问题时使用哪种技术的大致指南：
- en: '`map`, `filter`, and `remove` that accept and return sequences will be all
    you need when working with sequential data.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理顺序数据时，`map`、`filter` 和 `remove` 这些接受和返回序列的函数将是你所需要的所有。
- en: '`reduce`, because your calculation needs to take into account the relationships
    between items in your data, or because you need to produce an aggregate result.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`，因为你的计算需要考虑数据中项之间的关系，或者因为你需要产生一个汇总结果。'
- en: '`recur`), or because your data is non-linear, such as a `tree` or a `graph`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recur`），或者因为你的数据是非线性的，例如 `树` 或 `图`。'
- en: '**Option 4**: In a subset of the cases in *Option 3*, the input data is extremely
    vast, or your calculation produces too many branches. The result is a blown call
    stack. In such cases, lazy sequences are a solution.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项 4**：在选项 3 的某些子集情况下，输入数据极其庞大，或者你的计算产生了太多的分支。结果是调用栈溢出。在这种情况下，惰性序列是一个解决方案。'
- en: Each step down this list incurs a higher cost in terms of programmer effort
    and code complexity. When you stay closer to the beginning of the list, Clojure
    provides more help and protection from potential mistakes. As you move further
    down the list, you have to pay more attention to how you implement your solution.
    Part of being an effective Clojure developer is knowing how to avoid options 3
    and 4 when you can, and then using them effectively when you really need to. For
    certain kinds of problems, such as parsing deeply nested data structures, lazy
    sequences are a very good fit, and may be the only practical solution in Clojure.
    That's why it's an important skill to have. There is another benefit too. Knowing
    how lazy sequences are produced will give you a deeper understanding of how they
    work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每向下移动一步列表，程序员的努力和代码复杂性都会增加。当你接近列表的起始位置时，Clojure 提供了更多的帮助和防止潜在错误的能力。当你进一步向下移动列表时，你必须更加注意你解决方案的实现方式。成为一名有效的
    Clojure 开发者的一部分是知道如何在可能的情况下避免选项 3 和 4，并在真正需要时有效地使用它们。对于某些类型的问题，例如解析深层嵌套的数据结构，惰性序列是一个非常好的选择，可能是
    Clojure 中唯一实用的解决方案。这就是为什么它是一项重要的技能。还有另一个好处。了解惰性序列是如何产生的，将使你对它们的工作原理有更深入的理解。
- en: In this chapter, we will start by using lazy sequences to deal with linear data
    before moving on to more complex tree structures.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先使用惰性序列来处理线性数据，然后再转向更复杂的树结构。
- en: A Simple Lazy Sequence
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的惰性序列
- en: 'To start with, let''s consider the simplest possible producer of lazy sequences,
    the `range` function, which simply returns a possibly infinite series of consecutive
    integers. The easiest way to write this is to use `iterate`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑最简单的惰性序列生产者，即 `range` 函数，它简单地返回一个可能无限的一系列连续整数。编写它的最简单方法是使用 `iterate`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `iterate` returns a sequence that starts with the initializer value,
    zero, and then continues with the result of calling `inc` on zero, then on the
    result of that and so on. Each intermediate value becomes an item in the returned
    lazy sequence. It works just fine:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`iterate` 返回一个以初始化值零开始的序列，然后继续调用 `inc` 函数的结果，然后是那个结果，以此类推。每个中间值都成为返回的惰性序列中的一个项。它工作得很好：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `iterate` function is doing all the work. We could stop here, but we wouldn''t
    have learned much about how lazy sequences are built. Here''s a more low-level
    version that performs the same task. It uses the `lazy-seq` macro, which is the
    base of all lazy sequences:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterate` 函数正在做所有的工作。我们本可以在这里停止，但我们不会学到很多关于惰性序列是如何构建的。这是一个更底层的版本，执行相同的任务。它使用
    `lazy-seq` 宏，这是所有惰性序列的基础：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function might look strange to you. We''re going to break it down in detail.
    Before we do that, let''s make sure it works:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可能看起来对你来说很奇怪。我们将详细分解它。在我们这样做之前，让我们确保它工作正常：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are three things that stand out here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三点引人注目。
- en: The use of `lazy-seq`. This is what makes the "magic" happen. Notice that `lazy-seq`
    wraps the entire body of the function.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lazy-seq` 的使用。这就是“魔法”发生的地方。注意，`lazy-seq` 包装了函数的整个主体。'
- en: The use of `cons`. The name of the `cons` function goes back to Lisp, which
    is much, much older than Clojure. `cons` is a function that connects two things.
    In most Lisp dialects, a list is constructed by using `cons` to connect an item
    to the rest of the list. Using `cons` here means that we are returning a list
    like this.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cons` 的使用。`cons` 函数的名字可以追溯到 Lisp，它比 Clojure 要古老得多。`cons` 是一个连接两个东西的函数。在大多数
    Lisp 方言中，列表是通过使用 `cons` 将一个项目连接到列表的其余部分来构建的。在这里使用 `cons` 意味着我们在返回一个这样的列表。'
- en: The use of recursion. Without `lazy-seq`, this recursive call would execute
    immediately, and continuously, until the stack blew up. With `lazy-seq`, the next
    call does not happen; instead, a reference to that future call is returned.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归的使用。没有 `lazy-seq`，这个递归调用将立即执行，并且持续执行，直到栈溢出。有了 `lazy-seq`，下一个调用不会发生；相反，返回了对那个未来调用的引用。
- en: 'The structure of the function mirrors the data structure that it produces:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的结构反映了它产生的数据结构：
- en: '![Figure 7.1: Structure of functions'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1：函数结构'
- en: '](img/B14502_07_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_07_01.jpg]'
- en: 'Figure 7.1: Structure of functions'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：函数结构
- en: Thanks to `lazy-seq`, the recursive call becomes a reference.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `lazy-seq`，递归调用变成了引用。
- en: On the left, we have the real part; on the right, the virtual part. As the sequence
    is consumed, more and more virtual calls to `our-range` become real. The reference
    to further virtual calls remains at the end of the list, ready when more integers
    are needed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有实部；在右侧，有虚部。随着序列的消耗，越来越多的对 `our-range` 的虚拟调用变成了实际调用。对进一步虚拟调用的引用保持在列表的末尾，以便在需要更多整数时准备就绪。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The future, unrealized calculation is often called a `thunk`. The word makes
    it sound like something that has already been thought, but it is something that
    hasn't been "`thunk`" yet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 未来尚未实现的计算通常被称为 `thunk`。这个词听起来像已经思考过的事情，但实际上是尚未被 "`thunk`" 的事情。
- en: This is just about the simplest possible version of a lazy sequence, but it
    is enough to provide an idea of the basic pattern that we will continue to expand
    upon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是懒序列最简单可能的版本，但它足以提供一个基本模式的概念，我们将在此基础上继续扩展。
- en: Consuming a Sequence
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消耗序列
- en: An iterative sequence such as `our-range` takes a single input and builds a
    sequence by calling a function on the input, then on the result of the first function
    call, then on the result of that call, and so on. While this kind of computation
    can be useful sometimes, more often than not our code needs to accept incoming
    data of some kind.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `our-range` 这样的迭代序列接受单个输入，并通过在输入上调用一个函数来构建序列，然后是第一个函数调用的结果，然后是那个调用的结果，依此类推。虽然这种计算有时可能很有用，但更常见的是我们的代码需要接受某种类型传入的数据。
- en: The pattern for doing this is a blend of the iterative style of lazy sequence
    and the recursive functions from the previous chapter. As with other forms of
    recursion, these functions will be built around conditionals, `if` or `cond` usually,
    and they will advance through the input sequence by working on the first item
    and then calling themselves again on the rest of the input. And like `our-range`,
    they will generally build their output with `cons`, attaching the current item
    onto a list that points to future possible calculations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种模式的组合了懒序列的迭代风格和前一章中的递归函数。与其他形式的递归一样，这些函数将围绕条件构建，通常是 `if` 或 `cond`，并通过处理输入序列的第一个项目并在其余输入上再次调用自己来前进。并且像
    `our-range` 一样，它们通常使用 `cons` 构建输出，将当前项目附加到一个指向未来可能计算的列表上。
- en: 'Exercise 7.01: Finding Inflection Points'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.01：寻找拐点
- en: In this exercise, we are building a tool to analyze data from users' GPS watches.
    Runners and hikers want to know how much of the time they are going uphill or
    downhill. The incoming data is a potentially endless sequence of tuples containing
    an elevation in meters, and a timestamp, the number of milliseconds since the
    user started their exercise.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们正在构建一个分析用户GPS手表数据的工具。跑步者和徒步旅行者想知道他们在上山或下山时花费了多少时间。传入的数据是一个可能无限长的元组序列，包含海拔（以米为单位）和时间戳，即用户开始锻炼以来的毫秒数。
- en: 'Each tuple looks as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元组看起来如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to iterate through the input sequence looking for local peaks or valleys,
    that is, the points where the elevation is greater than the preceding and following
    points (peak), or less than the preceding and following points (valley). We could
    use `reduce` instead, as we did for the bicycle race problem in *Chapter 5*, *Many
    to One: Reducing*. However, the input stream might be very, very long, so we don''t
    want to force evaluation, which is what would happen with `reduce`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遍历输入序列，寻找局部峰值或谷值，即海拔高于前后点的点（峰值），或低于前后点的点（谷值）。我们本可以使用 `reduce` 来代替，就像我们在第
    5 章 *多对一：归约* 中为自行车比赛问题所做的那样。然而，输入流可能非常非常长，所以我们不想强制评估，这就是使用 `reduce` 会发生的事情。
- en: 'Define some sample data in the required format. You can find this var at [https://packt.live/2Rhcbu6](https://packt.live/2Rhcbu6):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些符合要求格式的样本数据。您可以在[https://packt.live/2Rhcbu6](https://packt.live/2Rhcbu6)找到这个变量：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A peak or a valley can be detected by comparing three consecutive items. Write
    a predicate for detecting peaks or valleys.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过比较三个连续的项目可以检测到峰值或谷值。编写一个用于检测峰值或谷值的谓词。
- en: 'As we move through the list of elevation-time tuples, we will look at the current
    item and the next two items in order to identify peaks and valleys. In a sub-sequence
    of three items, if the middle item is greater than the first and the last, it''s
    a peak; if it is less than both, it is a valley. In all other cases, the middle
    item is neither a peak nor a valley. We''ll write two functions, `local-max?`
    and `local-min?`, which will translate this logic into functions:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们遍历海拔-时间元组的列表时，我们将查看当前项和接下来的两个项目，以识别峰值和山谷。在三个项目的子序列中，如果中间项大于第一个和最后一个，它是一个峰值；如果它小于两者，它是一个山谷。在其他所有情况下，中间项既不是峰值也不是山谷。我们将编写两个函数，`local-max?`和`local-min?`，将这个逻辑转换为函数：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we wanted to clean up our code with some destructuring, we could avoid all
    those `first` calls. The functions would take a single, three-item list. Each
    item is a two-item tuple. With two levels of destructuring, we can extract the
    elements we need without calling any functions:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想要通过一些解构来清理我们的代码，我们可以避免所有那些`first`调用。函数将接受一个包含三个项目的单列表。每个项目是一个包含两个项目的元组。通过两层解构，我们可以提取所需的元素而不调用任何函数：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we move forward by two items in `sample-data`, we find a valley. The third,
    fourth, and fifth items are `[25.9 589014]`, `[23.8 691995]`, and `[24.7 734902]`.
    The middle value is less than the first and last:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们在`sample-data`中向前移动两个项目，我们会发现一个山谷。第三个、第四个和第五个项目是`[25.9 589014]`、`[23.8 691995]`和`[24.7
    734902]`。中间的值小于第一个和最后一个：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Outline the recursive function. As we discussed, our function will have the
    same basic shape as most of the recursive functions we've seen so far. For our
    conditional, there are four cases we need to deal with. Before that, though, we
    must create a local binding to `current-series`, which will be the first three
    items in `data`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 概述递归函数。正如我们讨论的那样，我们的函数将与迄今为止我们看到的大多数递归函数具有相同的基本形状。对于我们的条件，我们需要处理四种情况。在此之前，我们必须创建一个对`current-series`的局部绑定，它将是`data`中的前三个项目。
- en: 'Since we are just laying out the function, we will return different keywords
    instead of real values for the moment:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们只是在布局函数，所以我们目前将返回不同的关键字而不是真实值：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the first test in the `cond` expression, we check to see whether we''ve
    run out of data, which we can do by checking the length of `current-series`. If
    `current-series` does not contain three items, then we know that we''ll never
    find a peak or a valley, so it''s time to stop. As usual, we place this condition
    first so that in the subsequent tests we can be sure to have at least some data.
    The next two tests use the predicates we defined earlier: `local-max?` and `local-min?`.
    In these cases, we will add the current value to the accumulated `data`. The last
    possibility is that the current item is neither a minimum nor a maximum. In this
    case, we aren''t interested in that particular item, so we will continue without
    placing it in the accumulated data.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`cond`表达式的第一个测试中，我们检查是否已经没有数据了，这可以通过检查`current-series`的长度来完成。如果`current-series`不包含三个项目，那么我们知道我们永远不会找到峰值或山谷，所以是时候停止了。像往常一样，我们首先放置这个条件，这样在随后的测试中我们可以确保至少有一些数据。接下来的两个测试使用我们之前定义的谓词：`local-max?`和`local-min?`。在这些情况下，我们将当前值添加到累积的`data`中。最后一种可能性是当前项既不是最小值也不是最大值。在这种情况下，我们对那个特定的项不感兴趣，所以我们将继续而不将其放入累积数据中。
- en: 'Now we can start deciding what will happen in each of these four cases. The
    first case, when we''ve run out of data, is the simplest, but perhaps the most
    surprising as well. Here, we just return an empty list:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始决定这四种情况中的每一种会发生什么。第一种情况，当我们没有数据时，是最简单的，但也许也是最令人惊讶的。在这里，我们只是返回一个空列表：
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With `recur` based recursion, this wouldn''t make any sense: returning an empty
    list on reaching the end of the input data would mean that the function always
    returns… an empty list. Not very useful, really.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于`recur`递归，这样做是没有意义的：在输入数据结束时返回一个空列表意味着该函数总是返回…一个空列表。实际上并不太有用。
- en: With a lazy sequence, however, this last item is simply the end of the list
    that will be returned. In many cases, the entire list will not be consumed, and
    the end of the input sequence will never be reached. If we think of a lazy sequence
    as a series of pointers toward potential calculations, the empty list here is
    simply the result of the very last potential calculation.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，对于惰性序列，最后一个项目仅仅是将要返回的列表的结尾。在许多情况下，整个列表不会被消耗，输入序列的结尾也永远不会到达。如果我们把惰性序列看作是一系列指向潜在计算的指针，那么这里的空列表仅仅是最后一次潜在计算的结果。
- en: It is also important that this be an empty list, and not, for example, an empty
    vector. Vectors are do not support laziness.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是，这应该是一个空列表，而不是，例如，一个空向量。向量不支持惰性。
- en: The next two cases are where `local-max?` or `local-min?` have decided that
    the second item in `current-series` is indeed a peak or a valley. When that happens,
    we need to do two things. First, we need to mark the tuple as either a peak or
    a valley by appending the appropriate keyword; secondly, we need to make sure
    that the tuple becomes part of the output sequence.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下两个情况是当`local-max?`或`local-min?`决定`current-series`中的第二个项目确实是一个峰值或谷值时。当这种情况发生时，我们需要做两件事。首先，我们需要通过添加适当的关键字将元组标记为峰值或谷值；其次，我们需要确保这个元组成为输出序列的一部分。
- en: 'Appending the keyword is easy:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加关键字很简单：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since each item is a two-value tuple, `conj` will make it into a three-value
    tuple:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于每个项都是一个包含两个值的元组，`conj`会将其转换为包含三个值的元组：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'When using `conj`, always be careful of what type of sequence you are using.
    When called on a vector, `conj` will append the new item to the end of the vector.
    When called on a list, it will append to the beginning. This may seem surprising,
    but there is a reason: `conj` always adds the new item in the most efficient way
    possible, depending on the data structure used. For vectors, this means adding
    to the end; for lists, this means adding to the beginning.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用`conj`时，总是要小心你正在使用什么类型的序列。当对一个向量调用时，`conj`会将新项追加到向量的末尾。当对一个列表调用时，它将追加到开头。这可能会让人惊讶，但有一个原因：`conj`总是以最有效的方式添加新项，这取决于所使用的数据结构。对于向量来说，这意味着添加到末尾；对于列表来说，这意味着添加到开头。
- en: 'Next, we need to incorporate this new value into the sequence that will be
    returned. Rather than placing it in an accumulator of some kind, as we might if
    we were using `recur`, the current item becomes the head of the list of all the
    remaining items to be calculated. This is what the `cons` function does. And that
    "list of all the remaining items to be calculated" is represented here as the
    recursive call to `inflection-points`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将这个新值纳入将要返回的序列中。而不是像使用`recur`时那样将其放置在某种累加器中，当前项变成了所有剩余待计算项的列表的头部。这正是`cons`函数所做的事情。而“所有剩余待计算项的列表”在这里是通过递归调用`inflection-points`来表示的：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Think of it this way. To the right, you have all the remaining items. The call
    to `inflection-points` is going to return them, eventually, or at least potentially.
    The current item, like we said, is the head of that list. To the left, there are
    the items that have already been calculated. The last one of those, just to the
    left of the current item, is going to be the head of a list where the second item
    is the current item. And so on, all the way to the start of the list. An item
    is linked to the right by calling a function, and to the left because a function
    is being called on it.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样想吧。在右边，你看到了所有剩余的项。`inflection-points`的调用最终会返回它们，至少是潜在地。正如我们所说的，当前项是这个列表的头部。在左边，是已经计算过的项。就在当前项左侧的那个，将成为一个列表的头部，其中第二个项是当前项。以此类推，直到列表的起始位置。一个项通过调用一个函数与右边链接，而与左边链接是因为对该项调用了函数。
- en: Note
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Recursion can be hard to grasp. Don't worry! It will get easier with practice.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 递归可能难以理解。不用担心！随着练习，它会变得更容易。
- en: When using `recur`, we tend to place the results in an argument to the next
    call to the recursive function. And we will be doing that with the `current-series`
    parameter. Because this function will return a lazy sequence, we'll use `cons`
    and place the current item in front of the potential result set. Each call to
    the function returns part of a list that the parent call can integrate into what
    it returns.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用`recur`时，我们倾向于将结果放置在递归函数下一次调用的参数中。我们将对`current-series`参数这样做。因为这个函数将返回一个惰性序列，我们将使用`cons`并将当前项放在潜在的结果集的前面。每次函数调用都返回列表的一部分，父调用可以将这部分整合到它返回的内容中。
- en: 'The last condition is the least interesting: ignore the current item and move
    on to the next. We do this in the now-familiar way of removing one item from data
    in the next recursive call to `inflection-points`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个条件是最不有趣的：忽略当前项并继续到下一个。我们以现在熟悉的方式在`inflection-points`的下一个递归调用中从数据中移除一个项来做这件事：
- en: '[PRE14]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here''s the complete function:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是完整的函数：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Test the function using the `sample-data` var we defined at the beginning:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在开头定义的`sample-data`变量测试函数：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use Clojure''s `cycle` function to transform `sample-data` into a circuit that
    our jogger runs over and over again:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Clojure的`cycle`函数将`sample-data`转换成一个我们的慢跑者反复跑过的电路：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`cycle` returns a lazy sequence that repeats a `seq` forever.'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cycle`返回一个无限重复`seq`的惰性序列。'
- en: This exercise introduced the fundamental structure that you will find in most
    functions that produce lazy sequences. Making the current the head of the list
    of future calculations by using `cons` it onto the next recursive call is lazy
    sequence recursion in a nutshell. The surrounding code may become more complex
    as we move forward, but this operation will be the building block of all the lazy
    sequence-producing functions that we write.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习介绍了你将在大多数生成惰性序列的函数中找到的基本结构。通过使用`cons`将其添加到下一个递归调用中，使当前成为未来计算列表的头部，这就是惰性序列递归的精髓。随着我们向前推进，周围的代码可能会变得更加复杂，但这个操作将是所有我们将要编写的生成惰性序列函数的构建块。
- en: 'Exercise 7.02: Calculating a Running Average'
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.02：计算移动平均值
- en: To put this into practice, let's imagine a scenario similar to the grocery conveyor
    belt in the previous chapter. This time, though, we're doing quality control on
    the potatoes that are delivered to our mega-store. The potatoes are weighed as
    they pass a gate. We want to keep accepting potatoes as long as the average stays
    within certain bounds. It's all right to have a few small potatoes, or a few huge
    ones, as long as most of them are within the limits. If the average gets too high
    or too low, then something must be wrong, so we'll stop accepting potatoes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此付诸实践，让我们想象一个与上一章中提到的杂货传送带类似的场景。不过这次，我们正在对我们超级商店接收到的土豆进行质量控制。土豆在通过一个门时被称重。只要平均值保持在一定的范围内，我们就可以继续接收土豆。即使有一些小的土豆或几个大的土豆，只要大多数土豆都在限制范围内就可以。如果平均值过高或过低，那么肯定出了问题，因此我们将停止接收土豆。
- en: Start up a fresh REPL.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的REPL。
- en: 'First, we need to simulate a potato source. We need to define a randomized
    potato-generating function. We''ll use the same technique for producing an infinite
    sequence of random values as we did for the grocery store, using `repeatedly`
    and `rand-int`. In this version, we add `10`, which will act as an extreme minimum
    potato size. This way our generator will produce potatoes between `10` and `400`
    grams:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要模拟一个土豆来源。我们需要定义一个随机土豆生成函数。我们将使用与杂货店相同的技术来生成无限序列的随机值，使用`repeatedly`和`rand-int`。在这个版本中，我们添加了`10`，这将作为极端最小土豆尺寸。这样我们的生成器将产生`10`到`400`克的土豆：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Test this lazy sequence with `take`. You will naturally get different random
    numbers:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`take`测试这个惰性序列。你将自然得到不同的随机数：
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how the first five elements are the same both times. Those items have
    been realized. New potato generation will only occur when more items are computed
    further along in the sequence.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到两次的前五个元素都是相同的。这些项目已经被实现。新的土豆生成只会在序列中更远的地方计算更多项目时发生。
- en: 'Now we arrive at our first design challenge. We need a way of representing
    the current average for each item in the list. Beyond just the weight of the current
    potato, we need the potato count at that point in the sequence and the accumulated
    weight so far. We could use a three-item tuple to hold those three values. If
    the fifth potato in the list weighs `200` grams, and the total weight of the first
    five potatoes was `784`, that potato could be represented like this:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们来到了第一个设计挑战。我们需要一种方式来表示列表中每个项目的当前平均值。除了当前土豆的重量外，我们还需要该点在序列中的土豆数量以及到目前为止的总重量。我们可以使用一个包含三个值的元组来保存这三个值。如果列表中的第五个土豆重量为`200`克，而前五个土豆的总重量为`784`克，那么这个土豆可以这样表示：
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since we have the item count and the total, this design allows us to easily
    calculate the average at any point in the sequence.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们有了项目数量和总数，这种设计使我们能够轻松地在序列中的任何一点计算平均值。
- en: 'To find the average after three items, we would take three items from the sequence,
    if our function returns something like this:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到三个项目后的平均值，我们会从序列中取出三个项目，如果我们的函数返回如下所示：
- en: '[PRE21]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Dividing `551`, the total weight so far, by `3`, the number of potatoes, would
    give us the current average, which is `179.33333` in this case.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将到目前为止的总重量`551`除以土豆数量`3`，将给出当前的平均值，在这个例子中是`179.33333`。
- en: 'We have our design, but we still need to implement it. Let''s go through our
    options for selecting a sequence-handling technique. `map` won''t work here because
    we need to accumulate data. The `map` windowing pattern from *Chapter 4*, *Mapping
    and Filtering*, sounds like it might do the job, but it cannot accumulate data
    from one end of the sequence. The "window" is local to a few list items. So then
    maybe `reduce` is the answer? Unfortunately, `reduce` is not lazy: the entire
    sequence would be realized immediately. In some cases that would be acceptable,
    but in this case we don''t know how long the input will be.'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经有了设计，但还需要实现它。让我们来看看选择序列处理技术的选项。`map`在这里不可用，因为我们需要累积数据。《第4章》中提到的`map`窗口模式听起来可能可以完成这项工作，但它不能从序列的一端累积数据。“窗口”仅限于几个列表项。那么也许`reduce`是答案？不幸的是，`reduce`不是惰性的：整个序列会立即实现。在某些情况下这可能可以接受，但在这个情况下我们不知道输入会有多长。
- en: 'That leaves us with recursion. We can''t use `recur` for the same reason we
    can''t use `reduce`: we might be processing a nearly infinite stream. That also
    means that standard recursion without `recur` will blow the stack well before
    we get through our first ton of potatoes. Therefore, we''ll use `lazy-seq` to
    produce different computations.'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就留下了递归。我们不能使用`recur`，原因和不能使用`reduce`一样：我们可能正在处理一个几乎无限的流。这也意味着没有`recur`的标准递归会在我们处理完第一吨土豆之前就崩溃。因此，我们将使用`lazy-seq`来产生不同的计算。
- en: 'Start with a skeleton for a function that returns a lazy sequence, using the
    `lazy-seq` macro to wrap the contents of the recursive function:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个返回惰性序列的函数骨架开始，使用`lazy-seq`宏来包装递归函数的内容：
- en: '[PRE22]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `prev` parameter will start as an empty vector. We will use it to pass the
    current total on to the next calculation.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`prev`参数将开始为一个空向量。我们将使用它将当前总重量传递给下一次计算。'
- en: 'Fill in the contents of the recursive function using the patterns learned in
    the previous chapter, starting with the conditional that stop the recursion when
    we''ve exhausted the input. Unlike functions that are designed to continue infinitely,
    such as `range`, `average-potatoes` only continues as long as it has input, so
    we do need to check if there is anything left:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一章学到的模式填写递归函数的内容，从停止递归的条件开始，即当输入被耗尽时。与设计为无限继续的函数不同，例如`range`和`average-potatoes`，只有当它还有输入时才会继续，因此我们需要检查是否还有剩余的内容：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we see the same pattern as in the previous exercise. When we reach the
    end of the list, we return an empty list.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们看到与上一个练习相同的模式。当我们到达列表的末尾时，我们返回一个空列表。
- en: Note
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: It would be possible to return `nil` here instead because `cons` treats `nil`
    here just like the empty list. Try `(cons 5 nil)` in your REPL. The empty list
    does a better job of telling us what is happening here.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里也可以返回`nil`，因为`cons`在这里将`nil`视为空列表。试着在你的REPL中运行`(cons 5 nil)`。空列表在这里更好地告诉我们发生了什么。
- en: 'Calculate the current item before performing the recursion. We''ll use a `let`
    binding here because we need the current item twice: once as an item in the list,
    and once as the `prev` argument that will be the basis for calculating the total
    weight when we get the next potato:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行递归之前计算当前项。在这里我们将使用`let`绑定，因为我们需要当前项两次：一次作为列表中的一个项，另一次作为`prev`参数，这将是我们计算下一个土豆总重量的基础：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first part of the `let` binding uses some destructuring to get the current
    count and the total so far from the `prev` argument. We don't need the weight
    of the previous potato since it is already included in the running total, which
    is why we've used an underscore for that value.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let`绑定的第一部分使用了一些解构来从`prev`参数中获取当前的计数和到目前为止的总数。我们不需要前一个土豆的重量，因为它已经包含在运行总和中，这就是为什么我们为那个值使用了下划线。'
- en: With the next binding, we build the actual tuple that will become an item in
    the sequence. The only complexity here is that `n` and `total` might be nil, so
    we have to check for that and supply `0` if they are. The first item in the tuple
    is just the weight of the current potato; the second item is the count we'll use
    calculating the average; the last is the total weight of all the potatoes counted
    so far.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过下一个绑定，我们构建实际的元组，它将成为序列中的一个项。这里的唯一复杂性是`n`和`total`可能为`nil`，因此我们必须检查这一点，并在它们为`nil`时提供`0`。元组的第一个项只是当前土豆的重量；第二个项是我们将用于计算平均值的计数；最后一个项是到目前为止所有土豆的总重量。
- en: 'Add the recursive logic:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加递归逻辑：
- en: '[PRE25]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All we've done in this last step is attach the current item to the list that
    will be created by the subsequent recursive calls to `average-potatoes`. We've
    supplied `current` as the `prev` argument for the next call.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后一步中，我们只是将当前项目附加到由后续对 `average-potatoes` 的递归调用创建的列表中。我们将 `current` 作为 `prev`
    参数传递给下一次调用。
- en: 'Note also that we use `next` instead of `rest`: this way, arrivals will be
    `nil` when we get to the end of the sequence, which is what we are expecting when
    we test with `if-not` at the beginning of this function. The `next` function is
    very similar to `rest`, which we used in the previous example. Both functions
    take a list and return all but the first item of that list. The difference between
    the two is visible when there are no more items in the list. In that case, `rest`
    returns an empty list, while `next` returns `nil`. Choosing one or the other depends
    on the circumstances. The advantage of `next` is that it is easy to test for truthiness
    as we did here, instead of calling `empty?` as we did with `rest` in the previous
    exercise. Because `rest` never returns `nil`, there is no risk of a null pointer
    exception.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还要注意，我们使用 `next` 而不是 `rest`：这样，当我们到达序列的末尾时，到达将是 `nil`，这正是我们在函数开头使用 `if-not`
    测试时所期望的。`next` 函数与我们在前一个例子中使用的 `rest` 非常相似。两个函数都接受一个列表，并返回该列表除了第一个项目之外的所有项目。当列表中没有更多项目时，这两个函数之间的区别是显而易见的。在这种情况下，`rest`
    返回一个空列表，而 `next` 返回 `nil`。选择哪一个取决于情况。`next` 的优点是，它很容易测试真值，就像我们在这里做的那样，而不是像我们在上一个练习中使用
    `rest` 那样调用 `empty?`。因为 `rest` 永远不会返回 `nil`，所以没有空指针异常的风险。
- en: 'Test your new lazy function. Let''s start by looking at a few individual items:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试您的新惰性函数。让我们先看看几个单独的项目：
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The third element of each tuple correctly indicates the accumulated weight.
    That part seems correct.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个元组的第三个元素正确地指示了累积的权重。这部分看起来是正确的。
- en: 'Now let''s try working with a large number of items. We''ll take the last element
    from a long list of potatoes:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们尝试处理大量项目。我们将从长长的土豆列表中取出最后一个元素：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At `500,000` potatoes, everything seems to still be working as expected.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `500,000` 个土豆的情况下，一切似乎仍然按预期工作。
- en: 'In this example, it''s important to note the difference between the preceding
    examples of lazy evaluation using `rand-int` and `inc`. With `rand-int`, each
    call is independent of all the other calls. Lazy evaluation is only useful here
    because it''s useful to have a potentially infinite sequence. With `inc`, when
    we implemented our version of `range`, the situation is slightly more complex
    because each call, and thus each item in the sequence, relies on the results of
    the call before. This is also true of the `average-potatoes` function: each call
    relies on the total and the count established in the previous call, and it relays
    this information onto the next call. At the same time, it does something more,
    because each calculation also consumes an item from the input sequence.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，重要的是要注意使用 `rand-int` 和 `inc` 进行惰性评估的前一个例子之间的区别。使用 `rand-int` 时，每次调用都是相互独立的。惰性评估在这里之所以有用，是因为它允许有一个可能无限长的序列。使用
    `inc` 时，当我们实现我们的 `range` 版本时，情况稍微复杂一些，因为每次调用以及序列中的每个项目都依赖于前一次调用的结果。这也适用于 `average-potatoes`
    函数：每次调用都依赖于前一次调用中建立的总量和计数，并将此信息传递给下一次调用。同时，它还做了更多的事情，因为每次计算也会消耗输入序列中的一个项目。
- en: 'The core `map` and `filter` functions do this as well: their results are no
    longer than their inputs. This adds one more reason to use write functions that
    consume and produce lazy sequences: they can be chained together with other lazy
    functions without forcing evaluation.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 核心的 `map` 和 `filter` 函数也这样做：它们的输出长度不超过它们的输入。这又增加了一个使用消耗和产生惰性序列的写函数的理由：它们可以与其他惰性函数一起链接，而无需强制评估。
- en: Lazy Consumption of Data
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性消耗数据
- en: Lazy evaluation is an interface that, most of the time, hides from the user
    whether a calculation has already been performed, or is about to be performed.
    This is what it means when we say that a lazy sequence contains possibly differed
    computations. "Possibly," because we don't know, and we don't need to know, whether
    or not the computation has already happened.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估是一个接口，它大多数时候都隐藏了用户是否已经执行了计算，或者即将执行计算。这就是我们说惰性序列包含可能延迟的计算的含义。“可能”是因为我们不知道，也不需要知道计算是否已经发生。
- en: To be useful though, lazy evaluation has to be passed from one function call
    to the next. If we pass a lazy sequence to function A, and the result of that
    to function B, and so on, the evaluation only remains lazy if A and B are designed
    to return lazy sequences.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要变得有用，延迟评估必须从一次函数调用传递到下一次。如果我们将一个延迟序列传递给函数 A，然后将结果传递给函数 B，依此类推，只有当 A 和 B
    被设计为返回延迟序列时，评估才会保持延迟。
- en: For example, say we have a lazy sequence called `xs`. If it gets passed to `map`,
    then to `filter`, and then to `take-while`, it will remain "lazy" the whole time.
    If instead we insert a `reduce` into that chain of function calls, or if we use
    `mapv` instead of `map`, the laziness disappears.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个名为 `xs` 的延迟序列。如果它被传递给 `map`，然后是 `filter`，然后是 `take-while`，它将始终保持“延迟”状态。如果我们在这个函数调用链中插入一个
    `reduce`，或者如果我们使用 `mapv` 而不是 `map`，延迟性就会消失。
- en: 'In the end, potential evaluation isn''t enough. You do actually want some real
    data at some point! However, there is generally an advantage in preserving laziness
    until the very end. That means avoiding something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，潜在的评估并不足够。你确实需要在某个时候得到一些实际数据！然而，通常在最后保留延迟性是有利的。这意味着避免像这样的事情：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we take some a sequence and use `map` to apply a function to each item.
    The call to `map` is lazy but the call to `reduce` is not, so the entire sequence
    is realized. Then some of those results are discarded by `filter`. Depending on
    what the functions are doing, this may be the only way to write this code. However,
    ideally, we would try to use `filter` first to narrow the data as much as possible
    before calling `reduce`, or any other function that does not preserve laziness:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们取一个序列并使用 `map` 将一个函数应用于每个项。`map` 的调用是延迟的，但 `reduce` 的调用不是，所以整个序列被实现。然后，`filter`
    会丢弃一些结果。根据函数执行的操作，这可能是有可能编写此代码的唯一方法。然而，理想情况下，我们会在调用 `reduce` 或任何其他不保留延迟性的函数之前，尽可能使用
    `filter` 来缩小数据。
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first advantage with this pattern is that your code becomes simpler. `filter`
    and `take-while` may have removed some types of data that the `reduce` call will
    not need to deal with at all. By waiting until the very last minute before forcing
    the sequence to be completely realized, there may actually be less computational
    work to do.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的第一个优点是代码变得更简单。`filter` 和 `take-while` 可能已经移除了一些 `reduce` 调用根本不需要处理的数据类型。通过等到最后一刻才强制序列完全实现，实际上可能需要做的计算工作更少。
- en: 'To see how this might work, let''s look at this simple expression:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这可能如何工作，让我们看看这个简单的表达式：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The evaluation starts with `(range)`, which, if `range` were not lazy, would
    return all the integers from zero to infinity. In other words, CPU usage would
    go to 100% and evaluation would stop when something broke.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 评估从 `(range)` 开始，如果 `range` 不是延迟的，它将返回从零到无穷大的所有整数。换句话说，CPU 使用率会达到 100%，评估会在出现错误时停止。
- en: 'Instead of that horrible outcome, though, we can imagine the return value of
    `(range)` as looking something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们可以想象 `(range)` 的返回值看起来像这样：
- en: '![Figure 7.2: Representation of range value'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2：范围值的表示](img/B14502_07_02.jpg)'
- en: '](img/B14502_07_02.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_07_02.jpg](img/B14502_07_02.jpg)'
- en: 'Figure 7.2: Representation of range value'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：范围值的表示
- en: 'An unrealized lazy sequence: a starting point and a pointer to future calculations.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未实现的延迟序列：一个起点和一个指向未来计算的指针。
- en: This is a lot less work than counting from zero to infinity. It's essentially
    `0` and a pointer toward instructions for calculating the rest of the sequence,
    if necessary.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这比从零计数到无穷大要少得多的工作。本质上是一个指向计算序列其余部分的指令的指针，如果需要的话。
- en: 'However, we don''t want all the integers, just the even ones:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不需要所有的整数，只需要偶数：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With this call to `filter`, we''ve created a second lazy sequence built upon
    the first:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个 `filter` 调用，我们创建了一个基于第一个的第二个延迟序列：
- en: '![Figure 7.3: Creating the second lazy sequence'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3：创建第二个延迟序列](img/B14502_07_03.jpg)'
- en: '](img/B14502_07_03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_07_03.jpg](img/B14502_07_03.jpg)'
- en: 'Figure 7.3: Creating the second lazy sequence'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：创建第二个延迟序列
- en: By adding `filter`, we've created a new lazy sequence that still only has one
    real piece of data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `filter`，我们创建了一个新的延迟序列，它仍然只包含一个实际的数据项。
- en: The only concrete data we have so far is still zero. All we've done is add to
    the instructions for getting the rest of the sequence. Everything is still virtual
    at this point.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前拥有的唯一具体数据仍然是零。我们所做的只是增加了获取序列其余部分的指令。到目前为止，一切都是虚拟的。
- en: 'And then, finally, we call `nth` and ask for the fourth item in the sequence:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后，我们调用 `nth` 并请求序列中的第四个项：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now everything changes. We need the real values of the first four items. `nth`
    causes the first four items of the `filter` sequence to be evaluated. To do this,
    `filter` needs the first seven items of the `range` sequence to be evaluated.
    Suddenly, `(range)` looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Current values in the range'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_04.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Current values in the range'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The first seven items are realized. The rest of the sequence is still virtual.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'And `(filter even? (range))` looks as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Filtering even numbers from the range'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_05.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Filtering even numbers from the range'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The fourth value in the list can now be consumed just like any other value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The important thing to understand here is this: the last element in each of
    these sequences is a pointer to further potential calculations. `filter` and `range`
    worked together to provide just enough data to `nth`, and no more. By passing
    pointers (or "instructions for future computations") from function to function,
    the ultimate consumer can send a signal back up the chain, from pointer to pointer,
    to obtain the necessary data.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Lazy sequences in Clojure are actually implemented as **chunked sequences**.
    This is an implementation detail: as an optimization, Clojure sometimes realizes
    a few more items than are actually necessary. While this is good to know, it should
    never matter. It just means that you can''t count on an item *not* being realized.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The capacity to avoid performing certain calculations until the last millisecond,
    or to avoid them entirely, is an important feature of lazy computation. There
    is another aspect that can be equally important: the ability to "forget" some
    of the calculations that have already been performed.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Consider a non-lazy Clojure collection, such as a vector. Whatever size the
    vector is, the entire vector is available in memory at the same time. When the
    program no longer needs the vector, the platform on which the program is running,
    the JVM or a JavaScript engine, has a garbage collector that will free up the
    memory occupied by the vector. But if the program still needs even just one item
    from that vector, the garbage collector will keep waiting until it can safely
    reclaim that memory space.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: A lazy sequence behaves in a totally different manner. Instead of being a single
    entity, it is a series of linked entities, each one referring to the next. As
    we've seen, this is how a lazy sequence can even reference items that don't exist
    yet, and maybe never will. There is another important part of the equation, though.
    Lazy sequences also the first part of the sequence to be garbage collected if
    it is no longer needed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: In the last example, we were looking for the fourth even number in the range.
    Instead, what if we were looking for the seven millionth even number?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is no reason, in this situation, to keep a reference to those first 13,999,999
    integers that were produced by `(range)`. That means that they can be safely garbage
    collected.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有必要保留对由`(range)`产生的最初13,999,999个整数的引用。这意味着它们可以被安全地垃圾回收。
- en: This feature of lazy sequences means that they can be used to process datasets
    that would be too big to fit in the computer's memory all at once. By "forgetting"
    the first part and not immediately computing the last part, Clojure can process
    extremely long sequences while using only a fraction of the memory it would take
    to contain them all at once. There is, however, a limitation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 懒序列的这个特性意味着它们可以用来处理那些一次性无法全部装入计算机内存的数据集。通过“忘记”第一部分并且不立即计算最后一部分，Clojure 可以处理极其长的序列，同时只使用包含它们所需内存的一小部分。然而，这里有一个限制。
- en: If a program maintains a reference to the beginning of a sequence, then it can
    no longer be garbage collected. Often, this won't matter, but with very long sequences,
    it becomes an important consideration. Throughout this chapter, you may notice
    that we often repeat expressions such as `(first my-seq)` inside a function when
    it might be tempting to use a local `let` binding instead. This is a way of avoiding
    references that would prevent a sequence from being garbage collected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序保持对序列开头的引用，那么它就不再可以被垃圾回收。通常情况下，这不会有什么影响，但面对非常长的序列时，这成为一个重要的考虑因素。在整个章节中，你可能注意到我们经常在函数内部重复使用像`(first
    my-seq)`这样的表达式，尽管使用局部的`let`绑定可能更有诱惑力。这是避免阻止序列被垃圾回收的引用的一种方法。
- en: Lazy Trees
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒树
- en: So far, we've seen that the "laziness" of lazy sequences is that they can point
    to future computations that will only be performed if they become necessary. There
    is another important advantage that is equally important, and that is what we
    are going to explore now. Remember from *Chapter 6*, *Recursion and Looping*,
    how recursive functions in Clojure need to use `recur` to avoid blowing up the
    stack? And remember how `recur` only works with a specific kind of recursion,
    tail recursion, where the next call to the recursive function can totally replace
    the previous call? The problem, you'll recall, is that only a limited number of
    stack frames are available. The function call on the root node of the tree needs
    to wait until all the calls have completed on all the child and grandchild and
    great-grandchild nodes, and so on. Stack frames are a limited resource but the
    data we need to operate on is often vast. This mismatch is a problem.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到懒序列的“懒”特性是它们可以指向未来的计算，这些计算只有在必要时才会执行。还有一个同样重要的优点，我们现在将要探讨。记得在*第6章*，*递归和循环*中，Clojure中的递归函数需要使用`recur`来避免栈溢出吗？还记得`recur`只与特定类型的递归一起工作，即尾递归，其中下一个对递归函数的调用可以完全替换上一个调用吗？问题，你可能会记得，是只有有限的栈帧可用。树根节点的函数调用需要等待所有对子节点、孙节点、曾孙节点等的调用都完成。栈帧是一种有限的资源，但我们需要操作的数据通常非常庞大。这种不匹配是一个问题。
- en: This is where lazy evaluation comes in. With lazy evaluation, Clojure itself
    handles the link to the next calculation, not the call stack. This way, when we
    use a recursive function to walk an entire tree, we are no longer trying to use
    the stack to map the structure of the tree. Instead, the lazy sequence itself
    does all the work of keeping track of which results need to be returned to which
    functions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是懒评估发挥作用的地方。使用懒评估，Clojure 本身处理下一个计算的链接，而不是调用栈。这样，当我们使用递归函数遍历整个树时，我们不再试图使用栈来映射树的结构。相反，懒序列本身完成所有跟踪哪些结果需要返回给哪些函数的工作。
- en: 'Exercise 7.03: A Tennis History Tree'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.03：网球历史树
- en: 'In this exercise, we return to the world of tennis. As you remember, in *Chapter
    5*, *Many to One: Reducing*, we built a system for establishing Elo ratings for
    tennis players based on historical data. These predictions have become popular
    on the sports journalism website you work for. Some readers have asked for more
    information about Elo predictions. In response to this new interest in your prediction
    engine, your employer wants the frontend team to build a visualization that shows
    the evolution of a player''s rating over their last few matches. Your job will
    be to provide the necessary data.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse most of the work we did in *Chapter 5*, *Many to One: Reducing*,
    for importing the data and generating the ratings. One modification will be necessary,
    though. In *Chapter 5*, *Many to One: Reducing*, we were only interested in the
    final rating. We''ll need to modify our previous code to append, line by line,
    the current ratings for the players in each match.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a project identical to the one in *Activity 5.01*, *Calculating Elo
    Ratings for Tennis* and copy the functions you wrote for the activity into a new
    file. You''ll need `match-probability`, `recalculate-rating`, and `elo-world-simple`.
    Copy `match_scores_1968-1990_unindexed_csv.csv` from [https://packt.live/36k1o6X](https://packt.live/36k1o6X)
    into the new project as well. The `deps.edn` file looked like this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The namespace declaration should look as follows:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Modify `elo-world-simple` so that each line (each match) is retained and that
    the ratings of both players are recorded.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the ability to store the ratings of players of each match, at the time
    they played the match, is rather simple. All the changes occur toward the end
    of the function. Start with the initialization map for the call to `reduce`.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `elo-world-simple`, the call to reduce looks like this (without the contents
    of the reducing function, for brevity):'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the new version, we''ll replace the `:match-count` field with a `:matches`
    field, whose initial value will be an empty vector:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To count the matches in the `elo-world-simple` version, for each line in the
    CSV file, we''ll simply increment `:match-count field` in the accumulator as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this version, we need to append the current match, decorated with the `winner-rating`
    and the `loser-rating` that have already been calculated, to the growing list
    of matches. Here''s the complete series of modifications made to `acc`. The new
    part is the anonymous function supplied to `update`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Put the function back together again. For clarity, let''s rename it `elo-db`.
    Since we only care about the list of matches, we can remove all the code dedicated
    to counting the number of correct predictions. Finally, after the call to `reduce`,
    we''ll add two more calls to the `->` threading macro:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `:matches` keyword, acting as a function, extracts the list of matches from
    the map returned by `reduce`. We also need to `reverse` the order of the matches
    because the queries we intend to run start at the present and go toward the past.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This gives us the final state of our function:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the REPL, run this function on the CSV file and store the matches in a var:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can verify that the ratings are available:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this data in place, we're ready to write functions to search for and extract
    information from it.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a function that tests whether a player is either the winner or loser in
    a given match.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to be able to skip over the matches we aren''t interested in, so this
    is a common test. Making it into its own predicate function will make our code
    easier to read. You might recognize the pattern, using a Clojure set, from *Chapter
    4*, *Mapping and Filtering*:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we''re ready to write our recursive function that will search through the
    list of matches. Start with a simple skeleton:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Like all of our recursive functions that consume another sequence, this one
    is structured around a conditional. Here we have the tests without the corresponding
    code. All we need to do now is fill in the blanks!
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start with the last condition, when the current match does not contain the player
    we're looking for.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, we forget about the current record and continue moving along
    the input list, recursively calling `match-tree-by-player` on the remaining items:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once again, the basic pattern should be somewhat familiar: `cons` will connect
    the current item—the current match—to the rest of whatever is to be calculated
    later. This time, however, we have a new problem: we need to continue our search
    for matches played by the winner and the loser of the current match. That''s two
    separate searches, which means two separate recursive calls to `match-tree-by-player`.
    Since we have two things, we need to put them into something. A vector is often
    a good choice in this kind of situation. Here''s the code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Surprised by that second call to `cons`? It is there because we need to add
    more than just one item to our output. We add the current match, then the vector
    that will hold the heads of the two new trees. Inside the vector, the two calls
    to `match-tree-by-player` will only be made when needed.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final `'()` is necessary because `cons` need a collection as a second argument.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the code for when `m` is empty.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As in the previous example, we provide an empty list so that the lazy sequence
    can finally end somewhere.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can see the complete function:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Test the function. Let''s start with a player we know is not in the match records:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We get an empty list, which is exactly what we want.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s try a player from the "database" (this is one of those times where
    you really want to attach the results to a var rather than trying to print everything
    to your REPL!):'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can check the first item to see if our data is really there:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: So far so good!
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s step back and think about what we''ve created here. If we try to see
    how many items are in the list, we get this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'That seems strange. We know that Roger Federer has played a lot more matches
    than that. The `count` function doesn''t work as we expect here because it doesn''t
    understand the structure of this hierarchal return value. All `count` can see
    is the first item, which is one match, `cons` onto a vector. All the other results
    are nested inside that vector. Each item in the hierarchy shares this same structure.
    Conceptually, it looks something like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: A hierarchical data structure where cons arrows contained in
    the vectors are lazy'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_06.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: A hierarchical data structure where cons arrows contained in the
    vectors are lazy'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'In this diagram, the laziness occurs inside the vector. Those two lazy sequences
    are not yet realized. We can check this by carefully drilling down into the structure:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is a good thing, because the entire structure, if realized, would be huge.
    Really, really huge. Hiding behind the fast response time is a tree that, if fully
    realized, would end up repeating thousands of times over the data in the original
    list. Try removing the `lazy-seq` wrapper from inside `match-tree-by-player`.
    The result will look something like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Overflowing the stack—too many recursive calls'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_07.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Overflowing the stack—too many recursive calls'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Let's look briefly at this error message. Clojure stack traces are not always
    that easy to read, but this one does contain some interesting information. The
    most part is the "`Caused by java.lang.stackOverflowError`" statement. That's
    what caused the compiler exception and stopped our code. Below this, the repeated
    lines mentioning `match-tree-by-player` are telling us that `match-tree-by-player`
    kept calling itself over and over again. This is just a small part of the entire
    stack trace, which goes on and on for several screens. Earlier, we talked about
    stack frames. Here, each line is a frame. Each call to the function is waiting
    for the next one to resolve. After a certain point, there are too many functions
    waiting on one another, and the stack finally overflows.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Once again, lazy evaluation saves us from this and allows us to traverse data
    in complex ways and to build, in a few lines of code, very complex data structures.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.04: A Custom take Function'
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous exercise gave us a way to extract a tree from our linear dataset.
    It still doesn't allow you to do what your employer is asking, namely to display
    a limited tree that shows just a few levels in the hierarchy. Once we have that,
    we'll be able to as many levels as the design team wants to show.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: What we really need is a specialized version of Clojure's `take` function that
    understands the structure of our data. We want to be able to write `(take-matches
    4 federer)` and get a four-level tree.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to solve two problems. First, we need to be able to traverse
    the tree we've created. Secondly, we need a way to count the number of levels
    we've traversed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: This exercise builds on the previous one. Use the `tennis_history.clj` files
    from [https://packt.live/38Dzp3H](https://packt.live/38Dzp3H) or make a complete
    copy.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start with a version of the function that only works when called with zero
    as its first argument:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Check if it works. To do this, you''ll need the `federer` var from the previous
    exercise:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s add the possibility of asking for either zero or one items:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This behavior duplicates our tests in the last exercise. We simply return the
    first match in the lazy sequence.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It''s still a good idea to test though. We''ll use `select-keys` to avoid lots
    of extra output data:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add an `:otherwise` condition when the `limit` is more than one:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This part should look familiar, because it mirrors the structure of the function
    we wrote to build this structure to begin with, with two levels of `cons`, the
    second of which attaches a vector containing two more calls to `take-matches`.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By saying `(dec limit)` each time, the future calls to `take-matches` will eventually
    reach zero and stop traversing the tree.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the complete function:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The results will be too long to print here because there are so many fields
    in each match map. They should have this basic structure:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the next exercise, we will make it easier to see these results.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Knowing When to Be Lazy
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that we did not use `lazy-seq` this time. Should we have?
    Obviously, it would be easy enough to wrap the function body with the `lazy-seq`
    macro. Whether we do that or not depends mostly on how and where the `take-matches`
    function is going to be used inside our application. If `take-matches` is the
    final step before passing off our data to the frontend, there is no point in making
    it lazy. We are certain that the data is of a reasonable size and that we need
    all of it to produce the visual we are going to show. Making the function eager
    (the opposite of lazy) seems like a good choice in this case.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if `take-matches` is going to be used for other tasks, then
    making it lazy might make sense. If, for example, we wanted to extract a larger
    number of levels and then perform some other kind of operation on the result,
    the benefits of lazy evaluation might be important.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: We are getting very close to satisfying our employer's requirements. We can
    retrieve the tree as a lazy sequence and now we can limit how many levels of match
    history we want to include. Our only remaining problem is that the results are
    hard to visualize, even in the REPL. We need to be able to format each match map.
    However, because of the tree structure, we can't just use `map` to transform each
    match. This is what we'll accomplish in the next exercise.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.05: Formatting the Matches'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a way to reach every map in the tree. Rather than writing a specialized
    `map` function, we''ll add an extra argument to `take-matches` that will be called
    on each match before it is returned. This will allow us to eliminate some of the
    keys we don''t need for presenting the data to users. Likewise, it would be nice
    to display the ratings as integers rather than floats. We''ll also add a feature:
    since we have the rating for each player before the match, we can also use the
    `match-probability` function to show the Elo prediction.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file as the previous exercise (or in a copy of the project), add
    a function argument to `take-matches` and call it on the matches before they''re
    returned:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is really quite simple. Just be careful not to forget to pass the `f` argument
    to the two recursive calls at the end. The formatting function is needed at every
    level of the tree.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we can call the function with `select-keys`, or any other formatting function
    we want.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test this, we''ll reuse the `federer` var from the two previous exercises.
    You can rebuild it if necessary like this, where `matches` is the output from
    `elo-db`:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s look at a few values:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Our data visualization could probably use some polish, but even in this form,
    we can see not only the actual structure of the tree, but the win-loss history
    of the players involved in Roger Federer's recent matches!
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we wanted to make the `f` parameter optional, we could supply the `identity`
    function as a default formatting function. The `identity` function simply returns
    whatever argument it is called with, which makes it the ideal placeholder function.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a `matches-with-ratings` function with a more sophisticated formatting
    function that changes the rating floats to integers and only shows the players''
    names and ratings:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Because `match-probabilty` returns a long decimal, we've made it more user friendly
    by turning it into a percentage.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the new function:![Figure 7.8: Matches with ratings'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_07_08.jpg)'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.8: Matches with ratings'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Now our results tell a real story! Beyond showing who won and who lost, they
    show whether the result was expected, or a surprise. It's easy to see which matches
    were upsets, like when Dudi Sela won despite only having 35% chance and which
    victories were nearly inevitable, such as Roger Federer's 98% chance of defeating
    Marcus Willis.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is also a good illustration of the power of using functions as
    arguments. With this minor change to our `take-matches` function, it has become
    something like a custom `map` function that could be used for many different purposes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.01: Historical, Player-Centric Elo'
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data visualization team at the sports journalism website loves your work.
    The readers are more and more curious about how Elo scores evolve over time. Emails
    pour in asking for more information. As a result, the journalists have a new request
    for a visualization. They found that it is difficult to present, on a single web
    page, more than four levels of tennis history. After that, there are too many
    branches and the readers stop reading.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: In the new project, the journalists would like to show the evolution of a single
    player over many matches. For a given match, they would like to show a relatively
    long history for the player they're focused on, and much shorter histories for
    each of their opponents.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the kind of graphic that the team wants to be able to make:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: The focus player has a long history, but the opponents are displayed
    with truncated histories'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_09.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: The focus player has a long history, but the opponents are displayed
    with truncated histories'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The journalists don't know yet how long the histories will have to be, so both
    lengths need to be parameterized. If opponent histories are longer than one level,
    the function should not focus only on the opponent but should return a full sub-tree
    that includes the opponent, and their opponent, and so on.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Your job is to adapt the existing code to this new use case.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: As a starting point, you will need the `match-probability`, `recalculate-rating`,
    `elo-world-db`, and `match-tree-by-player` functions from the code in *Exercise
    7.03*, *A Tennis History Tree*. You will also need to include their dependencies
    in your `deps.edn` file.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The recursive function you will write will be a specialized version of the `take-matches`
    function from Exercise 7.04\. It will operate on the output of `match-tree-by-player`,
    which in turn uses the output from `elo-world-db`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new function will have different behavior depending on whether a match involves
    the "focus player" or not. You will need to have separate parameters for both
    of these behaviors (in place of the `limit` parameter in `take-matches`, for example).
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like `take-matches`, your new function should accept a functional argument that
    will be called on individual matches.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hint
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don't forget that you can call `take-matches` from inside your new function,
    if you need to.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The fact that you have two separate behaviors for different kinds of matches
    will shape how your function moves recursively through the tree.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 701.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy sequences and recursion can be rather challenging. By now, you should know
    how to safely consume lazy sequences, how to produce them, and how to use them
    to build tree structures from linear data sources, all without blowing the stack
    of your runtime.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: As we've said before, writing functions to produce your own recursion-based
    lazy sequences should be something that you reach for only when all the other
    options won't work. Start with `map` and `filter`. If that's not enough, try `reduce`.
    Maybe the other forms of recursion will work. If none of those solve your problem,
    you have lazy sequences, an extremely powerful and efficient tool.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Lazy sequences and recursion always make us think. Being able to write your
    own lazy sequences will also make you a more enlightened consumer of lazy sequences.
    In Clojure, this is very valuable because lazy sequences are everywhere. Techniques
    like the ones we've explored here can also help you start thinking about new ways
    of understanding and solving problems.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: By now, you are well on your way to being able to code effectively in Clojure.
    To be an effective developer, you also need to know the tooling necessary to manage
    a Clojure project. That's what we will explore now. In the next chapter, you will
    learn about namespaces and how to use Leiningen to organize and run your projects.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
