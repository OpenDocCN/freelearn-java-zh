- en: '7\. Recursion II: Lazy Sequences'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, as we continue our exploration of recursive techniques, we
    will focus on lazy evaluation. We will write functions that safely produce potentially
    infinite lazy sequences, use lazy evaluation to consume linear data, produce lazily
    evaluated tree structures from linear data, and write functions that consume tree structures.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to think about new ways of understanding
    and solving problems.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At its simplest, a **lazy sequence** is a hybrid of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A *list* (not a vector!) of zero or more items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *reference* to possible future items of the list that can be computed if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, there''s a real part and a virtual part. Most of the time,
    you don''t need to think about this distinction. That''s the whole point of lazy
    sequences: the virtual part becomes real when you need it, if you need it. When
    you can stay away from the edge cases, you don''t need to worry about the virtual
    part because as soon as it''s needed, it will become real.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the last few chapters, we''ve already used lazy sequences in many different
    ways. They are an important, distinctive feature of Clojure and they are something
    that you''ll use every day as a Clojure programmer. You''ve seen by now that they
    are list-like structures with a twist: while you are using the first elements
    of the list, the rest of the list may not exist during runtime. Remember that
    in a lazy sequence, the individual items are not computed until they are needed.
    Or, to use the vocabulary of Clojure, they are not realized until they are consumed.
    You can define a potentially infinite lazy sequence and then only use, and compute,
    the first three items.'
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, the lazy sequences we've used were returned by core Clojure functions,
    such as `iterate`, which we looked at briefly in *Chapter 6*, *Recursion and Looping*,
    or familiar functions such as `map` and `filter`, which we saw in *Chapter 4*,
    *Mapping and Filtering*. The next step forward in this path is learning to write
    your own functions to produce lazy sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working in Clojure, lazy sequences are used all the time, as you''ve already
    seen by now. Writing functions to build your own lazy sequences is an advanced
    step and is more prone to errors. It should be considered the final option when
    dealing with sequences. Here is a rough guide to when deciding which techniques
    to use for solving a sequence-related problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map`, `filter`, and `remove` that accept and return sequences will be all
    you need when working with sequential data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce`, because your calculation needs to take into account the relationships
    between items in your data, or because you need to produce an aggregate result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recur`), or because your data is non-linear, such as a `tree` or a `graph`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option 4**: In a subset of the cases in *Option 3*, the input data is extremely
    vast, or your calculation produces too many branches. The result is a blown call
    stack. In such cases, lazy sequences are a solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each step down this list incurs a higher cost in terms of programmer effort
    and code complexity. When you stay closer to the beginning of the list, Clojure
    provides more help and protection from potential mistakes. As you move further
    down the list, you have to pay more attention to how you implement your solution.
    Part of being an effective Clojure developer is knowing how to avoid options 3
    and 4 when you can, and then using them effectively when you really need to. For
    certain kinds of problems, such as parsing deeply nested data structures, lazy
    sequences are a very good fit, and may be the only practical solution in Clojure.
    That's why it's an important skill to have. There is another benefit too. Knowing
    how lazy sequences are produced will give you a deeper understanding of how they
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by using lazy sequences to deal with linear data
    before moving on to more complex tree structures.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Lazy Sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with, let''s consider the simplest possible producer of lazy sequences,
    the `range` function, which simply returns a possibly infinite series of consecutive
    integers. The easiest way to write this is to use `iterate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `iterate` returns a sequence that starts with the initializer value,
    zero, and then continues with the result of calling `inc` on zero, then on the
    result of that and so on. Each intermediate value becomes an item in the returned
    lazy sequence. It works just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iterate` function is doing all the work. We could stop here, but we wouldn''t
    have learned much about how lazy sequences are built. Here''s a more low-level
    version that performs the same task. It uses the `lazy-seq` macro, which is the
    base of all lazy sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This function might look strange to you. We''re going to break it down in detail.
    Before we do that, let''s make sure it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are three things that stand out here.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `lazy-seq`. This is what makes the "magic" happen. Notice that `lazy-seq`
    wraps the entire body of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `cons`. The name of the `cons` function goes back to Lisp, which
    is much, much older than Clojure. `cons` is a function that connects two things.
    In most Lisp dialects, a list is constructed by using `cons` to connect an item
    to the rest of the list. Using `cons` here means that we are returning a list
    like this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of recursion. Without `lazy-seq`, this recursive call would execute
    immediately, and continuously, until the stack blew up. With `lazy-seq`, the next
    call does not happen; instead, a reference to that future call is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The structure of the function mirrors the data structure that it produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Structure of functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: Structure of functions'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to `lazy-seq`, the recursive call becomes a reference.
  prefs: []
  type: TYPE_NORMAL
- en: On the left, we have the real part; on the right, the virtual part. As the sequence
    is consumed, more and more virtual calls to `our-range` become real. The reference
    to further virtual calls remains at the end of the list, ready when more integers
    are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The future, unrealized calculation is often called a `thunk`. The word makes
    it sound like something that has already been thought, but it is something that
    hasn't been "`thunk`" yet.
  prefs: []
  type: TYPE_NORMAL
- en: This is just about the simplest possible version of a lazy sequence, but it
    is enough to provide an idea of the basic pattern that we will continue to expand
    upon.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a Sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An iterative sequence such as `our-range` takes a single input and builds a
    sequence by calling a function on the input, then on the result of the first function
    call, then on the result of that call, and so on. While this kind of computation
    can be useful sometimes, more often than not our code needs to accept incoming
    data of some kind.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern for doing this is a blend of the iterative style of lazy sequence
    and the recursive functions from the previous chapter. As with other forms of
    recursion, these functions will be built around conditionals, `if` or `cond` usually,
    and they will advance through the input sequence by working on the first item
    and then calling themselves again on the rest of the input. And like `our-range`,
    they will generally build their output with `cons`, attaching the current item
    onto a list that points to future possible calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.01: Finding Inflection Points'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are building a tool to analyze data from users' GPS watches.
    Runners and hikers want to know how much of the time they are going uphill or
    downhill. The incoming data is a potentially endless sequence of tuples containing
    an elevation in meters, and a timestamp, the number of milliseconds since the
    user started their exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each tuple looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to iterate through the input sequence looking for local peaks or valleys,
    that is, the points where the elevation is greater than the preceding and following
    points (peak), or less than the preceding and following points (valley). We could
    use `reduce` instead, as we did for the bicycle race problem in *Chapter 5*, *Many
    to One: Reducing*. However, the input stream might be very, very long, so we don''t
    want to force evaluation, which is what would happen with `reduce`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define some sample data in the required format. You can find this var at [https://packt.live/2Rhcbu6](https://packt.live/2Rhcbu6):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A peak or a valley can be detected by comparing three consecutive items. Write
    a predicate for detecting peaks or valleys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we move through the list of elevation-time tuples, we will look at the current
    item and the next two items in order to identify peaks and valleys. In a sub-sequence
    of three items, if the middle item is greater than the first and the last, it''s
    a peak; if it is less than both, it is a valley. In all other cases, the middle
    item is neither a peak nor a valley. We''ll write two functions, `local-max?`
    and `local-min?`, which will translate this logic into functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we wanted to clean up our code with some destructuring, we could avoid all
    those `first` calls. The functions would take a single, three-item list. Each
    item is a two-item tuple. With two levels of destructuring, we can extract the
    elements we need without calling any functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we move forward by two items in `sample-data`, we find a valley. The third,
    fourth, and fifth items are `[25.9 589014]`, `[23.8 691995]`, and `[24.7 734902]`.
    The middle value is less than the first and last:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Outline the recursive function. As we discussed, our function will have the
    same basic shape as most of the recursive functions we've seen so far. For our
    conditional, there are four cases we need to deal with. Before that, though, we
    must create a local binding to `current-series`, which will be the first three
    items in `data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we are just laying out the function, we will return different keywords
    instead of real values for the moment:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the first test in the `cond` expression, we check to see whether we''ve
    run out of data, which we can do by checking the length of `current-series`. If
    `current-series` does not contain three items, then we know that we''ll never
    find a peak or a valley, so it''s time to stop. As usual, we place this condition
    first so that in the subsequent tests we can be sure to have at least some data.
    The next two tests use the predicates we defined earlier: `local-max?` and `local-min?`.
    In these cases, we will add the current value to the accumulated `data`. The last
    possibility is that the current item is neither a minimum nor a maximum. In this
    case, we aren''t interested in that particular item, so we will continue without
    placing it in the accumulated data.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can start deciding what will happen in each of these four cases. The
    first case, when we''ve run out of data, is the simplest, but perhaps the most
    surprising as well. Here, we just return an empty list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `recur` based recursion, this wouldn''t make any sense: returning an empty
    list on reaching the end of the input data would mean that the function always
    returns… an empty list. Not very useful, really.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With a lazy sequence, however, this last item is simply the end of the list
    that will be returned. In many cases, the entire list will not be consumed, and
    the end of the input sequence will never be reached. If we think of a lazy sequence
    as a series of pointers toward potential calculations, the empty list here is
    simply the result of the very last potential calculation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is also important that this be an empty list, and not, for example, an empty
    vector. Vectors are do not support laziness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next two cases are where `local-max?` or `local-min?` have decided that
    the second item in `current-series` is indeed a peak or a valley. When that happens,
    we need to do two things. First, we need to mark the tuple as either a peak or
    a valley by appending the appropriate keyword; secondly, we need to make sure
    that the tuple becomes part of the output sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Appending the keyword is easy:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since each item is a two-value tuple, `conj` will make it into a three-value
    tuple:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When using `conj`, always be careful of what type of sequence you are using.
    When called on a vector, `conj` will append the new item to the end of the vector.
    When called on a list, it will append to the beginning. This may seem surprising,
    but there is a reason: `conj` always adds the new item in the most efficient way
    possible, depending on the data structure used. For vectors, this means adding
    to the end; for lists, this means adding to the beginning.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to incorporate this new value into the sequence that will be
    returned. Rather than placing it in an accumulator of some kind, as we might if
    we were using `recur`, the current item becomes the head of the list of all the
    remaining items to be calculated. This is what the `cons` function does. And that
    "list of all the remaining items to be calculated" is represented here as the
    recursive call to `inflection-points`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Think of it this way. To the right, you have all the remaining items. The call
    to `inflection-points` is going to return them, eventually, or at least potentially.
    The current item, like we said, is the head of that list. To the left, there are
    the items that have already been calculated. The last one of those, just to the
    left of the current item, is going to be the head of a list where the second item
    is the current item. And so on, all the way to the start of the list. An item
    is linked to the right by calling a function, and to the left because a function
    is being called on it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recursion can be hard to grasp. Don't worry! It will get easier with practice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When using `recur`, we tend to place the results in an argument to the next
    call to the recursive function. And we will be doing that with the `current-series`
    parameter. Because this function will return a lazy sequence, we'll use `cons`
    and place the current item in front of the potential result set. Each call to
    the function returns part of a list that the parent call can integrate into what
    it returns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last condition is the least interesting: ignore the current item and move
    on to the next. We do this in the now-familiar way of removing one item from data
    in the next recursive call to `inflection-points`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s the complete function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the function using the `sample-data` var we defined at the beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use Clojure''s `cycle` function to transform `sample-data` into a circuit that
    our jogger runs over and over again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`cycle` returns a lazy sequence that repeats a `seq` forever.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This exercise introduced the fundamental structure that you will find in most
    functions that produce lazy sequences. Making the current the head of the list
    of future calculations by using `cons` it onto the next recursive call is lazy
    sequence recursion in a nutshell. The surrounding code may become more complex
    as we move forward, but this operation will be the building block of all the lazy
    sequence-producing functions that we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.02: Calculating a Running Average'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To put this into practice, let's imagine a scenario similar to the grocery conveyor
    belt in the previous chapter. This time, though, we're doing quality control on
    the potatoes that are delivered to our mega-store. The potatoes are weighed as
    they pass a gate. We want to keep accepting potatoes as long as the average stays
    within certain bounds. It's all right to have a few small potatoes, or a few huge
    ones, as long as most of them are within the limits. If the average gets too high
    or too low, then something must be wrong, so we'll stop accepting potatoes.
  prefs: []
  type: TYPE_NORMAL
- en: Start up a fresh REPL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to simulate a potato source. We need to define a randomized
    potato-generating function. We''ll use the same technique for producing an infinite
    sequence of random values as we did for the grocery store, using `repeatedly`
    and `rand-int`. In this version, we add `10`, which will act as an extreme minimum
    potato size. This way our generator will produce potatoes between `10` and `400`
    grams:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test this lazy sequence with `take`. You will naturally get different random
    numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the first five elements are the same both times. Those items have
    been realized. New potato generation will only occur when more items are computed
    further along in the sequence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we arrive at our first design challenge. We need a way of representing
    the current average for each item in the list. Beyond just the weight of the current
    potato, we need the potato count at that point in the sequence and the accumulated
    weight so far. We could use a three-item tuple to hold those three values. If
    the fifth potato in the list weighs `200` grams, and the total weight of the first
    five potatoes was `784`, that potato could be represented like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we have the item count and the total, this design allows us to easily
    calculate the average at any point in the sequence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To find the average after three items, we would take three items from the sequence,
    if our function returns something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Dividing `551`, the total weight so far, by `3`, the number of potatoes, would
    give us the current average, which is `179.33333` in this case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have our design, but we still need to implement it. Let''s go through our
    options for selecting a sequence-handling technique. `map` won''t work here because
    we need to accumulate data. The `map` windowing pattern from *Chapter 4*, *Mapping
    and Filtering*, sounds like it might do the job, but it cannot accumulate data
    from one end of the sequence. The "window" is local to a few list items. So then
    maybe `reduce` is the answer? Unfortunately, `reduce` is not lazy: the entire
    sequence would be realized immediately. In some cases that would be acceptable,
    but in this case we don''t know how long the input will be.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That leaves us with recursion. We can''t use `recur` for the same reason we
    can''t use `reduce`: we might be processing a nearly infinite stream. That also
    means that standard recursion without `recur` will blow the stack well before
    we get through our first ton of potatoes. Therefore, we''ll use `lazy-seq` to
    produce different computations.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start with a skeleton for a function that returns a lazy sequence, using the
    `lazy-seq` macro to wrap the contents of the recursive function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `prev` parameter will start as an empty vector. We will use it to pass the
    current total on to the next calculation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fill in the contents of the recursive function using the patterns learned in
    the previous chapter, starting with the conditional that stop the recursion when
    we''ve exhausted the input. Unlike functions that are designed to continue infinitely,
    such as `range`, `average-potatoes` only continues as long as it has input, so
    we do need to check if there is anything left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we see the same pattern as in the previous exercise. When we reach the
    end of the list, we return an empty list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It would be possible to return `nil` here instead because `cons` treats `nil`
    here just like the empty list. Try `(cons 5 nil)` in your REPL. The empty list
    does a better job of telling us what is happening here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calculate the current item before performing the recursion. We''ll use a `let`
    binding here because we need the current item twice: once as an item in the list,
    and once as the `prev` argument that will be the basis for calculating the total
    weight when we get the next potato:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first part of the `let` binding uses some destructuring to get the current
    count and the total so far from the `prev` argument. We don't need the weight
    of the previous potato since it is already included in the running total, which
    is why we've used an underscore for that value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the next binding, we build the actual tuple that will become an item in
    the sequence. The only complexity here is that `n` and `total` might be nil, so
    we have to check for that and supply `0` if they are. The first item in the tuple
    is just the weight of the current potato; the second item is the count we'll use
    calculating the average; the last is the total weight of all the potatoes counted
    so far.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the recursive logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All we've done in this last step is attach the current item to the list that
    will be created by the subsequent recursive calls to `average-potatoes`. We've
    supplied `current` as the `prev` argument for the next call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note also that we use `next` instead of `rest`: this way, arrivals will be
    `nil` when we get to the end of the sequence, which is what we are expecting when
    we test with `if-not` at the beginning of this function. The `next` function is
    very similar to `rest`, which we used in the previous example. Both functions
    take a list and return all but the first item of that list. The difference between
    the two is visible when there are no more items in the list. In that case, `rest`
    returns an empty list, while `next` returns `nil`. Choosing one or the other depends
    on the circumstances. The advantage of `next` is that it is easy to test for truthiness
    as we did here, instead of calling `empty?` as we did with `rest` in the previous
    exercise. Because `rest` never returns `nil`, there is no risk of a null pointer
    exception.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test your new lazy function. Let''s start by looking at a few individual items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The third element of each tuple correctly indicates the accumulated weight.
    That part seems correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s try working with a large number of items. We''ll take the last element
    from a long list of potatoes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At `500,000` potatoes, everything seems to still be working as expected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this example, it''s important to note the difference between the preceding
    examples of lazy evaluation using `rand-int` and `inc`. With `rand-int`, each
    call is independent of all the other calls. Lazy evaluation is only useful here
    because it''s useful to have a potentially infinite sequence. With `inc`, when
    we implemented our version of `range`, the situation is slightly more complex
    because each call, and thus each item in the sequence, relies on the results of
    the call before. This is also true of the `average-potatoes` function: each call
    relies on the total and the count established in the previous call, and it relays
    this information onto the next call. At the same time, it does something more,
    because each calculation also consumes an item from the input sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The core `map` and `filter` functions do this as well: their results are no
    longer than their inputs. This adds one more reason to use write functions that
    consume and produce lazy sequences: they can be chained together with other lazy
    functions without forcing evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Consumption of Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lazy evaluation is an interface that, most of the time, hides from the user
    whether a calculation has already been performed, or is about to be performed.
    This is what it means when we say that a lazy sequence contains possibly differed
    computations. "Possibly," because we don't know, and we don't need to know, whether
    or not the computation has already happened.
  prefs: []
  type: TYPE_NORMAL
- en: To be useful though, lazy evaluation has to be passed from one function call
    to the next. If we pass a lazy sequence to function A, and the result of that
    to function B, and so on, the evaluation only remains lazy if A and B are designed
    to return lazy sequences.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say we have a lazy sequence called `xs`. If it gets passed to `map`,
    then to `filter`, and then to `take-while`, it will remain "lazy" the whole time.
    If instead we insert a `reduce` into that chain of function calls, or if we use
    `mapv` instead of `map`, the laziness disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, potential evaluation isn''t enough. You do actually want some real
    data at some point! However, there is generally an advantage in preserving laziness
    until the very end. That means avoiding something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we take some a sequence and use `map` to apply a function to each item.
    The call to `map` is lazy but the call to `reduce` is not, so the entire sequence
    is realized. Then some of those results are discarded by `filter`. Depending on
    what the functions are doing, this may be the only way to write this code. However,
    ideally, we would try to use `filter` first to narrow the data as much as possible
    before calling `reduce`, or any other function that does not preserve laziness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first advantage with this pattern is that your code becomes simpler. `filter`
    and `take-while` may have removed some types of data that the `reduce` call will
    not need to deal with at all. By waiting until the very last minute before forcing
    the sequence to be completely realized, there may actually be less computational
    work to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this might work, let''s look at this simple expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The evaluation starts with `(range)`, which, if `range` were not lazy, would
    return all the integers from zero to infinity. In other words, CPU usage would
    go to 100% and evaluation would stop when something broke.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of that horrible outcome, though, we can imagine the return value of
    `(range)` as looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Representation of range value'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: Representation of range value'
  prefs: []
  type: TYPE_NORMAL
- en: 'An unrealized lazy sequence: a starting point and a pointer to future calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a lot less work than counting from zero to infinity. It's essentially
    `0` and a pointer toward instructions for calculating the rest of the sequence,
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we don''t want all the integers, just the even ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With this call to `filter`, we''ve created a second lazy sequence built upon
    the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Creating the second lazy sequence'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: Creating the second lazy sequence'
  prefs: []
  type: TYPE_NORMAL
- en: By adding `filter`, we've created a new lazy sequence that still only has one
    real piece of data.
  prefs: []
  type: TYPE_NORMAL
- en: The only concrete data we have so far is still zero. All we've done is add to
    the instructions for getting the rest of the sequence. Everything is still virtual
    at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, finally, we call `nth` and ask for the fourth item in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now everything changes. We need the real values of the first four items. `nth`
    causes the first four items of the `filter` sequence to be evaluated. To do this,
    `filter` needs the first seven items of the `range` sequence to be evaluated.
    Suddenly, `(range)` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Current values in the range'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Current values in the range'
  prefs: []
  type: TYPE_NORMAL
- en: The first seven items are realized. The rest of the sequence is still virtual.
  prefs: []
  type: TYPE_NORMAL
- en: 'And `(filter even? (range))` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Filtering even numbers from the range'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Filtering even numbers from the range'
  prefs: []
  type: TYPE_NORMAL
- en: The fourth value in the list can now be consumed just like any other value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important thing to understand here is this: the last element in each of
    these sequences is a pointer to further potential calculations. `filter` and `range`
    worked together to provide just enough data to `nth`, and no more. By passing
    pointers (or "instructions for future computations") from function to function,
    the ultimate consumer can send a signal back up the chain, from pointer to pointer,
    to obtain the necessary data.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Lazy sequences in Clojure are actually implemented as **chunked sequences**.
    This is an implementation detail: as an optimization, Clojure sometimes realizes
    a few more items than are actually necessary. While this is good to know, it should
    never matter. It just means that you can''t count on an item *not* being realized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The capacity to avoid performing certain calculations until the last millisecond,
    or to avoid them entirely, is an important feature of lazy computation. There
    is another aspect that can be equally important: the ability to "forget" some
    of the calculations that have already been performed.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a non-lazy Clojure collection, such as a vector. Whatever size the
    vector is, the entire vector is available in memory at the same time. When the
    program no longer needs the vector, the platform on which the program is running,
    the JVM or a JavaScript engine, has a garbage collector that will free up the
    memory occupied by the vector. But if the program still needs even just one item
    from that vector, the garbage collector will keep waiting until it can safely
    reclaim that memory space.
  prefs: []
  type: TYPE_NORMAL
- en: A lazy sequence behaves in a totally different manner. Instead of being a single
    entity, it is a series of linked entities, each one referring to the next. As
    we've seen, this is how a lazy sequence can even reference items that don't exist
    yet, and maybe never will. There is another important part of the equation, though.
    Lazy sequences also the first part of the sequence to be garbage collected if
    it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the last example, we were looking for the fourth even number in the range.
    Instead, what if we were looking for the seven millionth even number?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is no reason, in this situation, to keep a reference to those first 13,999,999
    integers that were produced by `(range)`. That means that they can be safely garbage
    collected.
  prefs: []
  type: TYPE_NORMAL
- en: This feature of lazy sequences means that they can be used to process datasets
    that would be too big to fit in the computer's memory all at once. By "forgetting"
    the first part and not immediately computing the last part, Clojure can process
    extremely long sequences while using only a fraction of the memory it would take
    to contain them all at once. There is, however, a limitation.
  prefs: []
  type: TYPE_NORMAL
- en: If a program maintains a reference to the beginning of a sequence, then it can
    no longer be garbage collected. Often, this won't matter, but with very long sequences,
    it becomes an important consideration. Throughout this chapter, you may notice
    that we often repeat expressions such as `(first my-seq)` inside a function when
    it might be tempting to use a local `let` binding instead. This is a way of avoiding
    references that would prevent a sequence from being garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen that the "laziness" of lazy sequences is that they can point
    to future computations that will only be performed if they become necessary. There
    is another important advantage that is equally important, and that is what we
    are going to explore now. Remember from *Chapter 6*, *Recursion and Looping*,
    how recursive functions in Clojure need to use `recur` to avoid blowing up the
    stack? And remember how `recur` only works with a specific kind of recursion,
    tail recursion, where the next call to the recursive function can totally replace
    the previous call? The problem, you'll recall, is that only a limited number of
    stack frames are available. The function call on the root node of the tree needs
    to wait until all the calls have completed on all the child and grandchild and
    great-grandchild nodes, and so on. Stack frames are a limited resource but the
    data we need to operate on is often vast. This mismatch is a problem.
  prefs: []
  type: TYPE_NORMAL
- en: This is where lazy evaluation comes in. With lazy evaluation, Clojure itself
    handles the link to the next calculation, not the call stack. This way, when we
    use a recursive function to walk an entire tree, we are no longer trying to use
    the stack to map the structure of the tree. Instead, the lazy sequence itself
    does all the work of keeping track of which results need to be returned to which
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.03: A Tennis History Tree'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we return to the world of tennis. As you remember, in *Chapter
    5*, *Many to One: Reducing*, we built a system for establishing Elo ratings for
    tennis players based on historical data. These predictions have become popular
    on the sports journalism website you work for. Some readers have asked for more
    information about Elo predictions. In response to this new interest in your prediction
    engine, your employer wants the frontend team to build a visualization that shows
    the evolution of a player''s rating over their last few matches. Your job will
    be to provide the necessary data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse most of the work we did in *Chapter 5*, *Many to One: Reducing*,
    for importing the data and generating the ratings. One modification will be necessary,
    though. In *Chapter 5*, *Many to One: Reducing*, we were only interested in the
    final rating. We''ll need to modify our previous code to append, line by line,
    the current ratings for the players in each match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a project identical to the one in *Activity 5.01*, *Calculating Elo
    Ratings for Tennis* and copy the functions you wrote for the activity into a new
    file. You''ll need `match-probability`, `recalculate-rating`, and `elo-world-simple`.
    Copy `match_scores_1968-1990_unindexed_csv.csv` from [https://packt.live/36k1o6X](https://packt.live/36k1o6X)
    into the new project as well. The `deps.edn` file looked like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The namespace declaration should look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify `elo-world-simple` so that each line (each match) is retained and that
    the ratings of both players are recorded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the ability to store the ratings of players of each match, at the time
    they played the match, is rather simple. All the changes occur toward the end
    of the function. Start with the initialization map for the call to `reduce`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `elo-world-simple`, the call to reduce looks like this (without the contents
    of the reducing function, for brevity):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the new version, we''ll replace the `:match-count` field with a `:matches`
    field, whose initial value will be an empty vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To count the matches in the `elo-world-simple` version, for each line in the
    CSV file, we''ll simply increment `:match-count field` in the accumulator as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this version, we need to append the current match, decorated with the `winner-rating`
    and the `loser-rating` that have already been calculated, to the growing list
    of matches. Here''s the complete series of modifications made to `acc`. The new
    part is the anonymous function supplied to `update`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put the function back together again. For clarity, let''s rename it `elo-db`.
    Since we only care about the list of matches, we can remove all the code dedicated
    to counting the number of correct predictions. Finally, after the call to `reduce`,
    we''ll add two more calls to the `->` threading macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `:matches` keyword, acting as a function, extracts the list of matches from
    the map returned by `reduce`. We also need to `reverse` the order of the matches
    because the queries we intend to run start at the present and go toward the past.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This gives us the final state of our function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the REPL, run this function on the CSV file and store the matches in a var:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can verify that the ratings are available:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this data in place, we're ready to write functions to search for and extract
    information from it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a function that tests whether a player is either the winner or loser in
    a given match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to be able to skip over the matches we aren''t interested in, so this
    is a common test. Making it into its own predicate function will make our code
    easier to read. You might recognize the pattern, using a Clojure set, from *Chapter
    4*, *Mapping and Filtering*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''re ready to write our recursive function that will search through the
    list of matches. Start with a simple skeleton:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like all of our recursive functions that consume another sequence, this one
    is structured around a conditional. Here we have the tests without the corresponding
    code. All we need to do now is fill in the blanks!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start with the last condition, when the current match does not contain the player
    we're looking for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, we forget about the current record and continue moving along
    the input list, recursively calling `match-tree-by-player` on the remaining items:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once again, the basic pattern should be somewhat familiar: `cons` will connect
    the current item—the current match—to the rest of whatever is to be calculated
    later. This time, however, we have a new problem: we need to continue our search
    for matches played by the winner and the loser of the current match. That''s two
    separate searches, which means two separate recursive calls to `match-tree-by-player`.
    Since we have two things, we need to put them into something. A vector is often
    a good choice in this kind of situation. Here''s the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Surprised by that second call to `cons`? It is there because we need to add
    more than just one item to our output. We add the current match, then the vector
    that will hold the heads of the two new trees. Inside the vector, the two calls
    to `match-tree-by-player` will only be made when needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final `'()` is necessary because `cons` need a collection as a second argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the code for when `m` is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As in the previous example, we provide an empty list so that the lazy sequence
    can finally end somewhere.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can see the complete function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the function. Let''s start with a player we know is not in the match records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We get an empty list, which is exactly what we want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s try a player from the "database" (this is one of those times where
    you really want to attach the results to a var rather than trying to print everything
    to your REPL!):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check the first item to see if our data is really there:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So far so good!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s step back and think about what we''ve created here. If we try to see
    how many items are in the list, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'That seems strange. We know that Roger Federer has played a lot more matches
    than that. The `count` function doesn''t work as we expect here because it doesn''t
    understand the structure of this hierarchal return value. All `count` can see
    is the first item, which is one match, `cons` onto a vector. All the other results
    are nested inside that vector. Each item in the hierarchy shares this same structure.
    Conceptually, it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: A hierarchical data structure where cons arrows contained in
    the vectors are lazy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: A hierarchical data structure where cons arrows contained in the
    vectors are lazy'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this diagram, the laziness occurs inside the vector. Those two lazy sequences
    are not yet realized. We can check this by carefully drilling down into the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good thing, because the entire structure, if realized, would be huge.
    Really, really huge. Hiding behind the fast response time is a tree that, if fully
    realized, would end up repeating thousands of times over the data in the original
    list. Try removing the `lazy-seq` wrapper from inside `match-tree-by-player`.
    The result will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Overflowing the stack—too many recursive calls'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Overflowing the stack—too many recursive calls'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look briefly at this error message. Clojure stack traces are not always
    that easy to read, but this one does contain some interesting information. The
    most part is the "`Caused by java.lang.stackOverflowError`" statement. That's
    what caused the compiler exception and stopped our code. Below this, the repeated
    lines mentioning `match-tree-by-player` are telling us that `match-tree-by-player`
    kept calling itself over and over again. This is just a small part of the entire
    stack trace, which goes on and on for several screens. Earlier, we talked about
    stack frames. Here, each line is a frame. Each call to the function is waiting
    for the next one to resolve. After a certain point, there are too many functions
    waiting on one another, and the stack finally overflows.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, lazy evaluation saves us from this and allows us to traverse data
    in complex ways and to build, in a few lines of code, very complex data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.04: A Custom take Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous exercise gave us a way to extract a tree from our linear dataset.
    It still doesn't allow you to do what your employer is asking, namely to display
    a limited tree that shows just a few levels in the hierarchy. Once we have that,
    we'll be able to as many levels as the design team wants to show.
  prefs: []
  type: TYPE_NORMAL
- en: What we really need is a specialized version of Clojure's `take` function that
    understands the structure of our data. We want to be able to write `(take-matches
    4 federer)` and get a four-level tree.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to solve two problems. First, we need to be able to traverse
    the tree we've created. Secondly, we need a way to count the number of levels
    we've traversed.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise builds on the previous one. Use the `tennis_history.clj` files
    from [https://packt.live/38Dzp3H](https://packt.live/38Dzp3H) or make a complete
    copy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start with a version of the function that only works when called with zero
    as its first argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if it works. To do this, you''ll need the `federer` var from the previous
    exercise:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s add the possibility of asking for either zero or one items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This behavior duplicates our tests in the last exercise. We simply return the
    first match in the lazy sequence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It''s still a good idea to test though. We''ll use `select-keys` to avoid lots
    of extra output data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `:otherwise` condition when the `limit` is more than one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This part should look familiar, because it mirrors the structure of the function
    we wrote to build this structure to begin with, with two levels of `cons`, the
    second of which attaches a vector containing two more calls to `take-matches`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By saying `(dec limit)` each time, the future calls to `take-matches` will eventually
    reach zero and stop traversing the tree.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the complete function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results will be too long to print here because there are so many fields
    in each match map. They should have this basic structure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the next exercise, we will make it easier to see these results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Knowing When to Be Lazy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that we did not use `lazy-seq` this time. Should we have?
    Obviously, it would be easy enough to wrap the function body with the `lazy-seq`
    macro. Whether we do that or not depends mostly on how and where the `take-matches`
    function is going to be used inside our application. If `take-matches` is the
    final step before passing off our data to the frontend, there is no point in making
    it lazy. We are certain that the data is of a reasonable size and that we need
    all of it to produce the visual we are going to show. Making the function eager
    (the opposite of lazy) seems like a good choice in this case.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if `take-matches` is going to be used for other tasks, then
    making it lazy might make sense. If, for example, we wanted to extract a larger
    number of levels and then perform some other kind of operation on the result,
    the benefits of lazy evaluation might be important.
  prefs: []
  type: TYPE_NORMAL
- en: We are getting very close to satisfying our employer's requirements. We can
    retrieve the tree as a lazy sequence and now we can limit how many levels of match
    history we want to include. Our only remaining problem is that the results are
    hard to visualize, even in the REPL. We need to be able to format each match map.
    However, because of the tree structure, we can't just use `map` to transform each
    match. This is what we'll accomplish in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.05: Formatting the Matches'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a way to reach every map in the tree. Rather than writing a specialized
    `map` function, we''ll add an extra argument to `take-matches` that will be called
    on each match before it is returned. This will allow us to eliminate some of the
    keys we don''t need for presenting the data to users. Likewise, it would be nice
    to display the ratings as integers rather than floats. We''ll also add a feature:
    since we have the rating for each player before the match, we can also use the
    `match-probability` function to show the Elo prediction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file as the previous exercise (or in a copy of the project), add
    a function argument to `take-matches` and call it on the matches before they''re
    returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is really quite simple. Just be careful not to forget to pass the `f` argument
    to the two recursive calls at the end. The formatting function is needed at every
    level of the tree.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we can call the function with `select-keys`, or any other formatting function
    we want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test this, we''ll reuse the `federer` var from the two previous exercises.
    You can rebuild it if necessary like this, where `matches` is the output from
    `elo-db`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s look at a few values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our data visualization could probably use some polish, but even in this form,
    we can see not only the actual structure of the tree, but the win-loss history
    of the players involved in Roger Federer's recent matches!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we wanted to make the `f` parameter optional, we could supply the `identity`
    function as a default formatting function. The `identity` function simply returns
    whatever argument it is called with, which makes it the ideal placeholder function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a `matches-with-ratings` function with a more sophisticated formatting
    function that changes the rating floats to integers and only shows the players''
    names and ratings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because `match-probabilty` returns a long decimal, we've made it more user friendly
    by turning it into a percentage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the new function:![Figure 7.8: Matches with ratings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_07_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.8: Matches with ratings'
  prefs: []
  type: TYPE_NORMAL
- en: Now our results tell a real story! Beyond showing who won and who lost, they
    show whether the result was expected, or a surprise. It's easy to see which matches
    were upsets, like when Dudi Sela won despite only having 35% chance and which
    victories were nearly inevitable, such as Roger Federer's 98% chance of defeating
    Marcus Willis.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is also a good illustration of the power of using functions as
    arguments. With this minor change to our `take-matches` function, it has become
    something like a custom `map` function that could be used for many different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.01: Historical, Player-Centric Elo'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data visualization team at the sports journalism website loves your work.
    The readers are more and more curious about how Elo scores evolve over time. Emails
    pour in asking for more information. As a result, the journalists have a new request
    for a visualization. They found that it is difficult to present, on a single web
    page, more than four levels of tennis history. After that, there are too many
    branches and the readers stop reading.
  prefs: []
  type: TYPE_NORMAL
- en: In the new project, the journalists would like to show the evolution of a single
    player over many matches. For a given match, they would like to show a relatively
    long history for the player they're focused on, and much shorter histories for
    each of their opponents.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the kind of graphic that the team wants to be able to make:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: The focus player has a long history, but the opponents are displayed
    with truncated histories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: The focus player has a long history, but the opponents are displayed
    with truncated histories'
  prefs: []
  type: TYPE_NORMAL
- en: The journalists don't know yet how long the histories will have to be, so both
    lengths need to be parameterized. If opponent histories are longer than one level,
    the function should not focus only on the opponent but should return a full sub-tree
    that includes the opponent, and their opponent, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Your job is to adapt the existing code to this new use case.
  prefs: []
  type: TYPE_NORMAL
- en: As a starting point, you will need the `match-probability`, `recalculate-rating`,
    `elo-world-db`, and `match-tree-by-player` functions from the code in *Exercise
    7.03*, *A Tennis History Tree*. You will also need to include their dependencies
    in your `deps.edn` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The recursive function you will write will be a specialized version of the `take-matches`
    function from Exercise 7.04\. It will operate on the output of `match-tree-by-player`,
    which in turn uses the output from `elo-world-db`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new function will have different behavior depending on whether a match involves
    the "focus player" or not. You will need to have separate parameters for both
    of these behaviors (in place of the `limit` parameter in `take-matches`, for example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like `take-matches`, your new function should accept a functional argument that
    will be called on individual matches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hint
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don't forget that you can call `take-matches` from inside your new function,
    if you need to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The fact that you have two separate behaviors for different kinds of matches
    will shape how your function moves recursively through the tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 701.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy sequences and recursion can be rather challenging. By now, you should know
    how to safely consume lazy sequences, how to produce them, and how to use them
    to build tree structures from linear data sources, all without blowing the stack
    of your runtime.
  prefs: []
  type: TYPE_NORMAL
- en: As we've said before, writing functions to produce your own recursion-based
    lazy sequences should be something that you reach for only when all the other
    options won't work. Start with `map` and `filter`. If that's not enough, try `reduce`.
    Maybe the other forms of recursion will work. If none of those solve your problem,
    you have lazy sequences, an extremely powerful and efficient tool.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy sequences and recursion always make us think. Being able to write your
    own lazy sequences will also make you a more enlightened consumer of lazy sequences.
    In Clojure, this is very valuable because lazy sequences are everywhere. Techniques
    like the ones we've explored here can also help you start thinking about new ways
    of understanding and solving problems.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you are well on your way to being able to code effectively in Clojure.
    To be an effective developer, you also need to know the tooling necessary to manage
    a Clojure project. That's what we will explore now. In the next chapter, you will
    learn about namespaces and how to use Leiningen to organize and run your projects.
  prefs: []
  type: TYPE_NORMAL
