<html><head></head><body>
		<div>
			<div id="_idContainer019" class="Content">
			</div>
		</div>
		<div id="_idContainer020" class="Content">
			<h1 id="_idParaDest-30"><a id="_idTextAnchor032"/>2. Data Types and Immutability</h1>
		</div>
		<div id="_idContainer022" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we start by discovering the concept of immutability and its relevance in modern programs. We then examine simple data types such as strings, numbers and booleans, highlighting subtle differences in different environments like Clojure and ClojureScript. After a first exercise, we move on to more elaborated data types with collections such as lists, vectors, maps and sets, learning along the way which to use in different situations. After touching on the collection and sequence abstractions, we learn new techniques for working with nested data structures, before finally moving on to the final activity: implementing our very own in-memory database. </p>
			<p class="callout">By the end of this chapter, you will be able to work with the commonly used data types in Clojure. </p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor033"/>Introduction</h1>
			<p>Computer hardware has evolved dramatically in the last few decades. On a typical computer, storage and memory capacity have both increased a millionfold compared to the early 1980s. Nonetheless, standard industry practices in software development and mainstream ways of programming are not that different. Programming languages such as C++, Java, Python, and Ruby still typically encourage you to change things in place, and to use variables and mutate the state of a program, that is, to do things as if we were programming on a computer with a minimal amount of memory. However, in our quest for efficiency, better languages, and better tools, we reach for higher-level languages. We want to get further away from machine code. We want to write less code and let the computers do the tedious work.</p>
			<p>We don't want to think about the computer's memory anymore, such as where a piece of information is stored and whether it's safe and shareable, as much as we don't want to know about the order of the instructions in the CPU. It is a distraction to the problems we are trying to solve, which are already complicated enough. If you have ever tried to do some multithreading in the languages cited previously, you will know the pain of sharing data between threads. Although, leveraging multicore CPUs with multithreaded applications is an essential part of optimizing a modern program's performance.</p>
			<p>In Clojure, we work almost exclusively with immutable data types. They are safe to share, easy to fabricate, and improve the readability of our source code. Clojure provides the necessary tools to write programs with the functional programming paradigm: first-class citizen functions, which we will discover in the next chapter, and avoiding mutating and sharing the state of an application with immutable data types.</p>
			<p>Let's dust off the dictionary and look up the definition of immutable, "<em class="italic">Immutable: that cannot be changed; that will never change.</em>" It doesn't mean that a piece of information cannot change over time, but we record those modifications as a series of new values. "Updating" an immutable data structure provides a new value derived from the original value. However, the original value remains unchanged – those data structures that preserve previous versions of themselves are called persistent data structures.</p>
			<p>Intuitively, we may think that such a persistent data structure would negatively impact performance, but it's not as bad as it seems. They are optimized for performance, and techniques such as structural sharing bring the time complexity of all operations close to classic, mutable implementations.</p>
			<p>In other terms, unless you are programming an application that requires extraordinarily high performance, such as a video game, the benefits of using immutable data structures far outweigh the small loss in performance.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor034"/>Simple Data Types</h1>
			<p>A data type designates what kind of value a piece of data holds; it is a fundamental way of classifying data. Different types allow different kinds of operations: we can concatenate strings, multiply numbers, and perform logic algebra operations with Booleans. Because Clojure has a strong emphasis on practicality, we don't explicitly assign types to values in Clojure, but those values still have a type.</p>
			<p>Clojure is a hosted language and has three notable, major implementations in Java, JavaScript, and .NET. Being a hosted language is a useful trait that allows Clojure programs to run in different environments and take advantage of the ecosystem of its host. Regarding data types, it means that each implementation has different underlying data types, but don't worry as those are just implementation details. As a Clojure programmer, it does not make much difference, and if you know how to do something in Clojure, you likely know how to do it in, say, ClojureScript.</p>
			<p>In this topic, we will go through Clojure's simple data types. Here is the list of the data types looked at in this section. Please note that the following types are all immutable:</p>
			<ul>
				<li>Strings</li>
				<li>Numbers</li>
				<li>Booleans</li>
				<li>Keywords</li>
				<li>Nil</li>
			</ul>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor035"/>Strings</h2>
			<p>Strings are sequences of characters representing text. We have been using and manipulating strings since the first exercise of <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL.</em></p>
			<p>You can create a string by simply wrapping characters with double quotes (<strong class="source-inline">"</strong>):</p>
			<p class="source-code">user=&gt; "I am a String"</p>
			<p class="source-code">"I am a String"</p>
			<p class="source-code">user=&gt; "I am immutable"</p>
			<p class="source-code">"I am immutable"</p>
			<p>String literals are only created with double quotes, and if you need to use double quotes in a string, you can escape them with the backslash character (<strong class="source-inline">\</strong>):</p>
			<p class="source-code">user=&gt; (println "\"The measure of intelligence is the ability to change\" - Albert Einstein")</p>
			<p class="source-code">"The measure of intelligence is the ability to change" - Albert Einstein</p>
			<p class="source-code">nil</p>
			<p>Strings are not able to be changed; they are immutable. Any function that claims to transform a string yields a new value:</p>
			<p class="source-code">user=&gt; (def silly-string "I am Immutable. I am a silly String")</p>
			<p class="source-code">#'user/silly-string</p>
			<p class="source-code">user=&gt; (clojure.string/replace silly-string "silly" "clever")</p>
			<p class="source-code">"I am Immutable. I am a clever String"</p>
			<p class="source-code">user=&gt; silly-string</p>
			<p class="source-code">"I am Immutable. I am a silly String"</p>
			<p>In the preceding example, calling <strong class="source-inline">clojure.string/replace</strong> on <strong class="source-inline">silly-string</strong> returned a new string with the word "silly" replaced with "clever." However, when evaluating <strong class="source-inline">silly-string</strong> again, we can see that the value has not changed. The function returned a different value and did not change the original string.</p>
			<p>Although a string is usually a single unit of data representing text, Strings are also collections of characters. In the JVM implementation of Clojure, strings are of the <strong class="source-inline">java.lang.String</strong> Java type and they are implemented as collections of the <strong class="source-inline">java.lang.Character</strong> Java type, such as the following command, which returns a character:</p>
			<p class="source-code">user=&gt; (first "a collection of characters")</p>
			<p class="source-code">\a</p>
			<p class="source-code">user=&gt; (type *1)</p>
			<p class="source-code">java.lang.Character</p>
			<p><strong class="source-inline">first</strong> returns the first element of a collection. Here, the literal notation of a character is <strong class="source-inline">\a</strong>. The <strong class="source-inline">type</strong> function returns a string representation of the data type for a given value. Remember that we can use <strong class="source-inline">*1</strong> to retrieve the last returned value in the REPL, so <strong class="source-inline">*1</strong> evaluates to <strong class="source-inline">\a</strong>.</p>
			<p>It is interesting to note that, in ClojureScript, strings are collections of one-character strings, because there is no character type in JavaScript. Here is a similar example in a ClojureScript REPL:</p>
			<p class="source-code">cljs.user=&gt; (last "a collection of 1 character strings")</p>
			<p class="source-code">"s"</p>
			<p class="source-code">cljs.user=&gt; (type *1)</p>
			<p class="source-code">#object[String]</p>
			<p>As with the Clojure REPL, <strong class="source-inline">type</strong> returns a string representation of the data type. This time, in ClojureScript, the value returned by the <strong class="source-inline">last</strong> function (which returns the last character of a string) is of the <strong class="source-inline">#object[String] </strong>type, which means a JavaScript string.</p>
			<p>You can find a few common functions for manipulating strings in the core namespace, such as <strong class="source-inline">str</strong>, which we used in <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL!</em>, to concatenate (combine multiple strings together into one string):</p>
			<p class="source-code">user=&gt; (str "That's the way you " "con" "ca" "te" "nate")</p>
			<p class="source-code">"That's the way you concatenate"</p>
			<p class="source-code">user=&gt; (str *1 " - " silly-string)</p>
			<p class="source-code">"That's the way you concatenate - I am Immutable. I am a silly String"</p>
			<p>Most functions for manipulating strings can be found in the <strong class="source-inline">clojure.string</strong> namespace. Here is a list of them using the REPL <strong class="source-inline">dir</strong> function:</p>
			<p class="source-code">user=&gt; (dir clojure.string)</p>
			<p class="source-code">blank?</p>
			<p class="source-code">capitalize</p>
			<p class="source-code">ends-with?</p>
			<p class="source-code">escape</p>
			<p class="source-code">includes?</p>
			<p class="source-code">index-of</p>
			<p class="source-code">join</p>
			<p class="source-code">last-index-of</p>
			<p class="source-code">lower-case</p>
			<p class="source-code">re-quote-replacement</p>
			<p class="source-code">replace</p>
			<p class="source-code">replace-first</p>
			<p class="source-code">reverse</p>
			<p class="source-code">split</p>
			<p class="source-code">split-lines</p>
			<p class="source-code">starts-with?</p>
			<p class="source-code">trim</p>
			<p class="source-code">trim-newline</p>
			<p class="source-code">triml</p>
			<p class="source-code">trimr</p>
			<p class="source-code">upper-case</p>
			<p>As a reminder, this is how you can use a function from a specific namespace:</p>
			<p class="source-code">user=&gt; (clojure.string/includes? "potatoes" "toes")</p>
			<p class="source-code">true</p>
			<p>We will not cover all the string functions, but feel free to try them out now. You can always look up the documentation of a string function from the preceding list with the <strong class="source-inline">doc</strong> function.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor036"/>Numbers</h2>
			<p>Clojure has good support for numbers and you will most likely not have to worry about the underlying types, as Clojure will handle pretty much anything. However, it is important to note that there are a few differences between Clojure and ClojureScript in that regard.</p>
			<p>In Clojure, by default, natural numbers are implemented as the <strong class="source-inline">java.lang.Long</strong> Java type unless the number is too big for <strong class="source-inline">Long</strong>. In that case, it is typed <strong class="source-inline">clojure.lang.BigInt</strong>:</p>
			<p class="source-code">user=&gt; (type 1)</p>
			<p class="source-code">java.lang.Long</p>
			<p class="source-code">user=&gt; (type 1000000000000000000)</p>
			<p class="source-code">java.lang.Long</p>
			<p class="source-code">user=&gt; (type 10000000000000000000)</p>
			<p class="source-code">clojure.lang.BigInt</p>
			<p>Notice, in the preceding example, that the number was too big to fit in the <strong class="source-inline">java.lang.Long</strong> Java type and, therefore, was implicitly typed <strong class="source-inline">clojure.lang.BigInt</strong>.</p>
			<p>Exact ratios are represented by Clojure as "Ratio" types, which have a literal representation. 5/4 is not an exact ratio, so the output is the ratio itself:</p>
			<p class="source-code">user=&gt; 5/4</p>
			<p class="source-code">5/4</p>
			<p>The result of dividing <strong class="source-inline">3</strong> by <strong class="source-inline">4</strong> can be represented by the ratio 3/4:</p>
			<p class="source-code">user=&gt; (/ 3 4)</p>
			<p class="source-code">3/4</p>
			<p class="source-code">user=&gt; (type 3/4)</p>
			<p class="source-code">clojure.lang.Ratio</p>
			<p><strong class="source-inline">4/4</strong> is equivalent to <strong class="source-inline">1</strong> and is evaluated as follows:</p>
			<p class="source-code">user=&gt; 4/4</p>
			<p class="source-code">1</p>
			<p>Decimal numbers are "double" precision floating-point numbers: </p>
			<p class="source-code">user=&gt; 1.2</p>
			<p class="source-code">1.2</p>
			<p>If we take our division of 3 by 4 again, but this time mix in a "Double" type, we will not get a ratio as a result:</p>
			<p class="source-code">user=&gt; (/ 3 4.0)</p>
			<p class="source-code">0.75</p>
			<p>This is because floating-point numbers are "contagious" in Clojure. Any operation involving floating-point numbers will result in a float or a double:</p>
			<p class="source-code">user=&gt; (* 1.0 2)</p>
			<p class="source-code">2.0</p>
			<p class="source-code">user=&gt; (type (* 1.0 2))</p>
			<p class="source-code">java.lang.Double</p>
			<p>In ClojureScript, however, numbers are just "JavaScript numbers," which are all double-precision floating-point numbers. JavaScript does not define different types of numbers like Java and some other programming languages do (for example, <strong class="source-inline">long</strong>, <strong class="source-inline">integer</strong>, and <strong class="source-inline">short</strong>):</p>
			<p class="source-code">cljs.user=&gt; 1</p>
			<p class="source-code">1</p>
			<p class="source-code">cljs.user=&gt; 1.2</p>
			<p class="source-code">1.2</p>
			<p class="source-code">cljs.user=&gt; (/ 3 4)</p>
			<p class="source-code">0.75</p>
			<p class="source-code">cljs.user=&gt; 3/4</p>
			<p class="source-code">0.75</p>
			<p class="source-code">cljs.user=&gt; (* 1.0 2)</p>
			<p class="source-code">2</p>
			<p>Notice that, this time, any operation returns a floating-point number. The fact that there is no decimal separation for <strong class="source-inline">1</strong> or <strong class="source-inline">2</strong> is just a formatting convenience.</p>
			<p>We can make sure that all those numbers are JavaScript numbers (double-precision, floating-point) by using the <strong class="source-inline">type</strong> function:</p>
			<p class="source-code">cljs.user=&gt; (type 1)</p>
			<p class="source-code">#object[Number]</p>
			<p class="source-code">cljs.user=&gt; (type 1.2)</p>
			<p class="source-code">#object[Number]</p>
			<p class="source-code">cljs.user=&gt; (type 3/4)</p>
			<p class="source-code">#object[Number]</p>
			<p>If you need to do more than simple arithmetic, you can use the Java or JavaScript <strong class="source-inline">math</strong> libraries, which are similar except for a few minor exceptions.</p>
			<p>You will learn more about host platform interoperability in <em class="italic">Chapter 9</em>, <em class="italic">Host Platform Interoperability with Java and JavaScript</em> (how to interact with the host platform and its ecosystem), but the examples in the chapter will get you started with doing some more complicated math and with using the <strong class="source-inline">math</strong> library:</p>
			<p>Reading a value from a constant can be done like this:</p>
			<p class="source-code">user=&gt; Math/PI</p>
			<p class="source-code">3.141592653589793</p>
			<p>And calling a function, like the usual Clojure functions, can be done like this:</p>
			<p class="source-code">user=&gt; (Math/random)</p>
			<p class="source-code">0.25127992428738254</p>
			<p class="source-code">user=&gt; (Math/sqrt 9)</p>
			<p class="source-code">3.0</p>
			<p class="source-code">user=&gt; (Math/round 0.7)</p>
			<p class="source-code">1</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor037"/>Exercise 2.01: The Obfuscation Machine</h2>
			<p>You have been contacted by a secret government agency to develop an algorithm that encodes text into a secret string that only the owner of the algorithm can decode. Apparently, they don't trust other security mechanisms such as SSL and will only communicate sensitive information with their own proprietary technology.</p>
			<p>You need to develop an <strong class="source-inline">encode</strong> function and a <strong class="source-inline">decode</strong> function. The <strong class="source-inline">encode</strong> function should replace letters with numbers that are not easily guessable. For that purpose, each letter will take the character's number value in the ASCII table, add another number to it (the number of words in the sentence to encode), and finally, compute the square value of that number. The <strong class="source-inline">decode</strong> function should allow the user to revert to the original string. Someone highly ranked in the agency came up with that algorithm so they trust it to be very secure.</p>
			<p>In this exercise, we will put into practice some of the things we've learned about strings and numbers by building an obfuscation machine:</p>
			<ol>
				<li>Start your REPL and look up the documentation of the <strong class="source-inline">clojure.string/replace</strong> function:<p class="source-code">user=&gt; (doc clojure.string/replace)</p><p class="source-code">-------------------------</p><p class="source-code">clojure.string/replace</p><p class="source-code">([s match replacement])</p><p class="source-code">  Replaces all instance of match with replacement in s.</p><p class="source-code">   match/replacement can be:</p><p class="source-code">   string / string</p><p class="source-code">   char / char</p><p class="source-code">   pattern / (string or function of match).</p><p class="source-code">   See also replace-first.</p><p class="source-code">   The replacement is literal (i.e. none of its characters are treated</p><p class="source-code">   specially) for all cases above except pattern / string.</p><p class="source-code">   For pattern / string, $1, $2, etc. in the replacement string are</p><p class="source-code">   substituted with the string that matched the corresponding</p><p class="source-code">   parenthesized group in the pattern.  If you wish your replacement</p><p class="source-code">   string r to be used literally, use (re-quote-replacement r) as the</p><p class="source-code">   replacement argument.  See also documentation for</p><p class="source-code">   java.util.regex.Matcher's appendReplacement method.</p><p class="source-code">   Example:</p><p class="source-code">   (clojure.string/replace "Almost Pig Latin" #"\b(\w)(\w+)\b" "$2$1ay")</p><p class="source-code">   -&gt; "lmostAay igPay atinLay"</p><p>Notice that the <strong class="source-inline">replace</strong> function can take a pattern and a function of the matching result as parameters. We don't know how to iterate over collections yet, but using the <strong class="source-inline">replace</strong> function with a pattern and a "replacement function" should do the job.</p></li>
				<li>Try and use the <strong class="source-inline">replace</strong> function with the <strong class="source-inline">#"\w"</strong> pattern (which means word character), replace it with the <strong class="source-inline">!</strong> character, and observe the result:<p class="source-code">user=&gt; (clojure.string/replace "Hello World" #"\w" "!")</p><p>The output is as follows:</p><p class="source-code">"!!!!! !!!!!"</p></li>
				<li>Try and use the <strong class="source-inline">replace</strong> function with the same pattern, but this time passing an anonymous function that takes the matching letter as a parameter:<p class="source-code">user=&gt; (clojure.string/replace "Hello World" #"\w" (fn [letter] (do (println letter) "!")))</p><p>The output is as follows:</p><p class="source-code">H</p><p class="source-code">e</p><p class="source-code">l</p><p class="source-code">l</p><p class="source-code">o</p><p class="source-code">W</p><p class="source-code">o</p><p class="source-code">r</p><p class="source-code">l</p><p class="source-code">d</p><p class="source-code">"!!!!! !!!!!"</p><p>Observe that the function was called for each letter, printing the match out to the console and finally returning the string with the matches replaced by the <strong class="source-inline">!</strong> character. It looks like we should be able to write our encoding logic in that replacement function.</p></li>
				<li>Let's now see how we can convert a character to a number. We can use the <strong class="source-inline">int</strong> function, which coerces its parameter to an integer. It can be used like this:<p class="source-code">user=&gt; (int \a)</p><p class="source-code">97</p></li>
				<li>It seems that the "replacement function" will take a string as a parameter, so let's convert our string to a character. Use the <strong class="source-inline">char-array</strong> function combined with <strong class="source-inline">first</strong> to convert our string to a character as follows:<p class="source-code">user=&gt; (first (char-array "a"))</p><p class="source-code">\a</p></li>
				<li>Now, if we combine previous steps together and also compute the square value of the character's number, we should be approaching our obfuscation goal. Combine the code written previously to obtain a character code from a string and get its square value using the <strong class="source-inline">Math/pow</strong> function as follows:<p class="source-code">user=&gt; (Math/pow (int (first (char-array "a"))) 2)</p><p class="source-code">9409.0</p></li>
				<li>Let's now convert this result to the string that will be returned from our <strong class="source-inline">replace</strong> function. First, let's remove the decimal part by coercing the result to an <strong class="source-inline">int</strong>, and put things together in an <strong class="source-inline">encode-letter</strong> function, as follows:<p class="source-code">user=&gt;</p><p class="source-code">(defn encode-letter</p><p class="source-code">  [s]</p><p class="source-code">  (let [code (Math/pow (int (first (char-array s))) 2)]</p><p class="source-code">    (str (int code))))</p><p class="source-code">#'user/encode-letter</p><p class="source-code">user=&gt; (encode-letter "a")</p><p class="source-code">"9409"</p><p>Great! It seems to work. Let's now test our function as part of the <strong class="source-inline">replace</strong> function.</p></li>
				<li>Create the <strong class="source-inline">encode</strong> function, which uses <strong class="source-inline">clojure.string/replace</strong> as well as our <strong class="source-inline">encode-letter</strong> function:<p class="source-code">user=&gt;</p><p class="source-code">(defn encode</p><p class="source-code">  [s]</p><p class="source-code">  (clojure.string/replace s #"\w" encode-letter))</p><p class="source-code">#'user/encode</p><p class="source-code">user=&gt; (encode "Hello World")</p><p class="source-code">"518410201116641166412321 756912321129961166410000"</p><p>It seems to work but the resulting string will be hard to decode without being able to identify each letter individually. </p><p>There is another thing that we did not take into account: the <strong class="source-inline">encode</strong> function should take an arbitrary number to add to the code before calculating the square value.</p></li>
				<li>First, add a separator as part of our <strong class="source-inline">encode-letter</strong> function, for example, the <strong class="source-inline">#</strong> character, so that we can identify each letter individually. Second, add an extra parameter to <strong class="source-inline">encode-letter</strong>, which needs to be added before calculating the square value:<p class="source-code">user=&gt;</p><p class="source-code">(defn encode-letter</p><p class="source-code">  [s x]</p><p class="source-code">  (let [code (Math/pow (+ x (int (first (char-array s)))) 2)]</p><p class="source-code">    (str "#" (int code))))</p><p class="source-code">#'user/encode-letter</p></li>
				<li>Now, test the <strong class="source-inline">encode</strong> function another time:<p class="source-code">user=&gt; (encode "Hello World")</p><p class="source-code">Execution error (ArityException) at user/encode (REPL:3).</p><p class="source-code">Wrong number of args (1) passed to: user/encode-letter</p><p>Our <strong class="source-inline">encode</strong> function is now failing because it is expecting an extra argument. </p></li>
				<li>Modify the <strong class="source-inline">encode</strong> function to calculate the number of words in the text to obfuscate, and pass it to the <strong class="source-inline">encode-letter</strong> function. You can use the <strong class="source-inline">clojure.string/split</strong> function with a whitespace, as follows, to count the number of words:<p class="source-code">user=&gt;</p><p class="source-code">(defn encode</p><p class="source-code">  [s]</p><p class="source-code">  (let [number-of-words (count (clojure.string/split s #" "))]</p><p class="source-code">    (clojure.string/replace s #"\w" (fn [s] (encode-letter s number-of-words)))))</p><p class="source-code">#'user/encode</p></li>
				<li>Try your newly created function with a few examples and make sure it obfuscates strings properly:<p class="source-code">user=&gt; (encode "Super secret")</p><p class="source-code">"#7225#14161#12996#10609#13456 #13689#10609#10201#13456#10609#13924"</p><p class="source-code">user=&gt; (encode "Super secret message")</p><p class="source-code">"#7396#14400#13225#10816#13689 #13924#10816#10404#13689#10816#14161 #12544#10816#13924#13924#10000#11236#10816"</p><p>What a beautiful, unintelligible, obfuscated string – well done! Notice how the numbers for the same letters are different depending on the number of words in the phrase to encode. It seems to work according to the specification!</p><p>We can now start working on the <strong class="source-inline">decode</strong> function, for which we will need to use the following functions:</p><p><strong class="source-inline">Math/sqrt</strong> to obtain the square root value of a number.</p><p><strong class="source-inline">char</strong> to retrieve a letter from a character code (a number).</p><p><strong class="source-inline">subs</strong> as in substring, to get a sub-portion of a string (and get rid of our <strong class="source-inline">#</strong> separator).</p><p><strong class="source-inline">Integer/parseInt</strong> to convert a string to an integer.</p></li>
				<li>Write the <strong class="source-inline">decode</strong> function using a combination of the preceding functions, to decode an obfuscated character:<p class="source-code">user=&gt;</p><p class="source-code">(defn decode-letter</p><p class="source-code">  [x y]</p><p class="source-code">  (let [number (Integer/parseInt (subs x 1))</p><p class="source-code">        letter (char (- (Math/sqrt number) y))]</p><p class="source-code">  (str letter)))</p><p class="source-code">#'user/decode-letter</p></li>
				<li>Finally, write the <strong class="source-inline">decode</strong> function, which is similar to the <strong class="source-inline">encode</strong> function except that it should use <strong class="source-inline">decode-letter</strong> instead of <strong class="source-inline">encode-letter</strong>:<p class="source-code">user=&gt;</p><p class="source-code">(defn decode [s]</p><p class="source-code">  (let [number-of-words (count (clojure.string/split s #" "))]</p><p class="source-code">    (clojure.string/replace s #"\#\d+" (fn [s] (decode-letter s number-of-words)))))</p><p class="source-code">#'user/decode</p></li>
				<li>Test your functions and make sure that they both work:<p class="source-code">user=&gt; (encode "If you want to keep a secret, you must also hide it from yourself.")</p><p>The output is as follows:</p><p class="source-code">"#7569#13456 #18225#15625#17161 #17689#12321#15376#16900 #16900#15625 #14641#13225#13225#15876 #12321 #16641#13225#12769#16384#13225#16900, #18225#15625#17161 #15129#17161#16641#16900 #12321#14884#16641#15625 #13924#14161#12996#13225 #14161#16900 #13456#16384#15625#15129 #18225#15625#17161#16384#16641#13225#14884#13456."</p><p class="source-code">user=&gt; (decode *1)</p><p class="source-code">"If you want to keep a secret, you must also hide it from yourself."</p></li>
			</ol>
			<p>In this exercise, we've put into practice working with numbers and strings by creating an encoding system. We can now move on to learning other data types, starting with Booleans.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor038"/>Booleans</h2>
			<p>Booleans are implemented as Java's <strong class="source-inline">java.lang.Boolean</strong> in Clojure or JavaScript's "Boolean" in ClojureScript. Their value can either be <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>, and their literal notations are simply the lowercase <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong>.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>Symbols</h2>
			<p>Symbols are identifiers referring to something else. We have already been using symbols when creating bindings or calling functions. For example, when using <strong class="source-inline">def</strong>, the first argument is a symbol that will refer to a value, and when calling a function such as <strong class="source-inline">+</strong>, <strong class="source-inline">+</strong> is a symbol referring to the function implementing the addition. Consider the following examples:</p>
			<p class="source-code">user=&gt; (def foo "bar")</p>
			<p class="source-code">#'user/foo</p>
			<p class="source-code">user=&gt; foo</p>
			<p class="source-code">"bar"</p>
			<p class="source-code">user=&gt; (defn add-2 [x] (+ x 2))</p>
			<p class="source-code">#'user/add-2</p>
			<p class="source-code">user=&gt; add-2</p>
			<p class="source-code">#object[user$add_2 0x4e858e0a "user$add_2@4e858e0a"]</p>
			<p>Here, we have created the <strong class="source-inline">user/foo</strong> symbol, which refers to the <strong class="source-inline">"bar"</strong> string, and the <strong class="source-inline">add-2</strong> symbol, which refers to the function that adds 2 to its parameter. We have created those symbols in the user namespace, hence the notation with <strong class="source-inline">/</strong>: <strong class="source-inline">user/foo</strong>.</p>
			<p>If we try to evaluate a symbol that has not been defined, we'll get an error:</p>
			<p class="source-code">user=&gt; marmalade</p>
			<p class="source-code">Syntax error compiling at (REPL:0:0).</p>
			<p class="source-code">Unable to resolve symbol: marmalade in this context</p>
			<p>In the <em class="italic">REPL Basics</em> topic of <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL!</em>, we were able to use the following functions because they are bound to a specific symbol:</p>
			<p class="source-code">user=&gt; str</p>
			<p class="source-code">#object[clojure.core$str 0x7bb6ab3a "clojure.core$str@7bb6ab3a"]</p>
			<p class="source-code">user=&gt; +</p>
			<p class="source-code">#object[clojure.core$_PLUS_ 0x1c3146bc "clojure.core$_PLUS_@1c3146bc"]</p>
			<p class="source-code">user=&gt; clojure.string/replace</p>
			<p class="source-code">#object[clojure.string$replace 0xf478a81 "clojure.string$replace@f478a81"]</p>
			<p>Those gibberish-like values are string representations of the functions, because we are asking for the values bound to the symbols rather than invoking the functions (wrapping them with parentheses).</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor040"/>Keywords</h2>
			<p>You can think of a keyword as some kind of a special constant string. Keywords are a nice addition to Clojure because they are lightweight and convenient to use and create. You just need to use the colon character, <strong class="source-inline">:</strong>, at the beginning of a word to create a keyword:</p>
			<p class="source-code">user=&gt; :foo</p>
			<p class="source-code">:foo</p>
			<p class="source-code">user=&gt; :another_keyword</p>
			<p class="source-code">:another_keyword</p>
			<p>They don't refer to anything else like symbols do; as you can see in the preceding example, when evaluated, they just return themselves. Keywords are typically used as keys in a key-value associative map, as we will see in the next topic about collections.</p>
			<p>In this section, we went through simple data types such as string, numbers, Boolean, symbols, and keywords. We highlighted how their underlying implementation depends on the host platform because Clojure is a hosted language. In the next section, we will see how those values can aggregate to collections.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor041"/>Collections</h1>
			<p>Clojure is a functional programming language in which we focus on building the computations of our programs in terms of the evaluation of functions, rather than building custom data types and their associated behaviors. In the other dominant programming paradigm, object-oriented programming, programmers define the data types and the operations available on them. Objects are supposed to encapsulate data and communicate with each other by passing messages around. But there is an unfortunate tendency to create classes and new types of objects to customize the shape of the data, instead of using more generic data structures, which cascades into creating specific methods to access and modify the data. We have to come up with decent names, which is difficult, and then we pass instances of objects around in our programs. We create new classes all the time, but more code means more bugs. It is a recipe for disaster; it is an explosion of code, with code that is very specific and benefits from little reuse.</p>
			<p>Of course, it is not like that everywhere, and you can write clean object-oriented code, with objects being the little black boxes of functionality they were designed for. However, as programmers, whether it's through using other libraries or maintaining a legacy code base, we spend most of our time working with other people's code.</p>
			<p>In functional programming, and more specifically, in Clojure, we tend to work with just a few data types. Types that are generic and powerful, types that every other "Clojurian" already knows and has mastered.</p>
			<p>Collections are data types that can contain more than one thing and describe how those items relate to each other. The four main data structures for collections that you should know about are <strong class="bold">Maps</strong>, <strong class="bold">Sets</strong>, <strong class="bold">Vectors</strong>, and <strong class="bold">Lists</strong>. There are more available, including the data structure offered by your host platform (for example, Java or JavaScript) or other libraries, but those four are your bread and butter for doing things in Clojure.</p>
			<p><em class="italic">"Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming." - Rob Pike's Rule #5 of programming.</em></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor042"/>Maps</h2>
			<p>A Map is a collection of key-value pairs. Clojure provides – in a persistent and immutable fashion – the usual HashMap but also a SortedMap. </p>
			<p>HashMaps are called "Hash" because they create a hash of the key and map it to a given value. Lookups, as well as other common operations (<strong class="source-inline">insert</strong> and <strong class="source-inline">delete</strong>), are fast.</p>
			<p>HashMaps are used a lot in Clojure, notably, for representing entities where we need to associate some attributes to some values. SortedMaps are different because they preserve the order of the keys; otherwise, they have the same interface and are used in the same way as HashMaps. SortedMaps are not very common, so let's focus on HashMaps.</p>
			<p>You can create a HashMap with the literal notation using curly braces. Here is a Map with three key-value pairs, with the keys being the <strong class="source-inline">:artist</strong>, <strong class="source-inline">:song</strong>, and <strong class="source-inline">:year</strong> keywords:</p>
			<p class="source-code">user=&gt; {:artist "David Bowtie" :song "The Man Who Mapped the World" :year 1970}</p>
			<p class="source-code">{:artist "David Bowtie", :song "The Man Who Mapped the World", :year 1970}</p>
			<p>You might have noticed in the preceding example that key-value pairs in the map are separated by a space, but Clojure evaluates it and returns a Map with key-value pairs separated by a comma. As with other collections, you can choose to use a space or a comma to separate each entry. For maps, there's no best practice and if you think it improves a map's readability, use commas; otherwise, simply omit them. You can also separate entries with new lines.</p>
			<p>Here's another map written with comma-separated entries:</p>
			<p class="source-code">user=&gt; {:artist "David Bowtie", :song "Comma Oddity", :year 1969}</p>
			<p class="source-code">{:artist "David Bowtie", :song "Comma Oddity", :year 1969}</p>
			<p>Notice that the values can be of any type, and not only simple values such as strings and numbers, but also vectors and even other maps, allowing you to create nested data structures and structure information as follows:</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">  {</p>
			<p class="source-code">  "David Bowtie" {</p>
			<p class="source-code">    "The Man Who Mapped the World" {:year 1970, :duration "4:01"}</p>
			<p class="source-code">    "Comma Oddity" {:year 1969, :duration "5:19"}</p>
			<p class="source-code">  }</p>
			<p class="source-code">  "Crosby Stills Hash" {</p>
			<p class="source-code">    "Helplessly Mapping" {:year 1969, :duration "2:38"}</p>
			<p class="source-code">    "Almost Cut My Hair" {:year 1970, :duration "4:29", :featuring ["Neil Young", "Rich Hickey"]}</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">{"David Bowtie" {"The Man Who Mapped the World" {:year 1970, :duration "4:01"}, "Comma Oddity" {:year 1969, :duration "5:19"}}, "Crosby Stills Hash" {"Helplessly Mapping" {:year 1969, :duration "2:38"}, "Almost Cut My Hair" {:year 1970, :duration "4:29", :featuring ["Neil Young" "Rich Hickey"]}}}</p>
			<p>Keys can be of different types too, so you could have strings, numbers, or even other types as a key; however, we generally use keywords.</p>
			<p>Another way of creating a map is by using the <strong class="source-inline">hash-map</strong> function, passing in pairs of arguments as follows:</p>
			<p class="source-code">user=&gt; (hash-map :a 1 :b 2 :c 3)</p>
			<p class="source-code">{:c 3, :b 2, :a 1}</p>
			<p>Choose to use literal notation with curly braces when possible, but when HashMaps are programmatically generated, the <strong class="source-inline">hash-map</strong> function can come in handy.</p>
			<p>Map keys are unique:</p>
			<p class="source-code">user=&gt; {:name "Lucy" :age 32 :name "Jon"}</p>
			<p class="source-code">Syntax error reading source at (REPL:6:35).</p>
			<p class="source-code">Duplicate key: :name</p>
			<p>An exception was thrown because the <strong class="source-inline">:name</strong> key was present twice in the preceding literal map.</p>
			<p>However, different keys can have the same value:</p>
			<p class="source-code">user=&gt; {:name "Lucy" :age 32 :number-of-teeth 32}</p>
			<p class="source-code">{:name "Lucy", :age 32, :number-of-teeth 32}</p>
			<p>Notice that both <strong class="source-inline">age</strong> and <strong class="source-inline">number-of-teeth</strong> have the same value, and that is both valid and convenient, to say the least.</p>
			<p>Now that you know how to create maps, it is time for a bit of practice.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor043"/>Exercise 2.02: Using Maps</h2>
			<p>In this exercise, we will learn how to access and modify simple maps:</p>
			<ol>
				<li value="1">Start your REPL and create a map:<p class="source-code">user=&gt; (def favorite-fruit {:name "Kiwi", :color "Green", :kcal_per_100g 61 :distinguish_mark "Hairy"})</p><p class="source-code">#'user/favorite-fruit</p></li>
				<li>You can read an entry from the map with the <strong class="source-inline">get</strong> function. Try to look up a key or two, as follows:<p class="source-code">user=&gt; (get favorite-fruit :name)</p><p class="source-code">"Kiwi"</p><p class="source-code">user=&gt; (get favorite-fruit :color)</p><p class="source-code">"Green"</p></li>
				<li>If the value for a given key cannot be found, <strong class="source-inline">get</strong> returns <strong class="source-inline">nil</strong>, but you can specify a fallback value with a third argument to <strong class="source-inline">get</strong>:<p class="source-code">user=&gt; (get favorite-fruit :taste)</p><p class="source-code">nil</p><p class="source-code">user=&gt; (get favorite-fruit :taste "Very good 8/10")</p><p class="source-code">"Very good 8/10"</p><p class="source-code">user=&gt; (get favorite-fruit :kcal_per_100g 0)</p><p class="source-code">61</p></li>
				<li>Maps and keywords have the special ability to be used as functions. When positioned in the "operator position" (as the first item of the list), they are invoked as a function that can be used to look up a value in a map. Try it now by using the <strong class="source-inline">favorite-fruit</strong> map as a function:<p class="source-code">user=&gt; (favorite-fruit :color)</p><p class="source-code">"Green"</p></li>
				<li>Try to use a keyword as a function to look up a value in a Map:<p class="source-code">user=&gt; (:color favorite-fruit)</p><p class="source-code">"Green"</p><p>As with the <strong class="source-inline">get</strong> function, those ways of retrieving a value return <strong class="source-inline">nil</strong> when the key cannot be found, and you can pass an extra argument to provide a fallback value.</p></li>
				<li>Provide a fallback value for a key that doesn't exist in the <strong class="source-inline">favorite-fruit</strong> map:<p class="source-code">user=&gt; (:shape favorite-fruit "egg-like")</p><p class="source-code">"egg-like"</p></li>
				<li>We would like to store this value in the map. Use <strong class="source-inline">assoc</strong> to associate a new key, <strong class="source-inline">:shape</strong>, with a new value, <strong class="source-inline">"egg-like"</strong>, in our map:<p class="source-code">user=&gt; (assoc favorite-fruit :shape "egg-like")</p><p class="source-code">{:name "Kiwi", :color "Green", :kcal_per_100g 61, :distinguish_mark "Hairy", :shape "egg-like"}</p><p>The <strong class="source-inline">assoc</strong> operation returns a new map containing our previous key-value pairs as well as the new association we've just added.</p></li>
				<li>Evaluate <strong class="source-inline">favorite-fruit</strong> and notice that it remains unchanged:<p class="source-code">user=&gt; favorite-fruit</p><p class="source-code">{:name "Kiwi", :color "Green", :kcal_per_100g 61, :distinguish_mark "Hairy"}</p><p>Because a map is immutable, the value bound to the <strong class="source-inline">favorite-fruit</strong> symbol has not changed. By using <strong class="source-inline">assoc</strong>, we have created a new version of the map.</p><p>Now, the F3C ("Funny Fruity Fruits Consortium") have reverted their previous ruling and determined during their quarterly review of fruit specifications that the color of the kiwi fruit should be brown and not green. To make sure that your application is F3C compliant, you decide to update your system with the new value.</p></li>
				<li>Change the color of <strong class="source-inline">favorite-fruit</strong> by associating a new value to the <strong class="source-inline">:color</strong> key:<p class="source-code">user=&gt; (assoc favorite-fruit :color "Brown")</p><p class="source-code">{:name "Kiwi", :color "Brown", :kcal_per_100g 61, :distinguish_mark "Hairy"}</p><p><strong class="source-inline">assoc</strong> replaces the existing value when a key already exists, because HashMaps cannot have duplicate keys.</p></li>
				<li>If we wanted to add more structured information, we could add a map as a value. Add production information as a nested map in our <strong class="source-inline">Kiwi</strong> map:<p class="source-code">user=&gt; (assoc favorite-fruit :yearly_production_in_tonnes {:china 2025000 :italy 541000 :new_zealand 412000 :iran 311000 :chile 225000})</p><p class="source-code">{:name "Kiwi", :color "Green", :kcal_per_100g 61, :distinguish_mark "Hairy", :yearly_production_in_tonnes {:china 2025000, :italy 541000, :new_zealand 412000, :iran 311000, :chile 225000}}</p><p>Having nested maps or other data types is commonly used to represent structured information.</p><p><em class="italic">New research has found out that the Kiwi contains fewer calories than previously thought, and to stay compliant, the F3C requires organizations to reduce the current value of kcal per 100 g by 1.</em></p></li>
				<li>Decrement <strong class="source-inline">kcal_per_100g</strong> with the <strong class="source-inline">assoc</strong> function, as follows:<p class="source-code">user=&gt; (assoc favorite-fruit :kcal_per_100g (- (:kcal_per_100g favorite-fruit) 1))</p><p class="source-code">{:name "Kiwi", :color "Green", :kcal_per_100g 60, :distinguish_mark "Hairy"}</p><p>Great! It works, but there is a more elegant way to deal with this type of operation. When you need to change a value in a map based on a previous value, you can use the <strong class="source-inline">update</strong> function. While the <strong class="source-inline">assoc</strong> function lets you associate a completely new value to a key, <strong class="source-inline">update</strong> allows you to compute a new value based on the previous value of a key. The <strong class="source-inline">update</strong> function takes a function as its third parameter.</p></li>
				<li>Decrement <strong class="source-inline">kcal_per_100g</strong> with the <strong class="source-inline">update</strong> function and <strong class="source-inline">dec</strong>, as follows:<p class="source-code">user=&gt; (update favorite-fruit :kcal_per_100g dec)</p><p class="source-code">{:name "Kiwi", :color "Green", :kcal_per_100g 60, :distinguish_mark "Hairy"}</p><p>Notice how the value of <strong class="source-inline">:kcal_per_100g</strong> changed from <strong class="source-inline">61</strong> to <strong class="source-inline">60</strong>.</p></li>
				<li>You can also pass arguments to the function provided to update; for example, if we wanted to lower <strong class="source-inline">:kcal_per_100g</strong> by 10 instead of 1, we could use the subtract function, <strong class="source-inline">-</strong>, and write the following:<p class="source-code">user=&gt; (update favorite-fruit :kcal_per_100g - 10)</p><p class="source-code">{:name "Kiwi", :color "Green", :kcal_per_100g 51, :distinguish_mark "Hairy"}</p><p>Like <strong class="source-inline">assoc</strong>, <strong class="source-inline">update</strong> does not change the immutable map; it returns a new map.</p><p>This example illustrates the power of functions being "first-class citizens": we treat them like typical values; in this case, a function was passed as an argument to another function. We will elaborate on this concept in the next chapter while diving into functions in more depth.</p></li>
				<li>Finally, use <strong class="source-inline">dissoc</strong> (as in "dissociate") to remove one or multiple elements from a map:<p class="source-code">user=&gt; (dissoc favorite-fruit :distinguish_mark)</p><p class="source-code">{:name "Kiwi", :color "Green", :kcal_per_100g 61}</p><p class="source-code">user=&gt; (dissoc favorite-fruit :kcal_per_100g :color)</p><p class="source-code">{:name "Kiwi", :distinguish_mark "Hairy"}</p></li>
			</ol>
			<p>Well done! Now that we know how to use maps, it is time to move on to the next data structure: sets.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor044"/>Sets</h2>
			<p>A set is a collection of unique values. Clojure provides HashSet and SortedSet. Hash Sets are implemented as Hash Maps, with the key and the value of each entry being identical.</p>
			<p>Hash Sets are fairly common in Clojure and have a literal notation of a hash with curly braces, <strong class="source-inline">#{}</strong>, for example:</p>
			<p class="source-code">user=&gt; #{1 2 3 4 5}</p>
			<p class="source-code">#{1 4 3 2 5}</p>
			<p>Notice in the preceding expression that when the set is evaluated, it does not return the elements of the sets in the order that they were defined in the literal expression. This is because of the internal structure of the HashSet. The value is transformed in a unique hash, which allows fast access but does not keep the insertion order. If you care about the order in which the elements are added, you need to use a different data structure, for example, a sequence such as a vector (which we will soon discover). Use a HashSet to represent elements that logically belong together, for example, an enumeration of unique values.</p>
			<p>As with maps, sets cannot have duplicate entries:</p>
			<p class="source-code">user=&gt; #{:a :a :b :c}</p>
			<p class="source-code">Syntax error reading source at (REPL:135:15).</p>
			<p class="source-code">Duplicate key: :a</p>
			<p>Hash Sets can be created from a list of values by passing those values to the <strong class="source-inline">hash-set</strong> function: </p>
			<p class="source-code">user=&gt; (hash-set :a :b :c :d)</p>
			<p class="source-code">#{:c :b :d :a}</p>
			<p>Hash Sets can also be created from another collection with the <strong class="source-inline">set</strong> function. Let's create a HashSet from a vector:</p>
			<p class="source-code">user=&gt; (set [:a :b :c])</p>
			<p class="source-code">#{:c :b :a}</p>
			<p>Notice that the order defined in the vector was lost.</p>
			<p>The <strong class="source-inline">set</strong> function will not throw an error when converting a collection of non-unique values to a set with the <strong class="source-inline">set</strong> function, which can be useful for deduplicating values:</p>
			<p class="source-code">user=&gt; (set ["No" "Copy" "Cats" "Cats" "Please"])</p>
			<p class="source-code">#{"Copy" "Please" "Cats" "No"}</p>
			<p>Notice how one of the duplicate strings, <strong class="source-inline">"Cats"</strong>, was silently removed to create a set.</p>
			<p>A Sorted Set can be created with the <strong class="source-inline">sorted-set</strong> function and have no literal syntax as Hash Sets do:</p>
			<p class="source-code">user=&gt; (sorted-set "No" "Copy" "Cats" "Cats" "Please")</p>
			<p class="source-code">#{"Cats" "Copy" "No" "Please"}</p>
			<p>Notice that they are printed in the same way as Hash Sets, only the order looks different. Sorted Sets are sorted based on the natural order of elements they contain rather than the order of the arguments provided upon creation. You could instead provide your own sorting function, but we will focus on Hash Sets as they are far more common and useful.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor045"/>Exercise 2.03: Using Sets</h2>
			<p>In this exercise, we will use a Hash Set to represent a collection of supported currencies:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A Hash Set is a good choice of data structure for a list of currencies because we typically want to store a collection of unique values and efficiently check for containment. Also, the order of the currencies probably doesn't matter. If you wanted to associate more data to a currency (such as ISO codes and countries), then you would more likely use nested Maps to represent each currency as an entity, keyed by a unique ISO code. Ultimately, the choice of the data structure depends on how you plan to use the data. In this exercise, we simply want to read it, check for containment, and add items to our set.</p>
			<ol>
				<li value="1">Start a REPL. Create a set and bind it to the <strong class="source-inline">supported-currencies</strong> symbol:<p class="source-code">user=&gt; (def supported-currencies #{"Dollar" "Japanese yen" "Euro" "Indian rupee" "British pound"})</p><p class="source-code">#'user/supported-currencies</p></li>
				<li>As with maps, you can use <strong class="source-inline">get</strong> to retrieve an entry from a set, which returns the entry passed as a parameter when present in the set. Use <strong class="source-inline">get</strong> to retrieve an existing entry as well as a missing entry:<p class="source-code">user=&gt; (get supported-currencies "Dollar")</p><p class="source-code">"Dollar"</p><p class="source-code">user=&gt; (get supported-currencies "Swiss franc")</p><p class="source-code">nil</p></li>
				<li>It is likely that you just want to check for containment, and <strong class="source-inline">contains?</strong> is, therefore, semantically better. Use <strong class="source-inline">contains?</strong> instead of <strong class="source-inline">get</strong> to check for containment:<p class="source-code">user=&gt; (contains? supported-currencies "Dollar")</p><p class="source-code">true</p><p class="source-code">user=&gt; (contains? supported-currencies "Swiss franc")</p><p class="source-code">false</p><p>Notice that <strong class="source-inline">contains?</strong> returns a Boolean and that <strong class="source-inline">get</strong> returns the lookup value or <strong class="source-inline">nil</strong> when not found. There is the edge case of looking up <strong class="source-inline">nil</strong> in a set that will return <strong class="source-inline">nil</strong> both when found and not found. In that case, <strong class="source-inline">contains?</strong> is naturally more suitable.</p></li>
				<li>As with maps, sets and keywords can be used as functions to check for containment. Use the <strong class="source-inline">supported-currencies</strong> set as a function to look up a value in the set:<p class="source-code">user=&gt; (supported-currencies "Swiss franc")</p><p class="source-code">nil</p><p><strong class="source-inline">"Swiss franc"</strong> isn't in the <strong class="source-inline">supported-currencies</strong> set; therefore, the preceding return value is <strong class="source-inline">nil</strong>.</p></li>
				<li>If you tried to use the <strong class="source-inline">"Dollar"</strong> string as a function to look itself up in the set, you would get the following error:<p class="source-code">user=&gt; ("Dollar" supported-currencies)</p><p class="source-code">Execution error (ClassCastException) at user/eval7 (REPL:1).</p><p class="source-code">java.lang.String cannot be cast to clojure.lang.IFn</p><p>We cannot use strings as a function to look up a value in a set or a Map. That's one of the reasons why keywords are a better choice in both sets and maps when possible.</p></li>
				<li>To add an entry to a set, use the <strong class="source-inline">conj</strong> function, as in "conjoin":<p class="source-code">user=&gt; (conj supported-currencies "Monopoly Money")</p><p class="source-code">#{"Japanese yen" "Euro" "Dollar" "Monopoly Money" "Indian rupee" "British pound"}</p></li>
				<li>You can pass more than one item to the <strong class="source-inline">conj</strong> function. Try to add multiple currencies to our Hash Set:<p class="source-code">user=&gt; (conj supported-currencies "Monopoly Money" "Gold dragon" "Gil")</p><p class="source-code">#{"Japanese yen" "Euro" "Dollar" "Monopoly Money" "Indian rupee" "Gold dragon" "British pound" "Gil"}</p></li>
				<li>Finally, you can remove one or more items with the <strong class="source-inline">disj</strong> function, as in "disjoin": <p class="source-code">user=&gt; (disj supported-currencies "Dollar" "British pound")</p><p class="source-code">#{"Japanese yen" "Euro" "Indian rupee"}</p></li>
			</ol>
			<p>That's it for sets! If you ever need to, you can find more functions for working with sets in the <strong class="source-inline">clojure.set</strong> namespace (such as union and intersection), but this is more advanced usage, so let's move on to the next collection: vectors.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor046"/>Vectors</h2>
			<p>A vector is another type of collection that is widely used in Clojure. You can think of vectors as powerful immutable arrays. They are collections of values efficiently accessible by their integer index (starting from 0), and they maintain the order of item insertion as well as duplicates.</p>
			<p>Use a vector when you need to store and read elements in order, and when you don't mind duplicate elements. For example, a web browser history could be a good candidate, as you might want to easily go back to the recent pages but also remove older elements using a vector's index, and there would likely be duplicate elements in it. A map or a set wouldn't be of much help in that situation, as you don't have a specific key to look up a value with.</p>
			<p>Vectors have a literal notation with square brackets (<strong class="source-inline">[]</strong>):</p>
			<p class="source-code">user=&gt; [1 2 3]</p>
			<p class="source-code">[1 2 3]</p>
			<p>Vectors can also be created with the <strong class="source-inline">vector</strong> function followed by a list of items as arguments:</p>
			<p class="source-code">user=&gt; (vector 10 15 2 15 0)</p>
			<p class="source-code">[10 15 2 15 0]</p>
			<p>You can create a vector from another collection using the <strong class="source-inline">vec</strong> function; for example, the following expression converts a Hash Set to a vector:</p>
			<p class="source-code">user=&gt; (vec #{1 2 3})</p>
			<p class="source-code">[1 3 2]</p>
			<p>As with other collections, vectors also can contain different types of values:</p>
			<p class="source-code">user=&gt; [nil :keyword "String" {:answers [:yep :nope]}]</p>
			<p class="source-code">[nil :keyword "String" {:answers [:yep :nope]}]</p>
			<p>We can now start practicing.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor047"/>Exercise 2.04: Using Vectors</h2>
			<p>In this exercise, we will discover different ways of accessing and interacting with vectors:</p>
			<ol>
				<li value="1">Start a REPL. You can look up values in a vector using their index (that is, their position in the collection) with the <strong class="source-inline">get</strong> function. Try to use the <strong class="source-inline">get</strong> function with a literal vector:<p class="source-code">user=&gt; (get [:a :b :c] 0)</p><p class="source-code">:a</p><p class="source-code">user=&gt; (get [:a :b :c] 2)</p><p class="source-code">:c</p><p class="source-code">user=&gt; (get [:a :b :c] 10)</p><p class="source-code">nil</p><p>Because vectors start at 0-index, <strong class="source-inline">:a</strong> is at index 0 and <strong class="source-inline">:c</strong> is at index 2. When the lookup fails, <strong class="source-inline">get</strong> returns <strong class="source-inline">nil</strong>.</p></li>
				<li>Let's bind a vector to a symbol to make the practice more convenient:<p class="source-code">user=&gt; (def fibonacci [0 1 1 2 3 5 8])</p><p class="source-code">#'user/fibonacci</p><p class="source-code">user=&gt; (get fibonacci 6)</p><p class="source-code">8</p></li>
				<li>As with maps and sets, you can use the vector as a function to look up items, but for vectors, the parameter is the index of the value in the vector:<p class="source-code">user=&gt; (fibonacci 6)</p><p class="source-code">8</p></li>
				<li>Add the next two values of the Fibonacci sequence to your vector with the <strong class="source-inline">conj</strong> function:<p class="source-code">user=&gt; (conj fibonacci 13 21)</p><p class="source-code">[0 1 1 2 3 5 8 13 21]</p><p>Notice that the items are added to the end of the vector, and the order of the sequence is kept the same.</p></li>
				<li>Each item in the Fibonacci sequence corresponds to the sum of the previous two items. Let's dynamically compute the next item of the sequence:<p class="source-code">user=&gt;</p><p class="source-code">(let [size (count fibonacci)</p><p class="source-code">       last-number (last fibonacci)</p><p class="source-code">       second-to-last-number (fibonacci (- size 2))]</p><p class="source-code">    (conj fibonacci (+ last-number second-to-last-number)))</p><p class="source-code">[0 1 1 2 3 5 8 13]</p><p>In the preceding example, we used <strong class="source-inline">let</strong> to create three local bindings and improve the readability. We used <strong class="source-inline">count</strong> to calculate the size of a vector, <strong class="source-inline">last</strong> to retrieve its last element, <strong class="source-inline">8</strong>, and finally, we used the <strong class="source-inline">fibonacci</strong> vector as a function to retrieve the element at index "size - 2" (which is the value <strong class="source-inline">5</strong> at index <strong class="source-inline">5</strong>).</p></li>
			</ol>
			<p>In the body of the <strong class="source-inline">let</strong> block, we used the local binding to add the two last items to the end of the Fibonacci sequence with <strong class="source-inline">conj</strong>, which returns <strong class="source-inline">13</strong> (which is, indeed, 5 + 8).</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor048"/>Lists</h2>
			<p>Lists are sequential collections, similar to vectors, but items are added to the front (at the beginning). Also, they don't have the same performance properties, and random access by index is slower than with vectors. We mostly use lists to write code and macros, or in cases when we need a <strong class="bold">last-in, first-out</strong> (<strong class="bold">LIFO</strong>) type of data structure (for example, a stack), which can arguably also be implemented with a vector.</p>
			<p>We create lists with the literal syntax, <strong class="source-inline">()</strong>, but to differentiate lists that represent code and lists that represent data, we need to use the single quote, <strong class="source-inline">'</strong>:</p>
			<p class="source-code">user=&gt; (1 2 3)</p>
			<p class="source-code">Execution error (ClassCastException) at user/eval211 (REPL:1).</p>
			<p class="source-code">java.lang.Long cannot be cast to clojure.lang.IFn</p>
			<p class="source-code">user=&gt; '(1 2 3)</p>
			<p class="source-code">(1 2 3)</p>
			<p class="source-code">user=&gt; (+ 1 2 3)</p>
			<p class="source-code">6</p>
			<p class="source-code">user=&gt; '(+ 1 2 3)</p>
			<p class="source-code">(+ 1 2 3)</p>
			<p>In the preceding examples, we can see that a list that is not quoted with <strong class="source-inline">'</strong> throws an error unless the first item of the list can be invoked as a function.</p>
			<p>Lists can also be created with the <strong class="source-inline">list</strong> function:</p>
			<p class="source-code">user=&gt; (list :a :b :c)</p>
			<p class="source-code">(:a :b :c)</p>
			<p>To read the first element of a list, use <strong class="source-inline">first</strong>:</p>
			<p class="source-code">user=&gt; (first '(:a :b :c :d))</p>
			<p class="source-code">:a</p>
			<p>The <strong class="source-inline">rest</strong> function returns the list without its first item:</p>
			<p class="source-code">user=&gt; (rest '(:a :b :c :d))</p>
			<p class="source-code">(:b :c :d)</p>
			<p>We will not talk about iterations and recursion yet, but you could imagine that the combination of <strong class="source-inline">first</strong> and <strong class="source-inline">rest</strong> is all you need to "walk" or go through an entire list: simply by calling <strong class="source-inline">first</strong> on the rest of the list over and over again until there's no rest.</p>
			<p>You cannot use the <strong class="source-inline">get</strong> function with a list to retrieve by index. You could use <strong class="source-inline">nth</strong>, but it is not efficient as the list is iterated or "walked" until it reaches the desired position:</p>
			<p class="source-code">user=&gt; (nth '(:a :b :c :d) 2)</p>
			<p class="source-code">:c</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor049"/>Exercise 2.05: Using Lists</h2>
			<p>In this exercise, we will practice using lists by reading and adding elements to a to-do list.</p>
			<ol>
				<li value="1">Start a REPL and create a to-do list with a list of actions that you need to do, using the <strong class="source-inline">list</strong> function as follows:<p class="source-code">user=&gt; (def my-todo (list  "Feed the cat" "Clean the bathroom" "Save the world"))</p><p class="source-code">#'user/my-todo</p></li>
				<li>You can add items to your list by using the <strong class="source-inline">cons</strong> function, which operates on sequences:<p class="source-code">user=&gt; (cons "Go to work" my-todo)</p><p class="source-code">("Go to work" "Feed the cat" "Clean the bathroom" "Save the world")</p></li>
				<li>Similarly, you can use the <strong class="source-inline">conj</strong> function, which is used because a list is a collection:<p class="source-code">user=&gt; (conj my-todo "Go to work")</p><p class="source-code">("Go to work" "Feed the cat" "Clean the bathroom" "Save the world")</p><p>Notice how the order of the parameters is different. <strong class="source-inline">cons</strong> is available on lists because a list is a sequence, and <strong class="source-inline">conj</strong> is available to use on lists because a list is a collection. <strong class="source-inline">conj</strong> is, therefore, slightly more "generic" and also has the advantage of accepting multiple elements as arguments.</p></li>
				<li>Add multiple elements at once to your list by using the <strong class="source-inline">conj</strong> function:<p class="source-code">user=&gt; (conj my-todo "Go to work" "Wash my socks")</p><p class="source-code">("Wash my socks" "Go to work" "Feed the cat" "Clean the bathroom" "Save the world")</p></li>
				<li>Now it's time to catch up with your task. Retrieve the first element in your to-do list with the <strong class="source-inline">first</strong> function:<p class="source-code">user=&gt; (first my-todo)</p><p class="source-code">"Feed the cat"</p></li>
				<li>Once done, you can retrieve the rest of your tasks with the <strong class="source-inline">rest</strong> function:<p class="source-code">user=&gt; (rest my-todo)</p><p class="source-code">("Clean the bathroom" "Save the world")</p><p>You could imagine then having to call <strong class="source-inline">first</strong> on the rest of the list (if you had to develop a fully blown to-do list application). Because the list is immutable, if you keep calling <strong class="source-inline">first</strong> on the same <strong class="source-inline">my-todo</strong> list, you will end up with the same element, <strong class="source-inline">"Feed the cat"</strong>, over and over again, and also with a happy but very fat cat.</p></li>
				<li>Finally, you can also retrieve a specific element from the list using the <strong class="source-inline">nth</strong> function:<p class="source-code">user=&gt; (nth my-todo 2)</p><p class="source-code">"Save the world"</p><p>However, remember that retrieving an element at a specific position in a list is slower than with vectors because the list has to be "walked" until the <strong class="source-inline">nth</strong> element. In that case, you might be better off using a vector. One final note about <strong class="source-inline">nth</strong> is that it throws an exception when the element at position n is not found.</p></li>
			</ol>
			<p>That is all you need to know about lists for now and we can move on to the next section about collection and sequence abstractions.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor050"/>Collection and Sequence Abstractions</h2>
			<p>Clojure's data structures are implemented in terms of powerful abstractions. You might have noticed that the operations we used on collections are often similar, but behave differently based on the type of the collection. For instance, <strong class="source-inline">get</strong> retrieves items from a map with a key, but from a vector with an index; <strong class="source-inline">conj</strong> adds elements to a vector at the back, but to a list at the front.</p>
			<p>A sequence is a collection of elements in a particular order, where each item follows another. Maps, sets, vectors, and lists are all collections, but only vectors and lists are sequences, although we can easily obtain a sequence from a map or a set.</p>
			<p>Let's go through a few examples of useful functions to use with collections. Consider the following map:</p>
			<p class="source-code">user=&gt; (def language {:name "Clojure" :creator "Rich Hickey" :platforms ["Java" "JavaScript" ".NET"]})</p>
			<p class="source-code">#'user/language</p>
			<p>Use <strong class="source-inline">count</strong> to get the number of elements in a collection. Each element of this map is a key-value pair; therefore, it contains three elements:</p>
			<p class="source-code">user=&gt; (count language)</p>
			<p class="source-code">3</p>
			<p>Slightly more apparent, the following set contains no elements:</p>
			<p class="source-code">user=&gt; (count #{})</p>
			<p class="source-code">0</p>
			<p>We can test whether a collection is empty with the <strong class="source-inline">empty?</strong> function:</p>
			<p class="source-code">user=&gt; (empty? language)</p>
			<p class="source-code">false</p>
			<p class="source-code">user=&gt; (empty? [])</p>
			<p class="source-code">true</p>
			<p>A map is not sequential because there is no logical order between its elements. However, we can convert a map to a sequence using the <strong class="source-inline">seq</strong> function:</p>
			<p class="source-code">user=&gt; (seq language)</p>
			<p class="source-code">([:name "Clojure"] [:creator "Rich Hickey"] [:platforms ["Java" "JavaScript" ".NET"]])</p>
			<p>It yielded a list of vectors or <em class="italic">tuples</em>, which means that there is now a logical order and we can use sequence functions on this data structure:</p>
			<p class="source-code">user=&gt; (nth (seq language) 1)</p>
			<p class="source-code">[:creator "Rich Hickey"]</p>
			<p>A lot of functions just work on collections directly because they can be turned into a sequence, so you could omit the <strong class="source-inline">seq</strong> step and, for example, call <strong class="source-inline">first</strong>, <strong class="source-inline">rest</strong>, or <strong class="source-inline">last</strong> directly on a map or a set:</p>
			<p class="source-code">user=&gt; (first #{:a :b :c})</p>
			<p class="source-code">:c</p>
			<p class="source-code">user=&gt; (rest #{:a :b :c})</p>
			<p class="source-code">(:b :a)</p>
			<p class="source-code">user=&gt; (last language)</p>
			<p class="source-code">[:platforms ["Java" "JavaScript" ".NET"]]</p>
			<p>The value of using sequence functions such as <strong class="source-inline">first</strong> or <strong class="source-inline">rest</strong> on maps and sets seems questionable but treating those collections as sequences means that they can then be iterated. Many more functions are available for processing each item of a sequence, such as <strong class="source-inline">map</strong>, <strong class="source-inline">reduce</strong>, <strong class="source-inline">filter</strong>, and so on. We have dedicated entire chapters to learning about those in the second part of the book so that we can stay focused on the other core functions for now.</p>
			<p><strong class="source-inline">into</strong> is another useful operator that puts elements of one collection into another collection. The first argument for <strong class="source-inline">into</strong> is the target collection:</p>
			<p class="source-code">user=&gt; (into [1 2 3 4] #{5 6 7 8})</p>
			<p class="source-code">[1 2 3 4 7 6 5 8]</p>
			<p>In the preceding example, each element of the <strong class="source-inline">#{5 6 7 8}</strong> set was added into the <strong class="source-inline">[1 2 3 4]</strong> vector. The resulting vector is not in ascending order because Hash Sets are not sorted:</p>
			<p class="source-code">user=&gt; (into #{1 2 3 4} [5 6 7 8])</p>
			<p class="source-code">#{7 1 4 6 3 2 5 8}</p>
			<p>In the preceding example, the <strong class="source-inline">[5 6 7 8]</strong> vector was added to the <strong class="source-inline">#{1 2 3 4}</strong> set. Once again, Hash Sets do not keep insertion order and the resulting set is simply a logical collection of unique values.</p>
			<p>A usage example would be, for example, to deduplicate a vector, just put it into a set:</p>
			<p class="source-code">user=&gt; (into #{} [1 2 3 3 3 4])</p>
			<p class="source-code">#{1 4 3 2}</p>
			<p>To put items into a map, you would need to pass a collection of tuples representing key-value pairs:</p>
			<p class="source-code">user=&gt; (into {} [[:a 1] [:b 2] [:c 3]])</p>
			<p class="source-code">{:a 1, :b 2, :c 3}</p>
			<p>Each item is "conjoined" in the collection, and so it follows the semantic of the target collection for inserting items with <strong class="source-inline">conj</strong>. Elements are added to a list at the front:</p>
			<p class="source-code">user=&gt; (into '() [1 2 3 4])</p>
			<p class="source-code">(4 3 2 1)</p>
			<p>To help you understand <strong class="source-inline">(into '() [1 2 3 4])</strong>, here is a step-by-step representation of what happened:</p>
			<p class="source-code">user=&gt; (conj '() 1)</p>
			<p class="source-code">(1)</p>
			<p class="source-code">user=&gt; (conj '(1) 2)</p>
			<p class="source-code">(2 1)</p>
			<p class="source-code">user=&gt; (conj '(2 1) 3)</p>
			<p class="source-code">(3 2 1)</p>
			<p class="source-code">user=&gt; (conj '(3 2 1) 4)</p>
			<p class="source-code">(4 3 2 1)</p>
			<p>If you want to concatenate collections, <strong class="source-inline">concat</strong> might be more appropriate than <strong class="source-inline">into</strong>. See how they behave differently here:</p>
			<p class="source-code">user=&gt; (concat '(1 2) '(3 4))</p>
			<p class="source-code">(1 2 3 4)</p>
			<p class="source-code">user=&gt; (into '(1 2) '(3 4))</p>
			<p class="source-code">(4 3 1 2)</p>
			<p>A lot of Clojure functions that operate on sequences will return sequences no matter what the input type was. <strong class="source-inline">concat</strong> is one example:</p>
			<p class="source-code">user=&gt; (concat #{1 2 3} #{1 2 3 4})</p>
			<p class="source-code">(1 3 2 1 4 3 2)</p>
			<p class="source-code">user=&gt; (concat {:a 1} ["Hello"])</p>
			<p class="source-code">([:a 1] "Hello")</p>
			<p><strong class="source-inline">sort</strong> is another example. <strong class="source-inline">sort</strong> can rearrange a collection to order its elements. It has the benefit of being slightly more obvious in terms of why you would want a sequence as a result:</p>
			<p class="source-code">user=&gt; (def alphabet #{:a :b :c :d :e :f})</p>
			<p class="source-code">#'user/alphabet</p>
			<p class="source-code">user=&gt; alphabet</p>
			<p class="source-code">#{:e :c :b :d :f :a}</p>
			<p class="source-code">user=&gt; (sort alphabet)</p>
			<p class="source-code">(:a :b :c :d :e :f)</p>
			<p class="source-code">user=&gt; (sort [3 7 5 1 9])</p>
			<p class="source-code">(1 3 5 7 9)</p>
			<p>But what if you wanted a vector as a result? Well, now you know that you could use the <strong class="source-inline">into</strong> function:</p>
			<p class="source-code">user=&gt; (sort [3 7 5 1 9])</p>
			<p class="source-code">(1 3 5 7 9)</p>
			<p class="source-code">user=&gt; (into [] *1)</p>
			<p class="source-code">[1 3 5 7 9]</p>
			<p>It is interesting to note that <strong class="source-inline">conj</strong> can also be used on maps. For its arguments to be consistent with other types of collections, the new entry is represented by a tuple:</p>
			<p class="source-code">user=&gt; (conj language [:created 2007])</p>
			<p class="source-code">{:name "Clojure", :creator "Rich Hickey", :platforms ["Java" "JavaScript" ".NET"], :created 2007}</p>
			<p>Similarly, a vector is an associative collection of key-value pairs where the key is the index of the value:</p>
			<p class="source-code">user=&gt; (assoc [:a :b :c :d] 2 :z)</p>
			<p class="source-code">[:a :b :z :d]</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor051"/>Exercise 2.06: Working with Nested Data Structures</h2>
			<p>For the purpose of this exercise, imagine that you are working with a little shop called "Sparkling," whose business is to trade gemstones. It turns out that the owner of the shop knows a bit of Clojure, and has been using a Clojure REPL to manage the inventory with some kind of homemade database. However, the owner has been struggling to work with nested data structures, and they require help from a professional: you. The shop won't share their database because it contains sensitive data – they have just given you a sample dataset so that you know about the shape of the data.</p>
			<p>The shop owner read a blog post on the internet saying that pure functions are amazing and make for good quality code. So, they asked you to develop some pure functions that take their gemstone database as the first parameter of each function. The owner said you would only get paid if you provide pure functions. In this exercise, we will develop a few functions that will help us understand and operate on nested data structures.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A pure function is a function where the return value is only determined by its input values. A pure function does not have any side effects, which means that it does not mutate a program's state nor generate any kind of I/O.</p>
			<ol>
				<li value="1">Open up a REPL and create the following Hash Map representing the sample gemstone database:<p class="source-code-heading">repl.clj</p><p class="source-code">1  (def gemstone-db {</p><p class="source-code">2      :ruby {</p><p class="source-code">3        :name "Ruby"</p><p class="source-code">4        :stock 480</p><p class="source-code">5        :sales [1990 3644 6376 4918 7882 6747 7495 8573 5097 1712]</p><p class="source-code">6        :properties {</p><p class="source-code">7          :dispersion 0.018</p><p class="source-code">8          :hardness 9.0</p><p class="source-code">9          :refractive-index [1.77 1.78]</p><p class="source-code">10         :color "Red"</p><p class="source-code">11       }</p><p class="source-code">12     }</p><p class="source-code-link">The complete code for this snippet can be found at <a href="https://packt.live/3aD8MgL">https://packt.live/3aD8MgL</a></p><p>One of the most popular questions the shop gets from its customers is about the durability of a gem. This can be found in the properties of a gem, at the <strong class="source-inline">:hardness</strong> key. The first function that we need to develop is <strong class="source-inline">durability</strong>, which retrieves the hardness of a given gem.</p></li>
				<li>Let's start by using a function we already know, <strong class="source-inline">get</strong>, with the <strong class="source-inline">:ruby</strong> gem as an example:<p class="source-code">user=&gt; (get (get (get gemstone-db :ruby) :properties) :hardness)</p><p class="source-code">9.0</p><p>It works, but nesting <strong class="source-inline">get</strong> is not very elegant. We could use the map or keywords as functions and see how it improves the readability.</p></li>
				<li>Use the keywords as a function to see how it improves the readability of our code:<p class="source-code">user=&gt; (:hardness (:properties (:ruby gemstone-db)))</p><p class="source-code">9.0</p><p>This is slightly better. But it's still a lot of nested calls and parentheses. Surely, there must be a better way!</p><p>When you need to fetch data in a deeply nested map such as this one, use the <strong class="source-inline">get-in</strong> function. It takes a vector of keys as parameters and digs in the map with just one function call.</p></li>
				<li>Use the <strong class="source-inline">get-in</strong> function with the <strong class="source-inline">[:ruby :properties :hardness]</strong> vector of parameters to retrieve the deeply nested <strong class="source-inline">:hardness</strong> key:<p class="source-code">user=&gt; (get-in gemstone-db [:ruby :properties :hardness])</p><p class="source-code">9.0</p><p>Great! The vector of keys reads left to right and there is no nested expression. It will make our function a lot more readable.</p></li>
				<li>Create the durability function that takes the database and the <strong class="source-inline">gem</strong> keyword as a parameter and returns the value of the <strong class="source-inline">hardness</strong> property:<p class="source-code">user=&gt;</p><p class="source-code">(defn durability</p><p class="source-code">  [db gemstone]</p><p class="source-code">  (get-in db [gemstone :properties :hardness]))</p><p class="source-code">#'user/durability</p></li>
				<li>Test your newly created function to make sure that it works as expected:<p class="source-code">user=&gt; (durability gemstone-db :ruby)</p><p class="source-code">9.0</p><p class="source-code">user=&gt; (durability gemstone-db :moissanite)</p><p class="source-code">9.5</p><p>Great! Let's move on to the next function.</p><p>Apparently, a ruby is not simply "red" but "Near colorless through pink through all shades of red to a deep crimson." Who would have thought? The owner is now asking you to create a function to update the color of a gem, because they might want to change some other colors too, for marketing purposes. The function needs to return the updated database.</p></li>
				<li>Let's try to write the code to change the color property of a gem. We can try to use <strong class="source-inline">assoc</strong>:<p class="source-code">user=&gt; (assoc (:ruby gemstone-db) :properties {:color "Near colorless through pink through all shades of red to a deep crimson"})</p><p class="source-code">{:name "Ruby", :stock 120, :sales [1990 3644 6376 4918 7882 6747 7495 8573 5097 1712], :properties {:color "Near colorless through pink through all shades of red to a deep crimson"}}</p><p>It seems to work but, all the other properties are gone! We replaced the existing Hash Map at the key property with a new Hash Map that contains only one entry: the color.</p></li>
				<li>We could use a trick. Do you remember the <strong class="source-inline">into</strong> function? It takes a collection and put its values in another collection, like this:<p class="source-code">user=&gt; (into {:a 1 :b 2} {:c 3})</p><p class="source-code">{:a 1, :b 2, :c 3}</p><p>If we use the <strong class="source-inline">update</strong> function combined with <strong class="source-inline">into</strong>, we could obtain the desired result.</p></li>
				<li>Try to use <strong class="source-inline">update</strong> combined with <strong class="source-inline">into</strong> to change the <strong class="source-inline">:color</strong> property of the ruby gem:<p class="source-code">user=&gt; (update (:ruby gemstone-db) :properties into {:color "Near colorless through pink through all shades of red to a deep crimson"})</p><p class="source-code">{:name "Ruby", :stock 120, :sales [1990 3644 6376 4918 7882 6747 7495 8573 5097 1712], :properties {:dispersion 0.018, :hardness 9.0, :refractive-index [1.77 1.78], :color "Near colorless through pink through all shades of red to a deep crimson"}}</p><p>That's great, but there are two problems with this approach. First, the combination of <strong class="source-inline">update</strong> and <strong class="source-inline">into</strong> is not very readable or easy to understand. Second, we wanted to return the entire database, but we just returned the <strong class="source-inline">"Ruby"</strong> entry. We would have to add another operation to update this entry in the main database, perhaps by nesting another <strong class="source-inline">into</strong>, reducing readability even further.</p><p>As with <strong class="source-inline">get-in</strong>, Clojure offers a simpler way of dealing with nested maps: <strong class="source-inline">assoc-in</strong> and <strong class="source-inline">update-in</strong>. They work like <strong class="source-inline">assoc</strong> and <strong class="source-inline">update</strong>, but take a vector of keys (such as <strong class="source-inline">get-in</strong>) as a parameter, instead of a single key.</p><p>You would use <strong class="source-inline">update-in</strong> when you want to update a deeply nested value with a function (for example, to compute the new value with the previous value). Here, we simply want to replace the color with an entirely new value, so we should use <strong class="source-inline">assoc-in</strong>.</p></li>
				<li>Use <strong class="source-inline">assoc-in</strong> to change the <strong class="source-inline">color</strong> property of the ruby gem:<p class="source-code">user=&gt; (assoc-in gemstone-db [:ruby :properties :color] "Near colorless through pink through all shades of red to a deep crimson")</p><p class="source-code">{:ruby {:name "Ruby", :stock 120, :sales [1990 3644 6376 4918 7882 6747 7495 8573 5097 1712], :properties {:dispersion 0.018, :hardness 9.0, :refractive-index [1.77 1.78], :color "Near colorless through pink through all shades of red to a deep crimson"}}, :emerald {:name "Emerald", :stock 85, :sales [6605 2373 104 4764 9023], :properties {:dispersion 0.014, :hardness 7.5, :refractive-index [1.57 1.58], :color "Green shades to colorless"}}, :diamond {:name "Diamond", :stock 10, :sales [8295 329 5960 6118 4189 3436 9833 8870 9700 7182 7061 1579], :properties {:dispersion 0.044, :hardness 10, :refractive-index [2.417 2.419], :color "Typically yellow, brown or gray to colorless"}}, :moissanite {:name "Moissanite", :stock 45, :sales [7761 3220], :properties {:dispersion 0.104, :hardness 9.5, :refractive-index [2.65 2.69], :color "Colorless, green, yellow"}}}</p><p>Notice how <strong class="source-inline">gemstone-db</strong> was returned entirely. Can you notice the value that has changed? There is a lot of data, so it is not very obvious. You can use the <strong class="source-inline">pprint</strong> function to "pretty print" the value.</p><p>Use <strong class="source-inline">pprint</strong> on the last returned value to improve the readability and make sure that our <strong class="source-inline">assoc-in</strong> expression behaved as expected. In a REPL, the last returned value can be obtained with <strong class="source-inline">*1</strong>:</p><div id="_idContainer021" class="IMG---Figure"><img src="image/B14502_02_01.jpg" alt="Figure 2.1: Printing the output to REPL&#13;&#10;"/></div><p class="figure-caption">Figure 2.1: Printing the output to REPL</p><p>That is much more readable. We will not use <strong class="source-inline">pprint</strong> everywhere as it takes a lot of extra space, but you should use it.</p></li>
				<li>Create the <strong class="source-inline">change-color</strong> pure function, which takes three parameters: a database, a gemstone keyword, and a new color. This function updates the color in the given database and returns the new value of the database:<p class="source-code">user=&gt;</p><p class="source-code">(defn change-color</p><p class="source-code">  [db gemstone new-color]</p><p class="source-code">  (assoc-in gemstone-db [gemstone :properties :color] new-color))</p><p class="source-code">#'user/change-color</p></li>
				<li>Test that your newly created function behaves as expected:<p class="source-code">user=&gt; (change-color gemstone-db :ruby "Some kind of red")</p><p class="source-code">{:ruby {:name "Ruby", :stock 120, :sales [1990 3644 6376 4918 7882 6747 7495 8573 5097 1712], :properties {:dispersion 0.018, :hardness 9.0, :refractive-index [1.77 1.78], :color "Some kind of red"}}, :emerald {:name "Emerald", :stock 85, :sales [6605 2373 104 4764 9023], :properties {:dispersion 0.014, :hardness 7.5, :refractive-index [1.57 1.58], :color "Green shades to colorless"}}, :diamond {:name "Diamond", :stock 10, :sales [8295 329 5960 6118 4189 3436 9833 8870 9700 7182 7061 1579], :properties {:dispersion 0.044, :hardness 10, :refractive-index [2.417 2.419], :color "Typically yellow, brown or gray to colorless"}}, :moissanite {:name "Moissanite", :stock 45, :sales [7761 3220], :properties {:dispersion 0.104, :hardness 9.5, :refractive-index [2.65 2.69], :color "Colorless, green, yellow"}}}</p><p>The owner would like to add one last function to record the sale of a gem and update the inventory accordingly.</p><p>When a sale occurs, the shop owner would like to call the <strong class="source-inline">sell</strong> function with the following arguments: a database, a gemstone keyword, and a client ID. <strong class="source-inline">client-id</strong> will be inserted in the <strong class="source-inline">sales</strong> vector and the <strong class="source-inline">stock</strong> value for that gem will be decreased by one. As with the other functions, the new value of the database will be returned so that the client can handle the update themselves.</p></li>
				<li>We can use the <strong class="source-inline">update-in</strong> function in combination with <strong class="source-inline">dec</strong> to decrement (decrease by one) the stock. Let's try it with the diamond gem:<p class="source-code">user=&gt; (update-in gemstone-db [:diamond :stock] dec)</p><p class="source-code">{:ruby {:name "Ruby", :stock 120, :sales [1990 3644 6376 4918 7882 6747 7495 8573 5097 1712], :properties {:dispersion 0.018, :hardness 9.0, :refractive-index [1.77 1.78], :color "Near colorless through pink through all shades of red to a deep crimson"}}, :emerald {:name "Emerald", :stock 85, :sales [6605 2373 104 4764 9023], :properties {:dispersion 0.014, :hardness 7.5, :refractive-index [1.57 1.58], :color "Green shades to colorless"}}, :diamond {:name "Diamond", :stock 9, :sales [8295 329 5960 6118 4189 3436 9833 8870 9700 7182 7061 1579], :properties {:dispersion 0.044, :hardness 10, :refractive-index [2.417 2.419], :color "Typically yellow, brown or gray to colorless"}}, :moissanite {:name "Moissanite", :stock 45, :sales [7761 3220], :properties {:dispersion 0.104, :hardness 9.5, :refractive-index [2.65 2.69], :color "Colorless, green, yellow"}}}</p><p>The output is not very readable, and it is hard to verify that the value was correctly updated. Another useful command to improve readability in the REPL is the <strong class="source-inline">*print-level*</strong> option, which can limit the depth of the data structure printed to the terminal. </p></li>
				<li>Use the <strong class="source-inline">*print-level*</strong> option to set the depth level to <strong class="source-inline">2</strong>, and observe how the result is printed:<p class="source-code">user=&gt; (set! *print-level* 2)</p><p class="source-code">2</p><p class="source-code">user=&gt; (update-in gemstone-db [:diamond :stock] dec)</p><p class="source-code">{:ruby {:name "Ruby", :stock 120, :sales #, :properties #}, :emerald {:name "Emerald", :stock 85, :sales #, :properties #}, :diamond {:name "Diamond", :stock 9, :sales #, :properties #}, :moissanite {:name "Moissanite", :stock 45, :sales #, :properties #}} </p><p>The diamond stock has indeed decreased by 1, from 10 to 9.</p></li>
				<li>We can use the <strong class="source-inline">update-in</strong> function again, this time in combination with <strong class="source-inline">conj</strong> and a <strong class="source-inline">client-id</strong> to add in the <strong class="source-inline">sales</strong> vector. Let's try an example with the diamond gem and <strong class="source-inline">client-id 999</strong>:<p class="source-code">user=&gt; (update-in gemstone-db [:diamond :sales] conj 999)</p><p class="source-code">{:ruby {:name "Ruby", :stock 120, :sales #, :properties #}, :emerald {:name "Emerald", :stock 85, :sales #, :properties #}, :diamond {:name "Diamond", :stock 10, :sales #, :properties #}, :moissanite {:name "Moissanite", :stock 45, :sales #, :properties #}}</p><p>It might have worked, but we cannot see the <strong class="source-inline">sales</strong> vector as the data has been truncated by the <strong class="source-inline">*print-level*</strong> option.</p></li>
				<li>Set <strong class="source-inline">*print-level*</strong> to <strong class="source-inline">nil</strong> to reset the option, and reevaluate the previous expression:<p class="source-code">user=&gt; (set! *print-level* nil)</p><p class="source-code">nil</p><p class="source-code">user=&gt; (update-in gemstone-db [:diamond :sales] conj 999)</p><p class="source-code">{:ruby {:name "Ruby", :stock 120, :sales [1990 3644 6376 4918 7882 6747 7495 8573 5097 1712], :properties {:dispersion 0.018, :hardness 9.0, :refractive-index [1.77 1.78], :color "Near colorless through pink through all shades of red to a deep crimson"}}, :emerald {:name "Emerald", :stock 85, :sales [6605 2373 104 4764 9023], :properties {:dispersion 0.014, :hardness 7.5, :refractive-index [1.57 1.58], :color "Green shades to colorless"}}, :diamond {:name "Diamond", :stock 10, :sales [8295 329 5960 6118 4189 3436 9833 8870 9700 7182 7061 1579 999], :properties {:dispersion 0.044, :hardness 10, :refractive-index [2.417 2.419], :color "Typically yellow, brown or gray to colorless"}}, :moissanite {:name "Moissanite", :stock 45, :sales [7761 3220], :properties {:dispersion 0.104, :hardness 9.5, :refractive-index [2.65 2.69], :color "Colorless, green, yellow"}}}</p><p>Notice that our diamond <strong class="source-inline">sales</strong> vector now contains the value <strong class="source-inline">999</strong>.</p></li>
				<li>Now let's write our pure function, which combines the two operations (updating the stock and the clients):<p class="source-code">(defn sell</p><p class="source-code">  [db gemstone client-id]</p><p class="source-code">  (let [clients-updated-db (update-in db [gemstone :sales] conj client-id)]</p><p class="source-code">    (update-in clients-updated-db [gemstone :stock] dec)))</p></li>
				<li>Test your newly created function by selling a <strong class="source-inline">:moissanite</strong> to <strong class="source-inline">client-id</strong> <strong class="source-inline">123</strong>:<p class="source-code">user=&gt; (sell gemstone-db :moissanite 123)</p><p class="source-code">{:ruby {:name "Ruby", :stock 120, :sales [1990 3644 6376 4918 7882 6747 7495 8573 5097 1712], :properties {:dispersion 0.018, :hardness 9.0, :refractive-index [1.77 1.78], :color "Near colorless through pink through all shades of red to a deep crimson"}}, :emerald {:name "Emerald", :stock 85, :sales [6605 2373 104 4764 9023], :properties {:dispersion 0.014, :hardness 7.5, :refractive-index [1.57 1.58], :color "Green shades to colorless"}}, :diamond {:name "Diamond", :stock 10, :sales [8295 329 5960 6118 4189 3436 9833 8870 9700 7182 7061 1579], :properties {:dispersion 0.044, :hardness 10, :refractive-index [2.417 2.419], :color "Typically yellow, brown or gray to colorless"}}, :moissanite {:name "Moissanite", :stock 44, :sales [7761 3220 123], :properties {:dispersion 0.104, :hardness 9.5, :refractive-index [2.65 2.69], :color "Colorless, green, yellow"}}}</p></li>
			</ol>
			<p>Notice that the <strong class="source-inline">sales</strong> vector of the moissanite entity now contains the value <strong class="source-inline">123</strong>.</p>
			<p>In this exercise, we did not really "update" data but merely derived new data structures from others because of their immutability. Even if we work mostly with immutable data types, Clojure offers simple mechanisms that allow you to persist information. In the following activity, you will create a database that can be read and updated with the techniques acquired in this chapter, and we will even provide a helper function to make the database persistent.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor052"/>Activity 2.01: Creating a Simple In-Memory Database</h2>
			<p>In this activity, we are going to create our own implementation of an in-memory database. After all, if the "Sparkling" shop owner was able to do it, then it shouldn't be a problem for us!</p>
			<p>Our database interface will live in the Clojure REPL. We will implement functions to create and drop tables, as well as to insert and read records.</p>
			<p>For the purposes of this activity, we will provide a couple of helper functions to help you maintain the state of the database in memory:</p>
			<p class="source-code">(def memory-db (atom {}))</p>
			<p class="source-code">(defn read-db [] @memory-db)</p>
			<p class="source-code">(defn write-db [new-db] (reset! memory-db new-db))</p>
			<p>We use an <strong class="source-inline">atom</strong> but you don't need to understand how atoms work for now, as they are explained in great detail later in the book. You just need to know that it will keep a reference to our database in memory, and use two helper functions, <strong class="source-inline">read-db</strong> and <strong class="source-inline">write-db</strong>, to read and persist a Hash Map in memory.</p>
			<p>As guidance, we would like the data structure to have this shape:</p>
			<p class="source-code">{:table-1 {:data [] :indexes {}} :table-2 {:data [] :indexes {}}</p>
			<p>For example, if we used our database in a grocery store to save clients, fruits, and purchases, we can imagine that it would contain the data in this manner:</p>
			<p class="source-code">{</p>
			<p class="source-code">  :clients {</p>
			<p class="source-code">    :data [{:id 1 :name "Bob" :age 30} {:id 2 :name "Alice" :age 24}]</p>
			<p class="source-code">    :indexes {:id {1 0, 2 1}}</p>
			<p class="source-code">    },</p>
			<p class="source-code">  :fruits {</p>
			<p class="source-code">    :data [{:name "Lemon" :stock 10} {:name "Coconut" :stock 3}]</p>
			<p class="source-code">    :indexes {:name {"Lemon" 0, "Coconut" 1}}</p>
			<p class="source-code">  },</p>
			<p class="source-code">  :purchases {</p>
			<p class="source-code">    :data [{:id 1 :user-id 1 :item "Coconut"} {:id 1 :user-id 2 :item "Lemon"}]</p>
			<p class="source-code">    :indexes {:id {1 0, 2 1}}</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Storing data and indexes separately allows multiple indexes to be created without having to duplicate the actual data.</p>
			<p>The <strong class="source-inline">indexes</strong> map stores an association between the index key and its position in the <strong class="source-inline">data</strong> vector for each index key. In the fruits table, "Lemon" is the first record of the <strong class="source-inline">data</strong> vector, so the value in the <strong class="source-inline">:name</strong> index is 0.</p>
			<p>These steps will help you perform the activity:</p>
			<ol>
				<li value="1">Create the helper functions. You can get the Hash Map by executing the <strong class="source-inline">read-db</strong> function with no arguments, and write to the database by executing the <strong class="source-inline">write-db</strong> function with a Hash Map as an argument.</li>
				<li>Start by creating the <strong class="source-inline">create-table</strong> function. This function should take one parameter: the table name. It should add a new key (the table name) at the root of our Hash Map database, and the value should be another Hash Map containing two entries: an empty vector at the <strong class="source-inline">data</strong> key and an empty Hash Map at the <strong class="source-inline">indexes</strong> key.</li>
				<li>Test that your <strong class="source-inline">create-table</strong> function works.</li>
				<li>Create a <strong class="source-inline">drop-table</strong> function such that it takes one parameter as well - the table name. It should remove a table, including all its data and indexes from our database.</li>
				<li>Test that your <strong class="source-inline">drop-table</strong> function works.</li>
				<li>Create an <strong class="source-inline">insert</strong> function. This function should take three parameters: <strong class="source-inline">table</strong>, <strong class="source-inline">record</strong>, and <strong class="source-inline">id-key</strong>. The <strong class="source-inline">record</strong> parameter is a Hash Map, and <strong class="source-inline">id-key</strong> corresponds to a key in the record map that will be used as a unique index. For now, we will not handle cases when a table does not exist or when an index key already exists in a given table.<p>Try to use a <strong class="source-inline">let</strong> block to divide the work of the <strong class="source-inline">insert</strong> function in multiple steps:</p><p>In a <strong class="source-inline">let</strong> statement, create a binding for the value of the database, retrieved with <strong class="source-inline">read-db</strong>.</p><p>In the same <strong class="source-inline">let</strong> statement, create a second binding for the new value of the database (after adding the record in the <strong class="source-inline">data</strong> vector).</p><p>In the same <strong class="source-inline">let</strong> statement, retrieve the index at which the record was inserted by counting the number of elements in the <strong class="source-inline">data</strong> vector.</p><p>In the body of the <strong class="source-inline">let</strong> statement, update the index at <strong class="source-inline">id-key</strong> and write the resulting map to the database with <strong class="source-inline">write-db</strong>.</p></li>
				<li>To verify that your <strong class="source-inline">insert</strong> function works, try to use it multiple times to insert new records. </li>
				<li>Create a <strong class="source-inline">select-*</strong> function that will return all the records of a table passed as a parameter. </li>
				<li>Create a <strong class="source-inline">select-*-where</strong> function that takes three arguments: <strong class="source-inline">table-name</strong>, <strong class="source-inline">field</strong>, and <strong class="source-inline">field-value</strong>. The function should use the index map to retrieve the index of the record in the data vector and return the element. </li>
				<li>Modify the <strong class="source-inline">insert</strong> function to reject any index duplicate. When a record with <strong class="source-inline">id-key</strong> already exists in the <strong class="source-inline">indexes</strong> map, we should not modify the database and print an error message to the user. <p>On completing the activity, the output should be similar to this:</p><p class="source-code">user=&gt; (create-table :fruits)</p><p class="source-code">{:clients {:data [], :indexes {}}, :fruits {:data [], :indexes {}}}</p><p class="source-code">user=&gt; (insert :fruits {:name "Pear" :stock 3} :name)</p><p class="source-code">Record with :name Pear already exists. Aborting</p><p class="source-code">user=&gt; (select-* :fruits)</p><p class="source-code">[{:name "Pear", :stock 3} {:name "Apricot", :stock 30} {:name "Grapefruit", :stock 6}]</p><p class="source-code">user=&gt; (select-*-where :fruits :name "Apricot")</p><p class="source-code">{:name "Apricot", :stock 30}</p></li>
			</ol>
			<p>In this activity, we have used our new knowledge about reading and updating both simple and deeply nested data structures to implement a simple in-memory database. This was not an easy feat – well done!</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 682.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor053"/>Summary</h1>
			<p>In this chapter, we discovered the concept of immutability. We learned about Clojure's simple data types, as well as their implementation on different host platforms. We discovered the most common types of collections and sequences: maps, sets, vectors, and lists. We saw how to use them with generic collections and sequence operations. We learned how to read and update complex structures of nested collections. We also learned about the standard functions for using collection data structures, as well as more advanced usage with deeply nested data structures. In the next chapter, we will learn advanced techniques for working with functions.</p>
		</div>
	</body></html>