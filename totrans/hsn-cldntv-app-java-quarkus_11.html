<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Advanced Application Development</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will explore some advanced features of Quarkus that will help you design and code cutting-edge Quarkus applications. The topics we will learn about will cover different areas of Quarkus API, ranging from advanced configuration options to controlling the life cycle of a Quarkus application and firing time-based events using the Quarkus scheduler.</p>
<p>By the end of this chapter, you will be able to leverage the following advanced features:</p>
<ul>
<li>Using advanced MicroProfile configuration options</li>
<li>Controlling the life cycle events of your services</li>
<li>Scheduling periodic tasks in your services</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You can find the source code for the project in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter08">https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter08</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using advanced configuration options</h1>
                </header>
            
            <article>
                
<p>As we have already learned, Quarkus relies on the MicroProfile Config specification to inject configuration properties into our application. So far, we have used the default configuration file (named <kbd>application.properties</kbd>) to provide initial values for the application's initial settings.</p>
<p>Let's recap with a basic example of how to inject a property, including a default value for the attribute:</p>
<pre>@Inject<br/>@ConfigProperty(name="tempFileName", defaultValue="file.tmp")<br/>String fileName;</pre>
<p>In the preceding code, we are injecting an application property into the <kbd>fileName</kbd> variable. Note that property names should be carefully planned since Quarkus ships with an extensive set of system properties that can be used to manage its environment. Luckily, you don't need to have your documentation at hand to check for all the available system properties. As a matter of fact, you can use Maven's <kbd>generate-config</kbd> command to list all the built-in system properties, based on the extensions that you have currently installed:</p>
<pre><strong>mvn quarkus:generate-config</strong></pre>
<p>This command will create a file named <kbd>application.properties.example</kbd> under the <kbd>src/main/resources</kbd> folder. If you open this file, you will see that it contains a commented list of all the available configuration options, which are located under the <kbd>quarkus</kbd> namespace. Here is a brief excerpt of it:</p>
<pre># The name of the application.<br/># If not set, defaults to the name of the project.<br/>#<br/>#quarkus.application.name=<br/> <br/># The version of the application.<br/># If not set, defaults to the version of the project<br/>#<br/>#quarkus.application.version=</pre>
<p>As a side note, you can choose a different filename for <kbd>generate-command</kbd> by adding the <kbd>-Dfile=&lt;filename&gt;</kbd> option.</p>
<p>In the upcoming sections, we will learn about some advanced configuration drills using the examples located in the <kbd>Chapter08/advanced-config</kbd> folder of <span>this book's</span> GitHub repository as references. We recommend importing the project into your IDE before you move on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple configuration sources</h1>
                </header>
            
            <article>
                
<p>The <kbd>application.properties</kbd> file is not the only option when it comes to setting application properties. As per MicroProfile's Config specification, you can also use the following:</p>
<ul>
<li><strong>Java system properties</strong>: Java system properties can be read/written programmatically by means of the <kbd>System.getProperty()</kbd> and <kbd>System.setProperty()</kbd> APIs. As an alternative, you can set a property on the command line with the <kbd>-D</kbd> option, as follows:</li>
</ul>
<pre class="mce-root" style="padding-left: 60px"><strong><span>java -Dquarkus.http.port=8180 app.jar</span></strong></pre>
<ul>
<li><strong>Environment variables</strong>: This requires setting an environment variable for the property, as follows:</li>
</ul>
<pre class="mce-root" style="padding-left: 60px"><strong><span>export QUARKUS_HTTP_PORT=8180</span></strong></pre>
<p>As you may have noticed, the matching environment variable name has been set to uppercase and the dot has been replaced with an underscore.</p>
<div class="packt_infobox">Please note that, in the current version of Quarkus, it is required that the variable is also defined in <kbd>application.properties</kbd> so that it can be overridden by the environment variable.</div>
<p class="mce-root">Finally, it is also possible to collect our configuration from an external source by adding a new configuration source to our application. The next section will show us how to do this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring custom configuration sources</h1>
                </header>
            
            <article>
                
<p class="mce-root">In all the examples we've created so far, we have assumed that the application configuration is picked up from the <kbd>src/main/resources/application.properties</kbd> file, which is the default for Quarkus applications. Nevertheless, since Quarkus fully supports the <strong>MicroProfile Config</strong> specification, it is entirely possible to load the configuration from another source, which could be an external filesystem, a database, or anything that can be loaded by a Java application!</p>
<p>In order to do that, you have to implement the <kbd>org.eclipse.microprofile.config.spi.ConfigSource</kbd> interface, which exposes a set of methods for loading properties (<kbd>getProperties</kbd>), retrieving the properties' names (<kbd>getPropertyNames</kbd>), and retrieving the corresponding value (<kbd>getValue</kbd>).</p>
<p>As proof of concept, take a look at the following implementation, which is available in the <kbd>Chapter08/advanced-config</kbd> project:</p>
<pre class="mce-root">public class FileConfigSource implements ConfigSource {<br/>    private final String CONFIG_FILE = "/tmp/config.properties";<br/>    private final String CONFIG_SOURCE_NAME = "ExternalConfigSource";<br/>    private final int ORDINAL = 900;<br/><br/>    @Override<br/>    public Map getProperties() {<br/><br/>        try(InputStream in = new FileInputStream( CONFIG_FILE )){<br/><br/>            Properties properties = new Properties();<br/>            properties.load( in );<br/><br/>            Map map = new HashMap();<br/>            properties.stringPropertyNames()<br/>                    .stream()<br/>                    .forEach(key-&gt; map.put(key, <br/>                     properties.getProperty(key)));<br/><br/>            return map;<br/><br/>        } catch (IOException e) {<br/>            e.printStackTrace();<br/>        }<br/><br/>        return null;<br/>    }<br/><br/>    @Override<br/>    public Set getPropertyNames() {<br/><br/>        try(InputStream in = new FileInputStream( CONFIG_FILE )){<br/><br/>            Properties properties = new Properties();<br/>            properties.load( in );<br/><br/>            return properties.stringPropertyNames();<br/><br/>        } catch (IOException e) {<br/>            e.printStackTrace();<br/>        }<br/><br/>        return null;<br/>    }<br/><br/>    @Override<br/>    public int getOrdinal() {<br/>        return ORDINAL;<br/>    }<br/><br/>    @Override<br/>    public String getValue(String s) {<br/><br/>        try(InputStream in = new FileInputStream( CONFIG_FILE )){<br/>            Properties properties = new Properties();<br/>            properties.load( in );<br/>            return properties.getProperty(s);<br/><br/>        } catch (IOException e) {<br/>            e.printStackTrace();<br/>        }<br/><br/>        return null;<br/>    }<br/><br/>    @Override<br/>    public String getName() {<br/>        return CONFIG_SOURCE_NAME;<br/>    }<br/>}</pre>
<p>The code itself is pretty simple if you are familiar with the <kbd>java.io</kbd> API. The <kbd>FileConfigSource</kbd> class attempts to load an external configuration from the <kbd>/tmp/config.properties</kbd> path of your filesystem. It is worth mentioning that an <kbd>ORDINAL</kbd> variable has been set to specify the order for this <kbd>ConfigSource</kbd> class in case some properties are loaded from multiple sources.</p>
<p>The default value for a <kbd>ConfigSource</kbd> is set to <kbd>100</kbd>, and sources with the highest ordinal value have priority in case the property is defined across multiple sources. Here is the ranking of the available configuration sources:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Config source</strong></td>
<td><strong>Value</strong></td>
</tr>
<tr>
<td><kbd>application.properties</kbd></td>
<td><kbd>100</kbd></td>
</tr>
<tr>
<td>Environment variables</td>
<td><kbd>300</kbd></td>
</tr>
<tr>
<td>System properties</td>
<td><kbd>400</kbd></td>
</tr>
</tbody>
</table>
<p>Since we have set the <kbd>ORDINAL</kbd> variable to <kbd>900</kbd> in our example, it will prevail over the other configuration sources, if any.</p>
<p>Once the custom <kbd>ConfigSource</kbd> is available in the project, we need to register for this class. For this purpose, we have added a file named <kbd>org.eclipse.microprofile.config.spi.ConfigSource</kbd> under the <kbd>resources/META-INF/services</kbd> folder of the project. Here's a tree view of the project, under the <kbd>resources</kbd> folder:</p>
<pre>│   └── resources<br/>│       └── META-INF<br/>│               └── services<br/>│                   ├── org.eclipse.microprofile.config.spi.ConfigSource</pre>
<p> Within this file, we have specified the fully qualified name of <kbd>ConfigSource</kbd>. In our case, this is as follows:</p>
<pre>com.packt.chapter8.FileConfigSource</pre>
<p>Now, as soon as the application is started, the custom <kbd>ConfigSource</kbd> will be loaded and its properties will prevail over other potential duplicates of the same attributes.</p>
<p>Within the <kbd>AdvancedConfigTest</kbd> class of your project, you will find one assertion, which verifies that one property has been loaded from the external <kbd>FileConfigSource</kbd> class:</p>
<pre>given()<br/>        .when().get(<span>"/hello"</span>)<br/>        .then()<br/>        .statusCode(<span>200</span>)<br/>        .body(is(<span>"custom greeting"</span>))<span>;</span></pre>
<p>More details about the <kbd>AdvancedConfigTest</kbd> class will be discussed later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using converters in your configuration</h1>
                </header>
            
            <article>
                
<p>To discuss configuration converters, let's take this simple configuration example:</p>
<pre><span>year</span><span>=</span><span>2019<br/></span><span>isUser</span><span>=</span><span>true</span></pre>
<p>Here, it's perfectly fine to inject the preceding properties into our code:</p>
<pre><span>@ConfigProperty</span>(<span>name </span>= <span>"year"</span><span>, </span><span>defaultValue </span>= <span>"2020"</span>)<br/>Integer <span>year</span><span>;<br/></span><span><br/></span><span>@ConfigProperty</span>(<span>name </span>= <span>"isUser"</span><span>, </span><span>defaultValue </span>= <span>"false"</span>)<br/>Boolean <span>isUser</span><span>;</span></pre>
<p>Under the hood, the MicroProfile Config API provides a type-safe conversion for values that are not just plain strings.</p>
<div class="packt_infobox">Also, note that we can provide a default value for a property, which will be used if the property hasn't been defined in our configuration.</div>
<p>This happens by providing converters in the configuration model. Out of the box, some converters are already provided by the MicroProfile Config API by default. Here's a list of the built-in converters:</p>
<ul>
<li><kbd>boolean</kbd> and <kbd>java.lang.Boolean</kbd>. The following values are converted into Booleans (case-insensitive): <kbd>true</kbd>, <kbd>YES</kbd>, <kbd>Y</kbd>, <kbd>1</kbd>, and <kbd>ON</kbd>. Any other value will be <kbd>false</kbd>.</li>
<li><kbd>byte</kbd> and <kbd>java.lang.Byte</kbd>.</li>
<li><kbd>short</kbd> and <kbd>java.lang.Short</kbd>.</li>
<li><kbd>int</kbd> and <kbd>java.lang.Integer</kbd>.</li>
<li><kbd>long</kbd> and <kbd>java.lang.Long</kbd>.</li>
<li><kbd>float</kbd> and <kbd>java.lang.Float</kbd>. A dot <kbd>.</kbd> is used to separate the fractional digits.</li>
<li><kbd>double</kbd> and <kbd>java.lang.Double</kbd>. A dot <kbd>.</kbd> is used to separate the fractional digits.</li>
<li><kbd>char</kbd> and <kbd>java.lang.Character</kbd>.</li>
<li><kbd>java.lang.Class</kbd>. This is based on the result of <kbd>Class.forName</kbd>.</li>
</ul>
<p>Array, list, and set are also supported. In order to inject one of these Collections into a class variable, you can use the comma (<kbd>,</kbd>) char as a delimiter and <kbd>\</kbd> as the escape character. For example, take the following configuration:</p>
<pre><span>students</span><span>=</span><span>Tom,Pat,Steve,Lucy</span></pre>
<p>The following code will inject the preceding configuration into a <kbd>java.util.List</kbd> element:</p>
<pre><span>@ConfigProperty</span>(<span>name </span>= <span>"students"</span>)<br/>List&lt;String&gt; <span>studentList</span><span>;</span></pre>
<p>In much the same way, you can use built-in converters to generate an <kbd>Array</kbd> from a list of values. Take a look at the following configuration example:</p>
<pre><span>pets</span><span>=</span><span>dog,cat,bunny</span></pre>
<p class="mce-root">The preceding configuration can be injected into an array of strings as follows:</p>
<pre><span>@ConfigProperty</span>(<span>name </span>= <span>"pets"</span>)<br/>String[] <span>petsArray</span><span>;</span></pre>
<p>Even classes can be injected as part of the configuration:</p>
<pre><span>myclass</span><span>=</span><span>TestClass</span></pre>
<p>At runtime, the class will be searched by the class loader and created using the <kbd>Class.forName</kbd> construct. We can put it in our code as follows:</p>
<pre><span>@ConfigProperty</span>(<span>name </span>= <span>"myclass"</span>)<br/>TestClass <span>clazz</span><span>;</span></pre>
<p>Finally, it's worth mentioning that you can inject the whole <kbd>Config</kbd> object and retrieve the single properties each time you need them:</p>
<pre><span>@Inject<br/></span>Config <span>config</span><span>;<br/><br/></span><span>@GET<br/></span><span>@Produces</span>(MediaType.<span>TEXT_PLAIN</span>)<br/><span>public </span>String <span>hello</span>() {<br/>    Integer y = <span>config</span>.getValue(<span>"year"</span><span>, </span>Integer.<span>class</span>)<span>;<br/></span><span>    return </span><span>"Year is " </span>+y<span>;<br/></span>}</pre>
<p>Now, let's explore some more advanced strategies for creating type converters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding custom converters</h1>
                </header>
            
            <article>
                
<p>If the list of built-in converters is not enough, you can still create custom converters by implementing the generic interface, that is, <kbd>org.eclipse.microprofile.config.spi.Converter</kbd>. The <kbd>Type</kbd> parameter of the interface is the target type the string is converted into:</p>
<pre><span>public class </span>MicroProfileCustomValueConverter <span>implements </span>Converter&lt;CustomConfigValue&gt; {<br/><br/>    <span>public </span><span>MicroProfileCustomValueConverter</span>() {<br/>    }<br/><br/>    <span>@Override</span><span><br/></span><span>    </span><span>public </span>CustomConfigValue <span>convert</span>(String value) {<br/>        <span>return new </span>CustomConfigValue(value)<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>The following code is for the target <kbd>Type</kbd> parameter, which derives from a plain Java string that we have included in the configuration:</p>
<pre><span>public class </span>CustomConfigValue {<br/>    <br/>    <span>private final </span>String <span>email</span><span>;<br/></span><span>    private final </span>String <span>user</span><span>;<br/></span><span><br/></span><span>    public </span><span>CustomConfigValue</span>(String value) {<br/><br/>        StringTokenizer st = <span>new </span>StringTokenizer(value<span>,</span><span>";"</span>)<span>;<br/></span><span>        this</span>.<span>user </span>= st.nextToken()<span>;<br/></span><span>        this</span>.<span>email </span>= st.nextToken()<span>;</span><span>       <br/></span><span>    </span>}<br/><br/>    <span>public </span>String <span>getEmail</span>() {<br/>        <span>return </span><span>email</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public </span>String <span>getUser</span>() {<br/>        <span>return </span><span>user</span><span>;<br/></span><span>    </span>}</pre>
<p>You have to register your converter in a file named <kbd>resources/META-INF/services/org.eclipse.microprofile.config.spi.Converter</kbd>. Include the fully qualified class name of the custom implementation. For example, in our case, we have added the following line:</p>
<pre>com.packt.chapter8.MicroProfileCustomValueConverter</pre>
<p>Now, let's learn how to use our custom converter in practice. To do that, we will add the following line to the <kbd>application.properties</kbd> file, which uses the pattern coded in the constructor of the <kbd>CustomConfigValue</kbd> class:</p>
<pre><span>customconfig</span><span>=</span><span>john;johnsmith@gmail.com</span></pre>
<p>Now, the custom converter can be injected into our code as a class attribute:</p>
<pre><strong><span>@ConfigProperty</span>(<span>name </span>= <span>"customconfig"</span>)</strong><br/><strong>CustomConfigValue <span>value</span></strong><span><strong>;</strong><br/><br/></span><span>@Path</span>(<span>"/email"</span>)<br/><span>@GET<br/></span><span>@Produces</span>(MediaType.<span>TEXT_PLAIN</span>)<br/><span>public </span>String <span>getEmail</span>() {<br/>    <span>return </span><span>value</span>.getEmail()<span>;<br/></span>}</pre>
<p class="mce-root">Although the preceding example does nothing fancy, it shows us how we can create a customized property based on class definitions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing advanced configuration options</h1>
                </header>
            
            <article>
                
<p>Within the <kbd>Chapter08/advanced-config/src/test</kbd> folder of this chapter, you will find a test class named <kbd>AdvancedConfigTest</kbd>, which will verify the key concepts that we've learned about so far.</p>
<p>To run all of these tests successfully, copy the <kbd>customconfig.properties</kbd> file into the <kbd>/tmp</kbd> folder of your drive, otherwise one of the assertions contained in the <kbd>AdvancedConfigTest</kbd> class will fail:</p>
<pre><strong>cp Chapter08/customconfig.properties /tmp</strong></pre>
<p>Then, simply run the <kbd>install</kbd> goal, which will trigger the test's execution:</p>
<pre><strong>mvn install</strong></pre>
<p>You should see that all the tests contained in <kbd>AdvancedConfigTest</kbd> pass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration profiles</h1>
                </header>
            
            <article>
                
<p>We have just learned how to create complex configurations using built-in converters and, for the most demanding, custom converters. What about if we need to switch between different configurations, for example, when moving from a development environment to a production one? Here, you can duplicate your configuration. However, the proliferation of configuration files is not always welcome in IT projects. Let's learn how to deal with this concern using <strong>configuration profiles</strong>.</p>
<p>In a nutshell, configuration profiles allow us to specify namespaces for our profiles in our configuration so that we can bind each property to a specific profile in the same file.</p>
<p>Out of the box, Quarkus ships with the following configuration profiles:</p>
<ul>
<li><kbd>dev</kbd>: This is triggered when running in development mode (that is, <kbd>quarkus:dev</kbd>).</li>
<li><kbd>test</kbd>: This is triggered when running tests.</li>
<li><strong><kbd>prod</kbd></strong>: This is picked up when we're not running in development or test mode.</li>
</ul>
<div class="packt_infobox">Besides the preceding profiles, you can define your own custom profiles, which will be activated according to the rules we specified in the <em>Activating profiles</em> section.</div>
<p>You can use the following syntax to bind a configuration parameter to a specific profile:</p>
<pre>%{profile}.config.key=value</pre>
<p>To see a practical example of this, we will go through the source code in the <kbd>Chapter08/profiles</kbd> folder of this book's GitHub repository. We recommend importing the project into your IDE before you move on.</p>
<p>Let's start by checking its <kbd>application.properties</kbd> configuration file, which defines multiple profiles:</p>
<pre class="mce-root">%dev.quarkus.datasource.url=jdbc:postgresql://localhost:5432/postgresDev<br/>%test.quarkus.datasource.url=jdbc:postgresql://localhost:6432/postgresTest<br/>%prod.quarkus.datasource.url=jdbc:postgresql://localhost:7432/postgresProd<br/> <br/>quarkus.datasource.driver=org.postgresql.Driver<br/>quarkus.datasource.username=quarkus<br/>quarkus.datasource.password=quarkus<br/> <br/>quarkus.datasource.initial-size=1<br/>quarkus.datasource.min-size=2<br/>quarkus.datasource.max-size=8<br/><br/>%prod.quarkus.datasource.initial-size=10<br/>%prod.quarkus.datasource.min-size=10<br/>%prod.quarkus.datasource.max-size=20</pre>
<p>In the preceding configuration, we have specified three different JDBC URLs for our data source connection. Each one is bound to a different profile. We have also set a specific connection pool setting for the production profile in order to grant a larger number of database connections. In the next section, we will learn how to activate every single profile.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activating profiles</h1>
                </header>
            
            <article>
                
<p>Let's learn how to activate a specific profile by taking the <kbd>prod</kbd> profile in the preceding configuration as an example. First of all, we need to start a PostgreSQL instance named <kbd>postgresProd</kbd> and bind it to port <kbd>7432</kbd>:</p>
<pre><strong>docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_Prod -e POSTGRES_USER=quarkus -e POSTGRES_PASSWORD=quarkus -e POSTGRES_DB=postgresProd -e PGPORT=7432 -p 7432:7432 postgres:10.5</strong></pre>
<p class="mce-root">Then, we need to provide profile information during the <kbd>package</kbd> phase, as follows:</p>
<pre class="mce-root"><strong>mvn clean package -Dquarkus.profile=prod -DskipTests=true</strong></pre>
<p>When running the application, it will pick up the profile you specified in the <kbd>package</kbd> phase:</p>
<pre><strong>java -jar target/profiles-demo-1.0-SNAPSHOT-runner.jar</strong></pre>
<p>As an alternative, it is also possible to specify the profile using the <kbd>QUARKUS_PROFILE</kbd> environment variable, like so:</p>
<pre><strong>export QUARKUS_PROFILE=dev</strong><br/><strong>java -jar target/profiles-demo-1.0-SNAPSHOT-runner.jar</strong></pre>
<p>Finally, it's worth mentioning that the same strategy can be used to define non standard profiles. For example, let's say we want to add a <strong>staging</strong> profile for applications that need to be checked before production:</p>
<pre class="mce-root">%staging.quarkus.datasource.url=jdbc:postgresql://localhost:8432/postgresStage</pre>
<p>Here, we can apply the same strategy we've used for other profiles, that is, we can either specify the profile at application startup using the Java system property (<kbd>quarkus-profile</kbd>) or add the necessary information to the <kbd>QUARKUS_PROFILE</kbd> environment variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automatic profile selection</h1>
                </header>
            
            <article>
                
<p>To simplify development and testing, the <kbd>dev</kbd> and <kbd>test</kbd> profiles can be automatically triggered by the Maven plugin. So, for example, if you are executing Quarkus in development mode, the <kbd>dev</kbd> profile will be used eventually:</p>
<pre><strong>mvn quarkus:dev</strong></pre>
<p>In much the same way, the <kbd>test</kbd> profile will be activated when tests are executed, for example, during the <kbd>install</kbd> life cycle phase:</p>
<pre><strong>mvn quarkus:install</strong></pre>
<p class="mce-root">The <kbd>test</kbd> profile will be activated when you execute the Maven <kbd>test</kbd> goal. Additionally, it's worth knowing that you can set a different profile for your tests through <kbd>maven-surfire-plugin</kbd>, within its system properties:</p>
<pre>&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br/>&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;<br/>&lt;version&gt;${surefire-plugin.version}&lt;/version&gt;<br/>&lt;configuration&gt;<br/>    &lt;systemPropertyVariables&gt;<br/>        <strong>&lt;quarkus.test.profile&gt;custom-test&lt;/quarkus.test.profile&gt;</strong><br/>        &lt;buildDirectory&gt;${project.build.directory}&lt;/buildDirectory&gt;<br/>    &lt;/systemPropertyVariables&gt;<br/>&lt;/configuration&gt;</pre>
<p>In this section, we walked through application profiles. In the next section, we'll learn how to control the life cycle of our Quarkus applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling the application life cycle</h1>
                </header>
            
            <article>
                
<p>Controlling the application life cycle is a common requirement for your services to be able to bootstrap some external resources or verify the status of your components. One simple strategy, borrowed from the Java Enterprise API, is to include the <strong>Undertow</strong> extension (or any upper layer, such as rest services) so that you can leverage <kbd>ServletContextListener</kbd>, which is notified when a web application is created or destroyed. Here is a minimal implementation of it:</p>
<pre class="mce-root">public final class ContextListener implements ServletContextListener {<br/><br/>    private ServletContext context = null;<br/><br/>    public void contextInitialized(ServletContextEvent event) {<br/>        context = event.getServletContext();<br/>        System.out.println("Web application started!");<br/><br/>    }<br/>    public void contextDestroyed(ServletContextEvent event) {<br/>       context = event.getServletContext();<br/>       System.out.println("Web application stopped!");<br/><br/>    }<br/>}</pre>
<p>Although it is perfectly fine to reuse this strategy in a Quarkus web application, it is recommended to use this approach for any kind of Quarkus service. This can be done by observing the <kbd>io.quarkus.runtime.StartupEvent</kbd> and <kbd>io.quarkus.runtime.ShutdownEvent</kbd> events. Additionally, in CDI applications, you can observe an event with the <span class="blob-code-inner blob-code-marker"><kbd>@Initialized(ApplicationScoped.class)</kbd> qualifier, which is fired when the application context is initialized. This can be particularly useful for bootstrapping resources such as databases, which are required before the configuration is read by Quarkus.</span></p>
<p>To see a practical example of this, check the source code that's available in the <kbd>Chapter08/lifecycle</kbd> folder of this book's GitHub repository. As usual, it's advised to import the project into your IDE before you move on. The purpose of this example is to show you how to replace the PostgreSQL database, in our customer service, with the H2 database (<a href="https://www.h2database.com/">https://www.h2database.com/</a>).</p>
<p>Starting with the configuration, the life cycle project doesn't contain the PostgreSQL JDBC dependency anymore. To replace this, the following one has been included:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.quarkus<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>quarkus-jdbc-h2<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>To test our customer service, we have included two H2 database configuration profiles: one that's bound to the <kbd>dev</kbd> profile and one that's bound to the <kbd>test</kbd> profile:</p>
<pre><span>%dev.quarkus.datasource.url</span><span>=</span><span>jdbc:h2:tcp://localhost:19092/mem:test<br/></span><span>%test.quarkus.datasource.url</span><span>=</span><span>jdbc:h2:tcp://localhost/mem:test<br/></span><span>quarkus.datasource.driver</span><span>=</span><span>org.h2.Driver</span></pre>
<p>To bind the H2 database before the application context is started, we can use the following <kbd>DBLifeCycleBean</kbd> class:</p>
<pre>@ApplicationScoped<br/><span>public class </span>DBLifeCycleBean {<br/><br/>    <span>protected final </span>Logger log = <br/>     LoggerFactory.getLogger(<span>this</span>.getClass())<span>;<br/></span><span><br/></span><span>    </span><span>// H2 Database<br/></span><span>    </span><span>private </span>Server tcpServer<span>;<br/></span><span><br/></span><span>    public void </span>observeContextInit(@Observes <br/>     @Initialized(ApplicationScoped.<span>class</span>) Object event) {<br/>        <span>try </span>{<br/>            tcpServer =  Server.createTcpServer(<span>"-tcpPort"</span><span>,<br/>             </span><span>"19092"</span><span>, </span><span>"-tcpAllowOthers"</span>).start()<span>;<br/></span><span>            </span>log.info(<span>"H2 database started in TCP server <br/>            mode on Port 19092"</span>)<span>;</span><span><br/></span><span>        </span>} <span>catch </span>(SQLException e) {<br/><br/>            <span>throw new </span>RuntimeException(e)<span>;<br/></span><span><br/></span><span>        </span>}<br/>    }<br/>    <span>void </span>onStart(@Observes StartupEvent ev) {<br/>        log.info(<span>"Application is starting"</span>)<span>;</span><span><br/></span><span>    </span>}<br/><br/>    <span>void </span>onStop(@Observes ShutdownEvent ev) {<br/>        <span>if </span>(tcpServer != <span>null</span>) {<br/>            tcpServer.stop()<span>;<br/></span><span>            </span>log.info(<span>"H2 database was shut down"</span>)<span>;<br/></span><span>            </span>tcpServer = <span>null;</span><span><br/></span><span>        </span>}<br/>    }<br/>}</pre>
<p>This class is able to intercept the following events:</p>
<ul>
<li><strong>Context startup</strong>: This is captured through the <kbd>observeContextInit</kbd> method. The database is bootstrapped in this method.</li>
<li><strong>Application startup</strong>: This is captured through the <kbd>onStart</kbd> method. We are simply performing some logs when this event is fired.</li>
<li><strong>Application shutdown</strong>: This is captured through the <kbd>onStop</kbd> method. We are shutting down the database in this method.</li>
</ul>
<p>Now, you can start Quarkus in the <kbd>dev</kbd> profile as usual with the following command:</p>
<pre><strong>mvn quarkus:dev</strong></pre>
<p>When the application is started, we will be notified that the H2 database has been started:</p>
<pre class="mce-root"><strong>INFO  [com.pac.qua.cha.DBLifeCycleBean] (main) H2 database started in TCP server mode on Port 19092</strong></pre>
<p>Then, we will receive one more notification on application startup, where we can include some extra tasks to be completed:</p>
<pre><strong>[com.pac.qua.cha.DBLifeCycleBean] (main) Application is starting</strong></pre>
<p>Finally, when we stop the application, the resource will be dismissed, as shown in the following console logs:</p>
<pre><strong>[com.pac.qua.cha.DBLifeCycleBean] (main) H2 database was shut down</strong></pre>
<p>Before shutting down the database, you can enjoy running your customer service example with a tiny in-memory database layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activating a database test resource</h1>
                </header>
            
            <article>
                
<p>As a bonus tip, we will show you how to activate the H2 database during the test life cycle. This can be done by adding a class, annotated as <kbd>@QuarkusTestResource</kbd>, to your test classes while passing the <kbd>H2DatabaseTestResource</kbd> class as an attribute.</p>
<p>Here is an example:</p>
<pre>@QuarkusTestResource(H2DatabaseTestResource.<span>class</span>)<br/><span>public class </span>TestResources {<br/>}</pre>
<p><kbd>H2DatabaseTestResource</kbd> basically performs the same actions that <kbd>DBLifeCycleBean</kbd> does, before our tests are fired. Note that the following dependency has been added into the project to run the preceding test class:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.quarkus<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>quarkus-test-h2<span>&lt;/artifactId&gt;<br/></span><span>  &lt;scope&gt;</span>test<span>&lt;/scope&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>Now, you can safely run tests against the <kbd>test</kbd> profile with the following command:</p>
<pre><strong>mvn install</strong></pre>
<p>Note that, before our tests are executed, the following log will confirm that the H2 database has been started on one of our available IP addresses:</p>
<pre><strong>[INFO] H2 database started in TCP server mode; server status: TCP server  running at tcp://10.5.126.52:9092 (only local connections)</strong></pre>
<p>Bootstrapping external resources is indeed a common use case for life cycle managers. Another frequent use case consists of scheduling events at the application startup phase. In the next section, we will discuss how to fire events using Quarkus' scheduler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Firing events with the Quarkus scheduler</h1>
                </header>
            
            <article>
                
<p>Quarkus includes an extension called <strong>scheduler</strong>, which can be used to schedule tasks for single or repeated execution. We can use the cron format to specify the number of times the scheduler fires the event.</p>
<p>The source code for the following example is located in the <kbd>Chapter08/scheduler</kbd> folder of <span>this book's</span> GitHub repository. If you check the <kbd>pom.xml</kbd> file, you will notice that the following extension has been added to it:</p>
<pre>&lt;dependency&gt;<br/>      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>      &lt;artifactId&gt;quarkus-scheduler&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Our sample project generates a random token (for the sake of simplicity, a random string is used) every 30 seconds. The class that's in charge of generating random tokens is the following <kbd>TokenGenerator</kbd> class:</p>
<pre>@ApplicationScoped<br/>public class TokenGenerator {<br/><br/>    private String token;<br/><br/>    public String getToken() {<br/>        return token;<br/>    }<br/><br/>    @Scheduled(every="30s")<br/>    void generateToken() {<br/>        token= UUID.randomUUID().toString();<br/>        log.info("New Token generated"); <br/>    }<br/><br/>}</pre>
<p>Now, we can have our token injected into the built-in REST endpoint, as follows:</p>
<pre>@Path("/token")<br/>public class Endpoint {<br/><br/>    @Inject<br/>    TokenGenerator token;<br/><br/>    @GET<br/>    @Produces(MediaType.TEXT_PLAIN)<br/>    public String getToken() {<br/><br/>        return token.getToken();<br/>    }<br/>}</pre>
<p>Start the application as usual with the following command:</p>
<pre><strong>mvn quarkus:dev</strong></pre>
<p>You will notice that, every 30 seconds, the following message is printed in the console logs:</p>
<pre><strong>[INFO] New Token generated</strong></pre>
<p>Then, by requesting the <kbd>/token</kbd> URL, the randomly generated string will be returned:</p>
<pre><strong>curl http://localhost:8080/token</strong><br/><strong> 3304a8de-9fd7-43e7-9d25-6e8896ca67dd</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the cron scheduler format</h1>
                </header>
            
            <article>
                
<p>Besides using time expressions (<strong>s=seconds</strong>, <strong>m=minutes</strong>, <strong>h=hours</strong>, <strong>d=days</strong>), you can opt for the more compact expression of the cron scheduler. Therefore, if you wanted to fire the event every second, then you could use the following cron expression:</p>
<pre>@Scheduled(cron="* * * * * ?")<br/>void generateToken() {<br/>    token= UUID.randomUUID().toString();<br/>    log.info("New token generated");<br/>}</pre>
<p>Check the cron main page for more information about the cron format: <a href="http://man7.org/linux/man-pages/man5/crontab.5.html">http://man7.org/linux/man-pages/man5/crontab.5.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Firing one-time events</h1>
                </header>
            
            <article>
                
<p>If you need to execute one-time events, then you can inject the <kbd>io.quarkus.scheduler.Scheduler</kbd> class into your code directly and use the <kbd>startTimer</kbd> method, which will fire the execution of an action in a separate thread. This can be seen in the following example:</p>
<pre>@Inject<br/>Scheduler scheduler;<br/><br/>public void oneTimeEvnt() {<br/><br/>    scheduler.startTimer(300, () -&gt; oneTimeAction());<br/>    <br/>}<br/><br/>public void oneTimeAction() {<br/>    // Do something<br/>}</pre>
<p>In this brief excerpt, we can see how a single event, which will be executed in the <kbd>oneTimeAction()</kbd> method, can fire a one-time action after <kbd>300</kbd> milliseconds.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we presented some advanced techniques that we can use to manage our configuration using converters and configuration profiles. We have also demonstrated how different configuration sources can be injected and prioritized over the standard configuration file. In the second part of this chapter, we had a look at how to capture the application life cycle's events and how to schedule the execution of future tasks.</p>
<p>To make our applications even more scalable, in the next chapter, we will discuss how to build reactive applications, which are event-driven and non-blocking. Hold on tight!</p>


            </article>

            
        </section>
    </body></html>