- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Mastering Parallelism in Java
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握Java中的并行性
- en: Embark on an exhilarating journey into the heart of Java’s parallel programming
    landscape, a realm where the combined force of multiple threads is harnessed to
    transform complex, time-consuming tasks into efficient, streamlined operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一段激动人心的旅程，深入Java并行编程的核心，这是一个利用多个线程的合力将复杂、耗时任务转化为高效、流畅操作的区域。
- en: 'Picture this: an ensemble of chefs in a bustling kitchen or a symphony of musicians,
    each playing a vital role in creating a harmonious masterpiece. In this chapter,
    we delve deep into the Fork/Join framework, your maestro in the art of threading,
    skillfully orchestrating a myriad of threads to collaborate seamlessly.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：一群忙碌厨房中的厨师或一个乐队中的音乐家，每个人都在创造和谐杰作中扮演着至关重要的角色。在本章中，我们深入探讨Fork/Join框架，它是线程艺术中的指挥家，巧妙地编排众多线程以无缝协作。
- en: As we navigate through the intricacies of parallel programming, you’ll discover
    its remarkable advantages in boosting speed and efficiency akin to how a well-coordinated
    team can achieve more than the sum of its parts. However, with great power comes
    great responsibility. You’ll encounter unique challenges such as thread contention
    and race conditions, and we’ll arm you with the strategies and insights needed
    to master these obstacles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索并行编程的复杂性，你会发现它在提升速度和效率方面的显著优势，就像一个协调良好的团队能够实现比各部分总和更多的成果。然而，权力越大，责任越大。你将遇到独特的挑战，例如线程竞争和竞态条件，我们将为你提供克服这些障碍所需的战略和洞察力。
- en: This chapter is not just an exploration; it’s a toolkit. You’ll learn how to
    employ the Fork/Join framework effectively, breaking down daunting tasks into
    manageable sub-tasks, much like a head chef delegating components of a complex
    recipe. We’ll dive into the nuances of `RecursiveTask` and `RecursiveAction`,
    understanding how these elements work in unison to optimize parallel processing.
    Additionally, you’ll gain insights into performance optimization techniques and
    best practices, ensuring that your Java applications are not just functional but
    are also performing at their peak like a well-oiled machine.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不仅是一次探索，更是一个工具箱。你将学习如何有效地使用Fork/Join框架，将艰巨的任务分解成可管理的子任务，就像主厨将复杂菜谱的各个部分委派给助手一样。我们将深入研究`RecursiveTask`和`RecursiveAction`的细微差别，了解这些元素如何协同工作以优化并行处理。此外，你还将获得性能优化技术和最佳实践的见解，确保你的Java应用程序不仅功能齐全，而且像一台运转良好的机器一样在顶峰表现。
- en: By the end of this chapter, you’ll be equipped with more than just knowledge;
    you’ll possess the practical skills to implement parallel programming effectively
    in your Java applications. You’ll emerge ready to enhance functionality, optimize
    performance, and tackle the challenges of concurrent computing head-on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将不仅拥有知识，还将具备在Java应用程序中有效实施并行编程的实用技能。你将准备好增强功能、优化性能，并直面并发计算带来的挑战。
- en: So, let’s begin this exciting adventure into the dynamic world of Java’s parallel
    capabilities. Together, we’ll unlock the doors to efficient, concurrent computing,
    setting the stage for you to craft high-performance applications that stand out
    in the world of modern computing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始这段激动人心的冒险，进入Java并行能力的动态世界。我们将一起打开高效、并发计算的大门，为你搭建一个能够制作出在现代计算世界中脱颖而出的高性能应用程序的舞台。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need **Visual Studio Code** (**VS Code**), which you can download
    here: [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要**Visual Studio Code**（**VS Code**），你可以从这里下载：[https://code.visualstudio.com/download](https://code.visualstudio.com/download)。
- en: VS Code offers a lightweight and customizable alternative to the other available
    options. It’s a great choice for developers who prefer a less resource-intensive
    **Integrated Development Environment** (**IDE**) and want the flexibility to install
    extensions tailored to their specific needs. However, it may not have all the
    features out of the box compared to the more established Java IDEs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code提供了比其他可用选项更轻量级和可定制的替代方案。它是那些更喜欢资源消耗较少的**集成开发环境**（**IDE**）并希望安装针对其特定需求的扩展的开发者的绝佳选择。然而，与更成熟的Java
    IDE相比，它可能没有所有开箱即用的功能。
- en: 'Furthermore, the code in this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Unleashing the parallel powerhouse – the Fork/Join framework
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解放并行动力之源——Fork/Join 框架
- en: The **Fork/Join framework** unlocks the power of parallel processing, turning
    your Java tasks into a symphony of collaborating threads. Dive into its secrets,
    such as work-stealing algorithms, recursive conquers, and optimization strategies,
    to boost performance and leave sequential cooking in the dust!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fork/Join 框架**释放了并行处理的力量，将你的 Java 任务转变为协作线程的交响乐。深入探索其秘密，如工作窃取算法、递归征服和优化策略，以提升性能，让顺序烹饪成为过去式！'
- en: Demystifying Fork/Join – a culinary adventure in parallel programming
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭秘 Fork/Join – 并行编程中的烹饪冒险
- en: Imagine stepping into a grand kitchen of parallel computing in Java. This is
    where the Fork/Join framework comes into play, transforming the art of programming
    much like a bustling kitchen brimming with skilled chefs. It’s not just about
    adding more chefs; it’s about orchestrating them with finesse and strategy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下踏入 Java 并行计算的宏伟厨房。这就是 Fork/Join 框架发挥作用的地方，它将编程艺术转变为一个充满熟练厨师的繁忙厨房。这不仅仅是增加更多的厨师；这是关于用技巧和策略来编排他们。
- en: At the heart of this bustling kitchen lies the Fork/Join framework, a masterful
    tool in Java’s arsenal that automates the division of complex tasks into smaller,
    more manageable bites. Picture a head chef breaking down a complicated recipe
    into simpler tasks and delegating them to sous chefs. Each chef focuses on a part
    of the meal, ensuring that no one is waiting idly, and no task is overwhelming.
    This efficiency is akin to the work-stealing algorithm, the framework’s secret
    ingredient, where chefs who finish early lend a hand to those still busy, ensuring
    a harmonious and efficient cooking process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个繁忙的厨房中心，是 Fork/Join 框架，这是 Java 工具箱中的大师级工具，它自动将复杂任务分解成更小、更易于管理的部分。想象一位主厨将复杂的食谱分解成更简单的任务，并委托给副厨师。每位厨师专注于餐点的一部分，确保没有人无所事事，也没有任务压倒性。这种效率类似于框架的秘密成分——工作窃取算法，其中提前完成的厨师会帮助仍在忙碌的厨师，确保烹饪过程和谐高效。
- en: 'In this culinary orchestra, `ForkJoinPool` plays the role of an adept conductor.
    It’s a specialized thread pool tailored for the Fork/Join tasks, extending both
    the `Executor` and `ExecutorService` interfaces introduced in [*Chapter 2*](B20937_02.xhtml#_idTextAnchor048),
    *Introduction to Java’s Concurrency Foundations: Threads, Processes, and Beyond*.
    The `Executor` interface provides a way to decouple task submission from the mechanics
    of how each task will be run, including details of thread use, scheduling, and
    so on. The `ExecutorService` interface supplements this with methods for life
    cycle management and tracking the progress of one or more asynchronous tasks.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个烹饪管弦乐队中，`ForkJoinPool` 扮演着一位熟练的指挥。这是一个专门针对 Fork/Join 任务的线程池，它扩展了在 [*第 2 章*](B20937_02.xhtml#_idTextAnchor048)，*Java
    并发基础：线程、进程及其他* 中引入的 `Executor` 和 `ExecutorService` 接口。`Executor` 接口提供了一种将任务提交与每个任务如何运行的具体机制解耦的方法，包括线程使用、调度等细节。`ExecutorService`
    接口通过生命周期管理和跟踪一个或多个异步任务进度的方法来补充这一点。
- en: '`ForkJoinPool`, built on these foundations, is designed for work that can be
    broken down into smaller pieces recursively. It employs a technique called work-stealing,
    where idle threads can *steal* work from other busy threads, thereby minimizing
    idle time and maximizing CPU utilization.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些基础构建的 `ForkJoinPool`，旨在处理可以递归分解成更小部分的工作。它采用了一种称为工作窃取的技术，其中空闲线程可以从其他忙碌线程中“窃取”工作，从而最小化空闲时间并最大化
    CPU 利用率。
- en: Like a well-orchestrated kitchen, `ForkJoinPool` manages the execution of tasks,
    dividing them into sub-recipes, and ensuring no chef—or thread—is ever idle. When
    a task is complete, much like a sous chef presenting their dish, `ForkJoinPool`
    expertly combines these individual efforts to complete the final masterpiece.
    This process of breaking down tasks and combining the results is fundamental to
    the Fork/Join model, making `ForkJoinPool` an essential tool in the concurrency
    toolkit.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像管理得当的厨房一样，`ForkJoinPool` 管理任务的执行，将它们分解成子食谱，并确保没有厨师——或线程——是空闲的。当任务完成时，就像副厨师展示他们的菜肴一样，`ForkJoinPool`
    精湛地将这些个别努力结合起来，完成最终的杰作。这种分解任务和组合结果的过程是 Fork/Join 模型的基础，使 `ForkJoinPool` 成为并发工具箱中的必备工具。
- en: The Fork/Join framework revolves around the `ForkJoinTask` abstract class, which
    represents a task that can be split into smaller subtasks and executed in parallel
    using `ForkJoinPool`. It provides methods for splitting the task (fork), waiting
    for subtask completion (join), and computing the result.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Fork/Join 框架围绕 `ForkJoinTask` 抽象类展开，它代表一个可以分解成更小的子任务并在 `ForkJoinPool` 中并行执行的任务。它提供了用于分解任务（fork）、等待子任务完成（join）以及计算结果的函数。
- en: Two concrete implementations of `ForkJoinTask` are `RecursiveTask` is used for
    tasks that return a result, while `RecursiveAction` is used for tasks that don’t
    return a value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinTask` 的两个具体实现是 `RecursiveTask`，用于返回结果的任务，而 `RecursiveAction` 用于不返回值的任务。'
- en: Both allow you to break down tasks into smaller chunks for parallel execution.
    You need to implement the compute method to define the base case and the logic
    to split the task into subtasks. The framework handles the distribution of subtasks
    among the threads in `ForkJoinPool` and the aggregation of results.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都允许你将任务分解成更小的部分以并行执行。你需要实现计算方法来定义基本情况以及将任务分解成子任务的逻辑。框架负责在 `ForkJoinPool` 中的线程间分配子任务以及聚合结果。
- en: The key difference between `RecursiveTask` and `RecursiveAction` lies in their
    purpose and return type. `RecursiveTask` computes and returns a result, while
    `RecursiveAction` performs an action without returning a value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecursiveTask` 和 `RecursiveAction` 之间的关键区别在于它们的目的和返回类型。`RecursiveTask` 用于计算并返回一个结果，而
    `RecursiveAction` 则执行一个操作而不返回任何值。'
- en: 'To illustrate how `RecursiveTask` and `RecursiveAction` are used within the
    Fork/Join framework, consider the following code example. `SumTask` demonstrates
    summing a data array, while `ActionTask` shows processing data without returning
    a result:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `RecursiveTask` 和 `RecursiveAction` 在 Fork/Join 框架中的使用，考虑以下代码示例。`SumTask`
    展示了如何对数据数组求和，而 `ActionTask` 展示了如何处理数据而不返回结果：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a breakdown of the code and its functionality:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对代码及其功能的分解：
- en: '`SumTask` extends `RecursiveTask<Integer>` and is used for summing a portion
    of the array, returning the sum.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SumTask` 扩展了 `RecursiveTask<Integer>` 并用于计算数组的一部分，返回总和。'
- en: In the `SumTask` class, the task is split when the data length exceeds a threshold,
    demonstrating a divide-and-conquer approach. This is similar to a head chef dividing
    a large recipe task among sous chefs.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `SumTask` 类中，当数据长度超过阈值时，任务会被分解，展示了分而治之的方法。这类似于主厨将大型食谱任务分配给副厨师。
- en: '`ActionTask` extends `RecursiveAction` and is used for processing a portion
    of the array without returning a result.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActionTask` 扩展了 `RecursiveAction` 并用于处理数组的一部分而不返回结果。'
- en: The `fork()` method initiates the parallel execution of a subtask, while `join()`
    waits for the completion of these tasks, combining their results. The `compute()`
    method contains the logic for either directly performing the task or further splitting
    it.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fork()` 方法启动子任务的并行执行，而 `join()` 等待这些任务的完成，合并它们的结果。`compute()` 方法包含直接执行任务或进一步分解它的逻辑。'
- en: Both classes split their tasks when the dataset size exceeds a threshold, demonstrating
    the divide-and-conquer approach.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据集大小超过阈值时，这两个类都会分解任务，展示了分而治之的方法。
- en: '`ForkJoinPool` executes both tasks, illustrating how both `RecursiveTask` and
    `RecursiveAction` can be used in parallel processing scenarios.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinPool` 执行这两个任务，说明了 `RecursiveTask` 和 `RecursiveAction` 如何在并行处理场景中使用。'
- en: This example demonstrates the practical application of the Fork/Join framework’s
    ability to efficiently process large datasets in parallel, as discussed earlier.
    They exemplify how complex tasks can be decomposed and executed in a parallel
    manner to enhance application performance. Imagine using `SumTask` for rapidly
    processing large financial datasets or `ActionTask` for parallel processing in
    data cleaning operations in a real-time analytics application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了 Fork/Join 框架在并行处理大型数据集方面的实际应用，正如之前所讨论的。它们展示了复杂任务如何被分解并并行执行以提升应用性能。想象一下使用
    `SumTask` 快速处理大型金融数据集或使用 `ActionTask` 在实时分析应用的数据清洗操作中进行并行处理。
- en: In the next section, we’ll explore how to handle tasks with dependencies and
    navigate the intricacies of complex task graphs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何处理具有依赖关系的任务，并导航复杂任务图的复杂性。
- en: Beyond recursion – conquering complexities with dependencies
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越递归——利用依赖关系克服复杂性
- en: We’ve witnessed the beauty of recursive tasks in tackling smaller, independent
    challenges. But what about real-world scenarios where tasks have intricate dependencies
    like a multi-course meal where one dish relies on another to be complete? This
    is where `ForkJoinPool.invokeAll()` shines, a powerful tool for orchestrating
    parallel tasks with intricate relationships.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经见证了递归任务在解决较小、独立挑战时的美妙之处。但在现实场景中，任务具有复杂依赖关系，如多道菜式中一道菜依赖于另一道菜完成的情况，又该如何呢？这正是`ForkJoinPool.invokeAll()`大放异彩的地方，它是协调具有复杂关系的并行任务的有力工具。
- en: ForkJoinPool.invokeAll() – the maestro of intertwined tasks
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ForkJoinPool.invokeAll() –错综复杂任务的指挥家
- en: Imagine a bustling kitchen with chefs working on various dishes. Some tasks,
    such as chopping vegetables, can be done independently. But others, such as making
    a sauce, depend on ingredients already being prepped. This is where the head chef,
    `ForkJoinPool`, steps in. With `invokeAll()`, they distribute the tasks, ensuring
    that dependent tasks wait for their predecessors to finish before starting.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个熙熙攘攘的厨房，厨师们正在制作各种菜肴。有些任务，如切菜，可以独立完成。但其他任务，如制作酱料，则依赖于已经准备好的食材。这就是主厨`ForkJoinPool`介入的地方。通过`invokeAll()`，他们分配任务，确保依赖任务在开始之前等待其前驱任务完成。
- en: Managing dependencies in the kitchen symphony – a recipe for efficiency
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在厨房交响乐中管理依赖关系——效率的秘方
- en: Just as a chef carefully coordinates dishes with different cooking times, parallel
    processing requires meticulous management of task dependencies. Let’s explore
    this art through the lens of a kitchen, where our goal is to efficiently prepare
    a multi-course meal.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如厨师精心协调不同烹饪时间的菜肴一样，并行处理需要细致地管理任务依赖关系。让我们通过厨房的视角来探讨这种艺术，我们的目标是高效地准备多道菜式。
- en: 'The following are key strategies of parallel processing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些并行处理的关键策略：
- en: '**Task decomposition**: Break down the workflow into smaller, manageable tasks
    with clear dependencies. In our kitchen symphony, we’ll create tasks for preparing
    vegetables, making sauce, and cooking protein, each with its own prerequisites.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务分解**：将工作流程分解成更小、更易于管理的任务，并确保有明确的依赖关系。在我们的厨房交响乐中，我们将创建准备蔬菜、制作酱料和烹饪蛋白质的任务，每个任务都有其自身的先决条件。'
- en: '**Dependency analysis**: Identify task reliance and define execution order.
    Tasks such as cooking protein must await prepped vegetables and sauce, ensuring
    a well-orchestrated meal.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖分析**：识别任务依赖并定义执行顺序。如烹饪蛋白质这样的任务必须等待准备好的蔬菜和酱料，以确保菜肴的完美协调。'
- en: '**Granularity control**: Choose the appropriate task size to balance efficiency
    and overhead. Too many fine-grained tasks can increase management overhead, while
    large tasks might limit parallelism.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒度控制**：选择适当的任务大小以平衡效率和开销。过多的细粒度任务会增加管理开销，而大任务可能会限制并行性。'
- en: '**Data sharing and synchronization**: Ensure proper access and synchronization
    of shared data to avoid inconsistencies. If multiple chefs use a shared ingredient,
    we need a system to avoid conflicts and maintain kitchen harmony.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据共享和同步**：确保共享数据的正确访问和同步，以避免不一致性。如果多个厨师使用共享的食材，我们需要一个系统来避免冲突并保持厨房的和谐。'
- en: 'Let’s visualize dependency management with the `PrepVeggiesTask` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`PrepVeggiesTask`类来可视化依赖管理：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The provided code demonstrates the usage of the Fork/Join framework in Java
    to handle tasks with dependencies. It defines two interfaces: `KitchenTask` for
    generic tasks and `ChefTask` for tasks that return a String result.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码展示了在Java中使用Fork/Join框架处理具有依赖关系的任务的用法。它定义了两个接口：`KitchenTask`用于通用任务和`ChefTask`用于返回String结果的任务。
- en: 'Here are some key points:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些关键点：
- en: '`PrepVeggiesTask` and `CookVeggiesTask` implement `KitchenTask`, representing
    specific tasks in the kitchen. The `ChefTask` class is the core of the Fork/Join
    implementation, containing the actual task (`task`) and its dependencies (`dependencies`).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrepVeggiesTask`和`CookVeggiesTask`实现了`KitchenTask`，代表厨房中的具体任务。`ChefTask`类是Fork/Join实现的核心，包含实际任务（`task`）及其依赖（`dependencies`）。'
- en: The `awaitDependencies()` method waits for all dependencies to complete before
    executing the current task. The `compute()` method is the main entry point for
    the Fork/Join framework, ensuring prerequisites are met and performing the actual
    task.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitDependencies()`方法等待所有依赖完成后再执行当前任务。`compute()`方法是Fork/Join框架的主要入口点，确保满足先决条件并执行实际任务。'
- en: In the main method, an example dataset is created with `PrepVeggiesTask` objects
    as dependencies. `ForkJoinPool` is used to manage the execution of tasks. `CookVeggiesTask`
    with dependencies is submitted to the pool using `pool.invoke(cookTask)`, triggering
    the execution of the task and its dependencies.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主方法中，使用 `PrepVeggiesTask` 对象作为依赖项创建了一个示例数据集。使用 `ForkJoinPool` 来管理任务的执行。通过 `pool.invoke(cookTask)`
    将具有依赖关系的 `CookVeggiesTask` 提交到池中，触发任务的执行及其依赖项。
- en: '`ChefTask` acts as a blueprint for tasks with dependencies.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChefTask` 作为具有依赖关系的任务的蓝图。'
- en: '`awaitDependencies()` waits for prerequisites to finish.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitDependencies()` 等待先决条件完成。'
- en: '`PrepVeggiesTask` and `CookVeggiesTask` represent specific tasks.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrepVeggiesTask` 和 `CookVeggiesTask` 代表特定的任务。'
- en: '`performTask()` holds the actual task logic.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`performTask()` 包含实际的任务逻辑。'
- en: The code demonstrates how the Fork/Join framework can be used to handle tasks
    with dependencies, ensuring prerequisites are completed before executing a task.
    `ForkJoinPool` manages the execution of tasks, and the `ChefTask` class provides
    a structured way to define and perform tasks with dependencies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码演示了如何使用 Fork/Join 框架来处理具有依赖关系的任务，确保在执行任务之前完成先决条件。`ForkJoinPool` 管理任务的执行，而
    `ChefTask` 类提供了一种结构化的方式来定义和执行具有依赖关系的任务。
- en: Let’s weave a real-world scenario into the mix to solidify the concept of dependency
    management in parallel processing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结合一个现实世界的场景，以巩固并行处理中依赖关系管理概念。
- en: 'Picture this: you’re building a next-generation image rendering app that needs
    to handle complex 3D scenes. To efficiently manage the workload, you break down
    the rendering process into the following parallel tasks:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：你正在构建一个下一代图像渲染应用程序，该应用程序需要处理复杂的 3D 场景。为了有效地管理工作负载，你将渲染过程分解为以下并行任务：
- en: '**Task 1**: Downloading textures and model data'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务 1**：下载纹理和模型数据'
- en: '**Task 2**: Building geometric primitives from the downloaded data'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务 2**：从下载的数据中构建几何原语。'
- en: '**Task 3**: Applying lighting and shadows to the scene'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务 3**：对场景应用光照和阴影'
- en: '**Task 4**: Rendering the final image'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务 4**：渲染最终图像'
- en: 'Here’s where dependencies come into play:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里，依赖关系开始发挥作用：
- en: Task 2 can’t start until Task 1 finishes downloading the necessary data
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务 2 在开始之前必须等待任务 1 下载必要的数据完成。
- en: Task 3 needs the geometric primitives built by Task 2 before it can apply the
    lighting and shadows
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务 3 在应用光照和阴影之前需要任务 2 构建的几何原语。
- en: Finally, Task 4 depends on the completed scene from Task 3 to generate the final
    image
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，任务 4 依赖于任务 3 完成的场景来生成最终图像。
- en: By carefully managing these dependencies and utilizing parallel processing techniques,
    you can significantly speed up the rendering process, delivering smooth and visually
    stunning 3D experiences.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过精心管理这些依赖关系并利用并行处理技术，你可以显著加快渲染过程，提供流畅且视觉上令人惊叹的 3D 体验。
- en: This real-world example showcases how effective dependency management is crucial
    for harnessing the true power of parallel processing in various domains, from
    image rendering to scientific simulations and beyond.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个现实世界的例子展示了依赖关系管理对于在各个领域（从图像渲染到科学模拟等）发挥并行处理真正力量的关键作用。
- en: Remember, just like orchestrating a kitchen symphony or rendering a complex
    3D scene, mastering parallel processing lies in meticulous planning, execution,
    and efficient dependency management. With the right tools and techniques, you
    can transform your parallel processing endeavors into harmonious and high-performance
    symphonies of tasks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，就像指挥厨房交响乐或渲染复杂的 3D 场景一样，掌握并行处理在于细致的计划、执行和高效的依赖关系管理。有了正确的工具和技术，你可以将并行处理努力转变为和谐且高性能的任务交响乐。
- en: Now, let’s move on to explore the art of fine-tuning these symphonies in the
    next topic on performance optimization techniques!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探讨在性能优化技术主题中调整这些交响乐的艺术。
- en: Fine-tuning the symphony of parallelism – a journey in performance optimization
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整并行交响乐——性能优化的旅程
- en: In the dynamic world of parallel programming, achieving peak performance is
    akin to conducting a grand orchestra. Each element plays a crucial role and fine-tuning
    them is essential to creating a harmonious symphony. Let’s embark on a journey
    through the key strategies of performance optimization in Java’s parallel computing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行编程的动态世界中，实现最佳性能就像指挥一个大型管弦乐队。每个元素都扮演着至关重要的角色，而精细调整它们对于创作和谐的交响乐是必不可少的。让我们开始一段旅程，了解
    Java 并行计算中性能优化的关键策略。
- en: The art of granularity control
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒度控制的技艺
- en: Just as a chef balances ingredients for a perfect dish, granularity control
    in parallel programming is about finding the ideal task size. Smaller tasks, like
    having more chefs, boost parallelization but introduce dependencies and management
    overhead. Conversely, larger tasks simplify management but limit parallelism,
    like a few chefs handling everything. The key is assessing task complexity, weighing
    overhead against benefits, and avoiding overly fine-grained tasks that could tangle
    the process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如厨师平衡配料以制作完美佳肴一样，在并行编程中的粒度控制是关于找到理想的任务大小。较小的任务，就像有更多的厨师，可以增强并行处理，但会引入依赖和管理开销。相反，较大的任务简化了管理，但限制了并行处理，就像少数厨师处理一切。关键是评估任务复杂性，权衡开销与收益，并避免过于精细的任务，这些任务可能会使流程变得混乱。
- en: Tuning parallelism levels
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整并行级别
- en: Setting the right level of parallelism is like orchestrating our chefs to ensure
    each has just the right amount of work—neither too overwhelmed nor idly waiting.
    It’s a delicate balance between utilizing available resources and avoiding excessive
    overhead from too many active threads. Consider the characteristics of your tasks
    and the available hardware. Remember, larger thread pools might not always benefit
    from work-stealing as efficiently as smaller, more focused groups.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正确的并行级别就像指挥我们的厨师，确保每个人都有适量的工作——既不过于忙碌也不过于闲散。这是在利用可用资源与避免过多活跃线程带来的过度开销之间的一种微妙平衡。考虑你任务的特性以及可用的硬件。记住，较大的线程池可能并不总是像较小的、更专注的群体那样高效地受益于工作窃取。
- en: Best practices for a smooth performance
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定性能的最佳实践
- en: In our parallel kitchen, the best practices are the secret recipes for success.
    Limiting data sharing among threads can prevent conflicts over shared resources,
    much like chefs working on separate stations. Opting for a smart, thread-safe
    data structure such as `ConcurrentHashMap` can ensure safe access to shared data.
    Regularly monitoring performance and being ready to adjust task sizes and thread
    numbers can keep your parallel applications running smoothly and efficiently.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的并行厨房中，最佳实践是成功的秘诀。限制线程间的数据共享可以防止对共享资源的冲突，就像厨师在各自的岗位上工作一样。选择智能的、线程安全的如`ConcurrentHashMap`这样的数据结构可以确保对共享数据的安全访问。定期监控性能并准备好调整任务大小和线程数量可以使你的并行应用程序运行得更加顺畅和高效。
- en: By mastering these techniques—granularity control, tuning parallelism levels,
    and adhering to best practices—we can elevate our parallel computing to new heights
    of efficiency and performance. It’s not just about running parallel tasks; it’s
    about orchestrating them with precision and insight, ensuring each thread plays
    its part in this complex symphony of parallel processing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握这些技术——粒度控制、调整并行级别以及遵循最佳实践——我们可以将我们的并行计算提升到新的效率和性能高度。这不仅仅是运行并行任务；这是关于精确和深入地指挥它们，确保每个线程在这个复杂的并行处理交响乐中扮演其角色。
- en: Performance optimization lays the foundation for efficient parallelism. Now,
    we step into a world of refined elegance with Java’s parallel streams, enabling
    lightning-fast data processing through concurrent execution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化是高效并行处理的基础。现在，我们进入了一个由Java的并行流带来的精致优雅的世界，通过并发执行实现闪电般的数据处理。
- en: Streamlining parallelism in Java with parallel streams
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中使用并行流简化并行处理
- en: Fine-tuning the symphony of parallelism is akin to conducting a grand orchestra.
    Each element plays a crucial role and mastering them unlocks peak performance.
    This journey through key strategies, such as granularity control and parallelism
    levels, ensures harmonious execution in Java’s parallel computing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 微调并行处理的交响乐就像指挥一场大型管弦乐。每个元素都扮演着至关重要的角色，掌握它们可以解锁峰值性能。通过关键策略，如粒度控制和并行级别，这一旅程确保了Java并行计算中的和谐执行。
- en: Now, we step into a world of refined elegance with Java’s parallel streams.
    Imagine transforming a one-chef kitchen into a synchronized team, harnessing multiple
    cores for lightning-fast data processing. Remember that efficient parallelism
    lies in choosing the right tasks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入了一个由Java的并行流带来的精致优雅的世界。想象一下，将一个只有一个厨师的单人厨房转变为一个同步的团队，利用多个核心进行闪电般的数据处理。记住，高效的并行处理在于选择正确的任务。
- en: 'Parallel streams excel due to the following reasons:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 并行流之所以出色，有以下原因：
- en: '**Faster execution**: Especially for large datasets, they accelerate data operations
    remarkably'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快地执行**：特别是对于大数据集，它们显著加速数据操作'
- en: '**Handling large data**: Their strength lies in efficiently processing massive
    data volumes'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理大量数据**：它们的优势在于高效地处理大量数据'
- en: '**Ease of use**: Switching from sequential to parallel streams is often straightforward'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**：从顺序流切换到并行流通常很简单'
- en: 'However, consider the following challenges:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑以下挑战：
- en: '**Extra resource management**: Thread management incurs overhead, making smaller
    tasks less ideal'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外资源管理**：线程管理会产生开销，使得小任务不太理想'
- en: '**Task independence**: Parallel streams shine when tasks are independent and
    lack sequential dependencies'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务独立性**：当任务独立且没有顺序依赖时，并行流表现得尤为出色'
- en: '**Caution with shared data**: Concurrent access to shared data necessitates
    careful synchronization to avoid race conditions'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小心共享数据**：对共享数据的并发访问需要谨慎同步，以避免竞态条件'
- en: 'Let us now understand how to seamlessly integrate parallel streams to harness
    their performance benefits while addressing the potential challenges:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何无缝集成并行流，以利用其性能优势同时应对潜在挑战：
- en: '**Identify suitable tasks**: Begin by pinpointing computationally expensive
    operations within your code that operate on independent data elements, such as
    image resizing, sorting large lists, or performing complex calculations. These
    tasks are prime candidates for parallelization.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别合适的任务**：首先，确定代码中计算成本高昂的操作，这些操作独立于数据元素，例如图像调整大小、排序大型列表或执行复杂计算。这些任务是并行化的理想候选。'
- en: '`parallelStream()` method instead of `stream()`. This subtle change unlocks
    the power of multi-core processing.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `parallelStream()` 方法而不是 `stream()`。这种微妙的变化释放了多核处理的能力。
- en: For example, consider a scenario where you need to resize a large batch of photos.
    The sequential approach, `photos.stream().map(photo -> resize(photo))`, processes
    each photo individually. By switching to `photos.parallelStream().map(photo ->
    resize(photo))`, you unleash the potential of multiple cores, working in concert
    to resize photos simultaneously, often leading to significant performance gains.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，考虑这样一个场景，你需要调整大量照片的大小。顺序方法 `photos.stream().map(photo -> resize(photo))`
    会逐个处理每张照片。通过切换到 `photos.parallelStream().map(photo -> resize(photo))`，你释放了多核的潜力，它们协同工作同时调整照片大小，通常能带来显著的性能提升。
- en: Remember that effective parallel stream integration requires careful consideration
    of task suitability, resource management, and data safety to ensure optimal results
    and avoid potential pitfalls.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，有效的并行流集成需要仔细考虑任务适用性、资源管理和数据安全，以确保最佳结果并避免潜在陷阱。
- en: Next, we’ll conduct a comparative analysis, exploring different parallel processing
    tools and helping you choose the perfect instrument for your programming symphony.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进行对比分析，探讨不同的并行处理工具，帮助你为你的编程交响乐选择完美的乐器。
- en: Choosing your weapon – a parallel processing showdown in Java
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择你的武器——Java中的并行处理对决
- en: 'Mastering the Fork/Join framework is a culinary feat in itself, but navigating
    the broader landscape of Java’s parallel processing tools is where true expertise
    shines. To help you choose the perfect ingredient for your parallel processing
    dish, let’s explore how Fork/Join stacks up against other options:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 精通 Fork/Join 框架本身就是一项烹饪壮举，但在这个更广泛的 Java 并行处理工具领域中导航才是真正展现专长的领域。为了帮助你为你的并行处理菜肴选择完美的配料，让我们探讨
    Fork/Join 与其他选项如何相提并论：
- en: '`ThreadPoolExecutor`, on the other hand, is a more versatile kitchen manager,
    handling a large volume of independent, non-divisible tasks such as prepping separate
    dishes for a banquet. It’s ideal for simpler parallel needs where the sous chefs
    don’t need to break down their ingredients further.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`ThreadPoolExecutor` 是一个更通用的厨房经理，处理大量独立且不可分割的任务，例如为宴会准备单独的菜肴。它非常适合简单的并行需求，其中副厨师不需要进一步分解他们的配料。
- en: '**Fork/Join versus parallel streams**: Parallel streams are like pre-washed
    and chopped vegetables, ready to be tossed into the processing pan. They simplify
    data processing on collections by automatically parallelizing operations under
    the hood, using Fork/Join as their secret weapon. For straightforward data crunching,
    they’re a quick and convenient option. However, for complex tasks with custom
    processing logic, Fork/Join offers the fine-grained control and flexibility of
    a seasoned chef, allowing you to customize the recipe for optimal results.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fork/Join 与并行流**：并行流就像预先清洗和切好的蔬菜，可以直接放入处理锅中。它们通过在幕后自动并行化操作来简化集合上的数据处理，将 Fork/Join
    作为其秘密武器。对于简单的数据处理，它们是一个快速方便的选择。然而，对于具有自定义处理逻辑的复杂任务，Fork/Join 提供了像经验丰富的厨师一样的精细控制和灵活性，允许你为最佳结果定制食谱。'
- en: '`CompletableFuture` is like a multi-tasking sous chef, adept at handling asynchronous
    operations. It allows you to write non-blocking code and chain multiple asynchronous
    tasks together, ensuring your kitchen keeps running smoothly even while other
    dishes simmer. Think of it as preparing multiple side dishes without holding up
    the main course.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`就像一个多任务处理的副厨师，擅长处理异步操作。它允许你编写非阻塞代码并将多个异步任务链接在一起，确保厨房即使在其他菜肴慢炖时也能平稳运行。想象一下，你可以在不耽误主菜的情况下准备多个配菜。'
- en: '`Executors.newCachedThreadPool()` is like hiring temporary chefs who can jump
    in and out as needed. It’s perfect for short-lived, asynchronous jobs such as
    fetching ingredients. However, for long-running, CPU-intensive tasks, Fork/Join’s
    work-stealing algorithm shines again, ensuring each chef is optimally busy and
    maximizing efficiency throughout the entire cooking process.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newCachedThreadPool()`就像雇佣临时厨师，他们可以根据需要随时加入或退出。这对于短暂、异步的任务，如取食材，非常合适。然而，对于长时间运行、CPU密集型任务，Fork/Join的工作窃取算法再次大放异彩，确保每位厨师都处于最佳忙碌状态，在整个烹饪过程中最大化效率。'
- en: By understanding the strengths and weaknesses of each tool, you can choose the
    perfect one for your parallel processing needs. Remember, Fork/Join is the master
    of large-scale, parallelizable tasks, while other tools cater to specific needs,
    such as independent jobs, simpler data processing, asynchronous workflows, or
    even temporary assistance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解每个工具的优点和缺点，你可以为你的并行处理需求选择最合适的一个。记住，Fork/Join是大规模可并行任务的专家，而其他工具则满足特定的需求，如独立作业、简单的数据处理、异步工作流，甚至是临时协助。
- en: Having explored the comparative analysis of the Fork/Join framework with other
    parallel processing methods in Java, we now transition to a more specialized topic.
    Next, we delve into unlocking the power of big data with a custom Spliterator,
    where we will uncover advanced techniques for optimizing parallel stream processing,
    focusing on custom Spliterator implementation and efficient management of computational
    overhead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了Fork/Join框架与其他Java并行处理方法的比较分析之后，我们现在转向一个更专业的话题。接下来，我们将深入探讨如何使用自定义Spliterator释放大数据的威力，我们将揭示优化并行流处理的先进技术，重点关注自定义Spliterator实现和计算开销的有效管理。
- en: Unlocking the power of big data with a custom Spliterator
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义Spliterator释放大数据的威力
- en: Java’s **Splittable Iterator** (**Spliterator**) interface offers a powerful
    tool for dividing data into smaller pieces for parallel processing. But for large
    datasets, such as those found on cloud platforms such as **Amazon Web Services**
    (**AWS**), a custom Spliterator can be a game-changer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Java的**可分割迭代器**（**Spliterator**）接口为将数据分割成更小的块以进行并行处理提供了强大的工具。但对于大型数据集，例如在云平台如**亚马逊网络服务**（**AWS**）上找到的数据集，一个自定义Spliterator可以成为游戏规则的改变者。
- en: For example, imagine a massive bucket of files in AWS **Simple Storage Service**
    (**S3**). A custom Spliterator designed specifically for this task can intelligently
    chunk the data into optimal sizes, considering factors such as file types and
    access patterns. This allows you to distribute tasks across CPU cores more effectively,
    leading to significant performance boosts and reduced resource utilization.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下AWS **简单存储服务**（**S3**）中一个巨大的文件桶。为这项任务专门设计的自定义Spliterator可以智能地将数据分割成最佳大小，考虑因素包括文件类型和访问模式。这允许你更有效地将任务分配到CPU核心，从而显著提高性能并减少资源利用率。
- en: 'Now, imagine you have lots of files in an AWS S3 bucket and want to process
    them at the same time using Java Streams. Here’s how you could set up a custom
    Spliterator for these AWS S3 objects:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你有一个AWS S3存储桶中有很多文件，并想同时使用Java Streams处理它们。以下是如何为这些AWS S3对象设置自定义Spliterator的方法：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Java code presented showcases how to harness the custom Spliterator to
    achieve efficient parallel processing of S3 objects. Let’s dive into its key elements:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的Java代码展示了如何利用自定义Spliterator实现S3对象的效率并行处理。让我们深入了解其关键元素：
- en: '`S3ObjectSpliterator` to divide the list for parallel processing'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`S3ObjectSpliterator`用于将列表分割以进行并行处理'
- en: Initiates a parallel stream using the Spliterator, applying the `processS3Object`
    method to each object
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Spliterator启动并行流，对每个对象应用`processS3Object`方法
- en: '`S3ObjectSpliterator` class implements the `Spliterator<S3ObjectSummary>` interface,
    enabling tailored data division for parallel streams. Other key methods are as
    follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`S3ObjectSpliterator`类实现了`Spliterator<S3ObjectSummary>`接口，使得针对并行流的定制数据分割成为可能。其他关键方法如下：'
- en: '`tryAdvance`: Processes the current object and advances the cursor'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryAdvance`：处理当前对象并移动游标。'
- en: '`trySplit`: Divides the list into smaller chunks for parallel execution, returning
    a new Spliterator for the divided portion'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trySplit`：将列表分割成更小的块以进行并行执行，并为分割的部分返回一个新的Spliterator。'
- en: '`estimateSize`: Provides an estimate of remaining objects, aiding stream optimization'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`estimateSize`：提供剩余对象的估计，有助于流优化。'
- en: '`characteristics`: Specifies Spliterator traits (`IMMUTABLE`, `SIZED`, or `SUBSIZED`)
    for efficient stream operations'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`characteristics`：指定Spliterator特性（`IMMUTABLE`、`SIZED`或`SUBSIZED`），以实现高效的流操作。'
- en: '`processS3Object` method encapsulates the specific processing steps performed
    on each S3 object. Implementation details are not shown, but this method could
    involve tasks such as downloading object content, applying transformations, or
    extracting metadata.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`processS3Object`方法封装了在每个S3对象上执行的具体处理步骤。实现细节未显示，但此方法可能涉及下载对象内容、应用转换或提取元数据等任务。'
- en: 'The following are the advantages of the custom Spliterator approach:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为自定义Spliterator方法的优势：
- en: '**Fine-grained control**: A custom Spliterator allows for precise control over
    data splitting, enabling optimal chunk sizes for parallel processing based on
    task requirements and hardware capabilities'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度控制**：自定义Spliterator允许对数据分割进行精确控制，根据任务需求和硬件能力，实现并行处理的最优块大小。'
- en: '`trySplit` method effectively divides the workload for multi-core processors,
    leading to potential performance gains'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trySplit`方法有效地将工作负载分割给多核处理器，从而可能导致性能提升。'
- en: '**Flexibility for diverse data handling**: A custom Spliterator can be adapted
    to handle different S3 object types or access patterns, tailoring processing strategies
    for specific use cases'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活处理多种数据类型**：自定义Spliterator可以适应处理不同的S3对象类型或访问模式，针对特定用例定制处理策略。'
- en: In essence, this code demonstrates how a custom Spliterator empowers Java developers
    to take control of parallel processing for S3 objects, unlocking enhanced performance
    and flexibility for various data-intensive tasks within cloud environments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这段代码展示了自定义Spliterator如何使Java开发者能够控制S3对象的并行处理，解锁云环境中各种数据密集型任务的增强性能和灵活性。
- en: 'Beyond a custom Spliterator, Java offers an arsenal of advanced techniques
    to fine-tune stream parallelism and unlock exceptional performance. Let’s look
    at a code example showcasing three powerful strategies: custom thread pools, combining
    stream operations, and parallel-friendly data structures.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自定义Spliterator之外，Java还提供了一系列高级技术，用于微调流并行性和解锁卓越的性能。让我们通过一个代码示例来看看三种强大的策略：自定义线程池、组合流操作和并行友好型数据结构。
- en: 'Let’s explore these Java classes in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码来探索这些Java类：
- en: '[PRE3]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this code, we used the following techniques:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用了以下技术：
- en: '`ForkJoinPool` with a specified number of threads (in this case, `4`). This
    custom thread pool is used to execute our parallel stream, allowing for better
    resource allocation than using the common pool.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`具有指定的线程数（在本例中为`4`）。这个自定义线程池用于执行我们的并行流，比使用通用池提供了更好的资源分配。'
- en: '`filter` (to select even numbers) and `map` (to square the numbers) stream
    operations are combined into a single stream pipeline. This reduces the number
    of iterations over the data.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`（选择偶数）和`map`（平方数字）流操作被组合成一个单一的流管道。这减少了数据迭代次数。'
- en: '`ConcurrentHashMap` for storing the results of a parallel stream operation.
    This data structure is designed for concurrent access, making it a good choice
    for use in parallel streams.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`用于存储并行流操作的结果。这种数据结构旨在支持并发访问，因此是并行流使用的良好选择。'
- en: This class demonstrates how combining these advanced techniques can lead to
    more efficient and optimized parallel stream processing in Java.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类展示了如何结合这些高级技术，在Java中实现更高效和优化的并行流处理。
- en: A custom Spliterator offers a potent recipe for parallel processing, but is
    it always the tastiest dish? In the next section, we’ll sprinkle in some reality
    checks, exploring the potential benefits and hidden costs of parallelism.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义Spliterator为并行处理提供了一个强大的配方，但它是否总是最美味的菜肴？在下一节中，我们将加入一些现实检查，探讨并行化的潜在优势和隐藏成本。
- en: Benefits and pitfalls of parallelism
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行化的优势和陷阱
- en: Parallel processing not only offers significant speed advantages but also comes
    with challenges such as thread contention and data dependency issues. This section
    focuses on understanding when to use parallel processing effectively. It outlines
    the benefits and potential problems, providing guidance on choosing between parallel
    and sequential processing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理不仅提供了显著的速度优势，还伴随着诸如线程竞争和数据依赖问题等挑战。本节重点在于理解何时有效地使用并行处理。它概述了好处和潜在问题，提供了在并行和顺序处理之间选择时的指导。
- en: 'The key scenarios where parallel processing excels over sequential methods
    are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理在以下关键场景中优于顺序方法：
- en: '**Computationally intensive tasks**: Imagine crunching numbers, processing
    images, or analyzing vast datasets. These are the playgrounds for parallel processing.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算密集型任务**：想象一下处理数字、处理图像或分析大量数据集。这些都是并行处理的游乐场。'
- en: '**Independent operations**: Parallelism thrives when tasks are independent,
    meaning they don’t rely on each other’s results. Think of filtering items in a
    list or resizing multiple images. Each operation can be handled concurrently by
    a separate thread, boosting efficiency without causing tangled dependencies.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立操作**：当任务独立时，并行性蓬勃发展，这意味着它们不依赖于彼此的结果。想想在列表中过滤项目或调整多个图像的大小。每个操作都可以由一个单独的线程并发处理，从而提高效率，而不会造成复杂的依赖关系。'
- en: '**Input/Output (I/O) bound operations**: Tasks waiting for data from a disk
    or network are prime candidates for parallel processing. While one thread waits
    for data, others can tackle other independent tasks, maximizing resource utilization
    and keeping your code humming along.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入/输出（I/O）绑定操作**：等待从磁盘或网络获取数据的任务非常适合并行处理。当一条线程等待数据时，其他线程可以处理其他独立任务，最大化资源利用，并保持你的代码流畅运行。'
- en: '**Real-time applications**: Whether it’s rendering dynamic visuals or handling
    user interactions, responsiveness is crucial in real-time applications. Parallel
    processing can be your secret sauce, ensuring smooth, lag-free experiences by
    splitting the workload and keeping the **user interface** (**UI**) responsive
    even under heavy load.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时应用**：无论是渲染动态视觉效果还是处理用户交互，响应性在实时应用中至关重要。并行处理可以是你的秘密武器，通过分割工作负载并保持**用户界面**（**UI**）即使在重负载下也能保持响应，确保流畅、无延迟的体验。'
- en: Beyond these specific scenarios, the potential performance gains of parallel
    processing are vast. From accelerating video encoding to powering real-time simulations,
    its ability to unleash the power of multiple cores can dramatically improve the
    efficiency and responsiveness of your applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些特定场景之外，并行处理可能带来的性能提升是巨大的。从加速视频编码到支持实时模拟，它释放多个核心的能力可以显著提高应用程序的效率和响应速度。
- en: 'We’ve witnessed the exhilarating potential of parallel processing, but now
    comes the crucial question: how much faster is it? How can we quantify the performance
    gains of parallelism processing?'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们见证了并行处理的激动人心的潜力，但现在有一个关键问题：它有多快？我们如何量化并行处理的性能提升？
- en: 'The most common metric for measuring parallel processing efficiency is speedup.
    It simply compares the execution time of a task running sequentially with its
    parallel execution time. The formula is straightforward:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测量并行处理效率的最常见指标是加速比。它简单地比较了顺序执行任务的时间和并行执行时间。公式很简单：
- en: '*Speedup = Sequential Execution Time / Parallel* *Execution Time*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*加速比 = 顺序执行时间 / 并行* *执行时间*'
- en: A speedup of `2` means the parallel version took half the time of the sequential
    version.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 加速比为`2`意味着并行版本的时间是顺序版本的一半。
- en: 'However, parallel processing isn’t just about raw speed; it’s also about resource
    utilization and efficiency. Here are some additional metrics to consider:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并行处理不仅仅是关于原始速度；它还关乎资源利用率和效率。以下是一些需要考虑的额外指标：
- en: '**Efficiency**: The percentage of CPU time utilized by the parallel program.
    Ideally, you’d like to see efficiency close to 100%, indicating all cores are
    working hard.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：并行程序占用的CPU时间百分比。理想情况下，你希望看到效率接近100%，这表明所有核心都在努力工作。'
- en: '**Amdahl’s Law**: A 1960s principle by Gene Amdahl, which sets limits on parallel
    processing. Amdahl’s Law says that adding processors won’t magically speed up
    everything. Focus on bottlenecks first, then parallelize wisely. Why? Accelerating
    part of a task only helps if the rest is fast too. So, as tasks become more parallel,
    adding more processors gives less and less benefit. Optimize the slowest parts
    first! Even highly parallel tasks have *unparallelizable bits* that cap the overall
    speedup.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amdahl定律**：Gene Amdahl在20世纪60年代提出的原则，它为并行处理设定了限制。Amdahl定律指出，增加处理器不会神奇地加快一切。首先关注瓶颈，然后明智地并行化。为什么？仅加速任务的一部分只有在其余部分也很快的情况下才有帮助。因此，随着任务变得更加并行，增加更多处理器带来的好处越来越少。首先优化最慢的部分！即使是高度并行的任务也有*不可并行化部分*，这限制了整体速度的提升。'
- en: '**Scalability**: How well does the parallel program perform as the number of
    cores increases? Ideally, we want to see a near-linear speedup with additional
    cores.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：随着核心数量的增加，并行程序的性能如何？理想情况下，我们希望看到随着核心数量的增加，速度几乎线性提升。'
- en: 'Here are some notable tools for performance tuning in cloud environments and
    Java frameworks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些在云环境和Java框架中进行性能调优的知名工具：
- en: '**Profilers**: Identify hotspots and bottlenecks in your code:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析器**：识别代码中的热点和瓶颈：'
- en: '**Cloud**:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云**：'
- en: '**Amazon CodeGuru Profiler**: Identifies performance bottlenecks and optimization
    opportunities in AWS environments'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon CodeGuru Profiler**：在AWS环境中识别性能瓶颈和优化机会'
- en: '**Azure Application Insights**: Provides profiling insights for .NET applications
    running in Azure'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Application Insights**：为在Azure中运行的.NET应用程序提供分析洞察'
- en: '**Google Cloud Profiler**: Analyzes the performance of Java and Go applications
    on the **Google Cloud** **Platform** (**GCP**)'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud Profiler**：分析在**Google Cloud平台**（**GCP**）上运行的Java和Go应用程序的性能'
- en: '**Java frameworks**:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java框架**：'
- en: '**JProfiler**: Commercial profiler for detailed analysis of CPU, memory, and
    thread usage'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JProfiler**：用于详细分析CPU、内存和线程使用的商业分析器'
- en: '**YourKit Java Profiler**: Another commercial option with comprehensive profiling
    capabilities'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YourKit Java Profiler**：另一个具有全面分析功能的商业选项'
- en: '**Java VisualVM**: Free tool included in the JDK, offering basic profiling
    and monitoring features'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java VisualVM**：包含在JDK中的免费工具，提供基本的分析和监控功能'
- en: '**Java Flight Recorder** (**JFR**): Built-in tool for low-overhead profiling
    and diagnostics, especially useful in production environments'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java飞行记录器**（**JFR**）：用于低开销分析和诊断的内置工具，在生产环境中特别有用'
- en: '**Benchmarks**: Compare the performance of different implementations of the
    same task:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基准测试**：比较同一任务的不同实现性能：'
- en: '**Cloud**:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云**：'
- en: '**AWS Lambda power tuning**: Optimizes memory and concurrency settings for
    Lambda functions'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Lambda性能调优**：优化Lambda函数的内存和并发设置'
- en: '**Azure performance benchmarks**: Provides reference scores for various VM
    types and workloads in Azure'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure性能基准测试**：为Azure中各种虚拟机类型和工作负载提供参考分数'
- en: '**Google Cloud benchmarks**: Offers performance data for different compute
    options on GCP'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud基准测试**：提供GCP上不同计算选项的性能数据'
- en: '**Java frameworks**:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java框架**：'
- en: '**Java Microbenchmark Harness** (**JMH**): Framework for creating reliable
    and accurate microbenchmarks'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java微基准测试工具**（**JMH**）：用于创建可靠和精确微基准测试的框架'
- en: '**Caliper**: Another Microbenchmark framework from Google'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Caliper**：来自Google的另一个微基准测试框架'
- en: '**SPECjvm2008**: Standardized benchmark suite for measuring Java application
    performance'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SPECjvm2008**：用于衡量Java应用程序性能的标准基准测试套件'
- en: '**Monitoring tools**: Continuously track and assess the performance and health
    of diverse resources such as CPU, disk, and network usage, and application performance
    metrics:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控工具**：持续跟踪和评估各种资源的性能和健康状况，如CPU、磁盘和网络使用情况以及应用程序性能指标：'
- en: '**Cloud**:'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云**：'
- en: '**Amazon CloudWatch**: Monitors various metrics across AWS services, including
    CPU, memory, disk, and network usage'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon CloudWatch**：监控AWS服务中的各种指标，包括CPU、内存、磁盘和网络使用情况'
- en: '**Azure Monitor**: Provides comprehensive monitoring for Azure resources, including
    application performance metrics'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Monitor**：为Azure资源提供全面的监控，包括应用程序性能指标'
- en: '**Google Cloud Monitoring**: Offers monitoring and logging capabilities for
    GCP resources'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud Monitoring**：为GCP资源提供监控和日志记录功能'
- en: '**Java frameworks**:'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java框架**：'
- en: '**Java Management Extensions** (**JMX**): Built-in API for exposing management
    and monitoring information from Java applications'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java管理扩展**（**JMX**）：Java应用程序暴露管理和监控信息的内置API'
- en: '**Micrometer**: Framework for collecting and exporting metrics to different
    monitoring systems (e.g., Prometheus and Graphite)'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Micrometer**：用于收集和导出指标到不同监控系统的框架（例如 Prometheus 和 Graphite）。'
- en: '**Spring Boot Actuator**: Provides production-ready endpoints for monitoring
    Spring Boot applications.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot Actuator**：提供用于监控 Spring Boot 应用程序的现成端点。'
- en: By mastering these tools and metrics, you can transform from a blindfolded speed
    demon to a data-driven maestro, confidently wielding the power of parallel processing
    while ensuring optimal performance and efficiency.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握这些工具和指标，您可以从蒙眼的速度恶魔转变为数据驱动的指挥家，自信地运用并行处理的力量，同时确保最佳性能和效率。
- en: 'In the next section, we’ll tackle the other side of the coin: the potential
    pitfalls of parallelism. We’ll delve into thread contention, race conditions,
    and other challenges you might encounter.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨并行主义的另一面：并行性的潜在陷阱。我们将深入研究线程竞争、竞态条件和您可能遇到的其它挑战。
- en: Challenges and solutions in parallel processing
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行处理中的挑战与解决方案
- en: 'Parallel processing accelerates computation but comes with challenges such
    as thread contention, race conditions, and debugging complexities. Understanding
    and addressing these issues is crucial for efficient parallel computing. Let us
    dive into gaining an insight into each of these issues:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理加速了计算，但伴随着线程竞争、竞态条件和调试复杂性等挑战。理解和解决这些问题对于高效的并行计算至关重要。让我们深入了解这些问题：
- en: '**Thread contention**: This occurs when multiple threads compete for the same
    resources, leading to performance issues such as increased waiting times, resource
    starvation, and deadlocks.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程竞争**：当多个线程竞争相同资源时发生，导致性能问题，如增加的等待时间、资源饥饿和死锁。'
- en: '**Race conditions**: These happen when multiple threads access shared data
    unpredictably, causing problems such as data corruption and unreliable program
    behavior.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞态条件**：当多个线程不可预测地访问共享数据时，就会发生这种情况，导致数据损坏和不可靠的程序行为。'
- en: '**Debugging complexities**: Debugging in a multithreaded environment is challenging
    due to non-deterministic behavior and hidden dependencies, such as shared state
    dependency and order of execution dependency. These dependencies often arise from
    the interactions between threads that are not explicit in the code but can affect
    the program’s behavior.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试复杂性**：在多线程环境中调试具有挑战性，因为存在非确定性行为和隐藏的依赖关系，例如共享状态依赖和执行顺序依赖。这些依赖关系通常源于代码中未明确表示的线程交互，但可能影响程序的行为。'
- en: 'While these challenges may seem daunting, they’re not insurmountable. Let’s
    dive into practical strategies for mitigating these pitfalls:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些挑战可能看起来令人畏惧，但它们并非不可逾越。让我们深入了解缓解这些陷阱的实际策略：
- en: '`ConcurrentHashMap` or `ConcurrentLinkedQueue` when dealing with shared data,
    preventing concurrent access issues and data corruption.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`或`ConcurrentLinkedQueue`在处理共享数据时，防止并发访问问题和数据损坏。'
- en: '**Employ lock-free algorithms**: Consider lock-free algorithms such as **compare-and-swap**
    (**CAS**) operations, which avoid overhead associated with traditional locks and
    can improve performance while mitigating contention.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采用无锁算法**：考虑使用无锁算法，如**比较并交换**（**CAS**）操作，这些操作避免了与传统锁相关的开销，可以提高性能同时减轻竞争。'
- en: '`AtomicInteger`, which guarantee thread-safe updates to underlying values.*   **Mastering**
    **parallel debugging**:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicInteger`，它保证了底层值的线程安全更新。*   **精通** **并行调试**：'
- en: '**Use visual debuggers with thread views**: Debuggers such as Eclipse or IntelliJ
    IDEA offer specialized views for visualizing thread execution timelines, identifying
    deadlocks, and pinpointing race conditions'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用具有线程视图的可视化调试器**：例如 Eclipse 或 IntelliJ IDEA 这样的调试器提供了用于可视化线程执行时间线、识别死锁和定位竞态条件的专用视图。'
- en: '**Leverage logging with timestamps**: Strategically add timestamps to your
    logs in multithreaded code, helping you reconstruct the sequence of events and
    identify the thread responsible for issues'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用带时间戳的日志**：在多线程代码中策略性地添加时间戳到日志中，有助于您重建事件序列并识别导致问题的线程。'
- en: '**Employ assertion checks**: Place assertional checks at critical points in
    your code to detect unexpected data values or execution paths that might indicate
    race conditions'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采用断言检查**：在代码的关键点放置断言检查，以检测可能表明竞态条件的不预期的数据值或执行路径。'
- en: '**Consider automated testing tools**: Tools such as JUnit with parallel execution
    capabilities can help you uncover concurrency-related issues early on in the development
    process'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑自动化测试工具**：具有并行执行能力的工具，如JUnit，可以帮助你在开发早期阶段发现并发相关的问题'
- en: 'Here are a few real-world examples of how to avoid these issues in AWS:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些如何在AWS中避免这些问题的实际例子：
- en: '**Amazon SQS – Parallel processing for** **message queue**:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon SQS – 消息队列的并行处理**：'
- en: '**Use case**: Implementing parallel processing for message queue handling with
    **Amazon Simple Queue Service** (**SQS**) using its batch operations'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：使用Amazon Simple Queue Service（SQS）的批量操作实现消息队列处理的并行处理'
- en: '**Scenario**: A system needs to process a high volume of incoming messages
    efficiently'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**：一个系统需要高效地处理大量传入的消息'
- en: '**Implementation**: Instead of processing messages one by one, the system uses
    Amazon SQS’s batch operations to process multiple messages in parallel.'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现**：而不是逐个处理消息，系统使用Amazon SQS的批量操作并行处理多个消息。'
- en: '**Advantage**: This approach minimizes thread contention, as multiple messages
    are read and written in batches rather than competing for individual message handling'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优势**：这种方法最小化了线程竞争，因为多个消息是批量读取和写入的，而不是为单个消息处理而竞争'
- en: '**Amazon DynamoDB – Atomic updates and** **conditional writes**:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon DynamoDB – 原子更新和条件写入**：'
- en: '**Use case**: Utilizing DynamoDB’s atomic updates and conditional writes for
    safe parallel data access and modification.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：利用DynamoDB的原子更新和条件写入进行安全的并行数据访问和修改。'
- en: '**Scenario**: An online store tracks product inventory in DynamoDB and needs
    to update inventory levels safely when multiple purchases occur simultaneously.'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**：一个在线商店在DynamoDB中跟踪产品库存，并在多个购买同时发生时需要安全地更新库存水平。'
- en: '**Implementation**: When processing a purchase, the system uses DynamoDB’s
    atomic updates to adjust inventory levels. Conditional writings ensure that updates
    happen only if the inventory level is sufficient, preventing race conditions.'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现**：在处理购买时，系统使用DynamoDB的原子更新来调整库存水平。条件写入确保只有在库存水平足够的情况下才会进行更新，从而防止竞争条件。'
- en: '**Advantage**: This ensures inventory levels are accurately maintained even
    with concurrent purchase transactions.'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优势**：这确保了即使在并发购买交易的情况下，库存水平也能被准确维护。'
- en: '**AWS Lambda – Stateless functions and** **resource management**:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Lambda – 无状态函数和资源管理**：'
- en: '**Use case**: Designing AWS Lambda functions to be stateless and avoiding shared
    resources for simpler and safer concurrent executions.'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：设计AWS Lambda函数为无状态，避免共享资源，以实现更简单、更安全的并发执行。'
- en: '**Scenario**: A web application uses Lambda functions to handle user requests,
    such as retrieving user data or processing transactions.'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**：一个Web应用程序使用Lambda函数来处理用户请求，例如检索用户数据或处理交易。'
- en: '**Implementation**: Each Lambda function is designed to be stateless, meaning
    it doesn’t rely on or alter shared resources. Any required data is passed to the
    function in its request.'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现**：每个Lambda函数都被设计为无状态的，这意味着它不依赖于或改变共享资源。任何所需的数据都通过其请求传递给函数。'
- en: '**Advantage**: This stateless design simplifies Lambda execution and reduces
    the risk of data inconsistencies or conflicts when the same function is invoked
    concurrently for different users.'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优势**：这种无状态设计简化了Lambda执行，并减少了当同一函数因不同用户并发调用而出现数据不一致或冲突的风险。'
- en: In each of these cases, the goal is to leverage AWS’ built-in features to handle
    concurrency effectively, ensuring that applications remain robust, scalable, and
    error-free. By embracing these best practices and practical solutions, you can
    navigate the complexities of parallel processing with confidence. Remember, mastering
    concurrency requires a careful balance between speed, efficiency, and reliability.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，目标是通过利用AWS的内置功能来有效地处理并发，确保应用程序保持健壮、可扩展和错误-free。通过采用这些最佳实践和实际解决方案，你可以自信地应对并行处理的复杂性。记住，掌握并发需要仔细平衡速度、效率和可靠性。
- en: In the next section, we’ll explore the trade-offs of parallel processing, helping
    you make informed decisions about when to harness its power and when to stick
    with proven sequential approaches.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨并行处理的权衡，帮助你做出明智的决定，何时利用其力量，何时坚持使用经过验证的顺序方法。
- en: Evaluating parallelism in software design – balancing performance and complexity
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估软件设计中的并行性 – 平衡性能和复杂性
- en: Implementing parallel processing in software design involves critical trade-offs
    between the potential for increased performance and the added complexity it brings.
    A careful assessment is essential to determine whether parallelization is justified.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计中实现并行处理涉及在提高性能的潜力与它带来的额外复杂性之间的关键权衡。进行仔细的评估是确定并行化是否合理的必要条件。
- en: 'Here are the considerations for parallelization:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是并行化的考虑因素：
- en: '**Task suitability**: Evaluate whether the task is suitable for parallelization
    and whether the expected performance gains justify the added complexity'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务适宜性**：评估任务是否适合并行化，以及预期的性能提升是否足以证明增加的复杂性是合理的。'
- en: '**Resource availability**: Assess the hardware capabilities, such as CPU cores
    and memory, needed for effective parallel execution'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源可用性**：评估有效并行执行所需的硬件能力，如CPU核心和内存。'
- en: '**Development constraints**: Consider available time, budget, and expertise
    for developing and maintaining a parallelized system'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发限制**：考虑开发和维护并行化系统所需的时间、预算和专业知识。'
- en: '**Expertise requirements**: Ensure your team has the skills required for parallel
    programming'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专业知识要求**：确保你的团队拥有并行编程所需的技能。'
- en: The approach to parallel processing should begin with simple, modular designs
    for an easier transition to parallelism. Benchmarking is vital to gauge potential
    performance improvements. Opt for incremental refactoring, supported by comprehensive
    testing at each step, to ensure smooth integration of parallel processes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理的方法应该从简单、模块化的设计开始，以便更容易过渡到并行化。基准测试对于衡量潜在的性能改进至关重要。选择增量重构，并在每一步都进行全面的测试，以确保并行过程的顺利集成。
- en: From all this discussion, we conclude that parallel processing can substantially
    enhance performance, but successful implementation demands a balanced approach,
    considering task suitability, resource availability, and the development team’s
    expertise. It’s a potent tool that, when used judiciously and designed with clarity,
    can lead to efficient and maintainable code. Remember, while parallel processing
    is powerful, it’s not a universal solution and should be employed strategically.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些讨论中，我们得出结论，并行处理可以显著提高性能，但成功的实施需要平衡的方法，考虑到任务适宜性、资源可用性和开发团队的专长。这是一个强大的工具，当谨慎使用并清晰设计时，可以导致高效且易于维护的代码。记住，尽管并行处理很强大，但它不是万能的解决方案，应该有策略地使用。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was your invitation to this fascinating world of parallel processing,
    where we explored the tools at your disposal. First up was the Fork/Join framework.
    Your head chef, adept at breaking down daunting tasks into bite-sized sub-recipes,
    ensured everyone had a role to play. But efficiency is key, and that’s where the
    work-stealing algorithm kicked in. Think of it as chefs who glanced over each
    other’s shoulders, jumped in to help if anyone fell behind, and kept the kitchen
    humming like a well-oiled machine.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是邀请您进入这个迷人的并行处理世界的邀请，我们探索了您可用的工具。首先是Fork/Join框架。您的总厨师，擅长将艰巨的任务分解成小份的子食谱，确保每个人都有一份角色扮演。但效率是关键，这就是工作窃取算法介入的地方。想象一下，厨师们互相看了看对方的肩膀，如果有人落后，就跳进去帮忙，并保持厨房像一台运转良好的机器一样嗡嗡作响。
- en: However, not all tasks are created equal. That’s where `RecursiveTask` and `RecursiveAction`
    stepped in. They were like chefs specializing in different courses, one meticulously
    chopped vegetables while the other stirred a simmering sauce, each focused on
    their own piece of the culinary puzzle.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有任务都是平等的。这就是`RecursiveTask`和`RecursiveAction`介入的地方。它们就像专注于不同课程的厨师，一个细致地切菜，另一个搅拌着慢炖的酱汁，每个人都专注于他们自己的烹饪难题的一部分。
- en: Now, let’s talk about efficiency. Parallel streams were like pre-washed and
    chopped ingredients, ready to be tossed into the processing pan. We saw how they
    simplify data processing on collections, using the Fork/Join framework as their
    secret weapon to boost speed, especially for those dealing with mountains of data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈效率。并行流就像预先清洗和切好的食材，准备好被扔进处理锅中。我们看到它们如何简化集合上的数据处理，使用Fork/Join框架作为他们的秘密武器来提高速度，特别是对于那些处理大量数据的人来说。
- en: However, choosing the right tool is crucial. That’s why we dived into a parallel
    processing showdown, pitting Fork/Join against other methods such as `ThreadPoolExecutor`
    and `CompletableFuture`. This helped you understand their strengths and weaknesses
    and enabled you to make informed decisions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，选择正确的工具至关重要。这就是为什么我们深入到并行处理对决中，将Fork/Join与其他方法如`ThreadPoolExecutor`和`CompletableFuture`进行对比。这帮助你理解它们的优缺点，并使你能够做出明智的决定。
- en: However, complexity lurks in the shadows. So, we also tackled the art of handling
    tasks with dependencies, learned how to break them down, and kept data synchronized.
    This ensured your culinary masterpiece didn’t turn into a chaotic scramble.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，复杂性潜伏在阴影中。因此，我们也处理了处理具有依赖关系的任务的技巧，学习了如何分解它们，并保持数据同步。这确保了你的烹饪杰作不会变成混乱的杂烩。
- en: And who doesn’t love a bit of optimization? So, we explored strategies to fine-tune
    your parallel processing and learned how to balance task sizes and parallelism
    levels for the most efficient performance, like a chef adjusting the heat and
    seasoning to perfection.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 谁不喜欢一点优化？因此，我们探索了微调你的并行处理策略，并学习了如何平衡任务大小和并行级别以获得最有效的性能，就像厨师调整热量和调味料以达到完美一样。
- en: Finally, we delved into the advanced realm of a custom Spliterator, giving you
    the power to tailor parallel stream processing for specific needs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入到自定义Spliterator的高级领域，赋予你根据特定需求定制并行流处理的能力。
- en: As every dish comes with its own trade-offs, we discussed the balance between
    performance gains and complexity, guiding you in making informed software design
    decisions that leave you feeling satisfied, not burnt out.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每道菜都有自己的权衡，我们讨论了性能提升和复杂度之间的平衡，引导你做出明智的软件设计决策，让你感到满意，而不是疲惫不堪。
- en: We’ve orchestrated a symphony of parallel processing in this chapter, but what
    happens when your culinary creations clash and pots start boiling over? That’s
    where [*Chapter 4*](B20937_04.xhtml#_idTextAnchor099) steps in, where we will
    dive deep into the Java concurrency utilities and testing, your essential toolkit
    for handling the delicate dance of multithreading.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们编排了一部并行处理的交响曲，但当你的烹饪作品冲突，锅开始沸腾时会发生什么？这就是[第4章](B20937_04.xhtml#_idTextAnchor099)介入的地方，我们将深入探讨Java并发工具和测试，这是你处理多线程微妙舞蹈的必备工具包。
- en: Questions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the primary purpose of the Fork/Join Framework in Java?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fork/Join框架在Java中的主要目的是什么？
- en: To provide a GUI interface for Java applications
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Java应用程序提供GUI界面
- en: To enhance parallel processing by recursively splitting and executing tasks
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过递归拆分和执行任务来增强并行处理
- en: To simplify database connectivity in Java applications
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化Java应用程序中的数据库连接
- en: To manage network connections in Java applications
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java应用程序中管理网络连接
- en: How do `RecursiveTask` and `RecursiveAction` differ in the Fork/Join Framework?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RecursiveTask`和`RecursiveAction`在Fork/Join框架中的区别是什么？'
- en: '`RecursiveTask` returns a value, while `RecursiveAction` does not'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RecursiveTask`返回一个值，而`RecursiveAction`不返回'
- en: '`RecursiveAction` returns a value, while `RecursiveTask` does not'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RecursiveAction`返回一个值，而`RecursiveTask`不返回'
- en: Both return values but `RecursiveAction` does so asynchronously
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者都返回值，但`RecursiveAction`是异步返回的
- en: There is no difference; they are interchangeable
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有区别；它们可以互换
- en: What role does the work-stealing algorithm play in the Fork/Join Framework?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作窃取算法在Fork/Join框架中扮演什么角色？
- en: It encrypts data for secure processing
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它加密数据以进行安全处理
- en: It allows idle threads to take over tasks from busy threads
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许空闲线程接管忙碌线程的任务
- en: It prioritizes task execution based on complexity
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它根据复杂度优先执行任务
- en: It reduces the memory footprint of the application
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它减少了应用程序的内存占用
- en: Which of the following is the best practice for optimizing parallel processing
    performance in Java?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是优化Java中并行处理性能的最佳实践？
- en: Increasing the use of shared data
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加共享数据的使用
- en: Balancing task granularity and parallelism level
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平衡任务粒度和并行级别
- en: Avoiding the use of thread-safe data structures
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免使用线程安全的数据结构
- en: Consistently using the highest possible level of parallelism
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持续使用最高可能的并行级别
- en: What factors should be considered when implementing parallel processing in software
    design?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在软件设计中实现并行处理时，应考虑哪些因素？
- en: Color schemes and UI design
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 色彩方案和UI设计
- en: The task’s nature, resource availability, and team expertise
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务的本质、资源可用性和团队的专业知识
- en: The brand of hardware being used
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在使用的硬件品牌
- en: The programming language’s popularity
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程语言的流行度
