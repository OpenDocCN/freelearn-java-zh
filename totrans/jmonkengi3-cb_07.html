<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Networking with SpiderMonkey"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Networking with SpiderMonkey</h1></div></div></div><p>This chapter will be all about using the networking engine of jMonkeyEngine, SpiderMonkey, to take our games beyond the isolation of our own computers to the Internet. Don't worry if you're not well versed in networking, we'll take it from the very beginning.</p><p>This chapter contains the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up a server and client</li><li class="listitem" style="list-style-type: disc">Handling basic messaging</li><li class="listitem" style="list-style-type: disc">Making a networked game – Battleships</li><li class="listitem" style="list-style-type: disc">Implementing a network code for FPS</li><li class="listitem" style="list-style-type: disc">Loading a level</li><li class="listitem" style="list-style-type: disc">Interpolating between player positions</li><li class="listitem" style="list-style-type: disc">Firing over a network</li><li class="listitem" style="list-style-type: disc">Optimizing the bandwidth and avoiding cheating</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Introduction</h1></div></div></div><p>Data sent over the network is organized in packets, and protocols handle them differently. Packets can look different depending on protocols, but they contain the data itself along with control information, such as addresses and formatting information.</p><p>SpiderMonkey supports<a id="id487" class="indexterm"/> both TCP and UDP. In SpiderMonkey, TCP<a id="id488" class="indexterm"/> is referred to as reliable. TCP is reliable because it verifies<a id="id489" class="indexterm"/> each network packet sent, minimizing problems due to packet loss and other errors. TCP guarantees that everything arrives safely (if at all possible). Why ever use anything else then? For speed. Reliability means that TCP can be slow. In some cases, we're not dependent on every packet reaching the destination. UDP is more suitable for streaming and low-latency applications, but the application will have to be prepared to compensate for the unreliability. This means that when a packet is lost in FPS, the game needs to know what to do. Will it just stop in its tracks, or stutter along? If a character is moving and the game can predict the movement between the messages that arrive, it will create a smoother experience.</p><p>Learning how to use the API is fairly easy, but we will also see that networking is not something you add to a game; the game needs to be adapted for it from the planning stage.</p></div></div>
<div class="section" title="Setting up a server and client"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Setting up a server and client</h1></div></div></div><p>In this <a id="id490" class="indexterm"/>recipe, we'll look at the absolute minimum in order to get a server <a id="id491" class="indexterm"/>and client up and running and be able to talk to each other.</p><p>This is accomplished in just a few lines of code.</p><p>The server and client will share some common data that we'll store inside a <code class="literal">properties</code> file for easy access and external modification. First and foremost, the client must know the address of the server, and both server and client need to know which port to listen on and connect to. These would most likely be editable from within a game.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec174"/>How to do it...</h2></div></div></div><p>Perform the following steps to set up a server and client:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the constructor of the server class, we start by loading the properties file. Once done, we can initialize the server with the following lines of code:<div class="informalexample"><pre class="programlisting">server = Network.createServer(Integer.parseInt(prop.getProperty("server.port")));
server.start();</pre></div><p>In the static block, we must also make sure that the server doesn't shut down immediately.</p></li><li class="listitem">The client is set up in a similar way, shown as follows:<div class="informalexample"><pre class="programlisting">client = Network.connectToServer(prop.getProperty("server.address"), Integer.parseInt(prop.getProperty("server.port")));
client.start();</pre></div></li><li class="listitem">To verify that a connection has taken place, we can add <code class="literal">ConnectionListener</code> to the server, as follows:<div class="informalexample"><pre class="programlisting">public void connectionAdded(Server server, HostedConnection conn) {
  System.out.println("Player connected: " + conn.getAddress());
}</pre></div></li><li class="listitem">If we connect to the server again, we should see the message printed in the server's output window.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec175"/>How it works...</h2></div></div></div><p>The <code class="literal">Network</code> class is the main class used when setting up and connecting our components. This <a id="id492" class="indexterm"/>particular method is the simplest way to create a <a id="id493" class="indexterm"/>server, simply stating a port to listen to. Let's set different ports for TCP and UDP and supply the name and version of the server.</p><p>The <code class="literal">connectToServer</code> method creates <a id="id494" class="indexterm"/>a client and connects it to the specified address and port. Like in the server case, there are other convenient methods in <code class="literal">Network</code> that let us specify more parameters if we want.</p><p>That's actually all that's needed. When running the two programs in parallel, we should see the client connected to the server. There is no verification, however, that anything has happened. That's why we added <code class="literal">ConnectionListener</code> at the end. It's an interface with two methods: <code class="literal">connectionAdded</code> and <code class="literal">connectionRemoved</code>. These methods will be called whenever a client connects or disconnects. These methods gave the server a way to communicate to us that a connection has happened. These methods will be sources for a chain of events in more advanced recipes.</p><p>Once the server is started, it begins to listen for incoming connections on the specified port. If the network address is considered the street name, the port will be the door that will be opened and made passable. So far, a mere handshake between the server and client has been made at the doorstep.</p></div></div>
<div class="section" title="Handling basic messaging"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Handling basic messaging</h1></div></div></div><p>So far, we've <a id="id495" class="indexterm"/>learned the basics to set up a server and connecting a client. However, they don't do much, so let's look into what it takes to get them to communicate with each other.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec176"/>Getting ready</h2></div></div></div><p>In SpiderMonkey, communication is handled via messaging and the message interface. When a server <a id="id496" class="indexterm"/>sends a message, it uses the <code class="literal">broadcast()</code> method, while a client uses <code class="literal">send()</code>. The side that is supposed to receive the message has to have a suitable <code class="literal">MessageListener</code> class. To try all these things out, let's have our server greet the connecting player by sending them a message, which will be displayed once received.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec177"/>How to do it...</h2></div></div></div><p>Perform<a id="id497" class="indexterm"/> the following steps to connect and handle basic messaging:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We begin by defining our message. It's a simple serializable bean with just one field, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">@Serializable()
public class ServerMessage extends AbstractMessage{
    private String message;

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}</pre></div></li><li class="listitem">Next, we create a class that implements <code class="literal">MessageListener</code>. It's a very simple class that will print the message to the console when received, as follows:<div class="informalexample"><pre class="programlisting">public class ServerMessageHandler implements MessageListener&lt;Client&gt;{

    public void messageReceived(Client source, Message m) {
        ServerMessage message = (ServerMessage) m;
        System.out.println("Server message: " + message.getMessage());
    }
}</pre></div></li><li class="listitem">We instantiate <code class="literal">ServerMessageHandler</code> and add it to the client, telling it to only listen for <code class="literal">ServerMessages</code>, as follows:<div class="informalexample"><pre class="programlisting">ServerMessageHandler serverMessageHandler = new ServerMessageHandler();
client.addMessageListener(serverMessageHandler, ServerMessage.class);</pre></div><p>It is also possible to let <code class="literal">ServerMessageHandler</code> handle all incoming messages by using the following line of code:</p><div class="informalexample"><pre class="programlisting">client.addMessageListener(serverMessageHandler);</pre></div></li><li class="listitem">We<a id="id498" class="indexterm"/> now tell the server to create a message and send it to all the players when someone connects:<div class="informalexample"><pre class="programlisting">ServerMessage connMessage = new ServerMessage();
String message = "Player connected from: " + conn.getAddress();
connMessage.setMessage(message);
server.broadcast(connMessage);</pre></div></li><li class="listitem">There is one more thing we need to do. All the message classes used need to be registered before being used. We do this before the application starts, as follows:<div class="informalexample"><pre class="programlisting">public static void main(String[] args ) throws Exception {
  Serializer.registerClass(ServerMessage.class);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec178"/>How it works...</h2></div></div></div><p>Spending time and defining what messages should contain is a good way to get a grip of the project as a lot of the architecture will revolve around them. The message we created in this recipe is<a id="id499" class="indexterm"/> called <code class="literal">ServerMessage</code>, because it is used to send a lot of information from the server to the client.</p><p>The next class we created was <code class="literal">MessageListener</code>. The only thing it does upon receiving the message is print it to the console. We added it to the client, and also stated that it should specifically listen for <code class="literal">ServerMessages</code>.</p><p>By default, calling <code class="literal">broadcast</code> will send the message to all the connected clients. In this case, we just want to send a message to a specific client or a group of clients (like a team). Broadcast can also be called with <code class="literal">Filter</code>. It can also send messages to a specific channel, to which a team or group of players might be assigned.</p></div></div>
<div class="section" title="Making a networked game &#x2013; Battleships"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Making a networked game – Battleships</h1></div></div></div><p>In the <a id="id500" class="indexterm"/>previous recipes, we looked at how to set up a server, and connect and handle basic messaging. In this recipe, we'll reinforce this knowledge and expand it by adding server verification and applying it to a real game.</p><p>A turn-based board game is perhaps not what you would normally develop using a 3D game SDK, but it's a very good game to learn networking. The Battleships game is a good example not only because the rules are simple and known to many but also because it has a hidden element, which will help us understand the concept of server verification.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>If you're<a id="id501" class="indexterm"/> unfamiliar with the Battleships game, visit <a class="ulink" href="http://www.wikipedia.org/wiki/Batt">http://www.wikipedia.org/wiki/Batt</a>.</p></div></div><p>Since we're mainly interested in the networking aspects of the game, we'll skip some of the verification normally needed such as looking for overlapping ships. We also won't write any graphical interface and use the command prompt to obtain input. Again, to focus on the networking API, some of the plain Java logic for game rules won't be explained.</p><p>The game will have a client and server class. Each class will have a <code class="literal">MessageListener</code> implementation and share messages and game objects.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec179"/>Getting ready</h2></div></div></div><p>It is highly recommended to familiarize yourself with the content of the previous recipes in the chapter, if you haven't already.</p><p>The amount of messages will increase greatly compared to the previous recipes. Since both the server and client need to keep a track of the same messages and they need to be registered in the same order, we can create a <code class="literal">GameUtil</code> class. It has a static method called <code class="literal">initialize()</code>. For every new message type we create, we add a line like this:</p><div class="informalexample"><pre class="programlisting">Serializer.registerClass(WelcomeMessage.class);</pre></div><p>The game revolves around a couple of objects that we'll define before getting into the networking aspect.</p><p>We need a <code class="literal">Ship</code> class. For this implementation, it only needs the <code class="literal">name</code> and <code class="literal">segments</code> fields. We add methods so that once a tile containing <code class="literal">Ship</code> is hit, we can decrease the segments. When segments reach zero, it's sunk. Likewise, <code class="literal">Player</code> can be a simple class, with only an ID necessary for identification with the server, and the number of ships still alive. If the number of ships reaches zero, the player loses.</p><p>Many of the message types extend a class called <code class="literal">GameMessage</code>. This class in turn extends <code class="literal">AbstractMessage</code> and needs to contain the ID of the game, and state that the message should be reliable, thus using the TCP protocol.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec180"/>How to do it...</h2></div></div></div><p>We start by <a id="id502" class="indexterm"/>setting up a <code class="literal">Game</code> class. This will consist of the following six steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, the <code class="literal">Game</code> class needs an ID. This is used by the server to keep track of which game messages to relate to (since it supports many games at the same time), and will also be used as a reference for other things.</li><li class="listitem">The <code class="literal">Game</code> class needs the two <code class="literal">Player</code> objects, <code class="literal">player1</code> and <code class="literal">player2</code>, as well as the ID of the player whose turn it currently is. We can call that <code class="literal">currentPlayerId</code>.</li><li class="listitem">The <code class="literal">Game</code> class needs two boards; one for each player. The boards will be made of 2D <code class="literal">Ship</code> arrays. Each tile where there is a segment of a ship has a reference to the <code class="literal">Ship</code> object; the others are null.</li><li class="listitem">An integer <code class="literal">status</code> field lets <a id="id503" class="indexterm"/>us know what state the game currently is in, which is useful for message filtering. We can also add constants for the different statuses and set a default status, as follows:<div class="informalexample"><pre class="programlisting">public final static int GAME_WAITING = 0;
public final static int GAME_STARTED = 1;
public final static int GAME_ENDED = 2;
private int status = GAME_WAITING;</pre></div></li><li class="listitem">Now, we add a <code class="literal">placeShip</code> method. The method in this implementation is simplified and only contains verification that the ship is inside the board, as follows:<div class="informalexample"><pre class="programlisting">public void placeShip(int playerId, int shipId, int x, int y, boolean horizontal){
  Ship s = GameUtil.getShip(shipId);
  Ship[][] board;
  if(playerId == playerOne.getId()){
    board = boardOne;
    playerOne.increaseShips();
  } else {
    board = boardTwo;
    playerTwo.increaseShips();
  }
  for(int i = 0;i &lt; s.getSegments(); i++){
    [verify segment is inside board bounds]
  }
}</pre></div></li><li class="listitem">The other method that does some work in the <code class="literal">Game</code> class is <code class="literal">applyMove</code>. This takes <code class="literal">FireActionMessage</code> as input, checking the supplied tile to see whether there is a ship in that spot. It then checks whether the supposed ship is sunk, and whether the player has any ships left. If a ship is hit, it returns the <code class="literal">Ship</code> object to the calling method, as follows:<div class="informalexample"><pre class="programlisting">public Ship applyMove(FireActionMessage action){
  int x = action.getX();
  int y = action.getY();
  Ship ship = null;
  if(action.getPlayerId() == playerOne.getId()){
    ship = boardTwo[x][y];
    if(ship != null){
      ship.hit();
      if(ship.isSunk()){
        playerTwo.decreaseShips();
      }
    }
  } else {
      [replicate for playerTwo]
}
  if(playerTwo.getShips() &lt; 1 || playerOne.getShips() &lt; 1){
    status = GAME_ENDED;
  }
  if(action.getPlayerId() == playerTwo.getId()){
    turn++;
  }
  return ship;
}</pre></div></li></ol></div><p>Now, let's have <a id="id504" class="indexterm"/>a look at the server side of things. In the previous chapters, we had a look at connecting the clients, but a full game requires a bit more communication to set things up as we will see. This section will have the following eight steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Since the server is meant to handle several instances of a game at once, we'll define a couple of <code class="literal">HashMaps</code> to keep a track of the game objects. For each game we create, we put the <code class="literal">Game</code> object in the <code class="literal">games</code> map with the ID as a key:<div class="informalexample"><pre class="programlisting">private HashMap&lt;Integer, Game&gt; games = new HashMap&lt;Integer, Game&gt;();</pre></div></li><li class="listitem">We'll also use <code class="literal">Filters</code> to only send messages to players in a related game. To do this, we store a list of <code class="literal">HostedConnections</code>, with each being an address to a client, with the game ID as a key:<div class="informalexample"><pre class="programlisting">private HashMap&lt;Integer, List&lt;HostedConnection&gt;&gt; connectionFilters = new HashMap&lt;Integer, List&lt;HostedConnection&gt;&gt;();</pre></div></li><li class="listitem">Since<a id="id505" class="indexterm"/> we're continuously giving out a new player ID and increasing the value of the game ID, we'll have two fields for that as well: <code class="literal">nextGameId</code> and <code class="literal">nextPlayerId</code>.</li><li class="listitem">Everything starts with a connecting client. Like in the <span class="emphasis"><em>Setting up a server and client</em></span> recipe, we use <code class="literal">ConnectionListener</code> to handle this. The method either adds the player to an existing game, or creates a new one if none are available. Regardless of whether a new game is created or not, the <code class="literal">addPlayer</code> method is called afterwards, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">public void connectionAdded(Server server, HostedConnection conn) {
  Game game = null;
  if(games.isEmpty() || games.get(nextGameId - 1).getPlayerTwo() != null){
    game = createGame();
  } else {
    game = games.get(nextGameId - 1);
  }
  addPlayer(game, conn);
}</pre></div></li><li class="listitem">The <code class="literal">createGame</code> method creates a new <code class="literal">game</code> object and sets the correct ID. After placing it in the <code class="literal">games</code> map, it creates a new <code class="literal">List&lt;HostedConnection&gt;</code> called <code class="literal">connsForGame</code> and adds it to the <code class="literal">connectionFilters</code> map. The <code class="literal">connsForGame</code> list is empty for now, but will be populated as players connect:<div class="informalexample"><pre class="programlisting">private Game createGame(){
  Game game = new Game();
  game.setId(nextGameId++);
  games.put(game.getId(), game);
  List&lt;HostedConnection&gt; connsForGame = new ArrayList&lt;HostedConnection&gt;();
  connectionFilters.put(game.getId(), connsForGame);
  return game;
}</pre></div></li><li class="listitem">The first thing the <code class="literal">addPlayer</code> method does is create a new <code class="literal">Player</code> object and then set the ID of it. We use <code class="literal">WelcomeMessage</code> to send the ID back to the player:<div class="informalexample"><pre class="programlisting">private void addPlayer(Game game, HostedConnection conn){
  Player player = new Player();
  player.setId(nextPlayerId++);</pre></div></li><li class="listitem">The <a id="id506" class="indexterm"/>server broadcasts this message using the client's connection as a filter, ensuring it's the only recipient of the message, as follows:<div class="informalexample"><pre class="programlisting">  WelcomeMessage welcomeMessage = new WelcomeMessage();
  welcomeMessage.setMyPlayerId(player.getId());
  server.broadcast(Filters.in(conn), welcomeMessage);</pre></div></li><li class="listitem">It then decides whether the player is the first or second to connect to the game, and adds the player's <code class="literal">HostedConnection</code> instance to the list of connections associated with this game, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">  if(game.getPlayerOne() == null){
    game.setPlayerOne(player);
  } else {
    game.setPlayerTwo(player);
  }
List&lt;HostedConnection&gt; connsForGame = connectionFilters.get(game.getId());
connsForGame.add(conn);</pre></div></li><li class="listitem">It then creates a <code class="literal">GameStatusMessage</code> object, letting all players in the game know the current status (which is <code class="literal">WAITING</code>) and any player information it might have, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">  GameStatusMessage waitMessage = new GameStatusMessage();
  waitMessage.setGameId(game.getId());
  waitMessage.setGameStatus(Game.GAME_WAITING);
  waitMessage.setPlayerOneId(game.getPlayerOne() != null ? game.getPlayerOne().getId() : 0);
  waitMessage.setPlayerTwoId(game.getPlayerTwo() != null ? game.getPlayerTwo().getId() : 0);
  server.broadcast(Filters.in(connsForGame), waitMessage);
}</pre></div></li></ol></div><p>We're going to take a look at message handling on the client side and see how its <code class="literal">MessageListener</code> interface will handle incoming <code class="literal">WelcomeMessages</code> and game updates:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a class called <code class="literal">ClientMessageHandler</code>, which implements <code class="literal">MessageListener</code>. First, we will walk through the part handling the start of a game.</li><li class="listitem">The <code class="literal">thisPlayer</code> object has already been instanced in the client, so all we need <a id="id507" class="indexterm"/>to do when receiving <code class="literal">WelcomeMessage</code> is set the player's ID. Additionally, we can display something to the player letting it know the connection is set up:<div class="informalexample"><pre class="programlisting">public void messageReceived(Client source, Message m) {
  if(m instanceof WelcomeMessage){
    WelcomeMessage welcomeMess = ((WelcomeMessage)m);
    Player p = gameClient.getThisPlayer();
    p.setId(welcomeMessage.getMyPlayerId());
}</pre></div></li><li class="listitem">When a <code class="literal">GameStatusMessage</code> is received, we need to accomplish three things. First, set the ID of the game. Knowing the ID of the game is not necessary for the client in this implementation, but can be useful for communication with the server:<div class="informalexample"><pre class="programlisting">else if(m instanceof GameStatusMessage){
  int status = ((GameStatusMessage)m).getGameStatus();
  switch(status){
  case Game.GAME_WAITING:
    if(game.getId() == 0 &amp;&amp; ((GameStatusMessage)m).getGameId() &gt; 0){
         game.setId(((GameStatusMessage)m).getGameId());
      }</pre></div></li><li class="listitem">Then, we set the <code class="literal">playerOne</code> and <code class="literal">playerTwo</code> fields by simply checking whether they have been set before or not. We also need to identify the player by comparing the IDs of the players in the message with the ID associated with this client. Once found, we let him or her start placing ships, as follows:<div class="informalexample"><pre class="programlisting">if(game.getPlayerOne() == null &amp;&amp; ((GameStatusMessage)m).getPlayerOneId() &gt; 0){
  int playerOneId = ((GameStatusMessage)m).getPlayerOneId();
  if(gameClient.getThisPlayer().getId() == playerOneId){
    game.setPlayerOne(gameClient.getThisPlayer());
    gameClient.placeShips();
       } else {
         Player otherPlayer = new Player();
             otherPlayer.setId(playerOneId);
    game.setPlayerOne(otherPlayer);
  }

}
game.setStatus(status);</pre></div></li><li class="listitem">When <code class="literal">TurnMessage</code> is received, we should extract <code class="literal">activePlayer</code> from it and set it on the game. If <code class="literal">activePlayer</code> is the same as <code class="literal">thisPlayer</code> of <code class="literal">gameClient</code>, set <code class="literal">myTurn</code> to <code class="literal">true</code> on <code class="literal">gameClient</code>.</li><li class="listitem">The last message to be handled by the class is the <code class="literal">FiringResult</code> message. This calls <code class="literal">applyMove</code> on the <code class="literal">game</code> object. Some kind of output should be tied to this message telling the player what happened. This example game uses <code class="literal">System.out.println</code> to convey this.</li><li class="listitem">Finally, initialize our <code class="literal">ClientMessageHandler</code> object in the constructor of the client class, as follows:<div class="informalexample"><pre class="programlisting">ClientMessageHandler messageHandler = new ClientMessageHandler(this, game);
client.addMessageListener(messageHandler);</pre></div></li></ol></div><p>With<a id="id508" class="indexterm"/> the received messages handled, we can look at the logic on the client side and the messages it sends. This is very limited as most of the game functionality is handled by the server. </p><p>The following <a id="id509" class="indexterm"/>steps show how to implement the client-side game logic:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">placeShip</code> method can be written in many different ways. Normally, you will have a graphical interface. For this recipe though, we use a command prompt, which breaks down the input to <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates and whether the ship is placed horizontally or vertically. At the end, it should send five instances of <code class="literal">PlaceShipMessages</code> to the server. For each added ship, we also call <code class="literal">thisPlayer.increaseShips()</code>.</li><li class="listitem">We also need a method called <code class="literal">setMyTurn</code>. This uses the command prompt to receive <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates to shoot at. After this, it populates <code class="literal">FireActionMessage</code>, which is sent to the server.</li><li class="listitem">For <code class="literal">PlaceShipMessage</code>, create a new class and have it extend <code class="literal">GameMessage</code>.</li><li class="listitem">The class needs to contain the ID of the player placing the ship, coordinates, and orientation of the ship. The ID of the ship refers to the position in the following array:<div class="informalexample"><pre class="programlisting">private static Ship[] ships = new Ship[]{new Ship("PatrolBoat", 2), new Ship("Destroyer", 3), new Ship("Submarine", 3), new Ship("Battleship", 4), new Ship("Carrier", 5)};</pre></div></li><li class="listitem">We create another class called <code class="literal">FireActionMessage</code>, which also extends <code class="literal">GameMessage</code>.</li><li class="listitem">This has a reference to the player firing and an <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinate.</li></ol></div><p>Message<a id="id510" class="indexterm"/> handling on the server is similar to the one on the client. We have a <code class="literal">ServerMessageHandler</code> class implementing the <code class="literal">MessageListener</code> interface. This has to handle receiving messages from the player placing ships, and firing.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Inside the <code class="literal">messageReceived</code> method, catch all <code class="literal">PlaceShipMessages</code>. Using the supplied <code class="literal">gameId</code>, we get the game instance from the server's <code class="literal">getGame</code> method and call the <code class="literal">placeShip</code> method. Once this is done, we check to see whether both players have placed all their ships. If that is the case, it's time to start the game:<div class="informalexample"><pre class="programlisting">public void messageReceived(HostedConnection conn, Message m) {
  if (m instanceof PlaceShipMessage){
    PlaceShipMessage shipMessage = (PlaceShipMessage) m;
    int gameId = shipMessage.getGameId();
    Game game = gameServer.getGame(gameId);
    game.placeShip( … );
    if(game.getPlayerOne().getShips() == 5 &amp;&amp; game.getPlayerTwo() != null&amp;&amp; game.getPlayerTwo().getShips() == 5){
      gameServer.startGame(gameId);
    }</pre></div></li><li class="listitem">In the <code class="literal">startGame</code> method, the first thing we need to do is send a message to let the players know the game is now started. We know what clients to send the message to by getting the list of connections from the <code class="literal">connectionFilters</code> map as follows:<div class="informalexample"><pre class="programlisting">public Game startGame(int gameId){
  Game game = games.get(gameId);
  List&lt;HostedConnection&gt; connsForGame = connectionFilters.get(gameId);
  GameStatusMessage startMessage = new GameStatusMessage();
  startMessage.setGameId(game.getId());
  startMessage.setGameStatus(Game.GAME_STARTED);
  server.broadcast(Filters.in(connsForGame), startMessage);</pre></div></li><li class="listitem">After this, we<a id="id511" class="indexterm"/> decide which player will have the first move and send <code class="literal">TurnMessage</code> to the players, as follows:<div class="informalexample"><pre class="programlisting">  int startingPlayer = FastMath.nextRandomInt(1, 2);
  TurnMessage turnMessage = new TurnMessage();

  server.broadcast(Filters.in(connsForGame), turnMessage);
  return game;
}</pre></div></li><li class="listitem">Now, we need to define <code class="literal">TurnMessage</code>. It is another simple message, only containing the ID of the player whose turn it currently is and extending <code class="literal">GameMessage</code>.</li><li class="listitem">Back in <code class="literal">ServerMessageListener</code>, we make it ready to receive <code class="literal">FireActionMessage</code> from a player. We begin by verifying that the <code class="literal">playerId</code> of the incoming message matches with the current player on the server side. It can be implemented as follows:<div class="informalexample"><pre class="programlisting">if(m instanceof FireActionMessage){
  FireActionMessage fireAction = (FireActionMessage) m;
  int gameId = fireAction.getGameId();
  Game game = gameServer.getGame(gameId);
  if(game.getCurrentPlayerId() == fireAction.getPlayerId()){</pre></div></li><li class="listitem">Then, we call <code class="literal">applyMove</code> on the game, letting it decide whether it's a hit or not. If it's a hit, the ship will be returned. It can be implemented by typing the following code:<div class="informalexample"><pre class="programlisting">    Ship hitShip = game.applyMove(fireAction);</pre></div></li><li class="listitem">We go on and create a <code class="literal">FiringResult</code> message. This is an extension of <code class="literal">FireActionMessage</code> with additional fields for the (possible) ship being hit. It should be broadcasted to both the players letting them know whether the action was a hit or not.</li><li class="listitem">Finally, we switch the active player and send another <code class="literal">TurnMessage</code> to both the players as follows:<div class="informalexample"><pre class="programlisting">                TurnMessage turnMessage = new TurnMessage();
                turnMessage.setGameId(game.getId());
                game.setCurrentPlayerId(game.getCurrentPlayerId() == 1 ? 2 : 1);
                turnMessage.setActivePlayer(game.getCurrentPlayerId());
                gameServer.sendMessage(turnMessage);
            }</pre></div></li><li class="listitem">This flow will continue until one of the players has run out of ships. Then, we should simply send <code class="literal">GameStatusMessage</code> with the <code class="literal">END</code> status to the players and disconnect them.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec181"/>How it works...</h2></div></div></div><p>When a <a id="id512" class="indexterm"/>player launches the client, it will automatically connect to the server defined in the properties file.</p><p>The server will acknowledge this, assign a user ID to the player, and send back <code class="literal">WelcomeMessage</code> containing the ID. The job of <code class="literal">WelcomeMessage</code> is to confirm the connection to the client, and let the client know its given ID. In this implementation, it is used for future communication from the client. Another way of filtering incoming messages would be possible using the <code class="literal">HostedConnection</code> instance, as it holds a unique address to the client.</p><p>When the first player connects, a new game will be created. The game is put in the <code class="literal">WAITING</code> status until two players have connected, and both have placed their ships. For each player connecting, it creates a <code class="literal">GameStatusMessage</code> letting all players in the game know the current status (which is <code class="literal">WAITING</code>) and any player information it might have. The first player, <code class="literal">PlayerOne</code>, will receive the message twice (again when <code class="literal">PlayerTwo</code> connects), but it doesn't matter as the game will be in the <code class="literal">WAITING</code> status until both players have placed their ships.</p><p>The <code class="literal">placeShip</code> method is simplified and doesn't contain all the verification that you will normally have in a full game. Make sure that the the server checks whether a ship is outside the board, or overlapping, and make sure it's of the right type, length, and so on and send a message back if it is wrong. This method simply checks that the ship is inside bounds and skips it if it isn't. Verification can also be done on the client, but to limit exploitation, it has to be done on the server as well.</p><p>The starting player will be selected randomly and sent in a <code class="literal">TurnMessage</code> to both players stating who begins. The player is asked to enter a set of coordinates to fire at and <code class="literal">FireActionMessage</code> is sent to the server.</p><p>The server verifies the player and applies it to the board. It then broadcasts a <code class="literal">FireResult</code> message to all players with information about the action, and whether any ships are hit. If the attacked player still has ships left, it becomes his or her turn to fire.</p><p>Once a player has run out of ships, the game ends. The server broadcasts a message to all the clients and disconnects them.</p><p>The <a id="id513" class="indexterm"/>clients have very little information about the other player. The benefit of this is that it makes cheating much more difficult.</p></div></div>
<div class="section" title="Implementing a network code for FPS"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Implementing a network code for FPS</h1></div></div></div><p>Networked<a id="id514" class="indexterm"/> FPS games are a genre of games that never seem <a id="id515" class="indexterm"/>to lose popularity. In this recipe, we'll look at the basics to get a server and multiple clients up and running. We will emulate a server with a persistent environment, where players can connect and disconnect at any time.</p><p>We have the benefit of using some of the code generated in earlier chapters. The code we'll use requires some changes to be adapted to a networked game, but it will again show the benefit of using jMonkeyEngine's <code class="literal">Control</code> and <code class="literal">AppState</code> classes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec182"/>Getting ready</h2></div></div></div><p>Good recipes to read up on before this are the previous recipes in this chapter (especially <span class="emphasis"><em>Making a networked game – Battleships</em></span>, on which the architecture relies heavily) and also the <span class="emphasis"><em>Creating a reusable character control</em></span> recipe from <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>, as we will use a similar pattern here for our <code class="literal">NetworkedPlayerControl</code> implementations. To avoid repetition, this recipe will not show or explain all of the regular gameplay code.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec183"/>How to do it...</h2></div></div></div><p>We begin by defining a few classes that will be used commonly across both server and client:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First off, we define a class called <code class="literal">NetworkedPlayerControl</code> extending <code class="literal">AbstractControl</code>. We will use this both as an identifier for a player object and as a control for the spatial representation of the player.</li><li class="listitem">The class will be extended in further recipes, but for now it should keep track of an integer called <code class="literal">ID</code>.</li><li class="listitem">It also needs an abstract method called <code class="literal">onMessageReceived</code>, taking <code class="literal">PlayerMessage</code> as input. This is the method that our message handlers will call to apply changes. In <code class="literal">ServerPlayerControl</code>, the message will contain the actual input from the player, whereas <code class="literal">ClientPlayerControl</code> simply replicates what has happened on the server.</li><li class="listitem">Now, we define a class called <code class="literal">Game</code>, which will be shared by both the client and server.</li><li class="listitem">We add a <code class="literal">HashMap</code> object called <code class="literal">players</code>, where <code class="literal">playerId</code> is the key and <code class="literal">NetworkedPlayerControl</code> is the value. It keeps track of the players.</li></ol></div><p>We will<a id="id516" class="indexterm"/> need a couple of new messages for this example. All <a id="id517" class="indexterm"/>messages are assumed to be in a bean pattern with getters and setters. We define the messages with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a base message to be used for player-related information and call it <code class="literal">PlayerMessage</code>, extending <code class="literal">AbstractMessage</code>. This only needs an integer called <code class="literal">playerId</code>.</li><li class="listitem">We create the first message that extends <code class="literal">PlayerMessage</code>. It is called <code class="literal">PlayerActionMessage</code> and handles player input. This should be set to be reliable as we don't want to ever miss a player's input.</li><li class="listitem">Since player input can either be a key press or mouse click, it needs to have both a Boolean value called <code class="literal">pressed</code> and a float value called <code class="literal">floatValue</code>.</li><li class="listitem">In addition, we also have to add a String value called <code class="literal">action</code>.</li><li class="listitem">We extend <code class="literal">PlayerMessage</code> in another class called <code class="literal">PlayerUpdateMessage</code>. This will be used to distribute player location information from the server to the clients. This should not be reliable to avoid unnecessary delays.</li><li class="listitem">It has a <code class="literal">Vector3f</code> field called <code class="literal">position</code> and a <code class="literal">Quaternion</code> field called <code class="literal">lookDirection</code>.</li></ol></div><p>With the messages defined, let's see what the server code looks like:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We define a new class called <code class="literal">FPSServer</code>, which extends <code class="literal">SimpleApplication</code>.</li><li class="listitem">It needs to keep track of the following fields. Apart from the <code class="literal">Server</code> field, it also keeps track of the next ID to give to a connecting player, a Game, and a Map of all the currently connected players, with their connection as the key:<div class="informalexample"><pre class="programlisting">private Server server;
private int nextPlayerId = 1;
private Game game;
private HashMap&lt;HostedConnection, ServerPlayerControl&gt; playerMap = new HashMap&lt;HostedConnection, ServerPlayerControl&gt;();</pre></div></li><li class="listitem">Like in the previous recipe, we use a class called <code class="literal">GameUtil</code> to register all our message classes. We also set <code class="literal">frameRate</code> to <code class="literal">30 fps</code>. This might be different depending on the game type. Finally, we start the application in the headless mode, to save resources as follows:<div class="informalexample"><pre class="programlisting">public static void main(String[] args ) throws Exception{
  GameUtil.initialize();
  FPSServer gameServer = new FPSServer();
  AppSettings settings = new AppSettings(true);
  settings.setFrameRate(30);
  gameServer.setSettings(settings);
  gameServer.start(JmeContext.Type.Headless);
}</pre></div></li><li class="listitem">We<a id="id518" class="indexterm"/> initialize the server as in the <span class="emphasis"><em>Making a networked game ‑ Battleships</em></span> recipe and create a <code class="literal">ConnectionListener</code> instance to look for connecting and disconnecting players. This <a id="id519" class="indexterm"/>will call <code class="literal">addPlayer</code> and <code class="literal">removePlayer</code> respectively, when players connect or disconnect.</li><li class="listitem">In the <code class="literal">addPlayer</code> method, we create a new <code class="literal">ServerPlayerControl</code> instance, which is the server-side implementation of <code class="literal">NetworkedPlayerControl</code>, and assign an ID to it for easier reference, as follows:<div class="informalexample"><pre class="programlisting">private void addPlayer(Game game, HostedConnection conn){
  ServerPlayerControl player = new ServerPlayerControl();
  player.setId(nextPlayerId++);
  playerMap.put(conn, player);
  game.addPlayer(player);</pre></div></li><li class="listitem">Then, we create a spatial for it so that it has a reference in the scene graph (and thus, it will be automatically updated). This is not only for visual representation, but we are dependent on it to update our method, as follows:<div class="informalexample"><pre class="programlisting">  Node s = new Node("");
  s.addControl(player);
  rootNode.attachChild(s);</pre></div></li><li class="listitem">For any future communication with the server, the client will supply its <code class="literal">playerId</code> in all messages, so the server sends the assigned ID back to the client in <code class="literal">WelcomeMessage</code>. It broadcasts the message using the client's connection as a filter, as follows:<div class="informalexample"><pre class="programlisting">  WelcomeMessage welcomeMessage = new WelcomeMessage();
  welcomeMessage.setMyPlayerId(player.getId());
  server.broadcast(Filters.in(conn), welcomeMessage);</pre></div></li><li class="listitem">Then, we<a id="id520" class="indexterm"/> send information about <a id="id521" class="indexterm"/>all the other players to the player that joins, as follows:<div class="informalexample"><pre class="programlisting">  Collection&lt;NetworkedPlayerControl&gt; players = game.getPlayers().values();
  for(NetworkedPlayerControl p: players){
    PlayerJoinMessage joinMessage = new PlayerJoinMessage();
    joinMessage.setPlayerId(p.getId());
    server.broadcast(Filters.in(conn), joinMessage);
  }</pre></div></li><li class="listitem">Lastly, the server sends a message to all the other players about the new player, as follows:<div class="informalexample"><pre class="programlisting">  PlayerJoinMessage joinMessage = new PlayerJoinMessage();
  joinMessage.setPlayerId(player.getId());
  server.broadcast(joinMessage);
}</pre></div></li><li class="listitem">The <code class="literal">removePlayer</code> method works similarly, but it only has to send a message to each player currently connected about the disconnected player. It also uses <code class="literal">PlayerJoinMessage</code> but it sets the <code class="literal">leaving</code> Boolean to <code class="literal">true</code> to indicate the player is leaving, not joining the game.</li><li class="listitem">Then, the server will continuously send location and rotation (direction) updates to all players. Since we set <code class="literal">fps</code> to <code class="literal">30</code>, it will try to do this every 33 ms as follows:<div class="informalexample"><pre class="programlisting">public void simpleUpdate(float tpf) {
  super.simpleUpdate(tpf);
  Collection&lt;NetworkedPlayerControl&gt; players = game.getPlayers().values();
  for(NetworkedPlayerControl p: players){
    p.update(tpf);
    PlayerUpdateMessage updateMessage = new PlayerUpdateMessage();
    updateMessage.setPlayerId(p.getId());
updateMessage.setLookDirection(p.getSpatial().getLocalRotation());
updateMessage.setPosition(p.getSpatial().getLocalTranslation());
    updateMessage.setYaw(p.getYaw());
    server.broadcast(updateMessage);
  }
}</pre></div></li><li class="listitem">We<a id="id522" class="indexterm"/> also create a <code class="literal">ServerMessageHandler</code> class that implements <code class="literal">MessageListener</code>. It's a short <a id="id523" class="indexterm"/>class in this case, which will only listen to messages extending <code class="literal">PlayerMessage</code> and pass it on to the correct <code class="literal">NetworkedPlayerControl</code> class to update it. In this recipe, this will mean the input coming from the player, as follows:<div class="informalexample"><pre class="programlisting">public void messageReceived(HostedConnection source, Message m) {
  if(m instanceof PlayerMessage){
    PlayerMessage message = (PlayerMessage)m;
    NetworkedPlayerControl p = game.getPlayer(message.getPlayerId());
    p.onMessageReceived(message);
  }
}</pre></div></li><li class="listitem">For the server-side implementation of the <code class="literal">NetworkedPlayerControl</code> class, we extend it to a new class called <code class="literal">ServerPlayerControl</code>.</li><li class="listitem">Similar to the <code class="literal">GameCharacterControl</code> class from <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>, we will use a set of Booleans to keep track of the input, as follows:<div class="informalexample"><pre class="programlisting">boolean forward = false, backward = false, leftRotate = false, rightRotate = false, leftStrafe = false, rightStrafe = false;</pre></div></li><li class="listitem">In the implemented <code class="literal">onMessageReceived</code> method, listen for <code class="literal">PlayerMessages</code>. We don't know if it will contain Boolean or float values, so we look for both, as follows:<div class="informalexample"><pre class="programlisting">public void onMessageReceived(PlayerMessage message) {
  if(message instanceof PlayerActionMessage){
    String action = ((PlayerActionMessage) message).getAction();
    boolean value = ((PlayerActionMessage) message).isPressed();
    float floatValue = ((PlayerActionMessage) message).getFloatValue();</pre></div></li><li class="listitem">Then, we apply the values as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">if (action.equals("StrafeLeft")) {
  leftStrafe = value;
} else if (action.equals("StrafeRight")) {
  rightStrafe = value;
}
...
else if (action.equals("RotateLeft")) {
  rotate(floatValue);
} else if (action.equals("RotateRight")) {
  rotate(-floatValue);
 }</pre></div></li><li class="listitem">In the overridden <code class="literal">controlUpdate</code> method, we then modify the position and rotation of the spatial based on the input, just like we did in the <span class="emphasis"><em>Creating a reusable character control</em></span> recipe of <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>.</li></ol></div><p>The client <a id="id524" class="indexterm"/>is simple in many ways, since it basically <a id="id525" class="indexterm"/>only does two things. It takes a player's input, sends it to the server, receives updates from the server, and applies them as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We begin by creating a new class called <code class="literal">FPSClient</code> extending <code class="literal">SimpleApplication</code>.</li><li class="listitem">In the constructor, we read the network properties file and connect to the server, as follows:<div class="informalexample"><pre class="programlisting">Properties prop = new Properties();   prop.load(getClass().getClassLoader().getResourceAsStream("network/resources/network.properties"));
        client = Network.connectToServer(prop.getProperty("server.name"), Integer.parseInt(prop.getProperty("server.version")), prop.getProperty("server.address"), Integer.parseInt(prop.getProperty("server.port")));</pre></div></li><li class="listitem">Just as with the server, we register all the message classes before launching the application.</li><li class="listitem">The application should have a reference to a <code class="literal">Node</code> class called <code class="literal">playerModel</code>, which will be the visual representation of the players in the game. There should also be a <code class="literal">ClientPlayerControl</code> class called <code class="literal">thisPlayer</code>.</li><li class="listitem">In the <code class="literal">simpleInitApp</code> method, we attach <code class="literal">InputAppState</code>. This has the same functionality as the one in the <span class="emphasis"><em>Creating an input AppState object</em></span> recipe of <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>. The only difference is it will benefit from having a direct way of reaching the client to send messages:<div class="informalexample"><pre class="programlisting">public void simpleInitApp() {
  InputAppState inputAppState = new InputAppState();
  inputAppState.setClient(this);
  stateManager.attach(inputAppState);</pre></div></li><li class="listitem">Next, we <a id="id526" class="indexterm"/>create <code class="literal">playerGeometry</code> to be used for all the players in this example, as follows:<div class="informalexample"><pre class="programlisting">  Material playerMaterial  = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");
  playerGeometry = new Geometry("Player", new Box(1f,1f,1f));
  playerGeometry.setMaterial(playerMaterial);</pre></div></li><li class="listitem">We also<a id="id527" class="indexterm"/> turn off the application's <code class="literal">flyByCamera</code> instance and create a new <code class="literal">game</code> object, which we will populate when we receive information from the server, as follows:<div class="informalexample"><pre class="programlisting">  getFlyByCamera().setEnabled(false);
  game = new Game();</pre></div></li><li class="listitem">Lastly, we create a new <code class="literal">ClientMessageListener</code> object and add it to the client, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">ClientMessageHandler messageHandler = new ClientMessageHandler(this, game);
client.addMessageListener(messageHandler);</pre></div></li><li class="listitem">In the <code class="literal">createPlayer</code> method, we create a new <code class="literal">ClientPlayerControl</code> instance and also a <code class="literal">Node</code> instance, which we attach to the scene graph, as follows:<div class="informalexample"><pre class="programlisting">ClientPlayerControl player = new ClientPlayerControl();
player.setId(id);
final Node playerNode = new Node("Player Node");
        playerNode.attachChild(assetManager.loadModel("Models/Jaime/Jaime.j3o"));//
playerNode.addControl(player);</pre></div></li><li class="listitem">Since we don't know when this method will be called, we make sure that we attach the spatial in a thread-safe way. This can be implemented as follows:<div class="informalexample"><pre class="programlisting">enqueue(new Callable(){
  public Object call() throws Exception {
    rootNode.attachChild(playerNode);
    return null;
  }
});</pre></div></li><li class="listitem">Finally, we return the created <code class="literal">ClientPlayerControl</code> instance to the calling method.</li><li class="listitem">We add <a id="id528" class="indexterm"/>a new method called <code class="literal">setThisPlayer</code>. This method will be called when the player's <code class="literal">WelcomeMessage</code> is received. Inside this, we create <code class="literal">CameraNode</code>, which will be attached <a id="id529" class="indexterm"/>to the player, as follows:<div class="informalexample"><pre class="programlisting">public void setThisPlayer(ClientPlayerControl player){
  this.thisPlayer = player;
  CameraNode camNode = new CameraNode("CamNode", cam);
  camNode.setControlDir(CameraControl.ControlDirection.SpatialToCamera);
  ((Node)player.getSpatial()).attachChild(camNode);
}</pre></div></li><li class="listitem">We also have to override the <code class="literal">destroy</code> method to make sure we close the connection to the server when the client is shutdown. This can be implemented as follows:<div class="informalexample"><pre class="programlisting">public void destroy() {
  super.destroy();
  client.close();
}</pre></div></li><li class="listitem">Now, we need to create the client representation of <code class="literal">NetworkedPlayerControl</code> and extend it in a class called <code class="literal">ClientPlayerControl</code>.</li><li class="listitem">It has a <code class="literal">Vector3f</code> field called <code class="literal">tempLocation</code> and a <code class="literal">Quaternion</code> field called <code class="literal">tempRotation</code>. These are used to hold received updates from the server. It can also have a <code class="literal">float</code> field called <code class="literal">yaw</code> for head movement.</li><li class="listitem">In the <code class="literal">onMessageReceived</code> method, we only look for <code class="literal">PlayerUpdateMessages</code> and set <code class="literal">tempLocation</code> and <code class="literal">tempRotation</code> with the values received in the message, as follows:<div class="informalexample"><pre class="programlisting">public void onMessageReceived(PlayerMessage message) {
  if(message instanceof PlayerUpdateMessage){
    PlayerUpdateMessage updateMessage = (PlayerUpdateMessage) message;
  tempRotation.set(updateMessage.getLookDirection());
  tempLocation.set(updateMessage.getPosition());
tempYaw = updateMessage.getYaw();
  }
}</pre></div></li><li class="listitem">We will then apply the <code class="literal">temp</code> variable values in the <code class="literal">controlUpdate</code> method:<div class="informalexample"><pre class="programlisting">spatial.setLocalTranslation(tempLocation);
spatial.setLocalRotation(tempRotation);
yaw = tempYaw;</pre></div></li></ol></div><p>Just like<a id="id530" class="indexterm"/> on the server side, we need a message handler <a id="id531" class="indexterm"/>listening for incoming messages. To do this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new class called <code class="literal">ClientMessageHandler</code>, which implements <code class="literal">MessageListener&lt;Client&gt;</code>.</li><li class="listitem">The <code class="literal">ClientMessageHandler</code> class should have a reference to <code class="literal">FPSClient</code> in a field called <code class="literal">gameClient</code> and <code class="literal">Game</code> itself in another field called <code class="literal">game</code>.</li><li class="listitem">In the <code class="literal">messageReceived</code> method, we need to handle a number of messages. The <code class="literal">WelcomeMessage</code> is most likely to arrive first. When this happens, we create a player object and spatial and assign it to be this client's player, as follows:<div class="informalexample"><pre class="programlisting">public void messageReceived(Client source, Message m) {
  if(m instanceof WelcomeMessage){
    ClientPlayerControl p = gameClient.createPlayer(((WelcomeMessage)m).getMyPlayerId());
    gameClient.setThisPlayer(p);
    game.addPlayer(gameClient.getThisPlayer());</pre></div></li><li class="listitem">The <code class="literal">PlayerJoinMessage</code> is received both when player joins and leaves a game. What sets it apart is the <code class="literal">leaving</code> Boolean. We call both the <code class="literal">game</code> and <code class="literal">gameClient</code> methods based on whether the player is joining or leaving, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">PlayerJoinMessage joinMessage = (PlayerJoinMessage) m;
int playerId = joinMessage.getPlayerId();
if(joinMessage.isLeaving()){
   gameClient.removePlayer((ClientPlayerControl)   game.getPlayer(playerId));
  game.removePlayer(playerId);
} else if(game.getPlayer(playerId) == null){
  ClientPlayerControl p = gameClient.createPlayer(joinMessage.getPlayerId());
  game.addPlayer(p);
}</pre></div></li><li class="listitem">When the <code class="literal">PlayerUpdateMessage</code> is received, we first find the corresponding <code class="literal">ClientPlayerControl</code> class and pass on the message to it, as follows:<div class="informalexample"><pre class="programlisting">  } else if (m instanceof PlayerUpdateMessage){
    PlayerUpdateMessage updateMessage = (PlayerUpdateMessage) m;
    int playerId = updateMessage.getPlayerId();
    ClientPlayerControl p = (ClientPlayerControl) game.getPlayer(playerId);
    if(p != null){
      p.onMessageReceived(updateMessage);
    }</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec184"/>How it works...</h2></div></div></div><p>The <a id="id532" class="indexterm"/>server is running in the headless mode, which <a id="id533" class="indexterm"/>means it won't do any rendering and there will be no graphical output, but we still have access to the full jMonkeyEngine application. In this recipe, one server instance will only have one game active at a time.</p><p>We instantiate all network messages inside a class called <code class="literal">GameUtil</code>, since they have to be the same (and serialized in the same order) on the client and server.</p><p>The client will try to connect to the server as soon as it launches. Once connected, it will receive <code class="literal">playerId</code> from the server via <code class="literal">WelcomeMessage</code>, as well as <code class="literal">PlayerJoinMessages</code> for all other players that are already connected. Likewise, all other players will receive <code class="literal">PlayerJoinMessage</code> with the new player's ID.</p><p>The client sends any actions the players perform to the server using <code class="literal">PlayerActionMessage</code>, which applies them to its instance of the game. The server, which runs at 30 fps, will send positions and directions of each player to all the other players, using <code class="literal">PlayerUpdateMessages</code>.</p><p>The <code class="literal">InputAppState</code> class on the client is very similar to the one in <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>. The only difference is that instead of directly updating a <code class="literal">Control</code> instance, it creates a message and sends it to the server. In the <code class="literal">onAction</code> class, we set the Boolean value of the message, whereas in <code class="literal">onAnalog</code> (to look and rotate), <code class="literal">floatValue</code> will be used instead, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">public void onAction(String name, boolean isPressed, float tpf) {
  InputMapping input = InputMapping.valueOf(name);
  PlayerActionMessage action = new PlayerActionMessage();
  action.setAction(name);
  action.setPressed(isPressed);
  action.setPlayerId(client.getThisPlayer().getId());
  client.send(action);
}</pre></div><p>In the <a id="id534" class="indexterm"/>event of a player leaving the game, <code class="literal">PlayerJoinMessages</code> will be sent to the other players, with <code class="literal">leaving</code> set to <code class="literal">true</code>.</p><p>The <code class="literal">NetworkedPlayerControl</code> class is an abstract class, and doesn't do much on its own. You<a id="id535" class="indexterm"/> might recognize the implementation of <code class="literal">ServerPlayerControl</code> from <code class="literal">GameCharacterControl</code>, and they function similarly, but rather than receiving the input directly from the user, <code class="literal">ServerPlayerControl</code> gets it via a networked message instead.</p><p>Both the client and server implementation of <code class="literal">NetworkedPlayerControl</code> use the <code class="literal">tempRotation</code> and <code class="literal">tempLocation</code> fields to which they apply any incoming changes. This is so we don't modify the actual spatial transforms outside the main loop.</p><p>We shouldn't be fooled by the relative simplicity of this recipe. It merely shows the basics of a real-time networked environment. Making a full game creates much more complexity.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec185"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you'd like to see an example of a full real-time game, have a look at the full source <a id="id536" class="indexterm"/>of MonkeyZone at <a class="ulink" href="http://hub.jmonkeyengine.org/wiki/doku.php/jme3:advanced:monkey_zone">http://hub.jmonkeyengine.org/wiki/doku.php/jme3:advanced:monkey_zone</a>. It features not only human players, but also networked AI.</li></ul></div></div></div>
<div class="section" title="Loading a level"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec76"/>Loading a level</h1></div></div></div><p>No <a id="id537" class="indexterm"/>matter if it's an FPS, RTS, or driving game we're making, we'll want to be able to load different kinds of environments for the players to roam around in. How can we do that easily?</p><p>In this recipe, we'll add functionalities to the networked FPS game we outlined previously in this chapter. The principle will work for any kind of already networked game, although it might differ depending on how the game implements the level. Here, we'll assume it uses jMonkeyEngine scenes or <code class="literal">.j3o</code> scenes.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec186"/>How to do it...</h2></div></div></div><p>Perform the following set of steps to load a level:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by defining a new message class: <code class="literal">LoadLevelMessage</code>. It extends <code class="literal">GameMessage</code> since it might be useful to know the <code class="literal">gameId</code>. Apart from that, it has one field <code class="literal">levelName</code>.</li><li class="listitem">We'll add the same field to our <code class="literal">Game</code> class so that it can keep track of which level it's running.</li><li class="listitem">Next, let's create a <code class="literal">levelNode</code> field on our server, which we can load our level into, as follows:<div class="informalexample"><pre class="programlisting">private Node loadLevel(String levelName){
  return (Node) assetManager.loadModel("Scenes/"+levelName + ".j3o");
}</pre></div></li><li class="listitem">Then, we create a small method that will load the level from a predefined path, as follows:<div class="informalexample"><pre class="programlisting">levelNode = loadLevel("TestScene");
rootNode.attachChild(levelNode);
game.setLevelName("TestScene");</pre></div></li><li class="listitem">Inside the <code class="literal">simpleInitApp</code> method, we'll tell the application to load <code class="literal">TestScene</code> from <a class="link" href="ch01.html" title="Chapter 1. SDK Game Development Hub">Chapter 1</a>, <span class="emphasis"><em>SDK Game Development Hub</em></span>:<div class="informalexample"><pre class="programlisting">LoadLevelMessage levelMessage = new LoadLevelMessage();
levelMessage.setLevelName(game.getLevelName());
server.broadcast(Filters.in(conn), levelMessage);</pre></div></li><li class="listitem">Finally, inside the <code class="literal">addPlayer</code> method, we need to create and send the message to the connecting client. That's all for the server side of things.</li><li class="listitem">In the client, we create a <code class="literal">levelNode</code> field and a <code class="literal">loadLevel</code> method, but it's a little bit different:<div class="informalexample"><pre class="programlisting">public void loadLevel(final String levelName){
  enqueue(new Callable(){
    public Object call() throws Exception {
      if(rootNode.hasChild(levelNode)){
        rootNode.detachChild(levelNode);
        }
        levelNode = (Node) assetManager.loadModel("Scenes/"+levelName + ".j3o");
        rootNode.attachChild(levelNode);
        return null;
    }
  });
}</pre></div></li><li class="listitem">We need to <a id="id538" class="indexterm"/>make sure we manipulate the scene graph at the correct moment in time so that we can detach and attach the node inside an <code class="literal">enqueue</code> block.</li><li class="listitem">Finally, we make sure <code class="literal">MessageListener</code> picks up <code class="literal">LoadLevelMessage</code> as follows:<div class="informalexample"><pre class="programlisting">else if (m instanceof LoadLevelMessage){
  gameClient.loadLevel(((LoadLevelMessage)m).getLevelName());
  game.setLevelName(((LoadLevelMessage)m).getLevelName());
}</pre></div></li><li class="listitem">That's it! When we connect to the server again, we should see a familiar scene.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec187"/>How it works...</h2></div></div></div><p>When a client joins, the server creates a <code class="literal">LoadLevelMessage</code> class and populates it with the name of the level currently loaded. The server doesn't supply the level itself, but the client must have the levels supplied previously. The <code class="literal">LoadLevelMessage</code> class only provides a <a id="id539" class="indexterm"/>name in this case, which is probably enough in many cases. For some games, it's a good idea to support a custom path when loading levels, since it allows for greater customization options.</p></div></div>
<div class="section" title="Interpolating between player positions"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec77"/>Interpolating between player positions</h1></div></div></div><p>If we were <a id="id540" class="indexterm"/>to only run our game in a LAN environment, we would probably never expect low latency or any significant packet loss. While many are blessed even with good Internet connections nowadays, from time to time, problems still happen. One of the tricks to try to mitigate these problems is to use interpolation for entities on the client side.</p><p>This means that rather than just applying the position and rotation the client gets from the server, the client will move towards the target position and rotation in steps.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec188"/>How to do it...</h2></div></div></div><p>Perform the following steps to interpolate between the player positions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To simulate some network problems, set <code class="literal">framerate</code> on the server to <code class="literal">10</code>.</li><li class="listitem">If you connect to the server now, the movement will be noticeably jerky.</li><li class="listitem">We replace the contents of the <code class="literal">controlUpdate</code> method of <code class="literal">ClientPlayerControl</code> with the following lines to apply the interpolation:<div class="informalexample"><pre class="programlisting">float factor = tpf / 0.03f; spatial.setLocalTranslation(spatial.getLocalTranslation().interpolateLocal(tempLocation, factor)); spatial.setLocalRotation(spatial.getLocalRotation().slerp(spatial.getLocalRotation(), tempRotation, factor));</pre></div></li><li class="listitem">When we connect again and compare the experience, it will be much smoother.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec189"/>How it works...</h2></div></div></div><p>To simulate an environment with problems such as packet loss, we changed the FPS on the server to 10. Instead of sending out the 30 updates per second it did before, it will only send one every tenth of a second. This is not the same as 100 ms of latency, since it says nothing about the turnaround time. It's more as if two out of three updates were lost on the way, a 66 percent packet loss.</p><p>Previously, the client simply took the values it got from the server and applied them to the local players. Using interpolation, the player's position and rotation will move towards the latest actual position and rotation in steps every update.</p><p>We implemented the interpolation by first determining the interpolation factor. This was done by dividing <code class="literal">tpf</code> by the amount of time (roughly, in seconds) we would like the interpolation to take. The actual time will be longer since the steps become shorter with each update.</p><p>We then input this value and use the interpolation method of <code class="literal">Vector3f</code> and the <code class="literal">slerp</code> method of <code class="literal">Quaternion</code> to move them towards the actual values.</p><p>This is<a id="id541" class="indexterm"/> done by using a factor based on the <code class="literal">tpf</code> value provided in the <code class="literal">update</code> method. By doing so, the interpolation time will be roughly the same regardless of the frame rate. We should be aware that this in reality becomes latency, a delay between the action and appearance, as we have added a slight delay to when the player reaches the actual position.</p></div></div>
<div class="section" title="Firing over a network"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec78"/>Firing over a network</h1></div></div></div><p>An FPS <a id="id542" class="indexterm"/>wouldn't be a shooter unless there's actually some shooting possible. We'll look at an example with visible, non-instant bullets. For this, we'll be able to reuse some code from <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>. The recipe won't describe the actual collision as this is already described in that chapter.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec190"/>How to do it...</h2></div></div></div><p>Perform the following steps to fire over a network:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To start off, we create a new message, called <code class="literal">BulletUpdateMessage</code> to send updates on bullet positions. It only needs two fields: a <code class="literal">Vector3f</code> field for position and a Boolean field for whether it's alive or not.</li><li class="listitem">We'll add a check in the <code class="literal">messageReceived</code> method of <code class="literal">ServerMessageHandler</code> to see whether a player is firing. Any action verification we want to do should happen prior to this:<div class="informalexample"><pre class="programlisting">if(message.getAction().equals("Fire") &amp;&amp; message.isPressed()){
  server.onFire(p);
}</pre></div></li><li class="listitem">We find out the direction the player is facing and create a new <code class="literal">ServerBullet</code> instance. It's assigned the next available object ID and added to the <code class="literal">bullets</code> list, as follows:<div class="informalexample"><pre class="programlisting">public void onFire(NetworkedPlayerControl player){
  Vector3f direction = player.getSpatial().getWorldRotation().getRotationColumn(2);
  direction.setY(-player.getYaw());
  ServerBullet bullet = new ServerBullet(player.getSpatial().getWorldTranslation().add(0, 1, 0), direction);
  bullet.setId(nextObjectId++);
  bullets.add(bullet);
}</pre></div></li><li class="listitem">Now, we<a id="id543" class="indexterm"/> need to add another code block to the <code class="literal">simpleUpdate</code> method to maintain the bullets and send out messages, as follows:<div class="informalexample"><pre class="programlisting">int nrOfBullets = bullets.size();
for(int i = 0; i &lt; nrOfBullets; i++){
  ServerBullet bullet = bullets.get(i);
  bullet.update(tpf);
  BulletUpdateMessage update = new BulletUpdateMessage();
  update.setId(bullet.getId());
  update.setPosition(bullet.getWorldPosition());
  update.setAlive(bullet.isAlive());
  server.broadcast(update);
  if(!bullet.isAlive()){
    bullets.remove(bullet);
    nrOfBullets--;
    i--;
  }
}</pre></div></li><li class="listitem">In a <code class="literal">for</code> loop, we first update the bullet, and then create a new <code class="literal">BulletUpdateMessage</code>, which is sent to all players. If the bullet is out of range, it is removed from the list. This is implemented as follows:<div class="informalexample"><pre class="programlisting">if (m instanceof BulletUpdateMessage){
  BulletUpdateMessage update = (BulletUpdateMessage) m;
  ClientBullet bullet = gameClient.getBullet(update.getId());
  if(bullet == null){
    bullet = gameClient.createBullet(update.getId());
  }
  bullet.setPosition(update.getPosition());
  if(!update.isAlive()){
    gameClient.removeBullet(update.getId(), bullet.getSpatial());
  }
}</pre></div></li><li class="listitem">On the client side, we write a new method that creates a new bullet, once it receives information from the server:<div class="informalexample"><pre class="programlisting">public ClientBullet createBullet(int id){
  final ClientBullet bulletControl = new ClientBullet();
  final Spatial g = assetManager.loadModel("Models/Banana/banana.j3o");
  g.rotate(FastMath.nextRandomFloat(), FastMath.nextRandomFloat(), FastMath.nextRandomFloat());
  g.addControl(bulletControl);
  bullets.put(id, bulletControl);
  rootNode.attachChild(g);
  return bulletControl;
}</pre></div></li><li class="listitem">Then, we need a <code class="literal">removeBullet</code> method once we receive the information from the server.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec191"/>How it works...</h2></div></div></div><p>Like in the <a id="id544" class="indexterm"/>previous recipes, it's the server that is in control of things. The client merely says it wants to fire and any checks happen on the server side (although it's fine to mimick verification on the client side to save bandwidth). The recipe doesn't contain any specific verifications (a player can fire at any time), but this is explained more in <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>.</p><p>Unlike in <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>, we can't use the camera as input; instead, we use the direction of the firing player and apply the yaw for up and down tilt.</p><p>Bullets are different on the server and client side. On the server, they are merely logical objects. Like the non-instant bullets from the <span class="emphasis"><em>Firing non-instant bullets</em></span> recipe of <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>, they work like slow rays, moving through the world until they hit something or move out of range.</p><p>On the client, the bullet is a bit different from the server side, and is based on the control pattern. The client finds out about the bullet in <code class="literal">ClientMessageHandler</code>, as the first update is received. It sees if <code class="literal">ClientBullet</code> exists already, and if not, it will create a new one. All <code class="literal">ClientBullet</code> does then is update the position in the <code class="literal">controlUpdate</code> method.</p><p>It's not the actual fire message that creates the bullets, but the first time a <code class="literal">BulletUpdateMessage</code> is received on the client. The client will keep updating the Bullet's position, much like the player positions, until a message says it's no longer alive. At this point, it will be removed.</p><p>The recipe <a id="id545" class="indexterm"/>currently sends all bullets to all players. As with players, this could (and probably should) be based on a need-to-know basis to avoid cheating (and excessive bandwidth usage).</p></div></div>
<div class="section" title="Optimizing the bandwidth and avoiding cheating"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec79"/>Optimizing the bandwidth and avoiding cheating</h1></div></div></div><p>It can<a id="id546" class="indexterm"/> be summarized as follows: the less information a client has, the less opportunity there is of exploiting said information for cheating. Also, the less information a client needs, the less bandwidth is required.</p><p>Previously, we've generously sent information about every player, every update cycle. In this recipe, we'll change that so that the server checks what players can be seen by others, and only send that information.</p><p>We'll build this on top of the <span class="emphasis"><em>Implementing a network code for FPS</em></span> recipe.</p><p>We need to add some complexity to the <code class="literal">simpleUpdate</code> method of the server application. So, instead of sending information about all players to everybody, we need to check who should receive what.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec192"/>How to do it...</h2></div></div></div><p>Perform the following steps to optimize a bandwidth:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we'll add a visible field to our <code class="literal">PlayerUpdateMessage</code>. This is so that a client knows when a player has disappeared from the view.</li><li class="listitem">On the server side, we need to change two classes. First, our <code class="literal">ServerPlayerControl</code> needs to maintain a list of player IDs it currently sees.</li><li class="listitem">Before we do our checks, we need to make sure all the players are updated:<div class="informalexample"><pre class="programlisting">Collection&lt;NetworkedPlayerControl&gt; players = game.getPlayers().values();
  for(NetworkedPlayerControl p: players){
    p.update(tpf);
  }</pre></div></li><li class="listitem">Next, we iterate through our <code class="literal">playerMap</code> object. Here, we add a simple range check to see whether a player is visible or not, and lastly broadcast the information to the relevant players, as follows:<div class="informalexample"><pre class="programlisting">Iterator&lt;HostedConnection&gt; it = playerMap.keySet().iterator();
while(it.hasNext()){
  HostedConnection conn = it.next();
  ServerPlayerControl player = playerMap.get(conn);
  for(NetworkedPlayerControl otherPlayer: players){
    float distance = player.getSpatial().getWorldTranslation().distance(otherPlayer.getSpatial().getWorldTranslation());
  PlayerUpdateMessage updateMessage = null;
  if(distance &lt; 50){
    updateMessage = createUpdateMessage(otherPlayer);
    player.addVisiblePlayer(otherPlayer.getId());
  } else if (player.removeVisiblePlayer(otherPlayer.getId())){
    updateMessage = createUpdateMessage(otherPlayer);
    updateMessage.setVisible(false);
  }
  if(updateMessage != null){
    server.broadcast(Filters.in(conn), updateMessage);
  }
}</pre></div></li><li class="listitem">That's <a id="id547" class="indexterm"/>all for the server side. On the client side, we need to add a visible field to <code class="literal">ClientPlayerControl</code>.</li><li class="listitem">The second change we make is in <code class="literal">ClientMessageHandler</code>. We check whether the player is supposed to be visible, and whether it's attached to the scene graph or not:<div class="informalexample"><pre class="programlisting">if(p.isVisible() &amp;&amp; p.getSpatial().getParent() == null){
  gameClient.getRootNode().attachChild(p.getSpatial());
} else if (!p.isVisible() &amp;&amp; p.getSpatial().getParent() != null){
  gameClient.getRootNode().detachChild(p.getSpatial());
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec193"/>How it works...</h2></div></div></div><p>By using this principle, each client will only receive updates on other relevant players. We can't, however, just stop sending updates about certain players without also letting the client know why, or they would just freeze in their last known position. That's why the last message the server sends about a player is with <code class="literal">visible</code> set to <code class="literal">false</code>. However, to do so, the server must keep track of when a player has disappeared, and not just when it's not visible. That's why each <code class="literal">ServerPlayerControl</code> class needs to keep track of which players it saw the last update in its <code class="literal">visibleList</code>.</p><p>This recipe focused on the networking aspects of visibility and how and when to send updates. A proper game (at least an FPS) will need to keep track of obscured players as well, not only how far away they are.</p><p>Optimization<a id="id548" class="indexterm"/> can be done in different ways, and it all comes down to the application. An MMO may for example not be as dependent on frequent updates. In a game like that, network updates can be done with less frequency, if a player is further away, and instead rely on good interpolation to avoid jerkiness.</p><p>If we're using interpolation, and not absolute updates, we should also turn off interpolation when visible switches from false to true, to avoid players possibly gliding to the new position. We can also turn off updates when visible is false.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec194"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Sensing – vision</em></span> recipe in <a class="link" href="ch05.html" title="Chapter 5. Artificial Intelligence">Chapter 5</a>, <span class="emphasis"><em>Artificial Intelligence</em></span>, which provides an idea on how to implement sight on the server</li></ul></div></div></div></body></html>