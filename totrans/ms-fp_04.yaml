- en: The Problem of Side Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用的难题
- en: Pure functional programming is all about removing side effects and mutations.
    We remove them for a reason. In this chapter, we will see how shared mutable states
    and side-effecting functions can cause problems and why it is best to reduce them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数编程全部关于移除副作用和突变。我们这样做是有原因的。在本章中，我们将看到共享可变状态和有副作用的函数如何引起问题，以及为什么最好减少它们。
- en: 'The topics discussed are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论的主题如下：
- en: Side effects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用
- en: Mutable states
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变状态
- en: Pure functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: Generally encountered side effects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常遇到的副作用
- en: Pure functional paradigms in different programming languages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同编程语言中的纯函数范式
- en: Side effects
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用
- en: So what exactly are side effects and why should they be avoided? For this discussion,
    we can define a side effect as some instructions in a function's code that modify
    the environment outside the scope of this function. The most common example of
    a side effect is an exception thrown by a program. Throwing an exception is a
    side effect because if you don't handle it, it will disrupt the program outside
    the scope of this function. So the program will break at this point and will stop
    its execution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，副作用究竟是什么，为什么应该避免它们？为了这次讨论，我们可以将副作用定义为函数代码中的一些指令，这些指令修改了函数作用域之外的环境。最常见的副作用例子是程序抛出的异常。抛出异常是一种副作用，因为如果你不处理它，它将破坏函数作用域之外程序的行为。所以程序将在这一点上崩溃，并停止执行。
- en: Take, for example, the function of the *Soda Machine* example from the previous
    chapter. The function that simulates coin-insertion throws an exception if there
    are no soda cans in the slot machine. So if you try to call that function on an
    empty soda machine, your program will never proceed past the function call site,
    because an exception will be thrown. That is, unless you handle this exception
    with a `try` statement at the same call site. Note that this puts the burden of
    handling side effects on the client, which is probably not what we want to do.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以上一章中的*碳酸饮料机*示例为例。模拟投币功能的函数如果投币机中没有碳酸饮料罐，则会抛出异常。所以如果你尝试在一个空碳酸饮料机上调用这个函数，你的程序将永远不会通过函数调用点，因为会抛出异常。除非你在同一个调用点使用`try`语句来处理这个异常。注意，这会把处理副作用的责任放在客户端，这可能不是我们想要做的。
- en: 'Another side effect that you will encounter is a null returned from a function.
    For example, you have a database of users. You can add a function that queries
    the database and gets a user back given their ID:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会遇到另一个副作用，即函数返回null。例如，你有一个用户数据库。你可以添加一个函数，该函数查询数据库并根据ID返回用户：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Sometimes this function will be called with IDs of users that do not exist
    in the database. A traditional Java solution to the problem of data that does
    not exist is to return a null. Returning a null quickly creates a problem. It
    violates the expectation of the programmer that calls this function. The function
    return type is set to `User`. The programmer will rightfully expect to get an
    object of the `User` type out of this function. Therefore, they may try to call
    some of the `User` methods on that object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这个函数会被调用，传入的用户ID在数据库中不存在。对于数据不存在的问题，传统的Java解决方案是返回null。快速返回null会迅速产生问题。它违反了调用此函数的程序员对结果的预期。函数的返回类型被设置为`User`。程序员有理由期望从这个函数中得到一个`User`类型的对象。因此，他们可能会尝试调用该对象的某些`User`方法：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Calling a method of the `User` type on null will result in a null pointer exception
    unless you first verify that the object is not null.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在null对象上调用`User`类型的方法会导致空指针异常，除非你首先验证该对象不是null。
- en: One problem here is that side effects are not reflected anywhere in the function's
    signature. Moreover, their handling is not enforced by the compiler. In Java,
    of course, you are required to declare some exceptions thrown by the functions
    in their signatures. However, it has proven to be a bad design decision, and most
    languages do not require such a declaration. Moreover, even in Java, no declaration
    is made to specify that the function can return a null. Unless the programmer
    remembers that such side effects occur in the program, they may not handle them.
    So unless they handle the side effects, the program may be error-prone.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题之一是副作用在函数的签名中没有任何体现。此外，它们的处理也不是由编译器强制执行的。当然，在Java中，你需要在它们的签名中声明函数抛出的某些异常。然而，这已被证明是一个糟糕的设计决策，并且大多数语言都不要求这种声明。此外，即使在Java中，也没有声明指定函数可以返回null。除非程序员记得程序中存在这样的副作用，否则他们可能不会处理它们。所以除非他们处理了副作用，否则程序可能会出错。
- en: The main problem here is the extra mental load on the programmer. They are required
    to continually remember all the side effects that their functions may produce.
    Because if they don't, they will also forget to handle them properly. Thus, their
    code can introduce bugs. This problem is caused by the fact that the compiler
    does not enforce the handling of the side effects. The side effects are certain
    phenomena that are generated by the code at runtime. These phenomena are where
    local functions influence or are influenced by the outer environment without this
    being stated explicitly in the function type. These influences may then be generated
    by the function code, depending on the input values it receives at runtime. The
    compiler knows nothing about them. For example, the phenomenon of a function returning
    null, or an exception happening and the program being disrupted at that point.
    These things happen at runtime. At compile time, the compiler does not do any
    checks on whether they are appropriately treated.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里主要的问题是给程序员带来了额外的心理负担。他们需要不断地记住他们函数可能产生的所有副作用。因为如果不这样做，他们也可能忘记正确处理它们。因此，他们的代码可能会引入错误。这个问题是由编译器不强制处理副作用造成的。副作用是代码在运行时产生的一些现象。这些现象是局部函数在未在函数类型中明确声明的情况下，影响或被外部环境影响的结果。这些影响可能由函数代码生成，这取决于它在运行时接收到的输入值。编译器对此一无所知。例如，函数返回null的现象，或者异常发生导致程序在那个点中断。这些事情发生在运行时。在编译时，编译器不会检查它们是否得到了适当的处理。
- en: Mutable states
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变状态
- en: A mutable state, to put it simply, is data that can be changed. For example,
    at one point in time, you may read some variable, *x*, and find that it points
    to some data. At another time, you may read a different value from the same variable.
    The value is different because the variable is mutable and another part of the
    program mutated it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，可变状态是可以更改的数据。例如，在某个时间点，你可能会读取某个变量，*x*，并发现它指向某些数据。在另一个时间点，你可能会从同一个变量读取不同的值。值的不同是因为变量是可变的，程序的其他部分对其进行了修改。
- en: 'Let''s look at why exactly the mutable state is not desirable. Imagine you
    have an online game. It relies on multiple threads, and the concurrency architecture
    of choice is the actors model. You have an actor that is supposed to track the
    users currently present in the game. Tracking can be implemented as a mutable
    collection inside the actor. Users log in and out of the game by sending messages
    to this actor. So, every time a message for logging in arrives at the actor, the
    user is added to the list of logged-in users. When users want to log out, they
    are removed from the list:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨为什么可变状态并不理想。想象一下你有一个在线游戏。它依赖于多个线程，所选择的并发架构是演员模型。你有一个演员，其任务是跟踪当前游戏中存在的用户。跟踪可以通过在演员内部实现一个可变集合来完成。用户通过向这个演员发送消息来登录和退出游戏。因此，每次登录消息到达演员时，用户就会被添加到已登录用户列表中。当用户想要退出时，他们就会被从列表中移除：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, imagine you want to find the users that have reached a particular score
    to congratulate them via an email notification. You may want to do that at the
    end of each round (assuming it''s a round-based game), which is modeled by another
    message sent to the `GameState` actor. One way to implement this is to send a
    list of all the users to a separate notifications actor that will do the job:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你想找到达到特定分数的用户，并通过电子邮件通知他们。你可能想在每一轮结束时（假设这是一个基于轮次的游戏）这样做，这可以通过发送另一个消息到`GameState`演员来实现。实现这一目标的一种方法是将所有用户的列表发送到一个单独的通知演员，由它来完成这项工作：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s imagine that the job of looking up and notifying the users takes a while
    to complete. We can simulate the delay via the `Thread.sleep(1000)` statement.
    This statement pauses the execution of the current thread at the line where it
    is called for 1,000 milliseconds or 1 second. Let''s see how this works:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设查找和通知用户的工作需要一段时间才能完成。我们可以通过`Thread.sleep(1000)`语句来模拟延迟。这个语句在调用它的那一行暂停当前线程的执行，持续1,000毫秒或1秒。让我们看看它是如何工作的：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The communication protocol is defined as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通信协议定义如下：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s assume the following environment:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设以下环境：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have an actor system, an actor for the game state, and an actor for notifications.
    Also, we have two users. The second user, `User2`, is a *winning* user because
    their score is `>= 100`. Consider what happens if a *winning* user with the required
    score logs out immediately after we complete the round:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个演员系统，一个用于游戏状态的演员和一个用于通知的演员。此外，我们有两个用户。第二个用户`User2`是一个*获胜*用户，因为他们的分数`>=
    100`。考虑一下，如果一个*获胜*用户在完成回合后立即注销会发生什么：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Such a user will not be notified. Things go wrong here because the collection
    we sent to the actor that takes care of notifications is mutable. It is shared
    between the `GameState` actor and `NotificationActor`. This means that once a
    user logs out, they are removed from the collection by the `GameState` actor,
    which means that it will also be removed from the collection of the `NotificationActor`
    because it is the same collection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的用户将不会收到通知。问题出在这里，因为我们发送给负责通知的演员的集合是可变的。它被`GameState`演员和`NotificationActor`共享。这意味着一旦用户注销，他们就会被`GameState`演员从集合中移除，这也意味着它也将从`NotificationActor`的集合中被移除，因为它们是同一个集合。
- en: The preceding example demonstrates the problem of the shared mutable state in
    action. Again, this is extra mental load on the programmer. No longer can you
    reason in the scope of only one thread if you have an object shared with another
    thread. You must expand your scope of reasoning to all the threads that own this
    object. Because for all you know, the shared mutable object can be changed at
    any time. The actor model is supposed to help you to reason as if your program
    were single-threaded and no other threads existed. However, it won't help if you
    keep using a shared mutable state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了共享可变状态在实际操作中存在的问题。再次强调，这给程序员带来了额外的心理负担。如果你有一个与其他线程共享的对象，你不能再仅在一个线程的范围内进行推理。你必须扩大你的推理范围，涵盖所有拥有此对象的所有线程。因为就你所知，共享的可变对象可以随时被更改。演员模型旨在帮助你像你的程序是单线程的且没有其他线程存在一样进行推理。然而，如果你继续使用共享可变状态，它将不会有所帮助。
- en: The traditional approach to managing a shared mutable state is to use locks
    and monitors. The principle behind it is that a thread that is doing modifications
    to an object is supposed to take a lock on some monitor so that nobody else will
    be able to perform a modification while this thread deals with the object. However,
    this does not remove the mental load from the programmer. You still need to take
    into account threads other than the one you are currently programming. In practice,
    it is tough to debug programs that involve concurrency and a shared mutable state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 管理共享可变状态的传统方法是用锁和监视器。其背后的原理是，正在对对象进行修改的线程应该在一些监视器上获取锁，这样在它处理对象时，其他人将无法执行修改。然而，这并没有从程序员的心理负担中解脱出来。你仍然需要考虑除了你当前正在编写的线程之外的其他线程。在实践中，调试涉及并发和共享可变状态的程序是困难的。
- en: Pure functions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: In the previous sections, we have shown you how mutations and side effects can
    make the code harder to read and write. In this section, we will introduce the
    notion of pure functions, that is, the functions that do not produce side effects.
    It is central to pure functional programming. The functional paradigm dictates
    that you should express your program with the help of functions that do not produce
    any side effects. How would you model a situation where you need to throw an exception
    with the help of a pure function? Take the familiar *Soda Machine* example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们向您展示了突变和副作用如何使代码更难阅读和编写。在本节中，我们将介绍纯函数的概念，即不产生副作用的函数。这是纯函数式编程的核心。函数式范式规定，你应该使用不产生任何副作用的函数来表达你的程序。你将如何使用纯函数来模拟需要抛出异常的情况？以熟悉的*饮料机*示例为例。
- en: 'This is the slightly shortened version of the *Soda Machine* example we encountered
    in our previous discussions on side effects:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前关于副作用讨论中遇到的*Soda Machine*示例的略微简短版本：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can avoid throwing an exception from the function by returning a result
    wrapped in another data structure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过返回另一个数据结构包装的结果来避免从函数中抛出异常：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our case, we are not returning a pure result but an encapsulated result in
    the form of a `Try` of the result. The behavior of `Try` is to trap the possibility
    of an exception being thrown within its body for further handling. `Try`, as discussed
    in previous chapters, is a data structure that can contain either a value or an
    exception. So, if the soda machine is out of cans, we no longer throw an exception.
    We return the information that an error has occurred from the function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们不是返回一个纯结果，而是以`Try`的结果形式返回一个封装的结果。`Try`的行为是在其体内捕获抛出异常的可能性以进行进一步处理。正如前几章所讨论的，`Try`是一个可以包含值或异常的数据结构。因此，如果自动售货机没有罐装饮料了，我们不再抛出异常。我们从函数中返回一个错误已发生的消息。
- en: The benefit here compared to the comparative analysis is as follows. There is
    no longer an unexpected side effect happening in this function. An error that
    can happen no longer interrupts the entire flow of the program. Moreover, the
    call site user of the function must handle the error to access the result. Because
    the result is wrapped into the data structure, we cannot access that result unless
    we first unwrap the data structure that it is wrapped into.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与比较分析相比，这里的优势如下。在这个函数中不再会有意外的副作用发生。一个可能发生的错误不再会中断整个程序的流程。此外，函数的调用站点用户必须处理错误才能访问结果。因为结果被包装进数据结构中，除非我们首先解包它所包装的数据结构，否则我们无法访问那个结果。
- en: We can access the result by analyzing what exactly was returned. If it is a
    value, we know precisely that no error has happened. If it is an exception, we
    know that we need to handle it. At this point, we can say that the compiler enforces
    the handling of the error. The fact that the error can occur is reflected in the
    return type of the function. Hence, there is no longer a way to use the return
    value directly after it is returned. If you try to use it directly without first
    handling the possibility of an error, you will get a compile-time error. Because
    you will be trying to use the `Try` data structure as if it were the type that
    it wraps.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过分析返回的确切内容来访问结果。如果它是一个值，我们知道没有发生错误。如果它是一个异常，我们知道我们需要处理它。在这个时候，我们可以这样说，编译器强制处理错误。错误可能发生的事实反映在函数的返回类型中。因此，在返回后直接使用返回值不再可行。如果你试图在不首先处理错误可能性的情况下直接使用它，你将得到一个编译时错误。因为你将尝试使用`Try`数据结构，就像它是它所包装的类型一样。
- en: 'Another feature of purely functional programming is that it avoids using mutable
    data structures. Let''s have another look at the example of the actors exchanging
    data with one  another. What if instead of exchanging a mutable data structure
    we exchanged an immutable data structure? An immutable list? Check out the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数编程的另一个特点是它避免了使用可变数据结构。让我们再次看看演员之间交换数据的例子。如果我们不是交换一个可变数据结构，而是交换一个不可变数据结构，比如不可变列表，会怎样？看看下面的例子：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you recall, in the previous example, we had a problem with the list being
    modified from another thread when `NotificationActor` was trying to use it. Now,
    if we use an immutable list instead of a mutable list, the problem of mutation
    from another thread goes by itself, since immutable data structures cannot be
    mutated. A data structure that is immutable is automatically thread-safe. You
    can guarantee that nothing will mutate the data structure. Hence, you can share
    it freely with any other thread.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的，在前一个例子中，我们遇到了`NotificationActor`试图使用列表时列表被另一个线程修改的问题。现在，如果我们用不可变列表代替可变列表，由于不可变数据结构不能被修改，因此从另一个线程的修改问题就会自行消失。一个不可变的数据结构是自动线程安全的。你可以保证没有任何东西会修改数据结构。因此，你可以自由地与其他任何线程共享它。
- en: 'This argument can be extended by exchanging data with other methods as well.
    Imagine you have some mutable data structures and some `blackBox` methods:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个论点可以通过与其他方法交换数据来扩展。想象一下，你有一些可变的数据结构和一些`blackBox`方法：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After these `blackBox` methods have gone forth on this data structure, how
    do you know what exactly is contained in it now? You can''t have any guarantee
    of a mutable data structure unless you know exactly what happens in the black
    box method. Now, consider an example of an immutable list and the same situation
    of a black box method being called on this list:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些`blackBox`方法在这个数据结构上运行之后，你怎么知道现在它确切包含什么内容？除非你知道黑盒方法中确切发生了什么，否则你无法对可变数据结构有任何保证。现在，考虑一个不可变列表的例子和同样的情况，即在这个列表上调用黑盒方法：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Do you have any guarantee of what is contained in this list after the black
    box method did its job? You do because the list is immutable. Nothing can modify
    this list. So you can freely pass it around, not only to other threads, but also
    to other methods within one thread, and be confident that it is not modified.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在黑盒方法完成其工作后，你对这个列表中包含的内容有任何保证吗？你有，因为列表是不可变的。没有任何东西可以修改这个列表。所以你可以自由地传递它，不仅传递给其他线程，还可以传递给同一线程内的其他方法，并且可以确信它不会被修改。
- en: The benefit of such an approach is that there is no longer a need to extend
    the scope of your reasoning beyond your current local scope. If you are calling
    a black box method on an immutable data structure, there is no need for you to
    know exactly what happens in this method. This method will never modify an immutable
    data structure and knowing that is enough. So, if you're working in a multithreaded
    environment, or if you are working only with immutable data structures, no longer
    do you need to worry about things such as synchronization or taking locks. You
    know that your immutable data structure will never be changed by any thread.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，你不再需要将你的推理范围扩展到当前局部范围之外。如果你在一个不可变数据结构上调用黑盒方法，你不需要确切知道这个方法中发生了什么。这个方法永远不会修改不可变数据结构，知道这一点就足够了。所以，如果你在一个多线程环境中工作，或者你只使用不可变数据结构，你不再需要担心诸如同步或获取锁等问题。你知道你的不可变数据结构不会被任何线程更改。
- en: So far, we've discussed the property of purity from an intuitive perspective.
    Now let's look at a more scientific way of defining it—the concept of referential
    transparency.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已从直观的角度讨论了纯净性的属性。现在让我们看看一种更科学的方式来定义它——引用透明性的概念。
- en: Referential transparency
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明性
- en: The concepts of immutability and lack of side effects are encompassed by the
    term **referential transparency**. With a referentially transparent function,
    you can substitute the function call with the result it returns without changing
    the semantics of the program.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性和无副作用的概念被术语**引用透明性**所包含。具有引用透明性的函数，你可以用其返回的结果替换函数调用，而不会改变程序的语义。
- en: 'Let''s see how it works on an example. Consider another type of side effect—logging.
    The function returns the name of a user with a given ID, but it also writes that
    name into a log—the standard output, in this case:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在例子上的工作方式。考虑另一种类型的副作用——日志记录。该函数返回具有给定ID的用户名称，但它也将该名称写入日志——在这种情况下是标准输出：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Can we substitute the call of the preceding function with the result it computes?
    Let''s try:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否用函数计算出的结果替换先前的函数调用，而不丢失程序的语义？让我们试试：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The semantics would not be the same in this case. The original program prints
    the log to the standard output. The current program does not. This is so because
    the standard output occurred in the function that we have replaced with the result
    it computed, as a side effect.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，语义将不会相同。原始程序将日志打印到标准输出。当前的程序没有这样做。这是因为标准输出发生在我们用其计算结果替换的函数中，作为一个副作用。
- en: 'Now, let''s consider another program:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个程序：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function does the same thing, but instead of producing a side effect of
    logging, it includes the information that the side effect should have occurred
    into a list of all the messages that were supposed to be logged. Now we can return
    the list with the messages together with the result of the function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 函数做的是同样的事情，但它不是产生日志记录的副作用，而是将副作用应该发生的信息包含到所有应该被记录的消息列表中。现在我们可以返回包含消息的列表以及函数的结果。
- en: 'Can we substitute their function call with the result it computes without losing
    the semantics of the program? Check out the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否在不丢失程序语义的情况下用函数计算出的结果替换它们的函数调用？查看以下内容：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now the answer is yes. The original function computed the list with all the
    messages it produced and returned it together with the value it computed, without
    actually producing any side effects. Since there were no side effects produced
    in the process, we can substitute the function call with its result without changing
    the semantics of the program. The function is referentially transparent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在答案是肯定的。原始函数计算了它产生的所有消息的列表，并连同它计算出的值一起返回，而没有实际产生任何副作用。由于在过程中没有产生任何副作用，我们可以用函数的返回值替换函数调用，而不改变程序的语义。该函数是引用透明的。
- en: As you can see from the preceding example, in a referentially transparent function,
    all of the side effects are reflected in the return type and are usually represented
    by a specific data structure. This style may look verbose and unreadable to you
    at first because you are returning a pair with some extra stuff from your function.
    However, don't forget that one of the main principles of engineering is that of
    abstraction. So the unreadable code you see here can be abstracted away if you
    have proper abstractions. This can be done without losing the benefits we have
    achieved. The benefits include reducing the mental load on the programmer, the
    ability to explain your program locally, and the ability to exclude side effects
    from the equation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，在引用透明的函数中，所有的副作用都反映在返回类型中，通常由特定的数据结构表示。这种风格可能一开始看起来冗长且难以阅读，因为你从函数中返回了一个包含额外内容的对。然而，不要忘记工程学的一个主要原则是抽象。所以，如果你有适当的抽象，这里看到的难以阅读的代码可以被抽象掉。这样做的过程中不会失去我们已经获得的好处。这些好处包括减轻程序员的认知负担、能够局部解释你的程序，以及能够将副作用排除在等式之外。
- en: And such abstractions have been invented. Languages such as Scala or Haskell
    have excellent support for such abstractions. Later in this book, we will dive
    much deeper into how they work and how you can write programs with them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的抽象已经被发明出来。像Scala或Haskell这样的语言对这种抽象提供了出色的支持。在本书的后面部分，我们将更深入地探讨它们是如何工作的，以及如何使用它们来编写程序。
- en: Generally encountered side effects
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通常遇到的副作用
- en: In this section, we will talk more about the side effects commonly encountered
    in programs. Some of them we have already introduced, and others you may already
    know from your everyday programming. However, it is crucial for you to pay particular
    attention to such side effects, because this way, you learn to distinguish them
    in an ordinary program.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更详细地讨论程序中常见的一些副作用。其中一些我们已经介绍过，而其他一些你可能已经从日常编程中了解到了。然而，对你来说，特别注意这些副作用至关重要，因为这样，你才能学会在普通程序中区分它们。
- en: When writing programs (and when living our lives in general), very often, we
    get used to things without even paying attention to them. Certain things may be
    a source of headaches and problems, and the first step to resolving the problems
    is to name the things that cause them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写程序（以及当我们一般地生活时），我们往往对某些事情习以为常，甚至没有注意到它们。某些事情可能成为头痛和问题的来源，解决这些问题的第一步是命名导致它们的原因。
- en: As functional programming aims to eliminate side effects, it is reasonable for
    us to name some of the side effects that cause pain.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数式编程旨在消除副作用，因此我们合理地命名了一些导致痛苦的副作用。
- en: Error
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误
- en: The first effect we will be discussing is the effect of an error. An error is
    produced when something goes wrong in your program. In imperative languages, it
    is usually modeled by an exception. An exception is a phenomenon produced by a
    line of the program that disrupts the execution flow of the program at that point.
    Usually, it propagates up the call stack, disrupting the execution at its parent
    call stacks too. If left unhandled, exceptions propagate to the topmost call-stack
    frame, and the program will crash.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个效果是错误的效果。当你的程序中出现问题时，会产生错误。在命令式语言中，它通常由异常来建模。异常是由程序中的一行产生的现象，它在该点中断了程序的执行流程。通常，它沿着调用栈向上传播，也会中断其父调用栈的执行。如果未得到处理，异常会传播到最顶层的调用栈帧，程序将会崩溃。
- en: 'Consider an example of division by zero:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个除以零的例子：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have a division function that checks whether its denominator is zero. If
    it is, the function throws an exception. Now, consider calling this function as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个除法函数，它会检查其分母是否为零。如果是，该函数会抛出异常。现在，考虑如下调用此函数：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The execution of the main program will not progress further than the line where
    we tried to call the division function, the second argument of which is zero.
    This is because the error will happen in the function and will get propagated
    up the stack, eventually crashing the program.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序的执行将不会超过我们尝试调用除法函数的行，该函数的第二个参数为零。这是因为错误将在函数中发生，并最终传播到堆栈中，最终导致程序崩溃。
- en: Absence of result
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果缺失
- en: 'Consider a situation where we have a function that is supposed to make a database
    query. Specifically, we have users in our database, and we want a function to
    retrieve a user by their ID. Now, what will happen when there is no user with
    a given ID in the database? Consider the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种情况，我们有一个应该执行数据库查询的函数。具体来说，我们在数据库中有用户，我们希望有一个函数可以通过ID检索用户。现在，当数据库中没有给定ID的用户时会发生什么？考虑以下情况：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The solution of imperative languages is a null returned from the function. In
    [Chapter 3](67d28304-c855-47aa-afb6-b74fa5a0dd28.xhtml), *Functional Data Structures*,
    we saw how this is dangerous. The compiler doesn't know that null can be returned
    from the function. More precisely, it doesn't even know this is a possibility.
    The compiler allows for functions returning `null` and does not warn us about
    a possible null return value. The imperative style embraces this possibility.
    So we have a situation in imperative languages where potentially every function
    that returns an object may also return null. If we do not check that the result
    of that function is not null, we risk bugs. And to check the result of the function,
    we need to keep in mind the possibility of it returning null. And this is an extra
    mental load.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式语言的解决方案是从函数返回null。在[第三章](67d28304-c855-47aa-afb6-b74fa5a0dd28.xhtml)，“函数式数据结构”中，我们看到了这是多么危险。编译器不知道函数可以返回null。更准确地说，它甚至不知道这是一个可能性。编译器允许函数返回`null`，并且不会警告我们可能存在null返回值。命令式风格接受了这种可能性。因此，在命令式语言中，可能每个返回对象的函数也可能返回null。如果我们不检查该函数的结果是否为null，我们可能会遇到错误。并且为了检查函数的结果，我们需要记住它可能返回null的可能性。这又是一个额外的心理负担。
- en: Delay and asynchronous computations
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟和异步计算
- en: Imagine your program performs an HTTP call. For example, it tries to retrieve
    some JSON object from a web API. It can take some time; it may even take several
    seconds to complete.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你的程序执行了一个HTTP调用。例如，它试图从一个Web API中检索一些JSON对象。这可能需要一些时间；甚至可能需要几秒钟才能完成。
- en: Imagine that you want to make some competition within a function and return
    some value based on the result of the API request. You run into a problem here
    because the result of the API call was not available immediately. The fact that
    you need to wait for a specific long-running operation to complete is also a side
    effect.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望在函数内进行一些竞争，并根据API请求的结果返回一些值。你在这里会遇到问题，因为API调用的结果并没有立即可用。你需要等待一个特定的长时间运行的操作完成，这也是一个副作用。
- en: You can block on this long-running operation and resume your competition once
    the result arrives. However, this function will also block any functions that
    are calling it. In the context of a performance-critical environment, this may
    be an issue. For example, consider a web server. It has several threads to serve
    all the incoming requests. If its operations take too long to complete, it will
    quickly run out of threads. And some requests will end up waiting for a long time
    in the queue for a free thread.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个长时间运行的操作上阻塞，一旦结果到达就继续你的竞争。然而，这个函数也会阻塞调用它的任何函数。在性能关键的环境中，这可能会成为一个问题。例如，考虑一个Web服务器。它有多个线程来处理所有传入的请求。如果它的操作完成时间过长，它会很快耗尽线程。并且一些请求最终会在队列中等待很长时间，等待一个空闲的线程。
- en: So, you always need to keep in mind that some of your functions are blocking
    and take time to return. This is an extra piece of information to keep in mind.
    This produces an extra mental load for you. The side effect of delayed computation
    causes all of this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你始终需要记住，你的一些函数是阻塞的，需要时间来返回。这是一条需要记住的额外信息。这给你带来了额外的心理负担。延迟计算的副作用导致了这一切。
- en: The solution used in modern web servers is to make your server asynchronous.
    This means that you never wait for a long-running operation. You specify what
    to do next using a callback and continue according to that callback once the result
    is in place. This can lead to a situation known as callback hell. The problem
    is that when you overuse callbacks, the execution flow of the program becomes
    quite obscure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络服务器使用的解决方案是使你的服务器异步。这意味着你永远不会等待长运行的操作。你指定接下来要做什么，使用回调，一旦结果就绪，就根据该回调继续。这可能导致一种称为回调地狱的情况。问题是当你过度使用回调时，程序的执行流程变得相当晦涩。
- en: Usually, when something in the program is not apparent, this indicates a need
    for an abstraction. So it can be a good idea to abstract away callbacks.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当程序中的某件事不明显时，这表明需要抽象。因此，抽象回调可能是一个好主意。
- en: Functional programming also has a means to abstract away long-running computations.
    With it, you can write your code as if they were returning immediately. The data
    type of `Future` is present both in Scala and Java, and also in many modern programming
    languages. It servers precisely the purpose of abstracting long-running computations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程也有一种方法来抽象长运行的计算。有了它，你可以编写代码，就像它们立即返回一样。`Future`数据类型存在于Scala和Java中，也存在于许多现代编程语言中。它**精确地**服务于抽象长运行计算的目的。
- en: Logging
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: In an example in the *Referential Transparency* section of this chapter, we
    saw how logging can also be a side effect. Logging can be done using a separate
    login framework, or it can be as simple as writing to the standard output.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章“引用透明性”部分的例子中，我们看到了日志也可以是副作用。日志可以使用单独的登录框架来完成，或者它可能只是简单地写入标准输出。
- en: Things may get tricky with logging when you work in an unfamiliar environment.
    For example, if it is the environment of your desktop computer, everything is
    simple. You run a program from your terminal, and it outputs everything to the
    terminal. However, what if it is a web server? Often, you need to output your
    log into a separate file for it to be readable afterward. Alternatively, what
    if you are writing a mobile application? The program runs on a separate device,
    and it is not always the case that a print statement causes an output to your
    terminal. You may need to use some system-specific logging API, native to the
    environment you are working in.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在不熟悉的环境中工作时，日志可能会变得复杂。例如，如果是在你的桌面电脑环境中，一切都很简单。你从终端运行程序，它将所有输出都输出到终端。然而，如果是一个网络服务器呢？通常，你需要将日志输出到单独的文件中，以便之后可以阅读。或者，如果你正在编写一个移动应用程序呢？程序在单独的设备上运行，并不总是打印语句会导致输出到终端。你可能需要使用一些特定于系统的日志API，这些API是本地化的，适用于你正在工作的环境。
- en: Now imagine you have a program that has `print` statements pretty much everywhere
    in it. You suddenly start to understand that some of your functions try to interact
    with the environment outside of its scope when logging. Specifically, the logging
    API particular to the environment under which you are working. Now you need to
    modify this logging call to match the expectations of the environment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你有一个程序，其中几乎到处都有`print`语句。你突然开始理解，一些函数在记录日志时试图与作用域之外的环境进行交互。具体来说，是与你在工作环境中特定的日志API。现在你需要修改这个日志调用，以匹配环境的期望。
- en: A function that writes to a log interacts with the environment outside its scope.
    This means we can treat such calls as side effects according to our definition.
    Since you need to pay attention to these intricacies when working in different
    environments, it is fair to say they contribute to your mental load.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个写入日志的函数与作用域之外的环境进行交互。这意味着我们可以根据定义将这些调用视为副作用。由于你在不同环境中工作时需要关注这些复杂性，因此可以说它们增加了你的心理负担。
- en: Input-output operations
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入输出操作
- en: The final side effect that we'll discuss here are **input-output** (**IO**)
    operations to the filesystem, or to the network. We can say that these operations
    are side effects because they depend on the environment so much.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要讨论的最后一个副作用是与文件系统或网络的输入输出（**IO**）操作。我们可以将这些操作称为副作用，因为它们在很大程度上依赖于环境。
- en: In the case of IO operations on the filesystem, the success of the operation
    depends on whether the filesystem contains the specified file or if the file is
    readable. When performing network operations, the operation depends on whether
    we have a reliable internet connection or any firewalls.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: When debugging an IO program, lots of moving parts come to our attention. Do
    we have access to the desired filesystem? What about the ownership of the files
    we are trying to read or write? What about the permissions the current user has?
    What about filesystems of different operating systems? Linux and Windows have
    very different approaches to structuring their filesystems, so how do we port
    our application from one system to another? Do we have a reliable internet connection?
    Are we not behind a firewall? Do our DNS servers work correctly? Is the port we
    are trying to listen on available on this particular system?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: It is an extra mental load on you because there are so many things you need
    to consider. Hence, you can treat IO as side effects and an extra mental load.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: But how do we get rid of the side effects?
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you come from a purely imperative background, you may be quite confused at
    this point. Purely functional programming says that you need to eliminate all
    the side effects. But can you imagine a program without logging? And what would
    be the use of a web API that cannot connect to a network? If we cannot throw an
    exception, how do we specify the erroneous behavior of the program?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The side effects specified previously are essential to most modern applications,
    and it is usually not possible to imagine a reasonable program without side effects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it would be wrong to say that purely functional programming eliminates
    side effects from your program completely. Instead, it would be more precise to
    say that it eliminates side effects from your business logic. It pushes side effects
    away from the parts of your application that matter. The way it usually works
    with the purely functional style is that your business logic, which encompasses
    90% of the code, is indeed purely functional.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: You do not have all of the side effects specified previously. However, whenever
    the business logic needs to perform a side effect, it does not enact it directly.
    Instead, it creates a data structure that specifies which side effect needs to
    be performed, without actually performing them. Functional applications often
    have an entire domain-specific language to describe side effects. And whenever
    a piece of logic needs to execute a side effect, it expresses its need in this
    language. The specification of what needs to be done and the act of executing
    that specification are separate one from another.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Functional applications usually have a thin layer that takes care of executing
    the side effects expressed in the effect language of the application. The advantage
    of this approach is that most of the time you work on the business logic, this
    90% of your code. And this code is referentially transparent and pure. Which means
    all of the side effects that would have typically been present in it are separated
    away from it. All of the mental load that we were discussing previously is gone.
    This means that, most of the time, you are working without any extra mental load,
    locally, without considering the global scope.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: It is true that you also need to write the interpreter for your side effects.
    This is the 10% of code that the side effects expressed in the effect language
    of your choice. However, it is separate from your business logic. You can test
    your effect interpreter separately. Once it is written and in place, you can forget
    about it, and write your business logic in a pure way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are not yet diving into the details of how it is done. The
    purpose of this section is to give you an idea of how the problem of purity in
    a side-effecting application is addressed. Later in this book, we'll see precisely
    how functional programming facilitates this technique and what exactly it provides
    to write programs in this style.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The pure functional paradigm in different languages
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It doesn't take any particular infrastructure to program in a purely functional
    style. All you need is to be able to see side effects in code, to notice when
    they place an extra mental load on your mind and require you to hold more things
    in mind at once. And of course, you need to know how to abstract them away, how
    to make this mental load go away. Most modern programming languages are built
    for engineers. This is why they provide excellent capabilities for abstraction,
    including imperative languages such as C or Java. This is why, if you know what
    to abstract and how, you should be able to abstract that in these languages. And
    if you know precisely how the imperative style can hurt you, you can shield yourself
    from the trouble.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, certain imperative programming languages provide a specific infrastructure
    that facilitates purely functional style directly. For example, in Java, you have
    the `final` keyword. A variable declared with this keyword is immutable. You're
    not able to modify a `final` variable in Java once it is assigned a value. Also,
    in Java, you have immutable collections as part of its core infrastructure.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Even though you can apply the functional style in imperative languages, it is
    much easier to do so in functional languages. You may encounter trouble when applying
    the style to imperative languages. One thing may be that all the libraries you
    encounter are imperative. It may be hard to write purely functional code in such
    conditions because you will be working inside an imperative infrastructure. It
    will create certain inertia that may be hard to fight. So it may not be practical
    to work in the functional style in imperative languages. However, it may be used
    as a last resort, if you are overwhelmed by complexity.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of pure functional languages, such as Scala or Haskell, is that
    they provide you with an excellent infrastructure to write functional code. Haskell
    is a language that enforces functional style. There is just no other choice of
    style that you can use with that language. Hence, the libraries that you will
    be using in this language are also purely functional. You can work in a purely
    functional infrastructure. Scala is a more liberal language in some sense. It
    is a mix of the object-oriented and functional styles. So, it is convenient to
    use it to make a transition between purely imperative and purely functional styles.
    That is because you have a choice of style. If you do not know how to implement
    something in a purely functional way and deadlines are approaching, you can always
    resort to a familiar imperative style.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: This blending of the imperative and functional styles is pretty standard in
    modern programming languages. For example, in Python, you can encounter both styles.
    Some libraries are quite imperative, but there is good support for purely functional
    style too. Java is more conservative in this sense than Python. It appears to
    follow the imperative, algorithmic paradigm quite strictly, even though huge efforts
    have been put into making the functional style more natural to Java during the
    last decade or so.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: All in all, the point of this section is that the functional style is not about
    the language. The language can provide some momentum, in the sense of its existing
    infrastructure and the methodology of its community. This momentum can be in either
    direction—either it will work for you, or against you. However, if you understand
    the functional approach, you should be fine programming in any language using
    it. But you should always be aware of where the wind blows—what the moods of its
    community are, what philosophy its libraries follow. You should be aware of the
    momentum the language provides you and whether it works for you or against you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional imperative approach relies heavily upon algorithms that are
    supposed to produce certain phenomena at runtime—the side effects. The compiler
    is usually not aware of these phenomena or is not aware of them enough. We can
    define the side effects for this book as instructions that modify the environment
    outside their immediate scope. Side effects are usually not desirable, because
    they put extra mental load on the programmer's mind.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的命令式方法严重依赖于在运行时产生某些现象的算法——副作用。编译器通常对这些现象不太了解，或者了解得不够。我们可以将本书中的副作用定义为修改其直接作用域之外环境的指令。副作用通常是不受欢迎的，因为它们给程序员的思维增加了额外的负担。
- en: Another problem with the traditional imperative style is the mutation. Mutable
    data structures are not thread-safe. Also, they cannot be safely passed between
    pieces of logic even within the same thread.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 传统命令式风格的另一个问题是突变。可变数据结构不是线程安全的。而且，即使在同一线程内，它们也无法安全地在逻辑片段之间传递。
- en: Functional programming aims to resolve these problems and reduce your mental
    load. This style does so by abstracting away side effects, so that you write your
    program without explicitly performing them or mutating anything outside your current
    scope.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程旨在解决这些问题并减轻你的心理负担。这种风格通过抽象出副作用来实现，这样你就可以编写程序而无需显式执行它们或修改当前作用域之外的内容。
- en: Questions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the side effects?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 副作用是什么？
- en: What is mutable data?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是可变数据？
- en: What problems might side effects and mutable data cause?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 副作用和可变数据可能会引起什么问题？
- en: What is a pure function?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纯函数是什么？
- en: What is referential transparency?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是引用透明性？
- en: What are the benefits of using a purely functional style?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用纯函数式风格有什么好处？
- en: What are some generally encountered side effects?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常见的一些副作用有哪些？
- en: Is it possible to program with a purely functional style in imperative languages
    such as Java?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在像Java这样的命令式语言中，是否可以以纯函数式风格进行编程？
- en: What are the benefits of using a functional programming language over an imperative
    programming language for programming with a purely functional style?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数式编程语言而不是命令式编程语言进行纯函数式编程有什么好处？
