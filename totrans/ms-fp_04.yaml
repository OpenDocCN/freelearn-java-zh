- en: The Problem of Side Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functional programming is all about removing side effects and mutations.
    We remove them for a reason. In this chapter, we will see how shared mutable states
    and side-effecting functions can cause problems and why it is best to reduce them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics discussed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally encountered side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functional paradigms in different programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what exactly are side effects and why should they be avoided? For this discussion,
    we can define a side effect as some instructions in a function's code that modify
    the environment outside the scope of this function. The most common example of
    a side effect is an exception thrown by a program. Throwing an exception is a
    side effect because if you don't handle it, it will disrupt the program outside
    the scope of this function. So the program will break at this point and will stop
    its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, the function of the *Soda Machine* example from the previous
    chapter. The function that simulates coin-insertion throws an exception if there
    are no soda cans in the slot machine. So if you try to call that function on an
    empty soda machine, your program will never proceed past the function call site,
    because an exception will be thrown. That is, unless you handle this exception
    with a `try` statement at the same call site. Note that this puts the burden of
    handling side effects on the client, which is probably not what we want to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another side effect that you will encounter is a null returned from a function.
    For example, you have a database of users. You can add a function that queries
    the database and gets a user back given their ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes this function will be called with IDs of users that do not exist
    in the database. A traditional Java solution to the problem of data that does
    not exist is to return a null. Returning a null quickly creates a problem. It
    violates the expectation of the programmer that calls this function. The function
    return type is set to `User`. The programmer will rightfully expect to get an
    object of the `User` type out of this function. Therefore, they may try to call
    some of the `User` methods on that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Calling a method of the `User` type on null will result in a null pointer exception
    unless you first verify that the object is not null.
  prefs: []
  type: TYPE_NORMAL
- en: One problem here is that side effects are not reflected anywhere in the function's
    signature. Moreover, their handling is not enforced by the compiler. In Java,
    of course, you are required to declare some exceptions thrown by the functions
    in their signatures. However, it has proven to be a bad design decision, and most
    languages do not require such a declaration. Moreover, even in Java, no declaration
    is made to specify that the function can return a null. Unless the programmer
    remembers that such side effects occur in the program, they may not handle them.
    So unless they handle the side effects, the program may be error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem here is the extra mental load on the programmer. They are required
    to continually remember all the side effects that their functions may produce.
    Because if they don't, they will also forget to handle them properly. Thus, their
    code can introduce bugs. This problem is caused by the fact that the compiler
    does not enforce the handling of the side effects. The side effects are certain
    phenomena that are generated by the code at runtime. These phenomena are where
    local functions influence or are influenced by the outer environment without this
    being stated explicitly in the function type. These influences may then be generated
    by the function code, depending on the input values it receives at runtime. The
    compiler knows nothing about them. For example, the phenomenon of a function returning
    null, or an exception happening and the program being disrupted at that point.
    These things happen at runtime. At compile time, the compiler does not do any
    checks on whether they are appropriately treated.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mutable state, to put it simply, is data that can be changed. For example,
    at one point in time, you may read some variable, *x*, and find that it points
    to some data. At another time, you may read a different value from the same variable.
    The value is different because the variable is mutable and another part of the
    program mutated it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at why exactly the mutable state is not desirable. Imagine you
    have an online game. It relies on multiple threads, and the concurrency architecture
    of choice is the actors model. You have an actor that is supposed to track the
    users currently present in the game. Tracking can be implemented as a mutable
    collection inside the actor. Users log in and out of the game by sending messages
    to this actor. So, every time a message for logging in arrives at the actor, the
    user is added to the list of logged-in users. When users want to log out, they
    are removed from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine you want to find the users that have reached a particular score
    to congratulate them via an email notification. You may want to do that at the
    end of each round (assuming it''s a round-based game), which is modeled by another
    message sent to the `GameState` actor. One way to implement this is to send a
    list of all the users to a separate notifications actor that will do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s imagine that the job of looking up and notifying the users takes a while
    to complete. We can simulate the delay via the `Thread.sleep(1000)` statement.
    This statement pauses the execution of the current thread at the line where it
    is called for 1,000 milliseconds or 1 second. Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The communication protocol is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s assume the following environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an actor system, an actor for the game state, and an actor for notifications.
    Also, we have two users. The second user, `User2`, is a *winning* user because
    their score is `>= 100`. Consider what happens if a *winning* user with the required
    score logs out immediately after we complete the round:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Such a user will not be notified. Things go wrong here because the collection
    we sent to the actor that takes care of notifications is mutable. It is shared
    between the `GameState` actor and `NotificationActor`. This means that once a
    user logs out, they are removed from the collection by the `GameState` actor,
    which means that it will also be removed from the collection of the `NotificationActor`
    because it is the same collection.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example demonstrates the problem of the shared mutable state in
    action. Again, this is extra mental load on the programmer. No longer can you
    reason in the scope of only one thread if you have an object shared with another
    thread. You must expand your scope of reasoning to all the threads that own this
    object. Because for all you know, the shared mutable object can be changed at
    any time. The actor model is supposed to help you to reason as if your program
    were single-threaded and no other threads existed. However, it won't help if you
    keep using a shared mutable state.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional approach to managing a shared mutable state is to use locks
    and monitors. The principle behind it is that a thread that is doing modifications
    to an object is supposed to take a lock on some monitor so that nobody else will
    be able to perform a modification while this thread deals with the object. However,
    this does not remove the mental load from the programmer. You still need to take
    into account threads other than the one you are currently programming. In practice,
    it is tough to debug programs that involve concurrency and a shared mutable state.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we have shown you how mutations and side effects can
    make the code harder to read and write. In this section, we will introduce the
    notion of pure functions, that is, the functions that do not produce side effects.
    It is central to pure functional programming. The functional paradigm dictates
    that you should express your program with the help of functions that do not produce
    any side effects. How would you model a situation where you need to throw an exception
    with the help of a pure function? Take the familiar *Soda Machine* example.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the slightly shortened version of the *Soda Machine* example we encountered
    in our previous discussions on side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can avoid throwing an exception from the function by returning a result
    wrapped in another data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we are not returning a pure result but an encapsulated result in
    the form of a `Try` of the result. The behavior of `Try` is to trap the possibility
    of an exception being thrown within its body for further handling. `Try`, as discussed
    in previous chapters, is a data structure that can contain either a value or an
    exception. So, if the soda machine is out of cans, we no longer throw an exception.
    We return the information that an error has occurred from the function.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit here compared to the comparative analysis is as follows. There is
    no longer an unexpected side effect happening in this function. An error that
    can happen no longer interrupts the entire flow of the program. Moreover, the
    call site user of the function must handle the error to access the result. Because
    the result is wrapped into the data structure, we cannot access that result unless
    we first unwrap the data structure that it is wrapped into.
  prefs: []
  type: TYPE_NORMAL
- en: We can access the result by analyzing what exactly was returned. If it is a
    value, we know precisely that no error has happened. If it is an exception, we
    know that we need to handle it. At this point, we can say that the compiler enforces
    the handling of the error. The fact that the error can occur is reflected in the
    return type of the function. Hence, there is no longer a way to use the return
    value directly after it is returned. If you try to use it directly without first
    handling the possibility of an error, you will get a compile-time error. Because
    you will be trying to use the `Try` data structure as if it were the type that
    it wraps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of purely functional programming is that it avoids using mutable
    data structures. Let''s have another look at the example of the actors exchanging
    data with one  another. What if instead of exchanging a mutable data structure
    we exchanged an immutable data structure? An immutable list? Check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you recall, in the previous example, we had a problem with the list being
    modified from another thread when `NotificationActor` was trying to use it. Now,
    if we use an immutable list instead of a mutable list, the problem of mutation
    from another thread goes by itself, since immutable data structures cannot be
    mutated. A data structure that is immutable is automatically thread-safe. You
    can guarantee that nothing will mutate the data structure. Hence, you can share
    it freely with any other thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'This argument can be extended by exchanging data with other methods as well.
    Imagine you have some mutable data structures and some `blackBox` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After these `blackBox` methods have gone forth on this data structure, how
    do you know what exactly is contained in it now? You can''t have any guarantee
    of a mutable data structure unless you know exactly what happens in the black
    box method. Now, consider an example of an immutable list and the same situation
    of a black box method being called on this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Do you have any guarantee of what is contained in this list after the black
    box method did its job? You do because the list is immutable. Nothing can modify
    this list. So you can freely pass it around, not only to other threads, but also
    to other methods within one thread, and be confident that it is not modified.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of such an approach is that there is no longer a need to extend
    the scope of your reasoning beyond your current local scope. If you are calling
    a black box method on an immutable data structure, there is no need for you to
    know exactly what happens in this method. This method will never modify an immutable
    data structure and knowing that is enough. So, if you're working in a multithreaded
    environment, or if you are working only with immutable data structures, no longer
    do you need to worry about things such as synchronization or taking locks. You
    know that your immutable data structure will never be changed by any thread.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've discussed the property of purity from an intuitive perspective.
    Now let's look at a more scientific way of defining it—the concept of referential
    transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concepts of immutability and lack of side effects are encompassed by the
    term **referential transparency**. With a referentially transparent function,
    you can substitute the function call with the result it returns without changing
    the semantics of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works on an example. Consider another type of side effect—logging.
    The function returns the name of a user with a given ID, but it also writes that
    name into a log—the standard output, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we substitute the call of the preceding function with the result it computes?
    Let''s try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The semantics would not be the same in this case. The original program prints
    the log to the standard output. The current program does not. This is so because
    the standard output occurred in the function that we have replaced with the result
    it computed, as a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider another program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The function does the same thing, but instead of producing a side effect of
    logging, it includes the information that the side effect should have occurred
    into a list of all the messages that were supposed to be logged. Now we can return
    the list with the messages together with the result of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we substitute their function call with the result it computes without losing
    the semantics of the program? Check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now the answer is yes. The original function computed the list with all the
    messages it produced and returned it together with the value it computed, without
    actually producing any side effects. Since there were no side effects produced
    in the process, we can substitute the function call with its result without changing
    the semantics of the program. The function is referentially transparent.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding example, in a referentially transparent function,
    all of the side effects are reflected in the return type and are usually represented
    by a specific data structure. This style may look verbose and unreadable to you
    at first because you are returning a pair with some extra stuff from your function.
    However, don't forget that one of the main principles of engineering is that of
    abstraction. So the unreadable code you see here can be abstracted away if you
    have proper abstractions. This can be done without losing the benefits we have
    achieved. The benefits include reducing the mental load on the programmer, the
    ability to explain your program locally, and the ability to exclude side effects
    from the equation.
  prefs: []
  type: TYPE_NORMAL
- en: And such abstractions have been invented. Languages such as Scala or Haskell
    have excellent support for such abstractions. Later in this book, we will dive
    much deeper into how they work and how you can write programs with them.
  prefs: []
  type: TYPE_NORMAL
- en: Generally encountered side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will talk more about the side effects commonly encountered
    in programs. Some of them we have already introduced, and others you may already
    know from your everyday programming. However, it is crucial for you to pay particular
    attention to such side effects, because this way, you learn to distinguish them
    in an ordinary program.
  prefs: []
  type: TYPE_NORMAL
- en: When writing programs (and when living our lives in general), very often, we
    get used to things without even paying attention to them. Certain things may be
    a source of headaches and problems, and the first step to resolving the problems
    is to name the things that cause them.
  prefs: []
  type: TYPE_NORMAL
- en: As functional programming aims to eliminate side effects, it is reasonable for
    us to name some of the side effects that cause pain.
  prefs: []
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first effect we will be discussing is the effect of an error. An error is
    produced when something goes wrong in your program. In imperative languages, it
    is usually modeled by an exception. An exception is a phenomenon produced by a
    line of the program that disrupts the execution flow of the program at that point.
    Usually, it propagates up the call stack, disrupting the execution at its parent
    call stacks too. If left unhandled, exceptions propagate to the topmost call-stack
    frame, and the program will crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of division by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a division function that checks whether its denominator is zero. If
    it is, the function throws an exception. Now, consider calling this function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The execution of the main program will not progress further than the line where
    we tried to call the division function, the second argument of which is zero.
    This is because the error will happen in the function and will get propagated
    up the stack, eventually crashing the program.
  prefs: []
  type: TYPE_NORMAL
- en: Absence of result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider a situation where we have a function that is supposed to make a database
    query. Specifically, we have users in our database, and we want a function to
    retrieve a user by their ID. Now, what will happen when there is no user with
    a given ID in the database? Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The solution of imperative languages is a null returned from the function. In
    [Chapter 3](67d28304-c855-47aa-afb6-b74fa5a0dd28.xhtml), *Functional Data Structures*,
    we saw how this is dangerous. The compiler doesn't know that null can be returned
    from the function. More precisely, it doesn't even know this is a possibility.
    The compiler allows for functions returning `null` and does not warn us about
    a possible null return value. The imperative style embraces this possibility.
    So we have a situation in imperative languages where potentially every function
    that returns an object may also return null. If we do not check that the result
    of that function is not null, we risk bugs. And to check the result of the function,
    we need to keep in mind the possibility of it returning null. And this is an extra
    mental load.
  prefs: []
  type: TYPE_NORMAL
- en: Delay and asynchronous computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine your program performs an HTTP call. For example, it tries to retrieve
    some JSON object from a web API. It can take some time; it may even take several
    seconds to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you want to make some competition within a function and return
    some value based on the result of the API request. You run into a problem here
    because the result of the API call was not available immediately. The fact that
    you need to wait for a specific long-running operation to complete is also a side
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: You can block on this long-running operation and resume your competition once
    the result arrives. However, this function will also block any functions that
    are calling it. In the context of a performance-critical environment, this may
    be an issue. For example, consider a web server. It has several threads to serve
    all the incoming requests. If its operations take too long to complete, it will
    quickly run out of threads. And some requests will end up waiting for a long time
    in the queue for a free thread.
  prefs: []
  type: TYPE_NORMAL
- en: So, you always need to keep in mind that some of your functions are blocking
    and take time to return. This is an extra piece of information to keep in mind.
    This produces an extra mental load for you. The side effect of delayed computation
    causes all of this.
  prefs: []
  type: TYPE_NORMAL
- en: The solution used in modern web servers is to make your server asynchronous.
    This means that you never wait for a long-running operation. You specify what
    to do next using a callback and continue according to that callback once the result
    is in place. This can lead to a situation known as callback hell. The problem
    is that when you overuse callbacks, the execution flow of the program becomes
    quite obscure.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when something in the program is not apparent, this indicates a need
    for an abstraction. So it can be a good idea to abstract away callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming also has a means to abstract away long-running computations.
    With it, you can write your code as if they were returning immediately. The data
    type of `Future` is present both in Scala and Java, and also in many modern programming
    languages. It servers precisely the purpose of abstracting long-running computations.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an example in the *Referential Transparency* section of this chapter, we
    saw how logging can also be a side effect. Logging can be done using a separate
    login framework, or it can be as simple as writing to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Things may get tricky with logging when you work in an unfamiliar environment.
    For example, if it is the environment of your desktop computer, everything is
    simple. You run a program from your terminal, and it outputs everything to the
    terminal. However, what if it is a web server? Often, you need to output your
    log into a separate file for it to be readable afterward. Alternatively, what
    if you are writing a mobile application? The program runs on a separate device,
    and it is not always the case that a print statement causes an output to your
    terminal. You may need to use some system-specific logging API, native to the
    environment you are working in.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine you have a program that has `print` statements pretty much everywhere
    in it. You suddenly start to understand that some of your functions try to interact
    with the environment outside of its scope when logging. Specifically, the logging
    API particular to the environment under which you are working. Now you need to
    modify this logging call to match the expectations of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: A function that writes to a log interacts with the environment outside its scope.
    This means we can treat such calls as side effects according to our definition.
    Since you need to pay attention to these intricacies when working in different
    environments, it is fair to say they contribute to your mental load.
  prefs: []
  type: TYPE_NORMAL
- en: Input-output operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final side effect that we'll discuss here are **input-output** (**IO**)
    operations to the filesystem, or to the network. We can say that these operations
    are side effects because they depend on the environment so much.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of IO operations on the filesystem, the success of the operation
    depends on whether the filesystem contains the specified file or if the file is
    readable. When performing network operations, the operation depends on whether
    we have a reliable internet connection or any firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: When debugging an IO program, lots of moving parts come to our attention. Do
    we have access to the desired filesystem? What about the ownership of the files
    we are trying to read or write? What about the permissions the current user has?
    What about filesystems of different operating systems? Linux and Windows have
    very different approaches to structuring their filesystems, so how do we port
    our application from one system to another? Do we have a reliable internet connection?
    Are we not behind a firewall? Do our DNS servers work correctly? Is the port we
    are trying to listen on available on this particular system?
  prefs: []
  type: TYPE_NORMAL
- en: It is an extra mental load on you because there are so many things you need
    to consider. Hence, you can treat IO as side effects and an extra mental load.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we get rid of the side effects?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you come from a purely imperative background, you may be quite confused at
    this point. Purely functional programming says that you need to eliminate all
    the side effects. But can you imagine a program without logging? And what would
    be the use of a web API that cannot connect to a network? If we cannot throw an
    exception, how do we specify the erroneous behavior of the program?
  prefs: []
  type: TYPE_NORMAL
- en: The side effects specified previously are essential to most modern applications,
    and it is usually not possible to imagine a reasonable program without side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it would be wrong to say that purely functional programming eliminates
    side effects from your program completely. Instead, it would be more precise to
    say that it eliminates side effects from your business logic. It pushes side effects
    away from the parts of your application that matter. The way it usually works
    with the purely functional style is that your business logic, which encompasses
    90% of the code, is indeed purely functional.
  prefs: []
  type: TYPE_NORMAL
- en: You do not have all of the side effects specified previously. However, whenever
    the business logic needs to perform a side effect, it does not enact it directly.
    Instead, it creates a data structure that specifies which side effect needs to
    be performed, without actually performing them. Functional applications often
    have an entire domain-specific language to describe side effects. And whenever
    a piece of logic needs to execute a side effect, it expresses its need in this
    language. The specification of what needs to be done and the act of executing
    that specification are separate one from another.
  prefs: []
  type: TYPE_NORMAL
- en: Functional applications usually have a thin layer that takes care of executing
    the side effects expressed in the effect language of the application. The advantage
    of this approach is that most of the time you work on the business logic, this
    90% of your code. And this code is referentially transparent and pure. Which means
    all of the side effects that would have typically been present in it are separated
    away from it. All of the mental load that we were discussing previously is gone.
    This means that, most of the time, you are working without any extra mental load,
    locally, without considering the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: It is true that you also need to write the interpreter for your side effects.
    This is the 10% of code that the side effects expressed in the effect language
    of your choice. However, it is separate from your business logic. You can test
    your effect interpreter separately. Once it is written and in place, you can forget
    about it, and write your business logic in a pure way.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are not yet diving into the details of how it is done. The
    purpose of this section is to give you an idea of how the problem of purity in
    a side-effecting application is addressed. Later in this book, we'll see precisely
    how functional programming facilitates this technique and what exactly it provides
    to write programs in this style.
  prefs: []
  type: TYPE_NORMAL
- en: The pure functional paradigm in different languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It doesn't take any particular infrastructure to program in a purely functional
    style. All you need is to be able to see side effects in code, to notice when
    they place an extra mental load on your mind and require you to hold more things
    in mind at once. And of course, you need to know how to abstract them away, how
    to make this mental load go away. Most modern programming languages are built
    for engineers. This is why they provide excellent capabilities for abstraction,
    including imperative languages such as C or Java. This is why, if you know what
    to abstract and how, you should be able to abstract that in these languages. And
    if you know precisely how the imperative style can hurt you, you can shield yourself
    from the trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, certain imperative programming languages provide a specific infrastructure
    that facilitates purely functional style directly. For example, in Java, you have
    the `final` keyword. A variable declared with this keyword is immutable. You're
    not able to modify a `final` variable in Java once it is assigned a value. Also,
    in Java, you have immutable collections as part of its core infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Even though you can apply the functional style in imperative languages, it is
    much easier to do so in functional languages. You may encounter trouble when applying
    the style to imperative languages. One thing may be that all the libraries you
    encounter are imperative. It may be hard to write purely functional code in such
    conditions because you will be working inside an imperative infrastructure. It
    will create certain inertia that may be hard to fight. So it may not be practical
    to work in the functional style in imperative languages. However, it may be used
    as a last resort, if you are overwhelmed by complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of pure functional languages, such as Scala or Haskell, is that
    they provide you with an excellent infrastructure to write functional code. Haskell
    is a language that enforces functional style. There is just no other choice of
    style that you can use with that language. Hence, the libraries that you will
    be using in this language are also purely functional. You can work in a purely
    functional infrastructure. Scala is a more liberal language in some sense. It
    is a mix of the object-oriented and functional styles. So, it is convenient to
    use it to make a transition between purely imperative and purely functional styles.
    That is because you have a choice of style. If you do not know how to implement
    something in a purely functional way and deadlines are approaching, you can always
    resort to a familiar imperative style.
  prefs: []
  type: TYPE_NORMAL
- en: This blending of the imperative and functional styles is pretty standard in
    modern programming languages. For example, in Python, you can encounter both styles.
    Some libraries are quite imperative, but there is good support for purely functional
    style too. Java is more conservative in this sense than Python. It appears to
    follow the imperative, algorithmic paradigm quite strictly, even though huge efforts
    have been put into making the functional style more natural to Java during the
    last decade or so.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, the point of this section is that the functional style is not about
    the language. The language can provide some momentum, in the sense of its existing
    infrastructure and the methodology of its community. This momentum can be in either
    direction—either it will work for you, or against you. However, if you understand
    the functional approach, you should be fine programming in any language using
    it. But you should always be aware of where the wind blows—what the moods of its
    community are, what philosophy its libraries follow. You should be aware of the
    momentum the language provides you and whether it works for you or against you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional imperative approach relies heavily upon algorithms that are
    supposed to produce certain phenomena at runtime—the side effects. The compiler
    is usually not aware of these phenomena or is not aware of them enough. We can
    define the side effects for this book as instructions that modify the environment
    outside their immediate scope. Side effects are usually not desirable, because
    they put extra mental load on the programmer's mind.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the traditional imperative style is the mutation. Mutable
    data structures are not thread-safe. Also, they cannot be safely passed between
    pieces of logic even within the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming aims to resolve these problems and reduce your mental
    load. This style does so by abstracting away side effects, so that you write your
    program without explicitly performing them or mutating anything outside your current
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the side effects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is mutable data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What problems might side effects and mutable data cause?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a pure function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is referential transparency?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using a purely functional style?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some generally encountered side effects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to program with a purely functional style in imperative languages
    such as Java?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using a functional programming language over an imperative
    programming language for programming with a purely functional style?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
