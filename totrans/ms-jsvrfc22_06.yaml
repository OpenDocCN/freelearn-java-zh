- en: Chapter 6. Working with Tabular Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data that makes sense when displayed in a spreadsheet (or a tabular structure)
    is known as **tabular data**. In web applications, tabular data is commonly obtained
    from databases, where the data is natively represented in relational tables. The
    main JSF component for displaying tabular data is represented by the `<h:dataTable>`
    tag, which is capable of producing HTML classical tables. This chapter is a tribute
    to this tag, since tabular data is very commonly used and can be manipulated in
    many ways. Therefore, in this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple JSF table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CollectionDataModel` class of JSF 2.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a table row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing/updating a table row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a row number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a single row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting multiple rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paginating tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating tables with the JSF API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter focuses more on the tables that are populated with data that comes
    from collections (databases). But, you can include in and manipulate the content
    in the table with almost any JSF UI component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple JSF table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most commonly, everything starts from a POJO class (or a EJB entity class),
    as shown in the following code—note that tables with hardcoded information were
    skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each instance of this POJO class is actually a row in the table displayed to
    the user (it''s not mandatory, but usually this is how things work). Next, a JSF
    bean (or CDI bean) will provide a collection of POJO''s instances. (The `List`,
    `Map`, and `Set` instances are the ones that are most commonly used.) In the following
    code, the `List` instance is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that, usually, data is queried from a database, but this is not quite relevant
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'This common scenario ends with a piece of code that displays the data on the
    screen. The code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple JSF table](img/6466EN_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_1`.
  prefs: []
  type: TYPE_NORMAL
- en: The CollectionDataModel class of JSF 2.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until JSF 2.2, the supported types for the `<h:dataTable>` tag contains `java.util.List`,
    arrays, `java.sql.ResultSet`, `javax.servlet.jsp.jstl.sql.Result`, `javax.faces.model.DataModel`,
    null (or empty list), and types used as scalar values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can also use `java.util.Collection`. This is especially
    useful to Hibernate/JPA users, who are usually using the `Set` collections for
    entity relationships. Therefore, nothing can stop us from using a `HashSet`, `TreeSet`,
    or `LinkedHashSet` set for feeding our JSF tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example is like a test case for the most-used Java collections. First,
    let''s declare some collections of `Players` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.ArrayList`: This library implements `java.util.Collection`. The
    `java.util.ArrayList` collection is declared as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.LinkedList`: This library implements `java.util.Collection`. The
    `java.util.LinkedList` collection is declared as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.HashSet`: This library implements `java.util.Collection`. The `java.util.HashSet`
    collection is declared as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.TreeSet`: This library implements `java.util.Collection`. The `java.util.TreeSet`
    collection is declared as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For the `TreeSet` collection, you have to use `Comparable` elements, or provide
    `Comparator`. Otherwise, the `TreeSet` collection can't do its job since it wouldn't
    know how to order the elements. This means that the `Players` class should implement
    `Comparable<Players>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`java.util.LinkedHashSet`: This library implements `java.util.Collection`.
    The `java.util.LinkedHashSet` collection is declared as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.HashMap`: This library doesn''t implement `java.util.Collection`.
    The `java.util.HashMap` collection is declared as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.TreeMap`: This library doesn''t implement `java.util.Collection`.
    The `java.util.TreeMap` collection is declared as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.LinkedHashMap`: This library doesn''t implement `java.util.Collection`.
    The `java.util.LinkedHashMap` collection is declared as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Supposing that these collections are populated and the getters are available;
    they are used to display their content in a table in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.ArrayList`: This library implements `java.util.Collection`.. The
    following is the code of the `java.util.ArrayList` collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In the same manner, we can display in a table the `LinkedList`, `HashSet`, `TreeSet`,
    and `LinkedHashSet` collection classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`java.util.LinkedList`: This library implements `java.util.Collection`. The
    following is the code of the `java.util.LinkedList` collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.HashSet`: This library implements `java.util.Collection`. The following
    is the code of the `java.util.HashSet` collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.TreeSet`: This library implements `java.util.Collection`. The following
    is the code of the `java.util.TreeSet` collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.LinkedHashSet`: This library implements `java.util.Collection`.
    The following is the code of the `java.util.LinkedHashSet` collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the following examples to display a `Map` collection in a table. (`HashMap`,
    `TreeMap`, and `LinkedHashMap` are displayed in the same way.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`java.util.HashMap`: This library doesn''t implement `java.util.Collection`.
    The following is the code of the `java.util.HashMap` collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.TreeMap`: This library doesn''t implement `java.util.Collection`.
    The following is the code of the `java.util.TreeMap` collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`java.util.LinkedHashMap`: This library doesn''t implement `java.util.Collection`.
    The following is the code of the `java.util.LinkedHashMap` collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For a `Map` collection, you can have a getter method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the code of the table will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CollectionDataModel` class is an extension of the `DataModel` class that
    wraps a `Collection` class of Java objects. Furthermore, in this chapter, you
    will see some examples that will alter this new class.
  prefs: []
  type: TYPE_NORMAL
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous examples, the data is arbitrarily displayed. Sorting the data
    provides more clarity and accuracy in reading and using the information; for example,
    see the screenshot of the *Creating a simple JSF table* section. You can try to
    visually localize the number 1 in the ATP ranking, and number 2 and number 3,
    and so on, but it is much more useful to have the option of sorting the table
    by the **Ranking** column. This is a pretty simple task to implement, especially
    if you are familiar with Java''s `List`, `Comparator`, and `Comparable` features.
    It is beyond the scope of this book to present these features, but you can accomplish
    most of the sorting tasks by overriding the `compare` method, which has a straightforward
    flow: it compares both of its arguments for order and returns a negative integer,
    zero, or a positive integer, as the first argument is less than, equal to, or
    greater than the second. For example, let''s see some common sortings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sort the list of strings, such as player''s names. To do this sorting, the
    code of the `compare` method is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sort the list of numbers, such as the player''s rankings. To do this sorting,
    the code of the `compare` method is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sort the list of dates, such as player''s birthdays (this works as in the case
    of strings). To do this sorting, the code of the `compare` method is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `data` argument stands for a `List` collection type because not all types
    of collections can take the place of this one. For example, `List` will work perfectly,
    while `HashSet` won't. There are different workarounds to sort collections that
    are not `List` collections. You have to ensure that you choose the right collection
    for your case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know how to write comparators for the selected collection, then everything
    else is simple. You can encapsulate the comparators in managed beans methods and
    attach buttons, links, or anything else that calls those methods. For example,
    you can add these comparators to the `PlayersBean` backing bean, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can easily modify the code of the `index.xhtml` page to provide access
    to the sorting feature as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sorting tables](img/6466EN_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_3_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, each sorting provides two links: one for ascending and one
    for descending. We can easily glue these links in a switch-link, by using an extra
    property in our view scoped bean. For example, we can declare a property named
    `sortType`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a simple condition to make it act as a switch between ascending and descending
    sort as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `index.xhtml` page contains a single link per sort, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this trick can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sorting tables](img/6466EN_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_3_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and DataModel – CollectionDataModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A more complex sorting example involves a decorator class that extends the
    `javax.faces.model.DataModel` class. JSF uses a `DataModel` class even if we are
    not aware of it, because each collection (`List`, array, `HashMap` and so on)
    is wrapped by JSF in a `DataModel` class (or, in a subclass, as `ArrayDataModel`,
    `CollectionDataModel`, `ListDataModel`, `ResultDataModel`, `ResultSetDataModel`,
    or `ScalarDataModel`). JSF will call the table `DataModel` class''s methods when
    it renders/decodes table data. In the following screenshot, you can see all directly
    known subclasses of the `DataModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sorting and DataModel – CollectionDataModel](img/6466EN_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you will see in this chapter, sometimes you need to be aware of the `DataModel`
    class because you need to alter its default behavior. (It is recommended that
    you take a quick look at the official documentation of this class's section at
    [https://javaserverfaces.java.net/nonav/docs/2.2/javadocs/](https://javaserverfaces.java.net/nonav/docs/2.2/javadocs/)
    to obtain a better understanding.) The most common cases involve the rendering
    row numbers, sorting, and altering the row count of a table. When you do this,
    you will expose the `DataModel` class instead of the underlying collection.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's suppose that we need to use a collection, such as `HashSet`.
    This collection doesn't guarantee that the iteration order will remain constant
    over time, which can be a problem if we want to sort it. Of course, there are
    a few workarounds, such as converting it to `List` or using `TreeSet` instead,
    but we can alter the `DataModel` class that wraps the `HashSet` collection, which
    is the new JSF 2.2 class, `CollectionDataModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can accomplish this in a few steps, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend the `CollectionDataModel` class for overriding the default behavior
    of its methods, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide a constructor and use it for passing the original model (in this case,
    `CollectionDataModel`). Besides the original model, we need an array of integers
    representing the indexes of rows (For example, `rows[0]=0`, `rows[1]=1`, ... `rows[n]=
    model.getRowCount()`). Sorting the row indexes will actually sort the `HashSet`
    collection, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to override the `setRowIndex` method to replace the default row
    index, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, provide a comparator as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, our custom `CollectionDataModel` class with sorting capabilities is ready.
    We can test it by declaring and populating `HashSet`, wrapping it in the original
    `CollectionDataModel` class, and passing it to the custom `SortDataModel` class,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we are the caller, we need to provide a comparator. The complete example
    is available in the code bundle of this chapter, and is named `ch6_3_3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting a table row
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting a table row can be easily implemented by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a method in the managed bean that receives information about the row
    that should be deleted, and remove it from the collection that feeds the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, for a `Set` collection, the code will be as follows (`HashSet<Players>`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `Map<String, Players>`, the code will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Besides columns containing data, add a new column in the table named **Delete**.
    Each row can be a link to the `delete`*XXX* method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, we can delete a value from `Set` (`HashSet<Players>`), as shown
    in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And from `Map<String, Players>`, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following screenshot, you can see a possible output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting a table row](img/6466EN_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_4`.
  prefs: []
  type: TYPE_NORMAL
- en: Editing/updating a table row
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most convenient approaches for editing/updating a table row consists
    of using a special property to track the row edit status. This property can be
    named `edited` and it should be of the type `boolean` (default `false`). Define
    it in the POJO class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your POJO class is an entity class, then define this new property as transient,
    using the `@Transient` annotation or transient modifier. This annotation will
    tell JPA that this property doesn't participate in persistence and that its values
    are never stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, assign an **Edit** link to each row. Using the `rendered` attribute,
    you can easily show/hide the link using a simple EL condition; initially, the
    link is visible for each row. For example, take a look at the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `Set` collection, the code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For a `Map` collection, the code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the link is clicked, the `edited` property will be switched from `false`
    to `true` and the table will be re-rendered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `Set` collection, the code of the `editRowHashSet` method is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For a `Map` collection, the code of the `editRowHashSet` method is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This means that the link is not rendered anymore and the user should be able
    to edit that table row. You need to switch between the `<h:outputText>` tag, used
    to display data (visible when the `edited` property is `false`), and the `<h:inputText>`
    tag, which is used to collect data (visible when the `edited` property is `true`).
    Using the `rendered` attribute again will do the trick, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `Set` collection, the code is modified as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For a `Map` collection, the code is modified as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you need a button to save changes; this button will set the `edited`
    property back to `false`, preparing the table for more edits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `Set` collection, the code for the button is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For a `Map` collection, the code for the button is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a straightforward action, as you can see in the following points—values
    inserted in the input textbox are automatically saved in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `Set` collection, the code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For a `Map` collection, the code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Done! In the following screenshot, you can see a possible output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing/updating a table row](img/6466EN_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_5`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new row
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a new row is also a simple task. First, you need to provide a form that
    reflects a table row content, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a new row](img/6466EN_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This form can be easily implemented using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The button labeled **Add Player** will call a managed bean method that creates
    a new `Players` instance and adds it in the collection that feeds the table, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see the newly added row from the data
    shown in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a new row](img/6466EN_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_6_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more elegant approach is to add a row directly in the table and eliminate
    this user form. This can be easily accomplished by following these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use linked collections (for example, use `LinkedHashSet` instead of `HashSet`
    or `LinkedHashMap` instead of `HashMap`). A table is populated by iterating the
    corresponding collection, but some collections, such as `HashSet` or `HashMap`,
    do not provide an iteration order, which means that the iteration order is unpredictable.
    This is important because we want to add a row at the end of the table, but this
    is hard to achieve with an unpredictable iteration order. But a linked collection
    would fix this issue, which is shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new row by creating a new item in the corresponding collection and activate
    the editable mode using the `Set` and `Map` collections as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the code for a linked `Set` collection:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the code for a linked `Map` collection:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Check out the following screenshot for a possible output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a new row](img/6466EN_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_6_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying row numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, JSF doesn''t provide a method for displaying row numbers. But as
    you can see in the screenshot depicting the output in the *Editing/updating a
    table row* section, there is a column named **No** that displays row numbers.
    You can obtain this column in at least two ways. The simplest workaround consists
    of binding the table to the current view, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Another approach is to obtain it using the `DataModel` class, which has the
    `getRowIndex` method to return the currently selected row number. In order to
    do that, you need to wrap the collection in a `DataModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: The example named `ch6_7` contains the first approach of this task.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a single row
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest implementation of such a task is to provide a button for each row
    in the table. When a button is clicked, it can pass the selected row, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Since the `showSelectedPlayer` method receives the selected row, it can process
    it further with no other requirements. The complete example is available in the
    code bundle of this chapter, and is named `ch6_8_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, selecting one item from a bunch of items is a job for a
    group of radio buttons. In a JSF table, items are rows, and adding a radio button
    per row will result in a column as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting a single row](img/6466EN_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, adding radio buttons in the `<h:column>` tag using the `<h:selectOneRadio>`
    tag doesn''t behave as expected. The main functionality of radio buttons doesn''t
    work; selecting one radio will not deselect the rest of radios in the group. It
    is now acting more like a group of checkboxes. You can fix this issue by implementing
    a deselection mechanism through JavaScript. Moreover, at this point, you can set
    a JSF hidden field with the value of the selected row. For example, if the table
    is populated by `Map`, you use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you need to find the form containing the radios by the ID. Afterwards,
    iterate through the form''s children, and identify each radio by a fixed part
    of its ID. Check only the radio that was selected by the user, and uncheck the
    rest of them. Next, populate a hidden field with the value of the selected row.
    The ID of the selected radio and the row value are provided as arguments, as follows
    (in this case, the table is populated from `Map`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the hidden field for storing the selected row information, you need
    a button labeled **Show Hash Map Selection**, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `showSelectedPlayer` method is ready to process the selected
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete example is available in the code bundle of this chapter and
    is named `ch6_8_2`.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel that using a hidden field is not a very elegant approach, then you
    can replace its role by using the `valueChangeListener` attribute of the `<h:selectOneRadio>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: In the code bundle of this chapter, you can find an example that uses the `valueChangeListener`
    attribute named `ch6_8_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting multiple rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multiple selection is commonly achieved using groups of checkboxes. One of
    the most convenient approaches for multiple selections consists of using a special
    property for tracking the row selection status. This property can be named `selected`
    and it should be of type `boolean` (default `false`). You can define it in the
    POJO class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your POJO class is an entity class, then define this new property as transient,
    using the `@Transient` annotation or transient modifier. This annotation will
    tell JPA that this property doesn't participate in persistence and his values
    are never stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, assign a checkbox to each row (`<h:selectBooleanCheckbox>`). Using the
    `value` attribute and the `selected` property, you can easily track the selection
    status, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'So the `<h:selectBooleanCheckbox>` tag will do the hard work for us (we just
    exploit its natural behavior), therefore, all you need is a button labeled **Show
    Selected Players**, as shown in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `showSelectedPlayers` method has an easy task. It can iterate the collection
    and check the status of the `selected` property for each item; this is a good
    chance to reset the selected items as well. For example, you can extract the selected
    items in a separate list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_8_4`.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to use an extra property, such as `selected`, you can use
    a `Map <String, Boolean>` map. The code is pretty straightforward; therefore,
    a quick look over the complete code, `ch6_8_5`, will clarify things instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s most likely that you won''t need to display a table inside another table,
    but there are cases when this workaround can be useful in obtaining a clear presentation
    of the data. For example, nested collections can be presented as nested tables
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, players are stored in `HashMap` as keys, and each player has a collection
    (`HashSet`) of trophies. Each `HashSet` value is a value in `HashMap`. Therefore,
    you need to display the table of players; however, you need to display each player''s
    trophies. This can be achieved as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output for the preceding code can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nesting tables](img/6466EN_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application is named `ch6_9`, and is available in the code bundle
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Paginating tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to display large tables (with many rows), it can be useful to
    implement a pagination mechanism. There are many advantages, such as its fancy
    look, the clear presentation of data, saving space in web pages, and lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: In a standard version of such a table, we should be able to navigate to the
    first page, last page, next page, previous page, and in some tables, to select
    the number of rows displayed on one page.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you bind a table to its backing bean, you have access to three handy properties,
    which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first`: This property represents the first row number that is displayed in
    the current table page (it starts from the default value `0`). The value for this
    property can be specified using the `first` attribute of the `<h:dataTable>` tag.
    In the JSF API, this is accessible through the `HtmlDataTable.getFirst` and `HtmlDataTable.setFirst`
    methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rows`: This property represents the number of rows displayed in a single page,
    starting from `first`. The value for this property can be specified using the
    `rows` attribute of the `<h:dataTable>` tag. In the JSF API, this is accessible
    through the `HtmlDataTable.getRows` and `HtmlDataTable.setRows` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rowCount`: This property represents the total number of rows, from all pages,
    starting from row 0\. There is no attribute for this property. In the JSF API,
    this is accessible through the `HtmlDataTable.getRowCount` method. Setting the
    row count can be accomplished through the data model, as you will see later. By
    default, is determined by JSF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, these properties can be seen in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Paginating tables](img/6466EN_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding information is very useful for to implementing the pagination
    mechanism. First, we bind the table, and set the first row number and the number
    of rows per page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on some arithmetic and EL condition''s support, we can conclude the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first row number, the row number per page, and the total row count are
    accessible via the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the first page by using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A button that accomplishes this navigation can be disabled by an EL condition,
    as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the next page by using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A button that accomplishes this navigation can be disabled by an EL condition,
    as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the previous page by using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A button that accomplishes this navigation can be disabled by an EL condition,
    as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the last page by using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A button that accomplishes this navigation can be disabled by an EL condition,
    as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the **current page** of the **total pages** message by using the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Merging all these chunks of code in a sample application (see the application
    `ch6_10_1`), will result in something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Paginating tables](img/6466EN_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The biggest issue here is that even if the data is displayed in pages, they
    are still loaded in the memory as a bulk. In this case, pagination is just a *slicer*
    of the collection, which has only visual effect. In reality, the pagination is
    the effect of **lazy loading**, which represents a technique for querying only
    a portion of data from a database (instead of slicing the data in memory, you
    slice it from the database directly). There are many kinds of querying in a database,
    but in Java web/enterprise applications, EJB/JPA is the most used. EJB and JPA
    are large technologies that can't be covered here, but with some assumptions it
    will be very easy to understand the upcoming example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you feel that EJB/JPA are not good choices, you should can take into account
    the fact that the `<h:dataTable>` tag also supports `java.sql.ResultSet`, `javax.servlet.jsp.jstl.Result`,
    and `javax.sql.CachedRowSet`. So, for tests, you can use plain JDBC as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the `Players` POJO class, this time you will use a `Players` JPA
    entity that is bounded to a table named `PLAYERS`. This table contains the data
    that should be displayed in the JSF table and it was created in Apache Derby RDBMS,
    in the `APP` database (if you have NetBeans 8.0 with GlassFish 4.0, then this
    RDBMS and the `APP` database are out of the box). The idea is to query this table
    to obtain only the rows from `first` to `first` + `rows`, which is exactly the
    amount of rows displayed per page. This can be easily accomplished by JPA using
    the `setFirstResult` and `setMaxResults` methods of a query (the `loadPlayersAction`
    method was defined in a EJB component, named `PlayersSessionBean`), as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: So, passing the right `first` and `max` arguments will return the needed rows!
  prefs: []
  type: TYPE_NORMAL
- en: 'But pagination works if we know the total number of rows, since without this
    we can''t calculate the number of pages, or the last page, and so on. In JPA,
    we can do this easily (the `countPlayersAction` method was defined in a EJB component,
    named `PlayersSessionBean`) by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing the total number of rows (without actually extracting the data from
    the database) is great, but we need to tell JSF that number! Since `HtmlDataTable`
    doesn''t provide a `setRowCount` method, we have to take another approach into
    account. One solution is to extend the `DataModel` class (or one of its subclasses)
    and provide the row count explicitly; since we are using `HashSet`, we can extend
    the `CollectionDataModel` class of JSF 2.2 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'So, creating a `PlayersDataModel` class can be accomplished in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, each time a page navigation is detected in the table, we just need
    to call the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_10_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating tables with the JSF API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSF tables can be programmatically generated as well. The JSF API provides
    comprehensive support to accomplish such tasks. First, you *prepare* the place
    where the generated table will be added, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is simple: when the button labeled **Add Table** is clicked, the generated
    table should be attached in the `<h:panelGrid>` tag identified by the `myTable`
    ID.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating a JSF table in a programmatic fashion, you need to know how
    to create a table, a header/footer, a column, and so on. Let''s have a short overview
    as follows—the code is self-explanatory and straightforward, since JSF provides
    very intuitive methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the simplest table, `<h:dataTable value="..." var="t" border="1">`
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create a column with a header, a footer, and a possible converter,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, attach the table in DOM (in order to do that, you need to find the desired
    parent component) using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `findComponent` method uses the JSF `visit` method, which is very useful
    for traversing a tree of components, which is shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In Mojarra, the `FullVisitContext` method comes from the `com.sun.faces.component.visit`
    package. In MyFaces, this class comes from the `org.apache.myfaces.test.mock.visit`
    package. Both the implementations extend `javax.faces.component.visit.VisitContext`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The necessary expressions are then added as shown in the following code (you
    saw another example of this in [Chapter 2](ch02.html "Chapter 2. Communication
    in JSF"), *Communication in JSF*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, merge these methods in a helper class, `TableHelper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember the button labeled **Add Table**? Well, when that button is clicked,
    the `addTable` method is called. This method exploits the `TableHelper` class
    for programmatically creating a table, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Done! The complete application is available in the code bundle of this chapter,
    and is named `ch6_11`.
  prefs: []
  type: TYPE_NORMAL
- en: A programmatically generated table would be an apt approach for generating tables
    with variable number of columns, or dynamic columns. Let's suppose that we have
    two JPA entities, `Players` and `Trophies`. The first entity should produce a
    table with nine columns, while `Trophies` should produce a table with three columns.
    Moreover, the column names (headers) differ. It may sound complicated, but actually
    is more simple than you would have expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think that each table is mapped by a JPA entity, which means that we can write
    specific queries by indicating the entity name. Moreover, each entity can be passed
    through Java''s reflection mechanism to extract the field''s names (we are focusing
    on the `private` fields), which gave us the column headers. (If you alter the
    column names using `@Column(name="alias_name")`, then the process will be a little
    tricky to reflect the alias names.) So, we can use the following code (the package
    name is fixed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: So, as long as we pass the table name (entity name) to this method, it will
    return the corresponding data. For the complete example, check the application
    named `ch6_12` in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filtering data is a very useful facility in a table. It allows the user to *see*
    only the set of data that matches a certain set of rules (criteria); most commonly,
    filter by column(s). For example, the user may need to see all players younger
    than 26 years, which is a filter applied in the column labeled **Age**.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, a filter can have only visual effect, without modifying the filtered
    data (using some CSS, JS code, or duplicating the filter results in a separate
    collection and displaying that collection), or by removing the unnecessary items
    for the initial collection (which requires restoring its content when the filter
    is removed).
  prefs: []
  type: TYPE_NORMAL
- en: In JSF, we can write a nice filter by playing with some CSS code, which can
    be used to hide/show rows of a table; this is not a recommended approach in production,
    since all the data is still available in the source page, but it might be useful
    when you don't need anything fancy. The idea is to hide all of the table's rows
    that do not match the filter criteria, and for this, we can exploit the `rowClasses`
    attribute of the `<h:dataTable>` tag. This attribute's value is represented by
    a string of CSS classes separated by a comma; JSF iterates the CSS classes and
    applies them sequentially and repeatedly over rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two CSS classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a filter can use the `rowshow` CSS class to display a row containing valid
    data, and the `rowhide` CSS class to hide the rest of the rows. For example, iterating
    over a collection of five elements can reveal the following string of CSS classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: So, only the first and the third row will be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the steps involved in the writing of such a filter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A convenient way to add a filter selection per column consists of using the
    `<h:selectOneMenu>` tag. For example, we add a filter selection in the **Age**
    column, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `addTableFilter` method is called when the button labeled **Go!** is clicked.
    It checks the value of the `criteria` property, and if the value equals `<26`
    or `>=26`, then it iterates over the table rows and builds the corresponding string
    of CSS classes. Otherwise, if the `criteria` property is equal to `all`, the filter
    is removed, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following `removeTableFilter` method will restore the CSS class; therefore,
    all data will be visible again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the complete example, check the application named `ch6_13_1` in the code
    bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to notice that the number of rows per page is modified when the
    filter is applied. Actually, when the filter results are displayed, the rows per
    page become equal to table row count, and when the filter is removed, they take
    a value anything from 1 to row count. The conclusion is that the filtered data
    is displayed in a table without pagination.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, like filtering by age, you can apply a sort before generating
    the string of CSS classes. This will help you to display the filter results, without
    affecting data, and with pagination available. A complete example can be found
    in the code bundle of this chapter, named `ch6_13_2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain the same results by removing from the initial collection the
    items that do not match the filter criteria. For example, notice that before applying
    a filter, you need to restore the initial data of the collection—the `initHashSet`
    method can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: If you want to apply a chain of filters, then restore the data before entering
    in the chain. A complete example can be found in the code bundle of this chapter
    named `ch6_13_3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since collections that feed tables are usually populated from databases, you
    can apply filters directly on databases. A common case is represented by tables
    with a lazy loading mechanism; since you have only a slice of data in memory,
    you need to apply the filter on the database instead of filtering the collection
    that populates the table. This means that the filtration process is accomplished
    through SQL queries. For example, our filter can be modeled through SQL queries,
    by performing the following steps (this example is based on the lazy loading application
    presented earlier in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: 'You pass the filter criteria to the EJB component (`copy_criteria` acts as
    a flag—you don''t want to count the number of rows each time the user navigates
    through table pages using the same filter), as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Count the number of rows returned by the filter as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, round off by applying the filter criteria using SQL queries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Done! The complete example is available in the code bundle of this chapter and
    it is named `ch6_13_4`.
  prefs: []
  type: TYPE_NORMAL
- en: Styling tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all JSF UI components support the `style` and `styleClass` attributes
    for creating custom designs using CSS. But the `<h:dataTable>` tag supports attributes,
    such as `captionClass`, `captionStyle`, `columnClasses`, `rowClasses`, `headerClass`,
    and `footerClass`. Therefore, we should have no problem in adding a CSS style
    to every single part of a table (header, footer, caption, and so on). Obviously,
    there are plenty of examples that can be built, but let's see three of the most
    impressive and used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate row colors with the rowclasses attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rowClasses` attribute is used to indicate a string of CSS classes separated
    by a comma. The string is parsed by JSF, and the styles are applied sequentially
    and repeatedly to rows. For example, you can color the even rows with one color,
    and the odd rows with some other color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `even` and `odd` are the following CSS classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Alternate row colors with the rowclasses attribute](img/6466EN_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can obtain the same effect for columns, by using the `columnClasses` attribute
    instead of the `rowClasses` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The complete example is named `ch6_14_1`.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting rows on mouse hover
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Highlighting rows on mouse hover is a nice effect that can be accomplished
    with a piece of JavaScript. The idea is to set the `onmouseover` and `onmouseout`
    attributes, as shown in the following self-explanatory code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named `ch6_14_2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach does not involve using the JavaScript code. In this case,
    you can try CSS pseudo-classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete application is named `ch6_14_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting rows on mouse click
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Highlighting rows with a mouse click can be done with another piece of JavaScript
    code. You have to add the `onclick` attribute to each row and control the color
    alternation when the user clicks repeatedly on the same row, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named `ch6_14_4` in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tabular data is very commonly used in web applications, and this chapter is
    a tribute to the powerful JSF DataTable component (`<h:dataTable>`). JSF 2.2 brought
    even more power by allowing developers to render more collections than before,
    by adding the new `CollectionDataModel` class. This chapter covers the most common
    tasks that a table should accomplish, such as sorting, filtering, lazy loading,
    and CSS support. Notice that a cool and comprehensive extension of the `<h:dataTable>`
    tag is provided by PrimeFaces ([http://primefaces.org/](http://primefaces.org/))
    under the tag named `<p:dataTable>` ([http://www.primefaces.org/showcase/ui/datatableHome.jsf](http://www.primefaces.org/showcase/ui/datatableHome.jsf)).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be covering the AJAX technique for JSF applications.
  prefs: []
  type: TYPE_NORMAL
