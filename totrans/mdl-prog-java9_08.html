<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding Linking and Using jlink</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapters, we've learned about some advanced concepts relating to Java modularity, including handling readability and accessibility of module relationships, and the powerful concept of services. In this chapter, we'll move on to the final step in any application development--building and packaging your application.</p>
<p class="calibre2">Here's what you'll learn in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">You'll learn about the module resolution process, an important process that happens every time you compile or execute a modular Java application.</li>
<li class="calibre15">You'll be introduced to a new phase in the development process--linking. Linking, or static linking, is a new step in Java 9 modular development. It sits between the familiar compilation and execution phases that you should already be familiar with. In this chapter, you'll understand what linking is and the benefits of this step.</li>
<li class="calibre15">You'll learn how to use <kbd class="calibre12">jlink</kbd>, the new tool built into the platform to facilitate the linking phase and help build runtime images.</li>
<li class="calibre15">You'll learn about some <kbd class="calibre12">jlink</kbd> plugins that optimize runtime images that are created by <kbd class="calibre12">jlink</kbd>.</li>
<li class="calibre15">You'll learn how to build a modular JAR file, which is an alternative way to distribute your compiled library modules for use in other applications.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module resolution process</h1>
                
            
            <article>
                
<p class="calibre2">Before we get into the details of the linking process and what it can do for us, let's understand an important step that happens every time you compile and execute a modular Java application. This is a step called <strong class="calibre1">module resolution</strong>.</p>
<p class="calibre2">Traditionally (pre-Java 9), the Java compiler and Java runtime would to look at a set of folders and JAR files that form the <strong class="calibre1">classpath</strong>. The classpath is a configurable option that you pass to the compiler during compilation and to the runtimes during execution. In order to have any class file be under the purview of the compiler or runtime, you'd need to first place it in the classpath. Once it's there, every Java type is <em class="calibre22">available</em> for the compiler or the runtime.</p>
<p class="calibre2">Things are different with modules. We don't have to use the generic classpath anymore. Since every module defines its <em class="calibre22">inputs</em> and <em class="calibre22">outputs</em>, there's now an option to know exactly what portion of the code is needed at any time.</p>
<p class="calibre2">Consider the following module dependency graph:</p>
<div class="packt_figure"><img class="image-border67" src="../images/00074.jpeg"/></div>
<p class="calibre2">Let's assume that you have the modules <strong class="calibre1">A</strong>, <strong class="calibre1">B</strong>, <strong class="calibre1">C</strong>, <strong class="calibre1">D</strong>, and <strong class="calibre1">E</strong> in the module path. Let's imagine that you are playing the role of the Java runtime, and you want to execute the <kbd class="calibre12">main</kbd> method in module <strong class="calibre1">C</strong>. What is the minimal set of modules that are <em class="calibre22">required</em> for this to happen? You'll obviously need module <strong class="calibre1">C</strong>, since that has the <kbd class="calibre12">main</kbd> method. Next you'll need its dependencies, modules <strong class="calibre1">B</strong> and <strong class="calibre1">D</strong>. Next you'll need those modules' dependencies as well, which in this case is module <strong class="calibre1">A</strong>, which <strong class="calibre1">B</strong> depends on:</p>
<div class="packt_figure"><img class="image-border68" src="../images/00075.jpeg"/></div>
<p class="calibre2">Using this process, it's safe to say that the minimum set of modules required to execute a <kbd class="calibre12">main</kbd> type in module <strong class="calibre1">C</strong> is <strong class="calibre1">A</strong>, <strong class="calibre1">B</strong>, <strong class="calibre1">C</strong>, and <strong class="calibre1">D</strong>--module <strong class="calibre1">E</strong> is unnecessary.</p>
<p class="calibre2">Let's repeat the exercise, but this time to execute a type in module <strong class="calibre1">E</strong>. This time, we'll just need modules <strong class="calibre1">E</strong> and <strong class="calibre1">D</strong>; all other modules can be skipped:</p>
<div class="packt_figure"><img class="image-border69" src="../images/00076.jpeg"/></div>
<p class="calibre2">Now why are we doing this? What's the advantage of finding this <em class="calibre22">minimal set of modules?</em> Contrast this with the older classpath model where every type in the classpath is a part of the application, and any type could be <em class="calibre22">in use</em>. There's no way for the compiler and runtime to figure out where a given type exists unless it scans the entire classpath. That's not the case anymore! Since both the compiler and runtime now have a precise idea about what part of the code base is <em class="calibre22">needed</em> to execute anything and what part is not, it puts this advantage to good use, as we'll soon see. But in order to get this information, the platform runs a process of resolving modules, which is, in principle, similar to what we did in the preceding example. This process is called the module resolution process.</p>
<div class="packt_infobox">In graph theory, this process is referred to as finding <em class="calibre29">transitive closure</em>. Given a graph, the idea is to find a set of nodes that are <em class="calibre29">reachable</em> from a given node. The graph on which we perform transitive closure should be what's called a <strong class="calibre26">directed acyclic graph</strong> (<strong class="calibre26">DAG</strong>). The graph should be <strong class="calibre26">directed</strong>, in that the relationships between nodes are directional (with arrows), and <strong class="calibre26">acyclic</strong>, in that there shouldn't be cyclical relationships. Does the DAG remind you of any graphs you've seen recently? Yes! The Java module graph is a great example of a directed acyclic graph!</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module resolution steps</h1>
                
            
            <article>
                
<p class="calibre2">Here are the high-level steps that the platform runs through when it resolves modules:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Add the root module to the resolved set of modules. Remember that when you execute your code, you specify the type containing the main method and the module it belongs to. This module is the root module and forms the starting point for the module resolution process. Note that this starting point doesn't have to be just one module--there could be several modules, as we'll see shortly.</li>
<li value="2" class="calibre15">Identify all the <kbd class="calibre12">requires</kbd> dependencies of the module(s) added. Here, each module's descriptor file is looked up to identify all the modules that it <em class="calibre22">reads</em>. This includes both <kbd class="calibre12">requires</kbd> and <kbd class="calibre12">requires transitive</kbd>.</li>
<li value="3" class="calibre15">From the list from step 2, remove all modules that are already in the resolved set of modules.</li>
<li value="4" class="calibre15">Add the remaining modules to the resolved set of modules. Repeat step 2 for this list.</li>
</ol>
<p class="calibre2">As you can imagine, this is a recursive graph operation that starts with one or more modules and ends up with the minimal set of modules that are needed as dependencies. Since the platform does this during every compilation and runtime phase, it uses this opportunity to check for several different kinds of errors. In fact, many of the module errors we've encountered so far happen because of checks during and around the module resolution process. Here are a few of them:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Unavailable dependent modules</strong>: This one is obvious. While looking up dependencies, if a module isn't found among the observable modules, the process errors out. This, as we've seen, is the key to reliable configuration.</li>
<li class="calibre15"><strong class="calibre1">Multiple modules</strong>: Not only do all dependent modules have to be available, there needs to be only one of each. If there happen to be two modules in the module path that have the same name (even if they have entirely different contents), the platform catches this right away and throws an error.</li>
<li class="calibre15"><strong class="calibre1">Cyclic dependencies</strong>: If two or more modules depend on each other and form a closed loop cycle in the module graph, the platform throws an error, as we've already seen.</li>
<li class="calibre15"><strong class="calibre1">Split packages</strong>: The platform assumes that each package is available in just one module. The class loaders maintain a map of each package to the module it is found in. Thus, if there are multiple modules that contain the same package, the process terminates with an error.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Examining module resolution in action</h1>
                
            
            <article>
                
<p class="calibre2">There's a new command option added to Java that prints out debug information that describes the module resolution process. You can activate it by passing the option <kbd class="calibre12">--show-module-resolution</kbd>. When passed this option, the <kbd class="calibre12">java</kbd> command prints out console messages for each step of the module resolution. You can use this to see the process that the runtime goes through to resolve all the modules, much like we did in the preceding exercise.</p>
<p class="calibre2">This is how you ran the command-line address book module in the previous chapter, without the flag:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out -m packt.addressbook/packt.addressbook.Main</strong></pre>
<p class="calibre2">Here's how you run it with the module resolution diagnostics enabled:</p>
<pre class="calibre23"><strong class="calibre1">$ java --show-module-resolution --module-path out -m <br class="title-page-name"/>  packt.addressbook/packt.addressbook.Main</strong>  </pre>
<p class="calibre2">The verbose output gives a clear indication of what's happening here. Things start off with the root module <kbd class="calibre12">packt.addressbook</kbd>, as expected:</p>
<pre class="calibre23"><strong class="calibre1">root packt.addressbook file:///Users/koushik/code/java9/07-<br class="title-page-name"/>services/out/packt.addressbook/
</strong></pre>
<p class="calibre2">Next, it finds the dependent modules from the module descriptor. For every module it finds, the output lists the name of the module, where it found it (the path), and why (which module required it):</p>
<pre class="calibre23"><strong class="calibre1">packt.addressbook requires packt.addressbook.lib file:///Users/koushik/code/java9/07-services/out/packt.addressbook.lib/<br class="title-page-name"/>packt.addressbook requires java.logging jrt:/java.logging
</strong></pre>
<p class="calibre2">It also figures out the service providers based on the modules that declared themselves as consumers:</p>
<pre class="calibre23"><strong class="calibre1">packt.sortutil binds packt.sort.bubblesort file:///Users/koushik/code/java9/07-services/out/packt.sort.bubblesort/<br class="title-page-name"/>packt.sortutil binds packt.sort.javasort file:///Users/koushik/code/java9/07-services/out/packt.sort.javasort/<br class="title-page-name"/>packt.addressbook binds packt.sort.bubblesort file:///Users/koushik/code/java9/07-services/out/packt.sort.bubblesort/<br class="title-page-name"/>packt.addressbook binds packt.sort.javasort file:///Users/koushik/code/java9/07-services/out/packt.sort.javasort/ </strong></pre>
<p class="calibre2">The runtime continues to look for subsequent dependencies as it traverses the nodes of the module graph. After it's done adding all the necessary modules to the resolved set, it then executes the main method and the expected program output is printed on the console:</p>
<pre class="calibre23"><strong class="calibre1">Aug 16, 2017 11:07:02 PM packt.addressbook.Main main<br class="title-page-name"/>INFO: Address book viewer application: Started<br class="title-page-name"/>[Charles Babbage, Tim Berners-Lee, Edsger Dijkstra, Ada Lovelace, Alan Turing]<br class="title-page-name"/>Aug 16, 2017 11:07:03 PM packt.addressbook.Main main<br class="title-page-name"/>INFO: Address book viewer application: Completed</strong> </pre>
<p class="calibre2">Now that you've understood the process of module resolution and how it benefits the process of compile-time and runtime enforcement of reliable configuration, let's now look at another problem that it can solve. We briefly introduced the problem of the monolithic JDK in <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 1</span></a>, <em class="calibre22">Introducing Java 9 Modularity</em>. We'll quickly recap the problem and then learn how that it is no longer a problem with Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Revisiting the state of the JDK</h1>
                
            
            <article>
                
<p class="calibre2">In <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 1</span></a>, <em class="calibre22">Introducing Java 9 Modularity</em>, we examined the large size of the JDK, both in terms of the file size of <kbd class="calibre12">rt.jar</kbd> as well as the number of classes that are bundled in it. Typically, you wouldn't think about the JDK when developing Java applications. Once you've installed the JDK on your development machine, it sits in a remote corner of your hard disk at <kbd class="calibre12">$JAVA_HOME</kbd> and it doesn't bother you. There are, however, a few instances where you would need to worry about the size of the JDK, especially when bundling an application executable. Here are a couple of such occasions:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Runtime bundles for embedded devices</strong>: Java has been known to run on portable and embedded devices, such as compact music players, microwaves, and washing machines. Many of these are devices with scarce hardware capacities for memory and processing power, and for Java to run on those devices, the runtime should obviously be a part of the installed application. The size of the Java SE runtime is so prohibitive that there is a separate platform (Java ME) for such scenarios.</li>
<li class="calibre15"><strong class="calibre1">Runtime images for microservices</strong>: A common trend in recent years is to deploy lightweight microservices in the cloud. Instead of having one centralized web application that does everything, the application is split into separate smaller services that run on different machine instances and communicate with each other over the network. The runtime image for each instance is a self-sufficient set of binaries that include the application classes and the Java runtime. These microservices are ideally stateless, scalable, and disposable, so they'd ideally need to be lightweight and performant. Bundling a 75 MB runtime that needs to be a part of every instance doesn't really help.</li>
</ul>
<p class="calibre2">Think for a minute about why this problem even exists. Well, it's because of the classpath model of previous versions of Java. Any piece of code can potentially refer to any other Java type in the classpath, and there's no saying what's required and what's not, so we had no choice but to add the whole platform.</p>
<p class="calibre2">This is no longer the case with modular programming! We've seen that with module resolution, given a starting point, we can precisely identify which modules are required for its execution. This applies equally to both application and platform modules, since they both follow the same contract. Thanks to this, we can now apply the module resolution process and come up with a unique bare minimum set of platform <em class="calibre22">and</em> application modules that you'd need to run any application. Thus, when distributing an application with runtime, for example, you don't have to include the entire platform. Instead, you just include the platform modules that are necessary, and we do just that by introducing a whole new step in Java application development that we didn't have before--linking.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Linking using jlink</h1>
                
            
            <article>
                
<p class="calibre2">JDK 9 comes bundled with a new tool called <kbd class="calibre12">jlink</kbd> that lets you build your own complete runtime image that contains everything necessary to execute a given application. Remember the new structure of the JDK that we looked at in <a target="_blank" href="part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 4</span></a>, <em class="calibre22">Introducing the Modular JDK</em>:</p>
<div class="packt_figure"><img class="image-border70" src="../images/00077.jpeg"/></div>
<p class="calibre2">With <kbd class="calibre12">jlink</kbd>, you can create a similar custom image of your own to distribute your application. The generated image contains:</p>
<ul class="calibre14">
<li class="calibre15">The minimal set of your application and library modules that you've authored or added</li>
<li class="calibre15">The minimal set of platform modules needed for your application to work</li>
</ul>
<p class="calibre2">This effectively solves the problem of the huge overhead incurred to ship the platform along with your application. What you ship is just what the application needs--no more, no less. There are further benefits to this process, but before we get into that, let's learn how to use <kbd class="calibre12">jlink</kbd> to create this image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The jlink command</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">jlink</kbd> command needs the following inputs:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">The module path</strong>: This is where it needs to look for modules. This is the directory (or directories) where the compiled modules are available.</li>
<li class="calibre15"><strong class="calibre1">The starting module</strong>: This is the module from which to begin the module resolution process. This could be one or many, separated by delimiters.</li>
<li class="calibre15"><strong class="calibre1">The output directory</strong>: This is the location where it stores the generated image.</li>
</ul>
<p class="calibre2">The usage looks something like this, with the command broken into separate lines for readability:</p>
<pre class="calibre23"><strong class="calibre1">jlink --module-path &lt;module-path-locations&gt; </strong>
  <strong class="calibre1">    --add-modules &lt;starting-module-name&gt; </strong>
  <strong class="calibre1">    --output &lt;output_location&gt;</strong>  </pre>
<p class="calibre2">To run this command on our sample codebase and generate an image for the address book UI module, we first need to compile the modules in the same way that we usually do:</p>
<pre class="calibre23"><strong class="calibre1">$ javac --module-source-path src -d out $(find . -name '*.java')</strong>  </pre>
<p class="calibre2">Here, <kbd class="calibre12">out</kbd> is the location of the compiled modules, and thus, that is the module path for <kbd class="calibre12">jlink</kbd>. The module that serves as the starting point is <kbd class="calibre12">packt.addressbook.ui</kbd>.</p>
<p class="calibre2">In the same directory that we ran the <kbd class="calibre12">javac</kbd> command, we can now run <kbd class="calibre12">jlink</kbd>. To run the command, either make sure the  <kbd class="calibre12">$JAVA_HOME/bin</kbd> directory is in your operating system's  path, or use the path to access <kbd class="calibre12">jlink</kbd> directly:</p>
<pre class="calibre23"><strong class="calibre1">$ $JAVA_HOME/bin/jlink --module-path out <br class="title-page-name"/>   --add-modules packt.addressbook.ui --output image</strong>  </pre>
<p class="calibre2">Note that we get an error:</p>
<pre class="calibre23"><strong class="calibre1">Error: Module java.base not found, required by packt.addressbook.ui</strong> </pre>
<p class="calibre2">We are missing the platform modules! Note that <kbd class="calibre12">java.base</kbd> is a core platform module and is not available in the module path we've specified in the preceding command. Platform modules don't get special treatment; their module location needs to be explicitly specified to the <kbd class="calibre12">jlink</kbd> command!</p>
<p class="calibre2">We've already seen that the core Java modules are available in <kbd class="calibre12">$JAVA_HOME/jmods</kbd>. Let's add that to the <kbd class="calibre12">--module-path</kbd> parameter. As before, in order to specify multiple paths there, we need to separate the paths with the <kbd class="calibre12">:</kbd> symbol (<kbd class="calibre12">;</kbd> on Windows operating systems):</p>
<pre class="calibre23"><strong class="calibre1">$ $JAVA_HOME/bin/jlink --module-path $JAVA_HOME/jmods:out <br class="title-page-name"/>   --add-modules packt.addressbook.ui --output image</strong></pre>
<p class="calibre2"><kbd class="calibre12">jlink</kbd> will now get to work and quietly generate the runtime image for us. Let's look at the structure of the image generated:</p>
<div class="packt_figure"><img class="image-border71" src="../images/00078.jpeg"/></div>
<p class="calibre2">This should look familiar now. The structure is very similar to the JDK file structure we've already seen. One notable exception is that the <kbd class="calibre12">jmods</kbd> folder isn't here. This makes sense because this is a <em class="calibre22">runtime</em> image, and the <kbd class="calibre12">jmods</kbd> format is not designed to be used for runtime. Since this image contains only the modules necessary, they are all bundled into a common <kbd class="calibre12">modules</kbd> file in the <kbd class="calibre12">lib</kbd> folder.</p>
<p class="calibre2">Now that the image contains the runtime and the compiled application modules, it is a self-sufficient bundle. You can deploy this image on a computer that does not have the Java runtime installed and execute it without any problems.</p>
<p class="calibre2">Now, to execute our module from the runtime image, we need to execute the <kbd class="calibre12">java</kbd> executable that's available in the <kbd class="calibre12">bin</kbd> directory of the image, not the one in <kbd class="calibre12">$PATH</kbd>. You also don't have to specify the <kbd class="calibre12">--module-path</kbd> this time because the module resolution is already done! The generated image is already bundled with every module it needs, and thus already knows where to find them:</p>
<pre class="calibre23"><strong class="calibre1">$ cd image/ 
$ bin/java -m packt.addressbook.ui/packt.addressbook.ui.Main </strong></pre>
<p class="calibre2">You should see the address book UI application pop up. That's great, but you can probably tell something isn't right:</p>
<div class="packt_figure"><img class="image-border72" src="../images/00079.jpeg"/></div>
<p class="calibre2">The names aren't sorted. Can you guess why? It's because the sorting modules haven't been bundled in! If you run the <kbd class="calibre12">java --list-modules</kbd> on the <kbd class="calibre12">java</kbd> executable in the image, you can see all the modules that have been bundled in. Note that the sorting service modules aren't included:</p>
<pre class="calibre23"><strong class="calibre1">$ bin/java --list-modules 
java.base@9
 ... 
packt.addressbook.lib 
packt.addressbook.ui 
packt.contact 
packt.sortutil</strong> </pre>
<p class="calibre2">Remember that the module resolution process traverses the module graph and adds modules that have a <strong class="calibre1">direct dependency</strong> using the <kbd class="calibre12">requires</kbd> clause. Services, by definition, are loosely coupled and so are not required by any module. Because of this reason, both the service modules--<kbd class="calibre12">packt.sort.bubblesort</kbd> and <kbd class="calibre12">packt.sort.javasort</kbd>--haven't been included. This behavior of <kbd class="calibre12">jlink</kbd> is intentional. The bundling of service modules needs to be explicitly stated to the command.</p>
<div class="packt_infobox">Note that the <kbd class="calibre28">java --list-modules</kbd> command displays the observable modules that are available in the runtime image on which the command is run. All along, we've run the command on the installed JDK, so it listed all (and only) the platform modules. This time, we have run the command on the generated runtime image, which is a combination of our application modules and a select few platform modules. Thus, the output of the command reflects that accordingly.</div>
<p class="calibre2">There are a couple of ways we can fix our problem. The first way is to add the service modules to the list of <strong class="calibre1">starting-point modules</strong> for module resolution using the <kbd class="calibre12">--add-modules</kbd> option. Multiple module names can be specified for this option, with the names separated by commas. These modules and their dependencies will then also get bundled into the image, since the module resolution process will run starting from each of those modules, too, and add them to the resolved set:</p>
<pre class="calibre23"><strong class="calibre1">$ $JAVA_HOME/bin/jlink --module-path $JAVA_HOME/jmods:out <br class="title-page-name"/>    --add-modules packt.addressbook.ui,packt.sort.bubblesort,packt.sort.javasort <br class="title-page-name"/>    --o</strong><strong class="calibre1">utput image</strong>  </pre>
<p class="calibre2">Now, running <kbd class="calibre12">java --list-modules</kbd> in the generated image should show the sorting modules. Also, when executing the application, the UI should now show the list of contacts sorted by last name:</p>
<pre class="calibre23"><strong class="calibre1">$ bin/java --list-modules</strong>
  <strong class="calibre1">java.base@9-ea</strong>
 <strong class="calibre1"> ...</strong>
  <strong class="calibre1">packt.addressbook.lib</strong>
  <strong class="calibre1">packt.addressbook.ui</strong>
  <strong class="calibre1">packt.contact</strong>
  <strong class="calibre1">packt.sort.bubblesort</strong>
  <strong class="calibre1">packt.sort.javasort</strong>
  <strong class="calibre1">packt.sortutil</strong></pre>
<p class="calibre2">Another alternative to bundling in services is to use the <kbd class="calibre12">--bind-services</kbd> option of <kbd class="calibre12">jlink</kbd>:</p>
<pre class="calibre23"><strong class="calibre1">$ $JAVA_HOME/bin/jlink --module-path $JAVA_HOME/jmods:out <br class="title-page-name"/>    --add-modules packt.addressbook.ui --bind-services --output image</strong>  </pre>
<p class="calibre2">This parameter automatically identifies any services consumed by modules when it checks each module through the module resolution process. Then, all observable modules that declare that they are providers for those services will be automatically bundled in. This is an easier option because you don't have to explicitly mention service modules yourself, but there's a chance that you might pull in more modules than you really require. Let's say there's some random module in the module path that your application doesn't use, but it just happens to implement one of the service types you've used. Well, that module gets pulled in with this option!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Link phase optimizations and jlink plugins</h1>
                
            
            <article>
                
<p class="calibre2">There have always been two steps to get Java code to execute--the compile step (using <kbd class="calibre12">javac</kbd>) and the execution step (using <kbd class="calibre12">java</kbd>). During the compilation step, <kbd class="calibre12">javac</kbd> doesn't just try to convert Java code into byte code, it also tries to perform any optimizations it can and generate the most optimal and efficient byte code possible. Over the years, the Java compiler has learned several new tricks and strategies to better optimize the resulting byte code. But there has always been a challenge--the compiler works on a handful of classes at a time and it doesn't have the opportunity to see the big picture by looking at the entire application, which could have helped it implement better optimizations. That option is available for runtime, but some of the optimizations end up being too expensive when done at runtime. With the introduction of the new linking step in between the compile and execution phases, an opportunity opens up to do application-level optimization for our Java byte code. In fact, one of the goals of the platform team for the linking phase is to do <strong class="calibre1">whole-world</strong> optimizations--optimizations that span multiple classes and modules across the application, having been given the <strong class="calibre1">bigger picture</strong>.</p>
<p class="calibre2">Remember that the linking step is optional, of course. We've executed our application in the previous chapters without having to use <kbd class="calibre12">jlink</kbd>, and thereby without doing any such optimizations. However, if you were to use <kbd class="calibre12">jlink</kbd>, there's an opportunity to do optimizations--things such as compressing the image, identifying and removing unreachable code and types, pre-optimizing code, and methods where the possible inputs are constant and known ahead of time. These optimizations can happen when running <kbd class="calibre12">jlink</kbd> and are done using a series of <kbd class="calibre12">transformers</kbd>, which are built as plugins.</p>
<p class="calibre2">Here's an approximation of how <kbd class="calibre12">jlink</kbd> works to create the runtime image:</p>
<div class="packt_figure"><img class="image-border73" src="../images/00080.jpeg"/></div>
<p class="calibre2">The process starts with gathering all the necessary resources and running them through a series of transformers that can do various tasks and optimizations. The <kbd class="calibre12">jlink</kbd> tool has a plugin API so that anyone can create custom plugins that hook into this process and have the opportunity to transform the resulting image. After the transformers are done, the image is written to the output directory, where, again, plugins can be written to control what happens.</p>
<p class="calibre2">The Java 9 platform comes with built-in plugins that do several of these optimizations. In fact, some of these optimizations are so important and have such a significant impact that they have been turned on by default! It's important to know some of these options that are available to you while you generate your runtime image:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Module descriptor optimizations with the</strong> <strong class="calibre1">system-modules plugin</strong>: During the initial development of modules in Java, it was noticed that the Java runtime ended up spending a significant amount of time and resources examining, parsing, and validating the module descriptors (<kbd class="calibre12">module-info.class</kbd>) of each module in the system image. Since the set of modules that are going to be bundled in an image is known at link time, the process of scanning and validating all the module descriptors can be done at link time too. There is a <kbd class="calibre12">jlink</kbd> plugin that does this bundled with the platform, and is called <kbd class="calibre12">system-modules</kbd>. This plugin generates a pre-processed and pre-validated system module graph so that the runtime doesn't have to. The process results in such significant gains in performance that it's enabled by default whenever you run <kbd class="calibre12">jlink</kbd>.</li>
<li class="calibre15"><strong class="calibre1">Compressing the image with the</strong> <strong class="calibre1">compress plugin</strong>: This plugin allows you to apply compression to the generated image to reduce the size of the output runtime image. There are two types of compression that this plugin can perform on the generated image. The first identifies all usages of UTF-8 strings and generates a global string table so that any common <kbd class="calibre12">String</kbd> values have to be stored only once and can be reused across the application. The second type of compression is the ZIP compression of files in the resulting image to shrink its overall size.</li>
</ul>
<p class="calibre24">Unlike system-modules, this plugin is not enabled by default. To use it, you'll need to pass the <kbd class="calibre12">--compress</kbd> option to <kbd class="calibre12">jlink</kbd>. You can pass three values--<kbd class="calibre12">0</kbd>, which means no compression, <kbd class="calibre12">1</kbd>, which enables string sharing, and <kbd class="calibre12">2</kbd>, which does ZIP compression.</p>
<p class="calibre24">Running the two levels of compression while generating the address book image on our sample code shows the gains in size of the generated images:</p>
<pre class="calibre23">      $ <strong class="calibre1">$JAVA_HOME/bin/jlink --module-path $JAVA_HOME/jmods:out <br class="title-page-name"/>           --add-modules packt.addressbook.ui --bind-services <br class="title-page-name"/>           --compress=1 --output image1</strong>
<br class="title-page-name"/>      $ <strong class="calibre1">$JAVA_HOME/bin/jlink --module-path $JAVA_HOME/jmods:out<br class="title-page-name"/>          --add-modules packt.addressbook.ui --bind-services<br class="title-page-name"/>          --compress=2 --output image2</strong>  </pre>
<p class="calibre24">Examining the sizes of the resulting images shows us how much space the compression has saved us. The following table summarizes the folder sizes on my machine after running these commands:</p>
<table class="msotablegrid">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Compression</strong></p>
</td>
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Address book image size</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2">None</p>
</td>
<td class="calibre8">
<p class="calibre2">167.5 MB</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2">Level 1</p>
</td>
<td class="calibre8">
<p class="calibre2">129.4 MB</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2">Level 2</p>
</td>
<td class="calibre8">
<p class="calibre2">95.9 MB</p>
</td>
</tr>
</tbody>
</table>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Locale information with the</strong> <strong class="calibre1">include-locales plugin</strong>: By default, the runtime image bundles in all installed locale information. If you are targeting your application runtime only for certain locales, you can use the <kbd class="calibre12">--include-locales</kbd> option and pass the comma-separated list of locales you need. Only those locales will be included in the resulting image, thus freeing up more space:</li>
</ul>
<pre class="calibre23">      $ <strong class="calibre1">$JAVA_HOME/bin/jlink --module-path $JAVA_HOME/jmods:out<br class="title-page-name"/>       --add-modules packt.addressbook.ui --bind-services<br class="title-page-name"/>       --compress=2 --include-locales=en --output image3</strong>  </pre>
<p class="calibre24">The preceding command regenerates the image with full compression, and with the English locale included (<kbd class="calibre12">--include-locales=en</kbd>). On my machine, this resulted in further space savings, with the image size at 88.2 MB.</p>
<p class="calibre2">There are several other handy plugins that come bundled in the JDK. To get to know what plugins are available, and to learn how to use them, you can run <kbd class="calibre12">jlink</kbd> with the <kbd class="calibre12">--list-plugins</kbd> option. The complete list of installed plugins will be displayed, including the plugins we've just learned about and much more:</p>
<pre class="calibre23"><strong class="calibre1">$ $JAVA_HOME/bin/jlink --list-plugins</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building a modular JAR file</h1>
                
            
            <article>
                
<p class="calibre2">We've looked at creating complete modular runtime images and learned about the advantages of the linking process, but sometimes that may not be what you want. Suppose you are a library developer and you just want to bundle a single utility module as a jar file. When building a jar file from a module, you have an option of creating a <strong class="calibre1">modular JAR file</strong>. A modular jar file is just like any other jar file, but with the <kbd class="calibre12">module-info.class</kbd> file in the root directory. You can use this to distribute compiled modules as a single file instead of the whole module folder. You can drop a modular JAR file in a module path when running the <kbd class="calibre12">java</kbd> command, and it behaves just like the compiled module folders that we've been dealing with.</p>
<p class="calibre2">To illustrate this, let's replace a couple of modules in the <kbd class="calibre12">out</kbd> folder of the address book application with modular JAR files.</p>
<p class="calibre2">The way to create a modular JAR file is by using the <kbd class="calibre12">jar</kbd> utility. In order to convert the <kbd class="calibre12">packt.contact</kbd> module into a modular JAR file, we run the following command:</p>
<pre class="calibre23"><strong class="calibre1">$ jar --create --file out/contact.jar --module-version=1.0 <br class="title-page-name"/>     -C out/packt.contact .</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">--create</kbd> option tells the <kbd class="calibre12">jar</kbd> utility that it needs to create a JAR file. The <kbd class="calibre12">-C</kbd> option specifies where it can find the classes. The value is of the format <kbd class="calibre12">&lt;folder&gt; &lt;file&gt;</kbd>. In our case, the folder is <kbd class="calibre12">out/packt.contact</kbd>. This is followed by  "<kbd class="calibre12">.</kbd>"  which indicates that all files in this location need to be included. The <kbd class="calibre12">--module-version</kbd> option specifies a module version for the <kbd class="calibre12">jar</kbd>. Finally, the <kbd class="calibre12">--file</kbd> option provides the JAR output file name.</p>
<p class="calibre2">Running this command will create a modular JAR file, with the <kbd class="calibre12">module-info.class</kbd> file at the root. There's also a <kbd class="calibre12">META-INF</kbd> folder with a manifest file that records the version number specified: <kbd class="calibre12">Manifest-Version: 1.0</kbd>.</p>
<p class="calibre2">Even modules with an executable <kbd class="calibre12">main</kbd> method can be converted to modular jars. Here's how we'd convert the <kbd class="calibre12">packt.addressbook.ui</kbd> module into a modular JAR:</p>
<pre class="calibre23"><strong class="calibre1">$ jar --create --file out/addressbook-ui.jar --module-version=1.0 <br class="title-page-name"/>    --main-class=packt.addressbook.ui.Main -C out/packt.addressbook.ui .</strong>  </pre>
<p class="calibre2">Most of the parameters should be familiar here, except for the <kbd class="calibre12">--main-class</kbd>. This option, as the name says, specifies the type with the <kbd class="calibre12">main</kbd> method.</p>
<p class="calibre2">With these two modules converted to modular JAR files and placed in the module path, you can now delete the corresponding compiled module folders and still execute the application. The runtime treats the modular JAR file the same way as the expanded module folder:</p>
<pre class="calibre23"><strong class="calibre1">$ rm -rf out/packt.contact/ 
$ rm -rf out/packt.addressbook.ui/ 
$ java --module-path out <br class="title-page-name"/>     -m packt.addressbook.ui/packt.addressbook.ui.Main </strong></pre>
<p class="calibre2">The application should still work the same way, although this time, it's executing two of the modules from the JAR file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter examined the part of the application development process after you are done writing code--building and packaging your application for distribution. We started the chapter by examining the module resolution process. We then looked at the process of linking, which uses module resolution to build a runtime image containing just the modules needed for a given application. We then looked at some of the built-in plugins that allow us to optimize and preprocess the generated image. Finally, we learned how to generate a modular JAR file to bundle reusable library modules for use in other applications.</p>
<p class="calibre2">We've looked at a lot of features so far and how they work. In the next chapter, we'll start looking at how to work with Java 9 modules in the context of an existing legacy Java codebase. You'll learn ways to write code that is interoperable between different Java versions. You'll also learn techniques and strategies to migrate existing code written using Java 8 or earlier to the new modular application development of Java 9. See you in the next unit!</p>


            </article>

            
        </section>
    </body></html>