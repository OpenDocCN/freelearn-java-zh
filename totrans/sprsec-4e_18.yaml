- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Single Sign-On with the Central Authentication Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll examine the use of the **Central Authentication Service**
    (**CAS**) as a **Single Sign-On** (**SSO**) portal for Spring Security-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about **CAS**, its architecture, and how it benefits system administrators
    and organizations of any size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how Spring Security can be reconfigured to handle the interception
    of authentication requests and redirect them to **CAS**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the **JBCP Calendar** application to utilize CAS SSO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaining an understanding of how the **Single Logout** feature can be implemented,
    and configuring our application to support it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing how to use **CAS** proxy ticket authentication for services, and
    configuring our application to utilize proxy ticket authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing how to customize the out-of-the-box **JA-SIG CAS** server using the
    recommended war overlay approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the **CAS** server with **LDAP**, and passing data from **LDAP**
    to **Spring Security** via **CAS**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/lFJjp](https://packt.link/lFJjp).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Central Authentication Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CAS** is an open source, SSO server that provides centralized access control
    and authentication to web-based resources within an organization. The benefits
    of **CAS** for administrators are numerous, and it supports many applications
    and diverse user communities. These benefits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Individual or group access to resources (applications) can be configured in
    one location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broad support for a wide variety of authentication stores (to centralize user
    management) provides a single point of authentication and control in widely distributed
    cross-machine environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broad authentication support is provided for web-based and non-web-based Java
    applications through **CAS** client libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single point of reference for user credentials (via **CAS**) is provided so
    that **CAS** client applications are not required to have any knowledge of the
    user’s credentials, or knowledge of how to verify them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we’ll not focus much on the management of **CAS**, but on authentication
    and how **CAS** can act as an authentication point for the users of our site.
    Although **CAS** is commonly seen in intranet environments for enterprises or
    educational institutions, it can also be found in use at high-profile locations
    such as Sony Online Entertainment’s public-facing site.
  prefs: []
  type: TYPE_NORMAL
- en: High-level CAS authentication flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a high level, **CAS** is composed of a **CAS** server, which is the central
    web application for determining authentication, and one or more **CAS** services,
    which are distinct web applications that use the CAS server to get authenticated.
    The basic authentication flow of **CAS** proceeds via the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The user attempts to access a protected resource on the website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected through the browser from the **CAS** service to the **CAS**
    server to request a login.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS** server is responsible for user authentication. If the user is not
    already authenticated to the **CAS** server, then the latter requests credentials
    from the user. As shown in the following diagram, the user is presented with a
    login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user submits their credentials (that is, the username and password).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user’s credentials are valid, the **CAS** server responds with a redirect
    through the browser with a service ticket. A service ticket is a one-time use
    token used to identify a user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS** service calls the **CAS** server back to verify that the ticket
    is valid, has not expired, and so on. Note that this step does not occur through
    the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS** server responds with an assertion indicating that trust has been
    established. If the ticket is acceptable, trust has been established and the user
    may proceed via normal authorization checking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This behavior is illustrated visually in the following diagram:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 18.1 – High-level CAS authentication flow](img/B21757_18_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.1 – High-level CAS authentication flow
  prefs: []
  type: TYPE_NORMAL
- en: We can see that there is a high level of interaction between the **CAS** server
    and the secured application, with several data-exchange handshakes required before
    trust in the user can be established. We assume other network security precautions,
    such as the use of **Secure Sockets Layer** (**SSL**) and network monitoring,
    are in place.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this complexity is a SSO protocol that is quite hard to spoof
    through common techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how **CAS** authentication works in general, let’s see
    how it applies to Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security and CAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security has a strong integration capability with **CAS**, although it’s
    not as tightly integrated into the security namespace style of configuration as
    the **OAuth2** and **LDAP** integrations that we’ve explored thus far in the latter
    part of this book. Instead, much of the configuration relies on bean wiring and
    configuration by reference from the security namespace elements to bean declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two basic pieces of **CAS** authentication when using Spring Security involve
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Replacement of the standard `AuthenticationEntryPoint` implementation, which
    typically handles redirection of unauthenticated users to the login page with
    an implementation that redirects the user to the CAS server instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing the service ticket when the user is redirected back from the **CAS**
    server to the protected resource, through the use of a custom servlet filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important thing to understand about **CAS** is that in typical deployments,
    **CAS** is intended to replace all the alternative login mechanisms in our application.
    As such, once we configure **CAS** for Spring Security, our users must use **CAS**
    exclusively as the authentication mechanism for our application. In most cases,
    this is not a problem; as we discussed in the previous section, **CAS** is designed
    to proxy authentication requests to one or more authentication stores (just as
    Spring Security does when delegating to a database or **LDAP** for authentication).
    From the previous diagram (*Figure 18**.1*), we can see that our application is
    no longer checking its own authentication store to validate users. Instead, it
    authenticates the user with service tickets. However, as we will discuss in the
    *Getting the UserDetails object from a CAS assertion* section, initially, Spring
    Security still needs a data store to determine the user’s authorization. We will
    discuss how to remove this restriction later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After completing the basic **CAS** integration with Spring Security, we can
    remove the login link from the home page and enjoy automatic redirection to **CAS**’s
    login screen, where we attempt to access a protected resource. Of course, depending
    on the application, it can also be beneficial to still allow the user to explicitly
    log in (so that they can see customized content, among other things).
  prefs: []
  type: TYPE_NORMAL
- en: Required dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go too far, we should ensure that our dependencies are updated. The
    following is a list of the dependencies that we have added with comments on when
    they are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing and configuring CAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CAS** has the benefit of having an extremely dedicated team behind it that
    has done an excellent job of developing both quality software and accurate, straightforward
    documentation on how to use it. Should you choose to follow along with the examples
    in this chapter, you are encouraged to read the appropriate getting started manual
    for your **CAS** platform. You can find this manual at [https://apereo.github.io/cas/](https://apereo.github.io/cas/).'
  prefs: []
  type: TYPE_NORMAL
- en: In order to make integration as simple as possible, we have included a **CAS**
    server application for this chapter that can be deployed in Eclipse or IntelliJ,
    along with the calendar application.
  prefs: []
  type: TYPE_NORMAL
- en: For the examples in this chapter, we will assume that `https://localhost:9443/cas/`
    and the calendar application is deployed at `https://localhost:8443/`. To work,
    **CAS** requires the use of HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter were written using the most recent available version
    of the `CAS` server, `7.0.1` at the time of writing, which requires Java 21\.
    So, if you are on an earlier version of the server, these instructions may be
    slightly or significantly different for your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead and configure the components required for CAS authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start the chapter off with the source in `chapter18.00-calendar`
    and `chapter18.00-cas-server`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the CAS server, run the following command from the `chapter18.00-cas-server`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the following default CAS login/password for this example: `casuser`/`Mellon`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the **JBCP Calendar** application, we should be able to use the same credentials
    to log in. Note that the user has admin rights.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next steps, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the CAS SSL certificate inside the `chapter18.00-cas-server/src/main/resources/etc/cas`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To check the import is done successfully, run the following command. If you
    are asked for the password the keystore password, the default one is *change it*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $CAS_JAVA_HOME variable is the JVM used by the CAS server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check the import is done successfully, you can run the following command.
    If you are asked for the password the keystore password, the default one is *change
    it*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be similar to following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`$JBCP_JAVA_HOME` represents the path of *Java* used by the `cacerts` file
    is the following by default: `$$JBCP_JAVA_HOME/lib/security/cacerts`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$CAS_JAVA_HOME` represents the path of *Java* used by the `cacerts` file is
    the following by default: `$CAS_JAVA_HOME/lib/security/cacerts`.'
  prefs: []
  type: TYPE_NORMAL
- en: This path should be adapted to your current `cacerts` file location if you are
    not relying on the default JDK `cacerts` file.
  prefs: []
  type: TYPE_NORMAL
- en: To adapt the command to Windows, you need to replace the `$JBCP_JAVA_HOME` Unix/Linux
    environment variable syntax with the `%JBCP_JAVA_HOME%` Windows syntax. In this
    command, `%JBCP_JAVA_HOME%` is assumed to be a Windows environment variable pointing
    to the Java installation directory. Make sure to replace it with the actual path
    in your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn’t import both the *CAS server SSL certificate* into the *JBCP Calendar
    JVM*, and *JBCP Calendar SSL Certificate* into the *CAS server JVM*, you will
    get the following error in the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException:
    unable to find valid certification path to` `requested target`'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring basic CAS integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the Spring Security namespace does not support CAS configuration, there
    are quite a few more steps that we need to implement to get a basic working setup.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the CAS properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Spring Security setup relies on an `o.s.s.cas.ServiceProperties` bean in
    order to store common information about `ServiceProperties` object plays a role
    in coordinating the data exchange between the various **CAS** components—it is
    used as a data object to store CAS configuration settings that are shared (and
    are expected to match) by the varying participants in the **Spring CAS** stack.
    You can view the configuration included in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You probably noticed that we leveraged system properties to use variables named
    `${cas.base.url}` and `${service.base.url}`. Both values can be included in your
    application, and Spring will automatically replace them with the values provided
    in the `PropertySources` configuration. This is a common strategy when deploying
    a `https://localhost:9443/cas` by default for the `https://localhost:8443` for
    the calendar application.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration can be overridden using a system argument when the application
    is taken to production. Alternatively, the configuration can be externalized into
    a Java properties file. Either mechanism allows us to externalize our configuration
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make the following updates to your `application.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding the CasAuthenticationEntryPoint object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we briefly mentioned in the *Spring Security and CAS* section, `Spring Security`
    uses an `o.s.s.web.AuthenticationEntryPoint` interface to request credentials
    from the user. Typically, this involves redirecting the user to the login page.
    With `service` parameter that indicates where the `o.s.s.cas.web.CasAuthenticationEntryPoint`
    object, which is specifically designed for this purpose. The configuration that
    is included in the example application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `CasAuthenticationEntryPoint` object uses the `ServiceProperties` class
    to specify where to send the service ticket once the user is authenticated. CAS
    allows for the selective granting of access per user, per application, based on
    configuration. We’ll examine the particulars of this URL in a moment when we configure
    the servlet filter that is expected to process it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to update Spring Security to utilize the bean with the `casAuthentication`
    **EntryPoint** ID. Make the following update to our `SecurityConfig.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Enabling CAS ticket verification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Referring to the diagram that we saw earlier (*Figure 18**.1*), we can see that
    Spring Security is responsible for identifying an unauthenticated request and
    redirecting the user to CAS via the `FilterSecurityInterceptor` class. Adding
    the `CasAuthenticationEntryPoint` object has overridden the standard redirect
    to the login page functionality and provided the expected redirection from the
    application to the CAS server. Now, we need to configure things so that, once
    authenticated to CAS, the user is properly authenticated to the application.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember from [*Chapter 9*](B21757_09.xhtml#_idTextAnchor295), *Opening
    up to OAuth2*, **OAuth2** uses a similar redirection approach by redirecting unauthenticated
    users to the **OAuth2** provider for authentication, and then back to the application
    with verifiable credentials. CAS differs from **OAuth2**. In the **CAS** protocol,
    upon the user’s return to the application, the application is expected to call
    back the **CAS** server to explicitly validate that the credentials provided are
    valid and accurate. Compare this with **OAuth2**, which uses the presence of a
    date-based nonce and key-based signature so that the credentials passed by the
    **OAuth2** provider can be independently verified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of the `CasConfig.java` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to update Spring Security to utilize the bean with the `CasAuthenticationFilter`
    bean. Make the following update to our `SecurityConfig.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The last thing to do is to remove the existing `formLogin` `Spring Security`
    definition in the `SecurityFilterChain` Bean, as we will rely on **CAS** login
    forms for user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like that in `chapter18.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should be able to start both the `https://localhost:8443/`
    and select `casuser` and the password `Mellon`. Upon successful authentication,
    you will be redirected back to the **JBCP Calendar** application. Excellent job!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are experiencing issues, it is most likely due to **an improper SSL configuration**.
    Ensure that you have import the CAS SSL certificate inside the JRE keystore of
    your **JBCP** **Calendar** application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the basics of CAS configuration in the introduction,
    we will proceed to delve deeper into **Single Logout**.
  prefs: []
  type: TYPE_NORMAL
- en: Single Logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may notice that if you log out of the application, you get a logout confirmation
    page. However, if you click on a protected page, such as the **My Events** page,
    you are still authenticated. The problem is that the logout is only occurs locally.
    So, when you request another protected resource in the **JBCP Calendar** application,
    a login is requested from the **CAS** server. Since the user is still logged in
    to the **CAS** server, it immediately returns a service ticket and logs the user
    back into the **JBCP** **Calendar** application.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that if the user had signed in to other applications using the
    **CAS** server, they would still be authenticated to those applications, since
    our calendar application does not know anything about the other applications.
    Fortunately, **CAS** and Spring Security offer a solution to this problem. Just
    as we can request a login from the **CAS** server, we can also request a logout.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see a high-level diagram of how logging out works within **CAS**, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.2 – CAS Single Logout](img/B21757_18_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.2 – CAS Single Logout
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps explain how the **Single Logout** functionality works:'
  prefs: []
  type: TYPE_NORMAL
- en: The user requests to log out of the web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The web application then requests to log out of CAS by sending a redirect through
    the browser to the CAS server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS server recognizes the user and then sends a logout request to each CAS
    service that was authenticated. Note that these logout requests do not occur through
    the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS server indicates which user should log out by providing the original
    service ticket that was used to log the user in. The application is then responsible
    for ensuring that the user is logged out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS server displays the logout success page to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Single Logout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The configuration for a **Single Logout** is relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make the following updates to your `application.yml` file, adding the
    **CAS** logout URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first step is to specify a `logout-success-url` attribute to be the logout
    URL of the `SecurityConfig.java` file. This means that after we log out locally,
    we will automatically redirect the user to the **CAS** server’s logout page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we only have one application, this is all we need to make it appear as
    though a single logout is occurring. This is because we log out of our calendar
    application before redirecting to the `LogoutFilter` to `CasConfig.java`, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If there were multiple applications and the user logged out of another application,
    the `SingleSignoutFilter` object. Then we need to make Spring Security aware of
    the `singleLogoutFilter` object in our `SecurityConfig.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the **Single Logout** filter before the regular logout to ensure that
    it receives the logout events, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go ahead and start up the application and try logging out now. You will observe
    that you are logged out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, try logging back in and visiting the `https://localhost:9443/cas/logout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, try to visit the **JBCP Calendar** application. You will observe that you
    are unable to access the application without authenticating again. This demonstrates
    that the **Single Logout** functionality is operational.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like that in `chapter18.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the **Single Logout** implementation with **CAS**.
    Next, we will move on to discuss clustered environments.
  prefs: []
  type: TYPE_NORMAL
- en: Clustered environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the things that we failed to mention in our initial diagram of `HttpSession`
    as an in-memory map. This means that **Single Logout** will not work properly
    within a clustered environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.3 – CAS authentication in a clustered environment](img/B21757_18_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.3 – CAS authentication in a clustered environment
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following situation in the context of the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: The user logs in to **Cluster** **Member A**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cluster Member A** validates the service ticket.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then stores in memory, the mapping of the service ticket to the user’s session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user requests to log out from the **CAS** server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS** server sends a logout request to the **CAS** service, but **Cluster
    Member B** receives the logout request. It looks in its memory but does not find
    a session for **Service Ticket A**, because it only exists in **Cluster Member
    A**. This means the user will not be logged out successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy ticket authentication for stateless services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Centralizing our authentication using **CAS** seems to work rather well for
    web applications, but what if we want to call a web service using **CAS**? In
    order to support this, CAS has a notion of **proxy tickets** (**PT**). The following
    is a diagram of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.4 – CAS proxy ticket authentication](img/B21757_18_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.4 – CAS proxy ticket authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow is the same as standard **CAS** authentication until the following
    things take place:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Service Ticket** is validated when an additional parameter is included
    called the proxy ticket callback URL (**PGT URL**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS** server calls the **PGT URL** over **HTTPS** to validate that the
    **PGT URL** is what it claims to be. Like most of the processes in a CAS, this
    is done by performing an SSL handshake to the appropriate URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS** server submits the **Proxy Granting Ticket** (**PGT**) and the **Proxy
    Granting Ticket I Owe You** (**PGTIOU**) to the **PGT URL** over **HTTPS** to
    ensure that the tickets are submitted to the source they claim to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **PGT URL** receives the two tickets and must store an association of the
    **PGTIOU** to the **PGT**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS** server finally returns a response to the request in *step 1* that
    includes the username and the **PGTIOU**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS** service can look up the **PGT** using the **PGTIOU**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring proxy ticket authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how **PT** authentication works, we will update our current
    configuration to obtain a **PGT** by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add a reference to a `ProxyGrantingTicketStorage` implementation.
    Go ahead and add the following code to our `CasConfig.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ProxyGrantingTicketStorageImpl` implementation is an in-memory mapping
    of the **PGTIOU** to a **PGT**. Just as with logging out, this means we would
    have problems in a clustered environment using this implementation. Refer to the
    JA-SIG documentation to determine how to set this up in a clustered environment:
    [https://apereo.github.io/cas/7.0.x/high_availability/High-Availability-Guide.xhtml](https://apereo.github.io/cas/7.0.x/high_availability/High-Availability-Guide.xhtml).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to periodically clean `ProxyGrantingTicketStorage` by invoking
    its `cleanUp()` method. As you can see, Spring’s task abstraction makes this very
    simple. You may consider tweaking the configuration to clear the tickets in a
    separate thread pool that makes sense for your environment. For more information,
    refer to the *Task Execution and Scheduling* section of the Spring Framework Reference
    documentation at [https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml](https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to use `ProxyGrantingTicketStorage`, which we have just created.
    We just need to update the `ticketValidator` method to refer to our storage and
    to know the `CasConfig.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to update the `application.yml` file by adding the proxy callback
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last update we need to make is to our `CasAuthenticationFilter` object,
    to store the `ProxyGrantingTicketStorage` implementation when the `proxyReceptorUrl`
    attribute matches the `proxyCallbackUrl` attribute of the `Cas20ProxyTicketValidator`
    object to ensure that the `CasConfig.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have a **PGT**, what do we do with it? A service ticket is a single-use
    token. However, a **PGT** can be used to produce a **PT**. Let’s see how we can
    create a **PT** using a **PGT**.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the `application.yml` configuration file, we can observe that the `proxyCallBackUrl`
    attribute matches the absolute path of our context-relative `proxyReceptorUrl`
    attribute path. Since we are deploying our base application to `${service.base.url}`,
    the full path of our `proxyReceptor` URL will be `${service.base.url}/pgtUrl`.
  prefs: []
  type: TYPE_NORMAL
- en: Following this examination of the configuration on a **CAS** Server clustered
    environments, we will next delve into the detailed utilization of CAS proxy tickets.
  prefs: []
  type: TYPE_NORMAL
- en: Using proxy tickets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now use our `EchoController` class that we have included in the code
    for this chapter. You can see the relevant portions of it in the following code
    snippet. For additional details, refer to the example source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This controller is a contrived example that will obtain a `EchoController` object
    is actually making a RESTful call to the `MessagesController` object that is in
    the same application. This means that the calendar application makes a RESTful
    call to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and visit `https://localhost:8443/echo` to see it in action. The page
    looks a lot like the **CAS** login page (minus the CSS). This is because the controller
    attempts to echo our **My Events** page, and our application does not yet know
    how to authenticate a **PT**. This means it is redirected to the **CAS** login
    page. Let’s see how we can authenticate proxy tickets.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like that in `chapter18.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating proxy tickets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the following steps to learn about authenticating proxy tickets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to tell the `ServiceProperties` object that we want to authenticate
    all of the tickets and not just those submitted to the `filterProcessesUrl` attribute.
    Make the following updates to `CasConfig.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then need to update our `CasAuthenticationFilter` object for it to know
    that we want to authenticate all artifacts (that is, tickets) instead of only
    listening to a specific URL. We also need to use an `AuthenticationDetailsSource`
    interface that can dynamically provide the CAS service URL when validating proxy
    tickets on arbitrary URLs. This is important because when a CAS service asks whether
    a ticket is valid or not, it must also provide the CAS service URL that was used
    to create the ticket. Since proxy tickets can occur for any URL, we must be able
    to dynamically discover this URL. This is done by leveraging the `ServiceAuthenticationDetailsSource`
    object, which will provide the current URL from the HTTP request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need to ensure that we are using the `Cas30ProxyTicketValidator`
    object and not the `Cas30ServiceTicketValidator` implementation, and indicate
    which proxy tickets we will accept. We will configure our `Cas30ProxyTicketValidator`
    to accept a proxy ticket from any CAS service. In a production environment, you
    will want to consider restricting yourself to only those CAS services that are
    trusted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we want to provide a cache for our `CasAuthenticationProvider` object
    so that we do not need to hit the CAS service for every call made to our service.
    To do this, we need to configure a `StatelessTicketCache` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget the `@EnableCaching` in the `CasConfig.java`, so that caching can
    automatically enabled by Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have suspected, the Spring cache can rely on external implementations
    including `EhCache`. Go ahead and start the application back up and visit `https://localhost:8443/echo`
    again. This time, you should see a response to calling our **My** **Events** page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.5 – Authenticating proxy tickets response](img/B21757_18_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.5 – Authenticating proxy tickets response
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like that in `chapter18.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: After using proxy tickets, we’ll next explore the process of customizing the
    **CAS** server.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the CAS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the changes in this section will be made to the **CAS** server and not
    the calendar application. This section is only meant to be an introduction to
    configuring the **CAS** server, as a detailed setup is certainly beyond the scope
    of this book. Just as with the changes made to the calendar application, we encourage
    you to follow along with the changes in this chapter. For more information, you
    can refer to the **CAS Aperero** documentation: https://apereo.github.io/cas.'
  prefs: []
  type: TYPE_NORMAL
- en: CAS WAR overlay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preferred way to customize `cas-server-webapp`, as a dependency, and then
    provide additional files that will be merged with the existing **WAR overlay**.
  prefs: []
  type: TYPE_NORMAL
- en: How does the CAS internal authentication work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we jump into CAS configuration, we’ll briefly illustrate the standard
    behavior of CAS authentication processing. The following diagram should help you
    follow the configuration steps required to allow CAS to talk to our embedded LDAP
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.6 – CAS internal authentication flow](img/B21757_18_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.6 – CAS internal authentication flow
  prefs: []
  type: TYPE_NORMAL
- en: While the preceding diagram describes the internal flow of authentication within
    the **CAS** server itself, it is likely that if you are implementing an integration
    between Spring Security and **CAS**, you will need to adjust the configuration
    of the **CAS** server as well. It’s important, therefore, that you understand
    how **CAS** authentication works at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: The `org.apereo.cas.authentication.AuthenticationManager` interface (not to
    be confused with the Spring Security interface of the same name) is responsible
    for authenticating the user based on the provided credentials. In Spring Security,
    the actual processing of the credentials is delegated to one (or more) processing
    class implementing the `org.apereo.cas.authentication.AuthenticationHandler` interface.
    We recognize that the analogous interface in `Spring Security` would be `AuthenticationProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: While not a full review of the behind-the-scenes functionality of the **CAS**
    server, this should help you understand the configuration steps in the next several
    exercises. We encourage you to read the source code for **CAS** and consult the
    web-based documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CAS to connect to our embedded LDAP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CAS** verifies a username/password by authenticating against an LDAP directory,
    such as Active Directory or OpenLDAP. There are various directory architectures,
    and we offer configuration options for four common scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that **CAS** automatically generates the necessary components
    internally based on the specified settings. If you want to authenticate against
    multiple LDAP servers, you can increment the index and specify the settings for
    the next LDAP server.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, please be aware that attributes obtained during **LDAP** authentication
    are combined with attributes from other attribute repository sources, if applicable.
    Attributes obtained directly through **LDAP** authentication take precedence over
    all other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the available settings and properties in the CAS documentation
    ([https://apereo.github.io/cas/](https://apereo.github.io/cas/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps to configure an embedded LDAP server
    with **CAS**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we update the `build.gradle` dependencies of the `chapter18.00-cas-server`
    project. We enable the CAS LDAP support and add the `spring-security` built-in
    support for the embedded LDAP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need to add the following sections to our `application.yml` file with
    the connection parameters for the embedded LDAP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this exercise, we will be using an LDIF file created for this book, intended
    to capture many of the common configuration scenarios with LDAP and Spring Security
    (just as we did in [*Chapter 6*](B21757_06.xhtml#_idTextAnchor180), *LDAP Directory
    Services*). Copy the provided LDIF file to the following project location: `src/main/resources/ldif/calendar.ldif`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we need to configure the `CasOverlayOverrideConfiguration.java` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like that in `chapter18.05-cas-server` and `chapter18.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we’ve configured basic `admin1@example.com/admin` or `user1@example.com/user1`.
    Go ahead and try it to check whether it works. If it does not work, try checking
    the logs and comparing your configuration with the example configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Following the customization of the `UserDetails` object from a **CAS** assertion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the UserDetails object from a CAS assertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we have been authenticating with `InMemoryUserDetailsManager`
    object. However, we can create the `UserDetails` object from the **CAS** assertion
    just as we did with **OAuth2**. The first step is to configure the **CAS** server
    to return the additional attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Returning LDAP attributes in the CAS response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that **CAS** can return the username in the **CAS** response, but it
    can also return arbitrary attributes in the **CAS** response. Let’s see how we
    can update the CAS server to return additional attributes. Again, all the changes
    in this section are in the *CAS server and not in the* *calendar application*.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping LDAP attributes to CAS attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step requires us to map `GrantedAuthority`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll add another bit of configuration to the CAS `application.yml` file. This
    new bit of configuration is required to instruct `Principal` object to the `principalAttributeList`,
    which will ultimately be serialized as part of ticket validation. The configuration
    should be declared as follows in the `chapter18.06-cas-server` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The functionality behind the scenes here is confusing—essentially, the purpose
    of this class is to map `org.apereo.cas.authentication.principal.Principal` back
    to the LDAP directory. The provided `baseDN` Java bean property is searched using
    the LDAP query (`uid=user1@example.com`), and attributes are read from the matching
    entry. The attributes are mapped back to `org.apereo.cas.authentication.principal.Principal`
    using the key/value pairs in the `principalAttributeList` property. We recognize
    that LDAP’s `cn` and `sn` attributes are mapped to meaningful names, and the `description`
    attribute is mapped to the role that will be used for determining the authorization
    of our user.
  prefs: []
  type: TYPE_NORMAL
- en: Last, we would love to set up the same type of query in `Principal` to a full
    LDAP-distinguished name, and then use that `uniqueMember` attribute of a `groupOfUniqueNames`
    entry. Unfortunately, the CAS LDAP code doesn’t have this flexibility yet, leading
    to the conclusion that more advanced **LDAP** mapping will require extensions
    to base classes in **CAS**.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring a UserDetails from CAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we first set up `UserDetailsByNameServiceWrapper`, which simply translated
    the username presented to `UserDetails` object from `UserDetailsService`, which
    we had referenced. Now that `LdapUserDetailsService` as we discussed at the tail
    end of [*Chapter 6*](B21757_06.xhtml#_idTextAnchor180), *LDAP Directory Services*,
    and things will work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the next section, we will switch back to modifying the *calendar
    application and not the* *CAS server*.
  prefs: []
  type: TYPE_NORMAL
- en: The GrantedAuthorityFromAssertionAttributesUser object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have modified the `UserDetails` from the `AuthenticationUserDetailsService`
    implementation to the
  prefs: []
  type: TYPE_NORMAL
- en: '`o.s.s.cas.userdetails.GrantedAuthorityFromAssertionAttributesUser` **DetailsService**
    object, whose job it is to read the `GrantedAuthority` object for the user. Let’s
    assume that there is an attribute-entitled role that will be returned with the
    assertion. We simply configure a new `authenticationUserDetailsService` bean (be
    sure to replace the previously defined `authenticationUserDetailsService` bean)
    in the `CaseConfig.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like that in `chapter18.06-cas-server` and `chapter18.06-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: How is attribute retrieval useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that **CAS** provides a layer of abstraction for our application, removing
    the ability for our application to directly access the user repository, and instead
    forcing all such access to be performed through **CAS** as a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely powerful! It means that our application no longer cares what
    kind of repository the users are stored in, nor does it have to worry about the
    details of how to access them. This confirms that authentication with **CAS**
    is sufficient to prove that a user should be able to access our application. For
    system administrators, this means that should an LDAP server be renamed, moved,
    or otherwise adjusted, they only need to reconfigure it in a single location—**CAS**.
    Centralizing access through **CAS** allows for a high level of flexibility and
    adaptability in the overall security architecture of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Now all applications authenticated through **CAS** have the same view of a user
    and can consistently display information across any **CAS**-enabled environment.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that, once authenticated, Spring Security does not require the `Authentication`
    object may become stale over time, and possibly out of sync with the source **CAS**
    server. Take care to set session timeouts appropriately to avoid this potential
    issue!
  prefs: []
  type: TYPE_NORMAL
- en: Additional CAS capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CAS** offers additional advanced configuration capabilities outside of those
    that are exposed through the Spring Security **CAS** wrappers. Some of these include
    the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing transparent SSO for users who are accessing multiple **CAS**- secured
    applications within a configurable time window on the **CAS** server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications can force users to authenticate to `renew` property to `true` on
    `TicketValidator`; you may want to conditionally set this property in some custom
    code in the event that the user attempts to access a highly secured area of the
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **RESTful API** for obtaining service tickets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Aperero CAS server can also act as an **OAuth2** server. If you think about
    it, this makes sense, since **CAS** is very similar to **OAuth2**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing **OAuth** support for the **CAS** server so that it can obtain access
    tokens to a delegate OAuth provider (that is, Google), or so the CAS server can
    be the OAuth server itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’d encourage you to explore the full capabilities of the CAS client and server
    as well as ask any questions to the helpful folks in the **CAS Aperero** community
    forums!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the **CAS** SSO portal and how it can be integrated
    with Spring Security, and we also covered the **CAS** architecture and communication
    paths between actors in a **CAS**-enabled environment. We also saw the benefits
    of **CAS**-enabled applications for application developers and system administrators.
    We also learned about configuring the **JBCP Calendar** application to interact
    with a basic **CAS** installation. We also covered the use of **CAS**’s **Single**
    **Logout** support.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how proxy ticket authentication works and how to leverage it to
    authenticate stateless services.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the tasks of updating **CAS** to interact with **LDAP** and
    sharing **LDAP** data with our **CAS**-enabled application. We even learned about
    implementing attribute exchange with the industry-standard **SAML** protocol.
  prefs: []
  type: TYPE_NORMAL
- en: We hope this chapter was an interesting introduction to the world of SSO. There
    are many other SSO systems on the market, mostly commercial, but **CAS** is one
    of the leaders of the open source SSO world and offers an excellent platform to
    build out **SSO** capability in any organization.
  prefs: []
  type: TYPE_NORMAL
- en: For the last chapter, we’ll learn more on building GraalVM native images.
  prefs: []
  type: TYPE_NORMAL
