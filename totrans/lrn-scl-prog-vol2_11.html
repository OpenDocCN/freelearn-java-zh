<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to Akka</h1>
                
            
            <article>
                
<div class="packt_quote">"Technology is nothing. What's important is that you have faith in people, that they're good and smart, and if you give them tools, they'll do wonderful things with them."</div>
<div class="packt_quote1">- Steve Jobs</div>
<p class="calibre2">As developers, we are used to facing programming problems and solving them using abstractions, programming models, or some design patterns. These programming models tend to make ours and consumer's lives easier. This chapter is about learning one such programming model that solves more than one problem. We'll understand and work with Akka, which is based on <em class="calibre18">Actor models</em>. We can think of Akka libraries (well mostly) as an open source set of libraries that help you write concurrent, fault tolerant, and distributed applications. We'll talk about what you might expect from this toolkit. As we go through the chapter, we'll try understanding the actor model and how these actors work together, as well as how the actor mechanism is different from any other concurrency mechanism.</p>
<p class="calibre2">Going through all the Akka libraries is outside of the scope of this chapter as well as the book, hence we'll focus on understanding the actor system, which is the basis for any other library available within the Akka toolkit. This will enable us to use them when needed. In this chapter, we'll be going through the following:</p>
<ul class="calibre7">
<li class="calibre8">Why do we care about Akka<em class="calibre18">?</em></li>
<li class="calibre8">What's up with the Actor model?</li>
<li class="calibre8">Actors in practice</li>
<li class="calibre8">Supervising fault in our Actor<em class="calibre18">s</em></li>
<li class="calibre8">Testing Actors</li>
</ul>
<p class="calibre2">So why do we care about another programming model? Let's find out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why do we care about Akka?</h1>
                
            
            <article>
                
<p class="calibre2">With a large amount of data all around us, our computer/processing systems are striving for performance. With multicore architecture and distributed computing, we are achieving high performance with acceptable availability of services. But this cannot be taken for granted; we have come to a point where we already have mechanisms to deal with problems that arise due to either incapability of systems or the programming models we are using.</p>
<p class="calibre2">Due to the advent of multicore architecture, our systems are capable of processing a large amount of data with high performance. But there is a fault in our programming models, which we use to mutate states, and at the same time use several threads to vary the states present in our programs. This has given us a reason to think.</p>
<p class="calibre2">Two or more threads trying to process a particular shared state might cause a <em class="calibre18">deadlock</em> (more on this in <a target="_blank" href="part0240.html#74S700-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 13</a>, <em class="calibre18">Concurrent Programming in Scala</em>, where we discuss concurrency and threads in more detail) and your program may not even complete. But still, we are discussing the problem; nowhere do we see the solution. One way in which we can think of dealing with threads and problems is using some sort of locking mechanism so that two separate threads cannot access the same instance/state at the same time.</p>
<p class="calibre2">But think of it this way, by introducing locks, we are making our operating systems interrupt/suspend the thread and restore it later to perform the same task. It's expecting more from your computer's CPU.</p>
<p class="calibre2">It means that without locks we are facing problems with states of our instances, and now with locks in place, the program's performance takes a hit. Now picture a multithreaded distributed environment; life's worse there.</p>
<p class="calibre2">Also, the way we handle failures in multithreaded environments is not pleasing. Hence, what we need for handling these is a different mechanism altogether. In the case of Akka<em class="calibre18">,</em> we let entities interact via messages. We create entities in terms of Actors that communicate by passing messages to each other. You may compare this kind of communication to network communication where we depend on HTTP request-responses to perform the intended operation. Similarly, by encapsulating the state within Actor instances, we tend to pass immutable instances to another actor to perform some logic. That receiving actor, after applying/performing some logic, returns back a response. That's how we can build our systems.</p>
<p class="calibre2">Actor models have proven to be a highly effective solution. Akka provides this actor model and enforces a tree-like structure for actors. Some points to note down about actors:</p>
<ul class="calibre7">
<li class="calibre8">By communicating via messages, we omit the possibility of corrupting the state for a particular instance</li>
<li class="calibre8">Because one actor can process one message at a time, we avoid the deadlock situation</li>
<li class="calibre8">With a hierarchy in place, it's easier to form a domain logic</li>
<li class="calibre8">The parent-child relationship between two actors makes it possible for us to handle faulty behavior; in Akka terminology, we call it a <em class="calibre18">supervision strategy</em></li>
</ul>
<p class="calibre2">We'll go through the way <em class="calibre18">actors</em> communicate and how messages are ordered/stored and executed. First, let's try to understand the <em class="calibre18">Actor Model</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What's up with the Actor Model?</h1>
                
            
            <article>
                
<p class="calibre2">From our discussion, it's clear that we have some entities that act on receipt of some messages, or let's say requests. We call them Actors<em class="calibre18">.</em> To solve some domain-specific problems, we might want to have more than one Actor<em class="calibre18">.</em> Think of a basic scenario of e-commerce checkout flow. There's more than one area of concern. The following diagram represents the basic intended flow:</p>
<div class="cdpaligncenter"><img src="../images/00040.jpeg" class="calibre46"/></div>
<p class="calibre2">By taking a look at the diagram, it's clear that we have few entities, and these entities are going to take care of specific concerns. We have named these entities based on their area of concern:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">CheckoutActor</strong> might have the responsibility to fetch details from the cart and show the respective information.</li>
<li class="calibre8">Additionally, you might want to apply some coupon code or offer. Our system has to validate that coupon or offer code and based on that we might want to modify order details. For this particular process, we have <strong class="calibre1">HandleOffersActor</strong><em class="calibre18">.</em></li>
<li class="calibre8"><strong class="calibre1">ShippingActor</strong> has the responsibility of fetching user-specific information such as address, and based on that we can calculate the estimated time for shipping. It's important to note that <strong class="calibre1">ShippingActor</strong> is not restricted to process the whole logic within, and can call another child actor named <strong class="calibre1">UserInfoActor</strong><em class="calibre18">,</em> which does nothing but to fetch a user's information. Another point to note is that the operation of fetching user information is so general that this Actor might be useful outside this particular hierarchy.</li>
<li class="calibre8">After shipping details are in place, we might want to redirect a user to a payment page, where we can perform payment-specific logic. For that, we have <strong class="calibre1">PaymentsActor</strong><em class="calibre18">.</em></li>
<li class="calibre8">Finally, based on the payment's success or failure, we might want to handle orders. For example, upon successful payment, we want to proceed to ordering, and in case of failure we might want to send an email to the user stating that they process payment again! For this purpose, we have <strong class="calibre1">HandleNewOrdersActor</strong><em class="calibre18">.</em></li>
</ul>
<p class="calibre2">In the whole scenario, we can see that the whole flow makes a hierarchy of actors. Let's say <strong class="calibre1">ShippingActor</strong> fails to provide user information from the database, due to network/connection issues. Now it's up to us as to how we want to deal with that. Similarly, upon <strong class="calibre1">PaymentsActor</strong> failure, it's up to the business to make a decision about what to do next. It could be to proceed and take orders with payment status pending and payment method on delivery or to ask the user to retry. So, handling such scenarios is easier when you have your entities in a hierarchical manner, performing logic.</p>
<p class="calibre2">In this simple scenario, we understood that these actors form a hierarchy, or let's call it a group, and live within a system; in Akka terminology, we call it an <strong class="calibre1">ActorSystem</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding the Actor system</h1>
                
            
            <article>
                
<p class="calibre2">Akka documentation simply explains an <strong class="calibre1">ActorSystem</strong> as a heavyweight structure that will allocate 1 to N threads, and we should create one per <em class="calibre18">logical</em> application. Once we create an actor system, we get the license to create actors under that system. We'll take a look at how we can create Actors in the next sections<em class="calibre18">.</em></p>
<p class="calibre2">When we create actors as part of a system, these actors share the same configuration (such as <em class="calibre18">dispatchers, paths,</em> and <em class="calibre18">addresses)</em> as the Actor system.</p>
<p class="calibre2">Within an Actor system, there's a <strong class="calibre1">root guardian</strong> Actor; this serves as a parent actor to all actors residing within an actor system, internal actors, as well actors that we create. So, as expected, this is the last actor to be stopped when the system terminates.</p>
<p class="calibre2">The reason why Akka provides these guardian actors is to supervise the first-level actors we create, so for user created actors too, we have a specific <strong class="calibre1">user guardian</strong>. Similarly, for system provided actors, Akka has system guardian.</p>
<p class="calibre2">Take a look at the following diagram to understand the hierarchy of guardian actors in the Akka system:</p>
<div class="cdpaligncenter"><img src="../images/00041.jpeg" class="calibre47"/></div>
<p class="calibre2">In the previous diagram, we can see there's a path representation of each actor specified:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">root guardian</strong>: <kbd class="calibre11">/</kbd></li>
<li class="calibre8"><strong class="calibre1">user guardian</strong>: <kbd class="calibre11">/user</kbd></li>
<li class="calibre8"><strong class="calibre1">system guardian</strong>: <kbd class="calibre11">/system</kbd></li>
</ul>
<p class="calibre2">So, whenever we create an actor within an Actor system, we tend to create a first-level. Hence, in the example shown in the diagram, we can see that the actor's path is appended to <kbd class="calibre11">/user</kbd><em class="calibre18">,</em> in our case it is the <kbd class="calibre11">SimpleActor</kbd><em class="calibre18">,</em> hence the path formed is <kbd class="calibre11">/user/simpleActor</kbd><em class="calibre18">.</em> With an Actor system defined as <kbd class="calibre11">system</kbd><em class="calibre18">,</em> for creating these <em class="calibre18">first-level</em> (more on this in the next few sections) actors, we use:</p>
<pre class="calibre19">val system = ActorSystem("SimpleActorSystem") 
system.actorOf(Props[SimpleActor], "simple-actor") </pre>
<p class="calibre2">We'll try out creating an actor ourselves in subsequent sections, but for now it's worth nothing the way we called an <kbd class="calibre11">actorOf</kbd> method on <kbd class="calibre11">system</kbd> to create a <em class="calibre18">first-level</em> Actor. From here, we can create child Actors for our first-level Actor. And for that purpose, we use <kbd class="calibre11">context</kbd> instead of a <kbd class="calibre11">system</kbd> instance. It'll look as follows:</p>
<pre class="calibre19">val anotherSimpleActor = context.actorOf(Props[AnotherSimplActor], "another-simple-actor") </pre>
<p class="calibre2">Here, by using <kbd class="calibre11">context</kbd> instead of <kbd class="calibre11">system</kbd><em class="calibre18">,</em> we are specifying that the actor that we want to create is going to be in the context of the current Actor, making it a child actor. It's important to notice that this call to the following definition can only be made from within an Actor. So, with this method call, we get a child Actor for our <kbd class="calibre11">simpleActor</kbd>:</p>
<pre class="calibre19">context.actorOf(Props[AnotherSimpleActor], "another-simple-actor") </pre>
<p class="calibre2"><span> Assuming that the call was made from <kbd class="calibre11">SimpleActor</kbd> and <kbd class="calibre11">SimpleActor</kbd> is the first-level actor, our </span><kbd class="calibre11">anotherSimpleActor</kbd> <span>path may look like this:</span></p>
<pre class="calibre19">akka://SimpleActorSystem/user/simple-actor/another-simple-actor </pre>
<p class="calibre2">Now that we have seen the child actor path, it's obvious that path for our <kbd class="calibre11">simple-actor</kbd> will be:</p>
<pre class="calibre19">akka://SimpleActorSystem/user/simple-actor </pre>
<p class="calibre2">Also, a few points worth noting are the usage of <kbd class="calibre11">Props</kbd> and the return type of the <kbd class="calibre11">actorOf</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Props</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre11">Props</kbd> can be seen as a configuration object for <kbd class="calibre11">ActorRef</kbd><em class="calibre18">.</em> We can create instances of the props configuration with some configuration. The following is an example of that:</p>
<pre class="calibre19">val props = Props[SimpleActor]() 
  .withDispatcher("some-simple-dispatcher") 
 
val simpleActor: ActorRef = system.actorOf(props, "simple-actor") </pre>
<p class="calibre2">One important thing to know about the <kbd class="calibre11">Props</kbd> object is that it is immutable and hence thread-safe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Actor references and paths</h1>
                
            
            <article>
                
<p class="calibre2">When we create an Actor<em class="calibre18">,</em> what we get in response is an <kbd class="calibre11">ActorRef</kbd><em class="calibre18">.</em> This is a reference to our created Actor<em class="calibre18">.</em> Why we might need an <kbd class="calibre11">ActorRef</kbd> is to pass throughout the system to other actors as a reference. These references are used for message passing. Every actor that we create has a reference to itself through self.</p>
<p class="calibre2">From within an actor, it's possible to obtain an <em class="calibre18">actor reference</em> of the calling Actor via a method named <kbd class="calibre11">sender()</kbd><em class="calibre18">.</em></p>
<p class="calibre2"><span>We can also giv</span><span>e names to actor references. In our case, we named our</span> <kbd class="calibre11">SimpleActor</kbd> <span>reference</span> <kbd class="calibre11">simple-actor<span>:</span></kbd></p>
<pre class="calibre19">val simpleActor: ActorRef = system.actorOf(props, "simple-actor")</pre>
<p class="calibre2">We also know that these Actors are created in a hierarchical fashion and we can give unique names to <em class="calibre18">actor instances.</em> Hence, these names together make a path for each Actor. The path is unique for each Actor. Our <kbd class="calibre11">SimpleActor</kbd> path might look like this:</p>
<div class="cdpaligncenter"><img src="../images/00042.jpeg" class="calibre48"/></div>
<p class="calibre2">We can see that due to the hierarchy, we have paths for different actors, because actors must have unique names. We can also see that regardless of your actor being created on a remote network, its path is going to have the same structure along with host and port.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Selecting existing actorRefs via actorSelection</h1>
                
            
            <article>
                
<p class="calibre2">Due to every actor having its own unique ID, we can refer to a particular actor via its path using the <kbd class="calibre11">actorSelection</kbd> method. We can call the <kbd class="calibre11">actorSelection</kbd> method on <kbd class="calibre11">system</kbd> or <kbd class="calibre11">context</kbd> and get the <kbd class="calibre11">ActorRef</kbd><em class="calibre18">.</em></p>
<p class="calibre2">When we call <kbd class="calibre11">actorSelection</kbd> on <kbd class="calibre11">system</kbd><em class="calibre18">,</em> we need to pass the absolute Actor path starting from root, whereas while calling the same on <kbd class="calibre11">context</kbd><em class="calibre18">,</em> we can pass the path relative to the current Actor.</p>
<p class="calibre2">Assuming the current Actor (first-level Actor) has a <kbd class="calibre11">SiblingActor</kbd><em class="calibre18">,</em> at the same level, we may refer to the sibling Actor's actor reference as:</p>
<pre class="calibre19">context.actorSelection("../siblingActor") 
 
context.actorSelection("/user/siblingActor") </pre>
<p class="calibre2">In these two approaches, the first one used to represent the parent Actor<em class="calibre18">.</em> The other approach directly referred to the Actor's path. With this, we were able to get the actor references, but it's discouraged because we might not want to write actor paths explicitly. We can leverage use of <kbd class="calibre11">actorSelection</kbd><em class="calibre18">, </em>when suppose we want to make use of a wildcard (*), that is, to send messages to all the actors below a certain (*) level in hierarchy. The following diagram will clear what we mean by that:</p>
<div class="cdpaligncenter"><img src="../images/00043.jpeg" class="calibre49"/></div>
<p class="calibre2">Here, in previous diagram, by providing the following code:</p>
<pre class="calibre19">context.actorSelection("akka://someActorSystem/user/*/LogicAActor")</pre>
<p class="calibre2">We can obtain the reference, that point to all the <kbd class="calibre11">LogicAActor</kbd> parameters in previously mentioned hierarchy. Also it's worth knowing that a call to the <kbd class="calibre11">actorOf</kbd> method creates an actor on the context or system, depending upon which it's invoked. Whereas a call to <kbd class="calibre11">actorSelection</kbd> does not create any new actors, it points to <kbd class="calibre11">actorpath</kbd> which we pass, and doesn't ensure actor's existence there.</p>
<p class="calibre2">Now that we have gone through simple entities in an Actor system, let's try and understand how the Actor life cycle works and what approaches we might want to choose to kill an actor instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How the Actor life cycle works</h1>
                
            
            <article>
                
<p class="calibre2">When we make a call to method <kbd class="calibre11">actorOf</kbd><em class="calibre18">,</em> what we get in return is an <kbd class="calibre11">ActorRef</kbd><em class="calibre18"> </em>that in turn also possesses a particular path where we've created the Actor<em class="calibre18">.</em> With this call, we know exactly there's an Actor instance created, been assigned a unique ID, and hook methods are called. There's this method named <kbd class="calibre11">preStart()</kbd> that gets called as the very first action, after a new Actor is created.</p>
<p class="calibre2">A few points to note when a new Actor is created:</p>
<ul class="calibre7">
<li class="calibre8">A new Actor path is reserved for the Actor</li>
<li class="calibre8">A unique ID is assigned to the Actor</li>
<li class="calibre8">After the instance is created, the <kbd class="calibre11">preStart()</kbd> method is called:</li>
</ul>
<div class="cdpaligncenter"><img src="../images/00044.jpeg" class="calibre50"/></div>
<p class="calibre2">When an Actor is restarted:</p>
<ol class="calibre13">
<li value="1" class="calibre8">The <kbd class="calibre11">preRestart()</kbd> is called on the instance.</li>
<li value="2" class="calibre8">New instance is created, replaces the old instance.</li>
<li value="3" class="calibre8">The <kbd class="calibre11">postRestart()</kbd> method is called.</li>
</ol>
<p class="calibre2">When an Actor is stopped:</p>
<ol class="calibre13">
<li value="1" class="calibre8">The <kbd class="calibre11">postStop()</kbd> method is called on the instance.</li>
<li value="2" class="calibre8">Terminated message is sent to watchers.</li>
<li value="3" class="calibre8">Actor path is allowed to be used again.</li>
</ol>
<p class="calibre2">The previous diagram illustrates this whole cycle. An important point to note is that we get these hook methods in the form of <kbd class="calibre11">preStart</kbd>, <kbd class="calibre11">preRestart</kbd>, <kbd class="calibre11">postStop</kbd>, and <kbd class="calibre11">postRestart</kbd>. Using these methods, we can define some logic as required.</p>
<p class="calibre2">So, now that we're aware of the actor model and have also discussed that Actors communicate via messages, let's practice them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Hello world in Akka</h1>
                
            
            <article>
                
<p class="calibre2">For writing our first Akka actor, we need to add the <kbd class="calibre11">akka-actor</kbd> library dependency. For dependency management we'll be using SBT and, as we know, we'll be defining these library dependencies in our <kbd class="calibre11">build.sbt</kbd> file. To do this, we need to have SBT installed on our system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up the environment</h1>
                
            
            <article>
                
<p class="calibre2">To get started with a simple Akka project, we can simply follow these steps:</p>
<ol class="calibre13">
<li value="1" class="calibre8">Go to Lightbend's <strong class="calibre1">TECH HUB</strong> (<a href="https://developer.lightbend.com" target="_blank" class="calibre10">https://developer.lightbend.com</a>) and click on <span>START A PROJECT</span>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00045.jpeg" class="calibre51"/></div>
<ol start="2" class="calibre13">
<li value="2" class="calibre8">Search for <strong class="calibre1">Akka Quickstart</strong> Scala under Akka projects:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00046.jpeg" class="calibre52"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre8">Click on <span>CREATE A PROJECT FOR ME!</span>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00047.jpeg" class="calibre53"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre8">Extract the downloaded ZIP (compressed) file.</li>
</ol>
<p class="calibre2">We can open the extracted folder in <strong class="calibre1">IntelliJ IDEA</strong> IDE:</p>
<ol class="calibre13">
<li value="1" class="calibre8">Open IntelliJ IDE.</li>
<li value="2" class="calibre8">Click on <span>File</span> | <span>New</span> | <span>Project from Existing Sources...</span>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00048.jpeg" class="calibre54"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre8">Choose the <kbd class="calibre11">build.sbt</kbd> from the project (<kbd class="calibre11">akka-quickstart-scala</kbd>) we've just extracted:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00049.jpeg" class="calibre55"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre8">And you get the project open in the IntelliJ window:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00050.jpeg" class="calibre56"/></div>
<p class="calibre2">This is one way of starting with an Akka project. This project has already defined all the <kbd class="calibre11">akka-actors</kbd> specific dependencies. We don't have to define them on their own. But we would like to start by taking the first step ourselves hence let's start with a bootstrapped <kbd class="calibre11">sbt-scala</kbd> project and define library dependencies.</p>
<p class="calibre2">We can take some steps to do that:</p>
<ol class="calibre13">
<li value="1" class="calibre8">Open your favorite command line (Command prompt in Windows/Terminal in Linux and macOS), and go to the desired directory where you want to locate the project.</li>
<li value="2" class="calibre8"><span>Give the command</span> <kbd class="calibre11">sbt new sbt/scala-seed.g8</kbd><span>:</span></li>
</ol>
<div class="cdpaligncenter"><img src="../images/00051.jpeg" class="calibre57"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre8">Command prompt will ask for the name of the project. Give a name to it:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00052.jpeg" class="calibre58"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre8">The command will generate the Scala seed project for us. We can follow <em class="calibre18">Steps 1</em> to <em class="calibre18">3</em> to open the <strong class="calibre1">Acala</strong> seed project in IntelliJ IDE.</li>
<li value="5" class="calibre8">Open the <kbd class="calibre11">build.sbt</kbd> file. The file might look like this:</li>
</ol>
<pre class="calibre19">    import Dependencies._ 
 
    lazy val root = (project in file(".")). 
      settings( 
        inThisBuild(List( 
          organization := "com.example", 
          scalaVersion := "2.12.3", 
          version      := "0.1.0-SNAPSHOT" 
        )), 
        name := "Hello", 
        libraryDependencies += scalaTest % Test 
      ) </pre>
<p class="calibre2">This file specifies that we have a root project in the current directory named <kbd class="calibre11">Hello</kbd><em class="calibre18">.</em> Along with that, we have given some version-specific information, and the final line specifies that we currently have one <kbd class="calibre11">libraryDependency</kbd><em class="calibre18">,</em> that is, <kbd class="calibre11">scala-test</kbd><em class="calibre18">.</em> This value comes from the <kbd class="calibre11">Dependencies.scala</kbd> file.</p>
<p class="calibre2">We'll define <kbd class="calibre11">akka-actors</kbd> specific dependencies in this <kbd class="calibre11">build.sbt</kbd> file:</p>
<pre class="calibre19">libraryDependencies ++= Seq( 
  "com.typesafe.akka" %% "akka-actor" % "2.5.8", 
  "com.typesafe.akka" %% "akka-testkit" % "2.5.8", 
  "org.scalatest" %% "scalatest" % "3.0.1" % "test" 
  ) </pre>
<p class="calibre2">Here in the preceding code snippet, we've specified three dependencies; the first one is an <kbd class="calibre11">akka-actor</kbd> specific dependency. The second is for testing Akka Actors. The last one is specific to Scala testing.</p>
<p class="calibre2">With this, we would use the <kbd class="calibre11">sbt update</kbd> command for updating libraries, and give a command in the current project directory using <kbd class="calibre11">cmd/terminal</kbd><em class="calibre18">.</em></p>
<p class="calibre2">With these steps, we're ready to write our first Akka actor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Writing our first Actor</h1>
                
            
            <article>
                
<p class="calibre2">Writing an Actor is as simple as writing a class that extends the <kbd class="calibre11">akka.actor.Actor</kbd> class. And we know that Actors respond to messages, so to identify messages, we have a method named <kbd class="calibre11">receive</kbd> that we have to define for each Actor we write. Let's write our <kbd class="calibre11">SimpleActor</kbd>:</p>
<p class="calibre2"> </p>
<pre class="calibre19">import akka.actor.Actor 
 
class SimpleActor extends Actor { 
    
  override def receive = Actor.emptyBehavior 
 
} </pre>
<p class="calibre2">So, we wrote the <kbd class="calibre11">SimpleActor</kbd> with some empty behavior defined in the <kbd class="calibre11">receive</kbd> method. But here we've just wrote our Actor; we have to instantiate the Actor as part of an Actor system<em class="calibre18">.</em> After instantiating, we might also want to run our application to see the behavior, hence, let's write the entry point to our application and instantiate an Actor system:</p>
<p class="calibre2"> </p>
<pre class="calibre19">import akka.actor.ActorSystem 
 
object AkkaStarter extends App { 
 
  val simpleActorSystem = ActorSystem("SimpleActorSystem") 
 
} </pre>
<p class="calibre2">This statement gives us an instance for an Actor system with the name <kbd class="calibre11">SimpleActorSystem</kbd>. Now, we want to create an instance of our <kbd class="calibre11">SimpleActor</kbd> as a top (first) level actor, hence we'll use the <kbd class="calibre11">simpleActorSystem.actorOf</kbd> method available:</p>
<p class="calibre2"> </p>
<pre class="calibre19">import akka.actor.{Actor, ActorSystem, Props} 
 
class SimpleActor extends Actor { 
  override def receive = Actor.emptyBehavior 
} 
 
object SimpleActor { 
  val props = Props[SimpleActor] 
} 
 
object AkkaStarter extends App { 
 
  val simpleActorSystem = ActorSystem("SimpleActorSystem") 
 
  val simpleActor = simpleActorSystem.actorOf(SimpleActor.props) 
} </pre>
<p class="calibre2">Right now we have an Actor system available, and we have created an Actor instance. It is to be noted that by convention, we've created a companion object for our Actor class and defined its <kbd class="calibre11">props</kbd> value in it. We can also name our actor by giving an extra argument as a string:</p>
<pre class="calibre19">val simpleActor = simpleActorSystem.actorOf(SimpleActor.props, "simple-actor") </pre>
<p class="calibre2">This line gives our actor a <kbd class="calibre11">namesimple-actor</kbd><em class="calibre18">.</em> For now, the behavior defined for our Actor is empty<em class="calibre18">.</em> We would like to define a <kbd class="calibre11">receive</kbd> method for our actor. Let's think, what's the simplest thing our actor can do? It may be to call any public finance API to give us stock information or to call any API to perform currency conversion; that's up to us. For this example scenario, we'll call our <kbd class="calibre11">football.csv</kbd> file to fetch and show information to the user. Lets see how this can work using actors.</p>
<p class="calibre2">First, let's define some utility methods we might need to perform, parsing from string response to <kbd class="calibre11">Players</kbd> data. We have this case class for <kbd class="calibre11">Players</kbd>:</p>
<pre class="calibre19">case class Player(name: String, nationality: String, age:String, club: String, domesticLeague: String, rawTotal: String, finalScore: String, ranking2016: String, ranking2015: String) 
 
object Util { 
 
  def bufferedSourceToList(source: BufferedSource): List[String] = { 
      val list = source.getLines().toList 
      source.close() 
      list 
  } 
 
  def asPlayers(listOfPlayersString: List[String]) : List[Player] = listOfPlayersString match { 
    case head :: tail =&gt; tail map {line =&gt; 
      val columns = line.split((",")).map(_.trim) 
      Player(columns(5),columns(6),columns(9),columns(7), 
        columns(8),columns(10), columns(12), columns(0),columns(2)) 
    } 
    case Nil =&gt; List[Player]() 
  } 
 
} </pre>
<p class="calibre2">We defined two utility methods named <kbd class="calibre11">bufferedSourceToList</kbd> and <kbd class="calibre11">asPlayers</kbd><em class="calibre18">;</em> these methods do what they say. So, let's now define our <kbd class="calibre11">SimpleActor</kbd> receive method:</p>
<pre class="calibre19">class SimpleActor extends Actor { 
  import scala.io.Source 
  import SimpleActor.ShowFootballPlayersRequest 
  import Util._ 
 
  override def receive = { 
    case ShowFootballPlayersRequest(url) =&gt; { 
      val playersInfoSource = Source.fromFile(url) 
 
      val players = asPlayers(bufferedSourceToList(playersInfoSource)) 
      players.foreach(player =&gt; println(player + "n")) 
    } 
  } 
 
} 
 
object SimpleActor { 
  val props = Props[SimpleActor] 
 
  final case class ShowFootballPlayersRequest(uri: String)<br class="title-page-name"/> }</pre>
<p class="calibre2">We have defined the receive methods, or let's say <kbd class="calibre11">SimpleActor</kbd> method's behavior, for a particular request such as <kbd class="calibre11">ShowFootballPlayersRequest</kbd><em class="calibre18">.</em> The request itself contains the required information to fetch the information from the URI for the file. We defined this request as a final case class in the companion object of <kbd class="calibre11">SimpleActor</kbd><em class="calibre18">.</em> This conventional approach specifies the requests our actor supports. On receipt of such a request for players information, our actor fetches information from the file at the location specified, and then it prints the player's information.</p>
<p class="calibre2">Let's use it. We're going to send a request of <kbd class="calibre11">ShowFootballPlayersRequest</kbd> type using our actor reference:</p>
<pre class="calibre19">val fileSource = "/Users/vika/Workspace/akkaa/akka-starter/src/main/scala/files/football_stats.csv" 
 
simpleActor ! ShowFootballPlayersRequest(fileSource) </pre>
<p class="calibre2">In the previous code snippet, we've used a method with this operator-like name, "<kbd class="calibre11">!</kbd>", and passed an instance of <kbd class="calibre11">ShowFootballPlayersRequest</kbd> with the file source URI. This method, let's call it <kbd class="calibre11">bang</kbd> for now, in an ideal case goes to the actor's mailbox and delivers this message. This happens in a fire-and-forget manner. There's no guarantee of message delivery at the called actor's mailbox. There might be scenarios where you expect a response from called actors; in that case instead of calling <kbd class="calibre11">bang</kbd><em class="calibre18">,</em> we make an ask call to our Actors.</p>
<p class="calibre2">We'll consider a request containing a player's name and the source for a list of players. For example, the source can be any public API to get the player's information; in our case, it's a simple <kbd class="calibre11">List[Player]</kbd> with all the player's data.</p>
<p class="calibre2">The first thing we would like to do is create a simple request and response. For this, we can define these in our <kbd class="calibre11">SimpleActor</kbd> companion object.<span> First is a simple request with the player's name and a list of players we'll pass along. The second one is a response container which has nothing but an option player:</span></p>
<pre class="calibre19">final case class GetPlayerInformationRequest(name: String, source: List[Player]) 
final case class PlayerInformationResponse(player: Option[Player]) </pre>
<p class="calibre2">Now, let's define a receive method for such a request, of type <kbd class="calibre11">GetPlayerInformationRequest</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">import scala.concurrent.Future 
import scala.concurrent.ExecutionContext.Implicits.global
 
case GetPlayerInformationRequest(name, listOfPlayers) =&gt; { 
  log.info(s"Executing GetPlayerInformationRequest($name, listOfPlayers)")<br class="title-page-name"/><br class="title-page-name"/>akka.pattern.pipe(<br class="title-page-name"/> Future.<span>successful</span>(<span>PlayerInformationResponse</span>(listOfPlayers.find(_.name.contains(name))))<br class="title-page-name"/>) to sender()<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">A few points to note about this behavior:</p>
<ul class="calibre7">
<li class="calibre8">We have used a logger implementation to log information specific to this Actor. For this, we have used the <kbd class="calibre11">ActorLogging</kbd> trait. Simply mix in this trait by using:</li>
</ul>
<pre class="calibre19">    class SimpleActor extends Actor with ActorLogging</pre>
<ul class="calibre7">
<li class="calibre8">When we receive a message to perform some expensive operation, we perform that operation and wrap that in future<em class="calibre18">,</em> and want to return back future's reference to the calling Actor. For this purpose, we've used a method named <kbd class="calibre11">pipe</kbd> from the <kbd class="calibre11">akka.pattern</kbd> package. This method expects an execution context. The way we use pipe or the similar syntax method <kbd class="calibre11">pipeTo</kbd> is as follows:</li>
</ul>
<pre class="calibre19">    akka.pattern.pipe(someFuture) to sender() </pre>
<p class="calibre2">Alternatively we can use:</p>
<pre class="calibre19">  import akka.pattern._ 
  someFuture pipeTo sender() </pre>
<p class="calibre2">This <kbd class="calibre11">pipe</kbd> or <kbd class="calibre11">pipeTo</kbd> method sends back the response to the calling site.</p>
<p class="calibre2">After defining the behavior of our Actor for messages of type <kbd class="calibre11">GetPlayerInformationRequest</kbd><em class="calibre18">,</em> let's call the Actor with this message. First, we'll create the source, <kbd class="calibre11">List[Player]</kbd>:</p>
<pre class="calibre19">//Storing players in a collection! 
val players: List[Player] = Util 
  .asPlayers(bufferedSourceToList( 
    scala.io.Source.fromFile(fileSource) 
  )) </pre>
<p class="calibre2">Performing an ask call to the simple Actor is as simple as questioning the Actor:</p>
<pre class="calibre19">simpleActor ? GetPlayerInformationRequest("Cristiano Ronaldo", players) </pre>
<p class="calibre2">Now this <kbd class="calibre11">?</kbd> is called <em class="calibre18">ask method</em>; we use this method when we expect a response from the called Actor. We need to give an <kbd class="calibre11">import</kbd> statement to import this method in scope:</p>
<pre class="calibre19">import akka.pattern.ask </pre>
<p class="calibre2">Also, we might want to make sure this request gets completed in a given time duration. We'll ensure that particular timeout duration by bringing an implicit timeout value in scope:</p>
<pre class="calibre19">import akka.util.Timeout 
import scala.concurrent.duration._ 
 
implicit val timeout = Timeout(5 seconds) </pre>
<p class="calibre2">Now, on successful completion of our request we can obtain the values from the response. So, let's do that and print the player's information:</p>
<pre class="calibre19">val playerInformation = (simpleActor ? GetPlayerInformationRequest("Cristiano Ronaldo", players)) 
 
playerInformation 
  .mapTo[PlayerInformationResponse] 
  .map(futureValue =&gt; { 
      futureValue.player map println 
    }) </pre>
<p class="calibre2">First, we mapped the response to the desired type by providing a <kbd class="calibre11">mapTo</kbd> method, and then we mapped values from the future and printed. We've used the <em class="calibre18">fire-and-forget</em> way of sending a message to one actor and we've waited for some response using the <em class="calibre18">ask</em> method. There's another way we can communicate messages and that's using the <kbd class="calibre11">forward</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The tell versus ask versus forward method</h1>
                
            
            <article>
                
<p class="calibre2">We use one of these three approaches to transmit messages from one actor to another. As we've already established, <kbd class="calibre11">tell</kbd> transmits messages and does not wait for the response; this way, we ensure <em class="calibre18">at most once</em> delivery. We can also use the <kbd class="calibre11">ask</kbd> method in cases where we expect our called <em class="calibre18">actors</em> to respond back with some messages of the response type. There might be scenarios where you want to forward a message of a particular type with the same actor reference (<kbd class="calibre11">ActorRef</kbd>) to another Actor<em class="calibre18">.</em> For this purpose, we can use the <kbd class="calibre11">forward</kbd> method:</p>
<pre class="calibre19">class AnotherActor extends Actor { 
  override def receive = { 
    case ShowFootballPlayersRequest(url) =&gt; { 
      val playersInfoSource = Source.fromFile(url) 
 
      val players = asPlayers(bufferedSourceToList(playersInfoSource)) 
      players.foreach(player =&gt; println(player + "n")) 
    } 
  } 
} 
 
object AnotherActor { 
  val props = Props[AnotherActor] 
} </pre>
<p class="calibre2">We have defined <kbd class="calibre11">AnotherActor</kbd><em class="calibre18">,</em> and we can make this a child actor of our <kbd class="calibre11">SimpleActor</kbd><em class="calibre18">.</em> To do that, let's instantiate this actor by giving a <kbd class="calibre11">context.actorOf</kbd> call from <kbd class="calibre11">SimpleActor</kbd><em class="calibre18">.</em> Then, on receipt of a message of type <kbd class="calibre11">ShowFootballPlayersRequest</kbd>, we'll forward the message to <kbd class="calibre11">anotherActor</kbd>, as shown in the following code snippet:</p>
<pre class="calibre19">class SimpleActor extends Actor with ActorLogging { <br class="title-page-name"/><br class="title-page-name"/>  implicit val ec = context.dispatcher <br class="title-page-name"/>  // Works as executionContext for actor calls 
 
  val anotherActor = context.actorOf(AnotherActor.props) 
 
  override def receive = { 
    case ShowFootballPlayersRequest(url) =&gt; { 
      anotherActor forward ShowFootballPlayersRequest(url) 
    } 
 
    case GetPlayerInformationRequest(name, listOfPlayers) =&gt; { 
      log.info(s"Executing GetPlayerInformationRequest($name, listOfPlayers)") 
 
      akka.pattern.pipe(       Future.successful(PlayerInformationResponse(listOfPlayers.find(_.name.contins(name)) ))<br class="title-page-name"/>) to sender() } } }</pre>
<p class="calibre2">The <kbd class="calibre11">SimpleActor</kbd> class simply forwards the message to another actor; now, we can have a look at the whole code we have written and try to run it:</p>
<pre class="calibre19">package lsp 
 
import lsp.SimpleActor.{GetPlayerInformationRequest, PlayerInformationResponse, ShowFootballPlayersRequest} 
import akka.actor.{Actor, ActorLogging, ActorSystem, PoisonPill, Props} 
import akka.pattern.ask 
import scala.io.{BufferedSource, Source} 
import akka.util.Timeout 
import lsp.Util.{asPlayers, bufferedSourceToList} 
import scala.concurrent.duration._ 
import scala.concurrent.Future 
import scala.concurrent.ExecutionContext.Implicits.global 
 
 
class SimpleActor extends Actor with ActorLogging { 
 
  val anotherActor = context.actorOf(AnotherActor.props) 
 
  override def receive = { 
    case ShowFootballPlayersRequest(url) =&gt; { 
      anotherActor forward ShowFootballPlayersRequest(url) 
    } 
 
    case GetPlayerInformationRequest(name, listOfPlayers) =&gt; { 
      log.info(s"Executing GetPlayerInformationRequest($name, listOfPlayers)") 
 
      akka.pattern.pipe( 
        Future { 
          PlayerInformationResponse(listOfPlayers.find(_.name.contains(name))) 
        } 
      ) to sender() 
 
    } 
 
  } 
 
} 
object SimpleActor { 
  val props = Props[SimpleActor] 
 
  final case class ShowFootballPlayersRequest(uri: String) 
 
  final case class GetPlayerInformationRequest(name: String, source: List[Player]) 
  final case class PlayerInformationResponse(player: Option[Player]) 
} </pre>
<p class="calibre2">The previous code is our main <em class="calibre18">SimpleActor</em> and its companion object. Let's take a look at <em class="calibre18">AnotherActor</em>:</p>
<pre class="calibre19">class AnotherActor extends Actor { 
  override def receive = { 
    case ShowFootballPlayersRequest(url) =&gt; { 
      val playersInfoSource = Source.fromFile(url) 
 
      val players = asPlayers(bufferedSourceToList(playersInfoSource)) 
 
      players.foreach(player =&gt; println(player)) 
    } 
  } 
 
} 
object AnotherActor { 
  val props = Props[AnotherActor] 
} </pre>
<p class="calibre2">Finally, the entry point to our application where we boot the Actor system:</p>
<pre class="calibre19">object AkkaStarter extends App { 
  import Util._ 
 
  implicit val timeout = Timeout(5 seconds) 
 
  val simpleActorSystem = ActorSystem("SimpleActorSystem") 
  val simpleActor = simpleActorSystem.actorOf(SimpleActor.props, "simple-actor") 
 
  val fileSource = 
    "/Users/vika/Workspace/akkaa/akka-starter/src/main/scala/files/football_stats.csv" 
 
  //simpleActor ! ShowFootballPlayersRequest(fileSource) 
 
  //Storing players in a collection! 
  val players: List[Player] = Util 
    .asPlayers(bufferedSourceToList( 
      scala.io.Source.fromFile(fileSource) 
    )) 
 
  val playerInformation = (simpleActor ? GetPlayerInformationRequest("Cristiano Ronaldo", players)) 
 
  playerInformation 
    .mapTo[PlayerInformationResponse] 
    .map(futureValue =&gt; { 
        futureValue.player map println 
      }) 
 
  simpleActor ! PoisonPill 
} </pre>
<p class="calibre2">We also have this <kbd class="calibre11">Util</kbd> object which consists of utility methods. With this, we have defined the <kbd class="calibre11">Player</kbd> c<span>ase class:</span></p>
<pre class="calibre19">object Util { 
 
  def bufferedSourceToList(source: BufferedSource): List[String] = { 
      val list = source.getLines().toList 
 
      source.close() 
      list 
  } 
 
  def asPlayers(listOfPlayersString: List[String]) : List[Player] = listOfPlayersString match { 
    case head :: tail =&gt; tail map {line =&gt; 
      val columns = line.split((",")).map(_.trim) 
      Player(columns(5),columns(6),columns(9),columns(7), 
        columns(8),columns(10), columns(12), columns(0),columns(2)) 
    } 
    case Nil =&gt; List[Player]() 
  } 
 
} 
 
case class Player(name: String, nationality: String, age:String, club: String, 
                  domesticLeague: String, rawTotal: String, finalScore: String, 
                  ranking2016: String, ranking2015: String) </pre>
<p class="calibre2">Run:</p>
<pre class="calibre19">[INFO] [12/27/2017 14:40:48.150] [SimpleActorSystem-akka.actor.default-dispatcher-2] [akka://SimpleActorSystem/user/simple-actor] Executing GetPlayerInformationRequest(Cristiano Ronaldo, listOfPlayers) 
Player(Cristiano Ronaldo,Portugal,32,Real Madrid,Spain,4829,4789,1,2) </pre>
<p class="calibre2">After using our Actor, we should terminate its instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Stopping Actors</h1>
                
            
            <article>
                
<p class="calibre2">One way of stopping actors is by calling the <kbd class="calibre11">stop</kbd> method from the <kbd class="calibre11">system</kbd> or <kbd class="calibre11">context</kbd> for a particular actor. To do this, we can define a particular message that can be passed to the actor, telling it to stop. For example:</p>
<pre class="calibre19">case "terminate" =&gt; context stop self </pre>
<p class="calibre2">Most of the times the preferred way of terminating an actor is by sending a <kbd class="calibre11">PoisonPill</kbd> message to it:</p>
<pre class="calibre19">simpleActor ! PoisonPill </pre>
<p class="calibre2">This simple message passing can terminate the actor gracefully. The termination takes place after all the messages in the Actor's queue are processed before the poison pill is processed. Stopping an <em class="calibre18">actor</em> stops all of its child actors. Remember, we talked about those hook methods that can be called if we want to perform some logic when the actor is starting up or at termination. Let's take a look at those.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The preStart and postStop hooks</h1>
                
            
            <article>
                
<p class="calibre2">Let's define these methods in the <kbd class="calibre11">SimpleActor</kbd> class to log the starting and stopping of our <kbd class="calibre11">SimpleActor</kbd>:</p>
<pre class="calibre19">override def preStart(): Unit = log.info("SimpleActor starting!") 
 
override def postStop(): Unit = log.info("SimpleActor stopping!") </pre>
<p class="calibre2">Run:</p>
<pre class="calibre19">[INFO] [12/27/2017 14:56:54.887] [SimpleActorSystem-akka.actor.default-dispatcher-3] [akka://SimpleActorSystem/user/simple-actor] SimpleActor starting! 
[INFO] [12/27/2017 14:56:54.915] [SimpleActorSystem-akka.actor.default-dispatcher-2] [akka://SimpleActorSystem/user/simple-actor] Executing GetPlayerInformationRequest(Cristiano Ronaldo, listOfPlayers) 
Player(Cristiano Ronaldo,Portugal,32,Real Madrid,Spain,4829,4789,1,2) 
[INFO] [12/27/2017 14:56:54.938] [SimpleActorSystem-akka.actor.default-dispatcher-2] [akka://SimpleActorSystem/user/simple-actor] SimpleActor stopping! </pre>
<p class="calibre2">Similar methods are also available for restart operations in the form of <kbd class="calibre11">preRestart</kbd> and <kbd class="calibre11">postRestart</kbd><em class="calibre18">.</em></p>
<p class="calibre2">When we discuss communicating via messages, the question of in which order the messages get delivered to other actors <span>arises</span>, and also at what guarantee of message delivery.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Actor communication via messages and its semantics</h1>
                
            
            <article>
                
<p class="calibre2">We talked about the fashion of <em class="calibre18">fire-and-forget</em> regarding message passing; to understand this a bit more, let's take a look at a diagram explaining message delivery semantics.</p>
<p class="calibre2">The following diagram explains the semantics of message delivery; when we send messages over a network, there are chances of it getting delivered and also chances of it being lost. Also, in the case of an unsuccessful or successful attempt to deliver a message, we might try to send a message or we might not. It depends on us if want to try sending a message exactly once and then not the second time or so on.</p>
<p class="calibre2">Based on these assumptions, we can make some formal terminologies specifying what we discussed, and we call them:</p>
<ul class="calibre7">
<li class="calibre8">At most once</li>
<li class="calibre8">At least once</li>
<li class="calibre8">Exactly once</li>
</ul>
<div class="cdpaligncenter"><img src="../images/00053.jpeg" class="calibre59"/></div>
<p class="calibre2">The diagram explains each of the three approaches in simple terms. It's important to know that in case of the Actor's communication, we have at most once delivery; in other terms, it means no guaranteed delivery. When actors communicate, a message might or might not be delivered to the called Actor.</p>
<p class="calibre2">Actors are pretty lightweight and can accommodate a large number of messages fired to them; when we send a message to an actor, the messages get delivered to the actor's mailbox. An actor's mailbox is a queue that gets instantiated when we create an actor's instance. We know the way queue works is FIFO, <em class="calibre18">first in first out.</em> The ordering of the execution of the messages depends on the order in which they arrive to the mailbox.</p>
<p class="calibre2">Until now, our discussions were based on the possibilities of successful execution of the logic implemented via Actors. But we know that Akka provides a very nice fault handling mechanism in the <em class="calibre18">form</em> of a <em class="calibre18">supervision strategy.</em> Let's discuss it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Supervising fault in our actors</h1>
                
            
            <article>
                
<p class="calibre2">There is a possibility that our logic ends up in a network error or some unexpected exception. Imagine a scenario where our service needs to call a particular database instance to fetch some data. We might face <em class="calibre18">connection timed out</em> or some other similar errors. In that case, what should be our behavior? Maybe trying to establish the connection a couple of times will help, this can be achieved if our tasks are performed in such a hierarchical manner. We can achieve this task by performing hierarchy via the <em class="calibre18">actors</em> in place. And if some actor from down in the hierarchy fails and can communicate the failure to parent actor, the parent actor, based on the type of failure, can restart/kill the actor or perform some other operation as required. This is in a sense supervising the actors below in the hierarchy; let's say parent actors can supervise child actors. The way we define this strategy comes under the Akka defined supervision strategy.</p>
<p class="calibre2">Supervision in a sense is about reacting to <em class="calibre18">failures</em> within an actor's hierarchy. Apart from the <em class="calibre18">root guardian,</em> every <em class="calibre18">actor</em> has a parent/supervisor to supervise. Every actor when instantiated becomes a part of a <em class="calibre18">default supervision strategy</em>. It's also important to observe that <em class="calibre18">failures</em> need a separate channel to be communicated to supervisors. So, Akka has a separate group of <em class="calibre18">system level actors,</em> which deal with the communication of such messages.</p>
<p class="calibre2">Since we deal with actors in case of failures also, our reactions should be in terms of actor-specific actions.</p>
<p class="calibre2">Hence, think about the actions a supervisor can perform:</p>
<ul class="calibre7">
<li class="calibre8">Resume child actors</li>
<li class="calibre8">Restart child actors</li>
<li class="calibre8">Stop child actors</li>
<li class="calibre8">Escalate the failure</li>
</ul>
<p class="calibre2">When a supervisor actor encounters a <em class="calibre18">failed child actor,</em> it can perform one of the actions described above. Depending on our preference, we might want to apply the strategy to all the children actors, regardless of if all of them failed or not. It's also possible to only <em class="calibre18">resume/restart/stop</em> the failing child actor.</p>
<p class="calibre2">Based on the children on which the <em class="calibre18">supervision strategy</em> should be applied, we have two strategies, namely <em class="calibre18">OneForOneStrategy</em> and <em class="calibre18">AllForOneStrategy.</em> Let's take a look at them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">OneForOne versus AllForOne strategy</h1>
                
            
            <article>
                
<p class="calibre2">Take the scenario where we have <kbd class="calibre11">SimpleActor</kbd> and <kbd class="calibre11">AnotherSimpleActor</kbd> actors. There's one child actor for <kbd class="calibre11">SimpleActor</kbd> named <kbd class="calibre11">SimplerrrActor</kbd><em class="calibre18">:</em></p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">SimpleActor</strong>: <kbd class="calibre11">/user/topLevelActor/simpleActor</kbd></li>
<li class="calibre8"><strong class="calibre1">AnotherSimpleActor</strong>:<kbd class="calibre11"> /user/topLevelActor/anotherSimpleActor</kbd></li>
<li class="calibre8"><strong class="calibre1">SimplerrrActor</strong>:<kbd class="calibre11"> /user/topLevelActor/simpleActor/simplerrrActor</kbd></li>
</ul>
<p class="calibre2">In such cases, the user guardian is going to take care of <kbd class="calibre11">topLevelActor</kbd> and <kbd class="calibre11">topLevelActor</kbd> is going to supervise <kbd class="calibre11">SimpleActor</kbd> and <kbd class="calibre11">AnotherSimpleActor</kbd><em class="calibre18">.</em> If something goes wrong in <kbd class="calibre11">SimpleActor</kbd> and we want all the actors to resume/restart/stop, we can define an <kbd class="calibre11">AllForOneStrategy</kbd><em class="calibre18">.</em> If we want to perform such actions only on the failed <kbd class="calibre11">SimpleActor</kbd> and its subsequent children, we can opt for <kbd class="calibre11">OneForOneStrategy</kbd><em class="calibre18">.</em></p>
<p class="calibre2">These two are defined as case classes in Scala, which takes a few parameters in the form of <kbd class="calibre11">maxNrOfRetries</kbd>, <kbd class="calibre11">withinTimeRange</kbd>, and <kbd class="calibre11">loggingEnabled</kbd>:</p>
<pre class="calibre19">case class OneForOneStrategy( 
  maxNrOfRetries:              Int      = -1, 
  withinTimeRange:             Duration = Duration.Inf, 
  override val loggingEnabled: Boolean  = true) 
 
case class AllForOneStrategy( 
  maxNrOfRetries:              Int      = -1, 
  withinTimeRange:             Duration = Duration.Inf, 
  override val loggingEnabled: Boolean  = true) </pre>
<p class="calibre2">The first parameter is to specify the number of times we might want to retry the strategy on the child actor; we can make it an infinite number of times by specifying -1 as the number. After the specified number of times, the child actor will stop. A second parameter specifies the duration after which the next retry should happen. As shown, the value <kbd class="calibre11">Duration.Inf</kbd> specifies no time window at all. Finally, we have to specify the logging behavior; it expects a Boolean value, and by default, it's true and means enabled.</p>
<p class="calibre2">These two strategy classes extend the parent abstract class <kbd class="calibre11">SupervisorStrategy</kbd>. The way these two strategies work can be understood via the diagram here:</p>
<div class="cdpaligncenter"><img src="../images/00054.jpeg" class="calibre60"/></div>
<p class="calibre2">Now, the choice is ours to apply whichever strategy that suits our needs/situation. We define these strategies based on the type of failures; in the case that we've not covered a particular failure occurs, the failure gets escalated to the parent supervisor Actor. There's a defined set of actions performed by supervisors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Default supervision strategy</h1>
                
            
            <article>
                
<p class="calibre2">By default, the Akka system looks for a few exception types from failure messages received from child Actors. Let's take a look at those scenarios.</p>
<p class="calibre2">The default supervision strategy will stop the failing child Actor in case of:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">ActorInitializationException</kbd></li>
<li class="calibre8"><kbd class="calibre11">ActorKilledException</kbd></li>
<li class="calibre8"><kbd class="calibre11">DeathPactException</kbd></li>
</ul>
<p class="calibre2">Note that in case of exception, it'll restart the failing Actor.</p>
<p class="calibre2">With this information, let's try implementing one strategy on our own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Applying the supervision strategy</h1>
                
            
            <article>
                
<p class="calibre2">While overriding the default <kbd class="calibre11">supervisorStrategy</kbd><em class="calibre18">,</em> all we do is define the value with arguments and provide a <kbd class="calibre11">Decider</kbd>; this decider contains the logic to be implemented in case of exceptions. It looks like this:</p>
<pre class="calibre19">import akka.actor.SupervisorStrategy.{Resume, Restart} 
 
override val supervisorStrategy = 
  OneForOneStrategy( 
    maxNrOfRetries = 3, 
    withinTimeRange = 1 minute 
  ){ 
    case _: ArithmeticException =&gt; { 
      log.info("Supervisor handling ArithmeticException! n Resuming!") 
      Resume 
    } 
    case _: Exception =&gt; { 
      log.info("Supervisor handling Exception! n Restarting!") 
      Restart 
    } 
  } </pre>
<p class="calibre2">Here, we have defined a <kbd class="calibre11">OneForOneStrategy</kbd>, and on a case by case basis, the action to be performed in regards to the failing actor. A full example with this strategy in place can look like the following:</p>
<pre class="calibre19">package example 
 
import akka.actor.{Actor, ActorSystem, OneForOneStrategy, Props, ActorLogging} 
import scala.concurrent.duration._ 
 
object SupervisionStrategyInPractice extends App { 
  val system = ActorSystem("anActorSystem") 
 
  val topLevelActor = system.actorOf(TopLevelActor.props) 
 
  //Sending StopIt 
  topLevelActor ! TopLevelActor.StopIt 
  //Sending RestartIt 
  topLevelActor ! TopLevelActor.RestartIt 
} 
 
class TopLevelActor extends Actor with ActorLogging { 
  import akka.actor.SupervisorStrategy.{Resume, Restart 
 
  import TopLevelActor._ 
 
  override val preStart = log.info(s"TopLevelActor started!") 
  override val postStop = log.info(s"TopLevelActor stopping!") 
 
  val superSimpleActor = context.actorOf(SuperSimpleActor.props) 
 
  override def receive = { 
    case StopIt =&gt; superSimpleActor ! SuperSimpleActor.ArithmeticOpRequest 
    case RestartIt =&gt; superSimpleActor ! SuperSimpleActor.OtherMessage 
  } 
 
  override val supervisorStrategy = 
    OneForOneStrategy( 
      maxNrOfRetries = 3, 
 
      withinTimeRange = 1 minute 
    ){ 
      case _: ArithmeticException =&gt; { 
        log.info("Supervisor handling ArithmeticException! n Resuming!") 
        Resume 
      } 
      case _: Exception =&gt; { 
        log.info("Supervisor handling Exception! n Restarting!") 
        Restart 
      } 
    } 
} 
 
<br class="title-page-name"/> object TopLevelActor { 
  val props = Props[TopLevelActor] 
  case object StopIt 
  case object RestartIt 
} 
 
class SuperSimpleActor extends Actor with ActorLogging { 
  import SuperSimpleActor._ 
 
  override val preStart = log.info(s"SuperSimpleActor started!") 
  override val postStop = log.info(s"SuperSimpleActor stopping!") 
 
  override def preRestart(reason: Throwable, message: Option[Any]): Unit = 
    log.info(s"SuperSimpleActor restarting!") 
 
  override def receive = { 
    case ArithmeticOpRequest =&gt; 1 / 0 
    case OtherMessage =&gt; throw new Exception("Some Exception Occurred!") 
  } 
 
} 
 
object SuperSimpleActor { 
  val props = Props[SuperSimpleActor] 
 
 case object ArithmeticOpRequest 
  case object OtherMessage 
 
} </pre>
<p class="calibre2">As shown in the code, we have a <kbd class="calibre11">TopLevelActor</kbd><em class="calibre18">,</em> which sends messages to its child Actor <kbd class="calibre11">SuperSimpleActor</kbd><em class="calibre18">,</em> hence, <kbd class="calibre11">TopLevelActor</kbd> becomes a supervisor for its child actor. We have overridden the <kbd class="calibre11">supervisorStrategy</kbd>. According to the new Strategy, we can resume/restart based on the types of exceptions. The rest of the example is self-explanatory. We've logged the start and restart steps of our actors by overriding <kbd class="calibre11">preStart</kbd> <em class="calibre18">and</em> <kbd class="calibre11">preRestart</kbd> methods. Upon running the example, we'll get the logged output.</p>
<p class="calibre2">Run:</p>
<pre class="calibre19">[INFO] [12/28/2017 13:35:39.856] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a] TopLevelActor started! 
[INFO] [12/28/2017 13:35:39.856] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a] TopLevelActor stopping! 
[INFO] [12/28/2017 13:35:39.857] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor started! 
[INFO] [12/28/2017 13:35:39.857] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor stopping! 
[INFO] [12/28/2017 13:35:39.864] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a] Supervisor handling ArithmeticException!  
 Resuming! 
[WARN] [12/28/2017 13:35:39.865] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a/$a] / by zero 
[INFO] [12/28/2017 13:35:39.867] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a] Supervisor handling Exception!  
 Restarting! 
[ERROR] [12/28/2017 13:35:39.868] [anActorSystem-akka.actor.default-dispatcher-2] [akka://anActorSystem/user/$a/$a] Some Exception Occurred! 
java.lang.Exception: Some Exception Occurred! at example.SuperSimpleActor$$anonfun$receive$2.applyOrElse(SupervisionStrategyInPractice.scala:66) 
   at akka.actor.Actor.aroundReceive(Actor.scala:517) 
   at akka.actor.Actor.aroundReceive$(Actor.scala:515) 
   at example.SuperSimpleActor.aroundReceive(SupervisionStrategyInPractice.scala:55) ... 
[INFO] [12/28/2017 13:35:39.868] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor restarting! 
[INFO] [12/28/2017 13:35:39.871] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor started! 
[INFO] [12/28/2017 13:35:39.871] [anActorSystem-akka.actor.default-dispatcher-3] [akka://anActorSystem/user/$a/$a] SuperSimpleActor stopping! </pre>
<p class="calibre2">Since these failures are communicated via system level actors, the order of messages logged does not matter.</p>
<p class="calibre2">With this example, we've pretty much covered how we can implement a supervisor strategy for our Actor.</p>
<p class="calibre2">Akka library also provides <kbd class="calibre11">akka-testkit</kbd> for the testing of actors. It comes with a construct which make it easier to test actors. Let's go through the library and write unit test cases for our actor implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing actors</h1>
                
            
            <article>
                
<p class="calibre2">For the testing of Actors that we create, we might consider few entities that are needed to be present. These entities might be:</p>
<ul class="calibre7">
<li class="calibre8">A test actor-system</li>
<li class="calibre8">A <kbd class="calibre11">testActor</kbd> (the message sender)</li>
<li class="calibre8">The actor under testing (whose behavior we want to test)</li>
<li class="calibre8">Assertions to be made in case of an actors expected message</li>
</ul>
<p class="calibre2">Akka's <kbd class="calibre11">test-kit</kbd> library provides us with all of these needed entities ready-made. We can use these to test our actors. Let's write a simple actor test case.</p>
<p class="calibre2">The expect case is to check if our <kbd class="calibre11">GetPlayerInformationRequest</kbd> works fine:</p>
<pre class="calibre19">package lsp 
 
import akka.actor.ActorSystem 
import akka.testkit.{ImplicitSender, TestKit} 
import lsp.SimpleActor.{GetPlayerInformationRequest, PlayerInformationResponse} 
import org.scalatest.{BeforeAndAfterAll, WordSpecLike} 
 
class SimpleActorSpec extends TestKit(ActorSystem("testActorSystem")) 
  with ImplicitSender with WordSpecLike with BeforeAndAfterAll { 
 
  override def afterAll(): Unit = super.afterAll() 
 
  val players = List(Player("Cristiano Ronaldo", "Portuguese", "32", "Real Madrid", "La Liga", "1999", "1999", "1", "1")) 
 
  "SimpleActor" must { 
 
    "test for PlayerInformationRequest" in { 
 
      val simpleActor = system.actorOf(SimpleActor.props) 
 
      simpleActor ! GetPlayerInformationRequest("Cristiano Ronaldo", players) 
 
      val expectedResponse = 
        PlayerInformationResponse(Some(Player("Cristiano Ronaldo", "Portuguese", "32", "Real Madrid", "La Liga", "1999", "1999", "1", "1"))) 
 
      expectMsg(expectedResponse) 
    } 
     
  } 
   
} </pre>
<p class="calibre2">The previous code is a very simple example of how we can write an Actor test case. We should make sure that the test case we write is in the test directory:</p>
<div class="cdpaligncenter"><img src="../images/00055.jpeg" class="calibre61"/></div>
<p class="calibre2">Before we discuss our <em class="calibre18">test case,</em> let's run it. To run it, we can simply right-click using mouse and choose the <span>Run</span> option<em class="calibre18">.</em> In our case, the test case should pass. Now, let's take a look at the case we wrote.</p>
<p class="calibre2">The first thing to observe is the declaration we wrote:</p>
<pre class="calibre19">class SimpleActorSpec extends TestKit(ActorSystem("testActorSystem")) 
  with ImplicitSender with WordSpecLike with BeforeAndAfterAll </pre>
<p class="calibre2">We named our actor test case <kbd class="calibre11">SimpleActorSpec</kbd>, and extended <kbd class="calibre11">Testkit</kbd> by passing an <kbd class="calibre11">ActorSystem</kbd> for testing purposes. We've also mixed in <kbd class="calibre11">ImplicitSender</kbd>, which in turn returns the response from our actor under test, <kbd class="calibre11">SimpleActor</kbd>. Finally, <kbd class="calibre11">WordSpecLike</kbd> and the other <kbd class="calibre11">BeforeAndAfterAll</kbd> are just to provide DSL-like syntax methods for writing test cases. We can see these syntax methods in the form of must and in.</p>
<p class="calibre2">In the implementation, we've done what's expected, created the actor under the test's reference, and provided dummy data as in the players list. We also created a dummy response that's expected from our <kbd class="calibre11">SimpleActor</kbd>. The following line sends the message to <kbd class="calibre11">SimpleActor</kbd>, which in turn responds back:</p>
<pre class="calibre19">      simpleActor ! GetPlayerInformationRequest("Cristiano Ronaldo", players) </pre>
<p class="calibre2">The assertion part is handled using the <kbd class="calibre11">expectMsg</kbd> method. Here, we compared the dummy response to the expected response. For assertion purposes, <kbd class="calibre11">scala-test</kbd> library provides many alternatives.</p>
<p class="calibre2">With this, we wrote a simple test case for our <kbd class="calibre11">SimpleActor</kbd><em class="calibre18">.</em> We've covered all the basics we need to understand and write actors in Akka<em class="calibre18">.</em> There are a few advanced configuration-related topics such as <em class="calibre18">dispatchers, mailbox implementations</em>, and <em class="calibre18">routing</em> you might want to have a look at. For those, we can first thank the beautifully covered standard <em class="calibre18">documentation</em> of Akka available at: <a href="https://doc.akka.io/docs/akka/2.5.8/index-actors.html" class="calibre10">https://doc.akka.io/docs/akka/2.5.8/index-actors.html</a><em class="calibre18">.</em></p>
<p class="calibre2">And if you still have a question in mind about what's next or where to go from here, let me tell you there's way more that Akka provides. We've already talked about Akka as a set of open source libraries. These libraries are available for different problems. Libraries such as <kbd class="calibre11">akka-http</kbd>, streams, and clustering provide you with respective solutions. The good part is all these libraries are based on the abstraction of actor-model. And we have covered that in our chapter, so let's summarize what we've learnt in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter was an introduction to Akka for us. We tried to understand the basic underlying principle of actors. We've covered one of the most important libraries Akka provides, <kbd class="calibre11">akka-actors</kbd>. Starting from why we need a library of this sort, to understanding the way we implement Actors in Akka, we covered it all. Then from there, we covered the important supervision strategy in Akka. We talked about and practiced our own custom supervisor strategy. Finally, we had a look at <kbd class="calibre11">akka-testkit</kbd>, a testkit provided by Akka. With this, we covered what was needed to understand Akka actors and the basics of it. In the next chapter, we'll focus on how we can handle concurrency in Scala. We know it's importance in modern architecture, so the next chapter will be an exciting one.</p>
<p class="calibre2"/>


            </article>

            
        </section>
    </body></html>