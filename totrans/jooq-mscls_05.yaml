- en: '*Chapter 3*: jOOQ Core Concepts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before exploring more awesome features of jOOQ, we have to cover the core (fundamental)
    concepts that jOOQ relies on. Having a decent insight into jOOQ core concepts
    helps us to make the right decisions and to understand how jOOQ works under the
    hood. Don't worry, our aim is not to enter the jOOQ bowels! We aim to bring you
    close to the jOOQ paradigm and start thinking about your persistent layer in the
    jOOQ context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to briefly introduce the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Hooking jOOQ results (`Result`) and records (`Record`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring jOOQ query types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the jOOQ fluent API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting how jOOQ emphasizes SQL syntax correctness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting, coercing, and collating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding values (parameters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll be familiar with the jOOQ core concepts that
    will help you to easily follow the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter03](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Hooking jOOQ results (Result) and records (Record)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we''ve mapped the JDBC result set of our queries
    to POJOs via the jOOQ `fetchInto()` method. But, in jOOQ, between the JDBC result
    set and a well-known `List<POJO>` (or other data structure such as an array, map,
    and set), there is another fundamental layer referenced as `Result<Record>` represented
    from the following two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.jooq.Record`: When we trigger a `SELECT` query, we get back a result set
    that contains a list of columns and the corresponding list of values. Typically,
    we refer to the content of the result set as *records*. jOOQ maps each such *record*
    to its `Record` interface. Think of `Record` as the jOOQ internal representation
    of *records*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.jooq.Result`: The jOOQ `Result` interface is a `java.util.List` of `org.jooq.Record`.
    In other words, jOOQ maps each *record* of the result set to a `Record` and collects
    this record in `Result`. Once `Result<Record>` is complete (the whole result set
    was processed), it can be mapped into an array, a set/list of POJOs, or a map,
    or it can be returned as it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure represents this straightforward path: JDBC result set
    | jOOQ `Result<Record>` | array/list/set/map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Processing of the JDBC ResultSet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_3.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Processing of the JDBC ResultSet
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this figure, we can fetch the result set as type-specific
    to the application's needs (for instance, `List<POJO>`), but we can fetch the
    result set directly as `Result<Record>` as well. If you come from the JPA area,
    then you may think that the jOOQ `Record` is somehow similar to JPA entities,
    but this is not true. In jOOQ, there is no equivalent of persistence context (first-level
    cache), and jOOQ doesn't perform any kind of heavy lifting on these objects such
    as state transitions and auto-flushes. Most of the time, you can use records through
    the jOOQ API directly since you'll not even need a POJO.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In jOOQ, by default, the JDBC result set is fetched into memory eagerly (all
    data projected by the current query will be stored in memory), but as you''ll
    see in [*Chapter 8*](B16833_08.xhtml#_idTextAnchor128), *Fetching and Mapping*,
    we can operate on large result sets "lazily" using `fetchLazy()` and the `Cursor`
    type. Mapping the JDBC result set to `Result<Record>` comes with multiple benefits
    of which we highlight the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a) `Result<Record>` represents non-type-safe query results, but it can also
    represent type-safe query results via `Record` specializations such as table records,
    updatable records, and degree records up to degree 22 (number 22 is derived from
    Scala – [https://stackoverflow.com/q/6241441/521799](https://stackoverflow.com/q/6241441/521799)).
  prefs: []
  type: TYPE_NORMAL
- en: b) After fully loading `Result<Record>` into memory, jOOQ frees the resources
    as early as possible. It is preferable to operate on an in-memory `Result<Record>`
    instead of operating on a JDBC result set holding open a connection to the database.
  prefs: []
  type: TYPE_NORMAL
- en: c) `Result<Record>` can be easily exported to XML, CSV, JSON, and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: d) jOOQ exposes a friendly and comprehensive API for manipulating `Result<Record>`,
    therefore, for manipulating the result set.
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ supports a few types of `Record` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.jooq.TableRecord` and `org.jooq.UpdatableRecord` (records that can be
    stored back in the database again). A `TableRecord`/`UpdatableRecord` record originates
    from a single table (or view) having a primary key. Only `UpdatableRecord`s have
    a (known to jOOQ) primary key. The jOOQ Code Generator can produce this type of
    record on our behalf – for instance (check out our previous applications), the
    `jooq.generated.tables.records` package, which contains `CustomerRecord`, `EmployeeRecord`,
    and `OfficeRecord`. All these table records have been generated via the jOOQ generator
    and are strongly typed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Record` with the purpose of providing type-safety for queries that project
    custom record types in SQL. The query can contain records originating from a single
    table or from multiple tables. jOOQ will choose the proper `Record1` ... `Record22`
    interface and will pick up the correct types to guarantee the type-safety of query
    results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This kind of type-safety is applied to records for degrees up to 22\. This also
    applies to row value expressions, subselects that are combined by a set operator
    (for example, `UNION`), `IN` predicates and comparison predicates taking subselects,
    and `INSERT` and `MERGE` statements that take type-safe `VALUES()` clauses. Beyond
    degree 22, there is no type-safety.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`org.jooq.UDTRecord` API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.jooq.EmbeddableRecord`. This topic is covered in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110),
    *Types, Converters, and Bindings*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see several examples of fetching jOOQ records.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Result<Record> via plain SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In jOOQ, plain SQL, such as an SQL string, returns an anonymous type-safe `Result<Record>`.
    Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterating `Result` is like iterating `java.util.List`. Each `Record` can be
    accessed via a comprehensive API that, among other methods, exposes more than
    10 `get()`/`getValue()` methods for retrieving values from records in a non type-safe
    manner. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to `r3`. Our example works just fine, but if the specified type
    is not the proper one for the specified column (in other words, the data type
    cannot be converted, but conversion is possible), then we'll get a jOOQ `DataTypeException`
    or, even worse, you'll silently use the results of an apparently successful conversion
    that may have an improper representation. Moreover, typos in column names or columns
    that don't exist will cause `java.lang.IllegalArgumentException`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid such unpleasant cases, from this point forward, we rely on
    classes obtained via the jOOQ Code Generator. This gives us a tremendous boost
    in productivity and a wide range of features. Hmmm, have I told you that you should
    always count on the jOOQ Code Generator? Anyway, let's continue with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Result<Record> via select()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parameter-less `select()` method of `DSLContext` results in a projection
    that includes all columns. It also produces a non-type-safe `Result<Record>`.
    This time, we use the Java-based schema produced by the jOOQ Code Generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if `Result<Record>` is non-type-safe, the values of records can be type-safely
    extracted via the jOOQ generated classes. More precisely, we use the attributes
    of the generated `Customer` class as follows (`CUSTOMER` is `static`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: One step further, we can express this non-type-safe `Result<Record>` as a type-safe
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping org.jooq.Record into a strongly-typed org.jooq.TableRecord
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we fetch data from a single table having a primary key (`CUSTOMER`), we
    can use `TableRecord` associated by jOOQ with the database table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transforming the previous non-type-safe `Result<Record>` into a type-safe one
    can be done by mapping `org.jooq.Record` into the corresponding strongly-typed
    `org.jooq.TableRecord` via the `Record.into(Table<Z> table)` method. In this case,
    the corresponding strongly-typed `org.jooq.TableRecord` is `CustomerRecord`. Check
    out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing can be done via `Record.into(Class<? extends E> type)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we can use the `CustomerRecord` getters to access the values of
    records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what happens if we enrich this query to fetch data from two (or more)
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Result<Record> via select() and join()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s enrich `ctx.select().from(CUSTOMER)` with a `JOIN` clause to fetch records
    from `CUSTOMERDETAIL` as well (there is a one-to-one relationship between `CUSTOMER`
    and `CUSTOMERDETAIL`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The values of records can be type-safely extracted from the attributes of the
    generated `Customer` and `Customerdetail` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Re-writing this non-type-safe `Result<Record>` as a type-safe one is a little
    bit verbose. Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping org.jooq.Record into a strongly-typed org.jooq.TableRecord
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transforming the previous non-type-safe `Result<Record>` into a type-safe one
    can be done via the proper `select(SelectField<T1>, SelectField<T2>...SelectField<T22>)`
    or `into(Field<T1>, Field<T2> ... Field<T22>)` method and the proper `Record[N]`
    interface, `N=1..22`. Our schema reveals that the `CUSTOMER` and `CUSTOMERDETAIL`
    tables contain a total of 15 fields, therefore, the proper `Record[N]` is `Record15`
    and we use the `select(SelectField<T1>, SelectField<T2>... SelectField<T15>)`
    counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use the `into(Field<T1>, Field<T2> ... Field<T15>)` counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we have 22 such `select()` and `into()` methods, but we need the
    one that corresponds to our records' degree.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you noticed the `Record15<…>` construction? Of course you have! It''s
    hard to miss! Besides the obvious verbosity, it is not that easy to fill up the
    data types as well. You have to identify and write down each data type of the
    fetched fields in the correct order. Fortunately, we can avoid this torturous
    step by using the Java 9 `var` keyword. Once you have practiced the examples from
    this chapter and you''ve got familiar with `Record[N]`, consider using `var` whenever
    you don''t have a good reason to manually write down `Record[N]`. On the other
    hand, if you are using Kotlin/Scala, then you can take advantage of better support
    for tuple-style data structures and rely on automatic destructuration of `Record[N]`as
    `val(a, b, c) = select(A, B, C)`. For more details, consider this example: [https://github.com/jOOQ/jOOQ/tree/main/jOOQ-examples/jOOQ-kotlin-example](https://github.com/jOOQ/jOOQ/tree/main/jOOQ-examples/jOOQ-kotlin-example).
    So far, in Java, the previous two examples can be expressed using `var` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var result = ctx.select(...);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`var result = ctx.select()...into(...);`'
  prefs: []
  type: TYPE_NORMAL
- en: The records values can be accessed in the same way via the attributes of the
    generated `Customer` and `Customerdetail` classes. But, can we access it via the
    corresponding table records?
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the two TableRecords from Record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Extracting the two individual strongly-typed `TableRecord` types (`CustomerRecord`
    and `CustomerdetailRecord`) from the denormalized `Record` can be done via the
    `Record.into(Table<Z> table)` method. I bet you didn''t think that this was possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Further, we can rely on the built-in getters of `CustomerRecord` and `CustomerdetailRecord`
    to access the corresponding values.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Result<Record> via selectFrom()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best approach for selecting, in a type-safe manner, all the columns from
    a single table into `Result<Record>` relies on the `selectFrom(table)` method.
    In this context, jOOQ returns the record type supplied with the argument table,
    therefore, it returns `TableRecord`. Check out the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, the `CustomerRecord` getters return the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: While this is really cool, please consider the following important note as well.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Don't consider that `select().from(table)`and `selectFrom(table)` are the same
    thing. The former, `select().from(table)`, returns a non-type-safe `Result<Record>`
    and we can use any clause that modifies the type of the table expression (for
    instance, `JOIN`). On the other hand, `selectFrom(table)` returns a type-safe
    `Result<TableRecord>` and doesn't permit the usage of any clause that modifies
    the type of the table expression.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's tackle ad hoc selects.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Result<Record> via ad hoc selects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ad hoc selects, we enlist the needed columns that can originate in one or
    more tables. As long as we enlist the columns explicitly and rely on Java-based
    schema, jOOQ will determine the correct types and will prepare a record of a certain
    degree. Here is an example that selects some columns from a single table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Since we have three columns, jOOQ has picked up the record of degree 3, `Record3`,
    and automatically inferred the correct Java types, `Long`, `String`, and `BigDecimal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see an example that fetches five columns originating from two
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: This time, jOOQ picked up `Record5<Long, BigDecimal, String, String, String>`.
    I think you've got the idea!
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the values of records in a type-safe manner can be done via the attributes
    of the generated classes or you can use `Record.into(Table<Z> table)` to extract
    the strongly-typed `TableRecords` and rely on the corresponding getters. But,
    pay attention that only the fields listed/projected in the query have been populated
    with values from the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Result<Record> via UDTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'UDTs are ORDBMS features formally supported by Oracle and PostgreSQL and are
    modeled by jOOQ as `UDTRecord`. Let''s consider the following UDT defined in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `MANAGER` table schema uses this type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Running the jOOQ Code Generator produces an `org.jooq.UDT` implementation named
    `EvaluationCriteria.java` (in the `jooq.generated.udt` package). Besides the `org.jooq.UDT`
    implementation, an `org.jooq.UDTRecord` implementation is also generated under
    the name `EvaluationCriteriaRecord.java` (in the `jooq.generated.udt.records`
    package).
  prefs: []
  type: TYPE_NORMAL
- en: 'Having these artifacts generated, we can write the following example that returns
    a type-safe `Result<Record>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the values of records can be done as follows. Of course, the climax
    is represented by accessing the UDT record''s values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, relying on `Record.into(Table<Z> table)` can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, accessing the values of records can be done via `getManagerEvaluation()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Well, this was a brief overview of jOOQ records. I've intentionally skipped
    `UpdatableRecord` for now since this topic is covered later in [*Chapter 9*](B16833_09.xhtml#_idTextAnchor162),
    *CRUD, Transactions, and Locking*.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When this book was written, attempting to serialize a jOOQ record to JSON/XML
    via Spring Boot default Jackson features (for instance, by returning `Record`
    from a REST controller) will result in an exception! Setting `FAIL_ON_EMPTY_BEANS=false`
    will eliminate the exception but will lead to a weird and useless result. Alternatively,
    you can return POJOs or rely on jOOQ formatting capabilities – as you''ll see
    later, jOOQ can format a record as JSON, XML, and HTML. And, let''s not forget
    the alternative of using SQL/XML or SQL/JSON features and generating the JSON
    directly in the database (see *Chapter 8*, *Fetching and Mapping*). However, if
    you really want to serialize the jOOQ record, then you can rely on `intoMap()`
    and `intoMaps()`, as you can see in the bundled code. Meanwhile, you can monitor
    the progress on this topic here: [https://github.com/jOOQ/jOOQ/issues/11889](https://github.com/jOOQ/jOOQ/issues/11889).'
  prefs: []
  type: TYPE_NORMAL
- en: The examples covered in this section are available for Maven and Gradle in the
    code bundled with the book under the name *RecordResult*.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring jOOQ query types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'jOOQ distinguishes between two main types of queries:'
  prefs: []
  type: TYPE_NORMAL
- en: DML (`INSERT`, `UPDATE`, `DELETE`, and `MERGE`, among others) and DDL (`CREATE`,
    `ALTER`, `DROP`, `RENAME`, and similar) queries that produce a modification in
    the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DQL (`SELECT`) queries that produce results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DML and DDL queries are represented in jOOQ by the `org.jooq.Query` interface,
    while DQL queries are represented by the `org.jooq.ResultQuery` interface. The
    `ResultQuery` interface extends (among others) the `Query` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following snippet of code contains two jOOQ queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'These queries can be executed via jOOQ and they return the number of affected
    rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here are two result queries: first, a plain SQL query – here, jOOQ cannot
    infer the `Record` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, a jOOQ `ResultQuery` expressed via jOOQ generated classes (notice that
    this time, jOOQ infers the number of `ResultQuery` parameters and types – since
    we fetch only `JOB_TITLE`, there is `Record1<String>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `ResultQuery` extends `Iterable`, you can just *foreach* your queries
    in PL/SQL style and do something with each record. For instance, the following
    snippet of code works like a charm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: There is no need to explicitly call `fetch()`, but you can do it. The examples
    from this section are grouped in an application named *QueryAndResultQuery*. Next,
    let's talk about the jOOQ fluent API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the jOOQ fluent API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time spent with jOOQ is about writing fluent code via the jOOQ fluent
    API. This approach is quite convenient for building fluent SQL expressions that
    avoid disrupting or chunking the code. Moreover, fluent APIs are easy to enrich
    with more operations.
  prefs: []
  type: TYPE_NORMAL
- en: Relying on a brilliant implementation of the interface-driven design concept,
    jOOQ hides most implementations from client code and acts as a *good friend* that
    is ready to listen regarding the SQL that you need to run. Let's see several usages
    of the jOOQ fluent API.
  prefs: []
  type: TYPE_NORMAL
- en: Writing fluent queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have written several SQL in the jOOQ DSL API fluent style. Let''s
    have another one as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The goal of dissecting to the bone the previous jOOQ query is far away from
    us, but let's try to have some insights about how this query is seen through jOOQ
    eyes. This will help you to quickly accumulate the information from the chapters
    that follow and will increase your confidence in jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly, a JOOQ fluent query is composed of two basic building blocks: `org.jooq.QueryPart`
    interface as a common base type. Let''s briefly cover column expressions, table
    expressions, and query steps to better understand this paragraph.'
  prefs: []
  type: TYPE_NORMAL
- en: Column expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`org.jooq.Field` interface. There are many kinds of column expressions and
    all of them can be used in a variety of SQL statements/clauses to produce fluent
    queries. For example, in the `SELECT` clause, we have `org.jooq.SelectField` (which
    is a special `org.jooq.Field` interface for `SELECT`); in the `WHERE` clause,
    we have `org.jooq.Field`; in the `ORDER BY` clause, we have `org.jooq.OrderField`;
    in the `GROUP BY` clause, we have `org.jooq.GroupField`; and in conditions and
    functions, we typically have `org.jooq.Field`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Column expressions can be arbitrary built via the jOOQ fluent API to shape
    different query parts such as arithmetic expressions (for example, `column_expression_1.mul(column_expression_2)`),
    conditions/predicates (`org.jooq.Condition`) used in `WHERE` and `HAVING` (for
    example, here is an equality condition: `WHERE(column_expression_1.eq(column_expression_2))`),
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: When column expressions refer to table columns, they are referenced as `org.jooq.TableField`.
    These kinds of column expressions are produced internally by the jOOQ Code Generator
    and you can see them in each Java class specific to a table. The instances of
    `TableField` cannot be created directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s identify the column expressions types from our query using the following
    figure, which highlights them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Identify the column expressions of this query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_3.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Identify the column expressions of this query
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have some table columns that reference the `ORDERDETAIL` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'We have some extracted as `TableField`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have an unnamed column expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Just as a quick note, here, the `DSL.val()` method simply creates `Field<Integer>`
    (gets a bind value as `Param<Integer>`, where `Param` extends `Field`) representing
    a constant value. We will discuss jOOQ parameters a little bit later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the query so far using the extracted columns expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s extract the usages of the `sum()` aggregate function. The first
    usage of `sum()` relies on a table column expression (`tc2`) to produce a function
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'The second usage of `sum()` wraps an arithmetic expression that uses two table
    column expressions (`tc3` and `tc2`), therefore, it can be extracted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'One step further, and we notice that our query uses aliases for `f1` and `f2`,
    therefore, these can be extracted as aliased expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewrite the query again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Done! At this point, we have identified all column expressions of our query.
    How about table expressions?
  prefs: []
  type: TYPE_NORMAL
- en: Table expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next to fields, tables also represent the basic building blocks of any query.
    jOOQ represents a table via `org.jooq.Table`. In our query, there is a single
    table reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be extracted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the query becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: jOOQ supports a wide range of tables not only database tables, including plain
    SQL tables, aliased tables, derived tables, **Common Table Expressions** (**CTEs**),
    temporary tables, and table-valued functions. But, we will discuss these in the
    upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, notice that we haven''t touched `uc1.lt(tc2)`. As you can probably
    intuit, this is a condition that uses two column expressions and is mapped by
    jOOQ as `org.jooq.Condition`. It can be extracted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'After extracting all these parts, we obtain the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, you could even do the following, but there is no more type-safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, these query parts can be used to form other arbitrary queries as
    well. After all, in jOOQ, we can write queries that are 100% dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: In jOOQ, even when they look like static queries (due to jOOQ's API design),
    every SQL is dynamic, therefore, it can be broken up into query parts that can
    be fluently glued back in any valid jOOQ query. We'll talk about more examples
    later when we'll tackle dynamic filters.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's quickly get an overview of the query steps topic.
  prefs: []
  type: TYPE_NORMAL
- en: Query steps (SelectFooStep, InsertFooStep, UpdateFooStep, and DeleteFooStep)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Continuing to identify the remaining query parts, we have `select`, `from`,
    `where`, `groupBy`, and `orderBy`. These parts are logically chained to form our
    query and are represented by jOOQ as query steps. There are many types of query
    steps, but the ones used by our query can be decomposed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, the ones used as type-safe steps are as follows (remember, you can use
    Java 9 `var` instead of `SelectSelectStep<Record3<Short, BigDecimal, BigDecimal>>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the last line of this snippet of code. We return the generated valid
    SQL as a plain string without executing this query. Execution can happen in the
    presence of a connection to the database, therefore, we need `DSLContext` configured
    to accomplish this task. If we have injected `DSLContext`, then all we need to
    do is to use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'This `SelectSelectStep` contains an internal reference to the `DSLContext`
    configuration, therefore, we can replace the last line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is available for Maven and Gradle in the code bundled with
    this book under the name `FluentQueryParts`. While in this section, you saw how
    to decompose the query steps, keep in mind that it's almost always a better choice
    to rely on dynamic SQL queries than referencing these step types. So, as a rule
    of thumb, *always* try to avoid assigning or referencing the query steps directly.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, decomposing a query into parts is not a day-to-day task. Most of
    the time, you'll just use the fluent API, but there are cases when it is nice
    to know how to do it (for instance, it can be helpful for writing dynamic filters,
    referencing aliases in different places of a query, re-using a query part in multiple
    places, and writing correlated subqueries).
  prefs: []
  type: TYPE_NORMAL
- en: Another use of the jOOQ fluent API is focused on the `DSLContext` creation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DSLContext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most probably, in Spring Boot applications, we'll prefer to inject the default
    `DSLContext` as you saw in [*Chapter 1*](B16833_01.xhtml#_idTextAnchor015), *Starting
    jOOQ and Spring Boot*, and [*Chapter 2*](B16833_02.xhtml#_idTextAnchor024), *Customizing
    the jOOQ Level of Involvement*. But, in certain scenarios (for instance, wrapping
    and running a specific query with a custom setting, rendering an SQL in a different
    dialect than the default one, or needing to trigger an occasional query against
    a database that is not configured in Spring Boot), we'll prefer to use `DSLContext`
    as a local variable. This can be done in fluent style via the `DSL.using()` methods
    as in the following non-exhaustive list of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DSLContext from a data source and a dialect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having `DataSource` (for instance, injected in your repository), we can create
    `DSLContext` and execute a query in fluent style as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: This example relies on the `DSL.using(DataSource datasource, SQLDialect dialect)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DSLContext from a data source, a dialect, and some settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enabling/disabling some settings to the previous example requires us to instantiate
    `org.jooq.conf.Settings`. This class exposes a comprehensive fluent API (via the
    `withFoo()` methods) that influences the way jOOQ renders SQL code. For instance,
    the following snippet of code inhibits the rendering of the schema name (just
    look at this nice piece of fluent code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: This example relies on the `using(DataSource datasource, SQLDialect dialect,
    Settings settings)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Alter a setting of the injected DSLContext
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example, we created `DSLContext` that doesn''t render the schema
    name. This setting is applied to all usages of the created `DSLContext`, or in
    other words, to all queries triggered under the configuration of this `DSLContext`.
    How can we do the same thing for the default `DSLContext` provided by Spring Boot
    after it was injected into a repository? The following code provides the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Mainly, we access the current configuration of the injected `DSLContext` via
    `configuration()`, we set our setting, and call the `dsl()` method to get access
    back to `DSLContext`. Notice that from this point forward, all usages of `ctx`
    will not render the schema name unless you don''t enable it again. If you prefer
    to use some specific settings for a certain query, then create `DSLContext` derived
    from the injected one via `derive()` in place of `set()`. This way, the original
    `DSLContext` remains unaltered and you can operate on the derived one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: So, in the previous example, `ctx` remains unchanged and jOOQ uses a derived
    `DSLContext`, which will not render the schema name.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DSLContext from a connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating `DSLContext` from a connection and executing the query in fluent style
    can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: In such cases, we have to close the connection manually; therefore, we have
    used the `try-with-resources` technique. This example relies on the `DSL.using(Connection
    c)` method. If you want to specify the SQL dialect as well, then try out `DSL.using(Connection
    c, SQLDialect d)`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DSLContext from a URL, user, and password
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For standalone-based scripts, where handling resources is not important since
    the connection lives as long as the script itself, we can rely on `DSL.using(String
    url)`, `DSL.using(String url, Properties properties)`, and `DSL.using(String url,
    String user, String password)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to use the `DSL.using(String url, String user, String password)`
    method (or any of the other two) prior to jOOQ 3.14, then you have to explicitly
    close the connection as well. This can be done by explicitly calling `DSLContext.close()`
    or by using `try-with-resources`. Starting with jOOQ 3.14, these overloads of
    `DSL.using()` will produce the new `CloseableDSLContext` type that allows us to
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's see how to use `DSLContext` without a database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering SQL in a certain dialect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rendering SQL in a certain dialect (here, MySQL) can be done via this fluent
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Since there is no connection or data source, there is no interaction with the
    database. The returned string represents the generated SQL specific to the provided
    dialect. This example relies on the `DSL.using(SQLDialect dialect)` method.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all these examples in the code bundled with this book under the
    name *CreateDSLContext*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Lambdas and streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The jOOQ fluent API and Java 8 Lambdas and streams make a perfect team. Let's
    look at several examples that demonstrate this.
  prefs: []
  type: TYPE_NORMAL
- en: Using Lambdas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For instance, jOOQ comes with a functional interface named `RecordMapper` used
    for mapping a jOOQ record to a POJO. Let''s assume that we have the following
    POJOs. First, let''s assume we have `EmployeeName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s assume we have `EmployeeData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s assume that we have the following plain SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing and mapping this plain SQL is achievable via the `fetch(String sql)`
    flavor and `map(RecordMapper<? super R,E> rm)` as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing is applicable if the plain SQL is expressed via the Java-based
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also applicable if it is more concisely expressed via `fetch(RecordMapper<?
    super R,E> rm)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'If you think that these mappings are too simple for using a custom `RecordMapper`,
    then you are right. You''ll see more proper cases for custom record mappers later
    on when we''ll detail mappings. For this case, both of them can be solved via
    the built-in `into()` and `fetchInto()` methods by simply enriching the SQLs with
    hints via aliases. First, we can enrich the plain SQL (for MySQL, we use backticks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we can enrich the jOOQ SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Let's see a few more examples of using Lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet of code prints all sales. Since `selectFrom()` returns
    the record type supplied with the argument table, this code prints each `SaleRecord`
    (notice that calling `fetch()` is optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'Mapping the result set (`SaleRecord`) to `List<Double>` containing only the
    `sale` column can be done as follows via `fetch().map(RecordMapper<? super R,E>
    rm)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it can be done via `fetch(RecordMapper<? super R,E> rm)` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be done via a Lambda expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it can even be done via an anonymous record mapper as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's see how the jOOQ fluent API can be used with the Java Stream fluent
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Stream API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the jOOQ fluent API and the Stream fluent API as an apparently single
    fluent API is straightforward. Let''s assume that we have this POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: 'A plain SQL can obtain a `SaleStats` instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if we use the Java-based schema, then this code can be re-written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: It looks like the jOOQ fluent API and the Stream fluent API work together like
    a charm! All we have to do is call the `stream()` method after `fetch()`. While
    `fetch()` fetches the entire result set into memory, `stream()` opens a stream
    on this result set. Fetching the entire result set into memory via `fetch()`allows
    the JDBC resources (for instance, the connection) to be closed before streaming
    the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, besides `stream()`, jOOQ also exposes a method named `fetchStream()`,
    which is tackled later in the chapter, dedicated to lazy loading next to other
    specific topics. As a quick hint, keep in mind that `fetch().stream()` and `fetchStream()`
    are not the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: The examples from this section are grouped in the *FunctionalJooq* application.
  prefs: []
  type: TYPE_NORMAL
- en: Fluent programmatic configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, you already had a flavor of constructing the Code
    Generator configuration via the programmatic fluent API. The following snippet
    of code is just another example of the jOOQ `Settings` fluent API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: These are not the only cases when the jOOQ fluent API rocks. For instance, check
    the jOOQ JavaFX application for creating a bar chart from a jOOQ `result`. This
    is available in the jOOQ manual.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how jOOQ emphasizes that our fluent code should respect the
    SQL syntax correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting that jOOQ emphasizes SQL syntax correctness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the coolest features of jOOQ consists of the fact that jOOQ doesn't allow
    us to write bad SQL syntax. If you aren't an SQL expert or simply have issues
    with SQL-specific syntax, then all you have to do is to let jOOQ guide you step
    by step.
  prefs: []
  type: TYPE_NORMAL
- en: Having a fluent API for chaining methods to obtain a SQL is cool, but having
    a fluent API that emphasizes SQL syntax correctness is the coolest. jOOQ knows
    exactly how the query parts fit the puzzle and will help you via your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s assume that we *accidentally* wrote the following bad
    SQLs. Let''s start with an SQL that misses the `ON` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'The IDE signals this issue immediately, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Wrong SQL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_3.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Wrong SQL
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with another wrong SQL that uses `JOIN` in an improper place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: 'And, for the last example, let''s look at a wrong SQL that misses `over()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we can continue like this forever, but I think you get the idea!
    So, count on jOOQ!
  prefs: []
  type: TYPE_NORMAL
- en: Casting, coercing, and collating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ was designed to handle most of the casting issues under the hood, including
    for ultra-strong-typed databases such as DB2\. Nevertheless, explicit casting
    and/or coercing still serve some isolated cases. Most probably, we'll need them
    when we are not satisfied with the jOOQ automatic mapping (for instance, we consider
    that jOOQ didn't find the most accurate mapping), or we just need a certain type
    to respond to a special case. Even if they add a little bit of verbosity, casting
    and coercing can be used fluently; therefore, the DSL expressions are not disrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time, jOOQ finds the most accurate data type mapping between the
    database and Java. If we look into a jOOQ generated class that mirrors a database
    table, then we see that, for each column that has a database-specific type (for
    example, `VARCHAR`), jOOQ has found a Java type correspondent (for example, `String`).
    If we compare the schema of the `PAYMENT` table with the generated `jooq.generated.tables.Payment`
    class, then we find the following data type correspondence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Type mapping between the database and Java'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_3.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Type mapping between the database and Java
  prefs: []
  type: TYPE_NORMAL
- en: 'When the jOOQ mapping is not what we need or jOOQ cannot infer a certain type,
    then we can rely on the jOOQ casting API, which contains the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides these methods, the `DSL` class contains these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have some examples against MySQL and let''s start with the following
    query that maps the fetched data to the Java types that jOOQ has automatically
    chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `INVOICE_AMOUNT` is mapped to `BigDecimal`, and `CACHING_DATE` is mapped
    to `LocalDateTime`. Let''s assume that we are in a corner-case scenario that requires
    us to fetch `INVOICE_AMOUNT` as `String` and `CACHING_DATE` as `LocalDate`. Of
    course, we can loop the preceding result and perform the conversions of each record
    in Java, but, at the query level, we can accomplish this via jOOQ `cast()`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the SQL string generated after using `cast()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following figure, you can see the result set returned by these two SQLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Casting results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_3.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Casting results
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the jOOQ casting operations are rendered in the generated SQL string,
    therefore, the database is responsible for performing these casts. But, in this
    scenario, do we really need these clumsy castings or do we actually need data
    type coercions?
  prefs: []
  type: TYPE_NORMAL
- en: Coercing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data type coercions act like casting, except that they have no footprint on
    the actual SQL query being generated. In other words, data type coercions act
    as an unsafe cast in Java and are not rendered in the SQL string. With data type
    coercions, we only instruct jOOQ to pretend that a data type is of another data
    type and to bind it accordingly. Whenever possible, it is preferable to use coercions
    over casting. This way, we don''t risk casting issues and we don''t pollute the
    generated SQL with unnecessary castings. The API consists of several methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides these methods, the `DSL` class contains these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example from the *Casting* section, we relied on casting from `BigDecimal`
    to `String` and from `LocalDateTime` to `LocalDate`. This casting was rendered
    in the SQL string and was performed by the database. But, we can avoid polluting
    the SQL string with these casts via coercion as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: 'The produced result set is the same as in the case of using casting, but the
    SQL string doesn''t reflect coercions and the database didn''t perform any casting
    operations. This is much better and safer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with version 3.12, jOOQ allows for coercing `ResultQuery<R1>` to a
    new `ResultQuery<R2>` type as well. For instance, check out this plain SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: 'The result type of this query is `Result<Record>` but we can easily replace
    `fetch()` with `fetchInto()` to map this result to the generated `Employee` POJO
    (only the `firstName` and `lastName` fields will be populated) or to a custom
    POJO containing only the fetched fields. But, how about fetching `Result<Record2<String,
    String>>`? This can be accomplished via one of the `ResultQuery.coerce()` flavors
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: Coercing a result set to a table can be done via `ResultQuery.coerce(Table<X>
    table)`. You can find an example in the bundled code next to an alternative before
    jOOQ 3.12\. If during coercing, jOOQ finds any `Converter` or `Binding` configurations,
    then it will apply them (this is covered in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110),
    *Types, Converters, and Bindings*).
  prefs: []
  type: TYPE_NORMAL
- en: Coercing versus casting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Don''t conclude that `coerce()` can replace `cast()` all the time. Check out
    this example that uses `coerce()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: So, we pretend that `BUY_PRICE` is `BigDecimal` having a precision of *10* and
    a scale of `5`, and `PRODUCT_DESCRIPTION` is a string of length *10*. But, coercing
    cannot do that. In this case, coercing can pretend the `BigDecimal` (`BUY_PRICE`
    is really treated as a `BigDecimal` value), and `String` (`PRODUCT_DESCRIPTION`
    is really treated as a `String` value) types, but it cannot pretend the domain
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s replace `coerce()` with `cast()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, casting is rendered in the generated SQL string. The following figure
    compares the result of using `coerce()` and `cast()`; this works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Coercing versus casting (1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_3.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Coercing versus casting (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have one more example. Check out this example that uses `coerce()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '`PAYMENT.PAYMENT_DATE` is a timestamp, therefore, it is not enough to pretend
    that it is a date since the time component will fail our predicate. For instance,
    *2003-04-09 09:21:25* is not equal to *2003-04-09*. In this case, we need an actual
    cast from timestamp to date as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the cast takes place via this SQL (for *2003-04-09*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure compares the results of using `coerce()` and `cast()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Coercing versus casting (2)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_3.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Coercing versus casting (2)
  prefs: []
  type: TYPE_NORMAL
- en: Another good example where cast works and coerce does not is when the cast is
    performed in `GROUP BY`, which isn't uncommon when grouping timestamp columns
    by `CAST(ts AS DATE)`. Also, when the value being cast is an expression, not a
    bind variable, the effect is different (although coerce can be used to compare,
    for instance, `INTEGER` columns with `BIGINT` columns without the database needing
    to convert anything).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, in some cases when both could work (for instance, when you
    project the expressions), it is best to use `coerce()` rather than `cast()`. This
    way, you don't risk unsafe or raw-type casting in Java and you don't pollute the
    generated SQL with unnecessary castings.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss collations.
  prefs: []
  type: TYPE_NORMAL
- en: Collation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Databases define a character set as a set of symbols and encodings. A collation
    defines a set of rules for comparing (ordering) characters in a character set.
    jOOQ allows us to specify a collation via `collation``(Collation collation)` for
    `org.jooq.DateType` and via `collate``(String collation)`, `collate``(Collation
    collation)`, and `collate``(Name collation)` for `org.jooq.Field`. Here is an
    example of setting the `latin1_spanish_ci` collation for a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: All the examples from this section are available in the *CastCoerceCollate*
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Binding values (parameters)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binding values is another fundamental topic of jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: The well-known prepared statements and bind values combination is the preferable
    approach to express SQL statements in JDBC. Among benefits, this combination provides
    protection against SQL injections, sustains caching (for instance, most connection
    pools cache prepared statements across connections or rely on JDBC driver caching
    capabilities as HikariCP does), and reusability capabilities (re-using execution
    plans for identical SQL statements, regardless of actual bind values).
  prefs: []
  type: TYPE_NORMAL
- en: Having security and performance packed into this combination makes it preferable
    against static statements (`java.sql.Statement`) and inlined values, so jOOQ also
    embraces it as default.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, jOOQ aligns its support for bind values to JDBC style. In other
    words, jOOQ relies on `java.sql.PreparedStatement` and indexed bind values or
    indexed parameters. Moreover, exactly like JDBC, jOOQ uses a `?` (question mark)
    character for marking the bind value placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: However, in contrast to JDBC, which supports only indexed parameters and the
    `?` character, jOOQ supports named and inlined parameters as well. Each of them
    is detailed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in JDBC, the only way to exploit bind values aligns to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: In other words, in JDBC, it is our responsibility to keep track of the number
    of question marks and their corresponding index. This becomes cumbersome in complex/dynamic
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: As Lukas Eder highlights, "*The strength of languages such as L/SQL, PL/pgSQL,
    T-SQL (among other things) is precisely the fact that prepared statements can
    naturally embed bind values transparently, without the user having to think about
    the binding logic*."
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how jOOQ tackles bind values via indexed bind values or indexed
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Indexed parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing the previous query via jOOQ''s DSL API can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if it looks like we''ve inlined the values (*5000* and *Sales Rep*), this
    is not true. jOOQ abstracts away the JDBC frictions and allows us to use indexed
    parameters exactly where needed (directly in SQL). Since jOOQ takes care of everything,
    we don''t even care about the indexes of the parameters. Moreover, we take advantage
    of type-safety for these parameters and we don''t need to explicitly set their
    type. The preceding SQL renders the following SQL string (notice the rendered
    question marks as bind values placeholders):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: 'And, after jOOQ resolves the bind values, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: 'Behind the scene, jOOQ uses a method named `DSL.val(value)` for transforming
    the given `value` argument (`value` can be `boolean`, `byte`, `String`, `float`,
    `double`, and so on) into a bind value. This `DSL.val()` method wraps and returns
    a bind value via the `org.jooq.Param` interface. This interface extends `org.jooq.Field`,
    therefore, extends a column expression(or field) and can be used accordingly via
    the jOOQ API. The previous query can also be written by explicitly using `DSL.val()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: But, as you just saw, using `val()` explicitly is not needed in this case. Using
    `val()` like this is just adding noise to the SQL expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this query, we''ve used hardcoded values, but, most probably, these values
    represent user inputs that land in the query via the arguments of the method containing
    this query. Check out this example, which extracts these hardcoded values as arguments
    of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: Of course, mixing hardcoded and user input values in the same query is supported
    as well. Next, let's tackle a bunch of examples where the explicit usage of `val()`
    is really needed.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit usage of val()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are cases when we cannot pass plain values to jOOQ and expect back bind
    values. There are a few such cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When the bind value is at the left-hand side of an operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `Field` references and `Param` values are mixed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the bind value occurs in a clause that doesn't support it (for instance, in
    `select()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When functions require a `Field<T>` type for one of the parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Bind value is at the left-hand side of an operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Having the plain value at the left-hand side of an operator doesn''t allow
    us to write the needed jOOQ expression since we don''t have access to the jOOQ
    DSL API. For instance, we cannot write `...5000.eq(EMPLOYEE.SALARY)` since the
    `eq()` method is not available. On the other hand, we should write `...val(5000).eq(EMPLOYEE.SALARY)`.
    This time, *5000* is wrapped in `Param` (which extends `Field`) via `val(int/Integer
    value)` and we can continue to exploit the jOOQ DSL API, such as the `eq()` method.
    Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example where the value is a user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's see the other case, when `Field` references and `Param` values are
    mixed.
  prefs: []
  type: TYPE_NORMAL
- en: Field references and Param values are mixed
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s consider that we want to use the `DSL.concat(Field<?>... fields)` method
    for concatenating `CUSTOMER.CONTACT_FIRST_NAME`, the whitespace literal (`" "`),
    and `CUSTOMER.CONTACT_LAST_NAME` (for example, *Joana Nimar*). While `CONTACT_FIRST_NAME`
    and `CONTACT_LAST_NAME` are fields, the whitespace literal (`" "`) cannot be used
    in this context as a plain string. But, it can be wrapped in `Param` via the `val()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that mixes the jOOQ internal usage of `val()` and our
    explicit usage of `val()` for wrapping a user input value to add it as a column
    in the result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of mixing implicit and explicit `val()` usage for writing
    a simple arithmetic expression, *mod((((10 - 2) * (7 / 3)) / 2), 10)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'When the same parameter is used multiple times, it is advisable to extract
    it as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: While we take care of the `salary` value, jOOQ will take care of the *0.15*
    and *10000* constants. All three will become indexed bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Bind values from string query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If, for some reason, you want to bind values directly from a string query,
    then you can do it via plain SQL as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's talk about the named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Named parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While JDBC support is limited to indexed bind values, jOOQ goes beyond this
    limit and supports named parameters as well. Creating a jOOQ named parameter is
    accomplished via the `DSL.param()` methods. Among these methods, we have `param(String
    name, T value)`, which creates a named parameter with a name and an initial value.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the values of named parameters being provided as user
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: 'While rendering the SQL of the previous queries, you have observed that jOOQ
    doesn''t render the names of these parameters as placeholders. It still renders
    a question mark as the default placeholder. To instruct jOOQ to render the names
    of the parameters as placeholders, we call via the `DSL.renderNamedParams()` method
    that returns a string, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, we can specify a string to be used as a prefix for each rendered named
    parameter via `Settings.withRenderNamedParamPrefix()`. You can see an example
    in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned string can be passed to another SQL access abstraction that supports
    named parameters. For this example, the rendered SQL string is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's talk about the inline parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Inline parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An inline bind value is rendered as the actual plain value via `DSL.inline()`.
    In other words, while indexed and named parameters render the bind values as placeholders
    via question marks (or names), inline parameters render their plain values directly.
    jOOQ automatically replaces the placeholders (`?` or `:name` for named parameters)
    and will properly escape inline bind values to avoid SQL syntax errors and SQL
    injection. Nevertheless, be warned that abusing the usage of the inline parameters
    may lead to poor performance on RDBMSs that have execution plan caches. So, avoid
    copying and pasting `inline()` everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, using `inline()` for constants is a good practice. For instance,
    earlier, we used `val(" ")` to express `concat(CUSTOMER.CONTACT_FIRST_NAME, val("
    "), CUSTOMER.CONTACT_LAST_NAME))`. But, since the `" "` string is a constant,
    it can be inlined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: But, if you know that this is not a constant, then it is better to rely on `val()`
    to sustain execution plan caches.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the `Configuration` level, we can use inline parameters by switching from
    the `PreparedStatement` default to a static `Statement` via jOOQ settings. For
    example, the following `DSLContext` will use static statements, and all queries
    triggered in the context of this configuration will use inline parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, another option is to rely on `inline()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the inlined values can be user inputs as well. But, this technique
    is not recommended since user inputs may vary across executions and this will
    affect the performance of RDBMSs that rely on execution plan caches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous two examples render the same SQL having the actual plain values
    inlined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: 'Globally, we can choose the type of parameters via `Settings`, as here (indexed
    parameters (`ParamType.INDEXED`) are used by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, here is the global setting for using static statements and inline parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's see a handy approach to rendering a query with different types of
    parameter placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a query with different types of parameter placeholders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a query that uses indexed parameters and we need
    to render it as a certain SQL string having a different type of parameter placeholder
    (for instance, this may be required by another SQL abstraction):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: 'A handy approach for rendering this query with a different type of parameter
    placeholder relies on the `Query.getSQL(ParamType)` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParamType.INDEXED` (in this example, this is the default behavior):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: '`ParamType.NAMED` (for parameters with names, this produces placeholders of
    the`:name` type, but for unnamed parameters, it produces `:1`, `:2`, to `:n`,
    therefore, a combination of colon and index):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: '`ParamType.INLINED` and `ParamType.NAMED_OR_INLINED`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `ParamType.INLINED` and `ParamType.NAMED_OR_INLINED` produce the
    same output – inlined plain values. Actually, `ParamType.NAMED_OR_INLINED` generates
    named parameter placeholders only for parameters that are named explicitly, otherwise,
    it inlines all unnamed parameters. You can see more examples in the code bundled
    with the book.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how we can extract jOOQ parameters from the query as `List<Object>`.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting jOOQ parameters from the query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Accessing all types of supported parameters of a query can be accomplished
    via `Query.getParams()`, while accessing a single parameter can be done by index
    via `Query.getParam()`, as in the following example, which uses indexed parameters
    (the same approach can be used for inlined parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use named parameters, then those names can be used in place of indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: As you'll see soon, parameters can be used to set new binding values. Next,
    let's see how we can extract indexed and named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting binding values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a parameter, we can extract its underlying bind value via `getValue()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, extracting all the query bind values for indexed and named parameters
    without interacting with `Param` can be done via `getBindValues()`. This method
    returns `List<Object>` containing all the bind values of the query represented
    as a query or any of its subinterfaces such as `ResultQuery`, `Select`, and so
    on. Here is an example for indexed parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here is an example for named parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: In both examples, the returned list will contain two bind values, [*5000* and
    *Sales Rep*]. For inline parameters, `getBindValues()` returns an empty list.
    This is happening because, unlike `getParams()`, which returns all types of supported
    parameters, `getBindValues()` returns only actual bind values that render an actual
    placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the extracted binding values in another SQL abstraction, such as
    `JdbcTemplate` or JPA. For instance, here is `JdbcTemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: Setting new bind values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must start this section with the following important note.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to jOOQ documentation, starting with version 4.0, jOOQ plans to make
    the `Param` class immutable. Modifying `Param` values is strongly discouraged;
    therefore, use the information from this section carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, modifying bind values via `Param` was still possible when this
    book was written. For instance, the following example executes an SQL with an
    initial set of bind values, sets new bind values, and executes the query again.
    Setting new bind values is done via the deprecated `setConverted()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Query` interface also allows for setting new bind values directly, without
    explicitly accessing the `Param` type via the `bind()` method as follows (if there
    are named parameters that refer to them via their names instead of indexes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: Nevertheless, behind the scene, `bind()` works via `Param.setConverted()`.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience (but, not required), notice that both examples take advantage
    of the fact that a `PreparedStatement` can be reused with different bind values.
    First, we ask jOOQ to keep the statement open via `keepStatement(true)`. Second,
    the `Query` becomes like a resource that must be closed via `Query.close()` or
    in a `try-with-resources` statement.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of inline parameters, jOOQ will automatically close any underlying
    `PreparedStatement` in order for new bind values to have an effect; therefore,
    there is no use in keeping the statements open. The code is straightforward and
    is available in the code bundled with the book.
  prefs: []
  type: TYPE_NORMAL
- en: Named/unnamed parameters with no initial value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While in the previous examples the parameters have an initial value that was
    modified later, jOOQ also supports named/unnamed parameters with no initial value.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a named parameter without providing an initial value at its creation,
    then you may need one of the following `DSL.param()` flavors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `DSL.param(String name)` that returns `Param<Object>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of creating a named parameter with a defined class type
    and no initial value via `param(String name, Class<T> type)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we create a named parameter with a defined data type and no initial
    value via `param(String name, DataType<T> type)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we can create a named parameter with a defined type of another field and
    no initial value via `param(String name, Field<T> type)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also keep a reference to a named parameter having an initial value (for
    instance, just to not lose the generic type, `<T>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: In addition, jOOQ supports unnamed parameters without initial values but with
    a defined type. We can create such parameters via `param(Class<T> class)`, `param(DataType<T>
    dataType)`, and `param(Field<T> field)`.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we can create a parameter without a name and initial value with a
    generic type (`Object`/`SQLDataType.OTHER`) via `param()`. You can find examples
    in the code bundled with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering unnamed parameters via `Query` with `renderNamedParams()` results
    in rendering the positions of parameters starting with 1, such as `:1`, `:2`,
    to `:n`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, jOOQ still supports modifying binding values, but `setValue()`and
    `setConverted()` are deprecated and probably removed starting with version 4.0
    when jOOQ plans to make `Param` immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, pay attention to `param()` and `param(String name)`. As a rule of thumb,
    avoid these methods if you are using any of the following dialects: SQLDialect.DB2,
    DERBY, H2, HSQLDB, INGRES, and SYBASE. These dialects may have trouble inferring
    the type of the bind value. In such cases, prefer `param()` flavors that explicitly
    set a type of the bind value.'
  prefs: []
  type: TYPE_NORMAL
- en: All the examples from this section are available in the *BindingParameters*
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a comprehensive chapter, which covered several fundamental aspects
    of jOOQ. So far, you have learned how to create `DSLContext`, how the jOOQ fluent
    API works, how to deal with jOOQ `Result` and `Record`, how to tackle edge cases
    of casting and coercing, and how to use bind values. As a rule of thumb, having
    these fundamentals under your tool belt is a major advantage that helps you to
    make the correct and optimal decisions and will be a great support in the next
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss alternatives for building a DAO layer and/or
    evolving the jOOQ-generated DAO layer.
  prefs: []
  type: TYPE_NORMAL
