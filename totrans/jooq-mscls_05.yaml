- en: '*Chapter 3*: jOOQ Core Concepts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：jOOQ核心概念'
- en: Before exploring more awesome features of jOOQ, we have to cover the core (fundamental)
    concepts that jOOQ relies on. Having a decent insight into jOOQ core concepts
    helps us to make the right decisions and to understand how jOOQ works under the
    hood. Don't worry, our aim is not to enter the jOOQ bowels! We aim to bring you
    close to the jOOQ paradigm and start thinking about your persistent layer in the
    jOOQ context.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索jOOQ更多精彩功能之前，我们必须了解jOOQ所依赖的核心（基本）概念。对jOOQ核心概念的深入理解有助于我们做出正确的决策，并理解jOOQ在底层是如何工作的。别担心，我们的目标不是深入jOOQ的内部！我们的目标是让你接近jOOQ范式，并开始从jOOQ的上下文考虑你的持久层。
- en: 'The goal of this chapter is to briefly introduce the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是简要介绍以下主题：
- en: Hooking jOOQ results (`Result`) and records (`Record`)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩接jOOQ结果（`Result`）和记录（`Record`）
- en: Exploring jOOQ query types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索jOOQ查询类型
- en: Understanding the jOOQ fluent API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解jOOQ流畅API
- en: Highlighting how jOOQ emphasizes SQL syntax correctness
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调jOOQ如何强调SQL语法的正确性
- en: Casting, coercing, and collating
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换、强制转换和比较
- en: Binding values (parameters)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定值（参数）
- en: By the end of this chapter, you'll be familiar with the jOOQ core concepts that
    will help you to easily follow the upcoming chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉jOOQ核心概念，这些概念将帮助你轻松地跟随接下来的章节。
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter03](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter03).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter03](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter03)。
- en: Hooking jOOQ results (Result) and records (Record)
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩接jOOQ结果（Result）和记录（Record）
- en: 'In the previous chapters, we''ve mapped the JDBC result set of our queries
    to POJOs via the jOOQ `fetchInto()` method. But, in jOOQ, between the JDBC result
    set and a well-known `List<POJO>` (or other data structure such as an array, map,
    and set), there is another fundamental layer referenced as `Result<Record>` represented
    from the following two interfaces:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经通过jOOQ的`fetchInto()`方法将我们的查询的JDBC结果集映射到POJOs。但是，在jOOQ中，在JDBC结果集和众所周知的`List<POJO>`（或其他数据结构，如数组、映射和集合）之间，还有一个被称为`Result<Record>`的基本层，它由以下两个接口表示：
- en: '`org.jooq.Record`: When we trigger a `SELECT` query, we get back a result set
    that contains a list of columns and the corresponding list of values. Typically,
    we refer to the content of the result set as *records*. jOOQ maps each such *record*
    to its `Record` interface. Think of `Record` as the jOOQ internal representation
    of *records*.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.jooq.Record`：当我们触发一个`SELECT`查询时，我们得到一个包含列列表和相应值列表的结果集。通常，我们将结果集的内容称为*记录*。jOOQ将每个这样的*记录*映射到其`Record`接口。将`Record`视为jOOQ对*记录*的内部表示。'
- en: '`org.jooq.Result`: The jOOQ `Result` interface is a `java.util.List` of `org.jooq.Record`.
    In other words, jOOQ maps each *record* of the result set to a `Record` and collects
    this record in `Result`. Once `Result<Record>` is complete (the whole result set
    was processed), it can be mapped into an array, a set/list of POJOs, or a map,
    or it can be returned as it is.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.jooq.Result`：jOOQ的`Result`接口是一个`java.util.List`的`org.jooq.Record`。换句话说，jOOQ将结果集的每个*记录*映射到`Record`，并将此记录收集到`Result`中。一旦`Result<Record>`完成（整个结果集已处理），它可以映射到数组、集合/列表的POJOs、映射，或者可以按原样返回。'
- en: 'The following figure represents this straightforward path: JDBC result set
    | jOOQ `Result<Record>` | array/list/set/map:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下图表示这条直接路径：JDBC结果集 | jOOQ `Result<Record>` | 数组/列表/集合/映射：
- en: '![Figure 3.1 – Processing of the JDBC ResultSet'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – JDBC ResultSet的处理'
- en: '](img/B16833_Figure_3.1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_3.1.jpg)'
- en: Figure 3.1 – Processing of the JDBC ResultSet
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – JDBC ResultSet的处理
- en: As you can see from this figure, we can fetch the result set as type-specific
    to the application's needs (for instance, `List<POJO>`), but we can fetch the
    result set directly as `Result<Record>` as well. If you come from the JPA area,
    then you may think that the jOOQ `Record` is somehow similar to JPA entities,
    but this is not true. In jOOQ, there is no equivalent of persistence context (first-level
    cache), and jOOQ doesn't perform any kind of heavy lifting on these objects such
    as state transitions and auto-flushes. Most of the time, you can use records through
    the jOOQ API directly since you'll not even need a POJO.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这张图中可以看到，我们可以根据应用程序的需求以特定类型获取结果集（例如，`List<POJO>`），但也可以直接以`Result<Record>`获取结果集。如果您来自JPA领域，那么您可能会认为jOOQ的`Record`与JPA实体有些相似，但这并不正确。在jOOQ中，没有持久化上下文（一级缓存）的等价物，jOOQ也不会对这些对象执行任何重负载操作，如状态转换和自动刷新。大多数时候，您可以直接通过jOOQ
    API使用记录，因为您甚至不需要POJO。
- en: Important Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'In jOOQ, by default, the JDBC result set is fetched into memory eagerly (all
    data projected by the current query will be stored in memory), but as you''ll
    see in [*Chapter 8*](B16833_08.xhtml#_idTextAnchor128), *Fetching and Mapping*,
    we can operate on large result sets "lazily" using `fetchLazy()` and the `Cursor`
    type. Mapping the JDBC result set to `Result<Record>` comes with multiple benefits
    of which we highlight the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中，默认情况下，JDBC结果集会积极加载到内存中（当前查询投影的所有数据都将存储在内存中），但正如您将在[*第8章*](B16833_08.xhtml#_idTextAnchor128)中看到的，“获取和映射”，我们可以使用`fetchLazy()`和`Cursor`类型“懒惰”地操作大型结果集。将JDBC结果集映射到`Result<Record>`带来了多项好处，以下是我们强调的：
- en: a) `Result<Record>` represents non-type-safe query results, but it can also
    represent type-safe query results via `Record` specializations such as table records,
    updatable records, and degree records up to degree 22 (number 22 is derived from
    Scala – [https://stackoverflow.com/q/6241441/521799](https://stackoverflow.com/q/6241441/521799)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: a) `Result<Record>`表示非类型安全的查询结果，但它也可以通过`Record`特殊化（如表记录、可更新记录和度记录，最高到22度（数字22来自Scala
    – [https://stackoverflow.com/q/6241441/521799](https://stackoverflow.com/q/6241441/521799)））来表示类型安全的查询结果。
- en: b) After fully loading `Result<Record>` into memory, jOOQ frees the resources
    as early as possible. It is preferable to operate on an in-memory `Result<Record>`
    instead of operating on a JDBC result set holding open a connection to the database.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: b) 在将`Result<Record>`完全加载到内存后，jOOQ会尽早释放资源。在内存中操作`Result<Record>`比在保持数据库连接的JDBC结果集上操作更可取。
- en: c) `Result<Record>` can be easily exported to XML, CSV, JSON, and HTML.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: c) `Result<Record>`可以轻松导出为XML、CSV、JSON和HTML。
- en: d) jOOQ exposes a friendly and comprehensive API for manipulating `Result<Record>`,
    therefore, for manipulating the result set.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: d) jOOQ提供了一个友好且全面的API来操作`Result<Record>`，因此，用于操作结果集。
- en: 'jOOQ supports a few types of `Record` as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ支持以下几种类型的`Record`：
- en: '`org.jooq.TableRecord` and `org.jooq.UpdatableRecord` (records that can be
    stored back in the database again). A `TableRecord`/`UpdatableRecord` record originates
    from a single table (or view) having a primary key. Only `UpdatableRecord`s have
    a (known to jOOQ) primary key. The jOOQ Code Generator can produce this type of
    record on our behalf – for instance (check out our previous applications), the
    `jooq.generated.tables.records` package, which contains `CustomerRecord`, `EmployeeRecord`,
    and `OfficeRecord`. All these table records have been generated via the jOOQ generator
    and are strongly typed.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.jooq.TableRecord`和`org.jooq.UpdatableRecord`（可以再次存储在数据库中的记录）。`TableRecord`/`UpdatableRecord`记录来自具有主键的单个表（或视图）。只有`UpdatableRecord`有（为jOOQ所知）的主键。jOOQ代码生成器可以代表我们生成此类记录
    – 例如（查看我们之前的应用程序），`jooq.generated.tables.records`包，其中包含`CustomerRecord`、`EmployeeRecord`和`OfficeRecord`。所有这些表记录都是通过jOOQ生成器生成的，并且是强类型的。'
- en: '`Record` with the purpose of providing type-safety for queries that project
    custom record types in SQL. The query can contain records originating from a single
    table or from multiple tables. jOOQ will choose the proper `Record1` ... `Record22`
    interface and will pick up the correct types to guarantee the type-safety of query
    results.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Record`的目的是为在SQL中投影自定义记录类型的查询提供类型安全。查询可以包含来自单个表或多个表的记录。jOOQ将选择适当的`Record1`
    ... `Record22`接口，并选择正确的类型以确保查询结果的安全性。'
- en: Important Note
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: This kind of type-safety is applied to records for degrees up to 22\. This also
    applies to row value expressions, subselects that are combined by a set operator
    (for example, `UNION`), `IN` predicates and comparison predicates taking subselects,
    and `INSERT` and `MERGE` statements that take type-safe `VALUES()` clauses. Beyond
    degree 22, there is no type-safety.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种类型安全性应用于记录，直到 22 度。这也适用于行值表达式、通过集合运算符（例如，`UNION`）组合的子查询、`IN` 谓词和比较谓词（它们接受子查询）、以及接受类型安全
    `VALUES()` 子句的 `INSERT` 和 `MERGE` 语句。超过 22 度，就没有类型安全性。
- en: '`org.jooq.UDTRecord` API.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.jooq.UDTRecord` API。'
- en: '`org.jooq.EmbeddableRecord`. This topic is covered in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110),
    *Types, Converters, and Bindings*.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.jooq.EmbeddableRecord`。这个主题在 [*第 7 章*](B16833_07.xhtml#_idTextAnchor110)，*类型、转换器和绑定*
    中有所介绍。'
- en: Let's see several examples of fetching jOOQ records.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个获取 jOOQ 记录的示例。
- en: Fetching Result<Record> via plain SQL
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过普通 SQL 获取 Result<Record>
- en: 'In jOOQ, plain SQL, such as an SQL string, returns an anonymous type-safe `Result<Record>`.
    Here are two examples:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jOOQ 中，普通的 SQL，例如 SQL 字符串，返回一个匿名的类型安全 `Result<Record>`。以下有两个示例：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Iterating `Result` is like iterating `java.util.List`. Each `Record` can be
    accessed via a comprehensive API that, among other methods, exposes more than
    10 `get()`/`getValue()` methods for retrieving values from records in a non type-safe
    manner. Consider the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代 `Result` 就像迭代 `java.util.List`。每个 `Record` 都可以通过一个综合的 API 访问，该 API 提供了超过
    10 个 `get()`/`getValue()` 方法，以非类型安全的方式从记录中检索值。考虑以下示例：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Pay attention to `r3`. Our example works just fine, but if the specified type
    is not the proper one for the specified column (in other words, the data type
    cannot be converted, but conversion is possible), then we'll get a jOOQ `DataTypeException`
    or, even worse, you'll silently use the results of an apparently successful conversion
    that may have an improper representation. Moreover, typos in column names or columns
    that don't exist will cause `java.lang.IllegalArgumentException`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `r3`。我们的示例运行得很好，但如果指定的类型不是指定列的正确类型（换句话说，数据类型不能转换，但转换是可能的），那么我们将得到 jOOQ 的
    `DataTypeException`，甚至更糟糕的是，你可能会静默地使用一个表面上成功的转换的结果，该结果可能有错误的表现。此外，列名中的错误或不存在的列将导致
    `java.lang.IllegalArgumentException`。
- en: In order to avoid such unpleasant cases, from this point forward, we rely on
    classes obtained via the jOOQ Code Generator. This gives us a tremendous boost
    in productivity and a wide range of features. Hmmm, have I told you that you should
    always count on the jOOQ Code Generator? Anyway, let's continue with examples.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种不愉快的情况，从现在开始，我们依赖于通过 jOOQ Code Generator 获取的类。这为我们带来了巨大的生产力提升和广泛的功能。嗯，我告诉你你应该始终依赖
    jOOQ Code Generator 吗？无论如何，让我们继续举例。
- en: Fetching Result<Record> via select()
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 select() 获取 Result<Record>
- en: 'The parameter-less `select()` method of `DSLContext` results in a projection
    that includes all columns. It also produces a non-type-safe `Result<Record>`.
    This time, we use the Java-based schema produced by the jOOQ Code Generator:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`DSLContext` 的无参数 `select()` 方法会导致包含所有列的投影。它还产生一个非类型安全的 `Result<Record>`。这次，我们使用由
    jOOQ Code Generator 产生的基于 Java 的模式：'
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Even if `Result<Record>` is non-type-safe, the values of records can be type-safely
    extracted via the jOOQ generated classes. More precisely, we use the attributes
    of the generated `Customer` class as follows (`CUSTOMER` is `static`):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `Result<Record>` 是非类型安全的，也可以通过 jOOQ 生成的类以类型安全的方式提取记录的值。更确切地说，我们使用生成的 `Customer`
    类的属性如下（`CUSTOMER` 是 `static`）：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One step further, we can express this non-type-safe `Result<Record>` as a type-safe
    one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，我们可以将这个非类型安全的 `Result<Record>` 表达为类型安全的。
- en: Mapping org.jooq.Record into a strongly-typed org.jooq.TableRecord
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 org.jooq.Record 映射到强类型的 org.jooq.TableRecord
- en: Since we fetch data from a single table having a primary key (`CUSTOMER`), we
    can use `TableRecord` associated by jOOQ with the database table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从具有主键的单个表（`CUSTOMER`）中获取数据，我们可以使用 jOOQ 与数据库表关联的 `TableRecord`。
- en: 'Transforming the previous non-type-safe `Result<Record>` into a type-safe one
    can be done by mapping `org.jooq.Record` into the corresponding strongly-typed
    `org.jooq.TableRecord` via the `Record.into(Table<Z> table)` method. In this case,
    the corresponding strongly-typed `org.jooq.TableRecord` is `CustomerRecord`. Check
    out the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `org.jooq.Record` 映射到相应的强类型 `org.jooq.TableRecord`，可以通过 `Record.into(Table<Z>
    table)` 方法将先前的非类型安全的 `Result<Record>` 转换为类型安全的。在这种情况下，相应的强类型 `org.jooq.TableRecord`
    是 `CustomerRecord`。查看以下代码：
- en: '[PRE27]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The same thing can be done via `Record.into(Class<? extends E> type)`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可以通过`Record.into(Class<? extends E> type)`来实现：
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time, we can use the `CustomerRecord` getters to access the values of
    records:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们可以使用`CustomerRecord`的getter来访问记录的值：
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's see what happens if we enrich this query to fetch data from two (or more)
    tables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们将这个查询扩展以从两个（或更多）表中获取数据会发生什么。
- en: Fetching Result<Record> via select() and join()
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过select()和join()获取Result<Record>
- en: 'Let''s enrich `ctx.select().from(CUSTOMER)` with a `JOIN` clause to fetch records
    from `CUSTOMERDETAIL` as well (there is a one-to-one relationship between `CUSTOMER`
    and `CUSTOMERDETAIL`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加`JOIN`子句来丰富`ctx.select().from(CUSTOMER)`，以同时获取`CUSTOMERDETAIL`表中的记录（`CUSTOMER`和`CUSTOMERDETAIL`之间存在一对一的关系）：
- en: '[PRE40]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The values of records can be type-safely extracted from the attributes of the
    generated `Customer` and `Customerdetail` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的值可以从生成的`Customer`和`Customerdetail`类的属性中类型安全地提取：
- en: '[PRE47]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Re-writing this non-type-safe `Result<Record>` as a type-safe one is a little
    bit verbose. Let's see how to do it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个非类型安全的`Result<Record>`重写为类型安全的版本稍微有点冗长。让我们看看如何做到这一点。
- en: Mapping org.jooq.Record into a strongly-typed org.jooq.TableRecord
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将org.jooq.Record映射到强类型org.jooq.TableRecord
- en: 'Transforming the previous non-type-safe `Result<Record>` into a type-safe one
    can be done via the proper `select(SelectField<T1>, SelectField<T2>...SelectField<T22>)`
    or `into(Field<T1>, Field<T2> ... Field<T22>)` method and the proper `Record[N]`
    interface, `N=1..22`. Our schema reveals that the `CUSTOMER` and `CUSTOMERDETAIL`
    tables contain a total of 15 fields, therefore, the proper `Record[N]` is `Record15`
    and we use the `select(SelectField<T1>, SelectField<T2>... SelectField<T15>)`
    counterpart:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适当的`select(SelectField<T1>, SelectField<T2>...SelectField<T22>)`或`into(Field<T1>,
    Field<T2> ... Field<T22>)`方法以及适当的`Record[N]`接口（`N=1..22`），可以将之前的非类型安全的`Result<Record>`转换为类型安全的版本。我们的模式显示`CUSTOMER`和`CUSTOMERDETAIL`表总共包含15个字段，因此，适当的`Record[N]`是`Record15`，我们使用`select(SelectField<T1>,
    SelectField<T2>... SelectField<T15>)`对应的方法：
- en: '[PRE57]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Or, we can use the `into(Field<T1>, Field<T2> ... Field<T15>)` counterpart:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`into(Field<T1>, Field<T2> ... Field<T15>)`对应的方法：
- en: '[PRE76]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Obviously, we have 22 such `select()` and `into()` methods, but we need the
    one that corresponds to our records' degree.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们有22个这样的`select()`和`into()`方法，但我们需要与我们的记录度相对应的那个。
- en: Important Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Have you noticed the `Record15<…>` construction? Of course you have! It''s
    hard to miss! Besides the obvious verbosity, it is not that easy to fill up the
    data types as well. You have to identify and write down each data type of the
    fetched fields in the correct order. Fortunately, we can avoid this torturous
    step by using the Java 9 `var` keyword. Once you have practiced the examples from
    this chapter and you''ve got familiar with `Record[N]`, consider using `var` whenever
    you don''t have a good reason to manually write down `Record[N]`. On the other
    hand, if you are using Kotlin/Scala, then you can take advantage of better support
    for tuple-style data structures and rely on automatic destructuration of `Record[N]`as
    `val(a, b, c) = select(A, B, C)`. For more details, consider this example: [https://github.com/jOOQ/jOOQ/tree/main/jOOQ-examples/jOOQ-kotlin-example](https://github.com/jOOQ/jOOQ/tree/main/jOOQ-examples/jOOQ-kotlin-example).
    So far, in Java, the previous two examples can be expressed using `var` as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到`Record15<…>`结构了吗？当然注意到了！它很难错过！除了明显的冗长之外，填充数据类型也不是那么容易。你必须按正确的顺序识别并写下获取的字段的数据类型。幸运的是，我们可以通过使用Java
    9的`var`关键字来避免这个痛苦的步骤。一旦你练习了本章的示例，并且熟悉了`Record[N]`，那么在没有任何理由手动写下`Record[N]`的情况下，考虑使用`var`。另一方面，如果你使用Kotlin/Scala，那么你可以利用对元组样式数据结构的更好支持，并依赖于`Record[N]`的自动解构为`val(a,
    b, c) = select(A, B, C)`。更多详情，请参考这个示例：[https://github.com/jOOQ/jOOQ/tree/main/jOOQ-examples/jOOQ-kotlin-example](https://github.com/jOOQ/jOOQ/tree/main/jOOQ-examples/jOOQ-kotlin-example)。到目前为止，在Java中，前两个示例可以使用`var`如下表示：
- en: '`var result = ctx.select(...);`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`var result = ctx.select(...);`'
- en: '`var result = ctx.select()...into(...);`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`var result = ctx.select()...into(...);`'
- en: The records values can be accessed in the same way via the attributes of the
    generated `Customer` and `Customerdetail` classes. But, can we access it via the
    corresponding table records?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的值可以通过生成的`Customer`和`Customerdetail`类的属性以相同的方式访问。但是，我们能否通过相应的表记录来访问它？
- en: Extracting the two TableRecords from Record
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Record中提取两个TableRecords
- en: 'Extracting the two individual strongly-typed `TableRecord` types (`CustomerRecord`
    and `CustomerdetailRecord`) from the denormalized `Record` can be done via the
    `Record.into(Table<Z> table)` method. I bet you didn''t think that this was possible:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Record.into(Table<Z> table)` 方法从非规范化的 `Record` 中提取两个单独的强类型 `TableRecord`
    类型（`CustomerRecord` 和 `CustomerdetailRecord`）是可以实现的。我敢打赌你没想到这是可能的：
- en: '[PRE95]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Further, we can rely on the built-in getters of `CustomerRecord` and `CustomerdetailRecord`
    to access the corresponding values.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以依赖 `CustomerRecord` 和 `CustomerdetailRecord` 的内置获取器来访问相应的值。
- en: Fetching Result<Record> via selectFrom()
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 selectFrom() 获取 Result<Record>
- en: 'The best approach for selecting, in a type-safe manner, all the columns from
    a single table into `Result<Record>` relies on the `selectFrom(table)` method.
    In this context, jOOQ returns the record type supplied with the argument table,
    therefore, it returns `TableRecord`. Check out the code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型安全的方式下选择单个表中的所有列并将其放入 `Result<Record>` 的最佳方法依赖于 `selectFrom(table)` 方法。在这种情况下，jOOQ
    返回由参数表提供的记录类型，因此它返回 `TableRecord`。查看以下代码：
- en: '[PRE97]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Further, the `CustomerRecord` getters return the values:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`CustomerRecord` 获取器返回的值：
- en: '[PRE100]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: While this is really cool, please consider the following important note as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实很酷，但也请考虑以下重要注意事项。
- en: Important Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Don't consider that `select().from(table)`and `selectFrom(table)` are the same
    thing. The former, `select().from(table)`, returns a non-type-safe `Result<Record>`
    and we can use any clause that modifies the type of the table expression (for
    instance, `JOIN`). On the other hand, `selectFrom(table)` returns a type-safe
    `Result<TableRecord>` and doesn't permit the usage of any clause that modifies
    the type of the table expression.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不要认为 `select().from(table)` 和 `selectFrom(table)` 是同一件事。前者，`select().from(table)`，返回一个非类型安全的
    `Result<Record>`，我们可以使用任何修改表表达式类型的子句（例如，`JOIN`）。另一方面，`selectFrom(table)` 返回一个类型安全的
    `Result<TableRecord>`，不允许使用任何修改表表达式类型的子句。
- en: Next, let's tackle ad hoc selects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解决 ad hoc 查询。
- en: Fetching Result<Record> via ad hoc selects
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 ad hoc 查询获取 Result<Record>
- en: 'In ad hoc selects, we enlist the needed columns that can originate in one or
    more tables. As long as we enlist the columns explicitly and rely on Java-based
    schema, jOOQ will determine the correct types and will prepare a record of a certain
    degree. Here is an example that selects some columns from a single table:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ad hoc 查询中，我们列出所需列，这些列可以来自一个或多个表。只要我们明确列出列并依赖基于 Java 的模式，jOOQ 就会确定正确的类型，并准备一定程度的记录。以下是一个从单个表中选择一些列的示例：
- en: '[PRE107]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Since we have three columns, jOOQ has picked up the record of degree 3, `Record3`,
    and automatically inferred the correct Java types, `Long`, `String`, and `BigDecimal`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有三个列，jOOQ 自动选择了度数为 3 的记录，`Record3`，并自动推断出正确的 Java 类型，`Long`，`String` 和 `BigDecimal`。
- en: 'Next, let''s see an example that fetches five columns originating from two
    tables:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个示例，该示例从两个表中检索五个列：
- en: '[PRE113]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This time, jOOQ picked up `Record5<Long, BigDecimal, String, String, String>`.
    I think you've got the idea!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，jOOQ 选择了 `Record5<Long, BigDecimal, String, String, String>`。我想你已经明白了这个概念！
- en: Accessing the values of records in a type-safe manner can be done via the attributes
    of the generated classes or you can use `Record.into(Table<Z> table)` to extract
    the strongly-typed `TableRecords` and rely on the corresponding getters. But,
    pay attention that only the fields listed/projected in the query have been populated
    with values from the result set.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以类型安全的方式访问记录的值可以通过生成类的属性来完成，或者你可以使用 `Record.into(Table<Z> table)` 来提取强类型的 `TableRecords`
    并依赖相应的获取器。但请注意，只有查询中列出/投影的字段才填充了结果集的值。
- en: Fetching Result<Record> via UDTs
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 UDTs 获取 Result<Record>
- en: 'UDTs are ORDBMS features formally supported by Oracle and PostgreSQL and are
    modeled by jOOQ as `UDTRecord`. Let''s consider the following UDT defined in PostgreSQL:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: UDTs 是 Oracle 和 PostgreSQL 正式支持的 ORDBMS 功能，并由 jOOQ 模拟为 `UDTRecord`。让我们考虑以下在
    PostgreSQL 中定义的 UDT：
- en: '[PRE123]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Next, the `MANAGER` table schema uses this type as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`MANAGER` 表模式如下使用此类型：
- en: '[PRE126]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Running the jOOQ Code Generator produces an `org.jooq.UDT` implementation named
    `EvaluationCriteria.java` (in the `jooq.generated.udt` package). Besides the `org.jooq.UDT`
    implementation, an `org.jooq.UDTRecord` implementation is also generated under
    the name `EvaluationCriteriaRecord.java` (in the `jooq.generated.udt.records`
    package).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 jOOQ 代码生成器会生成一个名为 `EvaluationCriteria.java` 的 `org.jooq.UDT` 实现文件（位于 `jooq.generated.udt`
    包中）。除了 `org.jooq.UDT` 实现之外，还会生成一个名为 `EvaluationCriteriaRecord.java` 的 `org.jooq.UDTRecord`
    实现文件（位于 `jooq.generated.udt.records` 包中）。
- en: 'Having these artifacts generated, we can write the following example that returns
    a type-safe `Result<Record>`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 生成这些工件后，我们可以编写以下示例，它返回一个类型安全的 `Result<Record>`：
- en: '[PRE131]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Accessing the values of records can be done as follows. Of course, the climax
    is represented by accessing the UDT record''s values:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式访问记录的值。当然，高潮是访问 UDT 记录的值：
- en: '[PRE136]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Alternatively, relying on `Record.into(Table<Z> table)` can be done as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过 `Record.into(Table<Z> table)` 来实现，如下所示：
- en: '[PRE148]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'This time, accessing the values of records can be done via `getManagerEvaluation()`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，可以通过 `getManagerEvaluation()` 方法访问记录的值：
- en: '[PRE154]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Well, this was a brief overview of jOOQ records. I've intentionally skipped
    `UpdatableRecord` for now since this topic is covered later in [*Chapter 9*](B16833_09.xhtml#_idTextAnchor162),
    *CRUD, Transactions, and Locking*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就是对 jOOQ 记录的简要概述。我故意跳过了 `UpdatableRecord`，因为这个主题将在 [*第 9 章*](B16833_09.xhtml#_idTextAnchor162)，*CRUD、事务和锁定*
    中进行讨论。
- en: Important Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'When this book was written, attempting to serialize a jOOQ record to JSON/XML
    via Spring Boot default Jackson features (for instance, by returning `Record`
    from a REST controller) will result in an exception! Setting `FAIL_ON_EMPTY_BEANS=false`
    will eliminate the exception but will lead to a weird and useless result. Alternatively,
    you can return POJOs or rely on jOOQ formatting capabilities – as you''ll see
    later, jOOQ can format a record as JSON, XML, and HTML. And, let''s not forget
    the alternative of using SQL/XML or SQL/JSON features and generating the JSON
    directly in the database (see *Chapter 8*, *Fetching and Mapping*). However, if
    you really want to serialize the jOOQ record, then you can rely on `intoMap()`
    and `intoMaps()`, as you can see in the bundled code. Meanwhile, you can monitor
    the progress on this topic here: [https://github.com/jOOQ/jOOQ/issues/11889](https://github.com/jOOQ/jOOQ/issues/11889).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当这本书编写时，尝试通过 Spring Boot 默认的 Jackson 功能（例如，通过从 REST 控制器返回 `Record`）将 jOOQ 记录序列化为
    JSON/XML 将导致异常！设置 `FAIL_ON_EMPTY_BEANS=false` 将消除异常，但会导致奇怪且无用的结果。或者，你可以返回 POJO
    或依赖 jOOQ 的格式化功能——正如你将看到的，jOOQ 可以将记录格式化为 JSON、XML 和 HTML。而且，别忘了使用 SQL/XML 或 SQL/JSON
    功能，并在数据库中直接生成 JSON（参见 *第 8 章*，*获取和映射*）。然而，如果你真的想序列化 jOOQ 记录，那么你可以依赖 `intoMap()`
    和 `intoMaps()`，正如你将在附带代码中看到的那样。同时，你可以在[https://github.com/jOOQ/jOOQ/issues/11889](https://github.com/jOOQ/jOOQ/issues/11889)上监控这个主题的进展。
- en: The examples covered in this section are available for Maven and Gradle in the
    code bundled with the book under the name *RecordResult*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中涵盖的示例可在书籍附带代码中的 Maven 和 Gradle 下找到，名称为 *RecordResult*。
- en: Exploring jOOQ query types
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 jOOQ 查询类型
- en: 'jOOQ distinguishes between two main types of queries:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 区分了两种主要的查询类型：
- en: DML (`INSERT`, `UPDATE`, `DELETE`, and `MERGE`, among others) and DDL (`CREATE`,
    `ALTER`, `DROP`, `RENAME`, and similar) queries that produce a modification in
    the database
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DML（`INSERT`、`UPDATE`、`DELETE` 和 `MERGE` 等）和 DDL（`CREATE`、`ALTER`、`DROP`、`RENAME`
    等）查询，这些查询会在数据库中产生修改
- en: DQL (`SELECT`) queries that produce results
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DQL（`SELECT`）查询会产生结果
- en: DML and DDL queries are represented in jOOQ by the `org.jooq.Query` interface,
    while DQL queries are represented by the `org.jooq.ResultQuery` interface. The
    `ResultQuery` interface extends (among others) the `Query` interface.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: DML 和 DDL 查询在 jOOQ 中由 `org.jooq.Query` 接口表示，而 DQL 查询由 `org.jooq.ResultQuery`
    接口表示。`ResultQuery` 接口扩展了（包括）`Query` 接口。
- en: 'For instance, the following snippet of code contains two jOOQ queries:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段包含两个 jOOQ 查询：
- en: '[PRE163]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'These queries can be executed via jOOQ and they return the number of affected
    rows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询可以通过 jOOQ 执行，并返回受影响的行数：
- en: '[PRE167]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'And, here are two result queries: first, a plain SQL query – here, jOOQ cannot
    infer the `Record` types:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里有两个结果查询：首先是一个普通的 SQL 查询——在这里，jOOQ 无法推断 `Record` 类型：
- en: '[PRE168]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Second, a jOOQ `ResultQuery` expressed via jOOQ generated classes (notice that
    this time, jOOQ infers the number of `ResultQuery` parameters and types – since
    we fetch only `JOB_TITLE`, there is `Record1<String>`):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，通过 jOOQ 生成的类表达式的 jOOQ `ResultQuery`（注意这次，jOOQ 推断出 `ResultQuery` 参数的数量和类型——因为我们只获取
    `JOB_TITLE`，所以有 `Record1<String>`）：
- en: '[PRE172]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Since `ResultQuery` extends `Iterable`, you can just *foreach* your queries
    in PL/SQL style and do something with each record. For instance, the following
    snippet of code works like a charm:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ResultQuery` 扩展了 `Iterable`，您可以使用 PL/SQL 风格的 *foreach* 来遍历查询，并对每条记录进行处理。例如，以下代码片段效果很好：
- en: '[PRE178]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: There is no need to explicitly call `fetch()`, but you can do it. The examples
    from this section are grouped in an application named *QueryAndResultQuery*. Next,
    let's talk about the jOOQ fluent API.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要显式调用 `fetch()`，但您也可以这样做。本节中的示例被组织在一个名为 *QueryAndResultQuery* 的应用程序中。接下来，让我们谈谈
    jOOQ 流畅 API。
- en: Understanding the jOOQ fluent API
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 jOOQ 流畅 API
- en: Most of the time spent with jOOQ is about writing fluent code via the jOOQ fluent
    API. This approach is quite convenient for building fluent SQL expressions that
    avoid disrupting or chunking the code. Moreover, fluent APIs are easy to enrich
    with more operations.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时间花在 jOOQ 上是关于通过 jOOQ 流畅 API 编写流畅代码。这种方法对于构建避免打断或分块代码的流畅 SQL 表达式非常方便。此外，流畅
    API 很容易通过更多操作来丰富。
- en: Relying on a brilliant implementation of the interface-driven design concept,
    jOOQ hides most implementations from client code and acts as a *good friend* that
    is ready to listen regarding the SQL that you need to run. Let's see several usages
    of the jOOQ fluent API.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 基于接口驱动设计概念的出色实现，jOOQ 隐藏了大多数实现细节，并作为一个随时准备倾听您需要运行的 SQL 的 *好朋友*。让我们看看 jOOQ 流畅
    API 的几个用法。
- en: Writing fluent queries
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写流畅查询
- en: 'So far, we have written several SQL in the jOOQ DSL API fluent style. Let''s
    have another one as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经用 jOOQ DSL API 流畅风格编写了几个 SQL。让我们再看一个如下：
- en: '[PRE187]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The goal of dissecting to the bone the previous jOOQ query is far away from
    us, but let's try to have some insights about how this query is seen through jOOQ
    eyes. This will help you to quickly accumulate the information from the chapters
    that follow and will increase your confidence in jOOQ.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前的 jOOQ 查询剖析到极致的目标离我们还很远，但让我们尝试从 jOOQ 的视角来了解这个查询。这将帮助您快速积累后续章节的信息，并增强您对 jOOQ
    的信心。
- en: 'Roughly, a JOOQ fluent query is composed of two basic building blocks: `org.jooq.QueryPart`
    interface as a common base type. Let''s briefly cover column expressions, table
    expressions, and query steps to better understand this paragraph.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，一个 JOOQ 流畅查询由两个基本构建块组成：`org.jooq.QueryPart` 接口作为通用基类型。让我们简要地介绍一下列表达式、表表达式和查询步骤，以便更好地理解这一段。
- en: Column expressions
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表达式
- en: '`org.jooq.Field` interface. There are many kinds of column expressions and
    all of them can be used in a variety of SQL statements/clauses to produce fluent
    queries. For example, in the `SELECT` clause, we have `org.jooq.SelectField` (which
    is a special `org.jooq.Field` interface for `SELECT`); in the `WHERE` clause,
    we have `org.jooq.Field`; in the `ORDER BY` clause, we have `org.jooq.OrderField`;
    in the `GROUP BY` clause, we have `org.jooq.GroupField`; and in conditions and
    functions, we typically have `org.jooq.Field`.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.jooq.Field` 接口。列表达式有很多种，它们都可以用在各种 SQL 语句/子句中，以生成流畅的查询。例如，在 `SELECT` 子句中，我们有
    `org.jooq.SelectField`（这是一个特殊的 `org.jooq.Field` 接口，用于 `SELECT`）；在 `WHERE` 子句中，我们有
    `org.jooq.Field`；在 `ORDER BY` 子句中，我们有 `org.jooq.OrderField`；在 `GROUP BY` 子句中，我们有
    `org.jooq.GroupField`；在条件和函数中，我们通常有 `org.jooq.Field`。'
- en: 'Column expressions can be arbitrary built via the jOOQ fluent API to shape
    different query parts such as arithmetic expressions (for example, `column_expression_1.mul(column_expression_2)`),
    conditions/predicates (`org.jooq.Condition`) used in `WHERE` and `HAVING` (for
    example, here is an equality condition: `WHERE(column_expression_1.eq(column_expression_2))`),
    and so on.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 列表达式可以通过 jOOQ 流畅 API 随意构建，以形成不同的查询部分，如算术表达式（例如，`column_expression_1.mul(column_expression_2)`）、用于
    `WHERE` 和 `HAVING` 的条件/谓词（例如，这里是一个等价条件：`WHERE(column_expression_1.eq(column_expression_2))`）等等。
- en: When column expressions refer to table columns, they are referenced as `org.jooq.TableField`.
    These kinds of column expressions are produced internally by the jOOQ Code Generator
    and you can see them in each Java class specific to a table. The instances of
    `TableField` cannot be created directly.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表达式引用表列时，它们被引用为 `org.jooq.TableField`。这类列表达式是由 jOOQ 代码生成器内部生成的，你可以在每个特定于表的
    Java 类中看到它们。`TableField` 的实例不能直接创建。
- en: 'Let''s identify the column expressions types from our query using the following
    figure, which highlights them:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下图示来识别查询中的列表达式类型，它将它们突出显示：
- en: '![Figure 3.2 – Identify the column expressions of this query'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.2 – 识别此查询的列表达式'
- en: '](img/B16833_Figure_3.2.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_3.2.jpg]'
- en: Figure 3.2 – Identify the column expressions of this query
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.2 – 识别此查询的列表达式
- en: 'First of all, we have some table columns that reference the `ORDERDETAIL` table:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一些引用 `ORDERDETAIL` 表的表列：
- en: '[PRE197]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'We have some extracted as `TableField`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将其提取为 `TableField`：
- en: '[PRE200]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'We also have an unnamed column expression:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个未命名的列表达式：
- en: '[PRE206]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Just as a quick note, here, the `DSL.val()` method simply creates `Field<Integer>`
    (gets a bind value as `Param<Integer>`, where `Param` extends `Field`) representing
    a constant value. We will discuss jOOQ parameters a little bit later in this chapter.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅作为一个快速提示，在这里，`DSL.val()` 方法简单地创建代表常量值的 `Field<Integer>`（获取绑定值作为 `Param<Integer>`，其中
    `Param` 扩展 `Field`），我们将在本章稍后讨论 jOOQ 参数。
- en: 'Let''s rewrite the query so far using the extracted columns expression:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用提取的列表达式重写到目前为止的查询：
- en: '[PRE207]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Next, let''s extract the usages of the `sum()` aggregate function. The first
    usage of `sum()` relies on a table column expression (`tc2`) to produce a function
    expression:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们提取 `sum()` 聚合函数的使用情况。`sum()` 的第一次使用依赖于一个表列表达式（`tc2`）来生成一个函数表达式：
- en: '[PRE214]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'The second usage of `sum()` wraps an arithmetic expression that uses two table
    column expressions (`tc3` and `tc2`), therefore, it can be extracted as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()` 的第二种用法封装了一个使用两个表列表达式（`tc3` 和 `tc2`）的算术表达式，因此，它可以如下提取：'
- en: '[PRE215]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'One step further, and we notice that our query uses aliases for `f1` and `f2`,
    therefore, these can be extracted as aliased expressions:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 再进一步，我们注意到我们的查询使用了 `f1` 和 `f2` 的别名，因此，这些可以提取为带别名的表达式：
- en: '[PRE217]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Let''s rewrite the query again:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次重写查询：
- en: '[PRE219]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Done! At this point, we have identified all column expressions of our query.
    How about table expressions?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！在这个时候，我们已经识别了我们查询中的所有列表达式。那么表表达式呢？
- en: Table expressions
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表表达式
- en: 'Next to fields, tables also represent the basic building blocks of any query.
    jOOQ represents a table via `org.jooq.Table`. In our query, there is a single
    table reference:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字段之外，表也代表了任何查询的基本构建块。jOOQ 通过 `org.jooq.Table` 来表示表。在我们的查询中，有一个单独的表引用：
- en: '[PRE225]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'It can be extracted as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以如下提取：
- en: '[PRE226]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'This time, the query becomes the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，查询变成了以下形式：
- en: '[PRE230]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: jOOQ supports a wide range of tables not only database tables, including plain
    SQL tables, aliased tables, derived tables, **Common Table Expressions** (**CTEs**),
    temporary tables, and table-valued functions. But, we will discuss these in the
    upcoming chapters.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 支持广泛的表，不仅包括数据库表，还包括普通 SQL 表、别名表、派生表、**公用表表达式（CTEs**）、临时表和表值函数。但我们将讨论这些内容在接下来的章节中。
- en: 'So far, notice that we haven''t touched `uc1.lt(tc2)`. As you can probably
    intuit, this is a condition that uses two column expressions and is mapped by
    jOOQ as `org.jooq.Condition`. It can be extracted as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，请注意，我们还没有触及 `uc1.lt(tc2)`。正如你可能直觉到的，这是一个使用两个列表达式并映射为 jOOQ 的 `org.jooq.Condition`
    的条件。它可以如下提取：
- en: '[PRE236]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'After extracting all these parts, we obtain the following query:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取所有这些部分之后，我们得到了以下查询：
- en: '[PRE237]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Actually, you could even do the following, but there is no more type-safety:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你甚至可以这样做，但这样就没有更多的类型安全性：
- en: '[PRE243]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Obviously, these query parts can be used to form other arbitrary queries as
    well. After all, in jOOQ, we can write queries that are 100% dynamic.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些查询部分也可以用来形成其他任意查询。毕竟，在 jOOQ 中，我们可以编写 100% 动态的查询。
- en: Important Note
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In jOOQ, even when they look like static queries (due to jOOQ's API design),
    every SQL is dynamic, therefore, it can be broken up into query parts that can
    be fluently glued back in any valid jOOQ query. We'll talk about more examples
    later when we'll tackle dynamic filters.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jOOQ 中，即使它们看起来像静态查询（由于 jOOQ 的 API 设计），每个 SQL 都是动态的，因此，它可以被分解成可以流畅地重新组合到任何有效
    jOOQ 查询中的查询部分。我们将在稍后讨论动态过滤器时提供更多示例。
- en: Finally, let's quickly get an overview of the query steps topic.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速了解一下查询步骤主题。
- en: Query steps (SelectFooStep, InsertFooStep, UpdateFooStep, and DeleteFooStep)
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询步骤（SelectFooStep、InsertFooStep、UpdateFooStep和DeleteFooStep）
- en: 'Continuing to identify the remaining query parts, we have `select`, `from`,
    `where`, `groupBy`, and `orderBy`. These parts are logically chained to form our
    query and are represented by jOOQ as query steps. There are many types of query
    steps, but the ones used by our query can be decomposed as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 继续识别剩余的查询部分，我们有`select`、`from`、`where`、`groupBy`和`orderBy`。这些部分逻辑上链接在一起形成我们的查询，并由jOOQ表示为查询步骤。查询步骤有很多种类型，但我们的查询可以分解如下：
- en: '[PRE245]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Or, the ones used as type-safe steps are as follows (remember, you can use
    Java 9 `var` instead of `SelectSelectStep<Record3<Short, BigDecimal, BigDecimal>>`):'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，用作类型安全步骤的如下（记住，你可以使用Java 9 `var`代替`SelectSelectStep<Record3<Short, BigDecimal,
    BigDecimal>>`）：
- en: '[PRE251]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'Check out the last line of this snippet of code. We return the generated valid
    SQL as a plain string without executing this query. Execution can happen in the
    presence of a connection to the database, therefore, we need `DSLContext` configured
    to accomplish this task. If we have injected `DSLContext`, then all we need to
    do is to use it as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此代码片段的最后一行。我们返回生成的有效SQL作为纯字符串，而不执行此查询。执行可以在数据库连接存在的情况下发生，因此，我们需要配置`DSLContext`来完成此任务。如果我们已经注入了`DSLContext`，那么我们只需要像下面这样使用它：
- en: '[PRE262]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Or, we can use it like this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样使用它：
- en: '[PRE263]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'This `SelectSelectStep` contains an internal reference to the `DSLContext`
    configuration, therefore, we can replace the last line as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`SelectSelectStep`包含对`DSLContext`配置的内部引用，因此，我们可以将最后一行替换如下：
- en: '[PRE267]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: The complete code is available for Maven and Gradle in the code bundled with
    this book under the name `FluentQueryParts`. While in this section, you saw how
    to decompose the query steps, keep in mind that it's almost always a better choice
    to rely on dynamic SQL queries than referencing these step types. So, as a rule
    of thumb, *always* try to avoid assigning or referencing the query steps directly.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在本书附带代码中找到，这些代码打包在名为`FluentQueryParts`的部分下。虽然在本节中，你看到了如何分解查询步骤，但请记住，几乎总是更好的选择是依赖于动态SQL查询而不是引用这些步骤类型。因此，作为一个经验法则，*总是*尝试避免直接分配或引用查询步骤。
- en: Obviously, decomposing a query into parts is not a day-to-day task. Most of
    the time, you'll just use the fluent API, but there are cases when it is nice
    to know how to do it (for instance, it can be helpful for writing dynamic filters,
    referencing aliases in different places of a query, re-using a query part in multiple
    places, and writing correlated subqueries).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，将查询分解成部分并不是日常任务。大多数时候，你只会使用流畅API，但有时了解如何进行分解是有用的（例如，这有助于编写动态过滤器，在查询的不同位置引用别名，在多个位置重用查询部分，以及编写相关子查询）。
- en: Another use of the jOOQ fluent API is focused on the `DSLContext` creation.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ流畅API的另一个用途是关注`DSLContext`的创建。
- en: Creating DSLContext
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`DSLContext`
- en: Most probably, in Spring Boot applications, we'll prefer to inject the default
    `DSLContext` as you saw in [*Chapter 1*](B16833_01.xhtml#_idTextAnchor015), *Starting
    jOOQ and Spring Boot*, and [*Chapter 2*](B16833_02.xhtml#_idTextAnchor024), *Customizing
    the jOOQ Level of Involvement*. But, in certain scenarios (for instance, wrapping
    and running a specific query with a custom setting, rendering an SQL in a different
    dialect than the default one, or needing to trigger an occasional query against
    a database that is not configured in Spring Boot), we'll prefer to use `DSLContext`
    as a local variable. This can be done in fluent style via the `DSL.using()` methods
    as in the following non-exhaustive list of examples.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，在Spring Boot应用程序中，我们更喜欢注入默认的`DSLContext`，正如你在[*第1章*](B16833_01.xhtml#_idTextAnchor015)“启动jOOQ和Spring
    Boot”和[*第2章*](B16833_02.xhtml#_idTextAnchor024)“自定义jOOQ的参与级别”中看到的，但，在某些情况下（例如，使用自定义设置包装和运行特定查询，以不同于默认方言的方言渲染SQL，或者需要偶尔对未在Spring
    Boot中配置的数据库执行查询），我们更喜欢将`DSLContext`作为局部变量使用。这可以通过`DSL.using()`方法以流畅风格完成，如下列非详尽的示例所示。
- en: Creating DSLContext from a data source and a dialect
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数据源和方言创建`DSLContext`
- en: 'Having `DataSource` (for instance, injected in your repository), we can create
    `DSLContext` and execute a query in fluent style as here:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 有`DataSource`（例如，注入到你的仓库中），我们可以创建`DSLContext`并以流畅风格执行查询，如下所示：
- en: '[PRE268]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: This example relies on the `DSL.using(DataSource datasource, SQLDialect dialect)`
    method.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例依赖于`DSL.using(DataSource datasource, SQLDialect dialect)`方法。
- en: Creating DSLContext from a data source, a dialect, and some settings
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数据源、方言和一些设置创建DSLContext
- en: 'Enabling/disabling some settings to the previous example requires us to instantiate
    `org.jooq.conf.Settings`. This class exposes a comprehensive fluent API (via the
    `withFoo()` methods) that influences the way jOOQ renders SQL code. For instance,
    the following snippet of code inhibits the rendering of the schema name (just
    look at this nice piece of fluent code):'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 启用/禁用前一个示例中的某些设置需要我们实例化`org.jooq.conf.Settings`。这个类提供了一个全面的流畅API（通过`withFoo()`方法），它影响jOOQ渲染SQL代码的方式。例如，以下代码片段阻止了模式名称的渲染（只需看看这段流畅的代码）：
- en: '[PRE274]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: This example relies on the `using(DataSource datasource, SQLDialect dialect,
    Settings settings)` method.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例依赖于`using(DataSource datasource, SQLDialect dialect, Settings settings)`方法。
- en: Alter a setting of the injected DSLContext
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改注入的DSLContext的设置
- en: 'In the previous example, we created `DSLContext` that doesn''t render the schema
    name. This setting is applied to all usages of the created `DSLContext`, or in
    other words, to all queries triggered under the configuration of this `DSLContext`.
    How can we do the same thing for the default `DSLContext` provided by Spring Boot
    after it was injected into a repository? The following code provides the answer:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了不渲染模式名称的`DSLContext`。此设置应用于创建的`DSLContext`的所有使用，换句话说，应用于在此`DSLContext`配置下触发的所有查询。我们如何为Spring
    Boot注入到仓库后的默认`DSLContext`做同样的事情？以下代码提供了答案：
- en: '[PRE281]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Mainly, we access the current configuration of the injected `DSLContext` via
    `configuration()`, we set our setting, and call the `dsl()` method to get access
    back to `DSLContext`. Notice that from this point forward, all usages of `ctx`
    will not render the schema name unless you don''t enable it again. If you prefer
    to use some specific settings for a certain query, then create `DSLContext` derived
    from the injected one via `derive()` in place of `set()`. This way, the original
    `DSLContext` remains unaltered and you can operate on the derived one:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 主要地，我们通过`configuration()`访问注入的`DSLContext`的当前配置，设置我们的设置，并调用`dsl()`方法以获取对`DSLContext`的访问。请注意，从这一点开始，所有使用`ctx`的地方将不会渲染模式名称，除非你再次启用它。如果你希望为某个特定的查询使用一些特定的设置，那么可以通过`derive()`代替`set()`从注入的一个`DSLContext`派生出来。这样，原始的`DSLContext`保持不变，你可以操作派生出来的一个：
- en: '[PRE288]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: So, in the previous example, `ctx` remains unchanged and jOOQ uses a derived
    `DSLContext`, which will not render the schema name.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的示例中，`ctx`保持不变，jOOQ使用派生的`DSLContext`，它将不会渲染模式名称。
- en: Creating DSLContext from a connection
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从连接创建DSLContext
- en: 'Creating `DSLContext` from a connection and executing the query in fluent style
    can be done as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 从连接创建DSLContext并以流畅风格执行查询可以按以下方式完成：
- en: '[PRE295]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: In such cases, we have to close the connection manually; therefore, we have
    used the `try-with-resources` technique. This example relies on the `DSL.using(Connection
    c)` method. If you want to specify the SQL dialect as well, then try out `DSL.using(Connection
    c, SQLDialect d)`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须手动关闭连接；因此，我们使用了`try-with-resources`技术。此示例依赖于`DSL.using(Connection
    c)`方法。如果你想指定SQL方言，那么尝试使用`DSL.using(Connection c, SQLDialect d)`。
- en: Creating DSLContext from a URL, user, and password
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从URL、用户和密码创建DSLContext
- en: For standalone-based scripts, where handling resources is not important since
    the connection lives as long as the script itself, we can rely on `DSL.using(String
    url)`, `DSL.using(String url, Properties properties)`, and `DSL.using(String url,
    String user, String password)`.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于独立脚本的脚本，由于连接与脚本本身一样长，处理资源并不重要，我们可以依赖`DSL.using(String url)`、`DSL.using(String
    url, Properties properties)`和`DSL.using(String url, String user, String password)`。
- en: 'If you prefer to use the `DSL.using(String url, String user, String password)`
    method (or any of the other two) prior to jOOQ 3.14, then you have to explicitly
    close the connection as well. This can be done by explicitly calling `DSLContext.close()`
    or by using `try-with-resources`. Starting with jOOQ 3.14, these overloads of
    `DSL.using()` will produce the new `CloseableDSLContext` type that allows us to
    write this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在jOOQ 3.14之前使用`DSL.using(String url, String user, String password)`方法（或任何其他两个方法），那么你必须显式关闭连接。这可以通过显式调用`DSLContext.close()`或使用`try-with-resources`来实现。从jOOQ
    3.14开始，这些`DSL.using()`的重载将产生新的`CloseableDSLContext`类型，它允许我们编写如下代码：
- en: '[PRE305]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: Next, let's see how to use `DSLContext` without a database connection.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在不使用数据库连接的情况下使用`DSLContext`。
- en: Rendering SQL in a certain dialect
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以特定方言渲染SQL
- en: 'Rendering SQL in a certain dialect (here, MySQL) can be done via this fluent
    code:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定的方言（这里，MySQL）中渲染 SQL 可以通过以下流畅的代码完成：
- en: '[PRE313]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: Since there is no connection or data source, there is no interaction with the
    database. The returned string represents the generated SQL specific to the provided
    dialect. This example relies on the `DSL.using(SQLDialect dialect)` method.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有连接或数据源，因此没有与数据库的交互。返回的字符串表示针对提供的方言生成的特定 SQL。此示例依赖于 `DSL.using(SQLDialect
    dialect)` 方法。
- en: You can find all these examples in the code bundled with this book under the
    name *CreateDSLContext*.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书附带代码中找到所有这些示例，名称为 *CreateDSLContext*。
- en: Using Lambdas and streams
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Lambda 和流
- en: The jOOQ fluent API and Java 8 Lambdas and streams make a perfect team. Let's
    look at several examples that demonstrate this.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 流畅 API、Java 8 Lambda 和流组成了一支完美的团队。让我们看看几个演示这一点的例子。
- en: Using Lambdas
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Lambda
- en: 'For instance, jOOQ comes with a functional interface named `RecordMapper` used
    for mapping a jOOQ record to a POJO. Let''s assume that we have the following
    POJOs. First, let''s assume we have `EmployeeName`:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，jOOQ 提供了一个名为 `RecordMapper` 的功能接口，用于将 jOOQ 记录映射到 POJO。让我们假设我们有以下 POJO。首先，让我们假设我们有
    `EmployeeName`：
- en: '[PRE317]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'Next, let''s assume we have `EmployeeData`:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们假设我们有 `EmployeeData`：
- en: '[PRE322]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Next, let''s assume that we have the following plain SQL:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们假设我们有以下原始 SQL：
- en: '[PRE328]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'Executing and mapping this plain SQL is achievable via the `fetch(String sql)`
    flavor and `map(RecordMapper<? super R,E> rm)` as in the following:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `fetch(String sql)` 风味和 `map(RecordMapper<? super R,E> rm)`（如下所示）执行和映射这个原始
    SQL 是可行的：
- en: '[PRE330]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'The same thing is applicable if the plain SQL is expressed via the Java-based
    schema:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过基于 Java 的模式表达原始 SQL，则同样适用：
- en: '[PRE342]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'It is also applicable if it is more concisely expressed via `fetch(RecordMapper<?
    super R,E> rm)`:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过 `fetch(RecordMapper<? super R,E> rm)` 更简洁地表达，则也适用：
- en: '[PRE356]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'If you think that these mappings are too simple for using a custom `RecordMapper`,
    then you are right. You''ll see more proper cases for custom record mappers later
    on when we''ll detail mappings. For this case, both of them can be solved via
    the built-in `into()` and `fetchInto()` methods by simply enriching the SQLs with
    hints via aliases. First, we can enrich the plain SQL (for MySQL, we use backticks):'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这些映射对于使用自定义的 `RecordMapper` 来说太简单了，那么你是正确的。在我们详细讨论映射时，你将看到更多适合自定义记录映射的案例。对于这个案例，两者都可以通过使用内置的
    `into()` 和 `fetchInto()` 方法，通过别名添加提示来解决问题。首先，我们可以丰富原始的 SQL（对于 MySQL，我们使用反引号）：
- en: '[PRE368]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'And then, we can enrich the jOOQ SQL:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以丰富 jOOQ SQL：
- en: '[PRE373]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: Let's see a few more examples of using Lambdas.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多使用 Lambda 的例子。
- en: 'The following snippet of code prints all sales. Since `selectFrom()` returns
    the record type supplied with the argument table, this code prints each `SaleRecord`
    (notice that calling `fetch()` is optional):'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段打印出所有销售记录。由于 `selectFrom()` 返回带有参数表的记录类型，因此此代码打印出每个 `SaleRecord`（注意调用
    `fetch()` 是可选的）：
- en: '[PRE379]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'Mapping the result set (`SaleRecord`) to `List<Double>` containing only the
    `sale` column can be done as follows via `fetch().map(RecordMapper<? super R,E>
    rm)`:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果集（`SaleRecord`）映射到只包含 `sale` 列的 `List<Double>` 可以通过以下方式通过 `fetch().map(RecordMapper<?
    super R,E> rm)` 完成：
- en: '[PRE383]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'Or, it can be done via `fetch(RecordMapper<? super R,E> rm)` as follows:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过以下方式通过 `fetch(RecordMapper<? super R,E> rm)` 完成：
- en: '[PRE388]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'It can also be done via a Lambda expression as follows:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过以下 Lambda 表达式完成：
- en: '[PRE392]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: 'Or, it can even be done via an anonymous record mapper as follows:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，甚至可以通过以下匿名记录映射器完成：
- en: '[PRE396]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: Next, let's see how the jOOQ fluent API can be used with the Java Stream fluent
    API.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用 jOOQ 流畅 API 与 Java Stream 流畅 API 结合使用。
- en: Using the Stream API
  id: totrans-594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Stream API
- en: 'Using the jOOQ fluent API and the Stream fluent API as an apparently single
    fluent API is straightforward. Let''s assume that we have this POJO:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jOOQ 流畅 API 和 Stream 流畅 API 作为显然的单个流畅 API 是直接的。让我们假设我们有一个这样的 POJO：
- en: '[PRE404]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: 'A plain SQL can obtain a `SaleStats` instance as follows:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 一个原始 SQL 可以通过以下方式获得 `SaleStats` 实例：
- en: '[PRE409]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'But, if we use the Java-based schema, then this code can be re-written as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们使用基于 Java 的模式，那么此代码可以重写如下：
- en: '[PRE416]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: It looks like the jOOQ fluent API and the Stream fluent API work together like
    a charm! All we have to do is call the `stream()` method after `fetch()`. While
    `fetch()` fetches the entire result set into memory, `stream()` opens a stream
    on this result set. Fetching the entire result set into memory via `fetch()`allows
    the JDBC resources (for instance, the connection) to be closed before streaming
    the result set.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来jOOQ流畅API和Stream流畅API配合得像魔法一样！我们只需要在`fetch()`之后调用`stream()`方法。当`fetch()`将整个结果集加载到内存中时，`stream()`在这个结果集上打开一个流。通过`fetch()`将整个结果集加载到内存中允许在流式传输结果集之前关闭JDBC资源（例如，连接）。
- en: Nevertheless, besides `stream()`, jOOQ also exposes a method named `fetchStream()`,
    which is tackled later in the chapter, dedicated to lazy loading next to other
    specific topics. As a quick hint, keep in mind that `fetch().stream()` and `fetchStream()`
    are not the same thing.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了`stream()`方法外，jOOQ还提供了一个名为`fetchStream()`的方法，该方法将在本章后面讨论，专门用于懒加载以及其他特定主题。作为一个快速提示，请记住`fetch().stream()`和`fetchStream()`不是同一回事。
- en: The examples from this section are grouped in the *FunctionalJooq* application.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例被分组在*FunctionalJooq*应用程序中。
- en: Fluent programmatic configuration
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流畅的编程配置
- en: 'In the previous chapter, you already had a flavor of constructing the Code
    Generator configuration via the programmatic fluent API. The following snippet
    of code is just another example of the jOOQ `Settings` fluent API:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你已经通过程序化的流畅API构建了代码生成器配置的滋味。以下代码片段只是jOOQ `Settings`流畅API的另一个示例：
- en: '[PRE424]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: These are not the only cases when the jOOQ fluent API rocks. For instance, check
    the jOOQ JavaFX application for creating a bar chart from a jOOQ `result`. This
    is available in the jOOQ manual.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是jOOQ流畅API闪耀的唯一情况。例如，检查jOOQ JavaFX应用程序，它可以从jOOQ `result`创建条形图。这在jOOQ手册中可用。
- en: Next, let's see how jOOQ emphasizes that our fluent code should respect the
    SQL syntax correctness.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看jOOQ如何强调我们的流畅代码应该尊重SQL语法的正确性。
- en: Highlighting that jOOQ emphasizes SQL syntax correctness
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强调jOOQ注重SQL语法的正确性
- en: One of the coolest features of jOOQ consists of the fact that jOOQ doesn't allow
    us to write bad SQL syntax. If you aren't an SQL expert or simply have issues
    with SQL-specific syntax, then all you have to do is to let jOOQ guide you step
    by step.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ最酷的特性之一是它不允许我们编写错误的SQL语法。如果你不是SQL专家或者只是对SQL特定的语法有问题，那么你所要做的就是让jOOQ一步步引导你。
- en: Having a fluent API for chaining methods to obtain a SQL is cool, but having
    a fluent API that emphasizes SQL syntax correctness is the coolest. jOOQ knows
    exactly how the query parts fit the puzzle and will help you via your IDE.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个流畅的API来链式调用方法以获取SQL是酷的，但拥有一个强调SQL语法正确性的流畅API是最酷的。jOOQ确切地知道查询部分如何拼凑成完整的拼图，并且将通过你的IDE帮助你。
- en: 'For instance, let''s assume that we *accidentally* wrote the following bad
    SQLs. Let''s start with an SQL that misses the `ON` clause:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们*意外地*编写了以下错误的SQL。让我们从一个缺少`ON`子句的SQL开始：
- en: '[PRE431]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'The IDE signals this issue immediately, as shown in the following figure:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中所示，IDE立即发出此问题的信号：
- en: '![Figure 3.3 – Wrong SQL'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.3 – Wrong SQL'
- en: '](img/B16833_Figure_3.3.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_3.3.jpg]'
- en: Figure 3.3 – Wrong SQL
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 错误的SQL
- en: 'Let''s continue with another wrong SQL that uses `JOIN` in an improper place:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续另一个错误的SQL，它在不适当的位置使用了`JOIN`：
- en: '[PRE437]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: 'And, for the last example, let''s look at a wrong SQL that misses `over()`:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看一个缺少`over()`的错误的SQL：
- en: '[PRE447]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: Of course, we can continue like this forever, but I think you get the idea!
    So, count on jOOQ!
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以永远这样继续下去，但我认为你已经明白了这个想法！所以，相信jOOQ吧！
- en: Casting, coercing, and collating
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换、强制转换和比较
- en: jOOQ was designed to handle most of the casting issues under the hood, including
    for ultra-strong-typed databases such as DB2\. Nevertheless, explicit casting
    and/or coercing still serve some isolated cases. Most probably, we'll need them
    when we are not satisfied with the jOOQ automatic mapping (for instance, we consider
    that jOOQ didn't find the most accurate mapping), or we just need a certain type
    to respond to a special case. Even if they add a little bit of verbosity, casting
    and coercing can be used fluently; therefore, the DSL expressions are not disrupted.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ被设计用来在底层处理大多数类型转换问题，包括对于如DB2这样的超强类型数据库。尽管如此，显式的类型转换和/或强制转换仍然适用于一些孤立的情况。很可能会在我们对jOOQ自动映射不满意（例如，我们认为jOOQ没有找到最精确的映射）或我们需要某种类型来应对特殊情况时使用它们。即使它们增加了一点点冗余，类型转换和强制转换也可以流畅地使用；因此，DSL表达式不会被破坏。
- en: Casting
  id: totrans-670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换
- en: 'Most of the time, jOOQ finds the most accurate data type mapping between the
    database and Java. If we look into a jOOQ generated class that mirrors a database
    table, then we see that, for each column that has a database-specific type (for
    example, `VARCHAR`), jOOQ has found a Java type correspondent (for example, `String`).
    If we compare the schema of the `PAYMENT` table with the generated `jooq.generated.tables.Payment`
    class, then we find the following data type correspondence:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，jOOQ 在数据库和 Java 之间找到最准确的数据类型映射。如果我们查看一个反映数据库表的 jOOQ 生成的类，那么我们会看到，对于每个具有数据库特定类型（例如，`VARCHAR`）的列，jOOQ
    都找到了一个 Java 类型对应物（例如，`String`）。如果我们比较 `PAYMENT` 表的架构与生成的 `jooq.generated.tables.Payment`
    类，那么我们会发现以下数据类型对应关系：
- en: '![Figure 3.4 – Type mapping between the database and Java'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 数据库和 Java 之间的类型映射'
- en: '](img/B16833_Figure_3.4.jpg)'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_3.4.jpg)'
- en: Figure 3.4 – Type mapping between the database and Java
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 数据库和 Java 之间的类型映射
- en: 'When the jOOQ mapping is not what we need or jOOQ cannot infer a certain type,
    then we can rely on the jOOQ casting API, which contains the following methods:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 当 jOOQ 映射不是我们需要的，或者 jOOQ 无法推断出某种类型时，我们可以依赖 jOOQ 转换 API，它包含以下方法：
- en: '[PRE456]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: 'Besides these methods, the `DSL` class contains these methods:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方法之外，`DSL` 类还包含以下方法：
- en: '[PRE462]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'Let''s have some examples against MySQL and let''s start with the following
    query that maps the fetched data to the Java types that jOOQ has automatically
    chosen:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 MySQL 举一些例子，并从以下查询开始，该查询将获取的数据映射到 jOOQ 自动选择的 Java 类型：
- en: '[PRE468]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: 'So, `INVOICE_AMOUNT` is mapped to `BigDecimal`, and `CACHING_DATE` is mapped
    to `LocalDateTime`. Let''s assume that we are in a corner-case scenario that requires
    us to fetch `INVOICE_AMOUNT` as `String` and `CACHING_DATE` as `LocalDate`. Of
    course, we can loop the preceding result and perform the conversions of each record
    in Java, but, at the query level, we can accomplish this via jOOQ `cast()`, as
    follows:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`INVOICE_AMOUNT` 映射到 `BigDecimal`，而 `CACHING_DATE` 映射到 `LocalDateTime`。让我们假设我们处于一个特殊情况，需要将
    `INVOICE_AMOUNT` 作为 `String` 和 `CACHING_DATE` 作为 `LocalDate` 获取。当然，我们可以循环前面的结果并在
    Java 中执行每个记录的转换，但在查询级别，我们可以通过 jOOQ 的 `cast()` 方法完成此操作，如下所示：
- en: '[PRE474]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: 'Check out the SQL string generated after using `cast()`:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 查看使用 `cast()` 生成的 SQL 字符串：
- en: '[PRE483]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: 'In the following figure, you can see the result set returned by these two SQLs:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，你可以看到这两个 SQL 返回的结果集：
- en: '![Figure 3.5 – Casting results'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 投影结果'
- en: '](img/B16833_Figure_3.5.jpg)'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_3.5.jpg)'
- en: Figure 3.5 – Casting results
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 转换结果
- en: Notice that the jOOQ casting operations are rendered in the generated SQL string,
    therefore, the database is responsible for performing these casts. But, in this
    scenario, do we really need these clumsy castings or do we actually need data
    type coercions?
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，jOOQ 投影操作在生成的 SQL 字符串中呈现，因此，数据库负责执行这些转换。但是，在这种情况下，我们真的需要这些笨拙的转换，还是我们实际上需要数据类型强制转换？
- en: Coercing
  id: totrans-719
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制转换
- en: 'Data type coercions act like casting, except that they have no footprint on
    the actual SQL query being generated. In other words, data type coercions act
    as an unsafe cast in Java and are not rendered in the SQL string. With data type
    coercions, we only instruct jOOQ to pretend that a data type is of another data
    type and to bind it accordingly. Whenever possible, it is preferable to use coercions
    over casting. This way, we don''t risk casting issues and we don''t pollute the
    generated SQL with unnecessary castings. The API consists of several methods:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型强制转换类似于转换，但它们对生成的实际 SQL 查询没有影响。换句话说，数据类型强制转换在 Java 中充当不安全的转换，并且不会在 SQL 字符串中呈现。使用数据类型强制转换，我们只指示
    jOOQ 假设一个数据类型是另一种数据类型，并相应地绑定它。尽可能的情况下，我们更愿意使用强制转换而不是转换。这样，我们就不必担心转换问题，也不必用不必要的转换污染生成的
    SQL。API 由几个方法组成：
- en: '[PRE490]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: 'Besides these methods, the `DSL` class contains these methods:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方法之外，`DSL` 类还包含以下方法：
- en: '[PRE496]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: 'In the example from the *Casting* section, we relied on casting from `BigDecimal`
    to `String` and from `LocalDateTime` to `LocalDate`. This casting was rendered
    in the SQL string and was performed by the database. But, we can avoid polluting
    the SQL string with these casts via coercion as follows:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *转换* 部分的示例中，我们依赖于从 `BigDecimal` 到 `String` 以及从 `LocalDateTime` 到 `LocalDate`
    的转换。这种转换在 SQL 字符串中呈现，并由数据库执行。但是，我们可以通过强制转换避免用这些转换污染 SQL 字符串，如下所示：
- en: '[PRE502]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: 'The produced result set is the same as in the case of using casting, but the
    SQL string doesn''t reflect coercions and the database didn''t perform any casting
    operations. This is much better and safer:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的结果集与使用类型转换的情况相同，但 SQL 字符串没有反映强制转换，数据库也没有执行任何类型转换操作。这更好也更安全：
- en: '[PRE510]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: 'Starting with version 3.12, jOOQ allows for coercing `ResultQuery<R1>` to a
    new `ResultQuery<R2>` type as well. For instance, check out this plain SQL:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.12 开始，jOOQ 允许将 `ResultQuery<R1>` 强制转换为新的 `ResultQuery<R2>` 类型。例如，查看以下纯
    SQL：
- en: '[PRE517]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: 'The result type of this query is `Result<Record>` but we can easily replace
    `fetch()` with `fetchInto()` to map this result to the generated `Employee` POJO
    (only the `firstName` and `lastName` fields will be populated) or to a custom
    POJO containing only the fetched fields. But, how about fetching `Result<Record2<String,
    String>>`? This can be accomplished via one of the `ResultQuery.coerce()` flavors
    as follows:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的结果类型为 `Result<Record>`，但我们可以轻松地将 `fetch()` 替换为 `fetchInto()` 以将此结果映射到生成的
    `Employee` POJO（只有 `firstName` 和 `lastName` 字段将被填充）或只包含获取字段的自定义 POJO。但是，如何获取 `Result<Record2<String,
    String>>`？这可以通过 `ResultQuery.coerce()` 的一种变体来实现，如下所示：
- en: '[PRE519]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: Coercing a result set to a table can be done via `ResultQuery.coerce(Table<X>
    table)`. You can find an example in the bundled code next to an alternative before
    jOOQ 3.12\. If during coercing, jOOQ finds any `Converter` or `Binding` configurations,
    then it will apply them (this is covered in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110),
    *Types, Converters, and Bindings*).
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `ResultQuery.coerce(Table<X> table)` 将结果集强制转换为表。您可以在捆绑代码中找到一个示例，在 jOOQ
    3.12 之前的替代方案旁边。如果在强制转换过程中，jOOQ 发现任何 `Converter` 或 `Binding` 配置，则它将应用它们（这在 [*第
    7 章*](B16833_07.xhtml#_idTextAnchor110)，*类型、转换器和绑定*）中有所介绍。
- en: Coercing versus casting
  id: totrans-760
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制转换与类型转换
- en: 'Don''t conclude that `coerce()` can replace `cast()` all the time. Check out
    this example that uses `coerce()`:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 不要认为 `coerce()` 总是可以替换 `cast()`。查看以下使用 `coerce()` 的示例：
- en: '[PRE523]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: So, we pretend that `BUY_PRICE` is `BigDecimal` having a precision of *10* and
    a scale of `5`, and `PRODUCT_DESCRIPTION` is a string of length *10*. But, coercing
    cannot do that. In this case, coercing can pretend the `BigDecimal` (`BUY_PRICE`
    is really treated as a `BigDecimal` value), and `String` (`PRODUCT_DESCRIPTION`
    is really treated as a `String` value) types, but it cannot pretend the domain
    constraints.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们假装 `BUY_PRICE` 是具有 *10* 位精度和 *5* 位刻度的 `BigDecimal`，而 `PRODUCT_DESCRIPTION`
    是长度为 *10* 的字符串。但是，强制转换无法做到这一点。在这种情况下，强制转换可以假装 `BigDecimal`（`BUY_PRICE` 实际上被当作
    `BigDecimal` 值处理），以及 `String`（`PRODUCT_DESCRIPTION` 实际上被当作 `String` 值处理）类型，但它不能假装域约束。
- en: 'Let''s replace `coerce()` with `cast()`:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `coerce()` 替换为 `cast()`：
- en: '[PRE531]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: 'This time, casting is rendered in the generated SQL string. The following figure
    compares the result of using `coerce()` and `cast()`; this works as expected:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，类型转换在生成的 SQL 字符串中得到了体现。以下图比较了使用 `coerce()` 和 `cast()` 的结果；这正如预期的那样工作：
- en: '![Figure 3.6 – Coercing versus casting (1)'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 强制转换与类型转换（1）'
- en: '](img/B16833_Figure_3.6.jpg)'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_3.6.jpg)'
- en: Figure 3.6 – Coercing versus casting (1)
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 强制转换与类型转换（1）
- en: 'Let''s have one more example. Check out this example that uses `coerce()`:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个示例。查看以下使用 `coerce()` 的示例：
- en: '[PRE539]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '`PAYMENT.PAYMENT_DATE` is a timestamp, therefore, it is not enough to pretend
    that it is a date since the time component will fail our predicate. For instance,
    *2003-04-09 09:21:25* is not equal to *2003-04-09*. In this case, we need an actual
    cast from timestamp to date as follows:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '`PAYMENT.PAYMENT_DATE` 是一个时间戳，因此，仅仅假装它是日期是不够的，因为时间部分将使我们的谓词失败。例如，*2003-04-09
    09:21:25* 不等于 *2003-04-09*。在这种情况下，我们需要将时间戳实际转换为日期，如下所示：'
- en: '[PRE547]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: 'This time, the cast takes place via this SQL (for *2003-04-09*):'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，转换是通过以下 SQL（对于 *2003-04-09*）进行的：
- en: '[PRE555]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: 'The following figure compares the results of using `coerce()` and `cast()`:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图比较了使用 `coerce()` 和 `cast()` 的结果：
- en: '![Figure 3.7 – Coercing versus casting (2)'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 强制转换与类型转换（2）'
- en: '](img/B16833_Figure_3.7.jpg)'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_3.7.jpg)'
- en: Figure 3.7 – Coercing versus casting (2)
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 强制转换与类型转换（2）
- en: Another good example where cast works and coerce does not is when the cast is
    performed in `GROUP BY`, which isn't uncommon when grouping timestamp columns
    by `CAST(ts AS DATE)`. Also, when the value being cast is an expression, not a
    bind variable, the effect is different (although coerce can be used to compare,
    for instance, `INTEGER` columns with `BIGINT` columns without the database needing
    to convert anything).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 cast 起作用而 coerce 不起作用的良好例子是在 `GROUP BY` 中执行 cast，这在按 `CAST(ts AS DATE)`
    对时间戳列进行分组时并不罕见。此外，当被 cast 的值是表达式而不是绑定变量时，效果不同（尽管可以使用 coerce 来比较，例如，`INTEGER` 列与
    `BIGINT` 列，而无需数据库进行任何转换）。
- en: Important Note
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As a rule of thumb, in some cases when both could work (for instance, when you
    project the expressions), it is best to use `coerce()` rather than `cast()`. This
    way, you don't risk unsafe or raw-type casting in Java and you don't pollute the
    generated SQL with unnecessary castings.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验法则，在某些情况下，当两者都可以工作（例如，当你投影表达式时），最好使用 `coerce()` 而不是 `cast()`。这样，你就不必担心在
    Java 中进行不安全或原始类型转换的风险，也不会在生成的 SQL 中引入不必要的转换。
- en: Next, let's discuss collations.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论校对规则。
- en: Collation
  id: totrans-815
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 校对规则
- en: 'Databases define a character set as a set of symbols and encodings. A collation
    defines a set of rules for comparing (ordering) characters in a character set.
    jOOQ allows us to specify a collation via `collation``(Collation collation)` for
    `org.jooq.DateType` and via `collate``(String collation)`, `collate``(Collation
    collation)`, and `collate``(Name collation)` for `org.jooq.Field`. Here is an
    example of setting the `latin1_spanish_ci` collation for a field:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库将字符集定义为符号和编码的集合。校对规则定义了在字符集中比较（排序）字符的规则。jOOQ 允许我们通过 `collation`（校对规则）为 `org.jooq.DateType`
    指定校对规则，以及通过 `collate`（字符串校对规则）、`collate`（校对规则）和 `collate`（名称校对规则）为 `org.jooq.Field`
    指定校对规则。以下是一个为字段设置 `latin1_spanish_ci` 校对规则的示例：
- en: '[PRE559]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: All the examples from this section are available in the *CastCoerceCollate*
    application.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有示例都可在 *CastCoerceCollate* 应用程序中找到。
- en: Binding values (parameters)
  id: totrans-823
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定值（参数）
- en: Binding values is another fundamental topic of jOOQ.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定值是 jOOQ 的另一个基本主题。
- en: The well-known prepared statements and bind values combination is the preferable
    approach to express SQL statements in JDBC. Among benefits, this combination provides
    protection against SQL injections, sustains caching (for instance, most connection
    pools cache prepared statements across connections or rely on JDBC driver caching
    capabilities as HikariCP does), and reusability capabilities (re-using execution
    plans for identical SQL statements, regardless of actual bind values).
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，在 JDBC 中表达 SQL 语句时，使用预定义语句和绑定值的组合是首选方法。这种组合的好处包括提供对 SQL 注入的保护、支持缓存（例如，大多数连接池会在连接之间缓存预定义语句，或者像
    HikariCP 一样依赖 JDBC 驱动程序的缓存功能），以及可重用性能力（对于相同的 SQL 语句，无论实际的绑定值如何，都可以重用执行计划）。
- en: Having security and performance packed into this combination makes it preferable
    against static statements (`java.sql.Statement`) and inlined values, so jOOQ also
    embraces it as default.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 将安全和性能打包在这个组合中使其比静态语句（`java.sql.Statement`）和内联值更可取，因此 jOOQ 也将其作为默认选项。
- en: Important Note
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: By default, jOOQ aligns its support for bind values to JDBC style. In other
    words, jOOQ relies on `java.sql.PreparedStatement` and indexed bind values or
    indexed parameters. Moreover, exactly like JDBC, jOOQ uses a `?` (question mark)
    character for marking the bind value placeholders.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，jOOQ 将其对绑定值的支持与 JDBC 风格对齐。换句话说，jOOQ 依赖于 `java.sql.PreparedStatement` 和索引绑定值或索引参数。此外，与
    JDBC 一样，jOOQ 使用 `?`（问号）字符来标记绑定值占位符。
- en: However, in contrast to JDBC, which supports only indexed parameters and the
    `?` character, jOOQ supports named and inlined parameters as well. Each of them
    is detailed in this section.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与只支持索引参数和 `?` 字符的 JDBC 相比，jOOQ 还支持命名和内联参数。每个参数的详细信息都在本节中介绍。
- en: 'So, in JDBC, the only way to exploit bind values aligns to the following example:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 JDBC 中，利用绑定值的唯一方法是以下示例：
- en: '[PRE564]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: In other words, in JDBC, it is our responsibility to keep track of the number
    of question marks and their corresponding index. This becomes cumbersome in complex/dynamic
    queries.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在 JDBC 中，跟踪问号的数量及其对应索引是我们的责任。在复杂/动态查询中，这会变得很繁琐。
- en: As Lukas Eder highlights, "*The strength of languages such as L/SQL, PL/pgSQL,
    T-SQL (among other things) is precisely the fact that prepared statements can
    naturally embed bind values transparently, without the user having to think about
    the binding logic*."
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Lukas Eder强调的，“L/SQL、PL/pgSQL、T-SQL（以及其他一些语言）的强大之处在于，预处理语句可以自然地透明地嵌入绑定值，而无需用户考虑绑定逻辑。”
- en: Now, let's see how jOOQ tackles bind values via indexed bind values or indexed
    parameters.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看jOOQ是如何通过索引绑定值或索引参数来处理绑定值的。
- en: Indexed parameters
  id: totrans-842
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引参数
- en: 'Writing the previous query via jOOQ''s DSL API can be done as follows:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 通过jOOQ的DSL API编写之前的查询可以这样做：
- en: '[PRE572]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: 'Even if it looks like we''ve inlined the values (*5000* and *Sales Rep*), this
    is not true. jOOQ abstracts away the JDBC frictions and allows us to use indexed
    parameters exactly where needed (directly in SQL). Since jOOQ takes care of everything,
    we don''t even care about the indexes of the parameters. Moreover, we take advantage
    of type-safety for these parameters and we don''t need to explicitly set their
    type. The preceding SQL renders the following SQL string (notice the rendered
    question marks as bind values placeholders):'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 即使看起来我们内联了值（*5000* 和 *Sales Rep*），这并不是真的。jOOQ抽象掉了JDBC摩擦，并允许我们在需要的地方（直接在SQL中）使用索引参数。由于jOOQ负责一切，我们甚至不需要关心参数的索引。此外，我们利用这些参数的类型安全性，并且不需要显式设置它们的类型。前面的SQL生成了以下SQL字符串（注意渲染的问号作为绑定值占位符）：
- en: '[PRE577]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: 'And, after jOOQ resolves the bind values, we have the following:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在jOOQ解析了绑定值之后，我们得到以下结果：
- en: '[PRE583]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: 'Behind the scene, jOOQ uses a method named `DSL.val(value)` for transforming
    the given `value` argument (`value` can be `boolean`, `byte`, `String`, `float`,
    `double`, and so on) into a bind value. This `DSL.val()` method wraps and returns
    a bind value via the `org.jooq.Param` interface. This interface extends `org.jooq.Field`,
    therefore, extends a column expression(or field) and can be used accordingly via
    the jOOQ API. The previous query can also be written by explicitly using `DSL.val()`
    as follows:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，jOOQ使用一个名为`DSL.val(value)`的方法来将给定的`value`参数（`value`可以是`boolean`、`byte`、`String`、`float`、`double`等）转换为绑定值。这个`DSL.val()`方法通过`org.jooq.Param`接口包装并返回一个绑定值。这个接口扩展了`org.jooq.Field`，因此扩展了一个列表达式（或字段）并且可以通过jOOQ
    API相应地使用。之前的查询也可以通过显式使用`DSL.val()`来编写，如下所示：
- en: '[PRE589]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: But, as you just saw, using `val()` explicitly is not needed in this case. Using
    `val()` like this is just adding noise to the SQL expression.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如你刚才看到的，在这种情况下显式使用`val()`是不必要的。这样使用`val()`只是在SQL表达式中添加噪音。
- en: 'In this query, we''ve used hardcoded values, but, most probably, these values
    represent user inputs that land in the query via the arguments of the method containing
    this query. Check out this example, which extracts these hardcoded values as arguments
    of the method:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，我们使用了硬编码的值，但，很可能是这些值代表了通过包含此查询的方法的参数进入查询的用户输入。查看以下示例，它将这些硬编码的值作为方法的参数提取出来：
- en: '[PRE594]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: Of course, mixing hardcoded and user input values in the same query is supported
    as well. Next, let's tackle a bunch of examples where the explicit usage of `val()`
    is really needed.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在同一个查询中混合硬编码和用户输入值也是支持的。接下来，让我们处理一些确实需要显式使用`val()`的例子。
- en: Explicit usage of val()
  id: totrans-880
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式使用`val()`
- en: 'There are cases when we cannot pass plain values to jOOQ and expect back bind
    values. There are a few such cases:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不能将普通值传递给jOOQ并期望返回绑定值。有一些这样的情况：
- en: When the bind value is at the left-hand side of an operator
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当绑定值位于运算符的左侧时
- en: When `Field` references and `Param` values are mixed
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`Field`引用和`Param`值混合时
- en: When the bind value occurs in a clause that doesn't support it (for instance, in
    `select()`)
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当绑定值出现在不支持它的子句中时（例如，在`select()`中）
- en: When functions require a `Field<T>` type for one of the parameters
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数需要一个`Field<T>`类型作为其中一个参数时
- en: Let's have some examples.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些例子。
- en: Bind value is at the left-hand side of an operator
  id: totrans-887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绑定值位于运算符的左侧
- en: 'Having the plain value at the left-hand side of an operator doesn''t allow
    us to write the needed jOOQ expression since we don''t have access to the jOOQ
    DSL API. For instance, we cannot write `...5000.eq(EMPLOYEE.SALARY)` since the
    `eq()` method is not available. On the other hand, we should write `...val(5000).eq(EMPLOYEE.SALARY)`.
    This time, *5000* is wrapped in `Param` (which extends `Field`) via `val(int/Integer
    value)` and we can continue to exploit the jOOQ DSL API, such as the `eq()` method.
    Here is another example:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作符的左侧有普通值不允许我们编写所需的 jOOQ 表达式，因为我们没有访问 jOOQ DSL API。例如，我们不能编写 `...5000.eq(EMPLOYEE.SALARY)`，因为
    `eq()` 方法不可用。另一方面，我们应该编写 `...val(5000).eq(EMPLOYEE.SALARY)`。这次，*5000* 通过 `val(int/Integer
    value)` 被包装在 `Param`（它扩展了 `Field`）中，我们可以继续利用 jOOQ DSL API，例如 `eq()` 方法。以下是一个另一个示例：
- en: '[PRE602]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: 'Here is an example where the value is a user input:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个值是用户输入的示例：
- en: '[PRE608]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: Next, let's see the other case, when `Field` references and `Param` values are
    mixed.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看另一个案例，当 `Field` 引用和 `Param` 值混合时。
- en: Field references and Param values are mixed
  id: totrans-904
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 混合 Field 引用和 Param 值
- en: 'Let''s consider that we want to use the `DSL.concat(Field<?>... fields)` method
    for concatenating `CUSTOMER.CONTACT_FIRST_NAME`, the whitespace literal (`" "`),
    and `CUSTOMER.CONTACT_LAST_NAME` (for example, *Joana Nimar*). While `CONTACT_FIRST_NAME`
    and `CONTACT_LAST_NAME` are fields, the whitespace literal (`" "`) cannot be used
    in this context as a plain string. But, it can be wrapped in `Param` via the `val()`
    method, as follows:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们想要使用 `DSL.concat(Field<?>... fields)` 方法来连接 `CUSTOMER.CONTACT_FIRST_NAME`、空格文本（`"
    "`）和 `CUSTOMER.CONTACT_LAST_NAME`（例如，*Joana Nimar*）。虽然 `CONTACT_FIRST_NAME` 和
    `CONTACT_LAST_NAME` 是字段，但空格文本（`" "`）在这个上下文中不能作为一个普通字符串使用。但是，它可以通过 `val()` 方法被包装，如下所示：
- en: '[PRE615]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: 'Here is another example that mixes the jOOQ internal usage of `val()` and our
    explicit usage of `val()` for wrapping a user input value to add it as a column
    in the result set:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个示例，它混合了 jOOQ 内部对 `val()` 的使用和我们对将用户输入值包装为结果集中列的显式 `val()` 使用：
- en: '[PRE620]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: 'Here is another example of mixing implicit and explicit `val()` usage for writing
    a simple arithmetic expression, *mod((((10 - 2) * (7 / 3)) / 2), 10)*:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个混合隐式和显式 `val()` 使用来编写简单算术表达式的示例，*mod((((10 - 2) * (7 / 3)) / 2), 10)*：
- en: '[PRE630]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: 'When the same parameter is used multiple times, it is advisable to extract
    it as in the following example:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一个参数被多次使用时，建议像以下示例中那样提取它：
- en: '[PRE632]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: While we take care of the `salary` value, jOOQ will take care of the *0.15*
    and *10000* constants. All three will become indexed bind values.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们关注 `salary` 值时，jOOQ 将处理 *0.15* 和 *10000* 常量。所有三个都将成为索引绑定值。
- en: Bind values from string query
  id: totrans-936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自字符串查询的绑定值
- en: 'If, for some reason, you want to bind values directly from a string query,
    then you can do it via plain SQL as in the following example:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，您想直接从字符串查询中绑定值，那么您可以通过以下示例中的普通 SQL 来实现：
- en: '[PRE641]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: Next, let's talk about the named parameters.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈命名参数。
- en: Named parameters
  id: totrans-950
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'While JDBC support is limited to indexed bind values, jOOQ goes beyond this
    limit and supports named parameters as well. Creating a jOOQ named parameter is
    accomplished via the `DSL.param()` methods. Among these methods, we have `param(String
    name, T value)`, which creates a named parameter with a name and an initial value.
    Here is an example:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JDBC 的支持仅限于索引绑定值，但 jOOQ 超越了这个限制，同时也支持命名参数。创建一个 jOOQ 命名参数是通过 `DSL.param()`
    方法实现的。在这些方法中，我们有 `param(String name, T value)`，它创建一个具有名称和初始值的命名参数。以下是一个示例：
- en: '[PRE652]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: 'Here is an example of the values of named parameters being provided as user
    inputs:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个命名参数值作为用户输入提供的示例：
- en: '[PRE658]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '[PRE664]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: 'While rendering the SQL of the previous queries, you have observed that jOOQ
    doesn''t render the names of these parameters as placeholders. It still renders
    a question mark as the default placeholder. To instruct jOOQ to render the names
    of the parameters as placeholders, we call via the `DSL.renderNamedParams()` method
    that returns a string, as in the following example:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染之前查询的 SQL 时，您已经观察到 jOOQ 并没有将这些参数的名称作为占位符渲染。它仍然使用问号作为默认占位符。为了指示 jOOQ 将参数的名称作为占位符渲染，我们通过
    `DSL.renderNamedParams()` 方法调用，该方法返回一个字符串，如下面的示例所示：
- en: '[PRE668]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: Moreover, we can specify a string to be used as a prefix for each rendered named
    parameter via `Settings.withRenderNamedParamPrefix()`. You can see an example
    in the bundled code.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过 `Settings.withRenderNamedParamPrefix()` 指定一个字符串作为每个渲染的命名参数的前缀。您可以在捆绑的代码中看到一个示例。
- en: 'The returned string can be passed to another SQL access abstraction that supports
    named parameters. For this example, the rendered SQL string is as follows:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的字符串可以传递给支持命名参数的另一个 SQL 访问抽象。例如，渲染的 SQL 字符串如下：
- en: '[PRE674]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: '[PRE675]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: '[PRE677]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: Next, let's talk about the inline parameters.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈内联参数。
- en: Inline parameters
  id: totrans-986
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联参数
- en: An inline bind value is rendered as the actual plain value via `DSL.inline()`.
    In other words, while indexed and named parameters render the bind values as placeholders
    via question marks (or names), inline parameters render their plain values directly.
    jOOQ automatically replaces the placeholders (`?` or `:name` for named parameters)
    and will properly escape inline bind values to avoid SQL syntax errors and SQL
    injection. Nevertheless, be warned that abusing the usage of the inline parameters
    may lead to poor performance on RDBMSs that have execution plan caches. So, avoid
    copying and pasting `inline()` everywhere!
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 内联绑定值通过 `DSL.inline()` 被渲染为实际的 plain 值。换句话说，虽然索引和命名参数通过问号（或名称）将绑定值作为占位符渲染，但内联参数直接渲染它们的
    plain 值。jOOQ 自动替换占位符（对于命名参数是 `?` 或 `:name`），并将内联绑定值正确转义以避免 SQL 语法错误和 SQL 注入。尽管如此，请注意，过度使用内联参数可能会导致在具有执行计划缓存的
    RDBMS 上性能下降。因此，请避免在所有地方复制和粘贴 `inline()`！
- en: 'Typically, using `inline()` for constants is a good practice. For instance,
    earlier, we used `val(" ")` to express `concat(CUSTOMER.CONTACT_FIRST_NAME, val("
    "), CUSTOMER.CONTACT_LAST_NAME))`. But, since the `" "` string is a constant,
    it can be inlined:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于常量使用 `inline()` 是一个好习惯。例如，之前，我们使用 `val(" ")` 来表示 `concat(CUSTOMER.CONTACT_FIRST_NAME,
    val(" "), CUSTOMER.CONTACT_LAST_NAME))`。但是，由于 `" "` 字符串是常量，它可以被内联：
- en: '[PRE681]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: '[PRE683]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: But, if you know that this is not a constant, then it is better to rely on `val()`
    to sustain execution plan caches.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您知道这不是一个常量，那么最好依赖于 `val()` 以维持执行计划缓存。
- en: 'At the `Configuration` level, we can use inline parameters by switching from
    the `PreparedStatement` default to a static `Statement` via jOOQ settings. For
    example, the following `DSLContext` will use static statements, and all queries
    triggered in the context of this configuration will use inline parameters:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Configuration` 层级，我们可以通过从 `PreparedStatement` 默认设置切换到静态 `Statement` 通过 jOOQ
    设置来使用内联参数。例如，以下 `DSLContext` 将使用静态语句，并且在此配置的上下文中触发的所有查询都将使用内联参数：
- en: '[PRE686]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '[PRE689]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: '[PRE691]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '[PRE692]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '[PRE694]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: '[PRE695]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: 'Obviously, another option is to rely on `inline()`:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，另一个选项是依赖于 `inline()`：
- en: '[PRE696]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '[PRE698]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: '[PRE699]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: '[PRE700]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: Of course, the inlined values can be user inputs as well. But, this technique
    is not recommended since user inputs may vary across executions and this will
    affect the performance of RDBMSs that rely on execution plan caches.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，内联值也可以是用户输入。但是，由于用户输入可能在执行过程中变化，这会影响依赖于执行计划缓存的 RDBMS 的性能。因此，不建议使用此技术。
- en: 'The previous two examples render the same SQL having the actual plain values
    inlined:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例渲染了相同的SQL，其中实际 plain 值被内联：
- en: '[PRE701]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '[PRE702]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: '[PRE703]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '[PRE704]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: '[PRE705]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: '[PRE706]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: 'Globally, we can choose the type of parameters via `Settings`, as here (indexed
    parameters (`ParamType.INDEXED`) are used by default):'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局范围内，我们可以通过 `Settings` 选择参数的类型，如下所示（默认使用索引参数 `ParamType.INDEXED`）：
- en: '[PRE707]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: '[PRE708]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '[PRE709]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: '[PRE710]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: 'Or, here is the global setting for using static statements and inline parameters:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这里是对使用静态语句和内联参数的全局设置：
- en: '[PRE711]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: '[PRE712]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: '[PRE713]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: '[PRE714]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: '[PRE715]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: '[PRE716]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: Next, let's see a handy approach to rendering a query with different types of
    parameter placeholders.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一种方便的方法来渲染具有不同类型参数占位符的查询。
- en: Rendering a query with different types of parameter placeholders
  id: totrans-1033
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染具有不同类型参数占位符的查询
- en: 'Let''s assume that we have a query that uses indexed parameters and we need
    to render it as a certain SQL string having a different type of parameter placeholder
    (for instance, this may be required by another SQL abstraction):'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个使用索引参数的查询，并且我们需要将其渲染为具有不同类型参数占位符的特定 SQL 字符串（例如，这可能是另一个 SQL 抽象所必需的）：
- en: '[PRE717]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '[PRE718]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: '[PRE719]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: '[PRE720]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: '[PRE721]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: 'A handy approach for rendering this query with a different type of parameter
    placeholder relies on the `Query.getSQL(ParamType)` method as follows:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同类型参数占位符渲染此查询的便捷方法依赖于 `Query.getSQL(ParamType)` 方法，如下所示：
- en: '`ParamType.INDEXED` (in this example, this is the default behavior):'
  id: totrans-1041
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParamType.INDEXED`（在这个例子中，这是默认行为）:'
- en: '[PRE722]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '`ParamType.NAMED` (for parameters with names, this produces placeholders of
    the`:name` type, but for unnamed parameters, it produces `:1`, `:2`, to `:n`,
    therefore, a combination of colon and index):'
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParamType.NAMED`（对于有名称的参数，这会产生`:name`类型的占位符，但对于无名称的参数，则产生`:1`、`:2`到`:n`，因此，是冒号和索引的组合）:'
- en: '[PRE723]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '`ParamType.INLINED` and `ParamType.NAMED_OR_INLINED`:'
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParamType.INLINED` 和 `ParamType.NAMED_OR_INLINED`:'
- en: '[PRE724]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: In this case, `ParamType.INLINED` and `ParamType.NAMED_OR_INLINED` produce the
    same output – inlined plain values. Actually, `ParamType.NAMED_OR_INLINED` generates
    named parameter placeholders only for parameters that are named explicitly, otherwise,
    it inlines all unnamed parameters. You can see more examples in the code bundled
    with the book.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`ParamType.INLINED` 和 `ParamType.NAMED_OR_INLINED` 产生相同的输出 - 内联普通值。实际上，`ParamType.NAMED_OR_INLINED`
    只为显式命名的参数生成命名参数占位符，否则，它将内联所有未命名的参数。您可以在本书附带代码中看到更多示例。
- en: Next, let's see how we can extract jOOQ parameters from the query as `List<Object>`.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何将 jOOQ 参数从查询中提取为 `List<Object>`。
- en: Extracting jOOQ parameters from the query
  id: totrans-1049
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从查询中提取 jOOQ 参数
- en: 'Accessing all types of supported parameters of a query can be accomplished
    via `Query.getParams()`, while accessing a single parameter can be done by index
    via `Query.getParam()`, as in the following example, which uses indexed parameters
    (the same approach can be used for inlined parameters):'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Query.getParams()` 可以访问查询的所有支持类型参数，而通过索引访问单个参数可以通过 `Query.getParam()` 完成，如下例所示，它使用了索引参数（相同的方法也可以用于内联参数）：
- en: '[PRE725]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '[PRE726]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: '[PRE727]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: '[PRE728]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: '[PRE729]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '[PRE730]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '[PRE731]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '[PRE733]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: 'If we use named parameters, then those names can be used in place of indexes:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用命名参数，则可以使用这些名称代替索引：
- en: '[PRE734]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '[PRE735]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: '[PRE736]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: '[PRE737]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: '[PRE738]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '[PRE739]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: '[PRE740]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: '[PRE741]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: '[PRE742]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: '[PRE743]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: '[PRE744]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: As you'll see soon, parameters can be used to set new binding values. Next,
    let's see how we can extract indexed and named parameters.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 如您很快就会看到的，参数可以用来设置新的绑定值。接下来，让我们看看如何提取索引和命名参数。
- en: Extracting binding values
  id: totrans-1073
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取绑定值
- en: Having a parameter, we can extract its underlying bind value via `getValue()`.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个参数，我们可以通过 `getValue()` 提取其底层的绑定值。
- en: 'But, extracting all the query bind values for indexed and named parameters
    without interacting with `Param` can be done via `getBindValues()`. This method
    returns `List<Object>` containing all the bind values of the query represented
    as a query or any of its subinterfaces such as `ResultQuery`, `Select`, and so
    on. Here is an example for indexed parameters:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在不与 `Param` 交互的情况下，可以通过 `getBindValues()` 提取索引和命名参数的所有查询绑定值。此方法返回 `List<Object>`，其中包含查询的所有绑定值，表示为查询或其任何子接口，如
    `ResultQuery`、`Select` 等。以下是一个索引参数的示例：
- en: '[PRE745]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: '[PRE746]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: '[PRE747]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '[PRE748]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: '[PRE749]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: '[PRE750]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: '[PRE751]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: '[PRE752]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: '[PRE753]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: 'And, here is an example for named parameters:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是一个命名参数的示例：
- en: '[PRE754]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: '[PRE755]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: '[PRE756]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: '[PRE757]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '[PRE758]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: '[PRE759]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: '[PRE760]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: '[PRE761]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: '[PRE762]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: '[PRE763]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: In both examples, the returned list will contain two bind values, [*5000* and
    *Sales Rep*]. For inline parameters, `getBindValues()` returns an empty list.
    This is happening because, unlike `getParams()`, which returns all types of supported
    parameters, `getBindValues()` returns only actual bind values that render an actual
    placeholder.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，返回的列表将包含两个绑定值，[*5000* 和 *销售代表*]。对于内联参数，`getBindValues()` 返回一个空列表。这是因为，与返回所有支持类型的参数的
    `getParams()` 不同，`getBindValues()` 只返回实际渲染实际占位符的实际绑定值。
- en: 'We can use the extracted binding values in another SQL abstraction, such as
    `JdbcTemplate` or JPA. For instance, here is `JdbcTemplate`:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用提取的绑定值在另一个 SQL 抽象中，例如 `JdbcTemplate` 或 JPA。例如，以下是一个 `JdbcTemplate` 的示例：
- en: '[PRE764]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: '[PRE765]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: '[PRE766]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: '[PRE767]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: '[PRE768]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: '[PRE769]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: Setting new bind values
  id: totrans-1104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置新的绑定值
- en: We must start this section with the following important note.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须以以下重要注意事项开始本节。
- en: Important Note
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Conforming to jOOQ documentation, starting with version 4.0, jOOQ plans to make
    the `Param` class immutable. Modifying `Param` values is strongly discouraged;
    therefore, use the information from this section carefully.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 jOOQ 文档，从版本 4.0 开始，jOOQ 计划使 `Param` 类不可变。强烈不建议修改 `Param` 值；因此，请仔细使用本节中的信息。
- en: 'Nevertheless, modifying bind values via `Param` was still possible when this
    book was written. For instance, the following example executes an SQL with an
    initial set of bind values, sets new bind values, and executes the query again.
    Setting new bind values is done via the deprecated `setConverted()` method:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在本书编写时，通过 `Param` 修改绑定值仍然是可能的。例如，以下示例执行了一个带有初始绑定值的 SQL 语句，设置新的绑定值，然后再次执行查询。设置新的绑定值是通过已弃用的
    `setConverted()` 方法完成的：
- en: '[PRE770]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: '[PRE771]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: '[PRE772]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: '[PRE773]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: '[PRE774]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: '[PRE775]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: '[PRE776]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: '[PRE777]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: '[PRE778]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: '[PRE779]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: '[PRE780]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: '[PRE781]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: '[PRE782]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: '[PRE783]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: '[PRE784]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: '[PRE785]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: '[PRE786]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: '[PRE787]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: '[PRE788]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: '[PRE789]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: 'The `Query` interface also allows for setting new bind values directly, without
    explicitly accessing the `Param` type via the `bind()` method as follows (if there
    are named parameters that refer to them via their names instead of indexes):'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query` 接口还允许直接设置新的绑定值，而无需通过 `bind()` 方法显式访问 `Param` 类型，如下所示（如果有通过名称而不是索引引用它们的命名参数）：'
- en: '[PRE790]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: '[PRE791]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: '[PRE792]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: '[PRE793]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: '[PRE794]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: '[PRE795]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: '[PRE796]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: '[PRE797]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: '[PRE798]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: '[PRE799]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: '[PRE800]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: '[PRE801]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: '[PRE802]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: '[PRE803]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: '[PRE804]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: '[PRE805]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: '[PRE806]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: '[PRE807]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: Nevertheless, behind the scene, `bind()` works via `Param.setConverted()`.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在幕后，`bind()` 通过 `Param.setConverted()` 工作。
- en: For convenience (but, not required), notice that both examples take advantage
    of the fact that a `PreparedStatement` can be reused with different bind values.
    First, we ask jOOQ to keep the statement open via `keepStatement(true)`. Second,
    the `Query` becomes like a resource that must be closed via `Query.close()` or
    in a `try-with-resources` statement.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便（但不是必需的），请注意，这两个示例都利用了`PreparedStatement`可以与不同的绑定值重用的特性。首先，我们通过`keepStatement(true)`请求jOOQ保持语句打开。其次，`Query`变成了必须通过`Query.close()`或`try-with-resources`语句关闭的资源。
- en: In the case of inline parameters, jOOQ will automatically close any underlying
    `PreparedStatement` in order for new bind values to have an effect; therefore,
    there is no use in keeping the statements open. The code is straightforward and
    is available in the code bundled with the book.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 在内联参数的情况下，jOOQ会自动关闭任何底层的`PreparedStatement`，以便新的绑定值能够生效；因此，保持语句打开是没有必要的。代码简单直接，可以在本书附带代码中找到。
- en: Named/unnamed parameters with no initial value
  id: totrans-1151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无初始值的命名/无名称参数
- en: While in the previous examples the parameters have an initial value that was
    modified later, jOOQ also supports named/unnamed parameters with no initial value.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，参数具有后来修改的初始值，而jOOQ也支持没有初始值的命名/无名称参数。
- en: If you need a named parameter without providing an initial value at its creation,
    then you may need one of the following `DSL.param()` flavors.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在创建时没有提供初始值的命名参数，那么你可能需要以下`DSL.param()`之一。
- en: 'Here is an example of using `DSL.param(String name)` that returns `Param<Object>`:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`DSL.param(String name)`返回`Param<Object>`的示例：
- en: '[PRE808]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: '[PRE809]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: '[PRE810]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: '[PRE811]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: '[PRE812]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: '[PRE813]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: 'This is an example of creating a named parameter with a defined class type
    and no initial value via `param(String name, Class<T> type)`:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通过`param(String name, Class<T> type)`创建具有定义类类型但没有初始值的命名参数的示例：
- en: '[PRE814]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: '[PRE815]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: 'This is how we create a named parameter with a defined data type and no initial
    value via `param(String name, DataType<T> type)`:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们通过`param(String name, DataType<T> type)`创建具有定义数据类型但没有初始值的命名参数的方式：
- en: '[PRE816]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: '[PRE817]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: '[PRE818]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: 'And, we can create a named parameter with a defined type of another field and
    no initial value via `param(String name, Field<T> type)`:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过`param(String name, Field<T> type)`创建具有定义类型的其他字段但没有初始值的命名参数：
- en: '[PRE819]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: '[PRE820]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: 'We can also keep a reference to a named parameter having an initial value (for
    instance, just to not lose the generic type, `<T>`):'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以保留一个具有初始值的命名参数的引用（例如，仅为了不丢失泛型类型`<T>`）：
- en: '[PRE821]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: '[PRE822]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: '[PRE823]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: '[PRE824]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: In addition, jOOQ supports unnamed parameters without initial values but with
    a defined type. We can create such parameters via `param(Class<T> class)`, `param(DataType<T>
    dataType)`, and `param(Field<T> field)`.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jOOQ支持没有初始值但有定义类型的无名称参数。我们可以通过`param(Class<T> class)`、`param(DataType<T>
    dataType)`和`param(Field<T> field)`创建此类参数。
- en: Moreover, we can create a parameter without a name and initial value with a
    generic type (`Object`/`SQLDataType.OTHER`) via `param()`. You can find examples
    in the code bundled with this book.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过`param()`（`Object`/`SQLDataType.OTHER`）创建没有名称和初始值的泛型类型参数。你可以在本书附带代码中找到示例。
- en: Rendering unnamed parameters via `Query` with `renderNamedParams()` results
    in rendering the positions of parameters starting with 1, such as `:1`, `:2`,
    to `:n`.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Query`使用`renderNamedParams()`渲染无名称参数会导致参数位置从1开始渲染，例如`:1`、`:2`到`:n`。
- en: Important Note
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At the time of writing, jOOQ still supports modifying binding values, but `setValue()`and
    `setConverted()` are deprecated and probably removed starting with version 4.0
    when jOOQ plans to make `Param` immutable.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，jOOQ仍然支持修改绑定值，但`setValue()`和`setConverted()`已被弃用，并且可能在4.0版本中被删除，届时jOOQ计划使`Param`不可变。
- en: 'Also, pay attention to `param()` and `param(String name)`. As a rule of thumb,
    avoid these methods if you are using any of the following dialects: SQLDialect.DB2,
    DERBY, H2, HSQLDB, INGRES, and SYBASE. These dialects may have trouble inferring
    the type of the bind value. In such cases, prefer `param()` flavors that explicitly
    set a type of the bind value.'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意`param()`和`param(String name)`。一般来说，如果你使用以下方言中的任何一个：SQLDialect.DB2、DERBY、H2、HSQLDB、INGRES和SYBASE，应避免使用这些方法。这些方言可能难以推断绑定值的类型。在这种情况下，应优先使用显式设置绑定值类型的`param()`变体。
- en: All the examples from this section are available in the *BindingParameters*
    application.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的所有示例都可在*BindingParameters*应用程序中找到。
- en: Summary
  id: totrans-1183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a comprehensive chapter, which covered several fundamental aspects
    of jOOQ. So far, you have learned how to create `DSLContext`, how the jOOQ fluent
    API works, how to deal with jOOQ `Result` and `Record`, how to tackle edge cases
    of casting and coercing, and how to use bind values. As a rule of thumb, having
    these fundamentals under your tool belt is a major advantage that helps you to
    make the correct and optimal decisions and will be a great support in the next
    chapters.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个全面的章节，涵盖了jOOQ的几个基本方面。到目前为止，你已经学习了如何创建`DSLContext`，jOOQ流畅API是如何工作的，如何处理jOOQ的`Result`和`Record`，如何处理类型转换和强制转换的边缘情况，以及如何使用绑定值。一般来说，掌握这些基础知识将为你带来重大优势，帮助你做出正确和最优的决定，并在下一章中提供极大的支持。
- en: In the next chapter, we will discuss alternatives for building a DAO layer and/or
    evolving the jOOQ-generated DAO layer.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论构建DAO层和/或演进jOOQ生成的DAO层的替代方案。
