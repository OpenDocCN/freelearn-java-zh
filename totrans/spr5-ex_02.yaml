- en: Starting in the Spring World – the CMS Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll create our first application; at this point, we have learned the
    Spring concepts, and we are ready to put them into practice. At the beginning
    of this chapter, we'll introduce the Spring dependencies to create a web application,
    also we know that Spring Initializr is a fantastic project that enables developers
    to create Spring skeleton projects, with as many dependencies as they want. In
    this chapter, we will learn how to put up our first Spring application on IDE
    and command line, expose our first endpoint, understand how this works under the
    hood, and get to know the main annotations of Spring REST support. We will figure
    out how to create a service layer for the **CMS** (**Content Management System**)
    application and understand how Dependency Injection works in a Spring container.
    We will meet the Spring stereotypes and implement our first Spring bean. At the
    end of this chapter, we will explain how to create a view layer and integrate
    that with AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the first Spring application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the REST support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Dependency Injection in Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the CMS application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will create our first application with the Spring Framework; we will
    create a basic structure for the CMS application with Spring Initializr. This
    page helps to bootstrap our application, it's a kind of guide which allows us
    to configure the dependencies on Maven or Gradle. We can also choose the language
    and version of Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f669b75-6156-4855-a09b-3e2751a0039f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Project Metadata section, we can put the coordinates for Maven projects;
    there is a group field which refers to the `groupId` tag, and we have artifacts
    which refer to the `artifactId`. This is all for the Maven coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies section enables the configuration of the Spring dependencies,
    the field has the autocomplete feature and helps developers to put in the correct
    dependency.
  prefs: []
  type: TYPE_NORMAL
- en: The CMS project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start to code and learn amazing things, let''s understand a little
    bit about the CMS project, the main purpose of this project is to help companies
    manage the CMS content for different topics. There are three main entities in
    this project:'
  prefs: []
  type: TYPE_NORMAL
- en: The `News` class is the most important, it will store the content of the news.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a *category* which makes the search easier, and we can also group news
    by category, and of course, we can group by the user who has created the news.
    The news should be approved by other users to make sure it follows the company
    rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The news has some *tags* as well, as we can see the application is pretty standard,
    the business rules are easy as well; this is intentional because we keep the focus
    on the new things we will learn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we know how Spring Initializr ([https://start.spring.io](https://start.spring.io))
    works and the business rules we need to follow, we are ready to create the project.
    Let's do it right now.
  prefs: []
  type: TYPE_NORMAL
- en: Project metadata section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Insert `spring-five` in the Group field and `cms` in the Artifact field. If
    you want to customize it, no problem, this is a kind of informative project configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16170417-ad87-4e20-b0a0-083079714775.png)'
  prefs: []
  type: TYPE_IMG
- en: The dependencies section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type the `MVC` word in the Search for Dependencies field. The Web module will
    appear as an option, the Web module contains the full-stack web development with
    Embedded Tomcat and Spring MVC, select it. Also, we need to put `Thymeleaf` dependencies
    in this module. It is a template engine and will be useful for the view features
    at the end of this chapter. Type `Thymeleaf`, it includes the Thymeleaf templating
    engine, and includes integration with Spring. The module will appear, and then
    select it as well. Now we can see Web and Thymeleaf in the Selected Dependencies
    pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cd71b3c-c099-4c9b-840b-9ab81ef0b774.png)'
  prefs: []
  type: TYPE_IMG
- en: Generating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we have finished the project definition and chosen the project dependencies,
    we are ready to download the project. It can be done using the Generate Project
    button, click on it. The project will be downloaded. At this stage, the project
    is ready to start our work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/884468bd-0dd5-4d53-bb5a-a6db1af4c06a.png)'
  prefs: []
  type: TYPE_IMG
- en: The zip file will be generated with the name `cms.zip` (the Artifact field input
    information) and the location of the downloaded file depends on the browser configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '>Before opening the project, we must uncompress the artifact generated by **Spring
    Initializr** to the desired location. The command should be:  **`unzip -d <target_destination>
    /<path_to_file>/cms.zip`**. Follow the example: `unzip -d /home/john /home/john/Downloads/cms.zip.`'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can open the project in our IDE. Let's open it and take a look at the
    basic structure of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we run the application, let's have a walk through our project structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project on IntelliJ IDEA using the Import Project or Open options
    (both are similar), the following page will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5474f4e4-22e9-458b-9f7c-c61a9667268a.png)'
  prefs: []
  type: TYPE_IMG
- en: Then we can open or import the `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following project structure should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f15ef257-c577-43a0-b97f-2b6a76bca580.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the `pom.xml,` we have three dependencies, `spring-boot-starter-thymeleaf`, `spring-boot-starter-web`, `spring-boot-starter-test`,
    and an interesting plugin, `spring-boot-maven-plugin`**.**
  prefs: []
  type: TYPE_NORMAL
- en: These `starter` dependencies are a shortcut for developers because they provide
    full dependencies for the module. For instance, on the `spring-boot-starter-web,`
    there is `web-mvc`, `jackson-databind`, `hibernate-validator-web`, and some others;
    these dependencies must be on the classpath to run the web applications, and starters
    make this task considerably easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze our `pom.xml`, the file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Also, we have a `spring-boot-maven-plugin`, this awesome plugin provides Spring
    Boot support for Maven. It enables you to package the application in a Fat-JAR,
    and the plugin supports the run, start, and stop goals, as well interacting with
    our applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fat-JAR**: a JAR which contains all project class files and resources packed
    together with all its dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: For now, that is enough on Maven configurations; let's take a look at the Java
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Spring Initializr created one class for us, in general, the name of this
    class is artifact name plus `Application`, in our case `CmsApplication`, this
    class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Looking under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have some interesting things here, let''s understand them. The `@SpringBootApplication`
    is the essential annotation for the Spring Boot application; it''s a kind of alias
    for `@Configuration`, `@EnableAutoConfiguration`, and `@Component` annotations.
    Let''s dig in:'
  prefs: []
  type: TYPE_NORMAL
- en: The first annotation, `@Configuration` indicates that the class can produce
    a beans definitions for the Spring container. This is an interesting annotation to
    work with external dependencies such as `DataSources`; this is the most common
    use case for this annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second annotation, `@EnableAutoConfiguration` means that with the Spring
    `ApplicationContext` container, it will try to help us configure the default beans
    for the specific context. For instance, when we create the web MVC application
    with Spring Boot, we will probably need a web server container to run it. In a
    default configuration, the Spring container, together with `@EnableAutoConfiguration`,
    will configure a bean Tomcat-embedded container for us. This annotation is very
    helpful for developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Component` is a stereotype, the container understands which class is considered
    for auto-detection and needs to instantiate it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SpringApplication` class is responsible for bootstrapping the Spring application
    from the main method, it will create an `ApplicationContext` instance, take care
    of configurations provided by the configuration files, and finally, it will load
    the singleton beans that are defined by annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stereotype Annotations** denote a conceptual division in an architecture
    layer. They help the developers understand the purpose of the class and the layer
    which the beans represent, for example, `@Repository` means the data access layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will run the application in IntelliJ IDEA and command line. It is an important
    task to learn because we are working in different development environments; sometimes
    the configurations of the application are a little bit complicated, and we are
    not able to run it with IDEs, or sometimes the companies have different IDEs as
    standard, so we will learn about two different ways.
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, the IntelliJ IDEA recognizes the main class annotated with `@SpringBootApplication`
    and creates a run configuration for us, but it depends on the version of the tool,
    let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command line is a more generic tool to run the project. Also, this task
    is easy, thanks to the Spring Boot Maven plugin. There are two ways to run, and
    we will cover both.
  prefs: []
  type: TYPE_NORMAL
- en: Command line via the Maven goal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first one is a goal of the Spring Boot Maven plugin, and it is straightforward;
    open the terminal then go to the root project folder, pay attention as this is
    the same folder where we have the `pom.xml,` and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Maven will now compile the project and run the main class, the class `CmsApplication`,
    and we should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53c46844-611f-4cd1-87ce-ff858913473b.png)'
  prefs: []
  type: TYPE_IMG
- en: Command line via the JAR file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run it through the Java file, we need to compile and package it, and then
    we can run the project with the Java command line. To compile and package it,
    we can use the pretty standard Maven command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After the project is compiled and packaged as a Fat-JAR, we can execute the
    JAR file, go to the target folder and check the files from this folder, probably
    the result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8523a88d-85c2-483b-a54c-e00dc3f41ebe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have two main files in our target folder, the `cms-0.0.1-SNAPSHOT.jar` and
    the `cms-0.0.1-SNAPSHOT.jar.original`, the file with the `.original` extension
    is not executable. It is the original artifact resulting from the compilation,
    and the other is our executable file. It is what we are looking for, let''s execute
    it, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be as displayed. The application is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c11c8613-b841-4cc9-af00-52666e07a797.png)'
  prefs: []
  type: TYPE_IMG
- en: That is it for this part, in the next section, we will create the first **REST**
    (**Representational State Transfer**) resources and understand how the REST endpoints
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the REST resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have an application up and running in this section, and we will add
    some REST endpoints and model some initial classes for the CMS application, the
    REST endpoints will be useful for the AngularJS integration.
  prefs: []
  type: TYPE_NORMAL
- en: One of the required characteristics for the APIs is the documentation, and a
    popular tool to help us with these tasks is Swagger. The Spring Framework supports
    Swagger, and we can do it with a couple of annotations. The project's Spring Fox
    is the correct tool to do this, and we will take a look at the tool in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do this.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to create our class, we will add the `Lombok` dependency in
    our project. It is a fantastic library which provides some interesting things
    such as `GET`/`SET` at compilation time, the `Val` keyword to make variables final,
    `@Data` to make a class with some default methods like getters/setters, `equals`,
    and `hashCode`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Lombok dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Put the following dependency in a `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `provided` scope instructs Maven not to include this dependency in the JAR
    file because we need it at compile time. We do not need it at runtime. Wait for
    Maven to download the dependency, that is all for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can use the Reimport All Maven Projects provided by IntelliJ IDEA,
    located in the Maven Projects tab, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2001438-30ed-4cc8-9935-c76d35795176.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create our models, which are Java classes annotated with `@Data`.
  prefs: []
  type: TYPE_NORMAL
- en: Tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class represents a tag in our system. There isn''t necessarily any repository
    for it because it will be persisted together with our `News` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A category model for our CMS application can be used to group the news. Also,
    the other important thing is that this makes our news categorized to make the
    search task easy. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: User
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It represents a user in our domain model. We have two different profiles, the
    author who acts as a news writer, and another one is a reviewer who must review
    the news registered at the portal. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: News
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class represents news in our domain, for now, it does not have any behaviors.
    Only properties and getters/setters are exposed; in the future, we will add some
    behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Review` class can be found at GitHub: ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/models](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/models)).'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, they are simple Java classes which represent our CMS application
    domain. It is the heart of our application, and all the domain logic will reside
    in these classes. It is an important characteristic.
  prefs: []
  type: TYPE_NORMAL
- en: Hello REST resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created the models, and we can start to think about our REST resources.
    We will create three main resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CategoryResource` which will be responsible for the `Category` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is `UserResource`. It will manage the interactions between the
    `User` class and the REST APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last one, and more important as well, will be the `NewsResource` which will
    be responsible for managing news entities, such as reviews.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the CategoryResource class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create our first REST resource, let's get started with the `CategoryResource`
    class which is responsible for managing our `Category` class. The implementation
    of this entity will be simple, and we will create CRUD endpoints such as create,
    retrieve, update, and delete. We have two important things we must keep in mind
    when we create the APIs. The first one is the correct HTTP verb such as `POST`,
    `GET`, `PUT` and `DELETE`. It is essential for the REST APIs to have the correct
    HTTP verb as it provides us with intrinsic knowledge about the API. It is a pattern
    for anything that interacts with our APIs. Another thing is the status codes,
    and it is the same as the first one we must follow, this is the pattern the developers
    will easily recognize. The *Richardson Maturity Model* can help us create amazing
    REST APIs, and this model introduces some levels to measure the REST APIs, it's
    a kind of thermometer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we will create the skeleton for our APIs. Think about what features
    you need in your application. In the next section, we will explain how to add
    a service layer in our REST APIs. For now, let''s build a `CategoryResource` class,
    our implementation could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `CategoryRequest` can be found at GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo)).
  prefs: []
  type: TYPE_NORMAL
- en: We have some important concepts here. The first one is `@RestController`. It
    instructs the Spring Framework that the `CategoryResource` class will expose REST
    endpoints over the Web-MVC module. This annotation will configure some things
    in a framework, such as `HttpMessageConverters` to handle HTTP requests and responses
    such as XML or JSON. Of course, we need the correct libraries on the classpath,
    to handle JSON and XML. Also, add some headers to the request such as `Accept`
    and `Content-Type`. This annotation was introduced in version 4.0\. It is a kind
    of syntactic sugar annotation because it's annotated with `@Controller` and `@ResponseBody`.
  prefs: []
  type: TYPE_NORMAL
- en: The second is the `@RequestMapping` annotation, and this important annotation
    is responsible for the HTTP request and response in our class. The usage is quite
    simple in this code when we use it on the class level, it will propagate for all
    methods, and the methods use it as a relative. The `@RequestMapping` annotation
    has different use cases. It allows us to configure the HTTP verb, params, and
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have `@GetMapping`, `@PostMapping`, `@DeleteMapping`, and `@PutMapping`, these
    annotations are a kind of shortcut to configure the `@RequestMapping` with the
    correct HTTP verbs; an advantage is that these annotations make the code more
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: Except for the `removeCategory`, all the methods return the `ResponseEntity`
    class which enables us to handle the correct HTTP status codes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: UserResource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UserResource` class is the same as `CategoryResource`, except that it uses
    the `User` class. We can find the whole code on the GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02)).
  prefs: []
  type: TYPE_NORMAL
- en: NewsResource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NewsResource` class is essential, this endpoint enables users to review
    news previously registered, and it also provides an endpoint to return the updated
    news. This is an important feature because we are interested only in the relevant
    news. Irrelevant news cannot be shown on the portal. The resource class should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `NewsRequest` class can be found at [GitHub](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo).
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the HTTP verbs and the HTTP status code, as we need to follow
    the correct semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Adding service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have the skeleton for the REST layer ready, and in this section, we
    will start to create a service layer for our application. We will show how the
    Dependency Injection works under the hood, learn the stereotype annotations on
    Spring Framework and also start to think about our persistence storage, which
    will be presented in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to make some changes to our model, specifically in the `News` class.
    In our business rules, we need to keep our information safe, then we need to review
    all the news. We will add some methods to add a new review done by a user, and
    also we will add a method to check if the news was reviewed by all mandatory reviewers.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this feature, we need to create a method in our `News` class, the method
    will return a `Review` and should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We do not need to check if the user, who performs the review action, is a mandatory
    reviewer at all.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the news safely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Also, we need to check if the news is fully revised by all mandatory reviewers.
    It is quite simple, we are using Java 8, and it provides the amazing `Stream` interface,
    which makes the collections interactions easier than before. Let''s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Thanks, Java 8, we appreciate it.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application needs to have a persistence storage where our records can be
    loaded, even if the application goes down. We will create the fake implementation
    for our repositories.   In [C](827e9516-ff3d-44d7-8a16-95579684f453.xhtml)hapter
    3, *Persistence with Spring Data and Reactive* *Fashion*, we will introduce the
    Spring Data projects which help developers create amazing repositories with a
    fantastic DSL. For now, we will create some Spring beans to store our elements
    in memory, let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: CategoryService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with our simplest service, the `CategoryService` class, the behaviors
    expected of this class are CRUD operations. Then, we need a representation of
    our persistence storage or repository implementation, for now, we are using the
    ephemeral storage and `ArrayList` with our categories. In the next chapter, we
    will add the real persistence for our CMS application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first Spring service. The implementation is in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There is some new stuff here. This class will be detected and instantiated by
    the Spring container because it has a `@Service` annotation. As we can see, there
    is nothing special in that class. It does not necessarily extend any class or
    implement an interface. We received the `CategoryRepository` on a constructor,
    this class will be provided by the Spring container because we instruct the container
    to produce this, but in Spring 5 it is not necessary to use `@Autowired` anymore
    in the constructor. It works because we had the only one constructor in that class
    and Spring will detect it. Also, we have a couple of methods which represent the
    CRUD behaviors, and it is simple to understand.
  prefs: []
  type: TYPE_NORMAL
- en: UserService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UserService` class is quite similar to the `CategoryService`, but the
    rules are about the `User` entity, for this entity we do not have anything special.
    We have the `@Service` annotation, and we received the `UserRepository` constructor
    as well. It is quite simple and easy to understand. We will show the `UserService` implementation,
    and it must be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the class declaration with `@Service` annotation. This is a
    very common implementation in the Spring ecosystem. Also, we can find `@Component`,
    `@Repository` annotations. `@Service` and `@Component` are common for the service
    layer, and there is no difference in behaviors. The `@Repository` changes the
    behaviors a little bit because the frameworks will translate some exceptions on
    the data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: NewsService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an interesting service which will be responsible for managing the state
    of our news. It will interact like a *glue* to call the domain models, in this
    case, the `News` entity. The service is pretty similar to the others. We received
    the `NewsRepository` class, a dependency and kept the repository to maintain the
    states, let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Service` annotation is present again. This is pretty much standard for
    Spring applications. Also, we can change to the `@Component` annotation, but it
    does not make any difference to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Swagger for our APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger is the de facto tool for document web APIs, and the tool allows developers
    to model APIs, create an interactive way to play with the APIs, and also provides
    an easy way to generate the client implementation in a wide range of languages.
  prefs: []
  type: TYPE_NORMAL
- en: The API documentation is an excellent way to engage developers to use our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies to pom.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start the configuration, we need to add the required dependencies.
    These dependencies included Spring Fox in our project and offered many annotations
    to configure Swagger properly. Let's add these dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new dependencies are in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first dependency is the core of Swagger with annotations and related kinds
    of stuff. Spring Fox Swagger UI dependency provides a rich interface in HTML which
    permits developers to interact with the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dependencies are added, now we can configure the infrastructure for Swagger.
    The configuration is pretty simple. We will create a class with `@Configuration`
    to produce the Swagger configuration for the Spring container. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following Swagger configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `@Configuration` instructs the Spring to generate a bean definition for
    Swagger. The annotation, `@EnableSwagger2` adds support for Swagger. `@EnableSwagger2`
    should be accompanied by `@Configuration`, it is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: The `Docket` class is a builder to create an API definition, and it provides
    sensible defaults and convenience methods for configuration of the Spring Swagger
    MVC Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The invocation of method `.apis(RequestHandlerSelectors.withClassAnnotation(RestController.class))`
    instructs the framework to handle classes annotated with `@RestController`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many methods to customize the API documentation, for example, there
    is a method to add authentication headers.
  prefs: []
  type: TYPE_NORMAL
- en: That is the Swagger configuration, in the next section, we will create a first
    documented API.
  prefs: []
  type: TYPE_NORMAL
- en: First documented API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with the `CategoryResource` class, because it is simple to understand,
    and we need to keep the focus on the technology stuff. We will add a couple of
    annotations, and the magic will happen, let's do magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CategoryResource` class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of new annotations to understand. The `@Api` is the root annotation
    which configures this class as a Swagger resource. There are many configurations,
    but we will use the tags and description, as they are enough.
  prefs: []
  type: TYPE_NORMAL
- en: The `@ApiOperation` describes an operation in our API, in general against the
    requested path. The `value` attribute is regarding as the summary field on Swagger,
    it is a brief of the operation, and `notes` is a description of an operation (more
    detailed content).
  prefs: []
  type: TYPE_NORMAL
- en: The last one is the `@ApiResponse` which enables developers to describe the
    responses of an operation. Usually, they want to configure the status codes and
    message to describe the result of an operation.
  prefs: []
  type: TYPE_NORMAL
- en: Before you run the application, we should compile the source code.  It can be
    done using the Maven command line using the `mvn clean install,` or via IDE using
    the Run Application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have configured the Swagger integration, we can check the API documentation
    on the web browser. To do it, we need to navigate to `http://localhost:8080/swagger-ui.html` and
    this page should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/593d1a81-a87d-4346-80ae-31c132c2fb09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see APIs endpoints configured in our CMS application. Now, we will take
    a look at category which we have configured previously, click on the Show/Hide
    link. The output should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5a127ca-5b9a-49f7-960a-b608ac3f0022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, there are five operations in our Category API, the operation
    has a path and a summary to help understand the purpose. We can click on the requested
    operation and see detailed information about the operation. Let''s do it, click
    on List categories to see detailed documentation. The page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13866a16-49b0-441c-aa8b-a7943c54b35c.png)'
  prefs: []
  type: TYPE_IMG
- en: Outstanding job. Now we have an amazing API with excellent documentation. Well
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue creating our CMS application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrate with AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AngularJS Framework has been becoming a trend for a few years, the community
    is super active, the project was created by Google.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea of the framework is to help developers handle the complexities
    of the frontend layer, especially in the HTML part. The HTML markup language is
    static. It is a great tool to create static documents, but today it is not a requirement
    for modern web applications. These applications need to be dynamic. The UX teams
    around the world, work hard to create amazing applications, with different effects,
    these guys try to keep the applications more comfortable for the users.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS adds the possibility of extending the HTML with some additional attributes
    and tags. In this section, we will add some interesting behaviors on the frontend
    application. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our CMS application, we will work with some Angular components. We will use `Controllers` which
    will interact with our HTML and handle the behavior of some pages, such as those
    that show error messages. The `Services` is responsible for handling the infrastructure
    code such as interacting with our CMS API. This book is not intended to be an
    AngularJS guide. However, we will take a look at some interesting concepts to
    develop our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AngularJS common tags are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-app`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-controller`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-click`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-hide`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-show`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tags are included in the AngularJS Framework. There are many more tags
    created and maintained by the community. There is, for example, a library to work
    with HTML forms, we will use it to add dynamic behaviors in our CMS Portal.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controllers are part of the framework to handle the business logic of the application.
    They should be used to control the flow of data in an application. The controller
    is attached to the DOM via the `ng-controller` directive.
  prefs: []
  type: TYPE_NORMAL
- en: To add some actions to our view, we need to create functions on controllers,
    the way to do this is by creating functions and adding them to the `$scope` object.
  prefs: []
  type: TYPE_NORMAL
- en: The controllers cannot be used to carry out DOM manipulations, format data and
    filter data, it is considered best practice in the AngularJS world.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the controllers inject the service objects to delegate handling the
    business logic. We will understand services in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services are the objects to handle business logic in our application. In some
    cases, they can be used to handle state. The services objects are a singleton
    which means we have only one instance in our entire application.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, the services are responsible for interacting with our CMS
    APIs built on Spring Boot. Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application entry point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot Framework allows us to serve static files. These files should
    be in the classpath in one of these folders, `/static`, `/public`, `/resources`, or
    `/META-INF/resources`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `/static` folder, in this folder, we will put our AngularJS
    application. There are some standards to modularize the AngularJS application
    folder structure which depends on the application size and requirements. We will
    use the most simple style to keep the attention on Spring integration. Look at
    the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37d2683d-a4f2-4759-a86c-38c95369a7ae.png)'
  prefs: []
  type: TYPE_IMG
- en: There are some assets to start and run an AngularJS application. We will use
    the Content Delivery Network (CDN) to load the AngularJS Framework, the Angular
    UI-Router which helps to handle routing on our web application, and the Bootstrap
    Framework which helps to develop our pages.
  prefs: []
  type: TYPE_NORMAL
- en: Content Delivery Network is distributed proxy servers around the world. It makes
    the content more high availability and improves performance because it will be
    hosted nearer the end user. The detailed explanation can be found at CloudFare
    Page ([https://www.cloudflare.com/learning/cdn/what-is-a-cdn/](https://www.cloudflare.com/learning/cdn/what-is-a-cdn/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can start to configure our AngularJS application. Let''s start with
    our entry point, `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are some important things here. Let's understand them.
  prefs: []
  type: TYPE_NORMAL
- en: The `ng-app` tag is a directive which is used to bootstrap the AngularJS application.
    This tag is the root element of the application and is usually placed on the `<body>`
    or `<html>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ui-view` tag instructs the Angular UI-Router about which portion of the
    HTML document will be handled by the application states, in other words, the designated
    part has the dynamic behaviors and change depends on the routing system. Look
    at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This part of the code can be found at `index.hml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the `ui-view`, we have our JavaScript files, the first one is the
    AngularJS Framework, in this version the file is minified. Look at our JavaScript
    files, the files were created in the `/static/app/components` folder. Take a look
    at the image here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cdc6303-e961-493a-a1f9-f44de184e3ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The second one is the UI-Router which helps us to manage our routes. Finally,
    we have our JavaScript files which configure the AngularJS application, our controllers,
    and the services to interact with our CMS APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have some Bootstrap classes to align fields and make design easier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Category Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we need to create our controllers. We will start with the simplest to make
    the example more easy to understand. The `CategoryController` has the responsibility
    of controlling the data of the `Category` entity. There are two controllers, one
    enables us to create a category, and another lists all categories stored in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `category-controller.js` should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have created an AngularJS module. It helps us to keep the functions organized.
    It acts as a kind of namespace for us. The `.controller` function is a constructor
    to create our controller's instances. We received some parameters, the AngularJS
    framework will inject these objects for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Category Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CategoryService` objects is a singleton object because it is an AngularJS
    service. The service will interact with our CMS APIs powered by the Spring Boot
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `$http` service. It makes the HTTP communications easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `CategoryService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Well done, now we have implemented the `CategoryService`.
  prefs: []
  type: TYPE_NORMAL
- en: The `.service` function is a constructor to create a service instance, the `angular`
    acts under the hood. There is an injection on a constructor, for the service we
    need an `$http` service to make HTTP calls against our APIs. There are a couple
    of HTTP methods here. Pay attention to the correct method to keep the HTTP semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created our first Spring application. We saw Spring Initializr,
    the amazing tool that helps developers create the application skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how Spring works under the hood and how the framework got configured
    with a couple of annotations. Now, we have a basic knowledge of the Spring Bootstrap
    functions, and we can understand the Dependency Injection and component scan features
    present in the framework.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge is the basis for the next chapters, and now we are ready to start
    to work with more advanced features, such as persistence. Here we go. See you
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
