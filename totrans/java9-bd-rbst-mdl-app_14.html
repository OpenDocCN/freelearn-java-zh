<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Security Enhancements</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">In the last chapter, we</span> <span class="calibre7">covered concurrency enhancements introduced with the Java 9 platform. We took an in-depth look at concurrency both as a core Java concept and as a series of enhancements for Java 9. We also explored the <kbd class="calibre16">Flow</kbd> class API that</span> <span class="calibre7">supports Reactive Programming, a new concept in Java 9. In addition, we explored concurrency enhancements and the new Spin-Wait hints introduced in Java 9.</span></p>
<p class="mce-root">In this chapter, we will look at several small changes made to the JDK that involve security. The size of these changes does not reflect their significance. The security enhancements introduced with the Java 9 platform provide developers with a greater ability to write and maintain applications that are more secure than previously possible.</p>
<p class="mce-root">Specifically, we will review the following content areas in this chapter:</p>
<ul class="calibre13">
<li class="calibre14">Datagram Transport Layer Security</li>
<li class="calibre14">Creating PKCS12 keystores</li>
<li class="calibre14">Improving security application performance</li>
<li class="calibre14">TLS application-layer protocol negotiation extension</li>
<li class="calibre14">Leveraging CPU instructions for GHASH and RSA</li>
<li class="calibre14">OCSP stapling for TLS</li>
<li class="calibre14">DRBG-based <kbd class="calibre16">SecureRandom</kbd> implementations</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Datagram Transport Layer Security</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre8">Datagram Transport Layer Security</strong> (<strong class="calibre8">DTLS</strong>), is a communications protocol. The protocol provides a layer of security for datagram-based applications. DTLS permits secure communications and is based on the <strong class="calibre8">Transport Layer Security</strong> (<strong class="calibre8">TLS</strong>) protocol. Embedded security helps ensure messages are not forged, tampered with, or eavesdropped.</p>
<p class="mce-root">Let's review the relevant terminology:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Communication protocol</strong>: A set of rules that govern how information is transmitted.</li>
<li class="calibre14"><strong class="calibre3">Datagram</strong>: A structured transfer unit.</li>
<li class="calibre14"><strong class="calibre3">Eavesdropping</strong>: Undetected listening to in-transit data packets.</li>
<li class="calibre14"><strong class="calibre3">Forgery</strong>: Transmission of a packet with falsified sender.</li>
<li class="calibre14"><strong class="calibre3">Network packet</strong>: A formatted unit of data for transmission.</li>
<li class="calibre14"><strong class="calibre3">Tampering</strong>: The altering of data packets after the sender transmits them and before the intended receiver receives them.</li>
<li class="calibre14"><strong class="calibre3">TLS protocol</strong>: The most common network security protocol. Uses, as an example, IMPA and POP for email.</li>
</ul>
<p class="mce-root">The DTLS Java Enhancement Proposal 219 is aimed at creating an API for the DTLS versions 1.0 and 1.2.</p>
<p class="mce-root">In the sections that follow, we will look at each of the DTLS versions, 1.0 and 1.2, and then review the changes to the Java 9 platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">DTLS protocol version 1.0</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">DTLS protocol version 1.0 was established in 2006 and provides communications security for datagram protocols. Here are the basic characteristics:</p>
<ul class="calibre13">
<li class="calibre14">Permits client/server applications to communicate without permitting:
<ul class="calibre13">
<li class="calibre14">Eavesdropping</li>
<li class="calibre14">Tampering</li>
<li class="calibre14">Message forgery</li>
</ul>
</li>
<li class="calibre14">Based on the TLS protocol</li>
<li class="calibre14">Provides security guarantees</li>
<li class="calibre14">The DLS protocol's datagram semantics are preserved</li>
</ul>
<p class="mce-root">The following diagram illustrates where the <strong class="calibre8">Transport Layer</strong> fits into the overall schema of <strong class="calibre8">SSL/TLS</strong> protocol layers and protocols for each layer:</p>
<div class="mce-root1"><img src="Images/5b9c33a2-ee23-4cd5-8ddc-7e5a0591b964.png" width="2040" height="682" class="calibre144"/></div>
<p class="mce-root"><span class="calibre7">DTLS protocol version 1.0 provides detailed specifications with the major areas of coverage listed as follows:</span></p>
<ul class="calibre13">
<li class="calibre14">Ciphers:
<ul class="calibre13">
<li class="calibre14">Anti-replay block cipher</li>
<li class="calibre14">New cipher suites</li>
<li class="calibre14">Standard (or null) stream cipher</li>
</ul>
</li>
<li class="calibre14">Denial of service countermeasures</li>
<li class="calibre14">Handshake:
<ul class="calibre13">
<li class="calibre14">Message format</li>
<li class="calibre14">Protocol</li>
<li class="calibre14">Reliability</li>
</ul>
</li>
<li class="calibre14"><span class="calibre5">Messages:</span>
<ul class="calibre13">
<li class="calibre14"><span class="calibre5">Fragmentation and reassembly</span></li>
<li class="calibre14">Loss-insensitive messaging</li>
<li class="calibre14"><span class="calibre5">Size</span></li>
<li class="calibre14">Timeout and retransmission</li>
<li class="calibre14">Packet loss</li>
</ul>
</li>
<li class="calibre14"><strong class="calibre3">Path Maximum Transition Unit</strong> (<strong class="calibre3">PMTU</strong>) discovery</li>
<li class="calibre14">Record layer</li>
<li class="calibre14">Record payload protection</li>
<li class="calibre14">Reordering</li>
<li class="calibre14">Replay detection</li>
<li class="calibre14">Transport layer mapping</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">DTLS protocol version 1.2</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">DTLS protocol version 1.2 was published in January 2012 and is copyrighted by the <strong class="calibre8">Internet Engineering Task Force</strong> (<strong class="calibre8">IETF</strong>). This section shares code samples that illustrate the changes in version 1.2.</span></p>
<p class="mce-root"><span class="calibre7">The following code illustrates the TLS 1.2 handshake message header. This format supports:</span></p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre5">Message fragmentation</span></li>
<li class="calibre14"><span class="calibre5">Message loss</span></li>
<li class="calibre14"><span class="calibre5">Reordering</span></li>
</ul>
<pre class="calibre21"><span class="calibre5">    // Copyright (c) 2012 IETF Trust and the persons identified as<br class="calibre2"/>       authors of the code. All rights reserved.<br class="calibre2"/></span>
    struct <br class="calibre2"/>    {
      HandshakeType msg_type;
      uint24 length;
      uint16 message_seq;                           // New field
      uint24 fragment_offset;                       // New field
      uint24 fragment_length;                       // New field
      select (HandshakeType) <br class="calibre2"/>      {
        case hello_request: HelloRequest;
        case client_hello:  ClientHello;
        case hello_verify_request: HelloVerifyRequest;  // New type
        case server_hello:  ServerHello;
        case certificate:Certificate;
        case server_key_exchange: ServerKeyExchange;
        case certificate_request: CertificateRequest;
        case server_hello_done:ServerHelloDone;
        case certificate_verify:  CertificateVerify;
        case client_key_exchange: ClientKeyExchange;
        case finished: Finished;
      } body;<br class="calibre2"/>    } Handshake;</pre>
<div class="packt_infobox">The code presented in this section is from the DTLS protocol documentation and is republished here in accordance with IETF's <em class="calibre22">Legal Provisions Relating to IETF Documents</em>.</div>
<p class="mce-root">The record layer contains the information that we intend to send into records. The information starts off inside a <kbd class="calibre16">DTLSPlaintext</kbd> structure and then, after the handshake takes place, the records are encrypted and are eligible to be sent by the communication stream. The record layer format follows with new fields in version 1.2 annotated with the <kbd class="calibre16">// New field</kbd> in-code comments as follows:</p>
<pre class="calibre21">    // Copyright (c) 2012 IETF Trust and the persons identified<br class="calibre2"/>       as authors of the code. All rights reserved.<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>    struct <br class="calibre2"/>    {
      ContentType type;
      ProtocolVersion version;
      uint16 epoch;                                 // New field
      uint48 sequence_number;                       // New field
      uint16 length;
      opaque fragment[DTLSPlaintext.length];
    } DTLSPlaintext;

    struct <br class="calibre2"/>    {
       ContentType type;
       ProtocolVersion version;
       uint16 epoch;                                 // New field
       uint48 sequence_number;                       // New field
       uint16 length;
       opaque fragment[DTLSCompressed.length];<br class="calibre2"/>    } DTLSCompressed;

    struct <br class="calibre2"/>    {
       ContentType type;
       ProtocolVersion version;
       uint16 epoch;                                 // New field
       uint48 sequence_number;                       // New field
       uint16 length;
       select (CipherSpec.cipher_type) <br class="calibre2"/>       {
          case block:  GenericBlockCipher;
          case aead:   GenericAEADCipher;             // New field
       } fragment;
    } DTLSCiphertext;</pre>
<p class="mce-root">Finally, here is the updated handshake protocol:</p>
<pre class="calibre21">    // Copyright (c) 2012 IETF Trust and the persons identified<br class="calibre2"/>       as authors of the code. All rights reserved.<br class="calibre2"/><br class="calibre2"/>    enum {
      hello_request(0), client_hello(1),<br class="calibre2"/>       server_hello(2),
      hello_verify_request(3),                       // New field
      certificate(11), server_key_exchange (12),
      certificate_request(13), server_hello_done(14),
      certificate_verify(15), client_key_exchange(16),
      finished(20), (255) } HandshakeType;

      struct {
        HandshakeType msg_type;
        uint24 length;
        uint16 message_seq;                            // New field
        uint24 fragment_offset;                        // New field
        uint24 fragment_length;                        // New field
        select (HandshakeType) {
          case hello_request: HelloRequest;
          case client_hello:  ClientHello;
          case server_hello:  ServerHello;
          case hello_verify_request: HelloVerifyRequest;  // New field
          case certificate:Certificate;
          case server_key_exchange: ServerKeyExchange;
          case certificate_request: CertificateRequest;
          case server_hello_done:ServerHelloDone;
          case certificate_verify:  CertificateVerify;
          case client_key_exchange: ClientKeyExchange;
          case finished: Finished;
        } body; } Handshake;

      struct {
        ProtocolVersion client_version;
        Random random;
        SessionID session_id;
        opaque cookie&lt;0..2^8-1&gt;;                          // New field
        CipherSuite cipher_suites&lt;2..2^16-1&gt;;
        CompressionMethod compression_methods&lt;1..2^8-1&gt;; } ClientHello;

      struct {
        ProtocolVersion server_version;
        opaque cookie&lt;0..2^8-1&gt;; } HelloVerifyRequest;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">DTLS support in Java 9</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java 9's implementation of the DTLS API is transport-independent and light-weight. The design considerations for the API were as follows:</p>
<ul class="calibre13">
<li class="calibre14">Read timeouts will not be managed</li>
<li class="calibre14">The implementation will use a single TLS record for each wrap/unwrap operation</li>
<li class="calibre14">The application, not the API, will be required to:
<ul class="calibre13">
<li class="calibre14">Determine timeout values</li>
<li class="calibre14">Assemble out-of-order application data</li>
</ul>
</li>
</ul>
<p class="mce-root">The DTLS is a protocol used to secure data from the application layer before that data is passed to a transport layer protocol. DTLS is a good solution for encrypting and transmitting real-time data. Caution should be exercised so that we do not introduce vulnerabilities in our application's implementation. Here are security considerations specific to implementing DTLS in your Java 9 applications:</p>
<ul class="calibre13">
<li class="calibre14">Implement DTLS v1.2, since that is the latest version supported by Java 9.</li>
<li class="calibre14">Avoid <strong class="calibre3">Rivest-Shamir-Adleman</strong> (<strong class="calibre3">RSA</strong>) encryption. If RSA must be used, add addition security to your private keys since this is a weak point for RSA.</li>
<li class="calibre14">Use 192 bits or more when using the <strong class="calibre3">Elliptic Curve Diffie-Hellman</strong> (<strong class="calibre3">ECDH</strong>) anonymous key agreement protocol. The 192-bit value is based on a <strong class="calibre3">National Institute of Standards and Technology</strong> (<strong class="calibre3">NIST</strong>) recommendation.</li>
<li class="calibre14">The use of <strong class="calibre3">Authenticated Encryption with Associated Data</strong> (<strong class="calibre3">AEAD</strong>), a form of encryption, is highly recommended. AEAD provides authenticity, confidentiality, and integrity assurances on the data being encrypted and decrypted.</li>
<li class="calibre14">Always implement the <kbd class="calibre16">renegotiation_info</kbd> extension when implementing handshake renegotiation.</li>
<li class="calibre14">Establish a <span class="calibre5"><strong class="calibre3">Forward Secrecy</strong> (<strong class="calibre3">FS</strong>) capability in all Java applications using a communication protocol. Implementing FS</span> ensures past session encryption keys are not compromised when long-term encryption keys are compromised. Ideally a <strong class="calibre3">Perfect Forward Secrecy</strong> (<strong class="calibre3">PFS</strong>), where each key is only valid for a single session, would be used in the Java applications that call for the greatest security of transmitted data.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating PKCS12 keystores</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java 9 platform provides increased security for keystores. In order to appreciate the changes ushered in by Java Enhancement Proposal 229, create PKCS12 keystores by default, we will first review the concept of keystores, look at the <kbd class="calibre16">KeyStore</kbd> class, and then look at the changes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Keystore primer</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The concept of a <kbd class="calibre16">KeyStore</kbd> is relatively simple. It is essentially a database file, or data repository file, that stores public key certificates and private keys. The <kbd class="calibre16">Keystore</kbd> will be stored in the <kbd class="calibre16">/jre/lib/security/cacerts</kbd> folder. As you will see in the next section, this database is managed by Java's <kbd class="calibre16">java.security.KeyStore</kbd> class methods.</p>
<p class="mce-root"><kbd class="calibre16">KeyStore</kbd> features include:</p>
<ul class="calibre13">
<li class="calibre14">Contains one of the following entry types:
<ul class="calibre13">
<li class="calibre14">Private keys</li>
<li class="calibre14">Public key certificates</li>
</ul>
</li>
<li class="calibre14">Unique alias string names for every entry</li>
<li class="calibre14">Password protection for each key</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java Keystore (JKS)</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">java.security.KeyStore</kbd> <span class="calibre7">class is the storage facility for cryptographic keys and certificates. This class extends <kbd class="calibre16">java.lang.Object</kbd>, see as follows:</span></p>
<pre class="calibre21">    public class KeyStore extends Object</pre>
<p class="mce-root"><span class="calibre7">There are three types of entries managed by a <kbd class="calibre16">KeyStore</kbd>, each implements the <kbd class="calibre16">KeyStore.Entry</kbd> interface, one of the three interfaces provided by the <kbd class="calibre16">KeyStore</kbd> class. The</span> Entry implementations are defined in the following table:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Implementation</strong></td>
<td class="calibre33"><strong class="calibre3">Description</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">KeyStore.PrivateKeyEntry</kbd></td>
<td class="calibre33">
<ul class="calibre13">
<li class="calibre14">Contains the <kbd class="calibre16">PrivateKey</kbd> and can store it in a protected format</li>
<li class="calibre14">Contains the certificate chain for the public key</li>
</ul>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">KeyStore.SecretKeyEntry</kbd></td>
<td class="calibre33">
<ul class="calibre13">
<li class="calibre14">Contains the <kbd class="calibre16">SecretKey</kbd> and can store it in a protected format</li>
</ul>
</td>
</tr>
<tr class="calibre35">
<td class="calibre33"><kbd class="calibre16">KeyStore.TrustedCertifcateEntry</kbd></td>
<td class="calibre33">
<ul class="calibre13">
<li class="calibre14">Contains a single public key <kbd class="calibre16">Certificate</kbd> from an external source</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">This class has been part of the Java platform since version 1.2. It has one constructor, three interfaces, six sub-classes, and several methods. The constructor definition is:</p>
<pre class="calibre21">    protected KeyStore(KeyStoreSpi keyStoresSpi,<br class="calibre2"/>     Provider provider, String type)</pre>
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">KeyStore</kbd> <span class="calibre7">class</span> contains the following interfaces:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public static interface KeyStore.Entry</kbd>:
<ul class="calibre13">
<li class="calibre14">This interface serves as a marker for <kbd class="calibre16">KeyStore</kbd> entry types and contains no methods.</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public static interface KeyStore.LoadStoreParameter</kbd>:
<ul class="calibre13">
<li class="calibre14">This interface serves as a marker for load and store parameters and has the following method that returns null or the parameter used to protect the <kbd class="calibre16">KeyStore</kbd> data:
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">getProtectionParameter()</kbd></li>
</ul>
</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public static interface KeyStore.ProtectionParameter</kbd>:
<ul class="calibre13">
<li class="calibre14">This interface serves as a marker for <kbd class="calibre16">KeyStore</kbd> protection parameters and contains no methods.</li>
</ul>
</li>
</ul>
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">java.security.KeyStore</kbd> <span class="calibre7">class also contains the six nested classes listed as follows.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Builder</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">KeyStore.Builder</kbd> class is used when you want to defer the instantiation of a <kbd class="calibre16">KeyStore</kbd>:</p>
<pre class="calibre21">    public abstract static class KeyStore.Builder extends Object</pre>
<p class="mce-root">This class provides the necessary information for instantiating a <kbd class="calibre16">KeyStore</kbd> object. The class has the following methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public abstract KeyStore getKeyStore() throws KeyStoreException</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstractKeyStore.ProtectionParameter getProjectionParameter(String alias) throws KeyStoreException</kbd></li>
<li class="calibre14">Three options for <kbd class="calibre16">newInstance</kbd>:
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public static KeyStore.Builder newInstance(KeyStore keyStore, KeyStore.ProtectionParameter protectionParameter)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static KeyStore.Builder newInstance(String type, Provider provider, File file, KeyStore.ProtectionParameter protection)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static KeyStore.Builder newInstance(String type, Provider provider, KeyStore.ProtectionParameter protection)</kbd></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The CallbackHandlerProtection class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">KeyStore.CallbackHandlerProtection</kbd> class definition is as follows:</p>
<pre class="calibre21">    public static class KeyStore.CallbackHandlerProtection extends<br class="calibre2"/>     Object implements KeyStore.ProtectionParameter</pre>
<p class="mce-root">This class provides a <kbd class="calibre16">ProtectionParameter</kbd> to encapsulate a <kbd class="calibre16">CallbackHandler</kbd> and has the following method:</p>
<pre class="calibre21">    public CallbackHandler getCallbackHandler()</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The PasswordProtection class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">KeyStore.PasswordProtection</kbd> class definition is as follows:</p>
<pre class="calibre21">    public static class KeyStore.PasswordProtection extends Object <br class="calibre2"/>     implements KeyStore.ProtectionParameter, Destroyable</pre>
<p class="mce-root">This call provides an implementation of <kbd class="calibre16">ProtectionParameter</kbd> that is password-based. The class has the following methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public void destroy() throws DestroyFailedException</kbd>:
<ul class="calibre13">
<li class="calibre14">This method clears the password</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public char[] getPassword()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns a reference to the password</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public boolean isDestroyed()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns true if the password was cleared</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The PrivateKeyEntry class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">KeyStore.PrivateKeyEntry</kbd> <span class="calibre7">class definition is as follows:</span></p>
<pre class="calibre21">    public static final class KeyStore.PrivateKeyEntry extends<br class="calibre2"/>     Object implements KeyStore.Entry</pre>
<p class="mce-root">This creates an entry to hold a <kbd class="calibre16">PrivateKey</kbd> and the corresponding <kbd class="calibre16">Certificate</kbd> chain. This class has the following methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public Certificate getCertificate()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns the <strong class="calibre3">end entity</strong> <kbd class="calibre16">Certificate</kbd> from the <kbd class="calibre16">Certificate</kbd> chain</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public Certificate[] getCertificateChain()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns the <kbd class="calibre16">Certificate</kbd> chain as an array of <kbd class="calibre16">Certificates</kbd></li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public PrivateKey getPrivateKey()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns the <kbd class="calibre16">PrivateKey</kbd> from the current entry</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public String toString()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns the <kbd class="calibre16">PrivateKeyEntry</kbd> as a <kbd class="calibre16">String</kbd></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The SecretKeyEntry class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">KeyStore.SecretKeyEntry</kbd> <span class="calibre7">class definition is as follows:</span></p>
<pre class="calibre21">    public static final class KeyStore.SecretKeyEntry extends<br class="calibre2"/>     Object implements KeyStore.Entry</pre>
<p class="mce-root">This class holds a <kbd class="calibre16">SecretKey</kbd> and has the following methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public SecretKey getSecretKey()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns the entry's <kbd class="calibre16">SecretKey</kbd></li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public String toString()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns the <kbd class="calibre16">SecretKeyEntry</kbd> as a <kbd class="calibre16">String</kbd>.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The TrustedCertificateEntry class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">KeyStore.TrustedCertificateEntry</kbd> <span class="calibre7">class definition is as follows:</span></p>
<pre class="calibre21">    public static final class KeyStore.TrustedCertificateEntry extends<br class="calibre2"/>     Object implements KeyStore.Entry</pre>
<p class="mce-root">This class holds a trusted <kbd class="calibre16">Certificate</kbd> and has the following methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public Certificate getTrustedCertificate()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns the entry's trusted <kbd class="calibre16">Certificate</kbd></li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public String toString()</kbd>:
<ul class="calibre13">
<li class="calibre14">Returns the entry's trusted <kbd class="calibre16">Certificate</kbd> as a <kbd class="calibre16">String</kbd></li>
</ul>
</li>
</ul>
<p class="mce-root">The key to using this class is understanding the flow. First, we must load the <kbd class="calibre16">KeyStore</kbd>, using the <kbd class="calibre16">getInstance</kbd> method. Next we request access to the <kbd class="calibre16">KeyStore</kbd> instance. Then, we have access to read and write to the <kbd class="calibre16">Object</kbd>:</p>
<div class="mce-root1"><img src="Images/5ed9c56a-5951-4c6c-a561-416a6d07f71e.png" width="1304" height="816" class="calibre145"/></div>
<p class="mce-root">The following code snippet shows the load-request-access implementation:</p>
<pre class="calibre21">    . . . <br class="calibre2"/><br class="calibre2"/>    try {<br class="calibre2"/>      // KeyStore implementation will be returned for the default type<br class="calibre2"/>      KeyStore myKS = KeyStore.getInstance(KeyStore.getDefaultType());<br class="calibre2"/><br class="calibre2"/>      // Load<br class="calibre2"/>      myKS.load(null, null);<br class="calibre2"/>  <br class="calibre2"/>      // Instantiate a KeyStore that holds a trusted certificate<br class="calibre2"/>      TrustedCertificateEntry myCertEntry =<br class="calibre2"/>        new TrustedCertificateEntry(generateCertificate());<br class="calibre2"/><br class="calibre2"/>      // Assigns the trusted certificate to the "pack.pub" alias<br class="calibre2"/>      myKS.setCertificateEntry("packt.pub",<br class="calibre2"/>       myCertEntry.getTrustedCertificate());<br class="calibre2"/>  <br class="calibre2"/>      return myKS;<br class="calibre2"/>    } <br class="calibre2"/>    catch (Exception e) {<br class="calibre2"/>      throw new AssertionError(e);<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  . . .</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">PKCS12 default in Java 9</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Prior to Java 9, the default <kbd class="calibre16">KeyStore</kbd> type was <strong class="calibre8">Java KeyStore</strong> (<strong class="calibre8">JKS</strong>). The Java 9 platform now uses PKCS as the default <kbd class="calibre16">KeyStore</kbd> type, more specifically, PKCS12.</p>
<div class="packt_infobox"><strong class="calibre3">PKCS</strong> is the acronym for <strong class="calibre3">Public Key Cryptography Standards</strong>.</div>
<p class="mce-root">This change to PKCS provides stronger cryptographic algorithms as compared to JKS. As you would expect, JDK 9 will still be compatible with JKS to support previously developed systems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Improving security application performance</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java Enhancement Proposal 232, titled <em class="calibre20">Improving Security Application Performance</em>, was focused on performance improvements when running applications with a security manager installed. Security managers can result in processing overhead and less than ideal application performance.</p>
<p class="mce-root">This is an impressive undertaking as current CPU overhead when running security managers is estimated to result in 10-15% performance degradation. It is not feasible to completely remove the CPU overhead as some CPU processing is required to run the security manager. That being said, the intention of this proposal (JEP-232) was to decrease the overhead percentage as much as possible.</p>
<p class="mce-root">This effort resulted in the following optimizations, each detailed in subsequent sections:</p>
<ul class="calibre13">
<li class="calibre14">Security policy enforcement</li>
<li class="calibre14">Permission evaluation</li>
<li class="calibre14">Hash code</li>
<li class="calibre14">Package checking algorithm</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Security policy enforcement</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">JDK 9 uses <kbd class="calibre16">ConcurrentHashMap</kbd> for mapping <kbd class="calibre16">ProtectionDomain</kbd> to <kbd class="calibre16">PermissionCollection</kbd>. <kbd class="calibre16">ConcurrentHashMap</kbd> is typically used for high concurrency in applications. It has the following characteristics:</p>
<ul class="calibre13">
<li class="calibre14">Thread safe</li>
<li class="calibre14">Enter map does not need to be synchronized</li>
<li class="calibre14">Fast reads</li>
<li class="calibre14">Writes use locks</li>
<li class="calibre14">No object-level locking</li>
<li class="calibre14">Locking at a very granular level</li>
</ul>
<p class="mce-root">The <kbd class="calibre16">ConcurrentHashMap</kbd> class definition follows:</p>
<pre class="calibre21">    public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; <br class="calibre2"/>     implements ConcurrentMap&lt;K, V&gt;, Serializable</pre>
<p class="mce-root">In the preceding class definition, <kbd class="calibre16">K</kbd> refers to the type of keys maintained by the hash map and <kbd class="calibre16">V</kbd> indicates the type of mapped values. There is a <kbd class="calibre16">KeySetView</kbd> sub-class and several methods.</p>
<p class="mce-root">There are three additional classes related to enforcing security policy--<kbd class="calibre16">ProtectionDomain</kbd><span class="calibre7">,</span> <kbd class="calibre16">PermissionCollection</kbd><span class="calibre7">, and <kbd class="calibre16">SecureClassLoader</kbd>:</span></p>
<ul class="calibre13">
<li class="calibre14">The <kbd class="calibre16">ProtectionDomain</kbd> class is used to encapsulate a group of classes so that permissions can be granted to the domain.</li>
<li class="calibre14">The <kbd class="calibre16">PermissionCollection</kbd> class represents a collection of permission objects.</li>
<li class="calibre14">The <kbd class="calibre16">SecureClassLoader</kbd> class, which extends the <kbd class="calibre16">ClassLoader</kbd> class, provides additional functionality for defining classes with permissions for retrieval by the system policy. In Java 9, this class uses <kbd class="calibre16">ConcurrentHashMap</kbd> for increased security.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Permission evaluation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Under the category of permission evaluation, three optimizations were made:</p>
<ul class="calibre13">
<li class="calibre14">The <kbd class="calibre16">identifyPolicyEntries</kbd> list previously had policy provider code for synchronization. This code has been removed in JDK 9.</li>
<li class="calibre14"><kbd class="calibre16">PermissionCollection</kbd> entries are now stored in a <kbd class="calibre16">ConcurrentHashMap</kbd>. They were previously stored as a <kbd class="calibre16">HashMap</kbd> in a <kbd class="calibre16">Permission</kbd> class.</li>
<li class="calibre14">Permissions are now stored in concurrent collections in subclasses of <kbd class="calibre16">PermissionCollection</kbd>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The java.Security.CodeSource package</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A hash code is an object-generated number that is stored in a hash table for rapid storage and retrieval. Every object in Java has a hash code. Here are some characteristics and rules for hash codes:</p>
<ul class="calibre13">
<li class="calibre14">Hash codes are the same for equal objects within a running process</li>
<li class="calibre14">Hash codes can change between execution cycles</li>
<li class="calibre14">Hash codes should not be used as keys</li>
</ul>
<p class="mce-root">The Java 9 platform includes a modified <kbd class="calibre16">hashCode</kbd> method of <kbd class="calibre16">java.security.CodeSource</kbd> to optimize DNS lookups. These can be processor intensive, so a String version of the code source URL is used to compute hash codes.</p>
<p class="mce-root">The <kbd class="calibre16">CodeSource</kbd> class definition follows:</p>
<pre class="calibre21">    public class CodeSource extends Object implements Serializable</pre>
<p class="mce-root">This class has the following methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public boolean equals(Object obj)</kbd>: Returns <kbd class="calibre16">true</kbd> if the objects are equal. This overrides the <kbd class="calibre16">equals</kbd> method in the <kbd class="calibre16">Object</kbd> class.</li>
<li class="calibre14"><kbd class="calibre16">public final Certificate[] getCertificates()</kbd>: Returns an array of certificates.</li>
<li class="calibre14"><kbd class="calibre16">public final CodeSigner[] getCodeSigners()</kbd>: Returns an array of the code signers associated with the <kbd class="calibre16">CodeSource</kbd>.</li>
<li class="calibre14"><kbd class="calibre16">public final URL getLocation()</kbd>: Returns the URL.</li>
<li class="calibre14"><kbd class="calibre16">public int hashCode()</kbd>: Returns the hash code value for the current object.</li>
<li class="calibre14"><kbd class="calibre16">public boolean implies(CodeSource codesource)</kbd>: Returns true if the given code source meets the following criteria:
<ul class="calibre13">
<li class="calibre14">is not null</li>
<li class="calibre14">object's certificates are not null</li>
<li class="calibre14">object's location is not null</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public String toString()</kbd>: Returns a <kbd class="calibre16">String</kbd> with information about the <kbd class="calibre16">CodeSource</kbd> to include the location and certificates.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Package checking algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java 9's final <span class="calibre7">performance improvement when running applications with a security manager installed, came in the form of the <kbd class="calibre16">java.lang.SecurityManager</kbd> package enhancements. Specifically, the <kbd class="calibre16">checkPackageAccess</kbd> method's package checking algorithm was modified.</span></p>
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">java.lang.SecurityManager</kbd> <span class="calibre7">class allows applications to implement security policy on specific operations. The <kbd class="calibre16">public void checkPackageAccess(String pkg)</kbd> method, of this class receives a comma-delimited list of restricted packages from the the <kbd class="calibre16">getProperty</kbd> method. As illustrated here, depending on the evaluation, the <kbd class="calibre16">checkPackageAccess</kbd> method can throw one of two exceptions:</span></p>
<div class="mce-root1"><img src="Images/3eb8d4b8-ce69-45d2-9aa9-089c3242a60b.png" width="2150" height="1112" class="calibre146"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">TLS application-layer protocol negotiation extension</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java Enhancement Proposal 244, simply enhanced the <kbd class="calibre16">javax.net.ssl</kbd> package so that it supports the <strong class="calibre8">Transport Layer Security</strong> (<strong class="calibre8">TLS</strong>) <strong class="calibre8">ALPN</strong> (<strong class="calibre8">Application Layer Protocol Negotiation</strong>) extension. This extension permits application protocol negotiation for TLS connections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">TLS ALPN extension</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The ALPN is a TLS extension and can be used to negotiate which protocol to implement when using a secure connection. ALPN represents an efficient means of negotiating protocols. As indicated in the following diagram, there are five basic steps to TLS handshakes:</p>
<div class="mce-root1"><img src="Images/ad131890-dcff-459d-8703-ee8fa804d6b7.png" width="1212" height="1050" class="calibre147"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The javax.net.ssl package</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">java.net.ssl</kbd> package contains classes relating to secure socket packages. This permits us to use SSL as an example, for the reliable detection of errors introduced to the network byte stream. It also provides the ability to encrypt the data as well as provide authentication of client and server.</p>
<p class="mce-root">This package includes the following interfaces:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public interface HandshakeCompletedListener extends EventListener</kbd></li>
<li class="calibre14"><kbd class="calibre16">public interface HostnameVerifier</kbd></li>
<li class="calibre14"><kbd class="calibre16">public interface KeyManager</kbd></li>
<li class="calibre14"><kbd class="calibre16"><kbd class="calibre79">public interface ManagerFactoryParameters</kbd></kbd></li>
<li class="calibre14"><kbd class="calibre16">public interface SSLSession</kbd></li>
<li class="calibre14"><kbd class="calibre16">public interface SSLSessionBindingListener extends EventListener</kbd></li>
<li class="calibre14"><kbd class="calibre16">public interface SSLSessionContext</kbd></li>
<li class="calibre14"><kbd class="calibre16">public interace TrustManager</kbd></li>
<li class="calibre14"><kbd class="calibre16">public interface X509KeyManager extends KeyManager</kbd></li>
<li class="calibre14"><kbd class="calibre16">public interface X509TrustManager extends TrustManager</kbd></li>
</ul>
<p class="mce-root">The <span class="calibre7"><kbd class="calibre16">java.net.ssl</kbd></span> package also has the following sub-classes:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public class CertPathTrustManagerParameters extends Object implements ManagerFactoryParameters</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class ExtendedSSLSession extends Object implements SSLSession</kbd></li>
<li class="calibre14"><kbd class="calibre16">public class HandshakeCompleteEvent extends EventObject</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class HttpsURLConnection extends HttpURLConnection</kbd></li>
<li class="calibre14"><kbd class="calibre16">public class KeyManagerFactory extends Object</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class KeyManagerFactorySpi</kbd></li>
<li class="calibre14"><kbd class="calibre16">public class KeyStoreBuilderParameters extends Object implements ManagerFactoryParameters</kbd></li>
<li class="calibre14"><kbd class="calibre16">public class SSLContext extends Object</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class SSLContextSpi extends Object</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class SSLEngine extends Object</kbd></li>
<li class="calibre14"><kbd class="calibre16">public class SSLEngineResult extends Object</kbd></li>
<li class="calibre14"><kbd class="calibre16">public class SSLParameters extends Object</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final class SSLPermission extends BasicPermission</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class SSLServerSocket extends ServerSocket</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class SSLServerSocketFactory extends ServerSocketFactory</kbd></li>
<li class="calibre14"><kbd class="calibre16">public class SSLSessionBindingEvent extends EventObject</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class SSLSocket extends Socket</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class SSLSocketFactory extends SocketFactory</kbd></li>
<li class="calibre14"><kbd class="calibre16">public class TrustManagerFactory extends Object</kbd></li>
<li class="calibre14"><kbd class="calibre16"><kbd class="calibre79">public abstract class TrustManagerFactorySpi extends Object</kbd></kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class X509ExtendedKeyManager extends Object implements X509KeyManager</kbd></li>
<li class="calibre14"><kbd class="calibre16">public abstract class X509ExtendedTrustManager extends Object implements x509TrustManager</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The java.net.ssl package extension</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The change to the <kbd class="calibre16">java.net.ssl</kbd> package in the Java 9 platform is that it now supports the TLS ALPN extension. Key benefits of this change are:</p>
<ul class="calibre13">
<li class="calibre14">TLS clients and servers can now use multiple application-layer protocols, which may or may not use the same transport-layer port</li>
<li class="calibre14">The ALPN extension permits clients to prioritize application-layer protocols it supports</li>
<li class="calibre14">Servers can select a client protocol and for the TLS connection</li>
<li class="calibre14">Supports HTTP/2</li>
</ul>
<p class="mce-root">The following illustration was previously presented as the <span class="calibre7">five basic steps to TLS handshakes. Updated for Java 9 and presented here, the illustration indicates where the protocol names are shared between the client and server:</span></p>
<div class="mce-root1"><img src="Images/cba4b2e5-95d3-46b2-867f-67ed154af091.png" width="1494" height="1114" class="calibre148"/></div>
<p class="mce-root">Once the client's list of application layer protocols is received, the server can s<span class="calibre7">elect the server's preferred intersection value and e</span><span class="calibre7">xternally scan initial plain text <kbd class="calibre16">ClientHellos</kbd> and select an ALPN protocol. An application server will do one of the following:</span></p>
<ul class="calibre13">
<li class="calibre14">Select any of the supported protocols</li>
<li class="calibre14">Decide that the ALPN values (remotely offered and locally supported) are mutually exclusive</li>
<li class="calibre14">Ignore the ALPN extension</li>
</ul>
<p class="mce-root">Other key behaviors with regards to the ALPN extension:</p>
<ul class="calibre13">
<li class="calibre14">The server can alter connection parameters</li>
<li class="calibre14">After the SSL/TLS handshake starts, the application can query to see if an ALPN value has been selected yet</li>
<li class="calibre14">After the SSL/TLS handshake ends, the application can review which protocol was used</li>
</ul>
<p class="mce-root">A <kbd class="calibre16">ClientHello</kbd> is the first message in the TLS handshake. It has the following structure:</p>
<pre class="calibre21"><span class="calibre5">    struct</span> <span class="p">{</span>
      <span class="calibre5">ProtocolVersion</span> <span class="calibre5">client_version</span><span class="p">;</span>
      <span class="calibre5">Random</span> <span class="calibre5">random</span><span class="p">;</span>
      <span class="calibre5">SessionID</span> <span class="calibre5">session_id</span><span class="p">;</span>
      <span class="calibre5">CipherSuite</span> <span class="calibre5">cipher_suites</span><span class="calibre5">&lt;</span><span class="calibre5">2..2</span><span class="calibre5">^</span><span class="calibre5">16</span><span class="calibre5">-</span><span class="calibre5">1</span><span class="calibre5">&gt;</span><span class="p">;</span>
      <span class="calibre5">CompressionMethod</span> <span class="calibre5">compression_methods</span><span class="calibre5">&lt;</span><span class="calibre5">1..2</span><span class="calibre5">^</span><span class="calibre5">8</span><span class="calibre5">-</span><span class="calibre5">1</span><span class="calibre5">&gt;</span><span class="p">;</span>
      <span class="calibre5">Extension</span> <span class="calibre5">extensions</span><span class="calibre5">&lt;</span><span class="calibre5">0..2</span><span class="calibre5">^</span><span class="calibre5">16</span><span class="calibre5">-</span><span class="calibre5">1</span><span class="calibre5">&gt;</span><span class="p">;</span>
<span class="p">    }</span> <span class="calibre5">ClientHello</span><span class="p">;</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Leveraging CPU instructions for GHASH and RSA</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The self-descriptive title of Java Enhancement Proposal (JEP) 246, <strong class="calibre8">Leverage CPU Instructions for GHASH and RSA</strong>, provides great insight into its goal. The point of this JEP was to improve the performance of cryptographic operations, specifically GHASH and RSA. The performance improvement has been achieved in Java 9 by leveraging the newest SPARC and Intel x64 CPU instructions.</p>
<p class="mce-root">This enhancement did not require new or modified APIs as part of the Java 9 platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Hashing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7"><strong class="calibre8">Galois HASH</strong> (<strong class="calibre8">GHASH</strong>) and <strong class="calibre8">Rivest-Shamir-Adleman</strong> (<strong class="calibre8">RSA</strong>) are crypto systems hashing algorithms.</span> Hashes are a fixed length string or number generated from a string of text. Algorithms, specifically hashing algorithms, are devised so that the resultant hashes cannot be reverse engineered. We use hashing to store passwords that are generated with a salt.</p>
<div class="packt_infobox">Salts, in cryptology, are random data used as an input to a hashing function to generate a password. Salts help protect against rainbow table attacks and dictionary attacks.</div>
<p class="mce-root">The following graphic illustrates the basics of how hashing works:</p>
<div class="mce-root1"><img src="Images/0d04339c-77d0-4e35-9978-19a70ee1a5d3.png" width="1814" height="590" class="calibre149"/></div>
<p class="mce-root">As you can see, the hashing algorithm is fed plain text and a salt resulting in a new hashed password and the salt being stored. Here is the same graphic with sample input/output to demonstrate the functionality:</p>
<div class="mce-root1"><img src="Images/2760ddd0-8d13-46df-b1f0-e2c8d75cb5e9.png" width="1758" height="550" class="calibre150"/></div>
<p class="mce-root">The validation process, the following diagram starts with the user entering their plain text password. The hashing algorithm takes that plain text and rehashes it with the stored salt. Then the resulting hashed password is compared to the stored one:</p>
<div class="mce-root1"><img src="Images/6934f835-2c43-4bf3-a07c-3fceb6fbc617.png" width="1964" height="812" class="calibre151"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">OCSP stapling for TLS</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre8">Online Certificate Status Protocol</strong> (<strong class="calibre8">OCSP</strong>) stapling is a method of checking the revocation status of digital certificates. The OCSP stapling approach for determining an SSL certificate's validity is assessed as being both safe and quick. The determination speed is achieved by permitting web servers to provide the validity information on its organic certificates instead of the lengthier process of requesting validating information from the certificate's issuing vendor.</p>
<div class="packt_infobox"><span class="calibre5"><strong class="calibre3">Online Certificate Status Protocol</strong> (<strong class="calibre3">OCSP</strong>) stapling was previously referred to as the <strong class="calibre3">Transport Layer Security</strong> (<strong class="calibre3">TLS</strong>) certificate status request extension.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">OCSP stapling primer</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">THE OCSP stapling process involves several components and validity checks. The following graphic illustrates the OCSP stapling process:</p>
<div class="mce-root1"><img src="Images/f13723c8-e7c1-44f3-8b75-f0ee59f1a148.png" width="1942" height="1258" class="calibre152"/></div>
<p class="mce-root">As you can see, the process starts when the user attempts to open an SSL-encrypted website via their browser. The browser queries the web server to ensure the SSL-encrypted website has a valid certificate. The web server queries the certificate's vendor and is provided with both the certificate status and the digital signed time-stamp. The web server takes those two components (certificate status and digital signed time-stamp), staples them together, and returns the stapled set to the requesting browser. The browser can then check the validity of the time-stamp and decide whether to display the SSL-encrypted website or to display an error.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Changes for the Java 9 platform</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java Enhancement Proposal 249, <strong class="calibre8">OCSP Stapling for TLS</strong>, implements OCSP stapling via the TLS certificate status request extension. OSCP stapling checks the validity of X.509 certificates.</p>
<div class="packt_infobox">X.509 certificates are digital certificates that use the X509 <strong class="calibre3">Public Key Infrastructure</strong> (<strong class="calibre3">PKI</strong>).</div>
<p class="mce-root">Prior to Java 9, the certificate validity check (really, the check to see if the certificate has been revoked) can be enabled on the client side and has the following inefficiencies:</p>
<ul class="calibre13">
<li class="calibre14">OCSP responder performance bottlenecks</li>
<li class="calibre14">Performance degradation based on multiple passes</li>
<li class="calibre14">Additional performance degradation if OCSP checking is performed client side</li>
<li class="calibre14">False <strong class="calibre3">fails</strong> when browsers do not connect to an OCSP responder</li>
<li class="calibre14">Susceptibility of denial of service attacks on OCSP responders</li>
</ul>
<p class="mce-root">The new OCSP stapling for TLS includes the following system property changes for the Java 9 platform:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">jdk.tls.client.enableStatusRequestExtension</kbd>:
<ul class="calibre13">
<li class="calibre14">Default setting: true</li>
<li class="calibre14">Enables <kbd class="calibre16">status_request</kbd> extension</li>
<li class="calibre14">Enables <kbd class="calibre16">status_request_v2</kbd> extension</li>
<li class="calibre14">Enables processing <kbd class="calibre16">CertificateStatus</kbd> messages from server</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">jdk.tls.server.enableStatusRequestExtension</span></kbd>:
<ul class="calibre13">
<li class="calibre14">Default setting: false</li>
<li class="calibre14">Enables OCSP stapling support server-side</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">jdk.tls.stapling.responseTimeout</span></kbd>:
<ul class="calibre13">
<li class="calibre14">Default setting: 5000 milliseconds</li>
<li class="calibre14">Controls maximum time allocated by server to obtain OCSP responses</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">jdk.tls.stapling.cacheSize</span></kbd>:
<ul class="calibre13">
<li class="calibre14">Default setting: 256</li>
<li class="calibre14">Controls maximum number of cache entries</li>
<li class="calibre14">Can set maximum to zero eliminates ceiling</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">jdk.tls.stapling.cacheLifetime</span></kbd>:
<ul class="calibre13">
<li class="calibre14">Default setting: 3600 seconds (1 hour)</li>
<li class="calibre14">Controls maximum lifetime of a cached response</li>
<li class="calibre14">Can set value to zero in order to disable cache lifetime</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">jdk.tls.stapling.responderURI</span></kbd>:
<ul class="calibre13">
<li class="calibre14">Default setting: none</li>
<li class="calibre14">Can set a default URI for certificates without the <strong class="calibre3">Authority Info Access</strong> (<strong class="calibre3">AIA</strong>) extension</li>
<li class="calibre14">Does not override the AIA extension unless <kbd class="calibre16">jdk.tls.stapling.Override</kbd> property is set</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">jdk.tls.stapling.respoderOverride</span></kbd>:
<ul class="calibre13">
<li class="calibre14">Default setting: false</li>
<li class="calibre14">Allows a <kbd class="calibre16">jdk.tls.stapling.responderURI</kbd> provided property to override AIA extension values</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">jdk.tls.stapling.ignoreExtensions</span></kbd>:
<ul class="calibre13">
<li class="calibre14">Default setting: false</li>
<li class="calibre14">Disables OCSP extension forwarding as specified in <kbd class="calibre16">status_request</kbd> or <kbd class="calibre16">status_request_v2</kbd> TLS extensions.</li>
</ul>
</li>
</ul>
<p class="mce-root">The <kbd class="calibre16">status_request</kbd> and <kbd class="calibre16">status_request_v2</kbd> TLS hello extensions are now supported by both client and server-side Java implementations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">DRBG-based SecureRandom implementations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Prior to Java 9, the JDK had two approaches to generating secure random numbers. One method, written in Java, used SHA1-based random number generation and was not terribly strong. The other method was platform-dependent and used preconfigured libraries.</p>
<p class="mce-root"><strong class="calibre8">Deterministic Random Bit Generator</strong> (<strong class="calibre8">DRBG</strong>) is a method for generating random numbers. It has been approved by the <strong class="calibre8">National Institute of Standards and Technology</strong> (<strong class="calibre8">NIST</strong>), a branch of the U.S. Department of Commerce. DRBG methodologies include modern and stronger algorithms for generating secure random numbers.</p>
<p class="mce-root">Java Enhancement Proposal 273, <strong class="calibre8">DRBG-Based SecureRandom Implementations</strong> aimed to implement three specific DRBG mechanisms. These mechanisms are listed as follows:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">Hash_DRBG</kbd></li>
<li class="calibre14"><kbd class="calibre16">HMAC_DRBG</kbd></li>
<li class="calibre14"><kbd class="calibre16">CTR_DRBG</kbd></li>
</ul>
<div class="packt_tip">You can learn specifics about each of the DRBG mechanisms at <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf</a></div>
<p class="mce-root">Here are the three new APIs:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">SecureRandom</kbd>: New methods allowing the configuration of <kbd class="calibre16">SecureRandom</kbd> objects with the below listed configurable properties:
<ul class="calibre13">
<li class="calibre14">seeding</li>
<li class="calibre14">reseeding</li>
<li class="calibre14">random-bit-generation</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">SecureRandomSpi</kbd>: new methods to implement the <kbd class="calibre16">SecureRandom</kbd> methods</li>
<li class="calibre14"><kbd class="calibre16">SecureRandomParameter</kbd>: new interface so input can be passed to the new <kbd class="calibre16">SecureRandom</kbd> methods</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we looked a<span class="calibre7">t several small, but significant changes to the JDK that involve security. The featured security enhancements that are part of the Java 9 platform provide developers with the distinct ability to write and maintain applications that implement security. Specifically, we covered DTLS</span>, keystores, improving security application performance, the TLS application-layer protocol negotiation extension, leveraging CPU instructions for GHASH and RSA, OCSP stapling for TLS, and DRBG-based <kbd class="calibre16">SecureRandom</kbd> implementations.</p>
<p class="mce-root">In the next chapter we will explore the new command-line flags used in Java 9 as well as changes to various command-line tools. Our coverage will include managing the Java JVM run-time and compiler using the new command-line options and flags.</p>


            </article>

            
        </section>
    </div>



  </body></html>