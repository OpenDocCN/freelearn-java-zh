<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Communicating with External Systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Communicating with External Systems</h1></div></div></div><p>In this chapter, we are going to add the possibility to communicate with different systems in our application. Technically, we will resolve a systems integration problem. System integration problems include several cases: two applications that exchange data synchronously or asynchronously, an application that accesses information provided by another, an application that executes processes implemented in another, and so on. Given the number of solutions that exist today, it is necessary to know which one to choose depending on the problem, hence the importance of this chapter. At the end of this chapter, you will be able to choose an integration solution and have an overview of the changes made in the following APIs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JavaMail</li><li class="listitem" style="list-style-type: disc">Java EE connector architecture</li><li class="listitem" style="list-style-type: disc">Java message service</li><li class="listitem" style="list-style-type: disc">JAX-RS: Java API for RESTful Web Services</li></ul></div><div class="section" title="JavaMail"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec27"/>JavaMail</h1></div></div></div><p>The JavaMail 1.5 Specification was <a id="id337" class="indexterm"/>developed under JSR 919. This section just gives you an overview of improvements in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/mrel/jsr919/index2.html">http://jcp.org/aboutJava/communityprocess/mrel/jsr919/index2.html</a>.</p><div class="section" title="Sending e-mails in Java"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec38"/>Sending e-mails in Java</h2></div></div></div><p>The expansion of the Internet <a id="id338" class="indexterm"/>has greatly facilitated communication across the world through electronic messages (e-mail). Today, people at the ends of the earth can exchange information in a very short time. In order for this to be done, there must be a mail server for storage of data exchanged and clients (for example, Outlook) for sending and retrieving data. Communication between these elements requires different types of protocols, <a id="id339" class="indexterm"/>for example, <span class="strong"><strong>SMTP</strong></span> (<span class="strong"><strong>Simple Mail Transport Protocol</strong></span>) for sending mails, <span class="strong"><strong>POP</strong></span>
<span class="strong"><strong>3</strong></span> (<span class="strong"><strong>Post Office Protocol</strong></span>) for <a id="id340" class="indexterm"/>receiving mails, <span class="strong"><strong>IMAP</strong></span> (<span class="strong"><strong>Internet Message Access Protocol</strong></span>) for <a id="id341" class="indexterm"/>receiving e-mails. This multitude of protocols can pose a problem to the developer.</p><p>Given the multitude of protocols and <a id="id342" class="indexterm"/>the difficulties of low-level programming, the Java language provides the <span class="strong"><strong>JavaMail</strong></span> API in order to simplify sending and retrieving e-mails regardless of the underlying protocols. But the JavaMail API is not enough; because it was designed to handle the transmission aspect of the <a id="id343" class="indexterm"/>message (connection parameter, source, destination, subject, and so on), the body of the message is <a id="id344" class="indexterm"/>managed by <span class="strong"><strong>JavaBeans Activation Framework</strong></span> (<span class="strong"><strong>JAF framework</strong></span>). That is why, in addition to the <code class="literal">mail.jar</code> library, you have to import the <code class="literal">activation.jar</code> library.</p><div class="section" title="Sending an e-mail via the SMTP protocol"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec38"/>Sending an e-mail via the SMTP protocol</h3></div></div></div><p>Sending an e-mail using <a id="id345" class="indexterm"/>JavaMail is done as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Obtain the <code class="literal">session</code> <a id="id346" class="indexterm"/>object. This object encapsulates various information such as the address of <a id="id347" class="indexterm"/>the mail server. The following code shows how to get an object of type <code class="literal">Session</code>:<div class="informalexample"><pre class="programlisting">Properties prop = System.getProperties();
//serveurAddress is the host of you mail server
prop.put("mail.smtp.host", serveurAddress);
Session session = Session.getDefaultInstance(prop,null);</pre></div></li><li class="listitem">Construct the message. To send an e-mail, it is necessary to define some parameters such as the content of the e-mail, the sender, and destination. In addition to these settings, you may need to specify the subject of your e-mail and its header. All this is made possible through the <a id="id348" class="indexterm"/><code class="literal">MimeMessage</code> class that offers several methods to construct a message for a given session. The following code shows how to get an object of type <code class="literal">MimeMessage</code> and build a mail to send:<div class="informalexample"><pre class="programlisting">Message msg = new MimeMessage(session);
msg.setFrom(new InternetAddress("xxx-university@yahoo.fr"));
InternetAddress[] internetAddresses = new InternetAddress[1];
internetAddresses[0] = new InternetAddress("malindaped@yahoo.fr");
msg.setRecipients(Message.RecipientType.TO,internetAddresses);
msg.setSubject("Pre-inscription results");
msg.setText("Dear Malinda, we inform you that …");</pre></div></li><li class="listitem">Send the message. We send a message in one line with the <code class="literal">Transport</code> class. The following code shows how to send the message:<div class="informalexample"><pre class="programlisting">Transport.send(msg);</pre></div></li></ol></div><p>The following code shows how to send the results of preregistration for individual candidates from a Gmail account. As you can see, the Gmail sender account and its password are passed as a parameter to the <code class="literal">send</code> method. This allows the application to be authenticated by the server when sending the message. To test the sending code associated with this chapter, you need to have a Gmail account <a id="id349" class="indexterm"/>and replace <code class="literal">username</code> with the username of your account and <code class="literal">user_password</code> with the password of this account.</p><p>The following code is an example of <a id="id350" class="indexterm"/>sending an e-mail via Gmail SMTP server by using JavaMail API:</p><div class="informalexample"><pre class="programlisting">public class MailSender {

  private final String userName = "username@gmail.com";
  private final String userPassword = "user_password";    
  private Session session;

  public MailSender() {
    Properties props = new Properties();
    props.put("mail.smtp.auth", "true");
    props.put("mail.smtp.starttls.enable", "true");
    props.put("mail.smtp.host", "smtp.gmail.com");
    props.put("mail.smtp.port", "587");
    
    session = Session.getInstance(props, null);
  }

  public void sendMesage(String message, String toAddress) {
    try {
    
      Message msg = new MimeMessage(session);
      InternetAddress[] internetAddresses =new InternetAddress[1];
      internetAddresses[0] = new InternetAddress(toAddress);
      msg.setRecipients(Message.RecipientType.TO, internetAddresses);
      msg.setSubject("Pre-inscription results");
      msg.setText(message);
      
      Transport.send(msg, userName, userPassword);
    } catch (Exception ex) {
      ex.printStackTrace();
    }
  
  }
}</pre></div><p>Of course, the JavaMail API provides <a id="id351" class="indexterm"/>the ability to retrieve messages, attach documents to your messages, write messages in HTML <a id="id352" class="indexterm"/>format, and do lots of other things.</p></div></div><div class="section" title="The latest improvements in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec39"/>The latest improvements in action</h2></div></div></div><p>Although it is affected by a <a id="id353" class="indexterm"/>maintenance release, the JavaMail 1.5 Specification has undergone many changes. The most important can be grouped into three categories, which are: addition of annotations, addition of methods, and changing of some access modifiers.</p><div class="section" title="The added annotations"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec39"/>The added annotations</h3></div></div></div><p>In all, JavaMail 1.5 introduced two <a id="id354" class="indexterm"/>new annotations (<code class="literal">@MailSessionDefinition</code> and <code class="literal">@MailSessionDefinitions</code>) to configure JavaMail session resources in a Java EE 7 application server.</p><p>The <code class="literal">@MailSessionDefinition</code> <a id="id355" class="indexterm"/>annotation contains several <a id="id356" class="indexterm"/>parameters (see the <code class="literal">Java</code> class in the following code) with the goal of offering the possibility to define a Mail Session that will be registered in any valid Java EE namespace and accessed by other components through the <span class="strong"><strong>JNDI</strong></span>.</p><p>The following code highlights the attributes of <code class="literal">@MailSessionDefinition</code> annotation:</p><div class="informalexample"><pre class="programlisting">public @interface MailSessionDefinition {

  String description() default "";
  
  String name();

  String storeProtocol() default "";

  String transportProtocol() default "";

  String host() default "";
  String user() default "";

  String password() default "";

  String from() default "";

  String[] properties() default {};
}</pre></div><p>With this annotation, we can now define and use objects of <code class="literal">Session</code> type as in the case of the following code which is an example to show how to use <code class="literal">@MailSessionDefinition</code>:</p><div class="informalexample"><pre class="programlisting">@MailSessionDefinition(
  name = "java:app/env/MyMailSession",
  transportProtocol = "SMTP",
  user = "username@gmail.com",
  password = "user_password"        
  //...
)
@WebServlet(name = "MailSenderServlet")
public class MailSenderServlet extends HttpServlet {
  
  @Resource(lookup="java:app/env/MyMailSession")
  Session session;

  public void doPost(HttpServletRequest request, HttpServletResponse response)
  throws IOException, ServletException {

    //...
  }
}</pre></div><p>While the <code class="literal">@MailSessionDefinition</code> <a id="id357" class="indexterm"/>annotation allows us to define <code class="literal">MailSession</code>, <code class="literal">@MailSessionDefinitions</code> annotation allows us to configure many <code class="literal">MailSession</code> instances. The following code shows how to define two <code class="literal">MailSession</code> using instances <code class="literal">@MailSessionDefinitions</code> at a time:</p><div class="informalexample"><pre class="programlisting">@MailSessionDefinitions(
        { @MailSessionDefinition(name = "java:/en/..."),
        @MailSessionDefinition(name = "java:/en/...") }
)</pre></div></div><div class="section" title="The added methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec40"/>The added methods</h3></div></div></div><p>In order to ease the developer's work, <a id="id358" class="indexterm"/>JavaMail 1.5 added new methods that provide really interesting shortcuts. For example, the addition of the <code class="literal">Transport.send(msg, username, password)</code> method avoids creating additional objects for authentication parameters when sending the message. Before this, authentication parameters were defined at the <code class="literal">session</code> object and as you can see with the following code:</p><div class="informalexample"><pre class="programlisting">Session session = Session.getInstance(props,new javax.mail.Authenticator() {
  protected PasswordAuthentication getPasswordAuthentication() {
    return new PasswordAuthentication(username, password);
    }
});</pre></div><p>As another example of an added method, <a id="id359" class="indexterm"/>you have the <code class="literal">Message.getSession()</code> method, which allows you to access the <code class="literal">session</code> type object that was used to create the message. This may prevent you from having to drag the session throughout your treatment. The last added method that we will talk about is the <code class="literal">MimeMessage.reply(replyToAll, setAnswered)</code> method, which, due to the second parameter, allows you to automatically add a <code class="literal">Re</code> prefix to the subject line when you respond, for example, to a message.</p></div><div class="section" title="The changing of some access modifiers"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec41"/>The changing of some access modifiers</h3></div></div></div><p>Concerning access modifiers, the <a id="id360" class="indexterm"/>JavaMail 1.5 Specification has put an emphasis on good practice in some classes and facilitated the extension of others.</p><p>You will see, for example, that the access modifiers of the protected fields in the final classes of the <code class="literal">javax.mail.search</code> package have been changed to private. In fact, it is not important that the final class contains protected fields with public <code class="literal">getter</code>/<code class="literal">setter</code> method. So it is better to make them private and let <code class="literal">getter</code>/<code class="literal">setter</code> be public so that we can access/edit their values from outside.</p><p>Still, in the changing of access modifier, JavaMail 1.5 has transformed the fields <code class="literal">cachedContent</code> (of classes <code class="literal">MimeBodyPart</code> and <code class="literal">MimeMessage</code>) and <code class="literal">MimeMultipart</code> class's fields from private to protected in order to facilitate the extension of the relevant classes.</p></div></div></div></div>
<div class="section" title="Java EE Connector Architecture (JCA)"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Java EE Connector Architecture (JCA)</h1></div></div></div><p>The Java EE Connector <a id="id361" class="indexterm"/>Architecture 1.7 Specification was developed under JSR 322. This section just gives you an overview of improvements in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr322/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr322/index.html</a>.</p><div class="section" title="What is JCA?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>What is JCA?</h2></div></div></div><p>Generally, <span class="strong"><strong>Enterprise Information </strong></span><a id="id362" class="indexterm"/>
<span class="strong"><strong>Systems</strong></span> (<span class="strong"><strong>EIS</strong></span>s) of large companies are composed of a number of <a id="id363" class="indexterm"/>tools such as <span class="strong"><strong>Enterprise </strong></span><a id="id364" class="indexterm"/>
<span class="strong"><strong>Resource Planning</strong></span> applications (<span class="strong"><strong>ERP</strong></span>, that is <span class="strong"><strong>SAP</strong></span>), <span class="strong"><strong>Customer Relationship Management</strong></span> applications (<span class="strong"><strong>CRM</strong></span>, that is <a class="ulink" href="http://salesforce.com">salesforce.com</a>), <a id="id365" class="indexterm"/>mainframe Transaction Processing applications, legacy applications and Database Systems (such as Oracle). In such an environment, the development of a new solution may require access to one or more of these tools to retrieve information or perform processing: we then talk of an <a id="id366" class="indexterm"/>
<span class="strong"><strong>Enterprise Application Integration</strong></span> (<span class="strong"><strong>EAI</strong></span>). In the absence of a standard solution, this integration will be costly to both vendors and developers. Vendors will develop APIs to manage communication between different kinds of servers and developers will address EISs case by case and will implement the technical features (connection polling, transaction security mechanism, and so on) required by the application. Hence the need for JCA.</p><p>The Java EE Connector Architecture (JCA) is a specification that aims to standardize access to heterogeneous existing EISs from Java EE platforms. To this end, it defines a set of contracts that enable developers to access the different EISs seamlessly from a common interface called the <a id="id367" class="indexterm"/>
<span class="strong"><strong>Common Client Interface</strong></span> (<span class="strong"><strong>CCI</strong></span>). For those who have already been working with <span class="strong"><strong>JDBC</strong></span>, understanding of the functioning of JCA is a little easier. A JCA connector consists of two main <a id="id368" class="indexterm"/>elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Common Client Interface</strong></span> (<span class="strong"><strong>CCI</strong></span>): This API is to EISs as JDBC is to databases. In other words, the CCI defines a standard client API that allows components to access EISs and perform processing.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resource Adapter</strong></span>: This is <a id="id369" class="indexterm"/>a specific implementation of the CCI for a given EIS. It is provided by the vendor, which guarantees the execution of the features of its EIS through the JCA. The Resource Adapter, is packaged in a <code class="literal">.rar</code> archive called <code class="literal">Resource Adapter Module</code>, and it must obey some contracts (system level contracts) in order to be integrated into a Java EE platform and take advantage of services such as Connection, Transaction, and Security Management.</li></ul></div><p>That said, you can consider using JCA when you want to access an EIS that offers a Resource Adapter.</p></div><div class="section" title="JCA in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>JCA in action</h2></div></div></div><p>Failing to take a concrete example <a id="id370" class="indexterm"/>that shows you how to access the list of employees managed by SAP with a connector (which would be very long), to allow you to understand the essential features), the following code shows you just an overview of the use of the JCA API. These include the general principle of the connection, the possibility of data manipulation, and disconnection.</p><p>For those who wish to go further, GlassFish offers a complete example of implementing a connector to access a mail server, and the tutorial available at <a class="ulink" href="http://www.ibm.com/developerworks/java/tutorials/j-jca/index.html">http://www.ibm.com/developerworks/java/tutorials/j-jca/index.html</a>, provides you additional information.</p><p>The following code is a overview of interactions with a resource adapter:</p><div class="informalexample"><pre class="programlisting">try {
  javax.naming.Context ic = new InitialContext();
  javax.resource.cci.ConnectionFactory cf =
  (ConnectionFactory)
  ic.lookup("java:comp/env/eis/ConnectionFactory");
  //Connection
  javax.resource.cci.Connection ctx = cf.getConnection();
  
  System.out.println("Information about the result set functionality " + "supported by the connected EIS : " +ctx.getResultSetInfo());
  
  System.out.println("Metadata about the connection : " + ctx.getMetaData());
  
  //Get object for accessing EIS functions
  javax.resource.cci.Interaction interaction =ctx.createInteraction();
  
  //Get record factory
  javax.resource.cci.RecordFactory rfact = cf.getRecordFactory();
  
  javax.resource.cci.IndexedRecord input =rfact.createIndexedRecord("&lt;recordName&gt;");
  javax.resource.cci.IndexedRecord output =rfact.createIndexedRecord("&lt;recordName&gt;");
  //Look up a preconfigured InteractionSpec
  javax.resource.cci.InteractionSpec interSp = ... ;
  interaction.execute(interSp, input, output);
  int index_of_element = ...;//index of element to return
  System.out.println("The result : "+output.get(index_of_element));
  //close
  interaction.close();
  ctx.close();
} catch (Exception ex) {
  ex.printStackTrace();
}</pre></div></div><div class="section" title="Latest improvements"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Latest improvements</h2></div></div></div><p>Talking about novelty, the Java EE <a id="id371" class="indexterm"/>Connector Architecture 1.7 was slightly improved. Indeed, in this specification, it is more a matter of clarification and requirements statements. That said, JCA 1.7 has introduced the following changes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It insists on the availability of the the application component environment namespace of <a id="id372" class="indexterm"/>the <a id="id373" class="indexterm"/>endpoint to the <a id="id374" class="indexterm"/>resource adapter when the <code class="literal">endpointActivation</code> and <a id="id375" class="indexterm"/><code class="literal">endpointDeactivation</code> methods are called</li><li class="listitem" style="list-style-type: disc">It adds <code class="literal">ConnectionFactoryDefinition</code> and <code class="literal">AdministeredObjectDefinition</code> annotations for defining and configuring the resource adapter's resources</li><li class="listitem" style="list-style-type: disc">It clarifies the behavior of the dependency injection when Managed JavaBeans are used as CDI-<a id="id376" class="indexterm"/>managed Beans</li></ul></div></div></div>
<div class="section" title="Java Message Service (JMS)"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Java Message Service (JMS)</h1></div></div></div><p>The Java Message Service 2.0 <a id="id377" class="indexterm"/>Specification was developed under JSR 343. This section just gives you an overview of improvements in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr343/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr343/index.html</a>.</p><div class="section" title="When to use JMS"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>When to use JMS</h2></div></div></div><p>JMS is a Java API for interacting <a id="id378" class="indexterm"/>with <span class="strong"><strong>Message Oriented Middleware</strong></span> (<span class="strong"><strong>MOM</strong></span>). <a id="id379" class="indexterm"/>This type of middleware is born from the need to solve observed limits in synchronous connections. This is because synchronous connections are susceptible to network failures and require that the connected systems are available at the same time. Hence, the MOMs offer an integration system based on the exchange of messages that can be treated synchronously or asynchronously depending on the availability of the integrated systems.</p><p>The following image shows an architecture in which systems communicate through MOM:</p><div class="mediaobject"><img src="graphics/9235OT_06_01.jpg" alt="When to use JMS"/></div><p>Based on the foregoing, we conclude that JMS can be used in the following cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Transaction processing large amount of data (for example, synchronization of databases) through an unstable network</li><li class="listitem" style="list-style-type: disc">Communication between systems <a id="id380" class="indexterm"/>that are not always available simultaneously</li><li class="listitem" style="list-style-type: disc">Sending of data to multiple systems</li><li class="listitem" style="list-style-type: disc">Asynchronous processing</li></ul></div><p>To finish with this point, you should notice that the establishment of an integration system based on JMS requires that all components that need to be integrated be under your control. Hence, JMS would be better for the integration of internal solutions of a company.</p></div><div class="section" title="The latest improvements in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>The latest improvements in action</h2></div></div></div><p>Released in March 2002, the <a id="id381" class="indexterm"/>JMS 1.1 Specification was getting old and heavy compared to other APIs of the Java EE platform that have been simplified through the evolution of the platform. Based on this observation, you will understand why one of the main goals of JMS 2.0 API was to update the API so that it can be as simple as the other APIs of the platform and can integrate easily with them. To make this possible, several areas have been reviewed; these include the reduction of <span class="strong"><strong>boilerplate</strong></span> code, removing redundant items, adding <a id="id382" class="indexterm"/>new features, and integration of the novelties of the Java language.</p><div class="section" title="New features"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec42"/>New features</h3></div></div></div><p>In the JMS 2.0 Specification, three <a id="id383" class="indexterm"/>new features are highlighted: sending of messages asynchronously, delivery delay, and modification of the <code class="literal">JMSXDeliveryCount</code> message property.</p><div class="section" title="Sending messages asynchronously"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec21"/>Sending messages asynchronously</h4></div></div></div><p>In synchronous processing, if <a id="id384" class="indexterm"/>a method A invokes a method B, method A will remain blocked until the method B has completed. This can induce a waste of time. To overcome this problem, JMS 2.0 provides a set of methods to send messages asynchronously without losing sight of the progress of the operation. The following code demonstrates how to send messages asynchronously. The method <code class="literal">setAsync()</code> <a id="id385" class="indexterm"/>takes a listener as a parameter, which allows you to be informed <a id="id386" class="indexterm"/>at the end of the process or when an exception is thrown. If the listener is not null, the message will be sent asynchronously (the process will be performed by another thread different from the caller's thread). Otherwise, the message will be sent synchronously.</p><div class="informalexample"><pre class="programlisting">public void sendMessageAsynchronously(ConnectionFactory cfactory,Queue destination){
  try(JMSContext context = cfactory.createContext();){
    context.createProducer().setAsync(new Completion()).send(destination, "Hello world");
  }
}

class Completion implements CompletionListener{

  public void onCompletion(Message message) {     
    System.out.println("message sent successfully");
  }

  public void onException(Message message, Exception ex) {   
    System.out.println(ex.getMessage());
  }
}</pre></div></div><div class="section" title="Delivery delay"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec22"/>Delivery delay</h4></div></div></div><p>In addition to the possibility of sending <a id="id387" class="indexterm"/>messages asynchronously, JMS now permits us to defer the time of delivery of a message already in the <span class="strong"><strong>broker</strong></span>, which is a MOM server. <a id="id388" class="indexterm"/>After sending, the message will be stored at the broker, but it will stay unknown to the receiver until the time fixed by the sender. The message of the following code will be <a id="id389" class="indexterm"/>delivered to the recipient at least one hour after sending.</p><div class="informalexample"><pre class="programlisting">public void sendMessageWithDelay(ConnectionFactory cfactory,Queue destination){
  try(JMSContext context = cfactory.createContext();){
    context.createProducer().setDeliveryDelay(1000*60*60).send(destination, "Hello world");
  }
}</pre></div></div><div class="section" title="Handling of the JMSXDeliveryCount message property"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec23"/>Handling of the JMSXDeliveryCount message property</h4></div></div></div><p>Since Version 1.1, the JMS Specification has defined an optional <code class="literal">JMSXDeliveryCount</code> message property, which can <a id="id390" class="indexterm"/>be used to determine the messages that were delivered more than once and apply an action when the number of deliveries exceeds <a id="id391" class="indexterm"/>the maximum value. But, because the management of this property was optional, all providers had no obligation to increment it, which had the effect of making applications that used it non portable. The JMS 2.0 Specification has introduced this as standard, to allow us to customize the <a id="id392" class="indexterm"/>management of <span class="strong"><strong>poisonous messages</strong></span> in a portable way. A poisonous message is a JMS message that has exceeded the maximum number of deliveries for a given receiver. The following code shows how to retrieve the <code class="literal">JMSXDeliveryCount</code> message property and specify the action to be taken when one message has been delivered more that five time:</p><div class="informalexample"><pre class="programlisting">public class JmsMessageListener implements MessageListener {
  
  @Override
  public void onMessage(Message message) {
    try {
      int jmsxDeliveryCount =message.getIntProperty("JMSXDeliveryCount");
      //...
      if(jmsxDeliveryCount &gt; 5){
        // do something
      }
    } catch (JMSException ex) {
      ex.printStackTrace();
    }
  }
}</pre></div></div><div class="section" title="Simplification of the API"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec24"/>Simplification of the API</h4></div></div></div><p>The JMS 2.0 Specification introduces <a id="id393" class="indexterm"/>three new interfaces (<code class="literal">JMSContext</code>, <code class="literal">JMSProducer</code>, and <a id="id394" class="indexterm"/>
<code class="literal">JMSConsumer</code>) which contribute to the elimination of boilerplate code and simplifying the API. It is important to note that these interfaces (which constitute the simplified API) co-exist with the old interfaces to provide an alternative. So <a id="id395" class="indexterm"/>
<code class="literal">JMSContext</code> replaces the <code class="literal">Connection</code> and <code class="literal">Session</code> objects, <code class="literal">JMSProducer</code> replaces the <a id="id396" class="indexterm"/>
<code class="literal">MessageProducer</code> object, and <code class="literal">JMSConsumer</code> replaces the <code class="literal">MessageConsumer</code> object in the old version. As <a id="id397" class="indexterm"/>you can see in the following code, the difference between the two approaches is very clear. In the sending method based on JMS API 1.1 (<code class="literal">sendMessageJMSWithOldAPI</code>), we note: an excessive object creation, a mandatory throw of an exception, and a need to explicitly close connections.</p><p>Whereas, in the sending method based on JMS API 2.0 (<code class="literal">sendMessageJMSWithNewdAPI</code>), we have: the try-with-resources statement that saves the <a id="id398" class="indexterm"/>developer from having to explicitly close the connection and a send code reduced to the essentials that would fit on one line if we had injected <code class="literal">JMSContext</code> object.</p><div class="informalexample"><pre class="programlisting">//Sending message with JMS 1.1
public void sendMessageJMSWithOldAPI(ConnectionFactory connectionFactory, Queue destination) throws JMSException {
 Connection connection = connectionFactory.createConnection();
 try {
     Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
     MessageProducer messageProducer = session.createProducer(destination);
     TextMessage textMessage = session.createTextMessage("Message send with the old API");
     messageProducer.send(textMessage);
  } finally {
    connection.close();
  }
}

//Sending message with JMS 2.0
public void sendMessageJMSWithNewdAPI(ConnectionFactory connectionFactory, Queue destination) {
     try (JMSContext context = connectionFactory.createContext();) {
        context.createProducer().send(destination, "Message send with the new API");
   }
}</pre></div></div></div></div></div>
<div class="section" title="Java API for RESTful Web Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Java API for RESTful Web Services</h1></div></div></div><p>The Java API for RESTful Web <a id="id399" class="indexterm"/>Services 2.0 Specification was developed <a id="id400" class="indexterm"/>under JSR 339. This section just gives you an overview of improvements in the API. The complete document specification (for more information) <a id="id401" class="indexterm"/>can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr339/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr339/index.html</a>.</p><div class="section" title="When to use Web Services"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>When to use Web Services</h2></div></div></div><p>A Web Service is a software system based <a id="id402" class="indexterm"/>on open standards (such as HTTP, XML, and URI) and designed to allow exchanges between applications across the network. By using these open standards, it has everything required to be the most suitable solution for integrating heterogeneous systems. However, as we saw when we were talking about JMS, the choice of an integration solution should be made after a series of questions: Is the network connection good? Are the processes transactional? Is the amount of data to be processed huge? Must processing be synchronous? and so on.</p><p>If after investigation, your choice is Web Services, you must now select the type of web service to implement : the <span class="strong"><strong>SOAP</strong></span> Web Services based on SOAP (<span class="strong"><strong>Simple Object Access Protocol</strong></span>) and <a id="id403" class="indexterm"/>XML, or RESTful Web Services that are focused on resource sharing and thus their functioning is modeled on the Web. In this book, we will only discuss RESTful Web Services.</p></div><div class="section" title="JAX-RS in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>JAX-RS in action</h2></div></div></div><p>RESTful Web Services are a variant of <a id="id404" class="indexterm"/>Web Services in which any concepts that can be addressed (functionality or data) are considered as resources and therefore can be accessed through <a id="id405" class="indexterm"/>
<span class="strong"><strong>Uniform Resource Identifiers</strong></span> (<span class="strong"><strong>URI</strong></span>s). Once located, the representation or state of the resource is transferred in the form of an XML or a JSON document. In the case of our online preregistration application, the resources may be the list of selected students and the representation will be in a JSON document.</p><p>JAX-RS is the Java API to implement RESTful Web Services. The following code demonstrates how to write a REST service that returns a list of all students who were selected:</p><div class="informalexample"><pre class="programlisting">@Path("students")
@Stateless
@Produces({MediaType.APPLICATION_JSON})
public class StudentInformation {
  
  @PersistenceContext(unitName = "integrationPU")
  private EntityManager em;
  
  @GET
  @Path("getListOfStudents")
  public List&lt;Student&gt; getListOfStudents(){
    TypedQuery&lt;Student&gt; query = em.createQuery("SELECT s FROM Student s", Student.class);
    return query.getResultList();
  }
} }</pre></div></div><div class="section" title="The latest improvements in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>The latest improvements in action</h2></div></div></div><p>JAX-RS 2.0 not only <a id="id406" class="indexterm"/>simplified the implementation of RESTful Web Services, but also introduced new features in the API, among which we have client API, asynchronous processing, filters, and interceptors.</p><div class="section" title="The Client API"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec43"/>The Client API</h3></div></div></div><p>Since Version 1.0, the JAX-RS <a id="id407" class="indexterm"/>Specification did not define client APIs to interact with a RESTful service. So, each implementation provided a proprietary API, which had the effect of limiting the portability of applications. JAX-RS 2.0 fills this gap by providing a standard client API.</p><p>The following code demonstrates the implementation of a client that will access the list of selected students through the REST service exposed in the preceding code:</p><div class="informalexample"><pre class="programlisting">String baseURI ="http://localhost:8080/chapter06EISintegration-web";
Client client = ClientBuilder.newClient();
WebTarget target = client.target(baseURI+"/rs-resources/students/getListOfStudents");      
GenericType&lt;List&lt;Student&gt;&gt; list = new GenericType&lt;List&lt;Student&gt;&gt;() {};
List&lt;Student&gt; students =target.request(MediaType.APPLICATION_JSON).get(list);</pre></div></div><div class="section" title="Asynchronous processing"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec44"/>Asynchronous processing</h3></div></div></div><p>In addition to the standardization of the <a id="id408" class="indexterm"/>client API, JAX-RS 2.0 has integrated a feature already present in many of the APIs of the Java EE platform, which is <a id="id409" class="indexterm"/>asynchronous processing. It is now possible for a JAX-RS client to send requests or process responses asynchronously.</p><p>The following code demonstrates how a JAX-RS client can perform a get request asynchronously and wait for the response passively. As shown in the code, the execution of a JAX-RS request asynchronously requires a call to the <a id="id410" class="indexterm"/>
<code class="literal">async()</code> method. This method returns an object of type <a id="id411" class="indexterm"/>
<code class="literal">AsyncInvoker</code> whose get, post, delete, and put methods allow us to obtain the object type <code class="literal">Future</code> that will be used for further processing of the response.</p><p>The following code is an example of the execution of a asynchronous process in a JAX-RS client:</p><div class="informalexample"><pre class="programlisting">public class AppAsynchronousRestfulClient {

  public static void main(String[] args) {    
  String baseURI ="http://localhost:8080/chapter06EISintegration-web";
  String location = "/rs-resources";
  String method = "/students/getListOfAllStudentsAs";
  Client client = ClientBuilder.newClient();
  WebTarget target =
    (WebTarget) client.target(baseURI+location+method);
  System.out.println("Before response : "+new Date());
  Future&lt;String&gt; response = target.request(MediaType.APPLICATION_JSON).async().get(String.class);            
  
  new PassiveWaiting(response).start();   
  
  System.out.println("After PassiveWaiting : "+new Date());
  }
  
  static class PassiveWaiting extends Thread {
    Future&lt;String&gt; response;
    
    public PassiveWaiting(Future&lt;String&gt; response){
      this.response = response;
    }
    
    public void run(){
      try{
        System.out.println("response :"+response.get()+", time : "+new Date());
      }catch(Exception ex){
        ex.printStackTrace();
      }
    }
  }
}</pre></div><p>To ensure that the processing is executed asynchronously, we have defined a break of 20 seconds in the <a id="id412" class="indexterm"/>
<code class="literal">getListOfAllStudentsAs</code> method before executing the JPQL queries. The following code,which is a simulation of a slow processing, shows the contents of the method executed by the client:</p><div class="informalexample"><pre class="programlisting">@GET
@Path("getListOfAllStudentsAs")
public List&lt;Student&gt; getListOfAllStudentsAs() {
  try{
    Thread.sleep(20*1000);//20 seconds
  }catch(Exception ex){}
  TypedQuery&lt;Student&gt; query = em.createQuery("SELECT s FROM Student s", Student.class);
  return query.getResultList();
}</pre></div><p>Similarly, the JAX-RS servers are able to run processes asynchronously. The method that contains the instructions to perform the task asynchronously must inject an object of type <code class="literal">AsyncResponse</code> as a method parameter with the <code class="literal">@Suspended</code> annotation. However, you should know that the asynchronous mode of the server differs from the asynchronous mode of the client; the former consists of suspending the client connection from which the request was send during the processing of the request before resuming it later through the <code class="literal">resume()</code> method <a id="id413" class="indexterm"/>of the object <code class="literal">AsyncResponse</code>. The method itself will not run asynchronously. To make it asynchronous, you must either delegate the process to a thread (that is what we <a id="id414" class="indexterm"/>did in the <code class="literal">getListOfAllStudentsAs2</code> <a id="id415" class="indexterm"/>method of the following example), or decorate it with the <code class="literal">@Asynchronous</code> annotation. The following code demonstrates how to perform asynchronous processing at the server side.</p><p>The following code is an example of the execution of a process asynchronously in a JAX-RS server:</p><div class="informalexample"><pre class="programlisting">@Path("students")
@Stateless
@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
public class StudentInformation {

  @PersistenceContext(unitName = "integrationPU")
  private EntityManager em;
  
  @Resource(lookup ="java:comp/DefaultManagedScheduledExecutorService")
  ManagedExecutorService taskExecutor;

  @GET
  @Path("getListOfAllStudentsAs2")
  public void getListOfAllStudentsAs2(final @Suspended AsyncResponse response) {
      System.out.println("before time : "+new Date());
      taskExecutor.submit(
      new Runnable() {
        public void run() {
          String queryString = "SELECT s FROM Student sWHERE 1 = 1";
          TypedQuery&lt;Student&gt; query = em.createQuery(queryString, Student.class);

          List&lt;Student&gt; studentList = query.getResultList();
          try {
            Thread.sleep(10 * 1000);//1 second
          } catch (Exception ex) {
          }
          response.resume(studentList);
        }
      });
    System.out.println("After time : "+new Date());
  }
}</pre></div></div><div class="section" title="Filters and entity interceptors"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec45"/>Filters and entity interceptors</h3></div></div></div><p>Another big ticket of the JAX-RS 2.0 Specification is the introduction of two mechanisms for interception: filters and interceptors. These new features bring to the specification a standard way to intercept processing in order to seamlessly manage security, compression, encoding, logging, editing, and auditing of exchanges between a JAX-RS server and the different clients that will access the server resources.</p><p>Although the two concepts are very similar (as they all relate to interception), we must say that the filter is often used for the processing of the headers of requests or responses. Whereas, interceptors are generally set up to manipulate the content of messages.</p><div class="section" title="Filters"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec25"/>Filters</h4></div></div></div><p>The JAX-RS 2.0 specification <a id="id416" class="indexterm"/>defines four types of filters: two types of filters on each side (client and server). On the client side, one filter that must be run before sending the HTTP request implements the <code class="literal">ClientRequestFilter</code> interface and the other filter, which must be run immediately after the receipt of the response from the server, (but before the control is rendered to the application) implements the <code class="literal">ClientResponseFilter</code> <a id="id417" class="indexterm"/>interface. On the server side, the filter that will be executed before the access to a JAX-RS resource implements the <code class="literal">ContainerRequestFilter</code> interface and the filter that will run just before the response is sent to the client <a id="id418" class="indexterm"/>implements the <code class="literal">ContainerResponseFilter</code> interface. The following code shows an example of <code class="literal">ContainerRequestFilter</code> implementation that verifies the information that ensures a secure access to the resources available to external users of our online preregistration application. The <code class="literal">@Provider</code> <a id="id419" class="indexterm"/>annotation on top of the <code class="literal">MyJaxRsRequestFilter</code> class in the following code allows the filter to be automatically discovered by the container and applied to all resources of the server. Failing to use this annotation, you must manually registered the filter.</p><p>The following code is an example of <code class="literal">ContainerRequestFilter</code> implementation:</p><div class="informalexample"><pre class="programlisting">@Provider
public class MyJaxRsRequestFilter implements ContainerRequestFilter {

  @Override
  public void filter(ContainerRequestContext crq) {
    //        If the user has not been authenticated
    if(crq.getSecurityContext().getUserPrincipal() == null)
      throw new WebApplicationException(Status.UNAUTHORIZED);

      List&lt;MediaType&gt; supportedMedia =crq.getAcceptableMediaTypes();
    if("GET".equals(crq.getMethod()) &amp;&amp;!supportedMedia.contains(MediaType.APPLICATION_JSON_TYPE))
      throw new WebApplicationException(Status.UNSUPPORTED_MEDIA_TYPE);
      
      //      external users must only access student methods
      String path = crq.getUriInfo().getPath();
    if(!path.startsWith("/students"))
      throw new WebApplicationException(Status.FORBIDDEN);
      
      List&lt;String&gt; encoding = crq.getHeaders().get("accept-encoding");  
      //   If the client does not support the gzip compression
    if(!encoding.toString().contains("gzip"))
      throw new WebApplicationException(Status.EXPECTATION_FAILED);            
  }
}</pre></div></div><div class="section" title="Entity interceptors"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec26"/>Entity interceptors</h4></div></div></div><p>In addition to the differences noted <a id="id420" class="indexterm"/>between filters and entity interceptors, JAX-RS provides two types of entity interceptors instead of four. There is a reader interceptor that implements the <a id="id421" class="indexterm"/>
<code class="literal">ReaderInterceptor</code> interface and a writer interceptor, which implements the <code class="literal">WriterInterceptor</code> <a id="id422" class="indexterm"/>interface. Due to the elements that they are supposed to handle (message bodies), interceptors can be used to compress large content to optimize network utilization; they can also be used for some processing such as the generation and verification of digital signatures.</p><p>Given that the database of our online preregistration application will contain thousands of students, the following code demonstrates how we can take advantage of interceptors in the data exchange with the Ministry of Education in order to avoid network overloading when transmitting information about students.</p><p>The following code shows the implementation of <code class="literal">WriterInterceptor</code> (on the server side) that will compress data to send to the JAX-RS client. The <code class="literal">@ZipResult</code> annotation allows us to bind the interceptor only to some JAX-RS resources. If we remove this annotation, all JAX-RS resources of our application will be automatically compressed.</p><p>The following code is an example of a <a id="id423" class="indexterm"/>
<code class="literal">WriterInterceptor</code> implemention:</p><div class="informalexample"><pre class="programlisting">@ZipResult
@Provider
public class MyGzipWriterJaxRsInterceptor implements WriterInterceptor{  
    
    @Override
    public void aroundWriteTo(WriterInterceptorContext wic) throws IOException {        
        try (GZIPOutputStream gzipStream = new GZIPOutputStream(wic.getOutputStream());) {
            wic.setOutputStream(gzipStream);   
            wic.proceed();
        }        
    }
}</pre></div><p>To bind the <a id="id424" class="indexterm"/>
<code class="literal">MyGzipWriterJaxRsInterceptor</code> interceptor to a resource, we will only decorate the given resource with the <a id="id425" class="indexterm"/>
<code class="literal">@ZipResult</code> annotation. The following code demonstrates how to bind <code class="literal">MyGzipWriterJaxRsInterceptor</code> interceptor to a resource so that its representation can be always <a id="id426" class="indexterm"/>compressed before being sent to the client.</p><p>The following code is an example of of interceptor binding:</p><div class="informalexample"><pre class="programlisting">@GET
@ZipResult
@Path("getListOfAllStudentsGzip")
public List&lt;Student&gt; getListOfAllStudentsGzip() {        
  TypedQuery&lt;Student&gt; query = em.createQuery("SELECT s FROM Student s", Student.class);       
  return query.getResultList();
}</pre></div><p>The following code is an example of the declaration of <code class="literal">@ZipResult</code> annotation:</p><div class="informalexample"><pre class="programlisting">@NameBinding
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(value = RetentionPolicy.RUNTIME)
public @interface ZipResult {}</pre></div><p>The following code shows the implementation of the <code class="literal">ReaderInterceptor</code> interface (on the client side) that will <a id="id427" class="indexterm"/>decompress the data compressed by the server with the <code class="literal">MyGzipWriterJaxRsInterceptor</code> class:.</p><div class="informalexample"><pre class="programlisting">public class MyGzipReaderJaxRsInterceptor implements ReaderInterceptor {
    @Override
    public Object aroundReadFrom(ReaderInterceptorContext context) throws IOException {           
        try (InputStream inputStream = context.getInputStream();) {
            context.setInputStream(new GZIPInputStream(inputStream));
            return context.proceed();            
        }       
    }    
}</pre></div><p>To bind the interceptor to a particular client, we will use the <code class="literal">register</code> method of the <code class="literal">Client</code> object. The following code demonstrates how to associate an interceptor or a filter to a JAX-RS Client:</p><div class="informalexample"><pre class="programlisting">public static void main(String[] args) throws IOException {
  String baseURI = "http://localhost:8080/chapter06EISintegration-web";
  String location = "/rs-resources";
  String method = "/students/getListOfAllStudentsGzip";
  //client creation and registration of the interceptor/filter
  Client client = ClientBuilder.newClient().register(MyGzipReaderJaxRsInterceptor.class);
  WebTarget target = (WebTarget)client.target(baseURI + location + method);
  System.out.println("response : " + target.request(MediaType.APPLICATION_JSON).get(String.class));        
}</pre></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Summary</h1></div></div></div><p>During the analysis of the online preregistration application presented in the previous chapter, we realized that our system should communicate with other systems. This chapter has given us the knowledge to identify and implement the best way to exchange data with different kinds of heterogeneous systems. In the next chapter, we will revisit some concepts that we have used in a natural way so that you have a better understanding of them.</p></div></body></html>