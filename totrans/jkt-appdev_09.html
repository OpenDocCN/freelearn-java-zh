<html><head></head><body>
<div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-120"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-121"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.2.1">WebSockets</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Traditionally, web applications have been developed using the request/response model followed by HTTP. </span><span class="koboSpan" id="kobo.3.2">In this traditional request/response model, the request is always initiated by the client, then the server sends a response back to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">There has never been any way for the server to send data to the client independently, that is, without having to wait for a request, until now. </span><span class="koboSpan" id="kobo.5.2">The WebSocket protocol allows full-duplex, two-way communication between the client (browser) and </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">The Jakarta API for WebSocket allows us to develop WebSocket endpoints </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">in Java.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Developing WebSocket </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">server endpoints</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Developing WebSocket clients </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">in JavaScript</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Developing WebSocket clients </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">in Java</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.17.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.18.1">The source code for this chapter can be found on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">at </span></span><a href="https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch09_src"><span class="No-Break"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch09_src</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.21.1">.</span></span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.22.1">Developing WebSocket server endpoints</span></h1>
<p><span class="koboSpan" id="kobo.23.1">There are two ways we can</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.24.1"> implement a WebSocket server endpoint via the Jakarta API for WebSocket: we can either develop an endpoint programmatically, in which case we need to extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">jakarta.websocket.Endpoint</span></strong><span class="koboSpan" id="kobo.26.1"> class, or we can</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.27.1"> annotate </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">Plain Old Java Objects</span></strong><span class="koboSpan" id="kobo.29.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.30.1">POJOs</span></strong><span class="koboSpan" id="kobo.31.1">) with WebSocket-specific annotations. </span><span class="koboSpan" id="kobo.31.2">These two approaches are very similar, therefore we will be discussing in detail only the annotation approach, and will briefly explain how to develop WebSocket server endpoints programmatically later in </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">the chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">In this chapter, we will develop a simple web-based chat application that takes full advantage of the Jakarta API </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">for WebSocket.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.35.1">Developing an annotated WebSocket server endpoint</span></h2>
<p><span class="koboSpan" id="kobo.36.1">The following Java class illustrates</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.37.1"> how we can develop a WebSocket server endpoint by annotating a </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Java class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.39.1">
package com.ensode.jakartaeebook.websocketchat.serverendpoint;
//imports omitted
</span><strong class="bold"><span class="koboSpan" id="kobo.40.1">@ServerEndpoint("/websocketchat")</span></strong><span class="koboSpan" id="kobo.41.1">
public class WebSocketChatEndpoint {
  private static final Logger LOG =
    Logger.getLogger(WebSocketChatEndpoint.class.getName());
  </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">@OnOpen</span></strong><span class="koboSpan" id="kobo.43.1">
  public void connectionOpened() {
    LOG.log(Level.INFO, "connection opened");
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">@OnMessage</span></strong><span class="koboSpan" id="kobo.45.1">
  public synchronized void processMessage(Session session,
    String message) {
    LOG.log(Level.INFO, "received message: {0}", message);
    </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">session.getOpenSessions()</span></strong><span class="koboSpan" id="kobo.47.1">.forEach(sess -&gt; {
      if (</span><strong class="bold"><span class="koboSpan" id="kobo.48.1">sess.isOpen()</span></strong><span class="koboSpan" id="kobo.49.1">) {
        try {
          </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">sess.getBasicRemote().sendText(message);</span></strong><span class="koboSpan" id="kobo.51.1">
        } catch (IOException ex) {
          LOG.log(Level.SEVERE, ex.getMessage(), ex);
        }
      }
    });
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">@OnClose</span></strong><span class="koboSpan" id="kobo.53.1">
  public void connectionClosed() {
    LOG.log(Level.INFO, "connection closed");
  }
}</span></pre> <p><span class="koboSpan" id="kobo.54.1">The class-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">@ServerEndpoint</span></strong><span class="koboSpan" id="kobo.56.1"> annotation indicates that the class is a WebSocket server endpoint. </span><span class="koboSpan" id="kobo.56.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">URI</span></strong><span class="koboSpan" id="kobo.58.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Uniform Resource Identifier</span></strong><span class="koboSpan" id="kobo.60.1">) of the server endpoint is the value specified between the </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.61.1">parenthesis following the annotation (</span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">"/websocketchat"</span></strong><span class="koboSpan" id="kobo.63.1">, in this example). </span><span class="koboSpan" id="kobo.63.2">WebSocket clients will use</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.64.1"> this URI to communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">our endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">@OnOpen</span></strong><span class="koboSpan" id="kobo.68.1"> annotation is used to indicate a method that needs to be executed whenever a WebSocket connection is opened from any of the clients. </span><span class="koboSpan" id="kobo.68.2">In our example, we are simply sending some output to the server log, but of course, any valid server-side Java code can be </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">placed here.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Any method annotated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">@OnMessage</span></strong><span class="koboSpan" id="kobo.72.1"> annotation will be invoked whenever our server endpoint receives a message from any of the clients. </span><span class="koboSpan" id="kobo.72.2">Since we are developing a chat application, our code simply broadcasts the message it receives to all </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">connected clients.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">In our example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">processMessage()</span></strong><span class="koboSpan" id="kobo.76.1"> method is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">@OnMessage</span></strong><span class="koboSpan" id="kobo.78.1">, and it takes two parameters, an instance of a class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">jakarta.websocket.Session</span></strong><span class="koboSpan" id="kobo.80.1"> interface, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">String</span></strong><span class="koboSpan" id="kobo.82.1"> containing the message that was received. </span><span class="koboSpan" id="kobo.82.2">Since we are developing a chat application, our WebSocket server endpoint simply broadcasts the received message to all </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">connected clients.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">getOpenSessions()</span></strong><span class="koboSpan" id="kobo.86.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">Session</span></strong><span class="koboSpan" id="kobo.88.1"> interface returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">Set</span></strong><span class="koboSpan" id="kobo.90.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">Session</span></strong><span class="koboSpan" id="kobo.92.1"> objects representing all open sessions, we iterate through this set to broadcast the received message back to all connected clients by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">getBasicRemote()</span></strong><span class="koboSpan" id="kobo.94.1"> method on each </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">Session</span></strong><span class="koboSpan" id="kobo.96.1"> instance, then invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">sendText()</span></strong><span class="koboSpan" id="kobo.98.1"> method on the resulting </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">RemoteEndpoint.Basic</span></strong><span class="koboSpan" id="kobo.100.1"> implementation returned by </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">this call.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">getOpenSessions()</span></strong><span class="koboSpan" id="kobo.104.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">Session</span></strong><span class="koboSpan" id="kobo.106.1"> interface returns all the open sessions at the time the method was invoked. </span><span class="koboSpan" id="kobo.106.2">It is possible for one or more of the sessions to have closed after the method was invoked, so it is recommended to invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">isOpen()</span></strong><span class="koboSpan" id="kobo.108.1"> method on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Session</span></strong><span class="koboSpan" id="kobo.110.1"> implementation before attempting to send data back to </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">Finally, we need to annotate a method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">@OnClose</span></strong><span class="koboSpan" id="kobo.114.1"> annotation to handle the event when a client disconnects from </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.115.1">the server endpoint. </span><span class="koboSpan" id="kobo.115.2">In our example, we simply log a message to the </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">server log.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">There is one additional annotation we didn’t use in our example. </span><span class="koboSpan" id="kobo.117.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">@OnError</span></strong><span class="koboSpan" id="kobo.119.1"> annotation is used to indicate a method that needs to be invoked in case of an error when sending or receiving data to or from </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">As we can see, developing an annotated WebSocket server endpoint is straightforward. </span><span class="koboSpan" id="kobo.121.2">We simply need to add a few annotations and the application server will invoke our annotated methods </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">as necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">If we wish to develop a WebSocket server endpoint programmatically, we need to write a Java class that extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">jakarta.websocket.Endpoint</span></strong><span class="koboSpan" id="kobo.125.1">. </span><span class="koboSpan" id="kobo.125.2">This class has </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">onOpen()</span></strong><span class="koboSpan" id="kobo.127.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">onClose()</span></strong><span class="koboSpan" id="kobo.129.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">onError()</span></strong><span class="koboSpan" id="kobo.131.1"> methods that are called at the appropriate times during the endpoint’s lifecycle. </span><span class="koboSpan" id="kobo.131.2">There is no method equivalent to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">@OnMessage</span></strong><span class="koboSpan" id="kobo.133.1"> annotation – to handle incoming messages from the clients, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">addMessageHandler()</span></strong><span class="koboSpan" id="kobo.135.1"> method needs to be invoked in the session, passing an instance of a class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">jakarta.websocket.MessageHandler</span></strong><span class="koboSpan" id="kobo.137.1"> interface (or one of its subinterfaces) as its </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">sole parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">In general, it is more straightforward to develop annotated WebSocket endpoints as opposed to their programmatic counterparts. </span><span class="koboSpan" id="kobo.139.2">Therefore, we recommend the annotated approach </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">whenever possible.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">Now that we have seen how to develop WebSocket endpoints, we will focus our attention on developing </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">WebSocket clients.</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.143.1">Developing WebSocket clientsin JavaScript</span></h1>
<p><span class="koboSpan" id="kobo.144.1">Most WebSocket clients are</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.145.1"> implemented as web pages taking advantage of the JavaScript WebSocket API. </span><span class="koboSpan" id="kobo.145.2">We will cover how to do this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">The Jakarta API for WebSocket provides a client API that allows us to develop WebSocket clients as standalone Java applications. </span><span class="koboSpan" id="kobo.147.2">We will be covering this capability later in </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">the chapter.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.149.1">Developing JavaScript client-side WebSocket code</span></h2>
<p><span class="koboSpan" id="kobo.150.1">In this section, we will </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.151.1">cover how to develop client-side JavaScript code to interact with the WebSocket endpoint we developed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">previous section.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">The client page for our WebSocket example is implemented as a JSF page using HTML5-friendly markup (as explained in </span><a href="B21231_07.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.154.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.155.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">As illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.157.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.158.1">.1</span></em><span class="koboSpan" id="kobo.159.1">, our client page consists of a text area where we can see what the users of our application are saying (it is, after all, a chat application), and a text-input box that we can use to send messages to </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">other users.</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.161.1"><img alt="Figure 9.1 – Javascript WebSocket client" src="image/B21231_9_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.162.1">Figure 9.1 – Javascript WebSocket client</span></p>
<p><span class="koboSpan" id="kobo.163.1">The JavaScript code for our client page looks </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
&lt;script type="text/javascript"&gt;
  var websocket;
  function init() {
    </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">websocket = new WebSocket(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.167.1">     'ws://localhost:8080/websocketchat/websocketchat');</span></strong><span class="koboSpan" id="kobo.168.1">
     </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">websocket.onopen = function (event) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.170.1">      websocketOpen(event)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.171.1">    };</span></strong><span class="koboSpan" id="kobo.172.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">websocket.onmessage = function (event) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.174.1">      websocketMessage(event)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.175.1">    };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.176.1">    websocket.onerror = function (event) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.177.1">      websocketError(event)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.178.1">    };</span></strong><span class="koboSpan" id="kobo.179.1">
   }
   function websocketOpen(event) {
    console.log("webSocketOpen invoked");
  }
  function websocketMessage(event) {
    console.log("websocketMessage invoked");
    document.getElementById('chatwindow').value += '\r' +
      event.data;
  }
  function websocketError(event) {
    console.log("websocketError invoked");
  }
  function sendMessage() {
    var userName = document.getElementById('userName').value;
    var msg = document.getElementById('chatinput').value;
     websocket.send(userName + ": " + msg);
  }
  function closeConnection() {
    websocket.close();
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">window.addEventListener("load", init, false);</span></strong><span class="koboSpan" id="kobo.181.1">
&lt;/script&gt;</span></pre> <p><span class="koboSpan" id="kobo.182.1">The last line of our JavaScript code (</span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">window.addEventListener("load", init);</span></strong><span class="koboSpan" id="kobo.184.1">) sets our JavaScript </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">init()</span></strong><span class="koboSpan" id="kobo.186.1"> function to get executed as soon as the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">page loads.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">init()</span></strong><span class="koboSpan" id="kobo.190.1"> function, we initialize a new JavaScript WebSocket object, passing the URI of our server endpoint as a parameter. </span><span class="koboSpan" id="kobo.190.2">This</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.191.1"> lets our JavaScript code know the location of our </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">server endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">The JavaScript WebSocket object has a number of function types used to handle different events such as opening the connection, receiving a message, and handling errors. </span><span class="koboSpan" id="kobo.193.2">We need to set these types to our own JavaScript functions so that we can handle these events, which is what we do in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">init()</span></strong><span class="koboSpan" id="kobo.195.1"> method right after invoking the constructor for the JavaScript WebSocket object. </span><span class="koboSpan" id="kobo.195.2">In our example, the functions we assigned to the WebSocket object simply delegate their functionality to stand-alone </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">JavaScript functions.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">websocketOpen()</span></strong><span class="koboSpan" id="kobo.199.1"> function is called whenever the WebSocket connection is opened. </span><span class="koboSpan" id="kobo.199.2">In our example, we simply send a message to the browser’s </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">JavaScript console.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">webSocketMessage()</span></strong><span class="koboSpan" id="kobo.203.1"> function is invoked whenever the browser receives a WebSocket message from our WebSocket endpoint. </span><span class="koboSpan" id="kobo.203.2">In our example, we update the contents of the text area that has the ID of the chat window with the contents of </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the message.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">websocketError()</span></strong><span class="koboSpan" id="kobo.207.1"> function is called whenever there is a WebSocket-related error. </span><span class="koboSpan" id="kobo.207.2">In our example, we simply send a message to the browser’s </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">JavaScript console.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">Our JavaScript </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">sendMessage()</span></strong><span class="koboSpan" id="kobo.211.1"> function sends a message to the WebSocket server endpoint containing both the username and the contents of the text input with the ID of </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">chatinput</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">This function is called when the user clicks on the button with the ID </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">sendBtn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">closeConnection()</span></strong><span class="koboSpan" id="kobo.219.1"> JavaScript function closes the connection to our WebSocket </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">server endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">As we can see from this example, writing client-side JavaScript code to interact with WebSocket endpoints is </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">fairly straightforward.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.223.1">Developing WebSocket clients in Java</span></h2>
<p><span class="koboSpan" id="kobo.224.1">Although developing web-based WebSocket clients is currently the most common way of developing WebSocket clients, the </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.225.1">Jakarta API for WebSocket provides a client API we can </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.226.1">use to develop WebSocket clients </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">in Java.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">In this section, we will be developing a simple graphical WebSocket client using the client API of the Jakarta API for WebSocket. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.229.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.230.1">.2</span></em><span class="koboSpan" id="kobo.231.1"> illustrates the GUI of our Java </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">WebSocket client.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.233.1"><img alt=" Figure 9.2 – WebSocket client developed in Java" src="image/B21231_9_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.234.1"> Figure 9.2 – WebSocket client developed in Java</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.235.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.236.1">We won’t be covering the GUI code, since it is not relevant to the discussion. </span><span class="koboSpan" id="kobo.236.2">The complete code for the example, including the GUI code, can be downloaded from the book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">Just as with WebSocket server endpoints, Java WebSocket clients can be developed either programmatically or by using annotations. </span><span class="koboSpan" id="kobo.238.2">Once again, we will cover only the annotation approach. </span><span class="koboSpan" id="kobo.238.3">Developing a programmatic client is very similar to the way programmatic server endpoints are developed, which is to say, programmatic clients must extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">jakarta.websocket.Endpoint</span></strong><span class="koboSpan" id="kobo.240.1"> and override the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">appropriate methods.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Without further ado, here is the code for our Java </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">WebSocket client:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.244.1">
package com.ensode.websocketjavaclient;
//imports omitted
</span><strong class="bold"><span class="koboSpan" id="kobo.245.1">@ClientEndpoint</span></strong><span class="koboSpan" id="kobo.246.1">
public class WebSocketClient {
  private static final Logger LOG =
    Logger.getLogger(WebSocketClient.class.getName());
  private String userName;
  private Session session;
  private final WebSocketJavaClientFrame webSocketJavaClientFrame;
  public WebSocketClient(WebSocketJavaClientFrame
    webSocketJavaClientFrame) {
    this.webSocketJavaClientFrame = webSocketJavaClientFrame;
    try {
      </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">WebSocketContainer webSocketContainer =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.248.1">     ContainerProvider.getWebSocketContainer();</span></strong><span class="koboSpan" id="kobo.249.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">webSocketContainer.connectToServer(this, new URI(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.251.1">     "ws://localhost:8080/websocketchat/websocketchat"));</span></strong><span class="koboSpan" id="kobo.252.1">
    } catch (DeploymentException | IOException | URISyntaxException ex) {
      ex.printStackTrace();
    }
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">@OnOpen</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.254.1">  public void onOpen(Session session) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.255.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.256.1"> this.session = session;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.257.1">  }</span></strong><span class="koboSpan" id="kobo.258.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.259.1">@OnClose</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.260.1">  public void onClose(CloseReason closeReason) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.261.1">    LOG.log(Level.INFO, String.format(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.262.1">      "Connection closed, reason: %s",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.263.1">      closeReason.getReasonPhrase()));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.264.1">  }</span></strong><span class="koboSpan" id="kobo.265.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">@OnError</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.267.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.268.1">public void onError(Throwable throwable) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.269.1">    throwable.printStackTrace();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.270.1">  }</span></strong><span class="koboSpan" id="kobo.271.1">
  @OnMessage
  public void onMessage(String message, Session session) {
    webSocketJavaClientFrame.getChatWindowTextArea().setText(
            webSocketJavaClientFrame.getChatWindowTextArea().getText()
            + ""
            + "\n" + message);
  }
  public void sendMessage(String message) {
    try {
      session.getBasicRemote().sendText(userName + ": " + message);
    } catch (IOException ex) {
      ex.printStackTrace();
    }
  }
  //setters and getters omitted
}</span></pre> <p><span class="koboSpan" id="kobo.272.1">The class-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">@ClientEndPoint</span></strong><span class="koboSpan" id="kobo.274.1"> annotation </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.275.1">denotes our class as a WebSocket client. </span><span class="koboSpan" id="kobo.275.2">All Java WebSocket clients must</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.276.1"> be annotated with </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">this annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">The code to establish a connection to the WebSocket server endpoint is in our class constructor. </span><span class="koboSpan" id="kobo.278.2">First, we need to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">ContainerProvider.getWebSocketContainer() </span></strong><span class="koboSpan" id="kobo.280.1">to obtain an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">jakarta.websocket.WebSocketContainer</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">We then establish the connection by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">connectToServer()</span></strong><span class="koboSpan" id="kobo.284.1"> method on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">WebSocketContainer</span></strong><span class="koboSpan" id="kobo.286.1"> instance, passing a class annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">@ClientEndpoint</span></strong><span class="koboSpan" id="kobo.288.1"> as the first parameter (in our example, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">this</span></strong><span class="koboSpan" id="kobo.290.1">, since the connection code is inside our WebSocket Java client code), and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">URI</span></strong><span class="koboSpan" id="kobo.292.1"> object containing the WebSocket server endpoint URI as the </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">second parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">After the connection is established, we are ready to respond to WebSocket events. </span><span class="koboSpan" id="kobo.294.2">Alert readers may have noticed that we are using the exact same annotations we used to develop our server endpoint again in our </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">client code.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Any method annotated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">@OnOpen</span></strong><span class="koboSpan" id="kobo.298.1"> annotation will be invoked automatically when the connection to the WebSocket server endpoint is established, the method must return void and can have an optional parameter of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">jakarta.websocket.Session</span></strong><span class="koboSpan" id="kobo.300.1">. </span><span class="koboSpan" id="kobo.300.2">In our example, we initialize a class variable with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">Session</span></strong><span class="koboSpan" id="kobo.302.1"> instance we received as </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">a parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">Methods annotated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">@OnClose</span></strong><span class="koboSpan" id="kobo.306.1"> annotation are invoked whenever the WebSocket session is closed. </span><span class="koboSpan" id="kobo.306.2">The annotated method can have optional parameters of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">jakarta.websocket.Session</span></strong><span class="koboSpan" id="kobo.308.1"> and type </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">CloseReason</span></strong><span class="koboSpan" id="kobo.310.1">. </span><span class="koboSpan" id="kobo.310.2">In our example, we chose to use only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">CloseReason</span></strong><span class="koboSpan" id="kobo.312.1"> optional parameter, since this class has a handy </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">getReasonPhrase()</span></strong><span class="koboSpan" id="kobo.314.1"> method that provides a short explanation of why the session </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">was closed.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">@OnError</span></strong><span class="koboSpan" id="kobo.318.1"> annotation is used to indicate that a method will be called when an error occurs. </span><span class="koboSpan" id="kobo.318.2">Methods annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">@OnError</span></strong><span class="koboSpan" id="kobo.320.1"> must have a parameter of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">java.lang.Throwable</span></strong><span class="koboSpan" id="kobo.322.1"> (the parent class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">java.lang.Exception</span></strong><span class="koboSpan" id="kobo.324.1">), and can have an optional parameter of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Session</span></strong><span class="koboSpan" id="kobo.326.1">. </span><span class="koboSpan" id="kobo.326.2">In our example, we simply send the stack trace of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Throwable</span></strong><span class="koboSpan" id="kobo.328.1"> parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">stderr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Methods annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">@OnMessage</span></strong><span class="koboSpan" id="kobo.334.1"> are invoked </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.335.1">whenever an incoming WebSocket message is received. </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">@OnMessage</span></strong><span class="koboSpan" id="kobo.337.1"> methods can have different parameters depending on the type of message received and how we </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.338.1">wish to handle it. </span><span class="koboSpan" id="kobo.338.2">In our example, we used the most common case, receiving a text message. </span><span class="koboSpan" id="kobo.338.3">In this particular case, we need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">String</span></strong><span class="koboSpan" id="kobo.340.1"> parameter that will hold the contents of the message, and an optional </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">Session</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.342.1"> parameter.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.343.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.344.1">Refer to the JavaDoc </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.345.1">documentation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">@OnMessage</span></strong><span class="koboSpan" id="kobo.347.1"> at </span><a href="https://jakarta.ee/specifications/platform/10/apidocs/jakarta/websocket/onmessage"><span class="koboSpan" id="kobo.348.1">https://jakarta.ee/specifications/platform/10/apidocs/jakarta/websocket/onmessage</span></a><span class="koboSpan" id="kobo.349.1"> for information on how to handle other types </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">of messages.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">In our example, we simply update the chat window text area, appending the received message to </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">its contents.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">To send a WebSocket message, we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">getBasicRemote()</span></strong><span class="koboSpan" id="kobo.355.1"> method on our Session instance, then invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">sendText()</span></strong><span class="koboSpan" id="kobo.357.1"> method on the resulting </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">RemoteEndpoint.Basic</span></strong><span class="koboSpan" id="kobo.359.1"> implementation returned by this call (if this looks familiar, it is because we did exactly the same thing in the WebSocket server endpoint code). </span><span class="koboSpan" id="kobo.359.2">In our example, we do this in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">sendMessage()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.361.1"> method.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.362.1">Additional information about the Jakarta API for WebSocket</span></p>
<p class="callout"><span class="koboSpan" id="kobo.363.1">In this chapter, we covered the bulk </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.364.1">of the functionality provided by the Jakarta API for WebSocket. </span><span class="koboSpan" id="kobo.364.2">For additional information, refer to the user guide for Tyrus, a popular open source Jakarta API for </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.365.1">WebSocket implementation, </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">at </span></span><a href="https://eclipse-ee4j.github.io/tyrus-project.github.io/documentation/latest/index/"><span class="No-Break"><span class="koboSpan" id="kobo.367.1">https://eclipse-ee4j.github.io/tyrus-project.github.io/documentation/latest/index/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.368.1">.</span></span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.369.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.370.1">In this chapter, we covered the Jakarta API for WebSocket, a Jakarta EE API for developing WebSocket server endpoints </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">and clients:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.372.1">We first saw how to develop WebSocket server endpoints by taking advantage of the Jakarta API </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">for WebSockets</span></span></li>
<li><span class="koboSpan" id="kobo.374.1">Then, we covered how to develop web-based WebSocket clients </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">using JavaScript</span></span></li>
<li><span class="koboSpan" id="kobo.376.1">Finally, we explained how to develop WebSocket client applications </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">in Java</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.378.1">WebSockets allow us to implement real-time, two-way communication between a web browser and a web server. </span><span class="koboSpan" id="kobo.378.2">As we saw in this chapter, the Jakarta EE WebSocket API takes care of the low-level details allowing us to develop WebSocket endpoints via a few </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">simple annotations.</span></span></p>
</div>
</body></html>