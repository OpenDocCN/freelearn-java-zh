<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Sending Messages to Multiple Taxi Drivers
                </header>
            
            <article>
                
<p><a href="377ec533-342d-4a08-9011-7176de197886.xhtml">Chapter 2</a>, <em>Creating a Taxi Application</em>, included information on how to connect to and consume messages from RabbitMQ. This chapter demonstrates setting the prefetch value, which specifies the number of messages being sent to the consumer at the same time. It also covers how consumers can either manually acknowledge messages or receive the messages without acknowledgment, the former allowing a zero-message loss design.</p>
<p>A new feature is requested of the<strong> Complete Car</strong> (<strong>CC</strong>) team, as the back office wants to be able to send information messages to all taxis at once. This is a prime opportunity to introduce the fanout exchange, which routes messages to all queues bound to them irrespective of the routing keys.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Working with channels and queues</li>
<li>Specifying a consumer prefetch count</li>
<li>Acknowledging messages</li>
<li>Publishing to all queues </li>
</ul>
<h1 id="uuid-406965bc-c0db-420a-9a5b-7262c87665c9"><span class="fontstyle0">Technical requirements</span></h1>
<p class="mce-root">The code files of this chapter can be found on GitHub at<span> <a href="https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter03">https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter03</a></span>.</p>
<h1 id="uuid-3cea0efd-29a5-4952-9120-aec9caf30a63">Working with channels and queues</h1>
<p>CC's drivers and customers are enjoying the <strong>request taxi</strong> feature that was rolled out in <a href="377ec533-342d-4a08-9011-7176de197886.xhtml"><em>Chapter 2</em></a>, <em>Creating a Taxi Application</em>. First, publishing messages to the direct exchange for customers ordering a single taxi was explained, and then instructions were given on implementing the topic exchange, which customers use when ordering a taxi with specific requirements. In both cases, the consumer is bound to the channel that was used to consume a particular queue. If this channel was closed, the consumer would stop receiving messages. Because a channel cannot be reopened and has to be recreated from scratch, both the channel and its consumption must be re-established if there are any problems.</p>
<p>Let's walk through some important points about consumers and queues in RabbitMQ:</p>
<ul>
<li>A queue can have multiple consumers (unless the exclusive tag is used).</li>
<li>Each channel can have multiple consumers.</li>
<li>Each consumer uses server resources, so it is best to make sure not to use too many consumers.</li>
<li>Channels are full-duplex, meaning that one channel can be used to both publish and consume messages.</li>
</ul>
<div class="packt_infobox"><br/>
There is no logical limit to the number of channels or consumers a RabbitMQ broker can handle. There are, however, limiting factors, such as available memory, broker CPU power, and network bandwidth.<br/>
<br/>
As each channel mobilizes memory and consumes CPU power, limiting the number of channels or consumers may be a consideration in some environments. The administrator can configure a maximum number of channels per connection by using the <kbd>channel_max</kbd> parameter.</div>
<p>It's now time to look into how to get as much out of the consumers as possible by setting a prefetch count.</p>
<h1 id="uuid-b42d9bb3-701b-4608-99df-6c5f3b09a29e">Specifying a consumer prefetch count</h1>
<p>The number of messages sent to the consumer at the same time can be specified through the <strong>prefetch</strong> count value. The prefetch count value is used to get as much out of the consumers as possible.</p>
<p>If the prefetch count is too small, it could negatively affect the performance of RabbitMQ, since the platform is usually waiting for permission to send more messages. The following diagram shows an example of a long idle time. The example has the prefetch set to one, meaning that RabbitMQ will not send the next message until after the delivery, processing, and acknowledgment of the message is complete.</p>
<p>In the example, the processing time is only 5 ms, with a round-trip time of 125 ms (60 ms + 60 ms + 5 ms):</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-648 image-border" src="assets/7252f49c-fb63-406f-a7aa-fec309ad89fe.png" style="width:42.67em;height:18.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 3.1: Round-trip time is 125 ms with a processing time of only 5 ms</div>
<p>A <span>large prefetch count makes RabbitMQ send many messages from one queue to one consumer. If all messages are sent to a single consumer, it may be overwhelmed and leave the other consumers idle. The following diagram shows the consumer as they receive lots of messages while the other consumer is idle:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-649 image-border" src="assets/5d7e7aa7-b7d4-4df2-a065-32ee302fd53d.png" style="width:39.67em;height:13.08em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Fig 3.2: Consumer in an idling state</div>
<p>In <a href="377ec533-342d-4a08-9011-7176de197886.xhtml"><em>Chapter 2</em></a>, <em>Creating a Taxi Application</em>, a connection, channel, and consumer were created in Ruby. The following code block shows how to configure a prefetch value in Ruby:</p>
<pre>require "bunny"<br/>connection = Bunny.new ENV["RABBITMQ_URI"]<br/><br/>connection.start<br/>channel = connection.create_channel <br/>channel.prefetch(1)</pre>
<p>Note that the example shows the prefetch value at one <kbd>(1)</kbd>. This means that just one message will be delivered to the consumer until the consumer has <strong>ack:ed/nack:ed</strong> it. The default RabbitMQ prefetch setting provides an unlimited buffer for sending as many messages as possible to consumers that are ready to accept them. In the consumer, the client library caches the messages until processed. Prefetch settings limit the number of messages the client is able to receive before acknowledging them, rendering them invisible to other consumers, and removing them from the queue.</p>
<div class="packt_tip">RabbitMQ supports channel-level, message-based prefetch counts, not connection or byte size-based prefetching.</div>
<p>Next, we'll look at how to set the correct prefetch value.</p>
<h2 id="uuid-d2171cc4-854c-4022-b528-cb21766146d7">Setting the correct prefetch value</h2>
<p>In a scenario of one or a few consumers who are quickly processing messages, it is recommended to prefetch many messages at once to keep the client as busy as possible. It is possible to divide the total round-trip time by the processing time for each message to get an estimated prefetch value – if the processing time stays the same and the network behavior is stable.</p>
<p>A low prefetch value is recommended in situations where there are many consumers and a short processing time. If the prefetch value is set too low, the consumers will be idle much of the time, waiting for messages to arrive. On the other hand, if the prefetch value is too high, one consumer may be very busy while the others are idle. </p>
<div class="packt_tip">One typical mistake is to allow unlimited prefetch where one client receives all the messages, leading to high memory consumption and crashes, which cause all messages to be re-delivered.</div>
<p>In scenarios where there are many consumers and/or a longer time to process messages, it is recommended that the prefetch value is set to one (1) to evenly distribute messages among all consumers.</p>
<div class="packt_tip">If the client is set to auto-ack messages, prefetch settings will have no effect. </div>
<p>As mentioned in <a href="377ec533-342d-4a08-9011-7176de197886.xhtml"><em>Chapter 2</em></a>, <em>Creating a Taxi Application</em>, a consumer can acknowledge message delivery back to the broker. It's now time to look into how that can be done.</p>
<h1 id="uuid-139b8b06-e414-46fc-b499-f72d94a85201" class="mce-root">Acknowledging messages</h1>
<p>A message that is in transit between the broker and the consumer might get lost in the event of a connection failure, and important messages probably need to be retransmitted. Acknowledgments let the server and clients know when to retransmit messages.</p>
<p>There are two possible ways to acknowledge message delivery – once a consumer receives the message (an automatic acknowledgment, auto-ack), and when a consumer sends back an acknowledgment (explicit/manual acknowledge). With auto-ack, the message is acknowledged as soon as it leaves the queue (and is thereby removed from the queue). It is best to auto-ack when high message speeds are required, if the connections are reliable, and if lost messages aren't a concern.</p>
<div class="packt_tip">Using manual acknowledgments on messages can have a performance impact on the system, compared to an automatic acknowledgment. If aiming for fast throughput, manual acknowledgments should be disabled, and auto acknowledgments should be used instead.</div>
<p>In CC's case, the risk of losing a message is not acceptable, so the preceding code has been changed to set the acknowledgment to <kbd>manual</kbd>, making it possible to determine when to acknowledge the message:</p>
<pre>queue.subscribe(block: true, manual_ack: true) </pre>
<p>The message also has to be acknowledged once it has been fully processed:</p>
<pre>channel.acknowledge(delivery_info.delivery_tag, false)</pre>
<p>As demonstrated, the method to manually acknowledge takes two arguments – the first is <kbd>delivery tag</kbd>, and the second is needed in case more than one message must be acknowledged at once. A delivery tag is a channel-specific number that the server uses to identify deliveries. It is of crucial importance that the consumer acknowledges the messages on the same channel as they were received because not doing so will raise an error.</p>
<p>After changing the code and running the application, the ack column rate is shown as non-zero. This is because manual acknowledgment is now used and the RabbitMQ client now sends ack messages over the wire to the broker. This has a cost in terms of bandwidth usage and general performance; however, if the priority is the guarantee of successful message processing over speed, it is perfectly acceptable.</p>
<div class="packt_tip">Use manual acknowledgment if there is a risk that the processing of a message may fail and the broker needs to eventually redeliver it. Redelivery of unacknowledged messages doesn't happen immediately unless the message is rejected or the channel is closed.</div>
<p>CC's journey with RabbitMQ is getting more exciting, causing the team to request a new feature to send important information to all taxi drivers directly. Let's see how to implement this new feature!</p>
<h1 id="uuid-1335f1bc-0a65-490e-9dcf-fdc1bed1e62e">Publishing to all queues</h1>
<p>With the new feature request in hand, the CC programming team came up with the new overall messaging architecture shown in the following diagram. The back-office application will be connected to RabbitMQ in order to publish information messages to all taxi drivers:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-653 image-border" src="assets/966ed4da-f77c-4c89-acee-32a1e47dd8a6.png" style="width:70.75em;height:32.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 3.3: Back-office application in the architecture</div>
<div class="caption">
<p>To roll this out, one way could be to use the topic messaging that's already in place and create a special topic to which all drivers would be subscribed. However, there is an even cleaner and simpler approach offered by the AMQP protocol – fanout exchange.</p>
</div>
<h2 id="uuid-b255047f-1cc8-45c7-9cef-66081e5f9783">Fanout exchange</h2>
<p class="mce-root">Fanout exchange takes all messages that are coming in and delivers them to all queues that are bound to it. An easy-to-understand example of where to use a fanout is when messages need to be spread between many participants, like in a chat (however, there are probably better choices for pure chat applications).</p>
<p class="mce-root">Other examples include the following:</p>
<ul>
<li class="mce-root"><span>Score board or leaderboard updates from sports news to mobile clients, or other global events</span></li>
<li class="mce-root"><span>Broadcasting various state and configuration updates in distributed systems</span></li>
</ul>
<p class="mce-root">As shown in the following diagram, the fanout exchange routes a copy of each message it receives to all the queues bound to it. This model fits perfectly with the public address behavior that CC aims for in the new feature, the option to send a single message to all drivers:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-652 image-border" src="assets/0b369565-ce6e-4fa0-b3bc-228e1c0738a1.png" style="width:71.33em;height:29.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 3.4: The fanout exchange routes to all bound queues</div>
<p>It's time to add the fanout exchange into CC's application.</p>
<h2 id="uuid-d557f97d-7073-46aa-9420-499cc2691186">Binding to the fanout</h2>
<p>The back office should be able to publish a single message to all taxi drivers. This message could include current traffic information or information about a party that will happen during the evening. Because this new broadcast system will be <span>infrequently used</span>, the CC team was not as concerned about efficient connection management as they were with the main application. In fact, it's fine to connect and disconnect for each interaction with the fanout exchange because, in the case of temporary issues with the RabbitMQ broker, retries from the back office application will eventually succeed.</p>
<p>To start using the new fanout exchange in the back office, two steps must be performed: first, declare the fanout exchange when the application starts, and then bind the queue to it when a user logs in.</p>
<p>Number five in the following example shows the code added to the back office service in order to publish messages on this new exchange:</p>
<pre># 1. Require client library<br/>require "bunny"<br/><br/># 2. Read RABBITMQ_URI from ENV<br/>connection = Bunny.new ENV["RABBITMQ_URI"]<br/><br/># 3. Communication session with RabbitMQ<br/>connection.start<br/>channel = connection.create_channel<br/><br/># 4. Declare queues for taxis<br/>queue1 = channel.queue("taxi-inbox.1", durable: true)<br/><br/>queue2 = channel.queue("taxi-inbox.2", durable: true)<br/><br/># 5. Declare a fanout exchange<br/>exchange = channel.fanout("taxi-fanout")<br/><br/># 6. Bind the queue <br/>queue1.bind(exchange, routing_key: "")<br/>queue2.bind(exchange, routing_key: "")<br/><br/># 7. Publish a message<br/>exchange.publish("Hello everybody! This is an information message from the crew!", key: "")<br/><br/># 8. Close the connection<br/>connection.close </pre>
<p>The logic in this code should feel familiar. An empty string is used as the routing key when binding the queue. The value doesn't really matter because the fanout exchange doesn't care about routing keys.</p>
<p>Notice that <kbd>exchange</kbd> is declared right before using it. This avoids relying on the implicit pre-existence of the exchange. Not doing that would mean that the main application would have to run once to create the exchange before the back office service can use it. Since the exchange declaration is idempotent, it can and should be declared at all times.</p>
<div class="packt_infobox">Be particularly careful with AMQP client libraries that may use different default values for exchange and queue parameters; it's better to be explicit and to specify all values.</div>
<p>The same queues as in the direct and topic exchange example are not used since the taxi inbox queue only includes information messages. Two new queues (<kbd>taxi-inbox.1</kbd> and <kbd>taxi-inbox.2</kbd>) are instead declared and bounded to the exchange.</p>
<div class="packt_tip">
<p>Unless there is a strong guarantee that an exchange or a queue will pre-exist, assume it doesn't exist and declare it. It is better to be safe than sorry, especially when AMQP encourages it and provides the necessary means to do so.</p>
</div>
<p>With this code in place, the back office application can now send public information messages to all drivers. This is a great success, one that again reinforces CC in its decision to deploy RabbitMQ and build on it. Now, let's run the application.</p>
<h2 id="uuid-e196b2da-e1cc-4b08-850b-1e9e0af29b3c">Running the application</h2>
<p>There's nothing spectacular to note when running the application; messages from the back office successfully flow to the drivers' inbox queues and the only visible change is the newly created driver fanout exchange.</p>
<p>This is visible in the management console shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1046 image-border" src="assets/66699092-b5ce-4f3b-a402-dcb3986c68f9.png" style="width:40.17em;height:23.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 3.5: The fanout exchange for user queues is visible in the management console</div>
<p>At this point, it is interesting to take a look at the bindings of any particular queue. To do this, click on the <span class="packt_screen">Queues</span> tab and then scroll down and click on <span class="packt_screen">Bindings</span> to display the hidden window.</p>
<p>This will show what is reproduced, as in the following screenshot where each queue has multiple bindings – one for the user-to-taxi messaging feature, one for the topics messages, and a final one for the public address fanout feature:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-651 image-border" src="assets/17132d85-a996-4e16-86ea-236db35e0f71.png" style="width:27.17em;height:18.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 3.6: Each taxi queue has multiple bindings</div>
<p>Before concluding, let's pause for a second and relish the fact that there is now a successful taxi request integration that works across platforms. This may not seem important to anyone with a little experience in messaging systems; however, it is nothing short of a small miracle. Thanks to AMQP and RabbitMQ, the message broker can be replaced with any other AMQP-based message broker, and more services can be added in any chosen language.</p>
<h1 id="uuid-a1ee21ef-dc69-41b1-8e18-e76b2379829f">Summary</h1>
<p>This chapter talked about prefetch and manual acknowledgment from the consumer. The fanout exchange was introduced, <span>to be able to broadcast a single message to all active queues.</span> Up next, CC has new plans for its RabbitMQ system – they want to be able to clean up old messages in a smooth way and tweak the message delivery. They also want to be able to send messages to individual drivers from the back office service.</p>
<p>Continue on to the next chapter to find out what CC is up to!</p>


            </article>

            
        </section>
    </body></html>