<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Authentication</h1></div></div></div><p>Authentication is the process of verifying that the user who is accessing an application is indeed who he/she claims to be and also, that he/she is allowed to access and use our application. In this chapter, we'll see how we can secure our web services with authentication mechanisms.</p><div class="section" title="Building a basic HTTP authenticator"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec26"/>Building a basic HTTP authenticator</h1></div></div></div><p>Our web <a id="id214" class="indexterm"/>service now has the functionality that allows anyone to use an HTTP client and create and retrieve contacts. We need to somehow secure our web service and authenticate the users that call it. The most common way of authentication is basic HTTP authentication, which requires a basic set of credentials: a username and password.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec57"/>Getting ready</h2></div></div></div><p>Before we proceed with securing our web service, we need to add the <code class="literal">dropwizard-auth</code> dependency to our project, adding the following to the dependencies section of our <code class="literal">pom.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;io.dropwizard&lt;/groupId&gt;
  &lt;artifactId&gt;dropwizard-auth&lt;/artifactId&gt;
  &lt;version&gt;0.7.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec58"/>How to do it…</h2></div></div></div><p>Let's see what it takes to build the authentication mechanism and secure our methods; perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class in the <code class="literal">com.dwbook.phonebook</code> package named <code class="literal">PhonebookAuthenticator</code>; here, we are going to build our service's security mechanism. The class needs to implement the <code class="literal">Authenticator&lt;C, P&gt;</code> interface and its <code class="literal">#authenticate()</code> method. The first parameter of the authenticator<a id="id215" class="indexterm"/> is the <code class="literal">Authentication</code> method<a id="id216" class="indexterm"/>, whereas the second one is the return type of the <code class="literal">#authenticate()</code> method.<div class="informalexample"><pre class="programlisting">  package com.dwbook.phonebook;import com.google.common.base.Optional;
  import io.dropwizard.auth.AuthenticationException;
  import io.dropwizard.auth.Authenticator;
  import io.dropwizard.auth.basic.BasicCredentials;
  public class PhonebookAuthenticator implementsAuthenticator&lt;BasicCredentials, Boolean&gt; {
    public Optional&lt;Boolean&gt; authenticate(BasicCredentials c) throws AuthenticationException {
      if (c.getUsername().equals("john_doe") &amp;&amp; c.getPassword().equals("secret")) {
      return Optional.of(true);
      }
      return Optional.absent();
    }
  }</pre></div></li><li class="listitem">Enable<a id="id217" class="indexterm"/> the authenticator you've just built by adding it to the Dropwizard environment along with <code class="literal">JerseyEnvironment#register()</code>, passing to it a <code class="literal">BasicAuthProvider</code> instance. The constructor of <code class="literal">BasicAuthProvider</code> takes an instance of the authenticator to be used as the input and the authentication realm. You will also need to import <code class="literal">io.dropwizard.auth.basic.BasicAuthProvider</code>.<div class="informalexample"><pre class="programlisting">  // Register the authenticator with the environment
  e.jersey().register(new BasicAuthProvider&lt;Boolean&gt;(
    new PhonebookAuthenticator(), "Web Service Realm"));</pre></div></li><li class="listitem">You may now secure web service endpoints, modifying the declarations of the <code class="literal">ContactResource</code> class' methods to expect a <code class="literal">Boolean</code> variable as the parameter, annotated with <code class="literal">@Auth</code> (import <code class="literal">io.dropwizard.auth.Auth</code>). The inclusion of this annotated parameter will trigger the authentication process.<div class="informalexample"><pre class="programlisting">public Response getContact(@PathParam("id") int id, @Auth Boolean isAuthenticated) { … }

public Response createContact(Contact contact, @Auth   Boolean isAuthenticated) throws URISyntaxException { … }

public Response deleteContact(@PathParam("id") int id, @Auth Boolean isAuthenticated) { … }
public Response updateContact(@PathParam("id") int id, Contact contact, @Auth Boolean isAuthenticated) { … }</pre></div></li><li class="listitem">Build and start the application and then try to access any of the endpoints of the <code class="literal">ContactResource</code> class, such as <code class="literal">http://localhost:8080/contact/1</code>, trying to display the contact with an ID equal to 1. You will see a message stating that the server requires a username and a password.<div class="mediaobject"><img src="graphics/9530OS_09_01.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec59"/>How it works…</h2></div></div></div><p>The <code class="literal">dropwizard-auth</code> module includes everything we need in order to secure our services. We<a id="id218" class="indexterm"/> just need to implement an Authenticator and register it with the Dropwizard environment.</p><p>Then, when<a id="id219" class="indexterm"/> we use the <code class="literal">@Auth</code> annotation for a method's input parameter, we indicate that the user who is accessing our service must be authenticated. Each time an HTTP request is performed on a method that contains a variable annotated with <code class="literal">@Auth</code>, the authentication provider intercepts it requesting a username and password. These credentials are then passed on to our authenticator who is responsible for determining whether they're valid or not. Whatever the authentication result is, that is, the return value of <a id="id220" class="indexterm"/>the <code class="literal">#authenticate()</code> method, it is injected in the variable that is annotated with <code class="literal">@Auth</code>. In case the authentication is unsuccessful or no credentials are provided, the request is blocked and the response is an <span class="strong"><strong>HTTP/1.1 401 Unauthorized</strong></span> error. You can see the response received after performing an HTTP request with cURL without providing credentials in the following screenshot:</p><div class="mediaobject"><img src="graphics/9530OS_09_02.jpg" alt="How it works…"/></div><p>Our <a id="id221" class="indexterm"/>authenticator class needs to be a class that implements the <code class="literal">Authenticator&lt;C, P&gt;</code> interface, where <code class="literal">C</code> is the set of credentials that we may use to authenticate the user and <code class="literal">P</code> is the type of the authentication's outcome. In our case, we used <code class="literal">BasicCredentials</code> as the credentials store, which is what <code class="literal">BasicAuthProvider</code> provides. In the <code class="literal">#authenticate()</code> method, we perform all the tasks required<a id="id222" class="indexterm"/> to authenticate the user. We implemented this to check that the user's name is <code class="literal">john_doe</code> as identified by the password, <code class="literal">secret</code>. This was an example; the next recipe illustrates how to authenticate users when their details (username and password) are stored in a database.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec60"/>There's more…</h2></div></div></div><p>As you may have noticed, our authenticator's <code class="literal">#authenticate()</code> method's return type is <code class="literal">Optional</code>. This is a Guava type that allows us to prevent null-pointer exceptions. There are cases where the <code class="literal">#authenticate()</code> method should return nothing, so instead of simply returning null (which could cause problems if not handled correctly), we return <code class="literal">Optional.absent()</code>.</p><p>Such cases are when we need to provide an instance of the authenticated principal (that would probably contain username, name, e-mail, and so on) to the methods we secure, instead of just a <code class="literal">boolean</code> parameter, as we did in this example.</p><div class="section" title="Setting client's credentials"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec21"/>Setting client's credentials</h3></div></div></div><p>We have <a id="id223" class="indexterm"/>secured our web service, in particular the endpoints of the <code class="literal">ContactResource</code> class. Our client needs to be updated as well in order to be able to access these protected resources.</p><p>To do so, we <a id="id224" class="indexterm"/>will need to modify the <code class="literal">App#run()</code> method<a id="id225" class="indexterm"/>. Use the <code class="literal">#addFilter()</code> method of the <code class="literal">client</code> object, right<a id="id226" class="indexterm"/> after its instantiation, adding <code class="literal">HTTPBasicAuthFilter</code> (import <code class="literal">com.sun.jersey.api.client.filter.HTTPBasicAuthFilter</code>) and providing the correct username and password.</p><div class="informalexample"><pre class="programlisting">final Client client = new JerseyClientBuilder().using(environment).build();client.addFilter(new HTTPBasicAuthFilter("john_doe", "secret"));</pre></div><p>The <code class="literal">#addFilter()</code> method is used to add additional processing instructions to the <code class="literal">client</code> object. That is, every request that is performed by our Jersey client has to be processed by the filters we've added before it is eventually performed. In this case, we use the <code class="literal">#addFilter()</code> method in order to add the appropriate <code class="literal">BasicAuth</code> headers to every outgoing HTTP request.</p></div><div class="section" title="Optional authentication"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec22"/>Optional authentication</h3></div></div></div><p>There <a id="id227" class="indexterm"/>are many cases where authentication should be optional. Think of a service that returns personalized information for a user and a default message when no user is logged in. In order to declare optional authentication, we should have provided the <code class="literal">required=false</code> parameter on the <code class="literal">@Auth</code> annotation, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Auth(required=false)</pre></div></div><div class="section" title="Authentication schemes"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec23"/>Authentication schemes</h3></div></div></div><p>We used basic HTTP authentication in our application; however, it is not the only available authentication scheme. For example, some web services use API key authentication. In such cases, the authenticator should be checking the headers of the HTTP request, verifying the validity of the transmitted API key. However, doing so would require the usage of a custom authentication provider as well. In any case, the use of an authentication method depends on your application's needs.</p></div></div></div></div>
<div class="section" title="Authenticating users with credentials stored in a database"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec27"/>Authenticating users with credentials stored in a database</h1></div></div></div><p>In <a id="id228" class="indexterm"/>the previous recipe, we used a hard-coded set of username and password to verify the users' identity. In most real-world cases though, you will need to identify users and verify their identity using credentials that are stored in a database, or more specifically, in a table that holds user information.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec61"/>Getting ready</h2></div></div></div><p>Let's<a id="id229" class="indexterm"/> first create a table in the database that will hold user data.</p><p>Start the MySQL client, and after logging in, execute the following query in the phonebook database:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE IF NOT EXISTS `users` (
  `username` varchar(20) NOT NULL,
  `password` varchar(255) NOT NULL,
  PRIMARY KEY (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;</pre></div><p>Now let's add a user to the database by running the following query:</p><div class="informalexample"><pre class="programlisting">INSERT INTO `users` VALUES ('wsuser', 'wspassword');</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec62"/>How to do it…</h2></div></div></div><p>We are going to modify our authentication provider in order to check the current user's credentials in the database. Let's see how:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Since we are going to be interacting with the database for validating the user, we will need a DAO. So, create the <code class="literal">UserDAO</code> interface in the <code class="literal">com.dwbook.phonebook.dao</code> package.<div class="informalexample"><pre class="programlisting">  package com.dwbook.phonebook.dao;
  import org.skife.jdbi.v2.sqlobject.*;
  public interface UserDAO {
    @SqlQuery("select count(*) from users where username = :username and password = :password")
    int getUser(@Bind("username") String username, @Bind("password") String password);
  }</pre></div></li><li class="listitem">Modify <code class="literal">PhonebookAuthenticator</code>, adding a <code class="literal">UserDAO</code> instance as a member variable, creating a constructor to initialize the DAO instance using <code class="literal">jdbi</code>, and finally altering the authenticate method by utilizing the <code class="literal">UserDAO</code> instance for verifying user data by querying the database.<div class="informalexample"><pre class="programlisting">  import org.skife.jdbi.v2.DBI;
  import com.dwbook.phonebook.dao.UserDAO;
  import com.google.common.base.Optional;
  import io.dropwizard.auth.AuthenticationException;
  import io.dropwizard.auth.Authenticator;
  import io.dropwizard.auth.basic.BasicCredentials;

  public class PhonebookAuthenticator implements Authenticator&lt;BasicCredentials, Boolean&gt; {
    private final UserDAO userDao;

    public PhonebookAuthenticator(DBI jdbi) {
      userDao = jdbi.onDemand(UserDAO.class);
    }

    public Optional&lt;Boolean&gt; authenticate(BasicCredentials c) throws AuthenticationException {
      boolean validUser = (userDao.getUser(c.getUsername(), c.getPassword()) == 1);
      if (validUser) {
        return Optional.of(true);
      }
      return Optional.absent();
    }
  }</pre></div></li><li class="listitem">In the <code class="literal">App#run()</code> method<a id="id230" class="indexterm"/>, modify the registration of our authenticator in order to pass the existing <code class="literal">jdbi</code> instance to its constructor.<div class="informalexample"><pre class="programlisting">// Register the authenticator with the environment
e.jersey().register(new BasicAuthProvider&lt;Boolean&gt;(
  new PhonebookAuthenticator(jdbi), "Web Service Realm"));</pre></div></li></ol></div><p>You <a id="id231" class="indexterm"/>may now rebuild, run, and test the application again. This time, when requested, you will need to provide the username and password set stored in the database instead of the hard-coded ones.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec63"/>How it works…</h2></div></div></div><p>Upon every request that is performed on a protected resource, our application checks the user's credentials against the database. To do so, we created a simple DAO with a single query that actually counts the rows that match the provided username and password. Of course, this could be either 0 (when the username/password set is incorrect) or 1 (when there is a correct set of credentials provided). This is what we check for in the authenticator's<a id="id232" class="indexterm"/> <code class="literal">#authenticate()</code> method.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec64"/>There's more…</h2></div></div></div><p>In this recipe, we stored the password in a database as plain text. This is normally not the appropriate way to do so; passwords should always be encrypted or hashed, and never stored in clear text, to minimize the impact of a possible intrusion or unauthorized access.</p><div class="section" title="Caching"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec24"/>Caching</h3></div></div></div><p>To improve our application's performance, we could cache the database credentials. Dropwizard provides the <code class="literal">CachingAuthenticator</code> class that we could use for this matter. The concept is simple; we build a wrapper around our authenticator with the <code class="literal">CachingAuthenticator#wrap()</code> method and <a id="id233" class="indexterm"/>register it with the environment. We will also <a id="id234" class="indexterm"/>be defining a set of caching directives, for example, how many entries<a id="id235" class="indexterm"/> to cache and for how long, using Guava's <code class="literal">CacheBuilderSpec</code>. For this example, we need to import <code class="literal">io.dropwizard.auth.CachingAuthenticator</code> and <code class="literal">com.google.common.cache.CacheBuilderSpec</code>.</p><div class="informalexample"><pre class="programlisting">// Authenticator, with caching support (CachingAuthenticator)
CachingAuthenticator&lt;BasicCredentials, Boolean&gt; authenticator = new CachingAuthenticator&lt;BasicCredentials, Boolean&gt;(
e.metrics(), 
new PhonebookAuthenticator(jdbi), 
CacheBuilderSpec.parse("maximumSize=10000, expireAfterAccess=10m"));

// Register the authenticator with the environment
e.jersey().register(new BasicAuthProvider&lt;Boolean&gt;(
authenticator, "Web Service Realm"));

// Register the authenticator with the environment
e.jersey().register(new BasicAuthProvider&lt;Boolean&gt;(
authenticator, "Web Service Realm"));</pre></div><p>The key statement in the preceding snippet is <code class="literal">CacheBuilderSpec.parse("maximumSize=10000, expireAfterAccess=10m"));</code>. With this statement, we configure the wrapper to cache <code class="literal">10000</code> principals (the <code class="literal">maximumSize</code> property), that is, sets of usernames/passwords, and keep each of them cached for 10 minutes. The <a id="id236" class="indexterm"/>
<code class="literal">CacheBuilderSpec#parse()</code> method is used to build a <code class="literal">CacheBuilderSpec</code> instance by parsing a string. This is for our convenience, allowing us to externalize the cache configuration, as instead of parsing a static string, we could parse a property defined in our configuration settings file.</p></div></div></div></body></html>