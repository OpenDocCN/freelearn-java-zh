<html><head></head><body>
		<div id="_idContainer111">
			<h1 id="_idParaDest-248"><a id="_idTextAnchor250"/>Chapter 10: Implementing User Interaction</h1>
			<p><strong class="bold">User interaction</strong> constitutes<a id="_idIndexMarker1347"/> a very important layer in software architecture. This layer comprises all the ways, such as web interfaces and mobile applications, that end users can approach and use our applications.</p>
			<p>For this reason, user interaction needs to be implemented with very high attention to detail. A badly designed, poorly performing user interface will compromise the overall user experience, even if the rest of the application is well written and performs really well. And indeed, the user interface can use a number of different tricks to hide issues (such as performance issues) in other layers of the software architecture (that is, <em class="italic">the backend</em>).</p>
			<p>In this chapter, we are going to explore the most widely used technologies for Java applications, both for cloud-native and traditional applications. </p>
			<p>This will include frameworks built using the <strong class="bold">Java Enterprise Edition</strong> platform (such as <strong class="bold">Jakarta Server Pages</strong> and <strong class="bold">Jakarta Server Faces</strong>) and more modern JavaScript frameworks for single-page applications (React, in our case).</p>
			<p>In this chapter, you will learn about the following topics:</p>
			<ul>
				<li>User interface architecture – backend versus frontend</li>
				<li>Web user interfaces using Jakarta Server Faces and Jakarta Server Pages</li>
				<li>Introducing single-page applications</li>
				<li>Learning about mobile application development</li>
				<li>Exploring IVR, chatbots, and voice assistants</li>
				<li>Omnichannel strategy in enterprise applications</li>
			</ul>
			<p>Let's start by concentrating on the architecture of the user interaction layer, or rather, where to put each component and functionality. We will touch on the architectural aspects of building frontend layers for our applications.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor251"/>User interface architecture – backend versus frontend</h1>
			<p>It may seem silly<a id="_idIndexMarker1348"/> to<a id="_idIndexMarker1349"/> discuss where a <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) must live. After all, it's almost a given – the UI is the forefront of our software architecture, providing the interaction with end users, and for this reason, it must stay at the front, hence the term <em class="italic">frontend</em>, which is used as a synonym for UI. And everybody agrees on that, without a doubt.</p>
			<p>Except that it's not that easy to draw a line as to where a UI starts and where it ends. And, depending on the particular implementation, a number of different components may provide the functionalities needed to build the experience we want to eventually present to our customers. The UI will be made of, more or less, the following components:</p>
			<ul>
				<li><strong class="bold">Assets, also referred to as static files</strong>: These<a id="_idIndexMarker1350"/> are the pieces of the web application that must be sent (where relevant) to our clients. They include, usually, HTML files, JavaScript scripts, other graphical artifacts (images, CSS files, and movie clips), and even fully built, self-contained applications (as in the case of mobile apps).</li>
				<li><strong class="bold">Data</strong>: This is the content shown using the assets. This implies having a way to retrieve updates (usually involving web services or similar technology).</li>
				<li><strong class="bold">Behavior</strong>: This refers to how the UI reacts to user inputs and other events. This is a broader area that includes <em class="italic">interactivity</em> (what changes, and how, when our user does something), <em class="italic">validation</em> (checking user inputs for formal and substantial consistency), <em class="italic">navigation</em> (how different views, or pages, must be shown one after the other to implement the features requested by the user), and <em class="italic">security</em> (how to be sure that each user is properly identified and profiled, able to do only what they are allowed to do, and able to access only the appropriate set of data).</li>
			</ul>
			<p>The point is more or less this – different implementations will have different ways of providing assets to end users, different ways of providing (and collecting) data, and different implementations of behavior (such as navigation or validation being implemented on the client side or the server side). In this chapter, we will look at the most common ways to arrange all of those components to provide a good user experience. Our<a id="_idIndexMarker1351"/> next section will be about the most traditional <a id="_idIndexMarker1352"/>ways to implement this in Java Enterprise Edition – Jakarta Server Faces and Jakarta Server Pages.</p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor252"/>Web user interface using Jakarta Server Pages and Jakarta Server Faces</h1>
			<p>If you <a id="_idIndexMarker1353"/>have <a id="_idIndexMarker1354"/>ever<a id="_idIndexMarker1355"/> worked <a id="_idIndexMarker1356"/>with Java Enterprise applications developed from 2000 to 2015, chances are you have seen <strong class="bold">Java Server Pages</strong> (<strong class="bold">JSP</strong>) and <strong class="bold">Java Server Faces</strong> (<strong class="bold">JSF</strong>) in action. Now widely considered legacy, these two technologies still appear widely in existing Java deployments and are worth knowing about, at least for historical reasons. </p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor253"/>Introducing basic Java web technology – Jakarta Server Pages</h2>
			<p><strong class="bold">Jakarta Server Pages</strong> (formerly<a id="_idIndexMarker1357"/> Java Server Pages) is, in <a id="_idIndexMarker1358"/>essence, a templating technology, allowing you to mix dynamic content written in Java with static content (usually written in HTML). By using JSP, an application server can build a web page to provide to a client (and visualize in a web browser). We already talked about JSP in <a href="B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Essential Java Architectural Patterns</em>, when talking about server-side <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>). If you <a id="_idIndexMarker1359"/>remember, JSP plays the role of the <em class="italic">View</em> in the MVC pattern. In the same context, we mentioned servlets as another core component, taking care of the <em class="italic">Controller</em> part of MVC.</p>
			<p>It's now time to clarify the relationship between servlets and JSP. Assuming that most of you know what a servlet is, I will provide just a very brief description.</p>
			<p>A <strong class="bold">servlet</strong>, in Java, is a<a id="_idIndexMarker1360"/> special class that implements an API (the Jakarta Servlet API) and is designed to simplify communication over a client-server protocol. Usually, a servlet is created to model HTTP communication, as a way to provide HTML content to a browser. For this reason, in the hierarchy of classes and interfaces supporting the servlet model, there are a number of methods used to handle conversation over HTTP between a client and a server. Some such methods are adhering to the servlet life cycle (such as <strong class="source-inline">init()</strong>, called when the servlet is loaded, and <strong class="source-inline">destroy()</strong>, called before the servlet is unloaded), while others are called when HTTP actions are performed against the servlet (such as <strong class="source-inline">doPost(...)</strong>, to handle an HTTP <strong class="source-inline">POST</strong> request, and <strong class="source-inline">doGet(...)</strong>, to do the same with a <strong class="source-inline">GET</strong> request). </p>
			<p>So far so good! Servlets are specialized components, able to handle HTTP conversations, and for this reason, they are used to complement views (such as JSP files) in providing user experience features (such as form submission and page navigation). As we have discussed, it is common for a servlet to be the <em class="italic">controller</em>, whereas a JSP file is used as the <em class="italic">view</em>, although more sophisticated frameworks have been developed to deal with JSP, such as Struts and the Spring MVC.</p>
			<p>But there is another point worth noting – JSP files are basically servlets themselves. </p>
			<p>A JSP file, indeed, is<a id="_idIndexMarker1361"/> just a different way to implement a <a id="_idIndexMarker1362"/>servlet. Each JSP file, at runtime, is translated into a servlet by the application server running our code. As we discussed in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>, we need an application server fully or partially compliant with the JEE specification in order to run each JEE API (including the servlet and JSP APIs).</p>
			<p>So, now that we know that JSP is a templating technology and that each JSP file is translated to a servlet, which outputs to the client what we have modeled in the template, it is time to see what a JSP file looks like.</p>
			<p>A JSP file is somewhat similar to a <strong class="bold">PHP</strong> one. It mixes HTML fragments with special scripts implementing functions and business logic. The scripts are enclosed within tags, such as <strong class="source-inline">&lt;% ... %&gt;</strong>, which is<a id="_idIndexMarker1363"/> called a <strong class="bold">scriptlet</strong> and contains arbitrary Java code. A scriptlet is executed when a client requests a page. </p>
			<p>Another tag used in JSP is marked using <strong class="source-inline">&lt;%= %&gt;</strong> and is<a id="_idIndexMarker1364"/> called an <strong class="bold">expression</strong>. The Java code is evaluated when the page is loaded, and the result is used to compose the web page. Another commonly used JSP<a id="_idIndexMarker1365"/> feature is <strong class="bold">directives</strong>, delimited by <strong class="source-inline">&lt;%@ ... %&gt;</strong> and used to configure page metadata. A very basic JSP page might look like this:</p>
			<p class="source-code">&lt;%@ page contentType="text/html;charset=UTF-8" </p>
			<p class="source-code">  language="java" %&gt;</p>
			<p class="source-code">&lt;%@ page import = "java.util.Date" %&gt;</p>
			<p class="source-code">&lt;%@ page import = "java.text.SimpleDateFormat" %&gt;</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">    &lt;head&gt;</p>
			<p class="source-code">        &lt;title&gt;Simple JSP page&lt;/title&gt;</p>
			<p class="source-code">    &lt;/head&gt;</p>
			<p class="source-code">    &lt;%</p>
			<p class="source-code">      SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-</p>
			<p class="source-code">        yyyy HH:mm:ss");</p>
			<p class="source-code">      String date = sdf.format(new Date());</p>
			<p class="source-code">    %&gt;</p>
			<p class="source-code">    &lt;body&gt;</p>
			<p class="source-code">        &lt;h1&gt;Hello world! Current time is &lt;%=date%&gt; &lt;/h1&gt;</p>
			<p class="source-code">    &lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>Some things <a id="_idIndexMarker1366"/>worth<a id="_idIndexMarker1367"/> noticing are listed as follows:</p>
			<ul>
				<li>At the top of the files, directives are used. They define some metadata (the page content type and the language used) and the Java packages to be imported and used on the page.</li>
				<li>There is some HTML code interleaved with the scripts. The code inside the script delimiters is largely recognizable to Java developers, as it simply formats a date.</li>
				<li>In the first scriptlet, we define the <strong class="source-inline">date</strong> variable. We can then access it in the expression inside the <strong class="source-inline">&lt;h1&gt;</strong> HTML tag. The expression simply refers to the variable. The engine will then replace the variable value in that spot in the generated HTML page.</li>
			</ul>
			<p>In a real-world application, we can imagine some useful ways to use such syntax:</p>
			<ul>
				<li>We could use scriptlets to retrieve useful data by calling external services or using database connections.</li>
				<li>By using Java code in the scriptlets, it is easy to implement iterations (usually to display tabular data) and format data in a preferred way (both in scriptlets and expressions).</li>
				<li>Java code in scriptlets can be used to get and validate data provided by the user (usually using HTML forms). Moreover, user sessions and security can be managed in different ways (usually by leveraging cookies).</li>
			</ul>
			<p>It's also worth noticing that JSP directives can be used to include other JSP files. In this way, the logic can be modularized and reused.</p>
			<p>Moreover, JSP allows defining custom tag libraries. Such libraries are collections of personalized <a id="_idIndexMarker1368"/>tags <a id="_idIndexMarker1369"/>that embed custom logic that is executed when a tag is used. A widely used tag library is<a id="_idIndexMarker1370"/> the one provided by default by the JSP implementation, which is the <strong class="bold">Jakarta Standard Tag Library</strong> (<strong class="bold">JSTL</strong>). In order to use a tag library (JSTL core, in this case), we need to use a directive to import it like this:</p>
			<p class="source-code">&lt;%@ taglib prefix="c" </p>
			<p class="source-code">  uri="http://java.sun.com/jsp/jstl/core" %&gt;</p>
			<p>The JSTL provides a set of tags that offer the following functionalities:</p>
			<ul>
				<li><strong class="source-inline">Core</strong> provides basic functionalities such as flow control (loops and conditional blocks) and exception handling.</li>
				<li><strong class="source-inline">JSTL</strong> is used mostly for string manipulation and variable access.</li>
				<li><strong class="source-inline">SQL</strong> implements basic database connection handling and data access.</li>
				<li><strong class="source-inline">XML</strong> is used for XML document manipulation and parsing.</li>
				<li><strong class="source-inline">Formatting</strong> is a set of functions useful for formatting variables (such as dates and strings), according to character encodings and locale.</li>
			</ul>
			<p>So, the date formatting that we did in our previous example can be summarized with the appropriate JSTL tags (included from the <strong class="source-inline">Core</strong> and <strong class="source-inline">Formatting</strong> collections) as follows:</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt;c:set var = "now" value = "&lt;% = new java.util.Date()%&gt;" /&gt;</p>
			<p class="source-code">&lt;fmt:formatDate pattern=" dd-MM-yyyy HH:mm:ss " </p>
			<p class="source-code">  value="${now}" /&gt;</p>
			<p class="source-code">   &lt;body&gt; </p>
			<p class="source-code">         &lt;h1&gt;Hello world! Current time is &lt;%=date%&gt; &lt;/h1&gt; </p>
			<p class="source-code">     &lt;/body&gt;</p>
			<p class="source-code">...</p>
			<p>But even if JSTL tags are supposed to reduce the amount of Java code in JSP files, it's very hard to entirely remove <em class="italic">all</em> Java code. Java code mixed with presentation code is considered <a id="_idIndexMarker1371"/>an <a id="_idIndexMarker1372"/>antipattern to avoid, and it's not the only consideration to be made. In the next section, we will see why JSP is considered a legacy technology and almost every Java project today relies on different options for frontend development.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor254"/>JSP – the downsides</h2>
			<p>Now, it's time to<a id="_idIndexMarker1373"/> look at the bad news. There are a number of reasons why JSP is nowadays widely considered unsuitable for modern applications. I can summarize some of those reasons:</p>
			<ul>
				<li>JSP allows for Java code to be interleaved with HTML code. For this reason, it becomes very easy to mix presentation logic with business logic. The result is often an ugly mess (especially in big applications), as it becomes tempting to have presentation logic slip into Java code (such as conditional formatting and complex loops), with the final result being JSP pages that are both hard to read and maintain.</li>
				<li>For similar reasons, a collaboration between different teams with different skills is very difficult. Frontend teams (such as graphic designers) are supposed to work on the HTML sections of a JSP file, while the same file could be being worked on by the backend team for adding business logic-related functionalities. This leads to a resource contention that is hard to solve, as each team may break the other team's implementations.</li>
				<li>Focusing on frontend development, the development cycle is cumbersome and has a slow turnaround. Frontend developers and graphic designers are used to editing an HTML file, refreshing the browser, and immediately seeing the result. With JSP, this is just not possible; usually, the project has to be rebuilt into an artifact (such as a <strong class="source-inline">.war</strong> file) and redeployed to an application server. There can be solutions to this particular issue (such as exploded deployments, where a <strong class="source-inline">.war</strong> file is deployed as an extracted folder), but they are usually implemented differently depending on the application server and may have some downsides (such as not covering all the different kinds of modifications to the file or incurring out-of-memory exceptions if performed too many times).</li>
				<li>This leads to <a id="_idIndexMarker1374"/>another very important point – JSP files require an application server that is fully or partially implementing the JEE specification. <strong class="bold">Apache Tomcat</strong> is a <a id="_idIndexMarker1375"/>common choice here. Indeed, instead of a basic web server serving static content (which is what is used with modern client-side frameworks, as we will see in a couple of sections), you<a id="_idIndexMarker1376"/> will need a <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) and an application server (such as Tomcat) running on top. This will mean slightly more powerful machines are needed, and fine-tuning and security testing must be performed more thoroughly (simply because Java application servers are more complex than static files serving web servers, not because Java is less secure per se). Furthermore, frontend developers will need to use this server (maybe on their local workstation) for development purposes (and that may not be the simplest thing to manage).</li>
				<li>JSP also lacks a simple way of sharing components between different pages and applications. Also, the JSP tags are usually a bit cumbersome to use, especially in complex applications.</li>
				<li>Moreover, the performance in JSP applications is overall worse when compared to single-page applications. Modern JavaScript frameworks for single-page applications are indeed designed to keep the data exchange with the server at a minimum – after you download the HTML files and assets for the first time, and only then, the data is exchanged. This is not so easy to achieve with just JSP, which, in general, is designed to render the server-side page and download it as a whole.</li>
				<li>Finally, the intrinsic nature of JSP makes things more complex from an architectural point of view. Since, in a JSP file, you can use Java code, which entails calling backend services and doing SQL queries, the flow of calls may become complex and convoluted. <em class="italic">Are you supposed to have connections from the frontend directly to the database?</em> <em class="italic">What about services exposed by the backend?</em> Instead of having a thin, simple frontend layer used mostly for visualization and interactivity, you will have business logic and data manipulation sprawling all over the frontend layer. Not the best situation from an architectural standpoint.</li>
			</ul>
			<p>So, now we have seen the basics of JSP, which is a complete template engine that's useful for defining HTML websites and providing some dynamic content written in Java. We've also<a id="_idIndexMarker1377"/> understood what the limitations of the technology are. It is now worth noticing that JEE provides a more complex and complete framework for building web apps, which is Jakarta Server Faces.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor255"/>Jakarta Server Faces – a complex JEE web technology</h2>
			<p><strong class="bold">Jakarta Server Faces</strong> (<strong class="bold">JSF</strong>) is a much<a id="_idIndexMarker1378"/> more<a id="_idIndexMarker1379"/> complete (and complex) framework compared to JSP. It implements the MVC pattern, and it is much more prescriptive and opinionated. This means that concepts such as variable binding, page navigation, security, and session handling are core concepts of the framework. It also provides a component-centric view, meaning that it provides reusable components, which include complex view functionalities such as tables, forms, inputs, and validation.</p>
			<p>As per the <em class="italic">view</em> component of the MVC pattern, JSF used to rely on JSP templating. In more recent implementations, this has been switched <a id="_idIndexMarker1380"/>by default to <strong class="bold">Facelets</strong>, which is an XML-based templating technology.</p>
			<p>The <em class="italic">controller</em> part of JSF is implemented by a special <a id="_idIndexMarker1381"/>servlet, <strong class="bold">FacesServlet</strong>, which takes care of things such as resources initialization, life cycle, and request processing. </p>
			<p>Finally, the <em class="italic">model</em> part of JSF is implemented using so-called <em class="italic">managed beans</em>, which are simply Java classes with a set of properties, getters, and setters. Managed beans are used to bind to pages and components in pages, containing values to be displayed, validating the user input, and handling events. Managed beans can be configured to live within different scopes, including a session (attached to an HTTP session), a request (the same, but with an HTTP request), and an application (living as long as the entire web application does).</p>
			<p>There are a number of different JSF implementations, with the most famous being the <strong class="bold">Mojarra JSF</strong> (backed by<a id="_idIndexMarker1382"/> Oracle). Other projects extend such implementation, also providing a suite of reusable components. The most famous ones are <strong class="bold">RichFaces</strong> (backed<a id="_idIndexMarker1383"/> by<a id="_idIndexMarker1384"/> Red Hat<a id="_idIndexMarker1385"/> and discontinued for many years), <strong class="bold">IceFaces</strong>, and <strong class="bold">PrimeFaces</strong>.</p>
			<p>This is an overview <a id="_idIndexMarker1386"/>of the internal architecture <a id="_idIndexMarker1387"/>and basics of JSF. Without going into too much detail, let's analyze, as we have done for JSP, the downsides of JSF.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor256"/>JSF – the downsides</h2>
			<p>Let's start by saying<a id="_idIndexMarker1388"/> that, whereas JSP is currently considered legacy but sometimes still used here and there for basic tasks (for simple internal web interfaces such as administration panels), JSF is today avoided wherever possible. The reason for this is that, on top of the JSP's downsides, JSF adds some more. This is what I can say about it:</p>
			<ul>
				<li><strong class="bold">JSF is very hard to learn</strong>: While basic tasks are easy to perform, JSF does a lot of things behind the scenes, such as managing the life cycle of pages and building stateful sessions, that are very hard to master. For this reason, it's common to use it in the wrong way or take advantage of only a small subset of all the features provided, making it overkill and difficult to manage for most web applications.</li>
				<li><strong class="bold">JSF is difficult to test</strong>: Unit tests can be written for some components (such as managed beans) but it is very hard to automate all the tests, especially on the <em class="italic">view</em> side (Facelets), mostly because it's almost impossible to remove logic from that layer (and, as we know, having logic in the <em class="italic">view</em> layer is a terrible idea).</li>
				<li><strong class="bold">JSF is hard to troubleshoot</strong>: Since, as we said, JSF manages many things behind the scenes (above all, the binding of variables handled by the browser with the values contained in the managed beans), it's really hard to understand the cause of things going wrong (such as variables not being updated and performance issues).</li>
				<li><strong class="bold">JSF lacks a proper implementation for some small but very useful features</strong>: The first things here that come to mind are AJAX communication (where some values on a web page are updated without the need of a full-page reload) and friendly URLs (when the URL of a page can be customized, which is helpful because it<a id="_idIndexMarker1389"/> makes it easily readable and favored by search engines). For both of those features, there are some workarounds, but they are incomplete, not standard, and in general have been added late to the framework. Those are just two examples, but there are many; it's all down to a general inflexibility of the framework.</li>
			</ul>
			<p>The preceding points are enough to understand why, as of today, almost everybody agrees with JSF being a legacy technology that must not be adopted in new projects. </p>
			<p>For this reason, it is not worth providing code samples of JSF.</p>
			<p>In this section, we have looked at the two major web technologies built using the JEE framework. As we have seen, these technologies, even if they are still widely used, have some big limitations (especially JSF), mostly coming from their <em class="italic">monolithic</em> approach, meaning that they are tightly coupled with backend implementation, and their limited flexibility.</p>
			<p>In the next section, we will look at the widely used alternative to JEE native web technology – the single-page application.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor257"/>Introducing single-page applications</h1>
			<p><strong class="bold">Single-Page Applications</strong> (or <strong class="bold">SPAs</strong>) is a <a id="_idIndexMarker1390"/>broad term that came about to simply describe the behavior of some solutions meant to create web UIs in a lighter, more modern way. The first characteristic of the SPA is the one that it relates to the name. An SPA, in general, bundles all the assets necessary to start user interaction into a single HTML document and sends it to the client.</p>
			<p>All the following interactions between the client and the server, including loading data, sending data back, and loading other assets (as images or CSS files), are performed within the page using JavaScript. For this reason, SPAs minimize the communication between the client and server (improving performances), avoid the full-page refresh, and allow for a simpler architectural model.</p>
			<p>Indeed, a basic, static<a id="_idIndexMarker1391"/> file-serving web server (such as <strong class="bold">Apache HTTPD</strong> or <strong class="bold">NGINX</strong>) is all you <a id="_idIndexMarker1392"/>need on the frontend (no Java application server is needed). Moreover, the interaction between client and server is almost exclusively limited to web service calls (usually JSON over REST), hence mixing backend and frontend logic (such as doing SQL queries from the frontend layer) is highly discouraged. The most significant downside that I see with SPAs is that there is no standardization of them. Unlike JEE technologies, each framework here provides its own different approach.</p>
			<p>For this reason, there are a number of different, well-written, but incompatible implementations of frameworks for building SPAs. Most (if not all) heavily rely on JavaScript and are independent of what's used in the backend (provided that the backend can expose a compatible services layer, such as JSON over REST). In this context, we take for granted that a Java backend (JEE or something more modern, exposing a REST service) is provided.</p>
			<p>But it is not uncommon for simpler projects to go for a full-stack approach (using JavaScript also on the backend, usually running on<a id="_idIndexMarker1393"/> a server such as <strong class="bold">Node.js</strong>) or using different backend technology (such as Python or PHP). For the sake of brevity in this chapter, we will explore just one<a id="_idIndexMarker1394"/> SPA framework, <strong class="bold">React</strong>, which is backed by Facebook and widely used for building web applications, from small websites to large and popular platforms such as social networks. But it is worth noting that there are a number of similarly powerful alternatives (such as Angular, Vue, and Svelte), and since no standard is provided, there is no guarantee of the life cycle of any such technology, nor is it possible to easily move code written in one implementation to another. In order to start playing with SPAs, a<a id="_idIndexMarker1395"/> preamble on the JavaScript ecosystem will be needed.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor258"/>Basics of the JavaScript ecosystem</h2>
			<p>I suppose<a id="_idIndexMarker1396"/> that most of the readers of <a id="_idIndexMarker1397"/>this book are beginners or experienced Java developers and junior architects, with little or no exposure to JavaScript. Of course, JavaScript is a huge and interesting world that cannot be completely described in just a few paragraphs, so the goal of this section is just to give you the basics, enough for the next couple of sections, which will focus on React. </p>
			<p>JavaScript was born in 1995, mostly for programming inside a web browser. Originally designed for Netscape, it was of course then implemented as part of most major web browsers. Even if the name looks very similar, JavaScript doesn't share that much with the Java language, being interpreted (whereas Java is compiled into bytecode) and dynamically typed (so it checks for type safety at runtime, while Java is statically typed, checking for type safety at build time). And there are a number of other differences, including the object model, APIs, and dependency management. JavaScript has been standardized into a technical<a id="_idIndexMarker1398"/> specification called <strong class="bold">ECMAScript</strong>. </p>
			<p>Another important topic is Node.js. While, as mentioned, JavaScript was initially executed by engines embedded into web browsers, Node.js is a standalone engine, able to execute JavaScript code outside of a web browser. Node.js is used for server-side development, whereas JavaScript is used for developing server-side logic by implementing web services and integrating with other components such as databases. </p>
			<p>The reason I'm mentioning Node.js is not for its use as a backend server (or at least, this is not relevant in this particular context) but because it has evolved as a complete toolbox for JavaScript development. Indeed, it includes <strong class="bold">Node Package Manager</strong> (<strong class="bold">npm</strong>), which <a id="_idIndexMarker1399"/>is a utility for dependency management in JavaScript (conceptually similar to Maven in the Java world).</p>
			<p>Moreover, it's very often used as a local server for JavaScript development, being very lightweight and supporting the hot reloading of updates. Last but not least, a lot of client-side SPA frameworks (including React) distribute utilities for Node.js, such as command-line interfaces, useful for creating the skeleton of a new application, packaging it for distribution, and so on. Now that we have seen the basics of current JavaScript development, is time to have a look at the framework that we have selected for this <a id="_idIndexMarker1400"/>chapter, React, in the next <a id="_idIndexMarker1401"/>section.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor259"/>Introducing the React framework </h2>
			<p><strong class="bold">React</strong> (also known<a id="_idIndexMarker1402"/> as <strong class="bold">ReactJS</strong>) is a<a id="_idIndexMarker1403"/> JavaScript<a id="_idIndexMarker1404"/> framework for building SPAs. A very interesting feature of React is that as well as being used to build web applications to be accessed using a web browser, React can be used (through the React Native project) to build native applications to be executed on mobile platforms (Android and iOS) and desktop (Windows and macOS).</p>
			<p>React is very simple in its approach, which is based on the concept of components (more about that soon). Moreover, it's<a id="_idIndexMarker1405"/> also very efficient because it uses the concept of the <strong class="bold">virtual DOM</strong>.</p>
			<p>Many JavaScript frameworks create web pages and interactions by directly accessing and modifying<a id="_idIndexMarker1406"/> the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>). The DOM is basically the standard object representing the HTML document rendered by the browser, in the form of a tree starting with an HTML tag. </p>
			<p>React uses this alternative approach of building a custom object (called the virtual DOM) that is a partial representation of the DOM, modeling the desired state of the DOM itself (hence the appearance and behavior of the web application). React applications act on this representation. It is then the framework that compares the DOM to the virtual DOM and makes only the necessary updates to the DOM, changing it in an effective and efficient way.</p>
			<h3>JavaScript syntax extension</h3>
			<p><strong class="bold">JavaScript Syntax Extension</strong> (<strong class="bold">JSX</strong>) is a <a id="_idIndexMarker1407"/>technology that's widely used with React. It looks similar to <a id="_idIndexMarker1408"/>HTML and offers the ability to mix JavaScript code with HTML tags. With this in mind, it can be seen as a template technology, not so different from JSP, which we saw a couple of sections ago. It's also worth noting that, just as JSP transforms everything we write to Java code (and, specifically, to a servlet that uses Java code to output HTML), JSX does exactly the same, transforming JSX code into JavaScript code, producing the right HTML. </p>
			<p>It's worth noting that in the JSX world, mixing JavaScript and HTML is not considered an antipattern but is instead encouraged (and often done). This is because even if you implement complex logic with JavaScript, such logic mostly entails frontend-related behaviors (such as when to show one component and optional formatting), so you are less likely to pollute frontend code with things that don't belong in the frontend (such as business logic).</p>
			<p>The reason JSX is so popular is that can be used to define React components with a very compact and understandable syntax. This is what a basic React component might look like without using JSX:</p>
			<p class="source-code">React.createElement('h1', {className: 'welcomeBanner'}, </p>
			<p class="source-code">  `Welcome to our payment system, ${user.fullName} ! `);</p>
			<p>And this is how to implement the same component with JSX:</p>
			<p class="source-code">  &lt;h1 className="welcomeBanner"&gt;</p>
			<p class="source-code">    Welcome to our payment system, {user.fullName} !</p>
			<p class="source-code">  &lt;/h1&gt;</p>
			<p>So, the advantage <a id="_idIndexMarker1409"/>in terms of readability and effectiveness is <a id="_idIndexMarker1410"/>evident. And it would become more evident with more complex cases, such as with tags that include other tags (such as HTML lists or other nested tags). </p>
			<p>Readability and ease of use are not the only qualities of JSX. It's important to note that JSX will also prevent, by default, injection<a id="_idIndexMarker1411"/> attacks. An <strong class="bold">injection attack</strong> is when, using various techniques, a malicious user injects into your page custom code (such as JavaScript code or arbitrary HTML content). JSX, by default, sanitizes the output, hence neutralizing such attacks with no efforts on the development side. Moreover, JSX is a pretty complete language that can embed conditions and loops, call other functions, and so on. It's a very powerful tool for building UIs in React.</p>
			<p>Since we have mentioned React components, it's important now to explain what they are and how they work.</p>
			<h3>Introducing React components</h3>
			<p>The <strong class="bold">component</strong> is a <a id="_idIndexMarker1412"/>core concept of React. It is basically a small, embeddable piece of UI that includes structure, appearance, and behavior logic that can be reused.</p>
			<p>From a technical point of view, React components are JavaScript functions or classes. Components take, by default, a <strong class="source-inline">props</strong> argument, which is basically an object encapsulating the (optional) properties to be passed to the component. So, this is a component modeled using <strong class="source-inline">function</strong> (and JSX):</p>
			<p class="source-code">function HelloWorld(props) {</p>
			<p class="source-code">  return &lt;h1&gt; Welcome to our payment system, </p>
			<p class="source-code">    {props.fullName}&lt;/h1&gt;;</p>
			<p class="source-code">}</p>
			<p>And this is the same component, using a class:</p>
			<p class="source-code">class HelloWorld extends React.Component {</p>
			<p class="source-code">  render() {</p>
			<p class="source-code">    return &lt;h1&gt; Welcome to our payment system, {this.props. </p>
			<p class="source-code">      fullName}&lt;/h1&gt;;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>As you see, the component, whether defined as a function or a class, basically wraps around a JSX template representing the HTML code to be rendered. Whatever way you define it, you can then use it as a tag, in this case <strong class="source-inline">&lt;HelloWorld/&gt;</strong>, which will be replaced with what is evaluated by executing the component logic. It's worth knowing that to pass properties, you can simply use tag attributes, which will be passed as part of the <strong class="source-inline">props</strong> object. So, in our case, to pass <strong class="source-inline">fullName</strong>, it's enough to use the component as <strong class="source-inline">&lt;HelloWorld fullName="Giuseppe Bonocore"/&gt;</strong>.</p>
			<p>You may have noticed that when defined as a class, we are adding our presentation using the <strong class="source-inline">render</strong> method. By default, it is also possible to use the <strong class="source-inline">constructor</strong> method, which takes <strong class="source-inline">props</strong> as a parameter. Such a method can be used to initialize the component. If you need to manage a state in the component (such as when saving local variables), you can do so by accessing the <strong class="source-inline">this.state</strong> object.</p>
			<p>Such an object can be, of course, modified too, for which it is worth using the <strong class="source-inline">this.setState</strong> method, which will notify React that something in the state of the component has changed (and that maybe something in the view must be updated). This can be particularly useful when associated with UI events, such as the click of a button. The following code snippet represents a component with a button. Every time a user clicks on the button, a <a id="_idIndexMarker1413"/>counter is incremented and saved into the local state of the component:</p>
			<p class="source-code">class Counter extends React.Component {</p>
			<p class="source-code">  constructor(props) {</p>
			<p class="source-code">      super(props);</p>
			<p class="source-code">      this.state = {counter: 0};</p>
			<p class="source-code">    }</p>
			<p class="source-code">  render(props) {</p>
			<p class="source-code">     return (</p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;h2&gt;You have clicked {this.state.counter} times </p>
			<p class="source-code">          !&lt;/h2&gt;</p>
			<p class="source-code">        &lt;button onClick={() =&gt; this.setState({ counter: </p>
			<p class="source-code">          this.state.counter + 1 })}&gt;</p>
			<p class="source-code">            Click Me!</p>
			<p class="source-code">        &lt;/button&gt;</p>
			<p class="source-code">      &lt;/div&gt;  </p>
			<p class="source-code">    );</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>From here, of course, more complex combinations of event handling and internal state management can be designed. Last but not least, there are a number of other callbacks associated with the life cycle steps of the React component, such as <strong class="source-inline">componentDidMount</strong>, called after the component is rendered on the web page (but there are many other similar life cycle hooks).</p>
			<h3>React app structure</h3>
			<p>Now, we have <a id="_idIndexMarker1414"/>some basic information on how to create a<a id="_idIndexMarker1415"/> component and where to place our presentation markup and business logic. <em class="italic">But how should we start to create a basic React application and apply the concepts we have just learned about?</em></p>
			<p>The most common and easy way is to use the <strong class="source-inline">npm</strong> utility, which, as we saw a couple of sections ago, comes with the Node.js server. In order to download and install the Node.js server, you can refer <a id="_idIndexMarker1416"/>to the official website at <a href="https://nodejs.org/it/download/">https://nodejs.org/it/download/</a>.</p>
			<p>Once you have a working setup of Node, it is enough to run the following command:</p>
			<p class="source-code">npx create-react-app myAppName</p>
			<p>You'll need to change <strong class="source-inline">myAppName</strong> as needed, of course. Node.js (and <strong class="source-inline">npm</strong>) will then download all the necessary dependencies and create the folder structure and scaffolding for a basic React application.</p>
			<p>Such a structure might look as follows (some files are omitted):</p>
			<p class="source-code">myAppName /</p>
			<p class="source-code">       README.md</p>
			<p class="source-code">node_modules/</p>
			<p class="source-code">package.json</p>
			<p class="source-code">       public/</p>
			<p class="source-code">index.html</p>
			<p class="source-code">src/</p>
			<p class="source-code">index.js</p>
			<p class="source-code">App.js</p>
			<p>The most important files are as follows:</p>
			<ul>
				<li><strong class="source-inline">README.md</strong> is the autogenerated <em class="italic">readme</em> file associated with your project and is used for documentation purposes.</li>
				<li><strong class="source-inline">node_modules</strong> contains the JavaScript dependencies.</li>
				<li><strong class="source-inline">Package.json</strong> contains the project metadata, including the dependencies needed.</li>
				<li><strong class="source-inline">public/index.html</strong> is the page template.</li>
				<li><strong class="source-inline">src/index.js</strong> is the JavaScript file executed as the first file (the entry point).</li>
				<li><strong class="source-inline">src/App.js</strong> is a de facto standard generated by the <strong class="source-inline">create app</strong> utility. It is basically a macro component that includes all the components and references in an <strong class="source-inline">index.js</strong> file.</li>
			</ul>
			<p>So, that is the standard empty folder structure. In order to add our custom components, as per our previous example, we can create a <strong class="source-inline">components</strong> subfolder in <strong class="source-inline">src</strong>.</p>
			<p>Each file containing a component will be a <strong class="source-inline">.js</strong> file named using the name of the component (<em class="italic">with a capital initial letter</em>). For our previous component example, that would be <strong class="source-inline">Counter.js</strong>. </p>
			<p>The file should declare<a id="_idIndexMarker1417"/> the imported dependencies (at least React):</p>
			<p class="source-code">import React from "react";</p>
			<p>Then, make this component available to other components (the last line in the file):</p>
			<p class="source-code">export default Counter;</p>
			<p>In order to use such components in our app, we will need to import them into our <strong class="source-inline">App.js</strong> file as follows:</p>
			<p class="source-code">import Counter from "./components/Counter";</p>
			<p>We can then use them as a tag (<strong class="source-inline">&lt;Counter/&gt;</strong>) in our JSX content. </p>
			<p>Finally, in order to test our React application, you can execute this command from inside the project folder:</p>
			<p class="source-code">npm start</p>
			<p>This will execute the <strong class="source-inline">node.js</strong> server and launch your browser to the right page (<strong class="source-inline">http://localhost:3000/</strong>) to see your application running. Another important aspect of a React application<a id="_idIndexMarker1418"/> is how to interact with the backend APIs. We will look at this in the next section.</p>
			<h3>Interacting with REST APIs</h3>
			<p>What we <a id="_idIndexMarker1419"/>have looked at so far is basically presentation and behavior. A very important feature to consider, in order to implement a real application, is making requests to a backend. A common way to do that is to call REST APIs.</p>
			<p>The standard way to call a REST API from a React application is by using the <strong class="source-inline">axios</strong> library.</p>
			<p>To install the <strong class="source-inline">axios</strong> dependency in React, you can use the <strong class="source-inline">npm</strong> command:</p>
			<p class="source-code">npm install axios</p>
			<p>You will then need to import the library into the component that is going to make REST requests:</p>
			<p class="source-code">import axios from 'axios';</p>
			<p>And you can then use <strong class="source-inline">axios</strong> to make the usual REST calls (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and so on). This is a quick snippet of a REST <strong class="source-inline">get</strong> call reading from an API and saving data to the local state:</p>
			<p class="source-code">axios.get(`http://localhost:8080/rest/payments/find/1`)</p>
			<p class="source-code">  .then(response =&gt; response.data)</p>
			<p class="source-code">        .then((data) =&gt; {</p>
			<p class="source-code">          this.setState({ data: data })</p>
			<p class="source-code">          console.log(this.state.data)</p>
			<p class="source-code">         })</p>
			<p>Of course, this example can be extended to make use of other REST verbs.</p>
			<h3>React – where to go from here</h3>
			<p>The goal of the<a id="_idIndexMarker1420"/> previous sections was to give you a taste of what it's like to program a web interface using a client-side JavaScript framework. React is one of the most popular choices at the time of writing, so I think it's a good investment to learn at least the basics of it. However, what we have just learned is far from being complete. Here are a few more topics that I suggest exploring in more depth:</p>
			<ul>
				<li>Forms and event handling, in order to implement rich user interaction, including validation and file uploads</li>
				<li>Advanced visualizations, such as lists, tables, and conditional formatting</li>
				<li>Packaging and deploying to production, with considerations about file size optimization, progressive web apps, and best practices</li>
				<li>React Native, or how to target alternative platforms to web browsers, such as Android, iPhone, and desktop apps</li>
				<li>Routing (provided by the React Router dependency), which provides a way to implement navigation between different views</li>
			</ul>
			<p>In some cases, React provides a solution, while other times third-party plugins are required. There are a number of resources online; I suggest starting with the official React website and the other resources listed in the <em class="italic">Further reading</em> section. </p>
			<p>Let's quickly recap the evolution of frontend development in Java over time:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/Figure_10.1_B16354.jpg" alt="Figure 10.1 – The evolution of frontend development in Java&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – The evolution of frontend development in Java</p>
			<p>As we can see, <strong class="bold">Servlet</strong> was the first approach and is still somewhat used, regardless of its limitations, for basic use cases and as a supporting technology for more complex frameworks. The same is true for <strong class="bold">JSP</strong> (introduced shortly after <strong class="bold">Servlet</strong>), which provides some advantages (such as having a markup language that allows for development without directly using Java code).</p>
			<p>The usage of JSP has slowed down over time, but it's still used for some use cases. <strong class="bold">JSF</strong> started getting traction after <strong class="bold">JSP</strong> but stopped gaining popularity soon after, and it is now almost completely abandoned and basically only used in legacy applications. SPAs (based on frameworks such as React) have since emerged and are now very popular and widely used.</p>
			<p>With this section, we<a id="_idIndexMarker1421"/> have completed our overview of web frameworks. In the next section, we are going to take a look at mobile application development. </p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor260"/>Learning about mobile application development</h1>
			<p>Mobile application<a id="_idIndexMarker1422"/> development shares a lot of concepts (and challenges) with web application development. However, there are also some core differences. In this section, we are going to analyze some core concepts to keep in mind when designing the architecture of a mobile application.</p>
			<p>In this context, we are mostly referring to mobile applications as a further channel to access the functionalities offered by a more complex ecosystem that is also accessible in other ways (via a web frontend, at least). Also, most of the considerations made in this section should be seen from an enterprise perspective. So, of course, if you are working in a different environment (such as in a start-up), your mileage may vary. First of all, let's start by looking at why we should consider developing a mobile application as a way to enable interaction with our features and functionalities.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor261"/>The importance of mobile applications</h2>
			<p>In today's world, it's trivial to<a id="_idIndexMarker1423"/> point out that a mobile application is often our first point of contact with many services, such as banking, shopping, and entertainment.</p>
			<p>There are around 7 billion mobile users in the world, and it's more and more common for people to possess one or more mobile devices (smartphones and tablets) rather than a laptop or desktop PC.</p>
			<p>Mobile devices offer a regulated environment through application permission settings and app stores that, while being a bit more restrictive, highly improve stability and performance standards. That's often a key reason for choosing app interaction over web interaction – it often offers a more standardized user experience and simpler access.</p>
			<p>Then, of course, there is convenience – it's way easier to complete a task, whether it's purchasing something or just accessing some information, using a device that you have in your pocket compared to having to use a laptop or desktop PC.</p>
			<p>Last but not least, mobile devices are equipped with sensors and functionalities that are key for offering an integrated experience. I can search for a restaurant and immediately call them to book a table or ask for directions while driving there.</p>
			<p>Given all that, it's nowadays the default position to think about a <em class="italic">mobile-first</em> user experience when developing user interactions. But there are a number of challenges to think about.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor262"/>The challenges of mobile application development</h2>
			<p>When it comes to<a id="_idIndexMarker1424"/> the development of mobile applications, the first issue that<a id="_idIndexMarker1425"/> comes to mind is <strong class="bold">fragmentation</strong>. In web applications, modern browsers have almost eliminated incompatibilities between devices, and indeed today you will get the same user experience whether you are using Firefox, Chrome, or Edge on a Macintosh, Windows, or Linux machine. And modern frameworks (such as React, which we saw earlier) make it almost effortless to create such a unified experience.</p>
			<p>This is unfortunately not true for mobile devices:</p>
			<ul>
				<li>First of all, you have the form factor to consider. Different models of smartphones have different screen sizes and ratios. They can be used in landscape or portrait mode. Tablet devices add even more variants to the mix.</li>
				<li>The hardware resources may be limited. The rendering of complex animations or heavily interactive features may slow down some low-end devices.</li>
				<li>Connectivity can be unstable. You have to manage what happens to your application when the bandwidth is low or there is a network interruption.</li>
				<li>Devices often offer additional hardware, such as sensors, cameras, and GPS. However, you have to manage what happens when you have permissions to access such devices and what happens when they are denied.</li>
			</ul>
			<p>Last but not least, there are, at the time of writing, at least two ecosystems to consider, Google and Apple, which have different distribution channels, different supporting services (such as notifications and updates), and different programming languages and frameworks. This last point we are going to discuss in more detail in the next section.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor263"/>Mobile application development options</h2>
			<p>Since the inception<a id="_idIndexMarker1426"/> of mobile application development, a common topic has been how to manage different platforms (or, at least, Google and Apple) and whether there is a way to partially reuse the effort spent on development for other platforms (such as the web).</p>
			<p>The first viable option for reducing fragmentation and leveraging web development efforts is to completely ditch mobile application development and instead go for mobile-optimized web applications. This is a smart option, as with modern web development frameworks and languages (such as HTML5 and CSS3), it's easy to target mobile devices.</p>
			<p>These technologies, other than making it easy to create responsive designs that fit nicely in a mobile-optimized layout, create a standard for accessing the most common mobile features, such as position tracking (via GPS), cameras, and microphones. </p>
			<p>The most important benefit of this approach is that we can manage a single code base. Even if we want to differentiate between the mobile and web versions of our user interface (it's our choice – we could even just have one single version), at least we can have a single version across all mobile devices, regardless of the underlying technology. The second benefit is that we can keep our publishing process outside app stores, so we are not subject to the timing and regulations that are typically enforced by such distribution channels.</p>
			<p>However, there are of<a id="_idIndexMarker1427"/> course some limitations, with the most significant one being performance. Mobile web applications generally perform worse than their native counterparts. That is particularly true for heavily interactive experiences, such as games or very visual user interfaces. Moreover, mobile web applications have more limited options (if any) to run in an offline or limited-connectivity scenario.</p>
			<p>Moreover, mobile web applications are usually less <em class="italic">ergonomic</em> to access, meaning that the user needs to access the browser and load the application. Even if it's possible to use shortcuts, it's still a more uncomfortable experience than directly finding an app icon in an application list (which is also better from a branding perspective). Last but not least, mobile web applications do not benefit from the visibility that can come from app stores.</p>
			<p>A possible alternative to mobile web applications is hybrid applications. In this approach, a mobile web application is enclosed into a native <em class="italic">shell</em>, which basically is just a slimmed-down, full-screen browser used to act as a bridge between a mobile web application and a device. In such a setup, our application can be published to app stores and can access more native features of the host device. Moreover, it is possible to implement unique code bases, or at least that's the case with the two main technologies of Apple and Google. The downside is that performance and access to native hardware devices will still be limited compared to a fully native application. A notable framework to develop hybrid apps is React Native, which we mentioned previously.</p>
			<p>The last option is, obviously, to develop a fully native application. To do that, you will have to use the languages and tools provided for your specific target platform.</p>
			<p>Such languages are commonly Swift or Objective-C for Apple devices, and Java or Kotlin for Android ones. The vendors also distribute development environments and tools for building and distributing the applications.</p>
			<p>In this way, you will have full control over the device's capabilities and can exploit all the available resources, which can be crucial for some applications. The obvious downside is that you will have to manage two completely different development lines, which means having different skills on the team, dedicated build pipelines, and in general, a duplicated effort.</p>
			<p>Regardless of your development choice, you will still have to face a challenge in testing, as checking the application's behavior for all the available platforms properly can be very expensive. In order to partially solve this challenge, it is possible to rely on simulators, which emulate the major mobile devices for testing purposes. Another viable alternative is to use specialized services. There are a number of companies offering a range of<a id="_idIndexMarker1428"/> mobile devices for testing purposes, which can be rented (as cloud resources) and remotely controlled in order to execute test suites.</p>
			<p>In this section, we have looked at web and mobile applications, which are the two most common channels for enterprise services nowadays. But there are some other options that are being used more and more. We are going to learn about them in the next section.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor264"/>Exploring IVR, chatbots, and voice assistants</h1>
			<p>Providing<a id="_idIndexMarker1429"/> more<a id="_idIndexMarker1430"/> channels<a id="_idIndexMarker1431"/> for customer interaction is often a very smart investment. It means reaching more people, having a high customer satisfaction rate, and a reduced need for manual interaction (such as assistance provided by a human operator), which can be expensive and also less effective. These goals are important to achieve, and in this section, we'll look at some ways to do so.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor265"/>Interactive voice response</h2>
			<p><strong class="bold">Interactive Voice Response</strong> (<strong class="bold">IVR</strong>) is <a id="_idIndexMarker1432"/>one kind of technology that helps us achieve the aforementioned goals. It provides a way for a human user to interact with services over a phone call. I think that pretty much every one of us has first-hand experience of interacting with an IVR system, as they are pretty common in helpdesk hotlines. The system offers a number of options to choose from. The user can then choose one of the options using a <strong class="bold">Dual-Tone Multi-Frequency</strong> (<strong class="bold">DTMF</strong>) tone (a <a id="_idIndexMarker1433"/>tone generated by pressing a button on the phone's number pad) or via voice recognition (which can be harder and more expensive to implement than the DTMF method, as it requires speech-to-text capabilities).</p>
			<p>Every option can lead to another set of options. At some point, the customer gets to the desired information, provided by text-to-speech or a recorded message. Another option is to have the call ultimately dispatched to a human operator. While still requiring a human, the presence of the IVR system will most likely filter the most common requests, reducing the number of human operators required, and can provide the operator with data collected from the automatic interactions, such as the user's identity or the problem to resolve.</p>
			<p>Algorithmically, an IVR system basically involves <em class="italic">tree traversing</em>. The customer starts at the root node. At each interaction, the customer is provided with a set of options (the child nodes). The customer can then pick one of the nodes or step back a level (but no further than the root node, of course). At some point, the customer will reach a leaf (the desired information or a human operator).</p>
			<p>IVR systems, as we have seen, involve a lot of different technologies, starting with integrating phone calls (both inbound and outbound) and spanning media handling (recorded voice playback), speech-to-text, and text-to-speech. In other words, they are rarely implemented from scratch. In almost every case, in order to implement an IVR system, it is common to rely on packaged solutions. Asterisk, which is a piece of open source PBX software, is used as a common choice for implementing these kinds of systems. Nowadays, however, SaaS solutions are commonly used, requiring just configuration tweaks in order to implement the desired behavior. And since the interaction is so standardized with packaged solutions, and in terms of branding you're limited to the provided <a id="_idIndexMarker1434"/>recorded voices, a custom IVR implementation is not worth the effort.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor266"/>Chatbots</h2>
			<p><strong class="bold">Chatbots</strong> are basically<a id="_idIndexMarker1435"/> the same concept transposed to text chats. They achieve the same goal (providing a customized user experience while reducing pressure on human operators), but they don't require text-to-speech, speech-to-text, or recorded voice messages.</p>
			<p>The interaction can still be modeled as a tree by providing multiple options to the customer. However, it is common for most chatbot platforms to provide freeform input to customers and try to interpret what the customer is looking for, by parsing the messages and doing what is <a id="_idIndexMarker1436"/>called <strong class="bold">Natural Language Processing</strong> (<strong class="bold">NLP</strong>). This process can be complex, involving looking for keywords to analyze the customer's request or even decoding the meaning of the customer's entire message.</p>
			<p>Chatbots are less <em class="italic">invasive</em> than IVR, as they don't require integration with phone infrastructures. There are a number of frameworks available for implementing such solutions, and they are often identified as a perfect use case for the serverless deployment model (see <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>). However, as with IVR technology, it is unusual to implement such solutions from scratch nowadays, and it's more common to rely on packaged applications or SaaS solutions.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor267"/>Voice assistants</h2>
			<p><strong class="bold">Voice assistants</strong> are one <a id="_idIndexMarker1437"/>of the most modern takes on the same issue. Conceptually, voice assistants are kind of a mix between the user experience provided by an IVR system and the one provided by a chatbot. From a user's perspective, voice assistants are consumed from a proprietary hardware and software stack, implemented by what is commonly called a <em class="italic">smart speaker</em>. The most widespread implementations at the time of writing are Google Home and Amazon Alexa. </p>
			<p>This topic is particularly hot, as currently voice assistant applications are still in their infancy, and implementing one is a really unique feature. However, to do so, you will require specific skills, and each vendor relies on proprietary SDKs to build their platforms, which are usually hosted and powered by the cloud provider behind them (AWS and Google Cloud Platform).</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor268"/>Omnichannel strategy in enterprise applications</h1>
			<p>In this chapter, we <a id="_idIndexMarker1438"/>explored a number of <a id="_idIndexMarker1439"/>different options for user interaction, from web applications (which are the most common channel for user interaction), through mobile applications, to some alternative channels, such as IVR, chatbots, and voice assistants.</p>
			<p>This opens up a big consideration as to which is the best strategy to go for. Indeed, it is pretty common for enterprise applications to provide many, if not all, of these channels at once. And as a user, we want to interact with applications and get the same information and the same user experience regardless of the channel used.</p>
			<p>This poses some serious challenges, from user identity to state management.</p>
			<p>There are a number of ways to face such challenges. </p>
			<p>The most important thing is to provide a unified backend for all channels. To do so, it is common to use the same services (for example, for identifying a user or searching for saved information) and wrap things using a mediation layer (also <a id="_idIndexMarker1440"/>known as a <em class="italic">backend for frontend</em>) in order to optimize the inputs and outputs for a specific device (such as a phone call, a mobile application, or a web user interface). In this way, we can make sure that we provide the same results regardless of what channel is used for interaction.</p>
			<p>In doing so, we will provide what is <a id="_idIndexMarker1441"/>called <strong class="bold">multichannel</strong> functionality – the same features are available on different channels and devices (of course, with minor modifications due to the limitations of each device). But there is a further step that can be taken for a more complete user experience, and this is called <strong class="bold">omnichannel</strong> functionality. With <a id="_idIndexMarker1442"/>an omnichannel experience, the user can switch channels during a complex transaction and continue an operation started on a different kind of device with limited or no impact on the user experience and the final result.</p>
			<p>The classical example is a mortgage application. A user can call an IVR system asking for information to start a mortgage application. This mortgage application can then be continued using a web application, where the customer can more comfortably provide personal information. After an asynchronous approval process, the customer can then be notified on a mobile app of the mortgage application outcome and complete the process in the mobile app itself.</p>
			<p>In order to implement an omnichannel approach, our enterprise application must be capable of storing the state and details of multi-step transactions (such as the mortgage application in our example) in<a id="_idIndexMarker1443"/> a so-called <em class="italic">state machine</em>, commonly implemented as a business workflow (as seen in <a href="B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing Application Integration and Business Automation</em>). It will then be necessary to implement some services to interact with the workflow from the desired channel (as previously mentioned, using a mediator or backend-for-frontend pattern).</p>
			<p>A common strategy is also to <em class="italic">codify</em> some checks (possibly by using a business rule) in order to identify which step can be implemented by which specific channel (and device), as due to the specificity of each channel, it may be impossible (or at least not advisable) to perform certain steps on certain devices. A typical example is IVR. It is usually difficult to properly identify a customer over a phone call. It is possible to check the phone number and to ask for a PIN, but this may be not enough for some operations that are better suited to a mobile device (where we can ask for biometric authentication) or a web application (where we can <a id="_idIndexMarker1444"/>enforce <strong class="bold">Two-Factor Authentication</strong> (<strong class="bold">2FA</strong>)).</p>
			<p>With this section, we<a id="_idIndexMarker1445"/> have completed our <a id="_idIndexMarker1446"/>overview of the most common interaction channels for our users. </p>
			<p>Let's summarize what we have learned in this chapter.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor269"/>Summary</h1>
			<p>In this chapter, we have explored the core server-side web technologies provided by the JEE platform (JSP and JSF). We explored the pros and cons of these technologies and the main ideas behind them, including interaction with other JEE technologies and standards.</p>
			<p>We then moved on to client-side frameworks for building SPAs. We saw how simple and powerful the React framework is and how it can be used to implement componentized interfaces.</p>
			<p>We also studied the basics of mobile application development, which is now essential to provide a complete customer experience and can leverage some of the concepts of web application development.</p>
			<p>Moreover, we had a look at other interaction channels, such as phone calls (using IVR systems), text chats (using chatbots), and voice assistants. Lastly, we looked at some considerations on how to harmonize all those technologies into a multichannel and omnichannel user experience.</p>
			<p>In the next chapter, we are going to focus on the data layer. This will include coverage of relational databases as well as alternatives, such as key-value stores and NoSQL. This will represent another fundamental layer of application architecture.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor270"/>Further reading</h1>
			<ul>
				<li>The Eclipse Foundation – the JSP specification<em class="italic"> </em>(<a href="https://projects.eclipse.org/projects/ee4j.jsp">https://projects.eclipse.org/projects/ee4j.jsp</a>)</li>
				<li><em class="italic">The Problems with JSP</em>, <em class="italic">Jason Hunter</em> (<a href="http://servlets.com/soapbox/problems-jsp.html">http://servlets.com/soapbox/problems-jsp.html</a>)</li>
				<li>Jakarta EE – the JSF specification (<a href="https://jakarta.ee/specifications/faces/">https://jakarta.ee/specifications/faces/</a>)</li>
				<li><em class="italic">Why You Should Avoid JSF</em>, <em class="italic">Jens Schauder</em> (<a href="https://dzone.com/articles/why-you-should-avoid-jsf">https://dzone.com/articles/why-you-should-avoid-jsf</a>)</li>
				<li>Meta Platforms, Inc. – the official React website (<a href="https://reactjs.org/">https://reactjs.org/</a>)</li>
				<li>W3Schools – <em class="italic">React Tutorial</em> (<a href="https://www.w3schools.com/react/">https://www.w3schools.com/react/</a>)</li>
			</ul>
		</div>
	</body></html>