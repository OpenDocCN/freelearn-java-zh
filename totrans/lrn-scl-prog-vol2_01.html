<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building Blocks of Scala</h1>
                
            
            <article>
                
<p class="calibre2"/>
<div class="packt_quote">"You can't build a great building on a weak foundation. You must have a solid foundation if you're going to have a strong superstructure."</div>
<div class="packt_quote1">- Gordon B. Hinckley</div>
<p class="calibre2">Our aim as programmers is to provide a solution to a problem through some logical implementation. Programming languages work as a tool for just that. When we implement a solution to a problem, we must be able to describe the problem (specification) so that a programming language can verify (verification) whether the solution indeed solves the problem.</p>
<div class="cdpaligncenter"><img src="../images/00009.jpeg" class="calibre20"/></div>
<div class="cdpaligncenter1">Problem Solution</div>
<p class="calibre2">For implementation, we use various programming constructs, which are basic entities with some syntactic rules. These entities work as building blocks for any programming language. In Scala, we have similar syntax to almost any other programming language. We use <kbd class="calibre11">keyword/name/classifier/bound-entity</kbd><em class="calibre18">.</em> In this chapter, our aim is to get familiar with some of the building blocks. We'll go through:</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">val</kbd> and <kbd class="calibre11">var</kbd> keywords</li>
<li class="calibre8">Literals</li>
<li class="calibre8">Data types</li>
<li class="calibre8">Type Inference</li>
<li class="calibre8">Operators</li>
<li class="calibre8">Wrapper classes</li>
<li class="calibre8">String interpolation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is underneath a Scala program?</h1>
                
            
            <article>
                
<p class="calibre2">A Scala program is a tree of nested definitions. A definition may start with a keyword, definition's name, a classifier, and if it's a concrete definition, then also an entity to which that definition is bound. So the syntax is regular, just like any other programming language has <kbd class="calibre11">keyword/name/classifier/bound-entity</kbd>. Let's take an example. We'll use Scala REPL to see how a simple Scala program is built. For that, let's import a Scala package named <kbd class="calibre11">universe</kbd>:</p>
<pre class="calibre19">scala&gt; import scala.reflect.runtime.universe._ <br class="title-page-name"/>import scala.reflect.runtime.universe._ </pre>
<p class="calibre2">This <kbd class="calibre11">import</kbd> clause brings all the definitions within the <kbd class="calibre11">universe</kbd> package in scope. It means that the required functions we are going to use are in scope, and available for us to use. Then we'll use a <kbd class="calibre11">reify</kbd> method, which returns an <kbd class="calibre11">Expr</kbd> to construct <kbd class="calibre11">tree</kbd> out of our simple Scala program expression. We passed a Scala class to our <kbd class="calibre11">reify</kbd> method. Let's pretend that a Scala class encapsulates some members like a value with the name <kbd class="calibre11">segment</kbd><em class="calibre18"> </em>and a<em class="calibre18"> </em><kbd class="calibre11">name</kbd><em class="calibre18"> </em>definitions. We'll talk about all these members as we go along in subsequent sections. For now, let's execute this line and see what we get in response:</p>
<pre class="calibre19">scala&gt; val expr = reify {class Car {val segment="SUV"; def name="Q7"}} <br class="title-page-name"/>expr: reflect.runtime.universe.Expr[Unit] = <br class="title-page-name"/>Expr[Unit]({ <br class="title-page-name"/>  class Car extends AnyRef { <br class="title-page-name"/>    def &lt;init&gt;() = { <br class="title-page-name"/>      super.&lt;init&gt;(); <br class="title-page-name"/>      () <br class="title-page-name"/>    }; <br class="title-page-name"/>    val segment = "SUV"; <br class="title-page-name"/>    def name = "Q7" <br class="title-page-name"/>  }; <br class="title-page-name"/>  () <br class="title-page-name"/>}) </pre>
<p class="calibre2">The preceding code shows Scala's <kbd class="calibre11">reify</kbd> method's response. It looks like alien code (only for now) that we have no idea about, so let's find out what's meaningful to us. We know which is somewhat using the class <kbd class="calibre11">Car</kbd> that we passed to generate some code. We recognize this <kbd class="calibre11">Car</kbd> class<em class="calibre18"> </em>and that it's extending some construct named <kbd class="calibre11">AnyRef</kbd><em class="calibre18">.</em> Every class we define in Scala is a subclass of <kbd class="calibre11">AnyRef</kbd>, hence we can see the interpreter has shown the explicit view of our class definition with modifiers, constructors, and members that we defined. We'll use the <kbd class="calibre11">showRaw(expr.tree)</kbd> method to print tree:</p>
<pre class="calibre19">scala&gt; showRaw(expr.tree) <br class="title-page-name"/>res0: String = Block(List(ClassDef(Modifiers(), TypeName("Car"), List(), Template(List(Ident(TypeName("AnyRef"))), noSelfType, List(DefDef(Modifiers(), termNames.CONSTRUCTOR, List(), List(List()), TypeTree(), Block(List(Apply(Select(Super(This(typeNames.EMPTY), typeNames.EMPTY), termNames.CONSTRUCTOR), List())), Literal(Constant(())))), ValDef(Modifiers(), TermName("segment"), TypeTree(), Literal(Constant("SUV"))), DefDef(Modifiers(), TermName("name"), List(), List(), TypeTree(), Literal(Constant("Q7"))))))), Literal(Constant(()))) </pre>
<p class="calibre2">Now, we'll take a closer look at the response <kbd class="calibre11">res0</kbd><em class="calibre18">.</em> The expression started with <kbd class="calibre11">Block</kbd><em class="calibre18">,</em> that'<em class="calibre18">s</em> a tree representing the class we defined. Our class <kbd class="calibre11">Car</kbd> contained a value declaration named <kbd class="calibre11">segment</kbd>, and a method named <kbd class="calibre11">name</kbd><em class="calibre18">.</em> The representation of our class as a tree contains all the entities that we defined. And these together construct our program. A tree that we got using the method <kbd class="calibre11">showRaw(tree)</kbd><em class="calibre18"> </em>give us the skeleton of the program we wrote. The tree has String literals like <kbd class="calibre11">SUV</kbd> and <kbd class="calibre11">Q7</kbd>, value definitions like <kbd class="calibre11">segment</kbd>, and other meaningful constructs. We'll learn the basics of these literals and types of data in Scala in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Vals and vars</h1>
                
            
            <article>
                
<p class="calibre2">While writing our Scala programs, we can define our member fields using either <kbd class="calibre11">val</kbd> or <kbd class="calibre11">var</kbd> keywords<strong class="calibre1">.</strong> When we use a <kbd class="calibre11">val</kbd> keyword to assign a value to any attribute, it becomes a value<strong class="calibre1">.</strong> We're not allowed to change that value in the course of our program. So a <kbd class="calibre11">val</kbd> declaration is used to allow only immutable data binding to an attribute. Let's take an example:</p>
<pre class="calibre19">scala&gt; val a = 10<br class="title-page-name"/>a: Int = 10</pre>
<p class="calibre2">Here, we have used a <kbd class="calibre11">val</kbd> keyword with an attribute named <kbd class="calibre11">a</kbd>, and assigned it a value <kbd class="calibre11">10</kbd>. Furthermore, if we try to change that value, the Scala compiler will give an error saying: <kbd class="calibre11">reassignment to val</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">scala&gt; a = 12<br class="title-page-name"/>&lt;console&gt;:12: error: reassignment to val<br class="title-page-name"/>    a = 12</pre>
<p class="calibre2">Scala recommends use of <kbd class="calibre11">val</kbd> as much as possible to support immutability. But if an attribute's value is going to change in the course of our program, we can use the <kbd class="calibre11">var</kbd> declaration:</p>
<pre class="calibre19">scala&gt; var b = 10<br class="title-page-name"/>b: Int = 10</pre>
<p class="calibre2">When we define an attribute using a <kbd class="calibre11">var</kbd> keyword, we're allowed to change its value. The <kbd class="calibre11">var</kbd> keyword here stands for variable, which may vary over time:</p>
<pre class="calibre19">scala&gt; b = 12<br class="title-page-name"/>b: Int = 12</pre>
<p class="calibre2">If you take a closer look at our declaration of value <kbd class="calibre11">a</kbd>, you will find that we're not providing the <em class="calibre18">type</em> information anywhere, but still the Scala interpreter is able to infer the type of defined value, which in our case is an integer. That happens because of the Scala compiler's type inference characteristic. We'll learn about Scala's type inference later on in this chapter. Scala's compiler is able to infer the type of declared value. So it's up to the programmer if he/she wants to explicitly give type information for good readability of the code, or let Scala do this job for him/her. In Scala, we can explicitly give types after the attribute's name:</p>
<pre class="calibre19">scala&gt; val a: String = "I can be inferred."<br class="title-page-name"/>a: String = I can be inferred.</pre>
<p class="calibre2">This is a bit different to how we declare fields in Java. First, we use a <span><kbd class="calibre11">val</kbd> or <kbd class="calibre11">var</kbd> </span> <span>keyword </span>, then we give its type, and then give a literal value. Here, it's a <kbd class="calibre11">String</kbd> literal. When we explicitly define type information for an attribute, then the value we give to it should justify to the type specified:</p>
<pre class="calibre19">scala&gt; val a: Int = "12"<br class="title-page-name"/>&lt;console&gt;:11: error: type mismatch;<br class="title-page-name"/>found : String("12")<br class="title-page-name"/>required: Int<br class="title-page-name"/>    val a: Int = "12"</pre>
<p class="calibre2">The preceding code is not going to work for us, because the type specified is <kbd class="calibre11">Int</kbd>, and the literal bound to our attribute is a <kbd class="calibre11">String</kbd>, and as expected, Scala gifted an error saying type mismatch<em class="calibre18">.</em> Now that we know that the bound value to our attribute is a literal, I think we're ready to discuss literals in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Literals</h1>
                
            
            <article>
                
<p class="calibre2">In the previous discussion, we've seen a String literal and an Integer too. Here, we'll discuss all available literals, and how to define them in Scala. If you're coming from a Java background, then quite a few will be the same for you: Integer, Floating point, Boolean, Character, and String are similar. Along with those, the Tuple and Function literals can be treated as something new to learn. All the literals are listed as follows:</p>
<ul class="calibre7">
<li class="calibre8">Integer literals</li>
<li class="calibre8">Floating point literals</li>
<li class="calibre8">Boolean literals</li>
<li class="calibre8">Character literals</li>
<li class="calibre8">String literals</li>
<li class="calibre8">Symbol literals</li>
<li class="calibre8">Tuple literals</li>
<li class="calibre8">Function literals</li>
</ul>
<p class="calibre2">We'll discuss them one by one. Let's start with Integer literals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integer literals</h1>
                
            
            <article>
                
<p class="calibre2">Numeric literals can be expressed in the form of decimal, octal, or hexadecimal forms. These are basic integer values that can be signed or unsigned. Octal values are deprecated since version 2.10, so if you try out a numeric with a leading <kbd class="calibre11">0</kbd>, it'll give you a compile time error:</p>
<pre class="calibre19">scala&gt; val num = 002<br class="title-page-name"/>&lt;console&gt;:1: error: Decimal integer literals may not have a leading zero. (Octal syntax is obsolete.)<br class="title-page-name"/>val num = 002<br class="title-page-name"/>    ^</pre>
<p class="calibre2">If you define a literal with prefix <kbd class="calibre11">0x</kbd> or <kbd class="calibre11">0X</kbd>, it's going to be a hexadecimal literal. Also, the Scala interpreter prints these values as a decimal value. For example:</p>
<pre class="calibre19">scala&gt; 0xFF<br class="title-page-name"/>res0: Int = 255</pre>
<p class="calibre2">The value to be printed is converted to its decimal equivalent, and then printed. Hexadecimal literals can contain digits (0 to 9) and letters (A to F) in upper/lower case. Integer literals are further classified into different types such as <kbd class="calibre11">Int</kbd>, <kbd class="calibre11">Long</kbd>, <kbd class="calibre11">Byte</kbd>, and <kbd class="calibre11">Short</kbd> literals. These literals are divided based on the range of values. The following table shows the minimum and maximum values for specified types:</p>
<table class="msotablegrid">
<tbody class="calibre21">
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><strong class="calibre1">Type</strong></p>
</td>
<td class="calibre23">
<p class="calibre2"><strong class="calibre1">Minimum value</strong></p>
</td>
<td class="calibre23">
<p class="calibre2"><strong class="calibre1">Maximum value</strong></p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">Int</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">-2^31</p>
</td>
<td class="calibre23">
<p class="calibre2">2^31 - 1</p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">Long</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">-2^63</p>
</td>
<td class="calibre23">
<p class="calibre2">2^63- 1</p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">Short</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">-2^15</p>
</td>
<td class="calibre23">
<p class="calibre2">2^15 - 1</p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">Byte</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">-2^7</p>
</td>
<td class="calibre23">
<p class="calibre2">2^7 - 1</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">If we try to define any literal outside of these ranges for specified types, the compiler is going to give some error stating type mismatch:</p>
<pre class="calibre19">scala&gt; val aByte: Byte = 12<br class="title-page-name"/>aByte: Byte = 12</pre>
<p class="calibre2">Here, we defined a normal <kbd class="calibre11">Byte</kbd> value with type information given explicitly. If we try to give a value that is out of the range for a <kbd class="calibre11">Byte</kbd>, the compiler will try to convert that value to an integer, and then try to assign it to the attribute, but will fail to do so:</p>
<pre class="calibre19">scala&gt; val aByte: Byte = 123456<br class="title-page-name"/>&lt;console&gt;:20: error: type mismatch;<br class="title-page-name"/>found : Int(123456)<br class="title-page-name"/>required: Byte<br class="title-page-name"/>    val aByte: Byte = 123456</pre>
<p class="calibre2">This happened because the compiler tries to assign the converted value of <kbd class="calibre11">Int(123456)</kbd> to <kbd class="calibre11">aByte</kbd>, which is of <kbd class="calibre11">Byte</kbd> type. Hence, the types do not match. If we do not use type explicitly, then Scala itself is capable of inferring the type due to type inference. What if we try to assign an attribute, an integer value that does not come under any of the mentioned ranges? Let's try:</p>
<pre class="calibre19">scala&gt; val outOfRange = 123456789101112131415<br class="title-page-name"/>&lt;console&gt;:1: error: integer number too large<br class="title-page-name"/>val outOfRange = 123456789101112131415</pre>
<p class="calibre2">In these cases, the Scala compiler is smart enough to sense that things are out of control, and gives this error message stating integer number too large.</p>
<p class="calibre2">To define <kbd class="calibre11">long</kbd> literals, we put the character <kbd class="calibre11">L</kbd> or <kbd class="calibre11">l</kbd> at the end of our literal. Otherwise, we can also give type information for our attribute:</p>
<pre class="calibre19">scala&gt; val aLong = 909L<br class="title-page-name"/>aLong: Long = 909<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val aLong = 909l<br class="title-page-name"/>aLong: Long = 909<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val anotherLong: Long = 1<br class="title-page-name"/>anotherLong: Long = 1</pre>
<p class="calibre2">The <kbd class="calibre11">Byte</kbd> and <kbd class="calibre11">Short</kbd> values can be defined by explicitly telling the interpreter about the type:</p>
<pre class="calibre19">scala&gt; val aByte : Byte = 1<br class="title-page-name"/>aByte: Byte = 1<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val aShort : Short = 1<br class="title-page-name"/>aShort: Short = 1</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Floating point literals</h1>
                
            
            <article>
                
<p class="calibre2">Floating point literals include a decimal point that can be at the beginning or in between decimal digits, but not at the end. What we mean by this is that if you write the following statement, it won't work:</p>
<pre class="calibre19">scala&gt; val a = 1. //Not possible!</pre>
<p class="calibre2">It won't work if you try this in Scala REPL, the expression will be continued in the next line. A quick trick: if you give two more returns in REPL, it'll start a new command. But this is how we cannot create a floating point in Scala, so now let's see how we can define a <kbd class="calibre11">Double</kbd> or a <kbd class="calibre11">Float</kbd> value. By default, Scala treats decimal point values as <kbd class="calibre11">Double</kbd>, if we don't specify it to be a <kbd class="calibre11">Float</kbd>:</p>
<p class="calibre2"> </p>
<pre class="calibre19">scala&gt; val aDoubleByDefault = 1.0<br class="title-page-name"/>aDoubleByDefault: Double = 1.0</pre>
<p class="calibre2">We can specify our values to be of <kbd class="calibre11">Float</kbd> type the same way we did for <kbd class="calibre11">Long</kbd> literals but with an invisible asterisk. Let's check that condition:</p>
<p class="calibre2"> </p>
<pre class="calibre19">scala&gt; val aFloat: Float = 1.0 //Compile Error!<br class="title-page-name"/>scala&gt; val aFloat: Float = 1.0F //Works<br class="title-page-name"/>scala&gt; val aFloat: Float = 1.0f //Works</pre>
<p class="calibre2">All three were supposed to work and give us <kbd class="calibre11">Float</kbd> values but unfortunately only the latter two give back a <kbd class="calibre11">Float</kbd> value. The first one is going to give a type mismatch error stating what you specified is a <kbd class="calibre11">Float</kbd>, and what you bound is of <kbd class="calibre11">Double</kbd> type. So in Scala, to specify a literal to be of <kbd class="calibre11">Float</kbd> value, we'll have to give suffix <kbd class="calibre11">f</kbd> or <kbd class="calibre11">F</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">scala&gt; val aFloat: Float = 1.0<br class="title-page-name"/>&lt;console&gt;:11: error: type mismatch;<br class="title-page-name"/>found : Double(1.0)<br class="title-page-name"/>required: Float<br class="title-page-name"/>    val aFloat: Float = 1.0<br class="title-page-name"/>        ^</pre>
<p class="calibre2">Then we can optionally append <kbd class="calibre11">D</kbd> or <kbd class="calibre11">d</kbd> for a <kbd class="calibre11">Double</kbd> value, but we hardly do so. Floating point literals can also have an exponential part in it. That is going to be an <kbd class="calibre11">e</kbd> or <kbd class="calibre11">E</kbd> followed by an optional <kbd class="calibre11">+</kbd> or <kbd class="calibre11">-</kbd>, then few digits. <kbd class="calibre11">E</kbd> or <kbd class="calibre11">e</kbd> indicates the power of 10. So a value 3.567e2 means 3.567 multiplied by 10^2, which is 356.7, that is, 3.567 times 100.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Boolean literals</h1>
                
            
            <article>
                
<p class="calibre2">These are simple, they indicate 0 or 1, which mean true or false<em class="calibre18">.</em> The basic use of Boolean literals is for operating on comparisons, or conditions. These two are called Boolean literal, which can't be replaced by 0 or 1:</p>
<pre class="calibre19">scala&gt; val aBool: Boolean = 1<br class="title-page-name"/>&lt;console&gt;:11: error: type mismatch;<br class="title-page-name"/>found : Int(1)<br class="title-page-name"/>required: Boolean<br class="title-page-name"/>    val aBool: Boolean = 1<br class="title-page-name"/>        ^</pre>
<p class="calibre2">To define a Boolean value, we simply give <kbd class="calibre11">true</kbd> or <kbd class="calibre11">false</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">scala&gt; val aBool = true<br class="title-page-name"/>aBool: Boolean = true<br class="title-page-name"/>scala&gt; val aBool = false<br class="title-page-name"/>aBool: Boolean = false</pre>
<p class="calibre2">That's all for Boolean literals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Character literals</h1>
                
            
            <article>
                
<p class="calibre2">What if you want to break down some words and spaces into separate characters? If you do so, you're creating Character literals. We represent Character literals in single quotes. Any Unicode character or escape sequence can be represented as a Character literal. What's an escape sequence, by the way? Let's take this <kbd class="calibre11">backslash</kbd> for example. If we try this:</p>
<pre class="calibre19">scala&gt; val aChar = '\'<br class="title-page-name"/>&lt;console&gt;:1: error: unclosed character literal<br class="title-page-name"/>val aChar = '\'</pre>
<p class="calibre2">This will not work at all, because this <kbd class="calibre11">'\'</kbd> is an escape character. By definition, an escape sequence or character is something that does not represent itself in String or Character literal. To define these characters, we use this sequence:</p>
<pre class="calibre19">scala&gt; val doublequotes = "\""<br class="title-page-name"/>doublequotes: String = "<br class="title-page-name"/>scala&gt; val aString = doublequotes + "treatme a string" + doublequotes<br class="title-page-name"/>aString: String = "treatme a string"</pre>
<p class="calibre2">In the preceding code, we used our <kbd class="calibre11">doublequotes</kbd> as prefix and suffix to our string <kbd class="calibre11">treatme a string</kbd>, and get a response.</p>
<p class="calibre2">We've a list of escape sequence characters shown in the following table:</p>
<table class="msotablegrid">
<tbody class="calibre21">
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><strong class="calibre1">Sequence</strong></p>
</td>
<td class="calibre23">
<p class="calibre2"><strong class="calibre1">Value</strong></p>
</td>
<td class="calibre23">
<p class="calibre2"><strong class="calibre1">Unicode</strong></p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\b</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">Backspace</p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\u0008</kbd></p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\t</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">Horizontal Tab</p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\u0009</kbd></p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\r</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">Carriage Return</p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\u000D</kbd></p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\n</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">Line Feed</p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\u000A</kbd></p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\f</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">Form Feed</p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\u000C</kbd></p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\"</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">Double Quote</p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\u0022</kbd></p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\\</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">Backslash</p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\u005C</kbd></p>
</td>
</tr>
<tr class="calibre22">
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\'</kbd></p>
</td>
<td class="calibre23">
<p class="calibre2">Single Quote</p>
</td>
<td class="calibre23">
<p class="calibre2"><kbd class="calibre11">\u0027</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">You can also use the hex code to represent a Character literal, but we need to put a <kbd class="calibre11">\u</kbd> preceding it:</p>
<pre class="calibre19">scala&gt; val c = '\u0101'<br class="title-page-name"/>c: Char = ā</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">String literals</h1>
                
            
            <article>
                
<p class="calibre2">We've already used <kbd class="calibre11">String</kbd> literals in several places at this point. So here, apart from a formal introduction to what a <kbd class="calibre11">String</kbd> literal is, we'll take a look at how <kbd class="calibre11">String</kbd> literals in Scala are different, since there's more than one way to write <kbd class="calibre11">String</kbd> literals. Up till now we've declared <kbd class="calibre11">String</kbd> literals within double quotes:</p>
<pre class="calibre19">scala&gt; val boringString = "I am a String Literal."<br class="title-page-name"/>boringString: String = I am a String Literal.</pre>
<p class="calibre2">So let's start with a <kbd class="calibre11">String</kbd> literal declaration within triple quotes. Sounds interesting! Isn't it? Take a look at this:</p>
<pre class="calibre19">scala&gt; val interestingString = """I am an Interesting String<br class="title-page-name"/>    | Also span in multiple Lines!<br class="title-page-name"/>    | Ok, That's it about me"""<br class="title-page-name"/>interestingString: String =<br class="title-page-name"/>"I am an Interesting String</pre>
<pre class="calibre19">Also span in multiple Lines!<br class="title-page-name"/>Ok, That's it about me"</pre>
<p class="calibre2">Got an idea about it after seeing it? A string quoted in triple quotes can be spanned over multiple lines, thus they are called multi-line string literals. These are also called raw strings, because if you try to give any escape character inside triple quotes, these multi-line string literals treat them as normal characters:</p>
<pre class="calibre19">scala&gt; val aString = """ / " ' """<br class="title-page-name"/>aString: String = " / " ' "<br class="title-page-name"/>scala&gt; println(aString)<br class="title-page-name"/><br class="title-page-name"/>/ " '</pre>
<p class="calibre2">So these escape characters are treated as defined if inside multi-line strings. This can contain any character, even spaces. There's more to strings, such as string interpolation, where we can dynamically assign values to a string from the current scope. For that, we use interpolators. We'll study these further a little later on in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Symbol literals</h1>
                
            
            <article>
                
<p class="calibre2">A symbol has a name, and it can be defined as a single quote (') followed by alphanumeric identifier:</p>
<pre class="calibre19">scala&gt; val aSymbol = 'givenName<br class="title-page-name"/>aSymbol: Symbol = 'givenName<br class="title-page-name"/><br class="title-page-name"/>scala&gt; aSymbol.name<br class="title-page-name"/>res10: String = givenName</pre>
<p class="calibre2">We don't use symbols a lot in normal Scala programs. If we try to dig down deeper into symbols in Scala, we get to know that everything that we define in Scala and give a name to is a symbol. We can check the absolute type for a symbol:</p>
<pre class="calibre19">scala&gt; import scala.reflect.runtime.universe._<br class="title-page-name"/>import scala.reflect.runtime.universe._<br class="title-page-name"/><br class="title-page-name"/>scala&gt; typeOf[Symbol]<br class="title-page-name"/>res12:reflect.runtime.universe.Type= scala.reflect.runtime.universe.Symbol</pre>
<p class="calibre2">So this <kbd class="calibre11">Symbol</kbd> is from Scala's reflection package. We're not going to dig any deeper. If you're curious though, I would recommend going through the Scala documentation at <a href="http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html" class="calibre10">http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html</a>.</p>
<p class="calibre2">So that's all about Symbol literals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tuple literals</h1>
                
            
            <article>
                
<p class="calibre2">Tuple is a data type in Scala. We'll discuss the type in this chapter later on. First, let's take a look at how we can define a literal of the same type<span>:</span></p>
<pre class="calibre19">scala&gt; val aTuple = ("Val1", "Val2", "Val3")<br class="title-page-name"/>aTuple: (String, String, String) = (Val1,Val2,Val3)<br class="title-page-name"/>scala&gt; println("Value1 is: " + aTuple._1)<br class="title-page-name"/>Value1 is: Val1</pre>
<p class="calibre2">Here, we defined a <kbd class="calibre11">Tuple3</kbd>, which took three parameters that are in parentheses and comma separated. Its type is going to be <kbd class="calibre11">Tuple3</kbd>, the same way we can define <kbd class="calibre11">TupleN</kbd> with <kbd class="calibre11">N</kbd> being 1 to 22. Take a closer look at the REPL response for the first declaration:</p>
<pre class="calibre19">aTuple: (String, String, String) = (Val1,Val2,Val3)</pre>
<p class="calibre2">Here <kbd class="calibre11">aTuple</kbd> has a <kbd class="calibre11">Type (String, String, String)</kbd><em class="calibre18">,</em> so as we assigned values to our identifier, <kbd class="calibre11">aTuple</kbd> Scala was able to construct type based on values we gave. Tuple values can be accessed using a special underscore syntax. Here, we use the tuple attribute name, along with an underscore (_), followed by the index of value. In our example, we're using <kbd class="calibre11">val1</kbd>, so we gave <em class="calibre18"/><kbd class="calibre11">aTuple._1 value</kbd>.</p>
<p class="calibre2">A tuple with two elements is also called a <strong class="calibre1">Pair</strong>, it can be defined using the <em class="calibre18">arrow assoc</em> (<kbd class="calibre11">-&gt;</kbd>) operator:</p>
<pre class="calibre19">scala&gt; val smartPair = 1 -&gt; "One"<br class="title-page-name"/>smartPair: (Int, String) = (1,One)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Function literals</h1>
                
            
            <article>
                
<p class="calibre2">Function literals are a syntactical way of representing a function. The basic structure of a function is something that can take some parameters and return a response. If we've to represent a function that takes an <kbd class="calibre11">Int</kbd> value and respond in <kbd class="calibre11">String</kbd>, it will be like this:</p>
<pre class="calibre19">Int =&gt; String</pre>
<p class="calibre2">The left-hand side represents the input parameters, and the right-hand side gives parameters that are response type. The type of preceding function literal is <kbd class="calibre11">Function1[Int, String]</kbd><em class="calibre18">,</em> and parameters <kbd class="calibre11">Int</kbd> and <kbd class="calibre11">String</kbd> are representing input and output parameters respectively. We'll discuss these more when we talk about functions in subsequent chapters.</p>
<p class="calibre2">We have discussed how literals are represented in Scala, and now that we know this, we've got a heads up to go ahead with data types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Data types</h1>
                
            
            <article>
                
<p class="calibre2">We have just covered literals in Scala, and with that, we've almost covered the introduction to all the data types existing as well. We discussed how to define <kbd class="calibre11">Int</kbd>, <kbd class="calibre11">Long</kbd>, <kbd class="calibre11">Short</kbd>, and <kbd class="calibre11">Byte</kbd> data types. Along with these, we also covered <kbd class="calibre11">Float</kbd> and <kbd class="calibre11">Double</kbd> type. Together, all these are called numeric data types. The <kbd class="calibre11">Byte</kbd>, <kbd class="calibre11">Short</kbd>, and <kbd class="calibre11">Char</kbd> are called <strong class="calibre1">sub-range types</strong><em class="calibre18">.</em> We also talked about Boolean, character, and strings:</p>
<div class="cdpaligncenter"><img class="image-border4" src="../images/00010.jpeg"/></div>
<div class="cdpaligncenter1">Numeric value types</div>
<p class="calibre2">In Java, these numeric types are called <strong class="calibre1">Primitive Types</strong>, and then there are user-defined types as well. But in Scala, these somewhat similar types to primitives, are called <strong class="calibre1">value types</strong>. Objects of these value types are not represented by an object in the underlying runtime system. Thus, arithmetic operations performed are in the form of methods defined for <kbd class="calibre11">Int</kbd>, and other numeric value types. Think about it, it means that we can perform method operations on these. So let's take an example:</p>
<pre class="calibre19">scala&gt; val x = 10 //x is an object of Type Int<br class="title-page-name"/>x: Int = 10  //x is assigned value 10<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val y = 16 //y is an object of Type Int<br class="title-page-name"/>y: Int = 16 //y is assigned value 16<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val z = x + y //z is addition of x and y's value<br class="title-page-name"/>z: Int = 26</pre>
<p class="calibre2">As you can see, <kbd class="calibre11">x</kbd> and <kbd class="calibre11">y</kbd> are two Integer objects created, and there's another named <em class="calibre18"><kbd class="calibre11">z</kbd>.</em> The result is <kbd class="calibre11"><em class="calibre18">z</em></kbd>, addition of <kbd class="calibre11">x</kbd> and <kbd class="calibre11">y</kbd><em class="calibre18">.</em> The sign <em class="calibre18">+</em> here is a method on the <kbd class="calibre11">Int</kbd> object, which means more than just an operator, it's a method that is defined for <kbd class="calibre11">Int</kbd> types and expects a parameter of <kbd class="calibre11">Int</kbd> type. This is going to have a definition similar :</p>
<pre class="calibre19">scala&gt; def +(x: Int): Int = ??? //Some definition<br class="title-page-name"/>$plus: (x: Int)Int</pre>
<p class="calibre2">What do we get from this? It means that the construct is more powerful because the methods look more natural and can also be written for other types. And that's how it's written for <kbd class="calibre11">Int</kbd>. Let's try this:</p>
<pre class="calibre19">scala&gt; val aCharAndAnInt = 12 + 'a'<br class="title-page-name"/>aCharAndAnInt: Int = 109</pre>
<p class="calibre2">This happened because there's a method + overloaded for the type character. Something like this:</p>
<pre class="calibre19">scala&gt; def +(x: Char): Int = ???<br class="title-page-name"/>$plus: (x: Char)Int</pre>
<p class="calibre2">You may refer to the class <kbd class="calibre11">Int.scala</kbd> at <a href="http://www.scala-lang.org/api/2.12.0/scala/Int.html" class="calibre10">http://www.scala-lang.org/api/2.12.0/scala/Int.html</a>, and go through how these methods are structured. I would recommend taking a closer look at the source of this class, and see if there's anything particular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala's class hierarchy</h1>
                
            
            <article>
                
<p class="calibre2">Let's discuss Scala's class hierarchy, and also a few extra types that exist, such as bottom types in Scala. Scala has a unified type hierarchy, which means there's only one top-level class that's <kbd class="calibre11">Any</kbd>, and all other types extend directly or indirectly from this top-level type. It also means that any class that we define or a class pre-existing in Scala, has access to universal methods defined in the top-level class <kbd class="calibre11">Any</kbd><em class="calibre18">.</em> Two variants of a relationship shown in the following figure are <strong class="calibre1">subtypes</strong> and <strong class="calibre1">view</strong><em class="calibre18">.</em> The first one, <em class="calibre18">subtypes</em> depicts a relationship between two types, whereas the latter one shows that one type can be typecasted to another one. View relations are shown for value types, where a <kbd class="calibre11">Char</kbd> can be typecasted into <kbd class="calibre11">Int</kbd><em class="calibre18">.</em></p>
<p class="calibre2">The following figure shows the relationship between classes in Scala:</p>
<div class="cdpaligncenter"><img src="../images/00011.jpeg" class="calibre24"/></div>
<div class="cdpaligncenter1">Scala class hierarchy</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Any</h1>
                
            
            <article>
                
<p class="calibre2">A little excerpt from Scala's official website about the <em class="calibre18">root</em> of all classes:</p>
<p class="calibre2">"<em class="calibre18">Class</em> <em class="calibre18">Any is the root of the Scala class hierarchy. Every class in a Scala execution environment inherits directly or indirectly from this class. Starting with Scala 2.10 it is possible to directly extend</em> <em class="calibre18">Any using universal traits. A universal trait is a trait that extends</em> <em class="calibre18">Any</em><em class="calibre18">, only has</em> <em class="calibre18">def</em><em class="calibre18">s as members, and does no initialization.</em>"</p>
<p class="calibre2">Yes, <kbd class="calibre11">Any</kbd> is the super class of all the existing or defined classes in Scala. If you don't know what inheritance or super class is, here's a quick example for you. Let's say we defined a type <em class="calibre18">Item</em> for our newly opened store's order management application. Each <em class="calibre18">Item</em> has some parameters such as <kbd class="calibre11">id</kbd>. We further want to categorize our items and come up with several item categories, such as <kbd class="calibre11">ElectronicItem</kbd> and others. Now, <kbd class="calibre11">ElectronicItem</kbd> can be a subtype of <kbd class="calibre11">Item</kbd><em class="calibre18">,</em> and <kbd class="calibre11">Item</kbd> will be called a super type of <kbd class="calibre11">ElectronicItem</kbd>, hence it doesn't have to declare those three parameters again, and can use them directly to assign values. Take a look:</p>
<pre class="calibre19"><strong class="calibre1">import </strong>java.util.UUID<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">class </strong>Item {<br class="title-page-name"/><strong class="calibre1">  val </strong>id: UUID = UUID.randomUUID()<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">class </strong>ElectronicItem(<strong class="calibre1">val </strong>name: String, <strong class="calibre1">val </strong>subCategory: String) <strong class="calibre1">extends </strong>Item {<br class="title-page-name"/><strong class="calibre1">val </strong>uuid: String = <strong class="calibre1">"Elec_" </strong>+ id<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">object </strong>CartApp <strong class="calibre1">extends </strong>App {<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  def </strong>showItem(item: ElectronicItem) = println(<strong class="calibre1">s"Item id: </strong><strong class="calibre1">$</strong>{item.id}<strong class="calibre1"> uuid: </strong><strong class="calibre1">$</strong>{item.uuid} <strong class="calibre1">name: </strong><strong class="calibre1">$</strong>{item.name}<strong class="calibre1">"</strong>)<br class="title-page-name"/><br class="title-page-name"/>  showItem(<strong class="calibre1">new </strong>ElectronicItem(<strong class="calibre1">"Xperia"</strong>, <strong class="calibre1">"Mobiles"</strong>))<br class="title-page-name"/>  showItem(<strong class="calibre1">new </strong>ElectronicItem(<strong class="calibre1">"IPhone"</strong>, <strong class="calibre1">"Mobiles"</strong>))<br class="title-page-name"/> }</pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Item id: 16227ef3-2569-42b3-8c5e-b850474da9c4 uuid: Elec_16227ef3-2569-42b3-8c5e-b850474da9c4 name: Xperia<br class="title-page-name"/><br class="title-page-name"/>Item id: 1ea8b6af-9cf0-4f38-aefb-cd312619a9d3 uuid: Elec_1ea8b6af-9cf0-4f38-aefb-cd312619a9d3 name: IPhone</pre>
<p class="calibre2">This example shows what we intended with inheritance. "The <kbd class="calibre11">ElectronicItem</kbd> function extends <kbd class="calibre11">Item</kbd>" that means "every <kbd class="calibre11">ElectronicItem</kbd> is an item." That's why we're able to refer to ID, UUID, and the name from an <kbd class="calibre11">ElectronicItem</kbd> instance. We've used the <kbd class="calibre11">import</kbd> statement to bring UUID type in scope of our compilation unit, so that when we use UUID, it should not give a compile-time error.</p>
<p class="calibre2">Now, as we discussed, every class is a subclass of <kbd class="calibre11">Any</kbd><em class="calibre18">.</em> Hence, we have access to all non-private members of <kbd class="calibre11">Any</kbd><em class="calibre18">.</em> Methods like <em class="calibre18"><kbd class="calibre11">!=</kbd> , <kbd class="calibre11">==</kbd></em>, <kbd class="calibre11">asInstanceOf</kbd>, <kbd class="calibre11">equals</kbd>, <kbd class="calibre11">isInstanceOf</kbd><em class="calibre18">,</em> <kbd class="calibre11">toString</kbd>, and <kbd class="calibre11">hashCode</kbd> are defined in <kbd class="calibre11">Any</kbd> class. These are in the form of:</p>
<pre class="calibre19">final def  !=  (that: Any): Boolean <br class="title-page-name"/>final def  ==  (that: Any): Boolean<br class="title-page-name"/>def isInstanceOf[a]: Boolean<br class="title-page-name"/>def equals(that: Any): Boolean<br class="title-page-name"/>def ##: Int<br class="title-page-name"/>def hashCode: Int<br class="title-page-name"/>def toString: String</pre>
<p class="calibre2">And yes! You can override these non-final methods, which means you can have your own definition of these.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">AnyVal and AnyRef</h1>
                
            
            <article>
                
<p class="calibre2">Both <kbd class="calibre11">AnyVal</kbd> and <kbd class="calibre11">AnyRef</kbd> are two subclasses of root class <kbd class="calibre11">Any</kbd><em class="calibre18">.</em> These two represent two families of types in Scala: the first ones are object references, the latter are value classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">AnyRef</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">AnyRef</kbd> class represents all values that are/can be represented as objects in the underlying runtime system. It includes all user-defined classes that explicitly do not inherit from <kbd class="calibre11">AnyVal</kbd>. Some standard reference classes are <kbd class="calibre11">String</kbd>, <kbd class="calibre11">Tuple</kbd>, <kbd class="calibre11">Function</kbd>, and <kbd class="calibre11">Array</kbd>. The Scala compiler either provides syntactic sugar for them, or generates special code at the time of compilation for their operations. We've already seen a bit of syntactic sugar such as <kbd class="calibre11">Tuple2</kbd>, which can be represented as <kbd class="calibre11">(A, B)</kbd> where A and B are type parameters. An applied form of this <kbd class="calibre11">Tuple2</kbd> can be (<kbd class="calibre11">String</kbd> and <kbd class="calibre11">Int</kbd>). In Scala, we represent this as <kbd class="calibre11">Tuple2[String, Int]</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">AnyVal</h1>
                
            
            <article>
                
<p class="calibre2">The latter, <kbd class="calibre11">AnyVal</kbd>, represents values not implemented as objects in the underlying runtime system. Scala has some predefined numeric and non-numeric value classes as shown in the class hierarchy.</p>
<p class="calibre2">It's possible to define user-defined value types as well, with some conditions applied. Remember I asked you to take a closer look at the source of the <kbd class="calibre11">Int.scala</kbd> file? You may have noticed that there are no <kbd class="calibre11">val</kbd><span><span> </span></span> or <kbd class="calibre11">var</kbd> declarations in the class <kbd class="calibre11">Int</kbd> that extends <kbd class="calibre11">AnyVal</kbd><em class="calibre18">.</em> This is one of the constraints of defining a subtype of <kbd class="calibre11">AnyVal</kbd><em class="calibre18">.</em> One of the reasons you might consider defining an <kbd class="calibre11">AnyVal</kbd> type is to avoid object instantiation at runtime. Some of the constraints are:</p>
<ul class="calibre7">
<li class="calibre8">It must have a single <kbd class="calibre11">val</kbd> parameter that is the underlying representation. It means that if you declare <kbd class="calibre11">class Num(val underlying: Int) extends AnyVal</kbd><strong class="calibre1"><em class="calibre18">,</em></strong> then the compile time representation of it will be of type <kbd class="calibre11">Num</kbd>, but at runtime it'll be converted to <kbd class="calibre11">Int</kbd>, and methods defined within will be used as statics.</li>
<li class="calibre8">It must define only <kbd class="calibre11">def</kbd>, no <kbd class="calibre11">val</kbd>, <kbd class="calibre11">var</kbd>, nested classes, traits, or objects.</li>
<li class="calibre8">It can only extend <em class="calibre18">universal traits, traits</em> that extend only the super type <em class="calibre18">Any.</em></li>
<li class="calibre8">It can't be used for pattern-matching, or type tests.</li>
</ul>
<p class="calibre2">Scala's implementation of <kbd class="calibre11">AnyVal</kbd> includes nine implementations. Out of them, <kbd class="calibre11">Byte</kbd>, <kbd class="calibre11">Short</kbd>, <kbd class="calibre11">Int</kbd>, <kbd class="calibre11">Long</kbd>, <kbd class="calibre11">Char</kbd>, <kbd class="calibre11">Float</kbd>, and <kbd class="calibre11">Double</kbd> are numeric value types, while Boolean and Unit are non-numeric types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit</h1>
                
            
            <article>
                
<p class="calibre2">Scala's <kbd class="calibre11">Unit</kbd> is a subtype of <kbd class="calibre11">AnyVal</kbd>, and the implementation contains the equals method, which returns a true value if the passed argument is also a <kbd class="calibre11">Unit</kbd> which means a value <kbd class="calibre11">()</kbd>, that is, just a pair of parentheses otherwise false. Other methods are <kbd class="calibre11">hashCode</kbd> and <kbd class="calibre11">toString</kbd>, which return an implementation-specific hash code and <kbd class="calibre11">()</kbd> respectively, because Unit has only one value: <kbd class="calibre11">()</kbd>, which is equivalent to Java's <kbd class="calibre11">void</kbd> type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Boolean</h1>
                
            
            <article>
                
<p class="calibre2">A Boolean represents two values: <kbd class="calibre11">true</kbd> and <kbd class="calibre11">false</kbd>. As expected, it implements Boolean arithmetic methods such as <em class="calibre18">and</em>, <em class="calibre18">or</em>, <em class="calibre18">strict and</em>, <em class="calibre18">strict or</em>, <em class="calibre18">equality</em>, <em class="calibre18">inequality</em>, and negation in the form of <kbd class="calibre11">&amp;&amp;</kbd>, <kbd class="calibre11">||</kbd>, <kbd class="calibre11">&amp;</kbd>, <kbd class="calibre11">|</kbd>, <kbd class="calibre11">==</kbd>, <kbd class="calibre11">!=</kbd>, and <kbd class="calibre11">unary_</kbd>! respectively. Boolean also implements <kbd class="calibre11">equals</kbd>, <kbd class="calibre11">hashCode</kbd>, and <kbd class="calibre11">toString</kbd> from the class <kbd class="calibre11">Any</kbd>.</p>
<p class="calibre2">The equals method checks for argument evaluation and returns its result, while <kbd class="calibre11">hashCode</kbd> returns a fixed implementation-specific hash code based on value <kbd class="calibre11">true</kbd> or <kbd class="calibre11">false</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Null and Nothing</h1>
                
            
            <article>
                
<p class="calibre2">Null and Nothing are called <strong class="calibre1">Bottom types</strong> in Scala. Why do we need these Bottom types? Take a look at the code snippet:</p>
<pre class="calibre19">def checkIF10AndReturn20(x: Int): Int =  {<br class="title-page-name"/>  if(x == 10)<br class="title-page-name"/>    x * 2<br class="title-page-name"/>  else <br class="title-page-name"/>    throw new Exception("Sorry, Value wasn't 10")<br class="title-page-name"/> }</pre>
<p class="calibre2">The method <kbd class="calibre11">checkIf10AndReturn20</kbd> expects a returned value of <kbd class="calibre11">Int</kbd> type, but what's happening here is different. If the passed argument value is not 10, we are throwing an exception, yet still the compiler is OK with our code. How can this be possible?</p>
<p class="calibre2">This is because of Type Inference. It always looks for common types in both branches of an <kbd class="calibre11">if</kbd> statement, so if in the other branch, the type extends everything, then the inferred type will automatically be the first one. In Scala, <kbd class="calibre11">Nothing</kbd> is a subtype of everything, hence the inferred type automatically becomes of type <kbd class="calibre11">Int</kbd>. Let's visualize this:</p>
<div class="cdpaligncenter"><img src="../images/00012.jpeg" class="calibre25"/></div>
<div class="cdpaligncenter1">Visualizing Types Inferred</div>
<p class="calibre2">With this, it's important to understand that Type Inference plays an important role in Scala's ecosystem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Type inference</h1>
                
            
            <article>
                
<p class="calibre2">We can call type inference a built-in Scala feature that permits us to omit type information while writing code. This means we don't have to specify the type while declaring any variables; Scala compiler can do it for us:</p>
<pre class="calibre19">scala&gt; val treatMeAString = "Invisible"<br class="title-page-name"/>treatMeAString: String = Invisible</pre>
<p class="calibre2">We did not specify our <kbd class="calibre11">val</kbd>, to be of <kbd class="calibre11">String</kbd> type, but seeing the value of <kbd class="calibre11">Invisible</kbd>, Scala compiler was able to infer its type. Also with some constraints, we can also omit the method's return types:</p>
<pre class="calibre19">defcheckMeImaString(x: Boolean) = if(x) "True"else "False"</pre>
<p class="calibre2">Here we did not give the return type, as Scala compiler was able to infer its type. But for recursive methods, this doesn't work. The famous factorial method expects you to specify the return type if implementation is recursive:</p>
<pre class="calibre19">def recursiveFactorial(n: Int) = if(n == 0) 1 else recursiveFactorial(n-1) <br class="title-page-name"/>//Recursive method recursiveFactorial needs result type</pre>
<p class="calibre2">Scala uses a constraints-driven algorithm to implement type inference. It means that Scala compiler tries to infer constraints, and then attempts to unify the type. We're talking about <em class="calibre18">constraints</em>, but what are they? A constraint is a statement about the types of expression. And even if it's not an expression, for example, when we bind a value to a variable, we must deduce their type too. But first think about what we can deduce from the type of an expression:</p>
<ul class="calibre7">
<li class="calibre8">If it is related to the type of some identifier</li>
<li class="calibre8">If it is related to the type of some other expression</li>
<li class="calibre8">If it is a base type, such as numbers and Booleans</li>
<li class="calibre8">If it is a constructed type such as a function, whose domain and range types are further constrained</li>
</ul>
<p class="calibre2">Scala compiler uses this approach to deduce constraints and then apply unification (explanation is beyond the scope of this book) to infer the type. In instances where we can't take out any statements about an expression, inferring type is impossible:</p>
<pre class="calibre19">scala&gt; val x = x =&gt; x<br class="title-page-name"/>&lt;console&gt;:11: error: missing parameter type<br class="title-page-name"/>       val x = x =&gt; x</pre>
<p class="calibre2">Because of type inference only, we're able to use <em class="calibre18">syntactic sugar</em> for cases where we're not expected to specify types:</p>
<pre class="calibre19">scala&gt; List(1,4,6,7,9).filter(_+1 &gt; 5)<br class="title-page-name"/>res0: List[Int] = List(6, 7, 9)</pre>
<p class="calibre2">Exciting, isn't it? This way, we've performed our logic simply with less information about types. The underscore (<kbd class="calibre11">_</kbd>) used is syntactic sugar, and it's possible to use here because of type inference.</p>
<p class="calibre2">We'll continue our good work and learn about implementing this, perform operations using all these types, and strengthen our basics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operators in Scala</h1>
                
            
            <article>
                
<p class="calibre2">Based on the way we use them, the Scala operators can be classified into three types:</p>
<ul class="calibre7">
<li class="calibre8">Infix operators</li>
<li class="calibre8">Prefix operators</li>
<li class="calibre8">Postfix operators</li>
</ul>
<p class="calibre2">We use operators to perform some operation on operands, which is obvious, and the way we implement makes them infix, prefix, or postfix. A basic example of an infix operator is addition <kbd class="calibre11">+</kbd>:</p>
<pre class="calibre19">scala&gt; val x = 1 + 10<br class="title-page-name"/>x: Int = 11</pre>
<p class="calibre2">We have two operands (1 and 10) on which this addition operation is being performed. We've already discussed that <em class="calibre18">operators are methods.</em> It means that somehow the operation is being performed as <kbd class="calibre11">1.+(10)</kbd>, and <kbd class="calibre11">1 + 10</kbd> is just syntactic sugar of how we can write this. This is possible because the method + is defined for the given types. Here, in our case, the addition (+) method is defined for <kbd class="calibre11">Int</kbd><em class="calibre18">.</em> Along with this, there are several versions of overloaded methods that support other numeric value types as well. It means that we can pass in any other type and it'll be a normal addition operation performed, given that the overloaded version of that method is present:</p>
<pre class="calibre19">scala&gt; val y = 1 + 'a'<br class="title-page-name"/>y: Int = 98</pre>
<p class="calibre2">Here, the method <kbd class="calibre11">def+(arg: Char): Int</kbd> is invoked and has given an <kbd class="calibre11">Int</kbd> as a result. Think about it, if these methods are not native Scala operators and are methods, then we can also create methods like these that work as operators. This makes you feel powerful. Let's try this:</p>
<pre class="calibre19">class Amount(val amt: Double) {<br class="title-page-name"/><br class="title-page-name"/>  def taxApplied(tax: Double) = this.amt * tax/100 + this.amt<br class="title-page-name"/><br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/>object Order extends App {<br class="title-page-name"/>  val tax = 10<br class="title-page-name"/>  val firstOrderAmount = 130<br class="title-page-name"/><br class="title-page-name"/>  def amountAfterTax(amount: Amount) = amount taxApplied tax<br class="title-page-name"/><br class="title-page-name"/>  println(s"Total Amount for order:: ${amountAfterTax(new Amount(firstOrderAmount))}")<br class="title-page-name"/> }</pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Total Amount for order:: 143.0</pre>
<p class="calibre2">Great! <kbd class="calibre11">taxApplied</kbd> is the first operator that we defined, it is defined for the type <kbd class="calibre11">Amount</kbd><em class="calibre18">.</em> Our program has a class <kbd class="calibre11">Amount</kbd> that is just a <kbd class="calibre11">Double</kbd> value, and defines a method <kbd class="calibre11">taxApplied</kbd><em class="calibre18">.</em> This method expects a double value for <kbd class="calibre11">tax</kbd> to be applied on <kbd class="calibre11">this</kbd> which is going to be the current value for the amount. Operators are a way we can use methods, which is why we have this operator. We've used it in object, <kbd class="calibre11">Order</kbd> while defining a function, <kbd class="calibre11">amountAfterTax</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">&gt; amount taxApplied tax</pre>
<p class="calibre2">It can also be written as <kbd class="calibre11">amount.taxApplied(tax)</kbd><em class="calibre18">.</em> There are also a few examples in Scala; for example, the <kbd class="calibre11">indexOf</kbd> operator that works on <kbd class="calibre11">String</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">scala&gt; val firstString = "I am a String"<br class="title-page-name"/>firstString: String = I am a String<br class="title-page-name"/><br class="title-page-name"/>scala&gt; firstString indexOf 'a'<br class="title-page-name"/>res1: Int = 2</pre>
<p class="calibre2">We've talked about <em class="calibre18">infix</em> operators, where the operator sits between two operands. Now let's take a look at another way of using operators, that is, <em class="calibre18">prefix</em> and <em class="calibre18">postfix.</em> The first one, <em class="calibre18">prefix</em> operators, sits before an operand. Examples of these are <kbd class="calibre11">-</kbd>, <kbd class="calibre11">!</kbd>, and so on:</p>
<pre class="calibre19">scala&gt; def truthTeller(lie: Boolean) = !lie<br class="title-page-name"/>truthTeller: (lie: Boolean)Boolean<br class="title-page-name"/><br class="title-page-name"/>scala&gt; truthTeller(false)<br class="title-page-name"/>res2: Boolean = true</pre>
<p class="calibre2">Here, <kbd class="calibre11">!lie</kbd><em class="calibre18">,</em> uses the <em class="calibre18">prefix</em> operator <kbd class="calibre11">!</kbd>, and this is the way we put an operand to the right of our operator. But this is getting invoked as a method. What happens in the background is that Scala uses <kbd class="calibre11">unary_</kbd> to call these operators, and that's obvious because these operators use only one operand. So our implementation looks something like the following:</p>
<pre class="calibre19">scala&gt; def truthTeller(lie: Boolean) = lie.unary_!<br class="title-page-name"/>truthTeller: (lie: Boolean)Boolean</pre>
<p class="calibre2">The operator <kbd class="calibre11">!</kbd> is defined for Boolean types, hence we were allowed to make calls on Boolean. The other way is where the operand sits on the left side, called <em class="calibre18">postfix</em> operators. Examples of these operators are convertors such as <kbd class="calibre11">toLowerCase</kbd>, <kbd class="calibre11">toInt</kbd>, <kbd class="calibre11">toString</kbd>, and so on:</p>
<pre class="calibre19">scala&gt; 1.toString<br class="title-page-name"/>res4: String = 1<br class="title-page-name"/><br class="title-page-name"/>scala&gt; "1".toInt<br class="title-page-name"/>res5: Int = 1<br class="title-page-name"/><br class="title-page-name"/>scala&gt; "ABC".toLowerCase<br class="title-page-name"/>res7: String = abc</pre>
<p class="calibre2">It means that these operators are defined as methods in the corresponding types. This is one way to classify operators in Scala. Now we'll go and have a quick look at types of operators based on the context they are used in programming languages. These are basically classified as:</p>
<ul class="calibre7">
<li class="calibre8">Arithmetic operators</li>
<li class="calibre8">Relational operators</li>
<li class="calibre8">Logical operators</li>
<li class="calibre8">Bitwise operators</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Arithmetic operators</h1>
                
            
            <article>
                
<p class="calibre2">We can perform arithmetic operations using the arithmetic operators. Arithmetic operators contain operators for addition (+), subtraction (-), multiplication (*), division (/), and remainder (%). We've already seen many examples for addition, not mentioning that these operators are methods!</p>
<p class="calibre2">Let's take examples of others:</p>
<pre class="calibre19">scala&gt; val x = 10 - 1<br class="title-page-name"/>x: Int = 9<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val y = 10 * 1<br class="title-page-name"/>y: Int = 10<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val z = 10 / 1<br class="title-page-name"/>z: Int = 10<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val yx = 10 % 9<br class="title-page-name"/>yx: Int = 1</pre>
<p class="calibre2">These operators have their overloaded versions also defined, to see that we may try with different types as operands. Let's take an <kbd class="calibre11">Int</kbd> and <kbd class="calibre11">Double</kbd>:</p>
<pre class="calibre19">scala&gt; val yx = 10 % 9.0<br class="title-page-name"/>yx: Double = 1.0</pre>
<p class="calibre2">Here, the first operand is an <kbd class="calibre11">Int</kbd>, and the second one is a <kbd class="calibre11">Double</kbd>, and since <kbd class="calibre11">Int</kbd> is view-bounded to <kbd class="calibre11">Double</kbd>, the result is converted to <kbd class="calibre11">Double</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Relational operators</h1>
                
            
            <article>
                
<p class="calibre2">Relational operators are used to compare two operands. We have quite enough of these, ==, !=, &gt;, &lt;, &gt;= and &lt;=. Let's try them:</p>
<pre class="calibre19">scala&gt; val equal_op = 10 == 10<br class="title-page-name"/>equal_op: Boolean = true<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val not_eq_op = 10 != 10<br class="title-page-name"/>not_eq_op: Boolean = false<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val gt_than_op = 10 &gt; 10<br class="title-page-name"/>gt_than_op: Boolean = false<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val gt_than_op = 11 &gt; 10<br class="title-page-name"/>gt_than_op: Boolean = true<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val lt_than_op = 11 &lt; 10<br class="title-page-name"/>lt_than_op: Boolean = false<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val gt_eq_op = 11 &gt;= 11<br class="title-page-name"/>gt_eq_op: Boolean = true<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val lt_eq_op = 11 &lt;= 11<br class="title-page-name"/>lt_eq_op: Boolean = true</pre>
<p class="calibre2">With these operators, we compare two operands for their values, and these operations yield a Boolean result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Logical operators</h1>
                
            
            <article>
                
<p class="calibre2">Logical operators include <kbd class="calibre11">!</kbd> (NOT), <kbd class="calibre11">&amp;&amp;</kbd> (AND), and <kbd class="calibre11">||</kbd> (OR), and obviously we use these to perform logical operations on operands. These methods are written for Boolean, so they expect Boolean operands:</p>
<pre class="calibre19">scala&gt; val log_not = !true<br class="title-page-name"/>log_not: Boolean = false<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val log_or = true || false<br class="title-page-name"/>log_or: Boolean = true<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val log_and = true &amp;&amp; true<br class="title-page-name"/>log_and: Boolean = true</pre>
<p class="calibre2">Logical AND and OR are short-circuiting operators. It means that these are only evaluated till the result is undetermined. This is achievable in Scala even though operators are methods, because of a feature of function calls named <em class="calibre18">by-name parameters.</em> It allows us to pass parameters by name that get evaluated later on when required at the time of method call.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bitwise operators</h1>
                
            
            <article>
                
<p class="calibre2">We can perform operations on individual bits of Integer types using Bitwise operators. These includes Bitwise AND (&amp;), OR (|), and XOR (^):</p>
<pre class="calibre19">scala&gt; 1 &amp; 2<br class="title-page-name"/>res2: Int = 0<br class="title-page-name"/><br class="title-page-name"/>scala&gt; 1 | 2<br class="title-page-name"/>res3: Int = 3<br class="title-page-name"/><br class="title-page-name"/>scala&gt; 1 ^ 2<br class="title-page-name"/>res5: Int = 3</pre>
<p class="calibre2">These operators can be performed only on <kbd class="calibre11">Int</kbd>. If you try this on <kbd class="calibre11">Double</kbd>, it'll throw an error: <em class="calibre18">value &amp; is not a member of Double.</em> These operators perform operations on individual bits; in our case, 1 is converted into bits as 01 and 2 as 10, and then AND, OR, and XOR operations are performed:</p>
<ul class="calibre7">
<li class="calibre8">0001 AND 0010 resulted into 00 means 0</li>
<li class="calibre8">0001 OR 0010 resulted into 11 means 3</li>
<li class="calibre8">0001 XOR 0010 resulted into 11 means 3</li>
</ul>
<p class="calibre2">We can perform a logical not-operating using <kbd class="calibre11">~</kbd> operator:</p>
<pre class="calibre19">scala&gt; ~2<br class="title-page-name"/>res8: Int = -3</pre>
<p class="calibre2">There are also <em class="calibre18">three shift methods</em> for <kbd class="calibre11">Int</kbd> types named <em class="calibre18">shift right (&gt;&gt;), shift left (&lt;&lt;) and unsigned-shift right (&gt;&gt;&gt;).</em> These are binary operators working on two operands. Bits of operand on the left are shifted by value to the right.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operator precedence</h1>
                
            
            <article>
                
<p class="calibre2">Operations such as <em class="calibre18">2 + 3 * 4 / 2 - 1</em> can give different results if there's no rule for evaluation of these. Hence we have some precedence-based rules for these. We're going to talk about it in this part:</p>
<pre class="calibre19">scala&gt; 2 + 3 * 4 / 2 - 1<br class="title-page-name"/>res15: Int = 7</pre>
<p class="calibre2">For reference purposes, we have the preceding expression. The evaluation gives back the result <em class="calibre18"><kbd class="calibre11">7</kbd>.</em> How?</p>
<p class="calibre2">The expression <em class="calibre18">(2 + ((3 * 4) / 2))) - 1</em> is evaluated in the following steps:</p>
<ol class="calibre13">
<li value="1" class="calibre8"><em class="calibre18">(2 + (12 / 2)) - 1</em></li>
<li value="2" class="calibre8"><em class="calibre18">(2 + 6) - 1</em></li>
<li value="3" class="calibre8"><em class="calibre18">8 - 1</em></li>
<li value="4" class="calibre8"><em class="calibre18">7</em></li>
</ol>
<p class="calibre2">It's based on operator precedence. That's in the following order:</p>
<div class="cdpaligncenter"><img src="../images/00013.jpeg" class="calibre26"/></div>
<div class="cdpaligncenter1">Operator precedence</div>
<p class="calibre2">As shown in the preceding figure, Scala operator expressions are evaluated based on the precedence shown. As per the figure, <strong class="calibre1">*</strong>, <strong class="calibre1">/</strong>, and <strong class="calibre1">%</strong> are of top priority, then comes <strong class="calibre1">+</strong> and <strong class="calibre1">-</strong>.</p>
<p class="calibre2">Other operators also follow the same precedence as shown. If operators of the same precedence level appear together, the operands are evaluated from left to right. It means that the expression <kbd class="calibre11">1 + 2 + 3 * 3 * 4 - 1</kbd> will result in <kbd class="calibre11">38</kbd>:</p>
<pre class="calibre19">scala&gt; 1 + 2 + 3 * 3 * 4 - 1<br class="title-page-name"/>res16: Int = 38</pre>
<p class="calibre2">The expression <span><em class="calibre18">(1 + 2) + ((3 * 3) * 4) - 1</em> will be evaluated in the following steps:</span></p>
<ol class="calibre13">
<li value="1" class="calibre8"><em class="calibre18">1 + 2 + 9 * 4 - 1</em></li>
<li value="2" class="calibre8"><em class="calibre18">1 + 2 + 36 - 1</em></li>
<li value="3" class="calibre8"><em class="calibre18">3 + 36 - 1</em></li>
<li value="4" class="calibre8"><em class="calibre18">39 - 1</em></li>
<li value="5" class="calibre8"><em class="calibre18">38</em></li>
</ol>
<p class="calibre2">This gives clarity of evaluation of expressions in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Wrapper classes</h1>
                
            
            <article>
                
<p class="calibre2">In Scala, we can create our own universe, apart from the native methods provided, we can add our own implementations, which we call <em class="calibre18">Rich Wrapper</em> classes. This is possible because of <em class="calibre18">Implicit Conversions.</em> First, we'll list out some <em class="calibre18">Wrappers</em> available already:</p>
<div class="cdpaligncenter"><img src="../images/00014.jpeg" class="calibre27"/></div>
<div class="cdpaligncenter1">Rich wrappers</div>
<p class="calibre2">To see how it happens, let's see an example:</p>
<pre class="calibre19">scala&gt; val x = 10<br class="title-page-name"/>x: Int = 10<br class="title-page-name"/><br class="title-page-name"/>scala&gt; x.isValidByte<br class="title-page-name"/>res1: Boolean = true</pre>
<p class="calibre2">The preceding expression tries to check if the value of <kbd class="calibre11">x</kbd> can be converted into a <kbd class="calibre11">Byte</kbd>, and suffices range of a <kbd class="calibre11">Byte</kbd>, and finds it to be <kbd class="calibre11">true</kbd>:</p>
<pre class="calibre19">scala&gt; val x = 260<br class="title-page-name"/>x: Int = 260<br class="title-page-name"/><br class="title-page-name"/>scala&gt; x.isValidByte<br class="title-page-name"/>res2: Boolean = false<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val x = 127<br class="title-page-name"/>x: Int = 127<br class="title-page-name"/><br class="title-page-name"/>scala&gt; x.isValidByte<br class="title-page-name"/>res3: Boolean = true</pre>
<p class="calibre2">As you know, range for a <kbd class="calibre11">Byte</kbd> is -128 to 127. If you try to assign it to a value that's out of range of a <kbd class="calibre11">Byte</kbd> and expect it to behave like a <kbd class="calibre11">Byte</kbd><em class="calibre18">,</em> it won't work. Thus, the result for the preceding expression is <kbd class="calibre11">false</kbd><em class="calibre18">.</em></p>
<p class="calibre2">Apart from this <kbd class="calibre11">isValidByte</kbd>, there are a number of utility methods present in the class <kbd class="calibre11">RichByte</kbd> wrapper class<em class="calibre18">.</em></p>
<p class="calibre2">These wrappers methods look like they're natively defined for the types existing. One of the examples is a wrapper around a <kbd class="calibre11">String</kbd> that is <kbd class="calibre11">StringOps</kbd>. A String in Scala is nothing more than an instance of <kbd class="calibre11">java.lang.String</kbd><em class="calibre18">,</em> so it's clear that all methods implemented for <kbd class="calibre11">java.lang.String</kbd> are applicable here as well. For example, the <kbd class="calibre11">charAt</kbd> method does pretty good here:</p>
<pre class="calibre19">scala&gt; val x = "I am a String"<br class="title-page-name"/>x: String = I am a String<br class="title-page-name"/>scala&gt; x.charAt(5)<br class="title-page-name"/>res13: Char = a</pre>
<p class="calibre2">Now let's try some methods from <kbd class="calibre11">StringOps</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">scala&gt; x.capitalize<br class="title-page-name"/>res14: String = I am a String<br class="title-page-name"/><br class="title-page-name"/>scala&gt; x.toUpperCase<br class="title-page-name"/>res15: String = I AM A STRING<br class="title-page-name"/><br class="title-page-name"/>scala&gt; x.toLowerCase<br class="title-page-name"/>res16: String = i am a string</pre>
<p class="calibre2">The three methods <kbd class="calibre11">capitalize</kbd><em class="calibre18">,</em> <kbd class="calibre11">toUpperCase</kbd><em class="calibre18">,</em> and <kbd class="calibre11">toLowerCase</kbd> are defined in the <kbd class="calibre11">StringOps</kbd> class and not in <kbd class="calibre11">String</kbd> classes, but still it works the same way as calling a native method for a <kbd class="calibre11">String</kbd> type. There are more of these methods that work as a utility method for <kbd class="calibre11">Strings</kbd>. This is because of the power of <em class="calibre18">Implicit Conversions.</em> We'll learn how <em class="calibre18">Implicits</em> work in Scala in later chapters.</p>
<p class="calibre2">One of the ways to create a <kbd class="calibre11">Range</kbd> class out of <kbd class="calibre11">Int</kbd> types can be achieved using a method <em class="calibre18">to.</em> We call these <strong class="calibre1">rich methods</strong>. It's really simple to use them, and based on the purpose they solve, we can also name them:</p>
<pre class="calibre19">scala&gt; val rangeOfNumbers = 1 to 199<br class="title-page-name"/>rangeOfNumbers: scala.collection.immutable.Range.Inclusive = Range 1 to 199<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val rangeOfNumbersUntil = 1 until 199<br class="title-page-name"/>rangeOfNumbersUntil: scala.collection.immutable.Range = Range 1 until 199<br class="title-page-name"/><br class="title-page-name"/>scala&gt; rangeOfNumbers contains 1<br class="title-page-name"/>res17: Boolean = true<br class="title-page-name"/><br class="title-page-name"/>scala&gt; rangeOfNumbersUntil contains 1<br class="title-page-name"/>res18: Boolean = true<br class="title-page-name"/><br class="title-page-name"/>scala&gt; rangeOfNumbersUntil contains 199<br class="title-page-name"/>res19: Boolean = false<br class="title-page-name"/><br class="title-page-name"/>scala&gt; rangeOfNumbers contains 199<br class="title-page-name"/>res20: Boolean = true</pre>
<p class="calibre2">The preceding are few examples of methods from the <kbd class="calibre11">Range</kbd> class, which provide rich methods for <kbd class="calibre11">Int</kbd> to create a <kbd class="calibre11">Range</kbd> with. The <kbd class="calibre11">Range</kbd> can contain values inclusive of those. It's built with, and can also exclude, those values. Methods for building these are <kbd class="calibre11">to</kbd> and <kbd class="calibre11">until</kbd><em class="calibre18">.</em> The first includes both values we use to build a <kbd class="calibre11">Range</kbd>; the latter includes only the beginning value. We've tried all these. As you can see, <kbd class="calibre11">rangeOfNumbersUntil</kbd> does not contain <kbd class="calibre11">199</kbd>. We can also create a <kbd class="calibre11">Range</kbd> with some <kbd class="calibre11">step</kbd> difference:</p>
<pre class="calibre19">scala&gt; 1 to 10 by 2 foreach println</pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">1<br class="title-page-name"/>3<br class="title-page-name"/>5<br class="title-page-name"/>7<br class="title-page-name"/>9</pre>
<p class="calibre2">This is pretty simple; pretty and simple. Especially with the syntax, we are able to write concisely because of <em class="calibre18">Implicit Conversions</em> and <em class="calibre18">Type Inference</em> happening at the backend. Scala Compiler is taking care of all those parts, leaving us with the simple job of writing code in a beautiful way. Another way of utilizing conciseness while writing a String is by using String Interpolators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">String Interpolators</h1>
                
            
            <article>
                
<p class="calibre2">We've already used String Interpolators, it's hard to avoid using them when they are available to you. Remember when we used them? Yes! When we were learning to create operators on our own:</p>
<pre class="calibre19">println(s"Total Amount for order:: ${amountAfterTax(new Amount(firstOrderAmount))}")</pre>
<p class="calibre2">This little <kbd class="calibre11">s</kbd> here is a String interpolator. While using these, we precede our <kbd class="calibre11">String</kbd> with a character named <kbd class="calibre11">s</kbd>, and inside double quotes of the String, we can use any variable with a <kbd class="calibre11">$</kbd> and it'll be replaced by its value:</p>
<pre class="calibre19">scala&gt; val myAge = s"I completed my $age."<br class="title-page-name"/>myAge: String = I completed my 25.</pre>
<p class="calibre2">This is an example of how we can use interpolators. The <kbd class="calibre11">s</kbd> is not the only interpolator existing in Scala. We have a couple more interpolators. We'll go through them one by one.</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">s</kbd> interpolator</li>
<li class="calibre8">The <kbd class="calibre11">f</kbd> interpolator</li>
<li class="calibre8">The <kbd class="calibre11">raw</kbd> interpolator</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The s interpolator</h1>
                
            
            <article>
                
<p class="calibre2">First, we'll look at the <kbd class="calibre11">s</kbd> interpolator. We've already seen how we can create a processed String with variables. Now, let's take an example that takes on expressions:</p>
<pre class="calibre19">scala&gt; val nextYearAge = s"Next Year, I'll complete ${age + 1}."<br class="title-page-name"/>nextYearAge: String = Next Year, I'll complete 26.</pre>
<p class="calibre2">Here, we used <kbd class="calibre11">${...}</kbd> where a <kbd class="calibre11">$</kbd> sign is followed by a pair of braces {&lt;expression&gt;}, consisting of the expression to be evaluated. It can be any expression. An arithmetic operation like we just did, or a method call:</p>
<pre class="calibre19">scala&gt; def incrementBy1(x: Int) = x + 1<br class="title-page-name"/>incrementBy1: (x: Int)Int<br class="title-page-name"/><br class="title-page-name"/>scala&gt; val nextYearAge = s"Next Year, I'll complete ${incrementBy1(age)}."<br class="title-page-name"/>nextYearAge: String = Next Year, I'll complete 26.</pre>
<p class="calibre2">Here, we defined a method named <kbd class="calibre11">incrementBy1</kbd> that increments any Int passed by 1 and gives back the result. We've called that method from our interpolator. By the way, it's good to know that our interpolator <kbd class="calibre11">s</kbd> is a method just like any other operator in Scala. We're allowed to create our own interpolators in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">f Interpolator</h1>
                
            
            <article>
                
<p class="calibre2">To have something like <kbd class="calibre11">printf</kbd> styled formatting in Scala, we can use the <kbd class="calibre11">f</kbd> interpolator. We do this by using a <kbd class="calibre11">f</kbd> preceding the double quotes of our string, and then within the String we can use one of the format specifiers:</p>
<pre class="calibre19">scala&gt; val amount = 100<br class="title-page-name"/>amount: Int = 100<br class="title-page-name"/>scala&gt; val firstOrderAmount = f"Your total amount is: $amount%.2f"<br class="title-page-name"/>firstOrderAmount: String = Your total amount is: 100.00</pre>
<p class="calibre2">From the preceding example, it's clear that we use <em class="calibre18">f</em> as a prefix to our string and use <kbd class="calibre11">$</kbd> followed by the expression that includes our format specifier. This works as a formatter for our strings.</p>
<p class="calibre2">A few format specifiers are listed as following:</p>
<div class="cdpaligncenter"><img class="image-border5" src="../images/00015.jpeg"/></div>
<div class="cdpaligncenter1">Format Specifiers</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The raw interpolator</h1>
                
            
            <article>
                
<p class="calibre2">The final one pre-existing interpolator in Scala is the <kbd class="calibre11">raw</kbd> interpolator. This interpolator does not allow you to use any escape sequence characters in your string, it means that if you try to give an escape sequence character, it'll be treated as a normal literal and nothing more. The way we write <kbd class="calibre11">raw</kbd> interpolator is almost similar to the other two interpolators. We precede our String with a <em class="calibre18">raw</em> keyword and it works for us:</p>
<pre class="calibre19">scala&gt; val rawString = raw"I have no escape \n character in the String \n "<br class="title-page-name"/>rawString: String = "I have no escape \n character in the String \n "</pre>
<p class="calibre2">Here, in the string escape character, <kbd class="calibre11">\n</kbd> was treated as a normal literal, and in the resulting string it remained the same. In a normal string, <kbd class="calibre11">\n</kbd> would have converted into a <em class="calibre18">newline</em> character.</p>
<pre class="calibre19">scala&gt; val rawString = "I have no escape \n character in the String \n "<br class="title-page-name"/>rawString: String =<br class="title-page-name"/>"I have no escape<br class="title-page-name"/>character in the String<br class="title-page-name"/>"</pre>
<p class="calibre2">Using this raw interpolator, we can avoid escape sequences. These constructs give us a way to write code more efficiently and concisely.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">So, let's summarize what we have learned in this chapter. We started with the most basic <kbd class="calibre11">val</kbd> and <kbd class="calibre11">var</kbd> variable constructs. Then, we learned how we can write literals, and what data types we have in Scala. We then studied the interesting class hierarchy in Scala, in which we talked about unified class hierarchy and value and reference type classes. Later, we learned one of the most important concepts of Type Inference in Scala. After that, we started with operators, and their precedence. We learned how wrapper classes provide all the richness of functionalities to us as programmers. Finally, we learned a simple, but useful way of processing our String literals using interpolators. Now, it's clear that with some more practice of all these constructs that we've learned we'll be ready to go further and learn about some logical and looping constructs that shape up our programs.</p>
<p class="calibre2">In the next chapter, we'll discuss some looping constructs in Scala, logical constructs, and an introduction to pattern matching and how we can control our program flow using pattern matching and enabling us to strengthen our programs on logical ground.</p>
<p class="calibre2"/>


            </article>

            
        </section>
    </body></html>