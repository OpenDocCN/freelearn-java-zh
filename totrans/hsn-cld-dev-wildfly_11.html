<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Adding Resilience Using Hystrix</h1>
                </header>
            
            <article>
                
<p class="western"><span><span>In this chapter, we will learn how to deal with network failures, which are inevitable in a distributed environment. In order to do that, we will introduce the <strong>circuit breaker</strong> architectural pattern and cover when it should be used, and what its benefits are. We will look at its Netflix implementation, <strong>Hystrix</strong>. We will also cover how it is implemented and how it can be used. As an example, we will use Hystrix to add resilience and fault tolerance to our sample application.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unreliable network</h1>
                </header>
            
            <article>
                
<p>When you develop your services for distributed environments, you must take into consideration that invocations of the services will be performed over the network. As a result, the application must be prepared to deal with network failures, which will certainly happen.</p>
<p>This problem is further enhanced by the fact that a single misbehaving service can poison a large number of services. Let's take a look at the number of scenarios, that can make this possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependent services</h1>
                </header>
            
            <article>
                
<p>In large distributed systems, each service would have a large number of dependencies on other services. It requires only one dependency to fail to make the service irresponsible. Also, a service will go down too, becoming unavailable for other services that depend on it. Such a situation is known as cascading failures (Further reading, link 1).</p>
<p>However, that's not all. In a production-ready environment when there are a lot of calls being performed, a service that has latency problems will quickly block all available threads and make all other services unreachable.</p>
<p>Clearly, if we want to design a robust distributed system, we will need to have a tool that will enable users to deal with the problems described previously. The tool that we will use is the <span>Hystrix library</span>.</p>
<p>Hystrix is a library developed by Netflix to deal with service failures and to provide robustness for its sophisticated distributed architecture. Let's find out how Hystrix deals with the problems previously described.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The circuit breaker pattern</h1>
                </header>
            
            <article>
                
<p>The architectural design pattern created to deal with the problems described previously is the circuit breaker pattern. The main idea behind it is simple: wrap the invocation code into the command, which will perform the invocation, and calculate the status of the remote service. If the service is declared unreachable by the metrics used by the command, then the next invocations are rejected immediately. After a given time, new connections will be tried again, and, if successful, the command will start performing invocations to the service again.</p>
<p>The name of the pattern was taken from the electrical circuit breaker, a device used to protect the electrical circuit from the damage that may result from the excess electrical current. If the current in the circuit is too high then the circuit breaker opens, preventing the current from flowing. In order to make the circuit operate again, the circuit breaker has to be closed.</p>
<p>Owing to its archetype, the software circuit breaker has inherited the electrical nomenclature. If the targeted service is healthy and the invocations are forwarded to it directly, we will be talking about closed breaker. If the health metrics are exceed, the invocations are not performed, and the circuit breaker will be opened.</p>
<p>Obviously, the library that is responsible for the implementation of the circuit breaker has to provide algorithms that decide whether the remote service is healthy, how and when to open the circuit, and what to do if a circuit breaker is closed. Let's discuss how Hystrix does it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Hystrix circuit breaker</h1>
                </header>
            
            <article>
                
<p>The following diagram presents the behavior of the Hystrix circuit breaker:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e996a749-765d-456b-beb2-05277a18ce1f.png" style=""/></div>
<p>During the invocation of the remote service, Hystrix checks whether the circuit breaker is open. This decision is made based on the statistics gathered from the recent invocations. If the percentage of failures in the last time window is lower than the configured threshold, then the circuit is open and the invocation is performed.</p>
<p>After the invocation is performed, the circuit breaker stores its result (success/failure) in the statistics. The statistics are gathered for the configured time window, which is further divided into the number of buckets, with only one bucket being discarded at a time so that the data for the given window is not discarded all at once.</p>
<p>What happens when the circuit is open? Firstly, the algorithm checks whether the configured sleep time has passed. If it is the case, then only one request is allowed to be executed. This stage of a circuit breaker is called half-open and its purpose is to check whether the invoked service is healthy again. If the invocation succeeds, then a circuit breaker is opened again and the metrics are reset. If, on the other hand, the sleep time has not exceeded or the one invocation in a half-open state has failed, then the circuit breaker is opened again and the sleep time is reset.</p>
<p>So, we now know the Hystrix circuit breaker algorithm and how it reacts to statistics on successful and failed invocation. However, how <span>do</span> we actually define failure? There are three cases when the invocation is marked as failed. First, the configured invocation timeout has been exceeded. Second, the client library has thrown an exception. Third, the number of threads available for a given dependency has been exceeded.</p>
<p>The last point is an implementation of the bulkheading algorithm. Let's learn more about it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bulkheading</h1>
                </header>
            
            <article>
                
<p>In order to prevent a situation in which one of the dependencies uses the whole thread pool of an application, Hystrix keeps the thread pool for each dependency. <span>If one of the dependencies becomes latent, it will keep all its threads busy and will reject further invocations, resulting in an increased failure count.</span> <span>Such a strategy is called <strong>bulkheading</strong>.</span></p>
<p>This time, the nomenclature is taken from ship engineering: the hull of the ship is divided into isolated bulkheads so that the hull damage in one place results in only one bulkhead being filled with water. Similarly, providing a thread pool for each of the dependencies results in only a dedicated thread pool being used if one of the services is misbehaving.</p>
<p>In complex distributed environments, it is often the case that the application has many dependencies, each of which depends on other client libraries. Often, such libraries are black boxes provided by a third-party company, making them hard to debug. In addition, increasing the number of those libraries increases the risk that one of them will <em>poison</em> the whole application. With bulkheading, you can easily mitigate this risk.</p>
<div class="packt_infobox">The state of each client can be easily tracked by the status of its thread pool. If monitoring shows that one of the thread pools is full, it is an indicator that it should be examined. If the underlying problem is fixed, the thread pool will clear up and the service will continue its operation.</div>
<p>The dependencies that share the same thread pool are configurable. As a result, you are able to tune bulkheading behavior according to your architecture. Such a configuration is done using Hystrix group mechanism, which we will show you in the examples later in this chapter.</p>
<p>So, we a<span>lready</span> know that the invocation may fail or be forced to fail by Hystrix. But, what happens in that scenario? The mechanism that is supposed to deal with invocation failures is called <strong>fallbacks</strong>. Let's learn more about it now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fallbacks</h1>
                </header>
            
            <article>
                
<p>Hystrix implements a fallbacks mechanism, which allows you to execute your code whenever the failure of the invocation happens. The command allows you to implement a fallback method, which will be executed during the failure. The method is executed regardless of the cause of the failureâ€”the same method will be executed in case of timeout or thread pool overflow.</p>
<p>The fallback method doesn't have to be implemented. If fallback is not implemented, the exception thrown by Hystrix will be propagated down the stack trace.</p>
<p>If, on the other hand, you decide to implement the fallback, you have a number of strategies for doing that. Let's take a look at a few examples.</p>
<p>If you are using a service that is used to read a data, you can return an empty answer in case of invocation failure. In such a scenario, no data will be available in case of service failure. This solution hides the underlying failure and immediately returns the response. The problem is, obviously, that the requested data is unavailable. You can deal with that by implementing the local cache and return the latest response in case of failure. In this scenario, the failure will be hidden and the data will be available. It won't be up to date for the time of failure, but it will allow your system to continue its operation.</p>
<p>Let's suppose now that you are using the authorization service to decide whether the user is authorized to perform some further operations. In this case, you can implement the fallback, which will always return the same response. However, what should this response be? As usual, it depends on your use case. In some scenarios, you may want to avoid a situation when a user who has paid for a service is unable to use it. In this scenario, you would return the successful authorization each time. The drawback is that a number of users will be able to use content that they haven't paid for at the time of authorization service failure. In other scenarios, you may need to deny authorization for all users. Surely the temporary allow-all strategy is not suitable for the bank application. In this case, you would have to deny the authorization for all users.</p>
<p>Finally, in some scenarios, not writing the fallback is a good strategy. Let's suppose that you are implementing an invocation that is supposed to modify some data as a part of transactional operations. In this scenario, the propagated exception is the strategy that we want: the whole operation will be stopped, and the exception will be propagated to the transaction manager, which will roll back the transaction.</p>
<p>In this section, we have only hinted at a number of possible fallback implementation strategies. As you may have noticed, the specific implementation (or lack of) depends directly on your service's business requirements. The key point to remember is that Hystrix won't allow the network failure to compromise the behavior of your application, and if a failure occurs it will allow you to deal with it using the fallback mechanism.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The whole algorithm</h1>
                </header>
            
            <article>
                
<p>Finally, we are ready to sum up the behavior of the Hystrix library:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/59d5a430-7e6f-4c83-b2c5-bf683668b833.png" style=""/></div>
<p>At the beginning, the user constructs the command and starts its execution. Hystrix checks whether the circuit breaker associated with this command is closed. If the circuit breaker is open, then the invocation will be rejected immediately and the fallback will be executed (if implemented). If the circuit breaker is closed, then the thread-pool is checked. If there are no available threads in the thread-pool, then the invocation fails; optionally, the fallback is executed and the failure is reported to the circuit breaker. If, on the other hand, there are threads <span>available,</span> then the invocation starts. If the invocation misses its timeout, then the failure is reported to the circuit breaker and the optional fallback is executed.</p>
<div class="packt_infobox">In this scenario, the thread may be blocked. Hystrix will time it out, but will have to wait for the client library to <em>return the thread</em>. If the invocation finishes and fails, then the failure is reported to the circuit breaker and optionally the fallback is executed.</div>
<p>Finally, if the execution succeeds, then the success is reported to the circuit breaker and the response is returned as the result of the command execution.</p>
<p>You have already learned the basics of the Hystrix's circuit breaker implementation. Now it is time to learn its basic API, which we will use later in this chapter. Let's do it now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Hystrix</h1>
                </header>
            
            <article>
                
<p>In order to learn Hystrix behavior in practice, we are going to extend customer-gateway service so that it uses Hystrix for its invocations. Later, we are going to make one of our services artificially unresponsive and see how Hystrix behaves. Let's start.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter11/customer-gateway-hystrix</kbd>.</div>
<p>Firstly, we are going to add Hystrix dependency to the <kbd>pom.xml</kbd>:</p>
<pre>(...)<br/><br/><strong>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;<br/>    &lt;artifactId&gt;hystrix-core&lt;/artifactId&gt;<br/>    &lt;version&gt;${version.hystrix}&lt;/version&gt;<br/></strong><span><strong>&lt;/dependency&gt;</strong><br/><br/>(...)</span></pre>
<p>The circuit breaker command is implemented by extending the <kbd>com.netflix.hystrix.HystrixCommand</kbd> class. Let's take a look at its usage at the concrete example of our <kbd>PricingProxy</kbd>:</p>
<pre><span>(...)<br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span>PricingProxy {<br/><br/>    (...)<br/><br/><strong>    //1</strong><br/><strong>    private class GetPriceCommand extends HystrixCommand&lt;Response&gt;</strong> {<br/><br/>        <span>private final </span>String <span>itemId</span><span>;<br/></span><span><br/><strong>        //2</strong><br/></span><strong>        public GetPriceCommand(String itemId) {<br/>            //3</strong><br/><strong>            super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("pricing-service"));</strong><strong><br/>            this.itemId = itemId;<br/>        }</strong><br/><br/><strong>        @Override<br/>        //4<br/>        protected Response run() {<br/>            //5</strong><br/><strong>            Client client = ClientBuilder.newClient();<br/>            WebTarget target = client.target(targetPath + "/price/" + itemId);<br/>            return target.request(MediaType.APPLICATION_JSON).get();<br/>        }</strong><br/>    }<br/>}</pre>
<p>The command has to extend the abstract <kbd>HystrixCommand</kbd> class (1). The class has to be parameterized with a type that will be returned as the command result. In our example, it will be the JAX-RS response classâ€”the same as we used in our raw invocation.</p>
<p>The class takes the <span><span>itemId</span></span> parameter as an argument (2), which will be used in the invocation.</p>
<p>As you can see in the constructor code, we have provided <kbd>HystrixCommandGroupKey</kbd> parameter to it (3). <kbd>HystrixCommand</kbd> constructors allow you to provide a combination of three arguments: <span><kbd>HystrixCommandGroupKey</kbd>, <kbd>HystrixThreadPoolKey</kbd>, and the timeout. The two enum parameters are used for command grouping: the commands with the same group key will belong to the same group and will be grouped together for the purpose of reporting, alerting, and monitoring. </span><span>The thread pool key specifies the commands that belong to the same Hystrix thread pool used by the bulkhead algorithm. </span><span>When the thread pool key is not enabled, the group key is used as the thread pool identifier.</span></p>
<p><span>As a result, in our example all the <kbd>pricingService</kbd> invocation commands will belong to the same group and will use their own thread pool. The third argument in the <kbd>HystrixCommand </kbd></span><span>constructors is the timeout of the invocation. If one is not provided, the default timeout is used.</span></p>
<p>We have to extend the <kbd>run</kbd> method of the HystrixCommand class (4). This method will be invoked when the command is executed. As you can see (5), the content of the method is the same as the code of the proxy in our raw invocation.</p>
<p>Now, let's take a look at how to execute the command:</p>
<pre><span>(...)<br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span>PricingProxy {<br/><br/>    private final String targetPath = System.getProperty("proxy.pricing.url");<strong><br/>    <br/>    //1<br/>    public Price getPrice(String itemId){<br/>        //2</strong><br/><strong>        return new GetPriceCommand(itemId).execute().readEntity(Price.class);<br/>    }</strong><br/><br/>    (...)<br/>}<br/><br/></pre>
<p>The <span><span>getPrice</span></span> method of the proxy (1) creates the command object (2) and invokes the <kbd>execute()</kbd> method on it. This results in the execution of the whole circuit breaker algorithm described in the theoretical section. Let's invoke the catalog/item method now and measure the time of its invocation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/24ceacfb-1a49-4b81-9ac9-8ee020ca99f6.png" style=""/></div>
<p>There is no difference; the invocation is executed immediately without any errors. Now, let's make <kbd>pricingService</kbd> artificially unresponsive.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter11/pricing-service-misbehave</kbd>.</div>
<p>In order to do that we are going to make the service wait a specified amount of time before returning a result:</p>
<pre><span>package </span>org.packt.swarm.petstore.pricing<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.pricing.model.Price<span>;<br/></span><span><br/></span><span>import </span>javax.enterprise.context.<span>ApplicationScoped</span><span>;<br/></span><span>import </span>javax.persistence.EntityManager<span>;<br/></span><span>import </span>javax.persistence.<span>PersistenceContext</span><span>;<br/></span><span>import </span>java.util.List<span>;<br/></span><span>import </span>java.util.concurrent.TimeUnit<span>;<br/></span><span>import </span>java.util.concurrent.locks.LockSupport<span>;<br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span>PricingService {<br/><br/>    <span>@PersistenceContext</span>(<span>unitName </span>= <span>"PricingPU"</span>)<br/>    <span>private </span>EntityManager <span>em</span><span>;<br/></span><span><br/></span><span>    public </span>Price <span>findByItemId</span>(String itemId) {<br/><strong>        //1</strong><br/><strong>        LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(5))</strong><span><strong>;</strong><br/></span><span>        return </span><span>em</span>.createNamedQuery(<span>"Price.findByItemId"</span><span>, </span>Price.<span>class</span>).setParameter(<span>"itemId"</span><span>, </span>itemId).getSingleResult();<span><br/></span><span>    </span>}<br/>}</pre>
<p>Let's deploy the new service to the cloud and retry an invocation. The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fbf54914-1a83-4df2-8f3b-b8323b9ee14a.png"/></div>
<p>As you will have noticed in the preceding screenshot, the invocation has resulted in failure. The circuit breaker was open, and there was a thread available in the thread pool. As a result, the invocation was performed, but it exceeded the default Hystrix timeout which equals 1 second.</p>
<p>To confirm this, let's look at the logs:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/235847c7-f59c-4d56-8e6b-56f10812c723.png"/></div>
<p>Hystrix does not lie here: the timeout was exceeded and we have implemented no fallback. We will do in a second, but before that let's learn how to modify Hystrix properties.</p>
<p>If you want to modify the configuration of <kbd>HystrixCommand</kbd>, you have to use the constructor with the <kbd>Setter</kbd> argument. This class allows you to configure all the constructor arguments described previously. Apart from that, the class allows you to provide the configuration properties for different aspects of the circuit breaker behavior. The exhaustive list of such properties is described in the Hystrix documentation. Here, we will present a few example modifications. Let's start with the circuit breaker timeout:</p>
<pre><span>(...)<br/></span><span>private class </span>GetPriceCommand <span>extends </span>HystrixCommand&lt;Response&gt; {<br/><br/>    <span>private final </span>String <span>itemId</span><span>;<br/></span><span><br/></span><span>    public </span><span>GetPriceCommand</span>(String itemId) {<br/><strong>        //1</strong><br/><strong>        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("pricing-service"))</strong><br/><strong>                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()<br/>        //2</strong><br/><strong>                        .withExecutionTimeoutInMilliseconds(100)))</strong><span><strong>;</strong><br/></span><span>        this</span>.<span>itemId </span>= itemId<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>protected </span>Response <span>run</span>() {<br/>        Client client = ClientBuilder.<span>newClient</span>()<span>;<br/></span><span>        </span>WebTarget target = client.target(<span>targetPath </span>+ <span>"/price/" </span>+ <span>itemId</span>)<span>;<br/></span></pre>
<pre><span>        return </span>target.request(MediaType.<span>APPLICATION_JSON</span>).get()<span>;<br/></span><span>    </span>}<br/>}<br/>(...)</pre>
<p>The preceding code modifies our command class in order to shorten the invocation timeout to 500 milliseconds. The <kbd>Setter</kbd> class is used, and the <kbd>CommandGroupKey</kbd> is set in the same way as in the examples before (1). In order to modify the configuration, we have added <kbd>HystrixCommandProperites.Setter</kbd> with the appropriate configuration (2). Now, let's take a look at the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b642354c-a033-4faa-b6a7-dc81f264acfd.png"/></div>
<p>Let's reconfigure the application to note the behavior of the bulkheading algorithm; we will increase the timeout and reduce the number of threads:</p>
<pre><span>(...)</span><span>private class </span>GetPriceCommand <span>extends </span>HystrixCommand&lt;Response&gt; {<br/><br/>    <span>private final </span>String <span>itemId</span><span>;<br/></span><span><br/></span><span>    public </span><span>GetPriceCommand</span>(String itemId) {<br/>        <span>super</span>(Setter.<span>withGroupKey</span>(HystrixCommandGroupKey.Factory.<span>asKey</span>(<span>"pricing-service"</span>))<br/><strong>//1</strong>           <strong>.andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter().withCoreSize(3))</strong><span><strong>;</strong><br/></span><span>        this</span>.<span>itemId </span>= itemId<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>protected </span>Response <span>run</span>() {<br/>        Client client = ClientBuilder.<span>newClient</span>()<span>;<br/></span><span>        </span>WebTarget target = client.target(<span>targetPath </span>+ <span>"/price/" </span>+ <span>itemId</span>)<span>;<br/></span><span>        return </span>target.request(MediaType.<span>APPLICATION_JSON</span>).get()<span>;<br/></span><span>    </span>}<br/>}<br/>(...)</pre>
<p>In order to do that, another setter (this time, the <kbd>HystrixThreadPoolProperties</kbd> setter) has to be created (1).</p>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0d847f23-0177-4987-99a0-26f5fe5a5b0e.png"/></div>
<p>As you will have noticed in the preceding screenshot, the first three invocations have obtained their threads and were blocked. The fourth thread returned immediately as there are no more threads in the thread pool.</p>
<p>Finally, let's open the circuit. If we run the code in a bash loop and look into the log, we will note the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fa07b7cd-d85a-4ffb-8fe4-587a161b1b18.png"/></div>
<p>Finally, let's implement the fallback:</p>
<pre><span>(...)<br/>private class </span>CreatePaymentCommand <span>extends </span>HystrixCommand&lt;Response&gt; {<br/><br/>    <span>private final </span>Payment <span>payment</span><span>;<br/></span><span><br/></span><span>    public </span><span>CreatePaymentCommand</span>(Payment payment) {<br/>        <span>super</span>(Setter.<span>withGroupKey</span>(HystrixCommandGroupKey.Factory.<span>asKey</span>(<span>SERVICE_NAME</span>))<br/>                              .andCommandPropertiesDefaults(HystrixCommandProperties.<span>Setter</span>()<br/>                                      .withExecutionTimeoutInMilliseconds(<span>100</span>)))<span>;<br/></span><span>        this</span>.<span>payment </span>= payment<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>protected </span>Response <span>run</span>() {<br/>        Client client = ClientBuilder.<span>newClient</span>()<span>;<br/></span><span>        </span>WebTarget target = client.target(<span>targetPath </span>+ <span>"/payment"</span>)<span>;<br/></span><span>        return </span>target.request(MediaType.<span>APPLICATION_JSON</span>).post(Entity.<span>json</span>(<span>payment</span>))<span>;<br/></span><span>    </span>}<br/><br/><strong>    @Override<br/>    //1<br/>    protected Response getFallback() {<br/></strong>        <strong>//2</strong><br/><strong>        return Response.status(Response.Status.SERVICE_UNAVAILABLE).build();<br/>    }</strong><br/>}<br/><br/>(...)</pre>
<p>In order to implement the fallback, you have to override the <kbd>getFallback</kbd> method (1). In our example, we have returned the <kbd>SERVICE_UNAVAILABLE</kbd> exception whenever the <kbd>paymentService</kbd> is unreachable (2).</p>
<p>We can now reimplement the <kbd>PetstoreService</kbd> so that it creates a meaningful exception whenever such situations occur:</p>
<pre><span>public </span>String <span>buy</span>(<span>int </span>customerId){<br/>    Cart cart = <span>cartProxy</span>.getCart(customerId)<span>;<br/></span><span><br/></span><span>    </span>Order order = createOrderFromCart(customerId<span>, </span>cart)<span>;<br/></span><span>    int </span>orderId  = <span>orderProxy</span>.createOrder(order)<span>;<br/></span><span><br/></span><span>    </span>Payment payment = <span>new </span>Payment()<span>;<br/></span><span>    </span>payment.setMerchantId(Constants.<span>MERCHANT_ID</span>)<span>;<br/></span><span>    </span>payment.setDescription(String.<span>format</span>(<span>"ORDER_ID: %s"</span><span>, </span>orderId))<span>;<br/></span><span>    </span>payment.setAmount(order.getPrice())<span>;<br/></span><span><br/></span><span>    </span>Response response =  <span>paymentProxy</span>.createPayment(payment)<span>;<br/></span><span><br/></span><strong>    if(response.getStatus() == Response.Status.SERVICE_UNAVAILABLE.getStatusCode()){</strong><br/><strong>        throw new RuntimeException("Payment service unreachable");<br/>    }</strong><br/><br/>    <span>return </span>(String) response.readEntity(String.<span>class</span>)<span>;<br/></span>}</pre>
<p>This will be the result of an invocation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a240fd13-0050-4fd1-b2ca-65ff68725d2e.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the basic theory behind the circuit breaker pattern.</p>
<p>In the practical part of this chapter, we extended our pet store application to provide the buying functionality. We then covered the basics of the Hystrix API and used it to implement resilient connections with our external payment service.</p>
<p>Later, we used our own mock implementation of misbehaving a payment service to present the behavior of the circuit breaker algorithm.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li style="list-style-type: none">
<ol>
<li><a href="https://github.com/Netflix/Hystrix/wiki">https://github.com/Netflix/Hystrix/wiki</a></li>
<li><a href="http://netflix.github.io/Hystrix/javadoc/">http://netflix.github.io/Hystrix/javadoc/</a></li>
</ol>
</li>
</ul>


            </article>

            
        </section>
    </body></html>