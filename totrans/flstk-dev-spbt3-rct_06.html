<html><head></head><body>
  <div id="_idContainer121" class="Basic-Text-Frame">
    <h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-57" class="chapterTitle">Securing Your Backend</h1>
    <p class="normal">This chapter explains how to secure your Spring Boot backend. Securing your backend is a crucial part of code development. It is essential for protecting sensitive data, complying with regulations, and preventing unauthorized access. The backend often handles the user authentication and authorization process. Securing these aspects properly ensures that only authorized users can access the application and perform specific actions. We will use the database application that we created in the previous chapter as a starting point.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Understanding Spring Security</li>
      <li class="bulletList">Securing your backend with a JSON Web Token</li>
      <li class="bulletList">Role-based security</li>
      <li class="bulletList">Using OAuth2 with Spring Boot</li>
    </ul>
    <h1 id="_idParaDest-58" class="heading-1">Technical requirements</h1>
    <p class="normal">The Spring Boot application that we created in the previous chapters is required.</p>
    <p class="normal">The following GitHub link will also be required: <a href="https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05"><span class="url">https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05</span></a>.</p>
    <h1 id="_idParaDest-59" class="heading-1">Understanding Spring Security</h1>
    <p class="normal"><strong class="keyWord">Spring Security</strong> (<span class="url">https://spring.io/projects/spring-security</span>) provides security<a id="_idIndexMarker182"/> services for Java-based<a id="_idIndexMarker183"/> web applications. The Spring Security project was started in 2003 and was previously named <em class="italic">Acegi Security System for Spring</em>.</p>
    <p class="normal">By default, Spring Security<a id="_idIndexMarker184"/> enables the following features:</p>
    <ul>
      <li class="bulletList">An <code class="inlineCode">AuthenticationManager</code> bean with an in-memory single user. The username is <code class="inlineCode">user</code> and the password is printed to the console output.</li>
      <li class="bulletList">Ignored paths for common static resource locations, such as <code class="inlineCode">/css</code> and <code class="inlineCode">/images</code>. HTTP basic authentication for all other endpoints.</li>
      <li class="bulletList">Security events published to Spring’s <code class="inlineCode">ApplicationEventPublisher</code> interface.</li>
      <li class="bulletList">Common<a id="_idIndexMarker185"/> low-level features<a id="_idIndexMarker186"/> turned on by <a id="_idIndexMarker187"/>default, including <strong class="keyWord">HTTP Strict Transport Security</strong> (<strong class="keyWord">HSTS</strong>), <strong class="keyWord">cross-site scripting</strong> (<strong class="keyWord">XSS</strong>), and <strong class="keyWord">cross-site request forgery</strong> (<strong class="keyWord">CSRF</strong>).</li>
      <li class="bulletList">A default autogenerated login page.</li>
    </ul>
    <p class="normal">You can include Spring Security in your application by adding the following highlighted dependencies to the <code class="inlineCode">build.gradle</code> file. The first dependency is for the application and the second is for testing:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">dependencies</span> {
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span>
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-rest'</span>
    <span class="code-highlight"><strong class="hljs-slc">implementation </strong><strong class="hljs-string-slc">'org.springframework.boot:spring-boot-starter-security'</strong></span>
    developmentOnly <span class="hljs-string">'org.springframework.boot:spring-boot-devtools'</span>
    runtimeOnly <span class="hljs-string">'org.mariadb.jdbc:mariadb-java-client'</span>
    testImplementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span>
    <span class="code-highlight"><strong class="hljs-slc">testImplementation </strong><strong class="hljs-string-slc">'org.springframework.security:spring-security-test'</strong></span>
}
</code></pre>
    <div class="packt_tip">
      <p class="normal">If you haven’t enabled automatic refresh, remember to refresh the Gradle project from Eclipse after you have modified your <code class="inlineCode">build.gradle</code> file.</p>
    </div>
    <p class="normal">When you start your application, you can<a id="_idIndexMarker188"/> see from the console that Spring Security has created an in-memory user with a username of <code class="inlineCode">user</code>. The user’s password can be seen in the console output, as illustrated here:</p>
    <figure class="mediaobject"><img src="../Images/B19818_05_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.1: Spring Security enabled</p>
    <p class="normal">If there is no password in the console, try to restart your project by pressing the red <strong class="screenText">Terminate</strong> button in the console and re-running it.</p>
    <div class="note">
      <p class="normal">The Eclipse console has limited output, and the default buffer size is 80,000 characters, so the output might be truncated before the password statement can appear. You can change this setting from the <strong class="screenText">Window | Preferences | Run/Debug | Console</strong> menu.</p>
    </div>
    <p class="normal">Now, if you make a <code class="inlineCode">GET</code> request to your REST API root endpoint, you will see that it has been secured. Open your web browser and navigate to <code class="inlineCode">http://localhost:8080/api</code>. You will be redirected to the Spring Security default login page, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B19818_05_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.2: Secured REST API</p>
    <p class="normal">To be able to make a successful <code class="inlineCode">GET</code> request, we have to authenticate<a id="_idIndexMarker189"/> to our RESTful API. Type <code class="inlineCode">user</code> into the <strong class="screenText">Username</strong> field and copy the generated password from the console to the <strong class="screenText">Password</strong> field. With authentication, we can see that the response contains our API resources, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B19818_05_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.3: Basic authentication</p>
    <p class="normal">To configure how Spring Security behaves, we have to add a new configuration class for Spring Security. The security<a id="_idIndexMarker190"/> configuration file can be used to define which URLs or URL patterns are accessible to which roles or users. You can also define the authentication mechanism, the login process, session management, and so on.</p>
    <p class="normal">Create a new class called <code class="inlineCode">SecurityConfig</code> in your application root package (<code class="inlineCode">com.packt.cardatabase</code>). The following source code shows the structure of the security configuration class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.
  EnableWebSecurity;
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebSecurity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> {
}
</code></pre>
    <p class="normal">The <code class="inlineCode">@Configuration</code> and <code class="inlineCode">@EnableWebSecurity</code> annotations switch off the default web security configuration, and we can define our own configuration in this class. Inside the <code class="inlineCode">filterChain(HttpSecurity http)</code> method that we will see in action later, we can define which endpoints in our application are secure and which are not. We don’t actually need this method yet because we can use the default settings where all the endpoints are secured.</p>
    <p class="normal">We can also add in-memory<a id="_idIndexMarker191"/> users to our application by using Spring Security’s <code class="inlineCode">InMemoryUserDetailsManager</code>,<strong class="keyWord"> </strong>which implements <code class="inlineCode">UserDetailsService</code>. Then we can implement user/password authentication that is stored in memory. We can also use <code class="inlineCode">PasswordEncoder</code> to encode passwords using the <code class="inlineCode">bcrypt</code> algorithm.</p>
    <p class="normal">The following highlighted source code will create an in-memory user with a username of <code class="inlineCode">user</code>, a password of <code class="inlineCode">password</code>, and a role of <code class="inlineCode">USER</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// SecurityConfig.java</span>
<span class="hljs-keyword">package</span> com.packt.cardatabase;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.context.annotation.Bean;</strong></span>
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.
  EnableWebSecurity;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.security.core.userdetails.User;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.security.core.userdetails.UserDetails;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.security.crypto.password.PasswordEncoder;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.security.provisioning.</strong></span><span class="code-highlight"><strong class="hljs-slc">InMemoryUserDetailsManager;</strong></span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebSecurity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> {
    <span class="code-highlight"><strong class="hljs-meta-slc">@Bean</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> InMemoryUserDetailsManager </strong><strong class="hljs-title-slc">userDetailsService</strong><strong class="hljs-params-slc">()</strong><strong class="hljs-slc"> {</strong></span>
        <span class="code-highlight"><strong class="hljs-type-slc">UserDetails</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">user</strong><strong class="hljs-slc"> </strong><strong class="hljs-operator-slc">=</strong><strong class="hljs-slc"> User.builder().username(</strong><strong class="hljs-string-slc">"user"</strong><strong class="hljs-slc">).</strong></span>
            <span class="code-highlight"><strong class="hljs-slc">password(passwordEncoder().encode(</strong><strong class="hljs-string-slc">"password"</strong><strong class="hljs-slc">))</strong></span>
            <span class="code-highlight"><strong class="hljs-slc">.roles(</strong><strong class="hljs-string-slc">"USER"</strong><strong class="hljs-slc">).build();</strong></span>
        <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">InMemoryUserDetailsManager</strong><strong class="hljs-slc">(user);</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
    <span class="code-highlight"><strong class="hljs-meta-slc">@Bean</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> PasswordEncoder </strong><strong class="hljs-title-slc">passwordEncoder</strong><strong class="hljs-params-slc">()</strong><strong class="hljs-slc"> {</strong></span>
        <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">BCryptPasswordEncoder</strong><strong class="hljs-slc">();</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
}
</code></pre>
    <p class="normal">Now, restart the<a id="_idIndexMarker192"/> application, and you will be able to test authentication using the in-memory user. The use of in-memory users is fine in the development phase, but a proper application should save users in the database.</p>
    <p class="normal">To save users to the database, you have to create a user entity class and repository. Passwords shouldn’t be saved to the database in plaintext format. If a database containing user passwords is hacked, attackers will be able to get the passwords directly in plaintext. Spring Security provides multiple hashing algorithms, such as <code class="inlineCode">bcrypt</code>, that you can use to hash passwords. The following steps show you how to implement this:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new class called <code class="inlineCode">AppUser</code> in the <code class="inlineCode">com.packt.cardatabase.domain</code> package. Activate the domain package and right-click it. Select <strong class="screenText">New</strong> | <strong class="screenText">Class</strong> from the menu and name the new class <code class="inlineCode">User</code>. After that, your project structure should look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_05_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.4: Project structure</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Annotate the <code class="inlineCode">AppUser</code> class<a id="_idIndexMarker193"/> with the <code class="inlineCode">@Entity</code> annotation. Add the ID, username, password, and role class fields. Finally, add the constructors, getters, and setters. We will set all the fields to be not <code class="inlineCode">nullable</code>. This means that database columns cannot hold <code class="inlineCode">null</code> values. We will also specify that the username must be unique by using <code class="inlineCode">unique=true</code> in the username’s <code class="inlineCode">@Column</code> annotation. Refer to the following <code class="inlineCode">AppUser.java</code> source code for the fields:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase.domain;
<span class="hljs-keyword">import</span> jakarta.persistence.Column;
<span class="hljs-keyword">import</span> jakarta.persistence.Entity;
<span class="hljs-keyword">import</span> jakarta.persistence.GeneratedValue;
<span class="hljs-keyword">import</span> jakarta.persistence.GenerationType;
<span class="hljs-keyword">import</span> jakarta.persistence.Id;
<span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppUser</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy=GenerationType.AUTO)</span>
    <span class="hljs-meta">@Column(nullable=false, updatable=false)</span>
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-meta">@Column(nullable=false, unique=true)</span>
    <span class="hljs-keyword">private</span> String username;
       
    <span class="hljs-meta">@Column(nullable=false)</span>
    <span class="hljs-keyword">private</span> String password;
    
    <span class="hljs-meta">@Column(nullable=false)</span>
    <span class="hljs-keyword">private</span> String role;
    
<span class="hljs-comment">// Constructors, getters and setters    </span>
}
</code></pre>
    <p class="normal">Here is the <code class="inlineCode">AppUser.java</code> constructors<a id="_idIndexMarker194"/> source code:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">public</span> <span class="hljs-title">AppUser</span><span class="hljs-params">()</span> {}
    <span class="hljs-keyword">public</span> <span class="hljs-title">AppUser</span><span class="hljs-params">(String username, String password, String role)</span> {
        <span class="hljs-built_in">super</span>();
        <span class="hljs-built_in">this</span>.username = username;
        <span class="hljs-built_in">this</span>.password = password;
        <span class="hljs-built_in">this</span>.role = role;
    }
</code></pre>
    <p class="normal">Here is the <code class="inlineCode">AppUser.java</code> source code with the getters and setters:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> username;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> {
        <span class="hljs-built_in">this</span>.username = username;
    }
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> password;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> {
        <span class="hljs-built_in">this</span>.password = password;
    }
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getRole</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> role;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRole</span><span class="hljs-params">(String role)</span> {
        <span class="hljs-built_in">this</span>.role = role;
    }
</code></pre>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Create a new interface called <code class="inlineCode">AppUserRepository</code> in the domain package. To do this, activate the domain package and right-click it. Select <strong class="screenText">New</strong> | <strong class="screenText">Interface</strong> from the menu and name it <code class="inlineCode">AppUserRepository</code>.
    <p class="normal">The source code for the repository <a id="_idIndexMarker195"/>class is similar to what we saw in the previous chapter, but there is one query method, <code class="inlineCode">findByUsername</code>, that we need for the steps that follow. This method is used to find a <code class="inlineCode">user</code> from the database in the authentication process. The method returns <code class="inlineCode">Optional</code> to prevent a null exception. Refer to the following <code class="inlineCode">AppUserRepository</code> source code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase.domain;
<span class="hljs-keyword">import</span> java.util.Optional;
<span class="hljs-keyword">import</span> org.springframework.data.repository.CrudRepository;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">AppUserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository
   </span>&lt;AppUser, Long&gt; {
    Optional&lt;AppUser&gt; <span class="hljs-title">findByUsername</span><span class="hljs-params">(String username)</span>;
  }
</code></pre></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Next, we will create a class that implements the <code class="inlineCode">UserDetailsService</code> interface that’s provided by Spring Security. Spring Security uses this for user authentication and authorization. Create a new <code class="inlineCode">service</code> package in the root package. To do this, activate the root package and right-click it. Select <strong class="screenText">New</strong> | <strong class="screenText">Package</strong> from the menu and name the new package <code class="inlineCode">service</code>, as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"> <img src="../Images/B19818_05_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.5: The service package</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Create a new class<a id="_idIndexMarker196"/> called <code class="inlineCode">UserDetailsServiceImpl</code> in the <code class="inlineCode">service</code> package we just created. Now, your project structure should look like this (in Eclipse, refresh the Project Explorer by pressing <em class="keystroke">F5</em>):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_05_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.6: Project structure</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">We have to inject the <code class="inlineCode">AppUserRepository</code> class into the <code class="inlineCode">UserDetailsServiceImpl</code> class because it is needed to fetch the user from the database when Spring Security handles authentication. The <code class="inlineCode">findByUsername</code> method<a id="_idIndexMarker197"/> that we implemented earlier returns <code class="inlineCode">Optional</code>, therefore we can use the <code class="inlineCode">isPresent()</code> method to check if the <code class="inlineCode">user</code> exists. If the <code class="inlineCode">user</code> doesn’t exist, we throw a <code class="inlineCode">UsernameNotFoundException</code> exception. The <code class="inlineCode">loadUserByUsername</code> method returns the <code class="inlineCode">UserDetails</code> object, which is required for authentication. We are using the Spring Security <code class="inlineCode">UserBuilder</code> class to build the user for the authentication. Here is the source code for <code class="inlineCode">UserDetailsServiceImpl.java</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase.service;
<span class="hljs-keyword">import</span> java.util.Optional;
<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.User.
  UserBuilder;
<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;
<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.
  UserDetailsService;
<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.
  UsernameNotFoundException;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;
<span class="hljs-keyword">import</span> com.packt.cardatabase.domain.AppUser;
<span class="hljs-keyword">import</span> com.packt.cardatabase.domain.AppUserRepository;
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> {
<span class="hljs-keyword">  private</span> <span class="hljs-keyword">final</span> AppUserRepository repository;
<span class="hljs-keyword">public</span> <span class="hljs-title">UserDetailsServiceImpl</span><span class="hljs-params">(AppUserRepository repository)</span> {
    <span class="hljs-built_in">this</span>.repository = repository;
}
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span>
    UsernameNotFoundException {
        Optional&lt;AppUser&gt; user = repository.findByUsername(username);
        <span class="hljs-type">UserBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (user.isPresent()) {
            <span class="hljs-type">AppUser</span> <span class="hljs-variable">currentUser</span> <span class="hljs-operator">=</span> user.get();
            builder = org.springframework.security.core.userdetails.
                      User.withUsername(username);
            builder.password(currentUser.getPassword());
            builder.roles(currentUser.getRole());
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">UsernameNotFoundException</span>(<span class="hljs-string">"User not found."</span>);
        }
        <span class="hljs-keyword">return</span> builder.build();
    }
}
</code></pre>
    <p class="normal">In our security configuration class, we have to specify that Spring Security should use users from the database instead of in-memory users. Delete the <code class="inlineCode">userDetailsService()</code> method from the <code class="inlineCode">SecurityConfig</code> class to disable in-memory users. Add a new <code class="inlineCode">configureGlobal</code> method to enable users from the database.</p>
    <p class="normal">We should never save the password<a id="_idIndexMarker198"/> as plaintext to the database. Therefore, we will define a password hashing algorithm in the <code class="inlineCode">configureGlobal</code> method. In this example, we are using the <code class="inlineCode">bcrypt</code> algorithm. This can be easily implemented with the Spring Security <code class="inlineCode">BCryptPasswordEncoder</code> class, which encodes a hashed password during the authentication process. Here is the <code class="inlineCode">SecurityConfig.java</code> source code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.
  authentication.builders.AuthenticationManagerBuilder;
<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.
  web.configuration.EnableWebSecurity;
<span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.
  BCryptPasswordEncoder;
<span class="hljs-keyword">import</span> com.packt.cardatabase.service.UserDetailsServiceImpl;
<span class="hljs-keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebSecurity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> {
<span class="hljs-keyword">    private</span> <span class="hljs-keyword">final</span> UserDetailsServiceImpl userDetailsService;
<span class="hljs-keyword">    public</span> <span class="hljs-title">SecurityConfig</span><span class="hljs-params">(UserDetailsServiceImpl userDetailsService)</span> {
        <span class="hljs-built_in">this</span>.userDetailsService = userDetailsService;
    }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureGlobal </span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span>
    <span class="hljs-keyword">throws</span> Exception {
      auth.userDetailsService(userDetailsService)
      .passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title">BCryptPasswordEncoder</span>());
    }
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BCryptPasswordEncoder</span>();
    }
}
</code></pre>
    <p class="normal">Now, the password<a id="_idIndexMarker199"/> must be hashed using <code class="inlineCode">bcrypt</code> before it’s saved to the database.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Finally, we can save a couple of test users to the database using the <code class="inlineCode">CommandLineRunner</code> interface. Open the <code class="inlineCode">CardatabaseApplication.java</code> file and inject <code class="inlineCode">AppUserRepository</code> into the main class:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CarRepository repository;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OwnerRepository orepository;
<span class="code-highlight"><strong class="hljs-keyword-slc">private</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">final</strong><strong class="hljs-slc"> AppUserRepository urepository;</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-title">CardatabaseApplication</span><span class="hljs-params">(CarRepository repository, OwnerRepository orepository</span><span class="code-highlight"><strong class="hljs-params-slc">, AppUserRepository urepository</strong></span><span class="hljs-params">)</span> {
    <span class="hljs-built_in">this</span>.repository = repository;
    <span class="hljs-built_in">this</span>.orepository = orepository;
    <span class="code-highlight"><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.urepository = urepository;</strong></span>
}
</code></pre>
      </li>
      <li class="numberedList">Let’s save two users<a id="_idIndexMarker200"/> to the database with <code class="inlineCode">bcrypt</code> hashed passwords. You can find <code class="inlineCode">bcrypt</code> calculators or generators on the internet. These generators allow you to input a plaintext password, and they will produce the corresponding <code class="inlineCode">bcrypt</code> hash:
        <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// Add owner objects and save these to db</span>
        <span class="hljs-type">Owner</span> <span class="hljs-variable">owner1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Owner</span>(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Johnson"</span>);
        <span class="hljs-type">Owner</span> <span class="hljs-variable">owner2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Owner</span>(<span class="hljs-string">"Mary"</span>, <span class="hljs-string">"Robinson"</span>);
        orepository.saveAll(Arrays.asList(owner1, owner2));
        repository.save(<span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(
                            <span class="hljs-string">"Ford"</span>, <span class="hljs-string">"Mustang"</span>, <span class="hljs-string">"Red"</span>, <span class="hljs-string">"ADF-1121"</span>,
                             <span class="hljs-number">2023</span>, <span class="hljs-number">59000</span>, owner1));
        repository.save(<span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(
                            <span class="hljs-string">"Nissan"</span>, <span class="hljs-string">"Leaf"</span>, <span class="hljs-string">"White"</span>, <span class="hljs-string">"SSJ-3002"</span>,
                            <span class="hljs-number">2020</span>, <span class="hljs-number">29000</span>, owner2));
        repository.save(<span class="hljs-keyword">new</span> <span class="hljs-title">Car</span>(
                            <span class="hljs-string">"Toyota"</span>, <span class="hljs-string">"Prius"</span>, <span class="hljs-string">"Silver"</span>, <span class="hljs-string">"KKO-0212"</span>,
                            <span class="hljs-number">2022</span>, <span class="hljs-number">39000</span>, owner2));
        <span class="hljs-comment">// Fetch all cars and log to console</span>
        <span class="hljs-keyword">for</span> (Car car : repository.findAll()) {
            logger.info(car.getBrand() + <span class="hljs-string">" "</span> + car.getModel());
        }
        <span class="code-highlight"><strong class="hljs-comment-slc">// Username: user, password: user</strong></span>
        <span class="code-highlight"><strong class="hljs-slc">urepository.save(</strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">AppUser</strong><strong class="hljs-slc">(</strong><strong class="hljs-string-slc">"user"</strong><strong class="hljs-slc">,</strong></span>
            <span class="code-highlight"><strong class="hljs-string-slc">"$2a$10$NVM0n8ElaRgg7zWO1CxUdei7vWoPg91Lz2aYavh9.</strong></span>
            <span class="code-highlight"><strong class="hljs-string-slc">f9q0e4bRadue"</strong><strong class="hljs-slc">,</strong><strong class="hljs-string-slc">"</strong><strong class="hljs-string-slc">USER"</strong><strong class="hljs-slc">));</strong></span>
        <span class="code-highlight"><strong class="hljs-comment-slc">// Username: admin, password: admin</strong></span>
        <span class="code-highlight"><strong class="hljs-slc">urepository.save(</strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">AppUser</strong><strong class="hljs-slc">(</strong><strong class="hljs-string-slc">"admin"</strong><strong class="hljs-slc">,</strong></span>
            <span class="code-highlight"><strong class="hljs-string-slc">"$2a$10$8cjz47bjbR4Mn8GMg9IZx.vyjhLXR/SKKMSZ9.</strong></span>
            <span class="code-highlight"><strong class="hljs-string-slc">mP9vpMu0ssKi8GW"</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">"ADMIN"</strong><strong class="hljs-slc">));</strong></span>
    }
</code></pre>
        <div class="note">
          <p class="normal"><strong class="keyWord">bcrypt</strong> is a strong hashing function<a id="_idIndexMarker201"/> that was designed by Niels Provos and David Mazières. Here is an example of a bcrypt hash that is generated from the <code class="inlineCode">admin</code> string:</p>
          <p class="normal"><code class="inlineCode">$2a$10$8cjz47bjbR4Mn8GMg9IZx.vyjhLXR/SKKMSZ9.mP9vpMu0ssKi8GW</code></p>
          <p class="normal"><code class="inlineCode">$2a</code> represents the algorithm version, and <code class="inlineCode">$10</code> represents the strength of the algorithm. The default strength of Spring Security’s <code class="inlineCode">BcryptPasswordEncoder</code> class is 10. bcrypt generates a random <strong class="keyWord">salt</strong> in hashing, so the hashed result is always different.</p>
        </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">After running<a id="_idIndexMarker202"/> your application, you will see that there is now an <code class="inlineCode">app_user</code> table in the database and that two user records are saved with hashed passwords, as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_05_07.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.7: Users</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="10">Now, you should restart the application and you will get a <code class="inlineCode">401 Unauthorized</code> error if you try to send a <code class="inlineCode">GET</code> request to the <code class="inlineCode">http://localhost:8080/api</code> path without authentication. You must authenticate to be able to send a successful request. The difference, when compared with the previous example, is that we are using the users from the database to authenticate.
    <p class="normal">Now, you can log in by sending a <code class="inlineCode">GET</code> request to the <code class="inlineCode">/api</code> endpoint using the browser, or we can use Postman and basic authentication, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B19818_05_08.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.8: GET request authentication</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">You can see that we currently<a id="_idIndexMarker203"/> get users by calling the <code class="inlineCode">api/appUsers</code> endpoint in our RESTful web service, which is something we want to avoid. As mentioned in <em class="chapterRef">Chapter 4</em>, Spring Data REST generates a RESTful web service from all public repositories by default. We can use the <code class="inlineCode">exported</code> flag of the <code class="inlineCode">@RepositoryRestResource</code> annotation and set it to <code class="inlineCode">false</code>, which means the following repository is not exposed as a REST resource:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase.domain;
<span class="hljs-keyword">import</span> java.util.Optional;
<span class="hljs-keyword">import</span> org.springframework.data.repository.CrudRepository;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.data.rest.core.annotation.</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  RepositoryRestResource;</strong></span>
<span class="code-highlight"><strong class="hljs-meta-slc">@RepositoryRestResource(exported = false)</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">AppUserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository
   </span>&lt;AppUser, Long&gt; {
    Optional&lt;AppUser&gt; <span class="hljs-title">findByUsername</span><span class="hljs-params">(String username)</span>;
  }
</code></pre>
      </li>
      <li class="numberedList">Now, if you restart the application and send a <code class="inlineCode">GET</code> request to the <code class="inlineCode">/api</code> endpoint, you will<a id="_idIndexMarker204"/> see that the <code class="inlineCode">/appUsers</code> endpoint is not visible anymore.</li>
    </ol>
    <p class="normal">Next, we will start to implement authentication using a JSON Web Token.</p>
    <h1 id="_idParaDest-60" class="heading-1">Securing your backend with a JSON Web Token</h1>
    <p class="normal">In the previous section, we covered<a id="_idIndexMarker205"/> how to use basic authentication<a id="_idIndexMarker206"/> with a RESTful web service. Basic authentication doesn’t provide a way to handle tokens or manage sessions. When a user logs in, the credentials are sent with each request, which can cause session management challenges and potential security risks. This method is not usable when we develop<a id="_idIndexMarker207"/> our own frontend with React, so we are going to use <strong class="keyWord">JSON Web Token</strong> (<strong class="keyWord">JWT</strong>) authentication instead (<span class="url">https://jwt.io/</span>). This will also give you an idea of how you can configure Spring Security in more detail.</p>
    <div class="note">
      <p class="normal">The other option<a id="_idIndexMarker208"/> for securing your RESTful web service is <strong class="keyWord">OAuth 2</strong>. OAuth2 (<span class="url">https://oauth.net/2/</span>) is the industry standard for authorization and it can be used<a id="_idIndexMarker209"/> quite easily in Spring Boot applications. There is a section later on in the chapter that will give you a basic idea about how to use it in your applications.</p>
    </div>
    <p class="normal">JWTs are commonly used in RESTful APIs for authentication and authorization purposes. They are a compact way to implement authentication in modern web applications. A JWT is really small in size and can therefore be sent in the URL, in the <code class="inlineCode">POST</code> parameter, or inside the header. It also contains all the necessary information about the user, such as their username and role.</p>
    <p class="normal">A JWT contains three different parts, separated by dots: <code class="inlineCode">xxxxx.yyyyy.zzzzz</code>. These parts are broken up as follows:</p>
    <ul>
      <li class="bulletList">The first part (<code class="inlineCode">xxxxx</code>) is the <strong class="keyWord">header, </strong>which defines the type of token and the hashing algorithm.</li>
      <li class="bulletList">The second part (<code class="inlineCode">yyyyy</code>) is the <strong class="keyWord">payload, </strong>which, typically, in the case of authentication, contains user information.</li>
      <li class="bulletList">The third part (<code class="inlineCode">zzzzz</code>) is the <strong class="keyWord">signature, </strong>which is used to verify that the token hasn’t been changed along the way.</li>
    </ul>
    <p class="normal">Here is an example of a JWT:</p>
    <pre class="programlisting code"><code class="hljs-code">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
</code></pre>
    <p class="normal">The following diagram shows a simplified representation of the authentication process using a JWT:</p>
    <figure class="mediaobject"><img src="../Images/B19818_05_09.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.9: JWT authentication process</p>
    <p class="normal">After successful authentication, the requests<a id="_idIndexMarker210"/> sent by the client should always contain<a id="_idIndexMarker211"/> the JWT that was received in the authentication.</p>
    <p class="normal">We will use <code class="inlineCode">jjwt</code> (<span class="url">https://github.com/jwtk/jjwt</span>), which is the JWT library for Java and Android for creating and parsing JWTs. Therefore, we have to add the following dependencies to the <code class="inlineCode">build.gradle</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">dependencies</span> {
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span>
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-rest'</span>
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-security'</span>
    <span class="code-highlight"><strong class="hljs-slc">implementation </strong><strong class="hljs-string-slc">'io.jsonwebtoken:jjwt-api:0.11.5'</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">runtimeOnly </strong><strong class="hljs-string-slc">'io.jsonwebtoken:jjwt-impl:0.11.5'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'io.jsonwebtoken:jjwt-</strong></span>
      <span class="code-highlight"><strong class="hljs-string-slc">jackson:0.11.5'</strong></span>
    developmentOnly <span class="hljs-string">'org.springframework.boot:spring-boot-devtools'</span>
    runtimeOnly <span class="hljs-string">'org.mariadb.jdbc:mariadb-java-client'</span>
    testImplementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span>
    testImplementation <span class="hljs-string">'org.springframework.security:spring-security-test'</span>
}
</code></pre>
    <div class="packt_tip">
      <p class="normal">Remember to refresh the Gradle project from Eclipse after you have updated the dependencies.</p>
    </div>
    <p class="normal">The following<a id="_idIndexMarker212"/> steps demonstrate<a id="_idIndexMarker213"/> how to enable JWT authentication in our backend.</p>
    <h2 id="_idParaDest-61" class="heading-2">Securing the login</h2>
    <p class="normal">We will start with the login<a id="_idIndexMarker214"/> functionality:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we will create a class that generates and verifies a signed JWT. Create a new class called <code class="inlineCode">JwtService</code> in the <code class="inlineCode">com.packt.cardatabase.service</code> package. At the beginning of the class, we will define a few constants: <code class="inlineCode">EXPIRATIONTIME</code> defines the expiration time of the token in milliseconds, <code class="inlineCode">PREFIX</code> defines the prefix of the token, and the <code class="inlineCode">"Bearer"</code> schema is typically used. A JWT is sent in the <code class="inlineCode">Authorization</code> header and the content of the header looks like the following when using the Bearer schema:
        <pre class="programlisting code"><code class="hljs-code">Authorization: Bearer <span class="hljs-tag">&lt;</span><span class="hljs-name">token</span><span class="hljs-tag">&gt;</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">JwtService</code> source code looks like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase.service;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JwtService</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">EXPIRATIONTIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">86400000</span>;   <span class="hljs-comment">// 1 day in ms. Should be shorter in production.</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Bearer"</span>;
}
</code></pre>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">We will create a secret key<a id="_idIndexMarker215"/> using the <code class="inlineCode">jjwt</code> library’s <code class="inlineCode">secretKeyFor</code> method. This is only for demonstration purposes. In a production environment, you should read your secret key from the application configuration. The <code class="inlineCode">getToken</code> method then generates and returns the token. The <code class="inlineCode">getAuthUser</code> method gets the token from the response <code class="inlineCode">Authorization</code> header. Then, we will use the <code class="inlineCode">parserBuilder</code> method provided by the <code class="inlineCode">jjwt</code> library to create a <code class="inlineCode">JwtParserBuilder</code> instance. The <code class="inlineCode">setSigningKey</code> method is used to specify a secret key for token verification. The <code class="inlineCode">parseClaimsJws</code> method removes the <code class="inlineCode">Bearer</code> prefix from the <code class="inlineCode">Authorization</code> header. Finally, we will use the <code class="inlineCode">getSubject</code> method to get the username. The whole <code class="inlineCode">JwtService</code> source code follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase.service;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> io.jsonwebtoken.Jwts;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> io.jsonwebtoken.SignatureAlgorithm;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> io.jsonwebtoken.security.Keys;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> java.security.Key;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.http.HttpHeaders;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.stereotype.Component;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> jakarta.servlet.http.HttpServletRequest;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> java.util.Date;</strong></span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JwtService</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">EXPIRATIONTIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">86400000</span>;   <span class="hljs-comment">// 1 day in ms. Should be shorter in production.</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Bearer"</span>;
  <span class="code-highlight"><strong class="hljs-comment-slc">// Generate secret key. Only for demonstration purposes.</strong></span>
  <span class="code-highlight"><strong class="hljs-comment-slc">// In production, you should read it from the application </strong></span>  <span class="code-highlight"><strong class="hljs-comment-slc">// configuration.</strong></span>
  <span class="code-highlight"><strong class="hljs-keyword-slc">static</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">final</strong><strong class="hljs-slc"> </strong><strong class="hljs-type-slc">Key</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">key</strong><strong class="hljs-slc"> </strong><strong class="hljs-operator-slc">=</strong><strong class="hljs-slc"> Keys.secretKeyFor (SignatureAlgorithm.</strong></span>    <span class="code-highlight"><strong class="hljs-slc">HS256);</strong></span>
  <span class="code-highlight"><strong class="hljs-comment-slc">// Generate signed JWT token</strong></span>
  <span class="code-highlight"><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> String </strong><strong class="hljs-title-slc">getToken</strong><strong class="hljs-params-slc">(String username)</strong><strong class="hljs-slc"> {</strong></span>
    <span class="code-highlight"><strong class="hljs-type-slc">String</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">token</strong><strong class="hljs-slc"> </strong><strong class="hljs-operator-slc">=</strong><strong class="hljs-slc"> Jwts.builder()</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">.setSubject(username)</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">.setExpiration(</strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">Date</strong><strong class="hljs-slc">(System.currentTimeMillis() +</strong></span>                            <span class="code-highlight"><strong class="hljs-slc">EXPIRATIONTIME))</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">.signWith(key)</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">.compact();  </strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> token;</strong></span>
  <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
  <span class="code-highlight"><strong class="hljs-comment-slc">// Get a token from request Authorization header,</strong></span>
  <span class="code-highlight"><strong class="hljs-comment-slc">// verify the token, and get username</strong></span>
  <span class="code-highlight"><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> String </strong><strong class="hljs-title-slc">getAuthUser</strong><strong class="hljs-params-slc">(HttpServletRequest request)</strong><strong class="hljs-slc"> {</strong></span>
    <span class="code-highlight"><strong class="hljs-type-slc">String</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">token</strong><strong class="hljs-slc"> </strong><strong class="hljs-operator-slc">=</strong><strong class="hljs-slc"> request.getHeader</strong></span>
        <span class="code-highlight"><strong class="hljs-slc">(HttpHeaders.AUTHORIZATION);</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (token != </strong><strong class="hljs-literal-slc">null</strong><strong class="hljs-slc">) {</strong></span>
      <span class="code-highlight"><strong class="hljs-type-slc">String</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">user</strong><strong class="hljs-slc"> </strong><strong class="hljs-operator-slc">=</strong><strong class="hljs-slc"> Jwts.parserBuilder()</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">.setSigningKey(key)</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">.build()</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">.parseClaimsJws(token.replace(PREFIX, </strong><strong class="hljs-string-slc">""</strong><strong class="hljs-slc">))</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">.getBody()</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">.getSubject();</strong></span>
      <span class="code-highlight"><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (user != </strong><strong class="hljs-literal-slc">null</strong><strong class="hljs-slc">)</strong></span>
        <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> user;</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-literal-slc">null</strong><strong class="hljs-slc">;</strong></span>
  <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
}
</code></pre>
      </li>
      <li class="numberedList">Next, we will add a new class<a id="_idIndexMarker216"/> to store credentials for authentication. Here we can use a Java <strong class="keyWord">record</strong>, which was introduced in Java 14. A record<a id="_idIndexMarker217"/> is a good choice if you need a class that only holds data; you can avoid a lot of boilerplate code. Create a new record (<strong class="screenText">New</strong> | <strong class="screenText">Record</strong>) called <code class="inlineCode">AccountCredentials</code> in the <code class="inlineCode">com.packt.cardatabase.domain</code> package:
    <figure class="mediaobject"><img src="../Images/B19818_05_10.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.10: Create a new record</p>
    <p class="normal">The record has two fields: <code class="inlineCode">username</code> and <code class="inlineCode">password</code>. Here is the source code for the record. As you can see, we don’t have to write getters and setters when using it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase.domain;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">AccountCredentials</span><span class="hljs-params">(String username, String password)</span> {}
</code></pre></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Now, we will implement<a id="_idIndexMarker218"/> the <code class="inlineCode">controller</code> class for login. Login is done by calling the <code class="inlineCode">/login</code> endpoint using the <code class="inlineCode">POST</code> method and sending the username and password inside the request body. Create a class called <code class="inlineCode">LoginController</code> inside the <code class="inlineCode">com.packt.cardatabase.web</code> package. We have to inject a <code class="inlineCode">JwtService</code> instance into the controller class because that is used to generate a signed JWT in the case of a successful login. The code is illustrated in the following snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase.web;
<span class="hljs-keyword">import</span> org.springframework.http.HttpHeaders;
<span class="hljs-keyword">import</span> org.springframework.http.ResponseEntity;
<span class="hljs-keyword">import</span> org.springframework.security.authentication.AuthenticationManager;
<span class="hljs-keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;
<span class="hljs-keyword">import</span> com.packt.cardatabase.domain.AccountCredentials;
<span class="hljs-keyword">import</span> com.packt.cardatabase.service.JwtService;
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtService jwtService;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthenticationManager authenticationManager;
    <span class="hljs-keyword">public</span> <span class="hljs-title">LoginController</span><span class="hljs-params">(JwtService jwtService,
      AuthenticationManager authenticationManager)</span> {
        <span class="hljs-built_in">this</span>.jwtService = jwtService;
        <span class="hljs-built_in">this</span>.authenticationManager = authenticationManager;
    }
    <span class="hljs-meta">@PostMapping("/login")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; getToken(<span class="hljs-meta">@RequestBody</span>
      AccountCredentials credentials) {
    <span class="hljs-comment">// Generate token and send it in the response Authorization</span>
    <span class="hljs-comment">// header</span>
    }
}
</code></pre>
      </li>
      <li class="numberedList">Next, we will implement the <code class="inlineCode">getToken</code> method<a id="_idIndexMarker219"/> that handles the login functionality. We get a JSON object from the request body that contains the username and password. <code class="inlineCode">AuthenticationManager</code> is used to perform authentication and it uses credentials that we get from the request. Then, we use the <code class="inlineCode">JwtService</code> class’ <code class="inlineCode">getToken</code> method to generate a JWT. Finally, we build an HTTP response that contains the generated JWT in the <code class="inlineCode">Authorization</code> header:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// LoginController.java</span>
<span class="hljs-meta">@PostMapping("/login")</span>
<span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; getToken(<span class="hljs-meta">@RequestBody</span> AccountCredentials
   credentials) {
    <span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">creds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>
      <span class="hljs-title">UsernamePasswordAuthenticationToken</span>(credentials.username(),                                          credentials.password());
    <span class="hljs-type">Authentication</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> authenticationManager.authenticate(creds);
    <span class="hljs-comment">// Generate token</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">jwts</span> <span class="hljs-operator">=</span> jwtService.getToken(auth.getName());
    <span class="hljs-comment">// Build response with the generated token</span>
    <span class="hljs-keyword">return</span> ResponseEntity.ok().header(HttpHeaders.AUTHORIZATION,
                   <span class="hljs-string">"Bearer"</span> + jwts).header(HttpHeaders.
                   ACCESS_CONTROL_EXPOSE_HEADERS,
                   <span class="hljs-string">"Authorization"</span>).build();
}
</code></pre>
      </li>
      <li class="numberedList">We have also injected <code class="inlineCode">AuthenticationManager</code> into the <code class="inlineCode">LoginController</code> class, therefore<a id="_idIndexMarker220"/> we have to add the following highlighted code to the <code class="inlineCode">SecurityConfig</code> class:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.context.annotation.Bean;</strong></span>
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.security.authentication.</strong></span><span class="code-highlight"><strong class="hljs-slc">AuthenticationManager;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.security.config.annotation.</strong></span>  <span class="code-highlight"><strong class="hljs-slc">authentication.configuration.AuthenticationConfiguration;</strong></span>
<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.  authentication.builders.AuthenticationManagerBuilder;
<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.  authentication.configuration.AuthenticationConfiguration;
<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
<span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
<span class="hljs-keyword">import</span> com.packt.cardatabase.service.UserDetailsServiceImpl;
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebSecurity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDetailsServiceImpl userDetailsService;
<span class="hljs-keyword">    public</span> <span class="hljs-title">SecurityConfig</span><span class="hljs-params">(UserDetailsServiceImpl userDetailsService)</span>{
        <span class="hljs-built_in">this</span>.userDetailsService = userDetailsService;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureGlobal</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span>
      <span class="hljs-keyword">throws</span> Exception {
        auth.userDetailsService(userDetailsService)
          .passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title">BCryptPasswordEncoder</span>());
    }
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BCryptPasswordEncoder</span>();
    }
    
    <span class="code-highlight"><strong class="hljs-meta-slc">@Bean</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> AuthenticationManager </strong><strong class="hljs-title-slc">uthenticationManager</strong><strong class="hljs-params-slc">(</strong></span>
      <span class="code-highlight"><strong class="hljs-params-slc">AuthenticationConfiguration authConfig)</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">throws</strong></span> <span class="code-highlight"><strong class="hljs-slc">Exception {</strong></span>
        <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> authConfig.getAuthenticationManager();</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
}
</code></pre>
      </li>
      <li class="numberedList">In this step, we have to configure Spring Security functionality. Spring Security’s <code class="inlineCode">SecurityFilterChain</code> bean defines which paths are secured and which are not. Add the following <code class="inlineCode">filterChain</code> method to the <code class="inlineCode">SecurityConfig</code> class. In the method, we define that the <code class="inlineCode">POST</code> method request to the <code class="inlineCode">/login</code> endpoint is allowed without authentication and that requests to all other endpoints require authentication. We will also define that Spring Security<a id="_idIndexMarker221"/> will never create a session, and therefore we can disable cross-site request forgery (<code class="inlineCode">csrf</code>). JWTs are designed to be stateless, which reduces the risk of session-related vulnerabilities. We will use Lambdas in the HTTP security configuration:
    <div class="packt_tip">
      <p class="normal">In some other programming languages, Lambdas are called <strong class="keyWord">anonymous functions</strong>. The usage of Lambdas makes code<a id="_idIndexMarker222"/> more readable and reduces boilerplate code.</p>
    </div>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// SecurityConfig.java</span>
<span class="hljs-comment">// Add the following import</span>
<span class="hljs-keyword">import</span> org.springframework.security.web.SecurityFilterChain;
<span class="hljs-comment">// Add filterChain method</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span>
  Exception {
    http.csrf((csrf) -&gt; csrf.disable())
        .sessionManagement((sessionManagement) -&gt; sessionManagement.            sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) -&gt;            authorizeHttpRequests.requestMatchers(HttpMethod.POST,            <span class="hljs-string">"/login"</span>).permitAll().anyRequest().authenticated());
    <span class="hljs-keyword">return</span> http.build();
}
</code></pre></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Finally, we are ready to test our login functionality. Open Postman and make a <code class="inlineCode">POST</code> request to the <code class="inlineCode">http://localhost:8080/login</code> URL. Define a valid user inside the request body, for example, <code class="inlineCode">{"username":"user", "password":"user"}</code> and select <strong class="screenText">JSON</strong> from the drop-down list. Postman will then set the <code class="inlineCode">Content-Type</code> header to <code class="inlineCode">application/json</code> automatically. You should check from the <strong class="screenText">Headers</strong> tab that the <code class="inlineCode">Content-Type</code> header is set correctly. Now, you should see an <code class="inlineCode">Authorization</code> header in the response that contains the signed JWT, like the one shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_05_11.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.11: Login request</p>
    <p class="normal">You can also test the login<a id="_idIndexMarker223"/> by using the wrong password and seeing that the response doesn’t contain the <code class="inlineCode">Authorization</code> header.</p>
    <h2 id="_idParaDest-62" class="heading-2">Securing the other requests</h2>
    <p class="normal">We have now finalized<a id="_idIndexMarker224"/> the login step, and we will move on to handling authentication<a id="_idIndexMarker225"/> for the rest of the incoming requests. In the authentication process, we are using <strong class="keyWord">filters</strong> that allow us to perform some operations before a request goes to the controller or before a response is sent to a client.</p>
    <p class="normal">The following steps demonstrate the rest of the authentication process:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We will use a filter class to authenticate all other incoming requests. Create a new class called <code class="inlineCode">AuthenticationFilter</code> in the root package. The <code class="inlineCode">AuthenticationFilter</code> class extends Spring Security’s <code class="inlineCode">OncePerRequestFilter</code> interface, which provides a <code class="inlineCode">doFilterInternal</code> method where we implement our authentication. We have to inject a <code class="inlineCode">JwtService</code> instance into the filter class because it is needed to verify a token from the request. The <code class="inlineCode">SecurityContextHolder</code> is where Spring Security stores the details of the authenticated user. The code<a id="_idIndexMarker226"/> is illustrated in the following snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase;
<span class="hljs-keyword">import</span> org.springframework.http.HttpHeaders;
<span class="hljs-keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;
<span class="hljs-keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;
<span class="hljs-keyword">import</span> com.packt.cardatabase.service.JwtService;
<span class="hljs-keyword">import</span> jakarta.servlet.FilterChain;
<span class="hljs-keyword">import</span> jakarta.servlet.ServletException;
<span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtService jwtService;
    <span class="hljs-keyword">public</span> <span class="hljs-title">AuthenticationFilter</span><span class="hljs-params">(JwtService jwtService)</span> {
        <span class="hljs-built_in">this</span>.jwtService = jwtService;
   }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request,</span><span class="hljs-params">               HttpServletResponse response, FilterChain filterChain)</span>
            <span class="hljs-keyword">throws</span> ServletException, java.io.IOException {
        <span class="hljs-comment">// Get token from the Authorization header</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">jws</span> <span class="hljs-operator">=</span> request.getHeader(HttpHeaders.AUTHORIZATION);
        <span class="hljs-keyword">if</span> (jws != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// Verify token and get user</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> jwtService.getAuthUser(request);
            <span class="hljs-comment">// Authenticate</span>
            <span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title">UsernamePasswordAuthenticationToken</span>(user, <span class="hljs-literal">null</span>,
                java.util.Collections.emptyList());
            SecurityContextHolder.getContext()
                .setAuthentication(authentication);
        }
        filterChain.doFilter(request, response);
    }
}
</code></pre>
      </li>
      <li class="numberedList">Next, we have to add our filter <a id="_idIndexMarker227"/>class to the Spring Security configuration. Open the <code class="inlineCode">SecurityConfig</code> class and inject the <code class="inlineCode">AuthenticationFilter</code> class that we just implemented, as shown in the highlighted code:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDetailsServiceImpl userDetailsService;
<span class="code-highlight"><strong class="hljs-keyword-slc">private</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">final</strong><strong class="hljs-slc"> AuthenticationFilter authenticationFilter;</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-title">SecurityConfig</span><span class="hljs-params">(UserDetailsServiceImpl userDetailsService</span><span class="code-highlight"><strong class="hljs-params-slc">,</strong></span><span class="code-highlight"><strong class="hljs-params-slc">AuthenticationFilter authenticationFilter</strong></span><span class="hljs-params">)</span> {
    <span class="hljs-built_in">this</span>.userDetailsService = userDetailsService;
<code style="font-weight: bold;" class="codeHighlighted">    </code><span class="code-highlight"><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.authenticationFilter = authenticationFilter;</strong></span>
}
</code></pre>
      </li>
      <li class="numberedList">Then, modify the <code class="inlineCode">filterChain</code> method in the <code class="inlineCode">SecurityConfig</code> class and add the following lines of code:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">//Add the following import</span>
<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.  UsernamePasswordAuthenticationFilter;
<span class="hljs-comment">// Modify the filterChain method</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span>   Exception {
    http.csrf((csrf) -&gt; csrf.disable())
        .sessionManagement((sessionManagement) -&gt; sessionManagement.            sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) -&gt;            authorizeHttpRequests.requestMatchers(HttpMethod.POST,            <span class="hljs-string">"/login"</span>).permitAll().anyRequest().authenticated())
        <span class="code-highlight"><strong class="hljs-slc">.addFilterBefore(authenticationFilter,</strong></span>            <span class="code-highlight"><strong class="hljs-slc">UsernamePasswordAuthenticationFilter.class);</strong></span>
    <span class="hljs-keyword">return</span> http.build();
}
</code></pre>
      </li>
      <li class="numberedList">Now, we are ready to test<a id="_idIndexMarker228"/> the whole workflow. After we run the application, we can first log in by calling the <code class="inlineCode">/login</code> endpoint with the <code class="inlineCode">POST</code> method and, in the case of a successful login, we will receive a JWT in the <code class="inlineCode">Authorization</code> header. Remember to add a valid user inside the body and set the <code class="inlineCode">Content-Type</code> header to <code class="inlineCode">application/json</code> if it is not done automatically by Postman. The following screenshot illustrates the process:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_05_12.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.12: Login request</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Following a successful login, we can call the other RESTful service endpoints by sending the JWT that was received from the login in the <code class="inlineCode">Authorization</code> header. Copy the token from the login response (without the <code class="inlineCode">Bearer</code> prefix) and add the <code class="inlineCode">Authorization</code> header with the token in the <code class="inlineCode">VALUE</code> column. Refer to the example in the following screenshot where a <code class="inlineCode">GET</code> request to the <code class="inlineCode">/cars</code> endpoint<a id="_idIndexMarker229"/> is done:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_05_13.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.13: Authenticated GET request</p>
    <div class="note">
      <p class="normal">Each time the application is restarted, you must authenticate again because a new JWT is generated.</p>
      <p class="normal">The JWT is not valid forever because an expiration date was set for it. In our case, we set a long expiration time for demonstration purposes. In production, the time should preferably be minutes, depending on the use case.</p>
    </div>
    <h2 id="_idParaDest-63" class="heading-2">Handling exceptions</h2>
    <p class="normal">We should also handle exceptions<a id="_idIndexMarker230"/> in the authentication. At the moment, if you try to log in using the wrong password, you get a <code class="inlineCode">403 Forbidden</code> status without any further clarification. Spring Security provides an <code class="inlineCode">AuthenticationEntryPoint</code> interface that can be used to handle exceptions. Let’s see how it works:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new class named <code class="inlineCode">AuthEntryPoint</code> in the root package that implements <code class="inlineCode">AuthenticationEntryPoint</code>. We will implement the <code class="inlineCode">commence</code> method, which gets an exception as a parameter. In the case of an exception, we set the response status to <code class="inlineCode">401 Unauthorized</code> and write an exception message to the response body. The code<a id="_idIndexMarker231"/> is illustrated in the following snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.PrintWriter;
<span class="hljs-keyword">import</span> jakarta.servlet.ServletException;
<span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;
<span class="hljs-keyword">import</span> org.springframework.http.MediaType;
<span class="hljs-keyword">import</span> org.springframework.security.core.
  AuthenticationException;
<span class="hljs-keyword">import</span> org.springframework.security.web.
  AuthenticationEntryPoint;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthEntryPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationEntryPoint</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(</span>
<span class="hljs-params">    HttpServletRequest request, HttpServletResponse response,</span>
<span class="hljs-params">    AuthenticationException authException)</span> <span class="hljs-keyword">throws </span>IOException,
    ServletException {
        response.setStatus (HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType (MediaType.APPLICATION_JSON_VALUE);
        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();
        writer.println(<span class="hljs-string">"Error: "</span> + authException.getMessage());
  }
}
</code></pre>
      </li>
      <li class="numberedList">Then, we have to configure Spring Security for the exception handling. Inject our <code class="inlineCode">AuthEntryPoint</code> class into the <code class="inlineCode">SecurityConfig</code> class, as shown in the following highlighted code:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// SecurityConfig.java</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDetailsServiceImpl userDetailsService;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthenticationFilter authenticationFilter;
<span class="code-highlight"><strong class="hljs-keyword-slc">private</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">final</strong><strong class="hljs-slc"> AuthEntryPoint exceptionHandler;</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-title">SecurityConfig</span><span class="hljs-params">(UserDetailsServiceImpl userDetailsService,   AuthenticationFilter authenticationFilter, </span><span class="code-highlight"><strong class="hljs-params-slc">AuthEntryPoint </strong></span>  <span class="code-highlight"><strong class="hljs-params-slc">exceptionHandler</strong></span><span class="hljs-params">)</span> {
    <span class="hljs-built_in">this</span>.userDetailsService = userDetailsService;
    <span class="hljs-built_in">this</span>.authenticationFilter = authenticationFilter;
    <span class="code-highlight"><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.exceptionHandler = exceptionHandler;</strong></span>
}
</code></pre>
      </li>
      <li class="numberedList">Then, modify the <code class="inlineCode">filterChain</code> method<a id="_idIndexMarker232"/> as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// SecurityConfig.java</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span>
  Exception {
    http.csrf((csrf) -&gt; csrf.disable())
        .sessionManagement((sessionManagement) -&gt;
            sessionManagement.sessionCreationPolicy(
            SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) -&gt;             authorizeHttpRequests.requestMatchers(HttpMethod.POST,            <span class="hljs-string">"/login"</span>).permitAll().anyRequest().authenticated())
        .addFilterBefore(authenticationFilter,            UsernamePasswordAuthenticationFilter.class)
        <span class="code-highlight"><strong class="hljs-slc">.exceptionHandling((exceptionHandling) -&gt; exceptionHandling.</strong></span>            <span class="code-highlight"><strong class="hljs-slc">authenticationEntryPoint(exceptionHandler));</strong></span>
    <span class="hljs-keyword">return</span> http.build();
}
</code></pre>
      </li>
      <li class="numberedList">Now, if you send a login <code class="inlineCode">POST</code> request with the wrong credentials, you will get a <code class="inlineCode">401 Unauthorized</code> status in the response and an error message in the body, as shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_05_14.png" alt="" role="presentation"/></figure>
    <figure class="mediaobject">Figure 5.14: Bad credentials</figure>
    <h2 id="_idParaDest-64" class="heading-2">Adding a CORS filter</h2>
    <p class="normal">We will also add a <strong class="keyWord">cross-origin resource sharing</strong> (<strong class="keyWord">CORS</strong>) filter to our security configuration class. CORS<a id="_idIndexMarker233"/> introduces certain headers<a id="_idIndexMarker234"/> that help the client and server decide if cross-origin requests should be allowed or denied. The CORS filter is needed for the frontend, which is sending requests from the other origin. The CORS filter intercepts requests, and if these are identified as cross-origin, it adds proper headers to the request. For that, we will use Spring Security’s <code class="inlineCode">CorsConfigurationSource</code> interface. </p>
    <p class="normal">In this example, we will allow all origins’ HTTP methods and headers. You can define a list of permissible origins, methods, and headers here if you require a more finely graded definition. Let’s begin:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add the following imports and methods to your <code class="inlineCode">SecurityConfig</code> class to enable the CORS filter:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// SecurityConfig.java</span>
<span class="hljs-comment">// Add the following imports</span>
<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> org.springframework.web.cors.CorsConfiguration;
<span class="hljs-keyword">import</span> org.springframework.web.cors.CorsConfigurationSource;
<span class="hljs-keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;
<span class="hljs-comment">// Add Global CORS filter inside the class</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> CorsConfigurationSource <span class="hljs-title">corsConfigurationSource</span><span class="hljs-params">()</span> {
    <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span>
       <span class="hljs-keyword">new</span> <span class="hljs-title">UrlBasedCorsConfigurationSource</span>();
    <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">CorsConfiguration</span>();
    config.setAllowedOrigins(Arrays.asList(<span class="hljs-string">"*"</span>));
    config.setAllowedMethods(Arrays.asList(<span class="hljs-string">"*"</span>));
    config.setAllowedHeaders(Arrays.asList(<span class="hljs-string">"*"</span>));
    config.setAllowCredentials(<span class="hljs-literal">false</span>);
    config.applyPermitDefaultValues();
    source.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, config);
    <span class="hljs-keyword">return</span> source;
}
</code></pre>
    <p class="normal">If you want to explicitly define the origins, you can set this in the following way:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// localhost:3000 is allowed</span>
config.setAllowedOrigins(Arrays.asList (<span class="hljs-string">"http://localhost:3000"</span>));
</code></pre>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">We also have to add the <code class="inlineCode">cors()</code> function<a id="_idIndexMarker235"/> to the <code class="inlineCode">filterChain</code> method, as shown<a id="_idIndexMarker236"/> in the following code snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// SecurityConfig.java</span>
<span class="hljs-comment">// Add the following static import</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.security.config.Customizer.withDefaults;
<span class="hljs-comment">// Modify filterChain method</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span>
  Exception {
    http.csrf((csrf) -&gt; csrf.disable())
        <span class="code-highlight"><strong class="hljs-slc">.cors(withDefaults())</strong></span>
        .sessionManagement((sessionManagement) -&gt; sessionManagement.            sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) -&gt; 
            authorizeHttpRequests.requestMatchers(HttpMethod.POST,            <span class="hljs-string">"/login"</span>).permitAll().anyRequest().authenticated())
        .addFilterBefore(authenticationFilter,            UsernamePasswordAuthenticationFilter.class)
        .exceptionHandling((exceptionHandling) -&gt; exceptionHandling.            authenticationEntryPoint(exceptionHandler));
    <span class="hljs-keyword">return</span> http.build();
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Now, we<a id="_idIndexMarker237"/> have secured<a id="_idIndexMarker238"/> our backend. In the next section, we will introduce the basics of role-based security, which you can use to get more fine-grained access control in your Spring Boot application.</p>
    <h1 id="_idParaDest-65" class="heading-1">Role-based security</h1>
    <p class="normal">In Spring Security, <strong class="keyWord">roles</strong> can be used to define<a id="_idIndexMarker239"/> coarse-grained role-based security, and users<a id="_idIndexMarker240"/> can be assigned to one or multiple roles. Roles often have a hierarchical structure, for example, <code class="inlineCode">ADMIN</code>, <code class="inlineCode">MANAGER</code>, <code class="inlineCode">USER</code>. Spring Security also provides <strong class="keyWord">authorities</strong>, which can be used for more fine-grained access control. We have defined simple roles for our users, <code class="inlineCode">ADMIN</code> and <code class="inlineCode">USER</code>, and we don’t use role-based security in our sample backend application. This section introduces the different ways to implement role-based security in your Spring Boot applications.</p>
    <p class="normal">You can define role-based access control at the request level in your security configuration class. In the following example code, we define which endpoints require specific roles for access. The <code class="inlineCode">/admin/**</code> endpoint requires the <code class="inlineCode">ADMIN</code> role for access and the <code class="inlineCode">/user/**</code> endpoint requires the <code class="inlineCode">USER</code> role for access. We use the Spring Security <code class="inlineCode">hasRole()</code> method, which returns true if the user has the specified role:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span>
   Exception {
    http.csrf((csrf) -&gt; csrf.disable()).cors(withDefaults())
        .sessionManagement((sessionManagement) -&gt; sessionManagement.            sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) -&gt; 
            authorizeHttpRequests.requestMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole             (<span class="hljs-string">"ADMIN"</span>).requestMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"USER"</span>)
            .anyRequest().authenticated())
    <span class="hljs-keyword">return</span> http.build();
}
</code></pre>
    <div class="packt_tip">
      <p class="normal">You can read more about request authorization<a id="_idIndexMarker241"/> in the Spring Boot documentation: <span class="url">https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html</span>.</p>
    </div>
    <p class="normal">Spring Security<a id="_idIndexMarker242"/> provides the <code class="inlineCode">@PreAuthorize</code>,<code class="inlineCode"> @PostAuthorize</code>, <code class="inlineCode">@PreFilter</code>,<code class="inlineCode"> @PostFilter</code>, and <code class="inlineCode">@Secured</code> annotations, which are used to apply <strong class="keyWord">method-level security</strong>. Method-level security<a id="_idIndexMarker243"/> is not enabled by default in <code class="inlineCode">spring-boot-starter-security</code>. You have to enable it in your Spring configuration class, for example, in top-level configuration, by using the <code class="inlineCode">@EnableMethodSecurity</code> annotation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> org.springframework.boot.CommandLineRunner;
<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> org.springframework.security.config.annotation.method.</strong></span><span class="code-highlight"><strong class="hljs-slc">configuration.EnableMethodSecurity;</strong></span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="code-highlight"><strong class="hljs-meta-slc">@EnableMethodSecurity</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CardatabaseApplication</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> {
}
</code></pre>
    <p class="normal">Then, you will be able to use the method-level security annotations in your methods. In the following example, users with the <code class="inlineCode">USER</code> role can execute the <code class="inlineCode">updateCar()</code> method and users with the <code class="inlineCode">ADMIN</code> role can execute the <code class="inlineCode">deleteOwner()</code> method. The <code class="inlineCode">@PreAuthorize</code> annotation checks the rule before the method is executed. If the user does not have a specified role, Spring Security prevents method execution, and an <code class="inlineCode">AccessDeniedException</code> is thrown:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CarService</span> {
    <span class="hljs-meta">@PreAuthorize("hasRole('USER')")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateCar</span><span class="hljs-params">(Car car)</span> {
        <span class="hljs-comment">// This method can be invoked by user with USER role.</span>
    }
    <span class="hljs-meta">@PreAuthorize("hasRole('ADMIN')")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteOwner</span><span class="hljs-params">(Car car)</span> {
        <span class="hljs-comment">// This method can be invoked by user with ADMIN role.</span>
    }
}
</code></pre>
    <p class="normal">The <code class="inlineCode">@PreAuthorize</code> annotation replaces the <code class="inlineCode">@Secured</code> annotation, and its use is recommended instead.</p>
    <p class="normal">The <code class="inlineCode">@PostAuthorize</code> annotation can be used to check authorization after the method is executed. You can use this, for example, to check that the user has permission to access the object that the method returns, or you can filter the data returned based on the user’s authorization.</p>
    <p class="normal">The <code class="inlineCode">@PreFilter</code> and <code class="inlineCode">@PostFilter</code> annotations can be used to filter lists of objects, but they are not typically used for role-based access <a id="_idIndexMarker244"/>control. The rules used with these annotations are more fine-grained.</p>
    <div class="note">
      <p class="normal">You can read more about method security<a id="_idIndexMarker245"/> in the Spring Security documentation: <a href="https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html"><span class="url">https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html</span></a>.</p>
    </div>
    <p class="normal">In the next section, we will introduce the basics of OAuth with Spring Boot.</p>
    <h1 id="_idParaDest-66" class="heading-1">Using OAuth2 with Spring Boot</h1>
    <p class="normal">It is really challenging to implement<a id="_idIndexMarker246"/> fully secure authentication<a id="_idIndexMarker247"/> and authorization in your application. In a production environment, it is recommended that you do it using an OAuth2 provider. This actually simplifies the authentication process, and providers typically have excellent security practices.</p>
    <div class="note">
      <p class="normal">These are not detailed instructions for implementing OAuth 2.0 authorization, but they will give you an idea of the process.</p>
    </div>
    <p class="normal"><strong class="keyWord">OAuth</strong> (<strong class="keyWord">Open Authorization</strong>) is a standard for secure access to protected<a id="_idIndexMarker248"/> resources on the internet. The OAuth standard version 2.0 is commonly used nowadays. There are several OAuth 2.0 providers<a id="_idIndexMarker249"/> that implement OAuth<a id="_idIndexMarker250"/> authorization for third-party applications. Some common<a id="_idIndexMarker251"/> providers are listed here:</p>
    <ul>
      <li class="bulletList">Auth0: <a href="https://auth0.com/"><span class="url">https://auth0.com/</span></a></li>
      <li class="bulletList">Okta: <a href="https://www.okta.com/"><span class="url">https://www.okta.com/</span></a></li>
      <li class="bulletList">Keycloak: <a href="https://www.keycloak.org/"><span class="url">https://www.keycloak.org/</span></a></li>
    </ul>
    <p class="normal">You can implement social logins<a id="_idIndexMarker252"/> using OAuth2, after which users can log in with their existing<a id="_idIndexMarker253"/> credentials from social media platforms such as Facebook. OAuth also defines mechanisms for revoking access tokens and handling token expiration. </p>
    <p class="normal">If you want to use OAuth in your Spring Boot applications, the first step is to select an OAuth provider. All providers in the list above can be used with your Spring Boot applications.</p>
    <p class="normal">In the<a id="_idIndexMarker254"/> OAuth2 process, the term <strong class="keyWord">resource owner</strong> refers typically to an end user and the <strong class="keyWord">authorization server</strong> is part of the OAuth provider’s service. The <strong class="keyWord">client</strong> is an application that wants<a id="_idIndexMarker255"/> to get access to protected resources. The <strong class="keyWord">resource server</strong> commonly refers to an API<a id="_idIndexMarker256"/> that the client wants<a id="_idIndexMarker257"/> to use.</p>
    <p class="normal">The simplified version of the OAuth2 authentication process with a REST API contains the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Authentication: The third-party application authenticates by requesting access to protected resources.</li>
      <li class="numberedList">Authorization: The resource owner authorizes access to their resources, commonly through user login.</li>
      <li class="numberedList">The authorization server authorizes the resource owner and redirects the user back to the client with an authorization code.</li>
      <li class="numberedList">The client requests an access token from the authorization server using the authorization code. The access token format is not specified in the standard, and JWTs are quite commonly used.</li>
      <li class="numberedList">The authorization server validates the access token. If the token is valid, the client application receives an access token.</li>
      <li class="numberedList">The client can start to use the access token to access protected resources, for example, calling REST API endpoints.</li>
    </ol>
    <p class="normal">After you have selected a provider and know how its service works, you have to configure your Spring Boot application. Spring Boot provides the <code class="inlineCode">spring-boot-starter-oauth2-client</code> dependency for OAuth2 authentication and authorization. It is used to simplify OAuth 2.0 integration in your Spring Boot application. Quite a few OAuth providers have documentation for different technologies, such as Spring Boot.</p>
    <p class="normal">The implementation will differ depending on the provider. Here are some useful links:</p>
    <ul>
      <li class="bulletList">Auth0 has a good tutorial<a id="_idIndexMarker258"/> for how to add login to your Spring Boot application: <a href="https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive"><span class="url">https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive</span></a>.</li>
      <li class="bulletList">Baeldung provides a quick guide<a id="_idIndexMarker259"/> to using Keycloak with Spring Boot applications: <a href="https://www.baeldung.com/spring-boot-keycloak"><span class="url">https://www.baeldung.com/spring-boot-keycloak</span></a>.</li>
      <li class="bulletList">Spring also has a tutorial<a id="_idIndexMarker260"/> on how to implement social login using GitHub: <span class="url">https://spring.io/guides/tutorials/spring-boot-oauth2</span>.</li>
    </ul>
    <p class="normal">We recommend reading these to get a better idea of using OAuth 2.0 in your own applications.</p>
    <p class="normal">Now, we have finished securing<a id="_idIndexMarker261"/> our backend using the JWT, and we will use<a id="_idIndexMarker262"/> this version when we start to develop our frontend.</p>
    <h1 id="_idParaDest-67" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we focused on making our Spring Boot backend more secure. We started by adding extra protection using Spring Security. Then, we implemented JWT authentication. JWTs are commonly used to secure RESTful APIs and it is a lightweight authentication method suitable for our needs. We also covered the basics of the OAuth 2.0 standard and how to start using it in your Spring Boot application.</p>
    <p class="normal">In the next chapter, we will learn the basics of testing in Spring Boot applications.</p>
    <h1 id="_idParaDest-68" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What is Spring Security?</li>
      <li class="numberedList">How can you secure your backend with Spring Boot?</li>
      <li class="numberedList">What is a JWT?</li>
      <li class="numberedList">How can you secure your backend with a JWT?</li>
      <li class="numberedList">What is OAuth 2.0?</li>
    </ol>
    <h1 id="_idParaDest-69" class="heading-1">Further reading</h1>
    <p class="normal">Packt has other resources available for you to learn about Spring Security. For instance:</p>
    <ul>
      <li class="bulletList"><em class="italic">Spring Security Core: Beginner to Guru,</em> by John Thompson (<a href="https://www.packtpub.com/product/spring-security-core-beginner-to-guru-video/9781800560000"><span class="url">https://www.packtpub.com/product/spring-security-core-beginner-to-guru-video/9781800560000</span></a>)</li>
    </ul>
    <h1 class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask the author questions, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/FullStackSpringBootReact4e"><span class="url">https://packt.link/FullStackSpringBootReact4e</span></a></p>
    <p class="normal"><img src="../Images/QR_Code107961080093826402.png" alt="" role="presentation"/></p>
  </div>
</body></html>