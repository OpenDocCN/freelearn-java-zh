<html><head></head><body>
		<div id="_idContainer018">
			<h1 id="_idParaDest-42"><em class="italic"><a id="_idTextAnchor049"/>Chapter 3</em>: Introducing the IBM Stock Trader Cloud-Native Application</h1>
			<p>Throughout this book, we'll be using an example application known as <strong class="bold">IBM Stock Trader</strong> to demonstrate various concepts and techniques. This open source example is intended to show people how to develop, deploy, and use a typical cloud-native application that is composed of various microservices and leverages various external services such as databases, messaging systems, and internet services. All microservices are containerized and deployed (via an operator) to a Kubernetes cluster such as the <strong class="bold">OpenShift Container Platform</strong>.</p>
			<p>As the name implies, the IBM Stock Trader example exists in the financial domain, simulating a brokerage application that tracks the stocks each customer has purchased in their portfolio. While it doesn't actually buy or sell anything, it does look up current actual prices of specified stocks and computes an overall portfolio value that maps to a customer loyalty level. It also simulates an account balance from which it debits commissions paid per trade and tracks the <strong class="bold">return on investment</strong> (<strong class="bold">ROI</strong>) for each portfolio. As well as this, it has optional pieces that do things such as send out notifications when new loyalty levels are reached and analyze submitted feedback to see if free (no commission) trades should be granted, demonstrating how it interacts with real-world systems such as Slack, Twitter, or <strong class="bold">International Business Machine Corporation's</strong> (<strong class="bold">IBM's</strong>) Watson.</p>
			<p>As we discuss each MicroProfile 4.x technology in upcoming chapters, we'll be referring back to how this example demonstrates the usage of each. We'll include code snippets from various microservices that comprise the example, explaining the benefits the application derives from using each MicroProfile technology. </p>
			<p>In this chapter, we're going to cover the following main topics: </p>
			<ul>
				<li>Overview of the IBM Stock Trader application</li>
				<li>Mandatory microservices and external services</li>
				<li>Optional microservices and external services</li>
			</ul>
			<p>By the end of this chapter, you will be familiar with the application, how to use it, how the various parts fit together to make a composite application, and which parts you can ignore if you're in a hurry.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor050"/>Overview of the IBM Stock Trader application</h1>
			<p>Created and <a id="_idIndexMarker160"/>enhanced over the past 3-4 years, this polyglot example demonstrates how to create containerized microservices, targeting a variety of application runtimes. For the most part, these microservices are deliberately kept simple so that readers don't get bogged down in the deep technical intricacies that would likely exist in a real brokerage application. That said, it is very much intended to be significantly more instructive than the various <em class="italic">Hello World</em>-level examples often shown in beginners' documentation for cloud-native programming.</p>
			<p>The example consists of about a dozen microservices that interact with about a dozen external dependencies (most of which are optional). There is also a Helm chart and an OpenShift operator (which wraps the Helm chart) used for deployment of the example, which will be covered in <a href="B17377_09_Final_SB_epub.xhtml#_idTextAnchor173"><em class="italic">Chapter 9</em></a>, <em class="italic">Deployment and Day 2 Operations</em>.</p>
			<p>In this section, we will provide a high-level overview of the application, the microservices that comprise it, and what they do. Let's start by looking at <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>).</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor051"/>UIs</h2>
			<p>Before <a id="_idIndexMarker161"/>diving into all of the backend <a id="_idIndexMarker162"/>microservices running in the cloud, let's look at what is provided as a client for you to use in your web browser. There is actually a choice of <strong class="bold">graphical UI</strong> (<strong class="bold">GUI</strong>) clients <a id="_idIndexMarker163"/>for this example. There's a simple Java<a id="_idIndexMarker164"/> servlet /JSP-based UI called <strong class="bold">Trader</strong> that deliberately uses very simplistic <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) to render results so that the servlet code is easily understandable. Let's take a look at this simplistic client in the following screenshot:</p>
			<p class="figure-caption"><img src="image/Figure_1.1_B17377_new.png" alt="Figure 3.1 – Simple Java servlet-based UI: Trader&#13;&#10;"/></p>
			<p class="figure-caption">Figure 3.1 – Simple Java servlet-based UI: Trader</p>
			<p>As you can <a id="_idIndexMarker165"/>see, this client provides a list <a id="_idIndexMarker166"/>of the portfolios and allows you to view the details of one, modify one, create a new one, or delete one. You have to log in successfully to use the client and have the option to submit feedback, which can lead to free (no-commission) trades. It will show your current loyalty level, your account balance, and your ROI.</p>
			<p>There is also a fancier user interface called <strong class="bold">Tradr</strong> that is written in Node.js using the <strong class="bold">Vue.js UI framework</strong> and <a id="_idIndexMarker167"/>that provides a more modern experience; this requires JavaScript to be enabled in your browser. Let's take a look at that one too—you can see it in <a id="_idIndexMarker168"/>the<a id="_idIndexMarker169"/> following screenshot:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_1.2_B17377.png.jpg" alt="Figure 3.2 – Fancy Node.js-based UI: Tradr&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Fancy Node.js-based UI: Tradr</p>
			<p>Both clients have the same functionality. The fancier one is a bit more complicated to understand when reading its code, but it presents a much more professional-looking, responsive experience. Trader looks as though it was written at the end of the twentieth century, while Tradr looks as though it was written in the modern day. </p>
			<p>There is also a command-line client called <strong class="source-inline">loopctl</strong> that runs a specified number of iterations (on parallel threads) of actions upon portfolios, which can be used for performance <a id="_idIndexMarker170"/>and throughput testing, as<a id="_idIndexMarker171"/> illustrated here:</p>
			<p class="source-code">sh-4.4$ ./loopctl.sh 1 1</p>
			<p class="source-code">1:  GET /broker</p>
			<p class="source-code">[{"owner": "Raunak", "total": 1,160,209.07, "loyalty": "PLATINUM", "balance": -89.82, "commissions": 139.82, "free": 0, "nextCommission": 5.99, "sentiment": "Unknown", "stocks": {}}, {"owner": "Karri", "total": 10,413.06, "loyalty": "BRONZE", "balance": 31.02, "commissions": 18.98, "free": 0, "nextCommission": 8.99, "sentiment": "Unknown", "stocks": {}}, {"owner": "Alex", "total": 12,049.00, "loyalty": "BRONZE", "balance": 41.01, "commissions": 8.99, "free": 0, "nextCommission": 8.99, "sentiment": "Unknown", "stocks": {}}, {"owner": "John", "total": 79,544.03, "loyalty": "SILVER", "balance": 16.04, "commissions": 33.96, "free": 0, "nextCommission": 7.99, "sentiment": "Unknown", "stocks": {}}, {"owner": "Eric", "total": 120,835.00, "loyalty": "GOLD", "balance": 43.01, "commissions": 6.99, "free": 0, "nextCommission": 6.99, "sentiment": "Unknown", "stocks": {}}, {"owner": "Charlie", "total": 3,004,905.16, "loyalty": "PLATINUM", "balance": 34.02, "commissions": 15.98, "free": 0, "nextCommission": 5.99, "sentiment": "Unknown", "stocks": {}}]</p>
			<p class="source-code">2:  POST /broker/Looper1</p>
			<p class="source-code">{"owner": "Looper1", "total": 0.00, "loyalty": "Basic", "balance": 50.00, "commissions": 0.00, "free": 0, "nextCommission": 9.99, "sentiment": "Unknown", "stocks": {}}</p>
			<p class="source-code">3:  PUT /broker/Looper1?symbol=IBM&amp;shares=1</p>
			<p class="source-code">{"owner": "Looper1", "total": 127.61, "loyalty": "Basic", "balance": 40.01, "commissions": 9.99, "free": 0, "nextCommission": 9.99, "sentiment": "Unknown", "stocks": {"IBM": {"symbol": "IBM", "shares": 1, "price": 127.61, "date": "2021-03-12", "total": 127.61, "commission": 9.99}}}</p>
			<p class="source-code">4:  PUT /broker/Looper1?symbol=AAPL&amp;shares=2</p>
			<p class="source-code">{"owner": "Looper1", "total": 369.67, "loyalty": "Basic", "balance": 30.02, "commissions": 19.98, "free": 0, "nextCommission": 9.99, "sentiment": "Unknown", "stocks": {"AAPL": {"symbol": "AAPL", "shares": 2, "price": 121.03, "date": "2021-03-12", "total": 242.06, "commission": 9.99}{"IBM": {"symbol": "IBM", "shares": 1, "price": 127.61, "date": "2021-03-12", "total": 127.61, "commission": 9.99}}}</p>
			<p>In the interest of brevity, only the first 4 of the 12 steps in each iteration are shown in the preceding output. In short, it creates a new portfolio, buys and sells stock in it, and deletes it, and does these dozen steps as many times as you request, on as many parallel<a id="_idIndexMarker172"/> threads as you want, and reports<a id="_idIndexMarker173"/> timings.</p>
			<p>No matter which of the three clients you use, they all make <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) calls<a id="_idIndexMarker174"/> to the same <strong class="bold">Broker</strong> microservice, which in turn reaches out to the other microservices as needed, as we'll see in the next section.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor052"/>Architectural diagram</h2>
			<p>Let's take <a id="_idIndexMarker175"/>a look at a diagram showing how all of the pieces fit together. It may look a little overwhelming at first but, per the advice from <em class="italic">The Hitchhiker's Guide to the Galaxy</em>, "<em class="italic">don't panic!".</em> Most of the microservices and dependencies you see in the following diagram are optional:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_1.3_B17377.jpg" alt="Figure 3.3 – Architectural diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Architectural diagram</p>
			<p>There is a<a id="_idIndexMarker176"/> GitHub repository at <a href="https://github.com/IBMStockTrader">https://github.com/IBMStockTrader</a> for each of the solid color boxes shown in <em class="italic">Figure 3.3</em>. As per standard GitHub naming conventions, each microservice name is converted to all lowercase, and a dash is used between words in a multi-word name; for example, the <strong class="bold">Stock Quote</strong> microservice<a id="_idIndexMarker177"/> is available at <a href="https://github.com/IBMStockTrader/stock-quote">https://github.com/IBMStockTrader/stock-quote</a>.</p>
			<p>There is also a Docker Hub repository at <a href="https://hub.docker.com/u/ibmstocktrader">https://hub.docker.com/u/ibmstocktrader</a> for each of these microservices. You can of course build each from their source code in GitHub (which we'll discuss in <a href="B17377_08_Final_SB_epub.xhtml#_idTextAnchor159"><em class="italic">Chapter 8</em></a>, <em class="italic">Building and Testing your Cloud-Native Application</em>) and push the images to whichever image repository you want, such as the one built into your OpenShift cluster. But to make it easier to deploy the example, there are pre-built images provided as well. If you use the operator to deploy the example, it will default to pulling the images from Docker Hub, but you can replace the default image and tag fields for each microservice to pull from any image repository.</p>
			<p>In the following sections, we'll look at each microservice in the application, as well as its dependencies.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor053"/>Mandatory microservices and external services</h1>
			<p>As mentioned <a id="_idIndexMarker178"/>earlier, the core part of the example is just that which is needed to do the basics of creating portfolios and buying/selling stock. Those parts of the example have a solid border around each box, as shown in <em class="italic">Figure 3.3</em>.</p>
			<p>The following subsections will describe each of the microservices and their dependencies that are required in order to exercise the primary functionality of the <strong class="bold">IBM Stock Trader</strong> application—that is, the ability to create portfolios and buy and sell stocks within them.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor054"/>Trader</h2>
			<p><strong class="bold">Trader</strong> is the<a id="_idIndexMarker179"/> standard UI <a id="_idIndexMarker180"/>client for the example. As seen earlier in <em class="italic">Figure 3.1</em>, it presents a list of existing portfolios, allowing you to create new ones, update existing ones (by buying or selling stocks), and delete portfolios. It communicates, via REST service calls, with <a id="_idIndexMarker181"/>the Broker microservice, passing <a id="_idIndexMarker182"/>a <strong class="bold">JavaScript Object Notation (JSON) Web Token</strong> (<strong class="bold">JWT</strong>) for <strong class="bold">single-sign-on</strong> (<strong class="bold">SSO</strong>) purposes.</p>
			<p>It is<a id="_idIndexMarker183"/> implemented via a set of simple Java servlets and JSPs that, as with most of the Stock Trader microservices, runs atop the open source Open Liberty application <a id="_idIndexMarker184"/>server, running in the <strong class="bold">Universal Base Image</strong> (<strong class="bold">UBI</strong>), which is a <strong class="bold">Red Hat Enterprise Linux</strong> (<strong class="bold">RHEL</strong>) 8.4 container with<a id="_idIndexMarker185"/> the Open J9 Java 11 <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>).</p>
			<p>There are choices for how this client performs authentication. The default and easiest way is to log in against a hardcoded list of credentials defined in a <strong class="source-inline">basicRegistry</strong> stanza within the <strong class="source-inline">server.xml</strong> file of the Trader microservice, such as <strong class="source-inline">stock</strong>/<strong class="source-inline">trader</strong> as the <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>)/password.</p>
			<h3>LDAP</h3>
			<p>Another <a id="_idIndexMarker186"/>option you can choose with the Trader microservice is <a id="_idIndexMarker187"/>to log in against your company's <strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>) server. This way, your employees can log in against their corporate user registry, such as with their serial number or email address. Note that if you are deploying the example to an OpenShift cluster in the public cloud and your user registry server runs in an on-premises data center behind a firewall, then <a id="_idIndexMarker188"/>you'll need to set up a <strong class="bold">virtual private network</strong> (<strong class="bold">VPN</strong>) connection back to that LDAP server.</p>
			<h3>OIDC</h3>
			<p>The final <a id="_idIndexMarker189"/>option for authentication with the Trader microservice is to log<a id="_idIndexMarker190"/> in using an <strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>) server. This option is often used if you want to require authentication via a third-party provider out on the internet, such as logging in via your Facebook, Twitter, or GitHub credentials. For testing purposes, you can also deploy your own OIDC server locally into your <a id="_idIndexMarker191"/>OpenShift cluster, such as by using the operator (in <a id="_idIndexMarker192"/>OperatorHub) for <strong class="bold">Red Hat SSO</strong> (<strong class="bold">RH-SSO</strong>), which is based on the open source <strong class="bold">Keycloak</strong> project.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor055"/>Broker</h2>
			<p>Architects <a id="_idIndexMarker193"/>often recommend<a id="_idIndexMarker194"/> using a <strong class="bold">model-view-controller</strong> (<strong class="bold">MVC</strong>) architecture with a<a id="_idIndexMarker195"/> multi-tiered application. With the Stock Trader example, the JSON is the <em class="italic">model</em>, Trader (or the optional Tradr or Looper) is the <em class="italic">view</em>, and the <strong class="bold">Broker</strong> microservice serves as the <em class="italic">controller</em>.</p>
			<p>It is a stateless microservice that, as with most of the microservices in this example, exposes a REST <a id="_idIndexMarker196"/>interface via the <strong class="bold">Jakarta RESTful Web Services</strong> (<strong class="bold">JAX-RS</strong>). It coordinates calls to various other microservices such as <strong class="bold">Portfolio</strong> and the optional <strong class="bold">Account</strong> and <strong class="bold">Trade History</strong>. It does not directly depend on any external services.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor056"/>Portfolio</h2>
			<p>This<a id="_idIndexMarker197"/> microservice<a id="_idIndexMarker198"/> takes care of all of the stock-related operations for a given portfolio. It reaches out to the <strong class="bold">Stock Quote</strong> microservice to get the current price of the desired stock.</p>
			<p>Conceptually, it is a stateful microservice; however, it does not maintain any state in memory. Instead, it connects to a relational database to persist and access its data. That database can be running locally in your OpenShift cluster or out in the cloud, or in an on-premises data center (which, if so, would require a VPN connection to reach). The microservice <a id="_idIndexMarker199"/>uses <strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>) to interact<a id="_idIndexMarker200"/> with the database, and optionally uses <strong class="bold">Kafka</strong> to post a message to a topic.</p>
			<h3>JDBC database</h3>
			<p><strong class="bold">Portfolio</strong> uses<a id="_idIndexMarker201"/> two <a id="_idIndexMarker202"/>tables in a relational database, named <strong class="source-inline">Portfolio</strong> and <strong class="source-inline">Stock</strong>. There is a row in the <strong class="source-inline">Portfolio</strong> table corresponding to each row you see in the table in the client. There is also a row in the <strong class="source-inline">Stock</strong> table for each stock purchased. The <strong class="source-inline">Stock</strong> table has a foreign key back to the <strong class="source-inline">Portfolio</strong> table, and a <strong class="source-inline">cascade delete</strong> rule on the relationship that will remove all of the stocks for a given portfolio if that portfolio is deleted.</p>
			<p>Since this example was created by IBMers and is often used to demonstrate how to connect up a cloud-native application to various IBM products, usually IBM's <strong class="bold">Db2</strong> (part of the IBM <em class="italic">Cloud Pak for Data</em>) is used as the relational database. However, it has been tested with other <strong class="bold">JDBC</strong> providers, such <a id="_idIndexMarker203"/>as the open source <strong class="bold">Apache Derby</strong>. Note that no code needed to change in the microservice to switch providers; only the <strong class="source-inline">server.xml</strong> file and the <strong class="source-inline">Dockerfile</strong> (to copy the JDBC <strong class="bold">Java ARchive</strong> (<strong class="bold">JAR</strong>) file <a id="_idIndexMarker204"/>into the container) needed updates to choose a different relational database vendor.</p>
			<p>Here's a graphical view of the resources that Portfolio uses in a <strong class="bold">Db2-as-a-Service</strong> database hosted in the IBM cloud:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_1.4_B17377.jpg" alt="Figure 3.4 – Details of the IBM Db2 on cloud database used by Portfolio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Details of the IBM Db2 on cloud database used by Portfolio</p>
			<p>In the preceding<a id="_idIndexMarker205"/> screenshot, you can see the details of the table holding each of the stocks that have been purchased; the <strong class="bold">OWNER</strong> column is a foreign key back to the portfolio containing the stocks.</p>
			<h3>Kafka</h3>
			<p>Portfolio also <a id="_idIndexMarker206"/>has an optional dependency on <strong class="bold">Kafka</strong>. If <a id="_idIndexMarker207"/>configured, Portfolio will publish a message to a Kafka topic whenever a stock is traded. The optional Trade History microservice will subscribe to this topic, using MicroProfile Reactive Messaging (which we'll discuss further in <a href="B17377_10_Final_SB_epub.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a>, <em class="italic">Reactive Cloud-Native Applications</em>), and act upon the message.</p>
			<p>Usually, the <strong class="bold">IBM Event Streams</strong> product (from the IBM <em class="italic">Cloud Pak for Integration</em>) is chosen as the <a id="_idIndexMarker208"/>Kafka provider. However, other providers could be used, such as <strong class="bold">AMQ Streams</strong> from <a id="_idIndexMarker209"/>Red <a id="_idIndexMarker210"/>Hat, if desired.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor057"/>Stock Quote</h2>
			<p>This is the<a id="_idIndexMarker211"/> simplest<a id="_idIndexMarker212"/> microservice in the example. It merely calls a <a id="_idIndexMarker213"/>REST <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) in the cloud that returns the current price of the specified stock (quotes are 15 minutes delayed from this free service; more real-time quotes cost money). There is also an optional caching service that can be used so that calls for the same stock ticker symbol (within a configurable period that defaults to 1 hour) can be returned quickly, without having to make another call out onto the internet.</p>
			<p>Note that this is the only microservice that is configured to run on Red Hat's <strong class="bold">Quarkus</strong> application framework. All of the other Java-based microservices run on Open Liberty. Quarkus is another Java MicroProfile implementation. The Java code is the same either way; the only difference is in how it is built and configured and which starting-point Docker container it runs in.</p>
			<h3>API Connect</h3>
			<p>The REST <a id="_idIndexMarker214"/>API that Stock Quote calls is implemented <a id="_idIndexMarker215"/>in <strong class="bold">API Connect</strong> (part of the <em class="italic">IBM Cloud Pak for Integration</em>). You can simply accept the defaults and it will use a pre-provisioned instance with everything already set up. This API fronts a free service out in <strong class="bold">IEX Cloud</strong> that returns stock prices with a 15-minute delay (getting more real-time prices costs money). For information on how to set up this API in your own instance of API Connect, see <a href="https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4">https://medium.com/cloud-engagement-hub/introducing-api-connect-a0218c906ce4</a>. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">This API used to use a different free stock price service from Quandl, but that service went offline; the nice thing was that nothing in the Stock Trader example had to change—it was simply an update to the implementation of the API from API Connect, which still presented the same operation signature.</p>
			<h3>Redis</h3>
			<p>Stock Quote<a id="_idIndexMarker216"/> uses <strong class="bold">Redis</strong> as its optional caching service. If not<a id="_idIndexMarker217"/> present, then each call will result in a trip out to the internet to get the stock price. By caching each stock's price in Redis, it means you can scale the Stock Quote microservice up to as many pods as you want and be sure that no matter which one you get routed to each time, you will get a consistent answer. It also means that in true <em class="italic">serverless</em> fashion (where stuff not recently used gets stopped to save money and <a id="_idIndexMarker218"/>restarted <strong class="bold">just in time</strong> (<strong class="bold">JIT</strong>) when new requests arrive), you can scale all the way down to zero pods when not needed and be sure that when you get scaled back up to handle new requests, you can still benefit from the previously cached data.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor058"/>Optional microservices and external services</h1>
			<p>There are also several <a id="_idIndexMarker219"/>optional parts of the example that you would only set up if you wanted certain extra bells and whistles available (such as having it send a tweet when you level up from <strong class="bold">SILVER</strong> to <strong class="bold">GOLD</strong>). Those parts have a dashed border in the architectural diagram.</p>
			<p>Most people setting up the example skip many (or sometimes all) of the following pieces in the interest of simplicity. But each of these demonstrates how to do some additional things in<a id="_idIndexMarker220"/> a cloud-native manner, so they serve as good examples of how to utilize additional <strong class="bold">Java Enterprise Edition</strong> (<strong class="bold">EE</strong>)/<strong class="bold">Jakarta EE</strong> and <strong class="bold">MicroProfile</strong> technologies.</p>
			<p>In this section, we will take a look at each of these optional microservices and their dependencies. The first of these is the alternate UI we saw earlier.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor059"/>Tradr</h2>
			<p>The more<a id="_idIndexMarker221"/> attractive UI is called <strong class="bold">Tradr</strong>. Its<a id="_idIndexMarker222"/> source code (the only non-Java microservice in the example) is a bit more complicated to read, but it provides a much more modern, responsive interface, as is generally expected these days of professional websites. It calls the exact same REST services from the Broker microservice—it just renders the results in a more appealing way.</p>
			<p>Note that, whereas Trader offers a choice of authentication approaches, with the default being a very simple approach requiring no extra setup, the Tradr client requires the use of OIDC. This means you have to do extra setup, to either stand up your own OIDC server in your OpenShift cluster or to adjust the configuration of an external OIDC server (which <a id="_idIndexMarker223"/>often requires registering <a id="_idIndexMarker224"/>a<a id="_idIndexMarker225"/> callback <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) pointing back to the OpenShift route for Tradr).</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor060"/>Account</h2>
			<p>This optional <a id="_idIndexMarker226"/>microservice takes care of things associated with a portfolio that are above and beyond the list of which stocks it holds. This includes the loyalty level, the account balance, commissions paid, the owner's sentiment, and any free trades they have earned. Those fields will just show <strong class="source-inline">Unknown</strong> (for strings) or <strong class="source-inline">-1</strong> (for numbers) if this microservice is not configured.</p>
			<p>Although the Portfolio<a id="_idIndexMarker227"/> microservice chose to use an old-fashioned <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>)-based database, this one demonstrates the use of a more modern NoSQL database to store each JSON document: IBM <strong class="bold">Cloudant</strong> (from the IBM <em class="italic">Cloud Pak for Data</em>).</p>
			<h3>Cloudant</h3>
			<p>Note that<a id="_idIndexMarker228"/> whereas the Portfolio<a id="_idIndexMarker229"/> microservice had to do an object-to-relational mapping (such as turning the one-to-many containment relationship between <strong class="source-inline">Portfolio</strong> and <strong class="source-inline">Stock</strong> into a foreign key with a <strong class="source-inline">cascade delete</strong> rule), that isn't necessary for the Account microservice. The exact same JSON that gets returned by each of the REST operations on this JAX-RS-based microservice is what is stored in the Cloudant database, as we can see here:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_1.5_B17377.jpg" alt="Figure 3.5 – An example Account document stored in IBM Cloudant&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – An example Account document stored in IBM Cloudant</p>
			<p>In the <a id="_idIndexMarker230"/>preceding screenshot, we<a id="_idIndexMarker231"/> can see the data that Account manages, including the loyalty level and the account balance. Note that the <strong class="source-inline">_id</strong> and <strong class="source-inline">_rev</strong> fields are ones added by Cloudant itself to manage how you find a specific document (<strong class="source-inline">_id</strong>) and revisions on a document (<strong class="source-inline">_rev</strong>).</p>
			<h3>ODM</h3>
			<p>Rather than<a id="_idIndexMarker232"/> hardcode the business rule<a id="_idIndexMarker233"/> for determining the loyalty level in Java, this microservice externalizes that rule to a business rules engine. This allows us to adjust thresholds, such as how high the portfolio's total value must reach to achieve <strong class="bold">GOLD</strong> status, on the fly via a dashboard, without having to change and redeploy the microservice.</p>
			<p>The example uses the IBM <strong class="bold">Operational Decision Manager</strong> (<strong class="bold">ODM</strong>), from the IBM <em class="italic">Cloud Pak for Automation</em>, as its business rules engine. There is a ruleset ZIP file in the Account Git repository (<a href="https://github.com/IBMStockTrader/account/blob/master/stock-trader-loyalty-decision-service.zip">https://github.com/IBMStockTrader/account/blob/master/stock-trader-loyalty-decision-service.zip</a>) that you can import into the Decision Center UI and deploy to a Decision server. If ODM isn't configured, the loyalty level will just remain at its starting value forever.</p>
			<p>Let's take a look at the <strong class="bold">Decision Center</strong> UI in the following screenshot:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_1.6_B17377.jpg" alt="Figure 3.6 – The IBM ODM Decision Center UI, showing our decision table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – The IBM ODM Decision Center UI, showing our decision table</p>
			<p>Here, we<a id="_idIndexMarker234"/> can see the decision<a id="_idIndexMarker235"/> table, showing the various thresholds. For example, once your portfolio's total value crosses <strong class="bold">US dollars</strong> (<strong class="bold">USD</strong>) $50,000, its loyalty level goes from <strong class="bold">BRONZE</strong> to <strong class="bold">SILVER</strong>.</p>
			<h3>Jakarta Messaging</h3>
			<p>When<a id="_idIndexMarker236"/> the<a id="_idIndexMarker237"/> loyalty level changes (meaning you have ODM configured and have bought enough stock—for example, the default threshold, as you can see in <em class="italic">Figure 3.6</em>, is $100,000 to reach <strong class="bold">GOLD</strong>), the Account microservice will post a message to a <strong class="bold">Jakarta Messaging</strong> queue. There are downstream microservices that will react to that message.</p>
			<p>Usually, the IBM <strong class="bold">MQ</strong> product, from the <em class="italic">IBM Cloud Pak for Integration</em>, is used as the Jakarta Messaging provider. You can also choose other providers—for example, the example has been tested with <a id="_idIndexMarker238"/>Open Liberty's built-in <strong class="bold">Java Message Service</strong> (<strong class="bold">JMS</strong>) provider as well. As with JDBC providers, no Java code needs to change in order to pick a different provider; the change is just an update to the <strong class="source-inline">server.xml</strong> file and <a id="_idIndexMarker239"/>a line in the <strong class="source-inline">Dockerfile</strong> to copy <a id="_idIndexMarker240"/>the Jakarta Messaging <strong class="source-inline">.rar</strong> file into the container.</p>
			<h3>Watson Tone Analyzer</h3>
			<p>Normally, whenever<a id="_idIndexMarker241"/> you <a id="_idIndexMarker242"/>buy or sell a stock, a commission is debited from your account balance. However, it is possible to earn a free (zero commission) trade by using the <strong class="bold">Submit Feedback</strong> button. Whatever text you type will be sent to the IBM <em class="italic">Watson Tone Analyzer</em> (hosted in the IBM Cloud), and a <strong class="source-inline">sentiment</strong> will be determined and returned. You get one free trade for submitting most kinds of feedback, but there's a rule that will give you three free trades in order to soothe you if it determines your sentiment is <strong class="bold">Angry</strong>. </p>
			<p>If you don't configure the Watson Tone Analyzer, you'll get back <strong class="bold">Unknown</strong> and no free trades.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor061"/>Trade History</h2>
			<p>This microservice <a id="_idIndexMarker243"/>keeps a record of <a id="_idIndexMarker244"/>every trade you made, when you made it, and what the stock cost when you made it. Without this microservice, the example only knows aggregate information. For example, if you bought 10 shares of IBM stock a month ago for $100, and 5 shares a week ago for $110, and 2 more shares today for $120, the Portfolio microservice would just know you now have 17 shares and what they are worth today ($2,040 in this example). The Trade History microservice remembers all of the details, so it would know you spent $1,790 and thus have an ROI of 14%. If this microservice isn't configured, the Trader and Tradr clients will just say <strong class="bold">Unknown</strong> for the ROI.</p>
			<p>As mentioned in the discussion of the Portfolio microservice, this microservice subscribes to and consumes the messages that Portfolio publishes to the Kafka topic, such as would be<a id="_idIndexMarker245"/> managed by <em class="italic">IBM Event Streams</em>. It does so via <strong class="bold">MicroProfile Reactive Messaging</strong>.</p>
			<h3>Mongo</h3>
			<p>This<a id="_idIndexMarker246"/> microservice <a id="_idIndexMarker247"/>uses a <strong class="bold">Mongo</strong> database to persist the details of each trade. Its readiness probe checks to make sure Mongo is running at the specified endpoint via the specified credentials—if Mongo is unavailable, then the pods for this deployment will never reach a <strong class="source-inline">Ready</strong> state and thus nothing will ever consume the messages from the topic.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor062"/>Messaging</h2>
			<p>This microservice <a id="_idIndexMarker248"/>consumes the JSON<a id="_idIndexMarker249"/> messages from the JMS queue about the change in loyalty level that the Account microservice sent. This microservice has the<a id="_idIndexMarker250"/> only Jakarta <strong class="bold">Enterprise Bean</strong> in the<a id="_idIndexMarker251"/> example, using a <strong class="bold">Message Driven Bean</strong> (<strong class="bold">MDB</strong>) to receive the messages. It then alerts you via the <strong class="bold">Notification</strong> microservice about the newly reached level. As with the Account microservice, this one also needs a Jakarta Messaging provider such as IBM MQ, as we can see in the following screenshot:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_1.7_B17377.jpg" alt="Figure 3.7 – The IBM MQ UI, showing a message sent by the Account microservice&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – The IBM MQ UI, showing a message sent by the Account microservice</p>
			<p>Here, we see a simple JSON message on the MQ queue that gets processed by the Messaging microservice to provide a notification—in this case, about <strong class="bold">Emily</strong> having upgraded her loyalty level from <strong class="bold">SILVER</strong> to <strong class="bold">GOLD</strong>.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor063"/>Notifications</h2>
			<p>There are <a id="_idIndexMarker252"/>two different <a id="_idIndexMarker253"/>flavors of the Notification microservice—one sends a tweet and the other posts to a Slack channel. Both have the same REST interface, so you just pick which you want to use when you deploy the example.</p>
			<h3>Notification-Twitter</h3>
			<p>The <strong class="bold">Notification-Twitter</strong> flavor <a id="_idIndexMarker254"/>uses<a id="_idIndexMarker255"/> the open source library from <a href="http://twitter4j.org">twitter4j.org</a> to interact with Twitter's REST API to send a tweet.</p>
			<p>Whereas most of the microservices in this example run on Open Liberty, this one runs on the <strong class="bold">traditional WebSphere Application Server</strong> (<strong class="bold">tWAS</strong>) in a Docker container.</p>
			<p>For more<a id="_idIndexMarker256"/> information on how this was set up, see <a href="https://medium.com/cloud-engagement-hub/experiences-using-the-twas-docker-container-557a9b044370">https://medium.com/cloud-engagement-hub/experiences-using-the-twas-docker-container-557a9b044370</a>. </p>
			<p>To configure the<a id="_idIndexMarker257"/> example to send tweets via your account, you need to get the <strong class="bold">Open Authorization</strong> (<strong class="bold">OAuth</strong>) credentials for your Twitter account. You'll need the consumer key and consumer secret, as well as the access token and access token secret. Here's an example tweet from Notification-Twitter:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_1.8_B17377.jpg" alt="Figure 3.8 – An example tweet sent by Notification-Twitter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – An example tweet sent by Notification-Twitter</p>
			<p>In <em class="italic">Figure 3.8</em> you see the tweet from the <strong class="source-inline">@IBMStockTrader</strong> account that was sent when the loyalty level upgraded from <strong class="bold">BRONZE</strong> to <strong class="bold">GOLD</strong>.</p>
			<h3>Notification-Slack</h3>
			<p>This flavor<a id="_idIndexMarker258"/> of the Notification microservice<a id="_idIndexMarker259"/> posts a message to a Slack channel. As with the Twitter flavor, it does so whenever a JMS message about a loyalty-level change is processed. The microservice calls a <em class="italic">serverless</em> function that sends the actual post to Slack, as we see here:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_1.9_B17377.jpg" alt="Figure 3.9 – An example Slack message sent by Notification-Slack&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – An example Slack message sent by Notification-Slack</p>
			<p>As you can see, the message is much like what was sent to Twitter, but in this case, it was sent to a Slack channel instead.</p>
			<p>The <em class="italic">serverless</em> function is implemented <a id="_idIndexMarker260"/>via the <strong class="bold">Apache OpenWhisk</strong> framework. You can either deploy OpenWhisk to your OpenShift cluster or use IBM's <strong class="bold">Function-as-a-Service</strong> (<strong class="bold">FaaS</strong>) known <a id="_idIndexMarker261"/>as <em class="italic">IBM Cloud Functions</em>. For details on how the action sequence was <a id="_idIndexMarker262"/>created that posts a message to the Slack channel, see <a href="https://medium.com/cloud-engagement-hub/serverless-computing-and-apache-openwhisk-164676af8972">https://medium.com/cloud-engagement-hub/serverless-computing-and-apache-openwhisk-164676af8972</a>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is also an Amazon Web Services (AWS) Lambda serverless function that Notification-Slack can invoke to cause the message to get posted to the Slack channel. It expects the same API definition as the OpenWhisk function, so no changes were needed to the Notification-Slack microservice - you just configure it with a different URL and credentials via the operator. Whether you choose IBM Cloud Functions or AWS Lambda, this shows that Kubernetes and serverless frameworks can work together harmoniously.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor064"/>Collector</h2>
			<p>This <a id="_idIndexMarker263"/>microservice <a id="_idIndexMarker264"/>receives evidence from other microservices, persists it to IBM Cloudant, and makes it available for <a id="_idIndexMarker265"/>periodic scraping by a security/compliance tool such as the <strong class="bold">Security and Compliance Center</strong> (<strong class="bold">SCC</strong>) in the IBM cloud. <strong class="source-inline">Trader</strong> can be configured to send evidence about login attempts, and <strong class="source-inline">Stock Quote</strong> can be configured to send evidence about cache hits (in Redis). It receives evidence via REST (a <strong class="source-inline">POST</strong> request) and exposes evidence via REST (a <strong class="source-inline">GET</strong> request).</p>
			<p>Unlike the other microservices, this one does <a id="_idIndexMarker266"/>not use <strong class="bold">MicroProfile JWT</strong> (<strong class="bold">mpJWT</strong>) for SSO; instead, it just uses basic auth (a simple user ID and password) since SCC would not know how to produce and sign such a JWT when it scrapes the <strong class="source-inline">/collector</strong> endpoint. This is similar to how <strong class="bold">MicroProfile Metrics</strong> (<strong class="bold">mpMetrics</strong>) does <a id="_idIndexMarker267"/>not use mpJWT, since a monitoring tool<a id="_idIndexMarker268"/> such as Prometheus would likewise not be able to create<a id="_idIndexMarker269"/> and attach such a JWT when it scrapes the <strong class="source-inline">/metrics</strong> endpoint.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor065"/>Looper</h2>
			<p>The final <a id="_idIndexMarker270"/>optional microservice<a id="_idIndexMarker271"/> in this example is called <strong class="bold">Looper</strong>. This is a servlet used for performance and stress testing. Via a query parameter (which defaults to <strong class="source-inline">1</strong> if not specified) on its route URL, you can tell it to run a specified number of iterations<a id="_idIndexMarker272"/> of a dozen operations, which show off all of the <strong class="bold">create, retrieve, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations available on the Broker microservice.</p>
			<p>For example, the operator for this example (which will be described in detail in <a href="B17377_09_Final_SB_epub.xhtml#_idTextAnchor173"><em class="italic">Chapter 9</em></a>, <em class="italic">Deployment and Day 2 Operations</em>) has a checkbox to set up a <strong class="bold">Horizontal Pod Autoscaler</strong> (<strong class="bold">HPA</strong>) that<a id="_idIndexMarker273"/> will scale up each microservice to additional <a id="_idIndexMarker274"/>pods if they reach certain <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) thresholds (and will scale back down when the CPU usage drops back off). By using Looper to put the example under load, you can see the HPA in action, and you can see that the resource usage graphs in the OpenShift console<a id="_idIndexMarker275"/> show the activity.</p>
			<h3>loopctl</h3>
			<p>One issue with <a id="_idIndexMarker276"/>requesting <a id="_idIndexMarker277"/>a large number of iterations of the <strong class="source-inline">Looper</strong> servlet is that you see no output until all of them are complete. In fact, most browsers, by default, will time out if the request takes an unreasonable amount of time to return. </p>
			<p>To address this, there is a command-line client to the Looper servlet known as <strong class="source-inline">loopctl</strong>, which calls the <strong class="source-inline">Looper</strong> servlet in a loop.</p>
			<p>You can tell it to run a specified number of iterations on a specified number of parallel threads. You saw the output of this command-line client earlier. To run it yourself, requesting 25 iterations on 4 parallel threads, the easiest approach is to go to the <strong class="bold">Terminal</strong> tab for the Looper pod in the OpenShift console and run <strong class="source-inline">./loopctl.sh 25 4</strong>, which would run 100 total iterations (temporarily creating portfolios named <strong class="source-inline">Looper1</strong>, <strong class="source-inline">Looper2</strong>, <strong class="source-inline">Looper3</strong>, and <strong class="source-inline">Looper4</strong>) and would output the average number of<a id="_idIndexMarker278"/> milliseconds <a id="_idIndexMarker279"/>per iteration.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor066"/>Summary</h1>
			<p>You should now have a feel for the cloud-native example that will be used throughout this book. Though it may appear a bit daunting at first, the mandatory parts are quite easy to set up (especially if you use the pre-built images in Docker Hub), so you can be up and running with the basics of the example in a matter of minutes. Then, you can add whichever of the optional bonus capabilities you'd like at your own pace.</p>
			<p>In the upcoming chapters, various MicroProfile technologies will be discussed in detail. Each will show snippets from particular microservices in this example. As you have seen, different microservices are meant to demonstrate different features of Jakarta EE and MicroProfile and provide a real running tutorial of how to integrate with various external services.</p>
			<p>In <a href="B17377_08_Final_SB_epub.xhtml#_idTextAnchor159"><em class="italic">Chapter 8</em></a>, <em class="italic">Building and Testing your Cloud-Native Application</em> we'll examine how these microservices were developed so that you can learn how to develop such microservices yourself. In <a href="B17377_09_Final_SB_epub.xhtml#_idTextAnchor173"><em class="italic">Chapter 9</em></a>, <em class="italic">Step-by-Step Stock Trader Development</em>, we'll cover the deployment of the example in detail, as well as <em class="italic">day 2</em> operations you can perform.</p>
			<p>In the next chapter, we will begin looking at each of the MicroProfile technologies themselves and see how they help Java developers create cloud-native applications that can run in, and deeply integrate with, an orchestrated, containerized environment in a public or private cloud.</p>
		</div>
	</body></html>